---
title: Explication des arborescences d’expressions
description: En savoir plus sur les arborescences d’expressions et leur utilité dans la conversion d’algorithmes pour une exécution externe et une inspection du code avant son exécution.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/14/2020
ms.locfileid: "73036991"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="e09b8-103">Explication des arborescences d’expressions</span><span class="sxs-lookup"><span data-stu-id="e09b8-103">Expression Trees Explained</span></span>

[<span data-ttu-id="e09b8-104">Précédent – Vue d’ensemble</span><span class="sxs-lookup"><span data-stu-id="e09b8-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="e09b8-105">Les arborescences d’expressions sont des structures de données qui définissent du code.</span><span class="sxs-lookup"><span data-stu-id="e09b8-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="e09b8-106">Elles sont basées sur les mêmes structures que celles utilisées par un compilateur pour analyser du code et générer la sortie compilée.</span><span class="sxs-lookup"><span data-stu-id="e09b8-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="e09b8-107">Lors de la lecture de ce didacticiel, vous remarquerez qu’il existe certaines similitudes entre les arborescences d’expressions et les types utilisés dans les API Roslyn pour générer des [Analyzers et CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="e09b8-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="e09b8-108">(Les analyseurs et les codeFixes sont des paquets NuGet qui effectuent une analyse statique sur le code et peuvent suggérer des correctifs potentiels pour un développeur.) Les concepts sont similaires, et le résultat final est une structure de données qui permet l’examen du code source d’une manière significative.</span><span class="sxs-lookup"><span data-stu-id="e09b8-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="e09b8-109">Toutefois, les arborescences d’expressions sont basées sur un ensemble de classes et d’API totalement différentdes API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="e09b8-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="e09b8-110">Examinons un exemple simple.</span><span class="sxs-lookup"><span data-stu-id="e09b8-110">Let's look at a simple example.</span></span>
<span data-ttu-id="e09b8-111">Voici une ligne de code :</span><span class="sxs-lookup"><span data-stu-id="e09b8-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="e09b8-112">Si vous analysez ceci comme une arborescence d’expressions, l’arborescence contient plusieurs nœuds.</span><span class="sxs-lookup"><span data-stu-id="e09b8-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="e09b8-113">Le nœud extérieur est une instruction de déclaration de variable avec attribution (`var sum = 1 + 2;`). Ce nœud extérieur contient plusieurs nœuds enfants : une déclaration de variable, un opérateur d’assignation et une expression qui représente la partie à droite du signe égal.</span><span class="sxs-lookup"><span data-stu-id="e09b8-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="e09b8-114">Cette expression est sous-divisée en expressions qui représentent l’opération d’addition et les opérandes gauche et droit de l’addition.</span><span class="sxs-lookup"><span data-stu-id="e09b8-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="e09b8-115">Penchons-nous un peu plus sur les expressions qui composent la partie à droite du signe égal.</span><span class="sxs-lookup"><span data-stu-id="e09b8-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="e09b8-116">L’expression est `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="e09b8-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="e09b8-117">Il s’agit d’une expression binaire.</span><span class="sxs-lookup"><span data-stu-id="e09b8-117">That's a binary expression.</span></span> <span data-ttu-id="e09b8-118">Plus spécifiquement, il s’agit d’une expression d’addition binaire.</span><span class="sxs-lookup"><span data-stu-id="e09b8-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="e09b8-119">Une expression d’addition binaire a deux enfants, représentant les nœuds gauche et droit de l’expression d’addition.</span><span class="sxs-lookup"><span data-stu-id="e09b8-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="e09b8-120">Ici, les deux nœuds sont des expressions constantes : l’opérande gauche est la valeur `1`, et l’opérande droit est la valeur `2`.</span><span class="sxs-lookup"><span data-stu-id="e09b8-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="e09b8-121">Visuellement, l’instruction entière est une arborescence. Vous pouvez partir du nœud racine et accéder à chaque nœud dans l’arborescence pour voir le code qui compose l’instruction :</span><span class="sxs-lookup"><span data-stu-id="e09b8-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="e09b8-122">Instruction de déclaration de variable avec attribution (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="e09b8-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="e09b8-123">Déclaration de type de variable implicite (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="e09b8-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="e09b8-124">Mot clé var implicite (`var`)</span><span class="sxs-lookup"><span data-stu-id="e09b8-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="e09b8-125">Déclaration de nom de variable (`sum`)</span><span class="sxs-lookup"><span data-stu-id="e09b8-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="e09b8-126">Opérateur d’assignation (`=`)</span><span class="sxs-lookup"><span data-stu-id="e09b8-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="e09b8-127">Expression d’addition binaire (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="e09b8-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="e09b8-128">Opérande gauche (`1`)</span><span class="sxs-lookup"><span data-stu-id="e09b8-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="e09b8-129">Opérateur d’addition (`+`)</span><span class="sxs-lookup"><span data-stu-id="e09b8-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="e09b8-130">Opérande droit (`2`)</span><span class="sxs-lookup"><span data-stu-id="e09b8-130">Right operand (`2`)</span></span>

<span data-ttu-id="e09b8-131">Cela peut sembler compliqué, mais c’est très puissant.</span><span class="sxs-lookup"><span data-stu-id="e09b8-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="e09b8-132">Suivant le même processus, vous pouvez décomposer des expressions beaucoup plus complexes.</span><span class="sxs-lookup"><span data-stu-id="e09b8-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="e09b8-133">Examinons cette expression :</span><span class="sxs-lookup"><span data-stu-id="e09b8-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="e09b8-134">L’expression ci-dessus est aussi une déclaration de variable avec une assignation.</span><span class="sxs-lookup"><span data-stu-id="e09b8-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="e09b8-135">La partie droite de l’assignation est une arborescence beaucoup plus complexe.</span><span class="sxs-lookup"><span data-stu-id="e09b8-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="e09b8-136">Je ne vais pas décomposer cette expression, mais réfléchissez à ce que pourraient être les différents nœuds.</span><span class="sxs-lookup"><span data-stu-id="e09b8-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="e09b8-137">Il y a des appels de méthode utilisant l’objet actif comme destinataire, un qui a un récepteur `this` explicite, un autre qui n’en a pas.</span><span class="sxs-lookup"><span data-stu-id="e09b8-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="e09b8-138">Il y a des appels de méthode utilisant d’autres objets récepteurs, et des arguments constants de différents types.</span><span class="sxs-lookup"><span data-stu-id="e09b8-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="e09b8-139">Pour finir, il y a un opérateur d’addition binaire.</span><span class="sxs-lookup"><span data-stu-id="e09b8-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="e09b8-140">En fonction du type de retour de `SecretSauceFunction()` ou `MoreSecretSauce()`, cet opérateur d’addition binaire peut être un appel de méthode à un opérateur d’addition substitué, résolu en un appel de méthode statique à l’opérateur d’addition binaire défini pour une classe.</span><span class="sxs-lookup"><span data-stu-id="e09b8-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="e09b8-141">Malgré cette complexité apparente, l’expression ci-dessus crée une arborescence qui peut être parcourue aussi facilement que le premier exemple.</span><span class="sxs-lookup"><span data-stu-id="e09b8-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="e09b8-142">Vous pouvez traverser les nœuds enfants successifs pour rechercher des nœuds terminaux dans l’expression.</span><span class="sxs-lookup"><span data-stu-id="e09b8-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="e09b8-143">Les nœuds parents ont des références à leurs enfants, et chaque nœud a une propriété qui décrit le genre de nœud dont il s’agit.</span><span class="sxs-lookup"><span data-stu-id="e09b8-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="e09b8-144">La structure d’une arborescence d’expressions est très cohérente.</span><span class="sxs-lookup"><span data-stu-id="e09b8-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="e09b8-145">Une fois que vous maîtrisez les principes de base, vous pouvez comprendre le code le plus complexe quand il est représenté sous forme d’arborescence d’expressions.</span><span class="sxs-lookup"><span data-stu-id="e09b8-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="e09b8-146">L’élégance dans la structure de données explique comment le compilateur C# peut analyser les programmes C# les plus complexes et créer une sortie appropriée à partir de ce code source complexe.</span><span class="sxs-lookup"><span data-stu-id="e09b8-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="e09b8-147">Une fois que vous vous serez familiarisé avec la structure des arborescences d’expressions, vous constaterez que les connaissances acquises vous permettront de travailler rapidement avec de nombreux scénarios avancés.</span><span class="sxs-lookup"><span data-stu-id="e09b8-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="e09b8-148">Les arborescences d’expressions offrent une puissance incroyable.</span><span class="sxs-lookup"><span data-stu-id="e09b8-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="e09b8-149">Outre la conversion d’algorithmes à exécuter dans d’autres environnements, vous pouvez utiliser des arborescences d’expressions pour simplifier l’écriture d’algorithmes qui inspectent du code avant de l’exécuter.</span><span class="sxs-lookup"><span data-stu-id="e09b8-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="e09b8-150">Vous pouvez écrire une méthode dont les arguments sont des expressions, puis examiner ces expressions avant d’exécuter le code.</span><span class="sxs-lookup"><span data-stu-id="e09b8-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="e09b8-151">L’arborescence d’expressions est une représentation complète du code : vous pouvez voir les valeurs de n’importe quelle sous-expression.</span><span class="sxs-lookup"><span data-stu-id="e09b8-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="e09b8-152">Vous pouvez voir les noms des méthodes et des propriétés.</span><span class="sxs-lookup"><span data-stu-id="e09b8-152">You can see method and property names.</span></span> <span data-ttu-id="e09b8-153">Vous pouvez voir la valeur de n’importe quelle expression constante.</span><span class="sxs-lookup"><span data-stu-id="e09b8-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="e09b8-154">Vous pouvez également convertir une arborescence d’expressions en délégué exécutable et exécuter le code.</span><span class="sxs-lookup"><span data-stu-id="e09b8-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="e09b8-155">Les API d’arborescences d’expressions vous permettent de créer des arborescences qui représentent presque n’importe quelle construction de code valide.</span><span class="sxs-lookup"><span data-stu-id="e09b8-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="e09b8-156">Toutefois, pour simplifier les choses au maximum, certains idiomes C# ne peuvent pas être créés dans une arborescence d’expressions.</span><span class="sxs-lookup"><span data-stu-id="e09b8-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="e09b8-157">C’est le cas des expressions asynchrones (utilisant les mots clés `async` et `await`).</span><span class="sxs-lookup"><span data-stu-id="e09b8-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="e09b8-158">Si vous avez besoin d’algorithmes asynchrones, vous devez manipuler directement les objets `Task` plutôt que de vous fier à la prise en charge du compilateur.</span><span class="sxs-lookup"><span data-stu-id="e09b8-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="e09b8-159">C’est aussi le cas pour la création des boucles.</span><span class="sxs-lookup"><span data-stu-id="e09b8-159">Another is in creating loops.</span></span> <span data-ttu-id="e09b8-160">En général, vous les créez à l’aide de boucles `for`, `foreach`, `while` ou `do`.</span><span class="sxs-lookup"><span data-stu-id="e09b8-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="e09b8-161">Comme vous le verrez [plus loin dans cette série](expression-trees-building.md), les API d’arborescences d’expressions prennent en charge une expression de boucle unique, avec des expressions `break` et `continue` qui contrôlent la répétition de la boucle.</span><span class="sxs-lookup"><span data-stu-id="e09b8-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="e09b8-162">La seule chose que vous ne pouvez pas faire est de modifier une arborescence d’expressions.</span><span class="sxs-lookup"><span data-stu-id="e09b8-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="e09b8-163">Les arborescences d’expressions sont des structures de données immuables.</span><span class="sxs-lookup"><span data-stu-id="e09b8-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="e09b8-164">Si vous souhaitez muter (changer) une expression de l’arborescence, vous devez créer une nouvelle arborescence qui est une copie de l’original, mais avec les modifications souhaitées.</span><span class="sxs-lookup"><span data-stu-id="e09b8-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="e09b8-165">Suivant – Types de frameworks prenant en charge les arborescences d’expressions</span><span class="sxs-lookup"><span data-stu-id="e09b8-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
