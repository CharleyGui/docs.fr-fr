---
title: Utiliser le modèle syntaxique du SDK .NET Compiler Platform
description: Cette présentation fournit des informations sur les types que vous utilisez pour comprendre et manipuler les nœuds de syntaxe.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: 87b79c3af4958299fcd966dcc4b04868f88675c7
ms.sourcegitcommit: fff146ba3fd1762c8c432d95c8b877825ae536fc
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/08/2020
ms.locfileid: "82975912"
---
# <a name="work-with-syntax"></a><span data-ttu-id="5eff4-103">Utiliser la syntaxe</span><span class="sxs-lookup"><span data-stu-id="5eff4-103">Work with syntax</span></span>

<span data-ttu-id="5eff4-104">Une **arborescence de syntaxe** est une structure de données de base qui est exposée par les API du compilateur.</span><span class="sxs-lookup"><span data-stu-id="5eff4-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="5eff4-105">Ces arborescences représentent la structure lexicale et syntaxique du code source.</span><span class="sxs-lookup"><span data-stu-id="5eff4-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="5eff4-106">Elles ont deux utilités principales :</span><span class="sxs-lookup"><span data-stu-id="5eff4-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="5eff4-107">Permettre aux outils (comme un IDE, des compléments, des outils d’analyse de code et des refactorisations) d’afficher et de traiter la structure syntaxique du code source dans le projet d’un utilisateur.</span><span class="sxs-lookup"><span data-stu-id="5eff4-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="5eff4-108">Pour activer les outils, tels que les refactorisations et un IDE, pour créer, modifier et réorganiser le code source de manière naturelle sans avoir à utiliser des modifications de texte direct.</span><span class="sxs-lookup"><span data-stu-id="5eff4-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having to use direct text edits.</span></span> <span data-ttu-id="5eff4-109">Par la création et la manipulation des arborescences, les outils peuvent facilement créer et réorganiser le code source.</span><span class="sxs-lookup"><span data-stu-id="5eff4-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="5eff4-110">Arborescences de syntaxe</span><span class="sxs-lookup"><span data-stu-id="5eff4-110">Syntax trees</span></span>

<span data-ttu-id="5eff4-111">Les arborescences de syntaxe sont la structure principale utilisée pour la compilation, l’analyse de code, la liaison, la refactorisation, les fonctionnalités de l’IDE et la génération de code.</span><span class="sxs-lookup"><span data-stu-id="5eff4-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="5eff4-112">Aucune partie du code source ne peut être comprise sans avoir au préalable été identifiée et classée dans l’un des nombreux éléments de langage structurel connus.</span><span class="sxs-lookup"><span data-stu-id="5eff4-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span>

<span data-ttu-id="5eff4-113">Les arborescences de syntaxe ont trois caractéristiques principales.</span><span class="sxs-lookup"><span data-stu-id="5eff4-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="5eff4-114">Leur première caractéristique est qu’elles stockent toutes les informations sources avec une haute fidélité.</span><span class="sxs-lookup"><span data-stu-id="5eff4-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="5eff4-115">Cela signifie que l’arborescence de syntaxe contient chaque information trouvée dans le texte source, chaque construction grammaticale, chaque jeton lexical et chaque élément situé entre eux, y compris les espaces blancs, les commentaires et les directives de préprocesseur.</span><span class="sxs-lookup"><span data-stu-id="5eff4-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="5eff4-116">Par exemple, chaque littéral mentionné dans la source est représenté exactement comme il a été tapé.</span><span class="sxs-lookup"><span data-stu-id="5eff4-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="5eff4-117">Les arborescences de syntaxe représentent également les erreurs dans le code source quand le programme est incomplet ou incorrect en affichant les jetons ignorés ou manquants dans l’arborescence de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5eff4-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>

<span data-ttu-id="5eff4-118">Cela amène à la deuxième caractéristique des arborescences de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5eff4-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="5eff4-119">Une arborescence de syntaxe obtenue de l’analyseur peut produire le texte exact à partir duquel elle a été analysée.</span><span class="sxs-lookup"><span data-stu-id="5eff4-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="5eff4-120">À partir de n’importe quel nœud de syntaxe, il est possible d’obtenir la représentation textuelle de la sous-arborescence ayant ce nœud pour racine.</span><span class="sxs-lookup"><span data-stu-id="5eff4-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="5eff4-121">Cela signifie que vous pouvez utiliser les arborescences de syntaxe pour créer et modifier le texte source.</span><span class="sxs-lookup"><span data-stu-id="5eff4-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="5eff4-122">La création d’une arborescence implique que vous avez créé le texte équivalent, et la modification d’une arborescence de syntaxe, en créant une autre arborescence à partir des modifications apportées à une arborescence existante, implique que vous avez modifié le texte.</span><span class="sxs-lookup"><span data-stu-id="5eff4-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span>

<span data-ttu-id="5eff4-123">La troisième caractéristique des arborescences de syntaxe est qu’elles sont immuables et thread-safe.</span><span class="sxs-lookup"><span data-stu-id="5eff4-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="5eff4-124">Autrement dit, une fois qu’une arborescence a été obtenue, elle est un instantané de l’état actuel du code et elle ne peut plus être changée.</span><span class="sxs-lookup"><span data-stu-id="5eff4-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="5eff4-125">Cela permet à plusieurs utilisateurs d’interagir simultanément avec la même arborescence de syntaxe dans différents threads sans verrouillage ou duplication.</span><span class="sxs-lookup"><span data-stu-id="5eff4-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="5eff4-126">Étant donné que les arborescences sont immuables et qu’elles ne peuvent pas être modifiées directement, les méthodes de fabrique facilitent la création et la modification des arborescences de syntaxe en créant des instantanés supplémentaires de l’arborescence.</span><span class="sxs-lookup"><span data-stu-id="5eff4-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="5eff4-127">Les arborescences réutilisent avantageusement les nœuds sous-jacents pour accélérer la génération d’une nouvelle version, sans consommer beaucoup plus de mémoire.</span><span class="sxs-lookup"><span data-stu-id="5eff4-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="5eff4-128">Une arborescence de syntaxe est littéralement une structure de données arborescente, où des éléments structurels non terminaux sont parents d’autres éléments.</span><span class="sxs-lookup"><span data-stu-id="5eff4-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="5eff4-129">Chaque arborescence de syntaxe est constituée de nœuds, de jetons et de trivia.</span><span class="sxs-lookup"><span data-stu-id="5eff4-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>

## <a name="syntax-nodes"></a><span data-ttu-id="5eff4-130">Nœuds de syntaxe</span><span class="sxs-lookup"><span data-stu-id="5eff4-130">Syntax nodes</span></span>

<span data-ttu-id="5eff4-131">Les nœuds de syntaxe figurent parmi les principaux éléments des arborescences de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5eff4-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="5eff4-132">Ces nœuds représentent des constructions syntaxiques, telles que des déclarations, des instructions, des clauses et des expressions.</span><span class="sxs-lookup"><span data-stu-id="5eff4-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="5eff4-133">Chaque catégorie de nœuds de syntaxe est représentée par une classe distincte dérivée de <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5eff4-134">L’ensemble de classes de nœud n’est pas extensible.</span><span class="sxs-lookup"><span data-stu-id="5eff4-134">The set of node classes is not extensible.</span></span>

<span data-ttu-id="5eff4-135">Tous les nœuds de syntaxe sont des nœuds non terminaux dans l’arborescence de syntaxe ; ils ont donc toujours d’autres nœuds et jetons comme enfants.</span><span class="sxs-lookup"><span data-stu-id="5eff4-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="5eff4-136">Chaque nœud enfant d’un autre nœud a un nœud parent qui est accessible via la propriété <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5eff4-137">Comme les nœuds et les arborescences sont immuables, le parent d’un nœud ne change jamais.</span><span class="sxs-lookup"><span data-stu-id="5eff4-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="5eff4-138">La racine de l’arborescence a un parent Null.</span><span class="sxs-lookup"><span data-stu-id="5eff4-138">The root of the tree has a null parent.</span></span>

<span data-ttu-id="5eff4-139">Chaque nœud a une méthode <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType>, qui retourne une liste des nœuds enfants dans l’ordre séquentiel déterminé par leur position dans le texte source.</span><span class="sxs-lookup"><span data-stu-id="5eff4-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="5eff4-140">Cette liste ne contient pas de jetons.</span><span class="sxs-lookup"><span data-stu-id="5eff4-140">This list does not contain tokens.</span></span> <span data-ttu-id="5eff4-141">Chaque nœud a également des méthodes pour examiner les descendants, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>tels <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>que, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> ou, qui représentent une liste de tous les nœuds, jetons ou anecdotes qui existent dans la sous-arborescence enracinée par ce nœud.</span><span class="sxs-lookup"><span data-stu-id="5eff4-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia that exist in the sub-tree rooted by that node.</span></span>

<span data-ttu-id="5eff4-142">En outre, chaque sous-classe de nœud de syntaxe expose les mêmes enfants par le biais de propriétés fortement typées.</span><span class="sxs-lookup"><span data-stu-id="5eff4-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="5eff4-143">Par exemple, une classe de nœud <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> a trois propriétés supplémentaires propres aux opérateurs binaires : <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> et <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="5eff4-144">Le type de <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> et <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> est <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, et le type de <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> est <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="5eff4-145">Certains nœuds de syntaxe ont des enfants facultatifs.</span><span class="sxs-lookup"><span data-stu-id="5eff4-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="5eff4-146">Par exemple, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> a un <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax> facultatif.</span><span class="sxs-lookup"><span data-stu-id="5eff4-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="5eff4-147">Si l’enfant n’est pas trouvé, la propriété retourne la valeur Null.</span><span class="sxs-lookup"><span data-stu-id="5eff4-147">If the child is not present, the property returns null.</span></span>

## <a name="syntax-tokens"></a><span data-ttu-id="5eff4-148">Jetons de syntaxe</span><span class="sxs-lookup"><span data-stu-id="5eff4-148">Syntax tokens</span></span>

<span data-ttu-id="5eff4-149">Les jetons de syntaxe sont les éléments terminaux dans la grammaire d’un langage ; ils représentent les plus petits fragments syntaxiques du code.</span><span class="sxs-lookup"><span data-stu-id="5eff4-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="5eff4-150">Ils ne sont jamais parents d’autres nœuds ou jetons.</span><span class="sxs-lookup"><span data-stu-id="5eff4-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="5eff4-151">Les jetons de syntaxe se composent de mots clés, d’identificateurs, de littéraux et de caractères de ponctuation.</span><span class="sxs-lookup"><span data-stu-id="5eff4-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span>

<span data-ttu-id="5eff4-152">Par souci d’efficacité, le type <xref:Microsoft.CodeAnalysis.SyntaxToken> est un type valeur CLR.</span><span class="sxs-lookup"><span data-stu-id="5eff4-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="5eff4-153">Par conséquent, contrairement aux nœuds de syntaxe, il n’y a qu’une seule structure pour tous les genres de jetons, avec une combinaison de propriétés dont le sens dépend du genre du jeton représenté.</span><span class="sxs-lookup"><span data-stu-id="5eff4-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="5eff4-154">Par exemple, un jeton de littéral d’entier représente une valeur numérique.</span><span class="sxs-lookup"><span data-stu-id="5eff4-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="5eff4-155">En plus du texte source brut sur lequel s’étend le jeton, le jeton de littéral a une propriété <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> qui indique précisément la valeur entière décodée.</span><span class="sxs-lookup"><span data-stu-id="5eff4-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="5eff4-156">Cette propriété est typée en <xref:System.Object>, car elle peut être l’un des nombreux types primitifs.</span><span class="sxs-lookup"><span data-stu-id="5eff4-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="5eff4-157">La propriété <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> fournit les mêmes informations que la propriété <xref:Microsoft.CodeAnalysis.SyntaxToken.Value>, mais elle est toujours typée en <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="5eff4-158">Dans du texte source C#, un identificateur peut inclure des caractères d’échappement Unicode, mais la syntaxe de la séquence d’échappement n’est pas considérée comme faisant partie du nom de l’identificateur.</span><span class="sxs-lookup"><span data-stu-id="5eff4-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="5eff4-159">Même si le texte brut sur lequel s’étend le jeton inclut la séquence d’échappement, la propriété <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> ne l’inclut pas.</span><span class="sxs-lookup"><span data-stu-id="5eff4-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="5eff4-160">À la place, elle inclut les caractères Unicode identifiés par la séquence d’échappement.</span><span class="sxs-lookup"><span data-stu-id="5eff4-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="5eff4-161">Par exemple, si le texte source contient un identificateur écrit sous la forme `\u03C0`, la propriété <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> pour ce jeton retourne `π`.</span><span class="sxs-lookup"><span data-stu-id="5eff4-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="5eff4-162">Trivia de syntaxe</span><span class="sxs-lookup"><span data-stu-id="5eff4-162">Syntax trivia</span></span>

<span data-ttu-id="5eff4-163">Les trivia de syntaxe représentent les parties du texte source qui n’ont pas une grande utilité pour la compréhension générale du code. Il s’agit notamment des espaces blancs, des commentaires et des directives de préprocesseur.</span><span class="sxs-lookup"><span data-stu-id="5eff4-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="5eff4-164">Comme les jetons de syntaxe, les trivia sont des types valeur.</span><span class="sxs-lookup"><span data-stu-id="5eff4-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="5eff4-165">Le type <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> unique est utilisé pour décrire tous les genres de trivia.</span><span class="sxs-lookup"><span data-stu-id="5eff4-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="5eff4-166">Du fait que les trivia ne font pas partie de la syntaxe du langage à proprement parler et qu’ils peuvent se trouver n’importe où entre deux jetons, ils ne sont pas représentés dans l’arborescence de syntaxe comme enfants d’un nœud.</span><span class="sxs-lookup"><span data-stu-id="5eff4-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="5eff4-167">Les trivia sont toutefois inclus dans l’arborescence de syntaxe, car ils sont importants lors de l’implémentation d’une fonctionnalité telle que la refactorisation, mais aussi pour garantir une haute fidélité avec le texte source.</span><span class="sxs-lookup"><span data-stu-id="5eff4-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="5eff4-168">Vous pouvez accéder aux trivia en inspectant les collections <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> ou <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> d’un jeton.</span><span class="sxs-lookup"><span data-stu-id="5eff4-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="5eff4-169">Quand le texte source est analysé, les séquences de trivia sont associées aux jetons.</span><span class="sxs-lookup"><span data-stu-id="5eff4-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="5eff4-170">En règle générale, un jeton est propriétaire de tous les trivia qui se trouvent après lui sur la même ligne.</span><span class="sxs-lookup"><span data-stu-id="5eff4-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="5eff4-171">Les trivia situés après cette ligne dépendent du jeton suivant.</span><span class="sxs-lookup"><span data-stu-id="5eff4-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="5eff4-172">Dans le fichier source, le premier jeton obtient tous les trivia initiaux, et la dernière séquence de trivia est associée au jeton de fin de fichier, qui a sinon une largeur égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="5eff4-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="5eff4-173">Contrairement aux nœuds et jetons de syntaxe, les trivia de syntaxe n’ont pas de parents.</span><span class="sxs-lookup"><span data-stu-id="5eff4-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="5eff4-174">Toutefois, comme les trivia font partie de l’arborescence et que chacun d’eux est associé à un jeton unique, vous pouvez accéder au jeton correspondant à l’aide de la propriété <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="5eff4-175">Étendues</span><span class="sxs-lookup"><span data-stu-id="5eff4-175">Spans</span></span>

<span data-ttu-id="5eff4-176">Chaque nœud, jeton ou trivia connaît sa position dans le texte source et le nombre de caractères qui le composent.</span><span class="sxs-lookup"><span data-stu-id="5eff4-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="5eff4-177">La position du texte est représentée par un entier 32 bits, qui est un index `char` de base zéro.</span><span class="sxs-lookup"><span data-stu-id="5eff4-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="5eff4-178">L’objet <xref:Microsoft.CodeAnalysis.Text.TextSpan> représente la position de début et le nombre de caractères sous forme de deux entiers.</span><span class="sxs-lookup"><span data-stu-id="5eff4-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="5eff4-179">Si <xref:Microsoft.CodeAnalysis.Text.TextSpan> a une longueur nulle, il fait référence à une position entre deux caractères.</span><span class="sxs-lookup"><span data-stu-id="5eff4-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="5eff4-180">Chaque nœud a deux propriétés <xref:Microsoft.CodeAnalysis.Text.TextSpan> : <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> et <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span></span>

<span data-ttu-id="5eff4-181">La propriété <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> définit l’étendue de texte comprise entre le début du premier jeton dans la sous-arborescence du nœud et la fin du dernier jeton.</span><span class="sxs-lookup"><span data-stu-id="5eff4-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="5eff4-182">Cette étendue n’inclut pas les trivia de début ou de fin.</span><span class="sxs-lookup"><span data-stu-id="5eff4-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="5eff4-183">La propriété <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> définit l’étendue de texte qui inclut l’étendue du nœud, plus l’étendue des trivia de début ou de fin.</span><span class="sxs-lookup"><span data-stu-id="5eff4-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="5eff4-184">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="5eff4-184">For example:</span></span>

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="5eff4-185">L’étendue du nœud de l’instruction dans le bloc est délimitée par deux barres verticales simples (|).</span><span class="sxs-lookup"><span data-stu-id="5eff4-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="5eff4-186">Elle inclut les caractères `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="5eff4-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="5eff4-187">L’étendue complète est délimitée par les deux barres verticales doubles (||).</span><span class="sxs-lookup"><span data-stu-id="5eff4-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="5eff4-188">Elle inclut les mêmes caractères que l’étendue du nœud, plus les caractères associés aux trivia de début et de fin.</span><span class="sxs-lookup"><span data-stu-id="5eff4-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="5eff4-189">Genres</span><span class="sxs-lookup"><span data-stu-id="5eff4-189">Kinds</span></span>

<span data-ttu-id="5eff4-190">Chaque nœud, jeton ou trivia a une propriété <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> de type <xref:System.Int32?displayProperty=nameWithType>, qui identifie précisément l’élément de syntaxe représenté.</span><span class="sxs-lookup"><span data-stu-id="5eff4-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="5eff4-191">Cette valeur peut être convertie en une énumération spécifique au langage.</span><span class="sxs-lookup"><span data-stu-id="5eff4-191">This value can be cast to a language-specific enumeration.</span></span> <span data-ttu-id="5eff4-192">Chaque langage, C# ou Visual Basic, possède une énumération `SyntaxKind` unique<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> ( <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>et, respectivement) qui répertorie tous les nœuds, jetons et éléments de anecdotes possibles dans la grammaire.</span><span class="sxs-lookup"><span data-stu-id="5eff4-192">Each language, C# or Visual Basic, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="5eff4-193">Cette conversion peut être effectuée automatiquement en accédant aux méthodes d’extension <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> ou <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-193">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="5eff4-194">La propriété <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> permet de lever facilement toute ambiguïté sur les types de nœud de syntaxe qui utilisent la même classe de nœud.</span><span class="sxs-lookup"><span data-stu-id="5eff4-194">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="5eff4-195">Pour les jetons et les trivia, cette propriété est le seul moyen de différencier les types d’élément entre eux.</span><span class="sxs-lookup"><span data-stu-id="5eff4-195">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span>

<span data-ttu-id="5eff4-196">Prenons l’exemple d’une classe <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax>, qui a les enfants <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> et <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-196">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="5eff4-197">La propriété <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> détermine si le nœud de syntaxe est du genre <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression> ou <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-197">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="5eff4-198">Erreurs</span><span class="sxs-lookup"><span data-stu-id="5eff4-198">Errors</span></span>

<span data-ttu-id="5eff4-199">Même si le texte source contient des erreurs de syntaxe, une arborescence de syntaxe complète avec aller-retour au code source est exposée.</span><span class="sxs-lookup"><span data-stu-id="5eff4-199">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="5eff4-200">Quand l’analyseur rencontre du code qui n’est pas conforme à la syntaxe définie pour le langage, il crée une arborescence de syntaxe à l’aide d’une des deux techniques suivantes.</span><span class="sxs-lookup"><span data-stu-id="5eff4-200">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="5eff4-201">Avec la première technique, quand l’analyseur ne trouve pas le genre de jeton attendu, il insère un jeton manquant dans l’arborescence de syntaxe, à l’emplacement où le jeton était attendu.</span><span class="sxs-lookup"><span data-stu-id="5eff4-201">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="5eff4-202">Un jeton manquant représente le jeton qui était attendu, mais du fait qu’il a une étendue vide, sa propriété <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="5eff4-202">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="5eff4-203">Avec la deuxième technique, l’analyseur ignore les jetons jusqu’à ce qu’il en trouve un à partir duquel il peut poursuivre l’analyse.</span><span class="sxs-lookup"><span data-stu-id="5eff4-203">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="5eff4-204">Dans ce cas, les jetons ignorés sont attachés en tant que nœud de trivia avec le genre <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="5eff4-204">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
