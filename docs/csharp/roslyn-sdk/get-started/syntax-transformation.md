---
title: Bien démarrer avec la transformation de la syntaxe (API Roslyn)
description: Une introduction à la façon de parcourir et d’interroger les arborescences de syntaxe.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 232fe5fcba35f152dbc3f00b2f2c092b5df0dd35
ms.sourcegitcommit: de7f589de07a9979b6ac28f54c3e534a617d9425
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/05/2020
ms.locfileid: "82794791"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="18a9e-103">Bien démarrer avec la transformation de la syntaxe</span><span class="sxs-lookup"><span data-stu-id="18a9e-103">Get started with syntax transformation</span></span>

<span data-ttu-id="18a9e-104">Ce tutoriel s’appuie sur les concepts et techniques décrits dans les démarrages rapides [Bien démarrer avec l’analyse de la syntaxe](syntax-analysis.md) et [Bien démarrer avec l’analyse sémantique](semantic-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="18a9e-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="18a9e-105">Si vous ne l’avez pas déjà fait, vous devez terminer ces démarrages rapides avant de commencer celui-ci.</span><span class="sxs-lookup"><span data-stu-id="18a9e-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="18a9e-106">Dans ce démarrage rapide, vous découvrez les techniques de création et de transformation des arborescences de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="18a9e-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="18a9e-107">En association avec les techniques que vous avez apprises dans les démarrages rapides précédents, vous créez votre première refactorisation de ligne de commande !</span><span class="sxs-lookup"><span data-stu-id="18a9e-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="18a9e-108">Immuabilité et plateforme de compilateur .NET</span><span class="sxs-lookup"><span data-stu-id="18a9e-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="18a9e-109">L’**immuabilité** est un principe fondamental de la plateforme de compilateur .NET.</span><span class="sxs-lookup"><span data-stu-id="18a9e-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="18a9e-110">Une fois créées, les structures de données immuables ne peuvent plus être modifiées.</span><span class="sxs-lookup"><span data-stu-id="18a9e-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="18a9e-111">Les structures de données immuables peuvent être partagées et analysées simultanément par plusieurs consommateurs, en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="18a9e-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="18a9e-112">Il n’existe aucun risque qu’un consommateur n’en perturbe un autre de manière imprévisible.</span><span class="sxs-lookup"><span data-stu-id="18a9e-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="18a9e-113">Votre analyseur n’a pas besoin de verrous ou d’autres mesures de concurrence.</span><span class="sxs-lookup"><span data-stu-id="18a9e-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="18a9e-114">Cette règle s’applique aux arborescences de syntaxe, compilations, symboles, modèles sémantiques et toute autre structure de données que vous rencontrez.</span><span class="sxs-lookup"><span data-stu-id="18a9e-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="18a9e-115">Au lieu de modifier des structures existantes, les API créent de nouveaux objets en fonction des différences spécifiés dans les anciens objets.</span><span class="sxs-lookup"><span data-stu-id="18a9e-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="18a9e-116">Vous appliquez ce concept aux arborescences de syntaxe pour créer de nouvelles arborescences à l’aide de transformations.</span><span class="sxs-lookup"><span data-stu-id="18a9e-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="18a9e-117">Créer et transformer des arborescences</span><span class="sxs-lookup"><span data-stu-id="18a9e-117">Create and transform trees</span></span>

<span data-ttu-id="18a9e-118">Vous choisissez une des deux stratégies pour les transformations de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="18a9e-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="18a9e-119">Les **méthodes de fabrique** sont particulièrement utiles lorsque vous recherchez des nœuds spécifiques à remplacer, ou des emplacements spécifiques dans lesquelles vous souhaitez insérer le nouveau code.</span><span class="sxs-lookup"><span data-stu-id="18a9e-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="18a9e-120">Les **modules de réécriture** sont recommandés lorsque vous souhaitez analyser un projet complet et y rechercher des modèles de code à remplacer.</span><span class="sxs-lookup"><span data-stu-id="18a9e-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="18a9e-121">Créer des nœuds avec des méthodes de fabrique</span><span class="sxs-lookup"><span data-stu-id="18a9e-121">Create nodes with factory methods</span></span>

<span data-ttu-id="18a9e-122">La première transformation de syntaxe montre les méthodes de fabrique.</span><span class="sxs-lookup"><span data-stu-id="18a9e-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="18a9e-123">Vous allez remplacer une instruction `using System.Collections;` par une instruction `using System.Collections.Generic;`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="18a9e-124">Cet exemple montre comment créer des objets <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> à l’aide des méthodes de fabrique <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="18a9e-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="18a9e-125">Pour chaque type de **nœud**, **jeton** ou **trivia**, il existe une méthode de fabrique qui crée une instance de ce type.</span><span class="sxs-lookup"><span data-stu-id="18a9e-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="18a9e-126">Vous créez des arborescences de syntaxe en composant hiérarchiquement des nœuds de façon ascendante.</span><span class="sxs-lookup"><span data-stu-id="18a9e-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="18a9e-127">Puis vous transformez le programme existant en remplaçant les nœuds existants par la nouvelle arborescence que vous avez créée.</span><span class="sxs-lookup"><span data-stu-id="18a9e-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="18a9e-128">Démarrez Visual Studio, puis créez un nouveau projet C# **Outil d’analyse du code autonome**.</span><span class="sxs-lookup"><span data-stu-id="18a9e-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="18a9e-129">Dans Visual Studio, choisissez **fichier** > **nouveau** > **projet** pour afficher la boîte de dialogue Nouveau projet.</span><span class="sxs-lookup"><span data-stu-id="18a9e-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="18a9e-130">Sous**extensibilité** **Visual C#** > , choisissez un **outil d’analyse du code autonome**.</span><span class="sxs-lookup"><span data-stu-id="18a9e-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="18a9e-131">Ce démarrage rapide inclut deux exemples de projets, par conséquent, nommez la solution **SyntaxTransformationQuickStart**, puis nommez le projet **ConstructionCS**.</span><span class="sxs-lookup"><span data-stu-id="18a9e-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="18a9e-132">Cliquez sur **OK**.</span><span class="sxs-lookup"><span data-stu-id="18a9e-132">Click **OK**.</span></span>

<span data-ttu-id="18a9e-133">Ce projet utilise les méthodes de classe <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> pour construire un élément <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> représentant l’espace de noms `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="18a9e-134">Ajoutez la directive using suivante en haut du fichier `Program.cs` pour importer les méthodes de fabrique de la classe <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> et les méthodes de <xref:System.Console> afin de les utiliser ultérieurement sans les qualifier :</span><span class="sxs-lookup"><span data-stu-id="18a9e-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="18a9e-135">Vous allez créer des **nœuds de syntaxe du nom** pour générer l’arborescence qui représente l’instruction `using System.Collections.Generic;`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="18a9e-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> est la classe de base pour les quatre types de noms qui s’affichent en C#.</span><span class="sxs-lookup"><span data-stu-id="18a9e-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="18a9e-137">Vous composez ces quatre types de noms à la fois pour créer n’importe quel nom pouvant s’afficher en langage C# :</span><span class="sxs-lookup"><span data-stu-id="18a9e-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="18a9e-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, qui représente des noms d’identificateur unique simples comme `System` et `Microsoft`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="18a9e-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, qui représente un nom de type ou de méthode générique comme `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="18a9e-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, qui représente un nom qualifié de formulaire `<left-name>.<right-identifier-or-generic-name>` comme `System.IO`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="18a9e-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, qui représente un nom en utilisant un alias d’assembly externe comme `LibraryV2::Foo`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="18a9e-142">Vous utilisez la méthode <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> pour créer un nœud <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="18a9e-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="18a9e-143">Ajoutez le code suivant à votre méthode `Main`, dans `Program.cs` :</span><span class="sxs-lookup"><span data-stu-id="18a9e-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="18a9e-144">Le code précédent crée un objet <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> et l’assigne à la variable `name`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="18a9e-145">La plupart des API Roslyn renvoient des classes de base pour les rendre plus faciles à utiliser avec les types associés.</span><span class="sxs-lookup"><span data-stu-id="18a9e-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="18a9e-146">La variable `name`, une <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, peut être réutilisée lorsque vous générez la <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="18a9e-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="18a9e-147">N’utilisez pas l’inférence de type lorsque vous générez l’exemple.</span><span class="sxs-lookup"><span data-stu-id="18a9e-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="18a9e-148">Vous allez automatiser cette étape dans ce projet.</span><span class="sxs-lookup"><span data-stu-id="18a9e-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="18a9e-149">Vous avez créé le nom.</span><span class="sxs-lookup"><span data-stu-id="18a9e-149">You've created the name.</span></span> <span data-ttu-id="18a9e-150">Maintenant, il est temps de créer d’autres nœuds dans l’arborescence en générant une <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="18a9e-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="18a9e-151">La nouvelle arborescence utilise `name` comme partie gauche du nom et une nouvelle <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> pour l’espace de noms `Collections` comme partie droite de la <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="18a9e-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="18a9e-152">Ajoutez le code suivant à `program.cs` :</span><span class="sxs-lookup"><span data-stu-id="18a9e-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="18a9e-153">Exécutez à nouveau le code et affichez les résultats.</span><span class="sxs-lookup"><span data-stu-id="18a9e-153">Run the code again, and see the results.</span></span> <span data-ttu-id="18a9e-154">Vous créez une arborescence de nœuds qui représente le code.</span><span class="sxs-lookup"><span data-stu-id="18a9e-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="18a9e-155">Vous allez continuer à utiliser ce modèle pour générer la <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> pour l’espace de noms `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="18a9e-156">Ajoutez le code suivant à `Program.cs` :</span><span class="sxs-lookup"><span data-stu-id="18a9e-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="18a9e-157">Réexécutez le programme pour voir que vous avez créé l’arborescence pour le code à ajouter.</span><span class="sxs-lookup"><span data-stu-id="18a9e-157">Run the program again to see that you've built the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="18a9e-158">Créer une arborescence modifiée</span><span class="sxs-lookup"><span data-stu-id="18a9e-158">Create a modified tree</span></span>

<span data-ttu-id="18a9e-159">Vous avez créé petite arborescence de syntaxe contenant une instruction.</span><span class="sxs-lookup"><span data-stu-id="18a9e-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="18a9e-160">Les API permettant de créer de nouveaux nœuds représentent la solution idéale pour créer des instructions uniques ou d’autres petits blocs de code.</span><span class="sxs-lookup"><span data-stu-id="18a9e-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="18a9e-161">Toutefois, pour générer de plus grands blocs de code, vous devez utiliser des méthodes qui remplacent les nœuds ou insèrent des nœuds dans une arborescence existante.</span><span class="sxs-lookup"><span data-stu-id="18a9e-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="18a9e-162">N’oubliez pas que les arborescences de syntaxe sont immuables.</span><span class="sxs-lookup"><span data-stu-id="18a9e-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="18a9e-163">L’**API Syntaxe** ne fournit aucun mécanisme permettant de modifier une arborescence de syntaxe existante après la construction.</span><span class="sxs-lookup"><span data-stu-id="18a9e-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="18a9e-164">Au lieu de cela, elle fournit des méthodes qui génèrent de nouvelles arborescences en fonction des modifications apportées aux arborescences existantes.</span><span class="sxs-lookup"><span data-stu-id="18a9e-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="18a9e-165">Les méthodes `With*` sont définies dans des classes concrètes qui dérivent de <xref:Microsoft.CodeAnalysis.SyntaxNode> ou dans des méthodes d’extension déclarées dans la classe <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions>.</span><span class="sxs-lookup"><span data-stu-id="18a9e-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="18a9e-166">Ces méthodes créent un nouveau nœud en appliquant les modifications apportées aux propriétés enfants d’un nœud existant.</span><span class="sxs-lookup"><span data-stu-id="18a9e-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="18a9e-167">En outre, la méthode d’extension <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> peut être utilisée pour remplacer un nœud descendant dans une sous-arborescence.</span><span class="sxs-lookup"><span data-stu-id="18a9e-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="18a9e-168">Cette méthode met également à jour le parent pour pointer vers l’enfant qui vient d’être créé, et répète ce processus pour l’arborescence complète. Ce processus est appelé « _re-spining_ » d’arborescence.</span><span class="sxs-lookup"><span data-stu-id="18a9e-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spinning_ the tree.</span></span>

<span data-ttu-id="18a9e-169">L’étape suivante consiste à créer une arborescence qui représente un (petit) programme complet puis à le modifier.</span><span class="sxs-lookup"><span data-stu-id="18a9e-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="18a9e-170">Ajoutez le code suivant au début de la classe `Program` :</span><span class="sxs-lookup"><span data-stu-id="18a9e-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="18a9e-171">L’exemple de code utilise l’espace de noms `System.Collections` et non pas l’espace de noms `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="18a9e-172">Ensuite, ajoutez le code suivant en bas de la méthode `Main` pour analyser le texte et créer une arborescence :</span><span class="sxs-lookup"><span data-stu-id="18a9e-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="18a9e-173">Cet exemple utilise la méthode <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> pour remplacer le nom dans un nœud <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> par celui construit dans le code précédent.</span><span class="sxs-lookup"><span data-stu-id="18a9e-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="18a9e-174">Créez un nouveau nœud <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> à l’aide de la méthode <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> pour mettre à jour le nom `System.Collections` avec le nom que vous avez créé dans le code précédent.</span><span class="sxs-lookup"><span data-stu-id="18a9e-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="18a9e-175">Ajoutez le code suivant dans le bas de la méthode `Main` :</span><span class="sxs-lookup"><span data-stu-id="18a9e-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="18a9e-176">Exécutez le programme et examinez attentivement la sortie.</span><span class="sxs-lookup"><span data-stu-id="18a9e-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="18a9e-177">`newusing` n’a pas été placé dans l’arborescence racine.</span><span class="sxs-lookup"><span data-stu-id="18a9e-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="18a9e-178">L’arborescence d’origine n’a pas été modifiée.</span><span class="sxs-lookup"><span data-stu-id="18a9e-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="18a9e-179">Ajoutez le code suivant à l’aide de la méthode d'extension <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> pour créer une nouvelle arborescence.</span><span class="sxs-lookup"><span data-stu-id="18a9e-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="18a9e-180">La nouvelle arborescence est le résultat du remplacement de l’importation existante par le nœud `newUsing` mis à jour.</span><span class="sxs-lookup"><span data-stu-id="18a9e-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="18a9e-181">Vous affectez cette nouvelle arborescence à la variable `root` existante :</span><span class="sxs-lookup"><span data-stu-id="18a9e-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="18a9e-182">Réexécutez le programme.</span><span class="sxs-lookup"><span data-stu-id="18a9e-182">Run the program again.</span></span> <span data-ttu-id="18a9e-183">Cette fois, l’arborescence importe correctement l’espace de noms `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="18a9e-184">Transformer des arborescences avec `SyntaxRewriters`</span><span class="sxs-lookup"><span data-stu-id="18a9e-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="18a9e-185">Les méthodes `With*` et <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> constituent une solution pratique pour transformer des branches individuelles en une arborescence de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="18a9e-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="18a9e-186">La classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> effectue plusieurs transformations sur une arborescence de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="18a9e-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="18a9e-187">La classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> est une sous-classe de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="18a9e-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="18a9e-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applique une transformation à un type spécifique de <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span><span class="sxs-lookup"><span data-stu-id="18a9e-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="18a9e-189">Vous pouvez appliquer des transformations à plusieurs types d’objets <xref:Microsoft.CodeAnalysis.SyntaxNode> là où elles apparaissent dans une arborescence de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="18a9e-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="18a9e-190">Le second projet de ce démarrage rapide crée une refactorisation de ligne de commande qui supprime des types explicites dans des déclarations de variables locales partout où une inférence de type peut être utilisée.</span><span class="sxs-lookup"><span data-stu-id="18a9e-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="18a9e-191">Créez un nouveau projet C# d' **outil d’analyse du code** autonome.</span><span class="sxs-lookup"><span data-stu-id="18a9e-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="18a9e-192">Dans Visual Studio, cliquez avec le bouton droit sur le nœud de la solution `SyntaxTransformationQuickStart`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="18a9e-193">Choisissez **Ajouter** > **un nouveau projet** pour afficher la **boîte de dialogue Nouveau projet**.</span><span class="sxs-lookup"><span data-stu-id="18a9e-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="18a9e-194">Sous**extensibilité** **Visual C#** > , choisissez **outil d’analyse du code autonome**.</span><span class="sxs-lookup"><span data-stu-id="18a9e-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="18a9e-195">Nommez votre projet `TransformationCS`, puis cliquez sur OK.</span><span class="sxs-lookup"><span data-stu-id="18a9e-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="18a9e-196">La première étape consiste à créer une classe dérivée de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> pour effectuer vos transformations.</span><span class="sxs-lookup"><span data-stu-id="18a9e-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="18a9e-197">Ajoutez un nouveau fichier de classe au projet.</span><span class="sxs-lookup"><span data-stu-id="18a9e-197">Add a new class file to the project.</span></span> <span data-ttu-id="18a9e-198">Dans Visual Studio, choisissez **projet** > **Ajouter une classe...**. Dans la boîte de dialogue **Ajouter un nouvel élément** , tapez `TypeInferenceRewriter.cs` comme nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="18a9e-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="18a9e-199">Ajoutez le code suivant à l’aide de directives dans le fichier `TypeInferenceRewriter.cs` :</span><span class="sxs-lookup"><span data-stu-id="18a9e-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="18a9e-200">Ensuite, étendez la classe `TypeInferenceRewriter` à la classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> :</span><span class="sxs-lookup"><span data-stu-id="18a9e-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="18a9e-201">Ajoutez le code suivant pour déclarer un champ en lecture seule privé qui contiendra une <xref:Microsoft.CodeAnalysis.SemanticModel> et initialisez-le dans le constructeur.</span><span class="sxs-lookup"><span data-stu-id="18a9e-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="18a9e-202">Vous aurez besoin de ce champ ultérieurement pour déterminer où l’inférence de type peut être utilisée :</span><span class="sxs-lookup"><span data-stu-id="18a9e-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="18a9e-203">Remplacez la méthode <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> :</span><span class="sxs-lookup"><span data-stu-id="18a9e-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```csharp
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="18a9e-204">De nombreuses API Roslyn déclarent des types de retour représentant des classes de base des types Runtime réels retournés.</span><span class="sxs-lookup"><span data-stu-id="18a9e-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="18a9e-205">Dans de nombreux scénarios, il est possible de remplacer un type de nœud par un autre, voire de le supprimer.</span><span class="sxs-lookup"><span data-stu-id="18a9e-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="18a9e-206">Dans cet exemple, la méthode <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> retourne un <xref:Microsoft.CodeAnalysis.SyntaxNode>, au lieu du type dérivé de <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span><span class="sxs-lookup"><span data-stu-id="18a9e-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="18a9e-207">Ce module de réécriture retourne un nouveau nœud <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> en fonction du nœud existant.</span><span class="sxs-lookup"><span data-stu-id="18a9e-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="18a9e-208">Ce démarrage rapide gère les déclarations de variables locales.</span><span class="sxs-lookup"><span data-stu-id="18a9e-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="18a9e-209">Vous pouvez l’étendre à d’autres déclarations telles que des boucles `foreach`, des boucles `for`, des expressions LINQ et des expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="18a9e-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="18a9e-210">En outre, ce module de réécriture transformera les déclarations dans la forme la plus simple :</span><span class="sxs-lookup"><span data-stu-id="18a9e-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="18a9e-211">Si vous souhaitez explorer votre propre déclaration, vous pouvez étendre l’exemple terminé pour ces types de déclarations de variables :</span><span class="sxs-lookup"><span data-stu-id="18a9e-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="18a9e-212">Ajoutez le code suivant au corps de la méthode `VisitLocalDeclarationStatement` pour ignorer la réécriture de ces formes de déclarations :</span><span class="sxs-lookup"><span data-stu-id="18a9e-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="18a9e-213">La méthode indique qu’aucune réécriture n’a lieu en retournant le paramètre `node` inchangé.</span><span class="sxs-lookup"><span data-stu-id="18a9e-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="18a9e-214">Si aucune de ces expressions `if` n’est vraie, le nœud représente une déclaration possible avec initialisation.</span><span class="sxs-lookup"><span data-stu-id="18a9e-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="18a9e-215">Ajoutez les instructions suivantes pour extraire le nom du type spécifié dans la déclaration et liez-le à l’aide du champ <xref:Microsoft.CodeAnalysis.SemanticModel> pour obtenir un symbole de type :</span><span class="sxs-lookup"><span data-stu-id="18a9e-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="18a9e-216">Ajoutez maintenant cette instruction pour lier l’expression de l’initialiseur :</span><span class="sxs-lookup"><span data-stu-id="18a9e-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="18a9e-217">Enfin, ajoutez l’instruction `if` suivante pour remplacer le nom de type existant par le mot clé `var` si le type de l’expression de l’initialiseur correspond au type spécifié :</span><span class="sxs-lookup"><span data-stu-id="18a9e-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode "Replace the initializer node")]

<span data-ttu-id="18a9e-218">Cette condition est nécessaire car la déclaration peut effectuer un cast de l’expression de l’initialiseur dans une classe de base ou une interface.</span><span class="sxs-lookup"><span data-stu-id="18a9e-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="18a9e-219">Si vous le souhaitez, les types à gauche et à droite de l’affectation ne correspondent pas.</span><span class="sxs-lookup"><span data-stu-id="18a9e-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="18a9e-220">Dans ce cas, la suppression du type explicite modifierait la sémantique d’un programme.</span><span class="sxs-lookup"><span data-stu-id="18a9e-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="18a9e-221">`var` est spécifié comme un identificateur plutôt qu’un mot clé car `var` est un mot clé contextuel.</span><span class="sxs-lookup"><span data-stu-id="18a9e-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="18a9e-222">Les trivias de début et de fin (espaces blancs) sont transférés de l’ancien nom de type vers le mot clé `var` afin de conserver les espaces blancs verticaux et l’indentation.</span><span class="sxs-lookup"><span data-stu-id="18a9e-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="18a9e-223">Il est plus simple d’utiliser `ReplaceNode` plutôt que `With*` pour transformer la <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>, car le nom de type est en fait le petit-enfant de l’instruction de déclaration.</span><span class="sxs-lookup"><span data-stu-id="18a9e-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="18a9e-224">Vous avez terminé le `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="18a9e-225">Revenez maintenant à votre fichier `Program.cs` pour terminer l’exemple.</span><span class="sxs-lookup"><span data-stu-id="18a9e-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="18a9e-226">Créez un test <xref:Microsoft.CodeAnalysis.Compilation> et obtenez le <xref:Microsoft.CodeAnalysis.SemanticModel> à partir de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="18a9e-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="18a9e-227">Utilisez <xref:Microsoft.CodeAnalysis.SemanticModel> pour tester votre `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="18a9e-228">Vous effectuerez cette étape en dernier.</span><span class="sxs-lookup"><span data-stu-id="18a9e-228">You'll do this step last.</span></span> <span data-ttu-id="18a9e-229">En attendant, déclarez une variable d’espace réservé représentant votre compilation de test :</span><span class="sxs-lookup"><span data-stu-id="18a9e-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="18a9e-230">Après une pause, vous devriez voir apparaître une erreur sous forme de tilde, indiquant qu’il n’existe aucune méthode `CreateTestCompilation`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="18a9e-231">Appuyez sur **Ctrl+point** pour ouvrir l’ampoule, puis sur Entrée pour appeler la commande **Générer un stub de méthode**.</span><span class="sxs-lookup"><span data-stu-id="18a9e-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="18a9e-232">Cette commande va générer un stub de méthode pour la méthode `CreateTestCompilation` dans la classe `Program`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="18a9e-233">Vous y reviendrez pour remplir cette méthode :</span><span class="sxs-lookup"><span data-stu-id="18a9e-233">You'll come back to fill in this method later:</span></span>

![C# - Générer une méthode à partir de l’utilisation](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="18a9e-235">Écrivez le code suivant pour effectuer une itération sur chaque <xref:Microsoft.CodeAnalysis.SyntaxTree> dans le test de <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="18a9e-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="18a9e-236">Pour chacune d’elles, initialisez un nouveau `TypeInferenceRewriter` avec le <xref:Microsoft.CodeAnalysis.SemanticModel> pour cet arborescence :</span><span class="sxs-lookup"><span data-stu-id="18a9e-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="18a9e-237">Dans l’instruction `foreach` que vous avez créée, ajoutez le code suivant pour effectuer la transformation sur chaque arborescence source.</span><span class="sxs-lookup"><span data-stu-id="18a9e-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="18a9e-238">Ce code écrit de façon conditionnelle la nouvelle arborescence transformée si des modifications ont été effectuées.</span><span class="sxs-lookup"><span data-stu-id="18a9e-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="18a9e-239">Votre module de réécriture doit uniquement modifier une arborescence si elle rencontre une ou plusieurs déclarations de variables locales qui pourraient être simplifiées à l’aide de l’inférence de type :</span><span class="sxs-lookup"><span data-stu-id="18a9e-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="18a9e-240">Vous devriez voir des tildes sous le code `File.WriteAllText`.</span><span class="sxs-lookup"><span data-stu-id="18a9e-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="18a9e-241">Sélectionnez l’ampoule et ajoutez l’instruction `using System.IO;` nécessaire.</span><span class="sxs-lookup"><span data-stu-id="18a9e-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="18a9e-242">Vous avez presque terminé.</span><span class="sxs-lookup"><span data-stu-id="18a9e-242">You're almost done!</span></span> <span data-ttu-id="18a9e-243">Il y a une étape restante : <xref:Microsoft.CodeAnalysis.Compilation>création d’un test.</span><span class="sxs-lookup"><span data-stu-id="18a9e-243">There's one step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="18a9e-244">Étant donné que vous n’avez pas utilisé du tout l’inférence de type pendant ce démarrage rapide, cela aurait été un cas de test parfait.</span><span class="sxs-lookup"><span data-stu-id="18a9e-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="18a9e-245">Malheureusement, la création d’une compilation à partir d’un fichier de projet C# dépasse le cadre de cette procédure pas à pas.</span><span class="sxs-lookup"><span data-stu-id="18a9e-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="18a9e-246">Heureusement, si vous avez suivi attentivement les instructions, il reste un espoir.</span><span class="sxs-lookup"><span data-stu-id="18a9e-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="18a9e-247">Remplacez le contenu de la méthode `CreateTestCompilation` par le code suivant :</span><span class="sxs-lookup"><span data-stu-id="18a9e-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="18a9e-248">Il crée une compilation de test correspondant par coïncidence au projet décrit dans ce démarrage rapide :</span><span class="sxs-lookup"><span data-stu-id="18a9e-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="18a9e-249">Croisez les doigts et exécutez le projet.</span><span class="sxs-lookup"><span data-stu-id="18a9e-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="18a9e-250">Dans Visual Studio, choisissez **Déboguer** > **Démarrer le débogage**.</span><span class="sxs-lookup"><span data-stu-id="18a9e-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="18a9e-251">Visual Studio devrait vous avertir que les fichiers de votre projet ont été modifiés.</span><span class="sxs-lookup"><span data-stu-id="18a9e-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="18a9e-252">Cliquez sur «**Oui pour tout**» pour recharger les fichiers modifiés.</span><span class="sxs-lookup"><span data-stu-id="18a9e-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="18a9e-253">Examinez ces fichiers pour vérifier la qualité de votre travail.</span><span class="sxs-lookup"><span data-stu-id="18a9e-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="18a9e-254">Remarquez à quel point le code serait plus propre sans tous ces spécificateurs de type explicites et redondants.</span><span class="sxs-lookup"><span data-stu-id="18a9e-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="18a9e-255">Félicitations !</span><span class="sxs-lookup"><span data-stu-id="18a9e-255">Congratulations!</span></span> <span data-ttu-id="18a9e-256">Vous avez utilisé les **API du compilateur** pour écrire votre propre refactorisation qui recherche certains modèles syntaxiques dans tous les fichiers d’un projet C#, analyse la sémantique du code source correspondant à ces modèles puis la transforme.</span><span class="sxs-lookup"><span data-stu-id="18a9e-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="18a9e-257">Vous êtes maintenant officiellement un auteur de refactorisation !</span><span class="sxs-lookup"><span data-stu-id="18a9e-257">You're now officially a refactoring author!</span></span>
