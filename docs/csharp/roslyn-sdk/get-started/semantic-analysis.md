---
title: Bien démarrer avec l’analyse sémantique
description: Ce tutoriel fournit une vue d’ensemble de l’utilisation de l’analyse sémantique avec le SDK du compilateur .NET.
ms.date: 02/06/2018
ms.custom: mvc
ms.openlocfilehash: 7bf2f40ea0bc059d9c517780016ca5deb805ceb6
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/25/2019
ms.locfileid: "75346981"
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="413a1-103">Bien démarrer avec l’analyse sémantique</span><span class="sxs-lookup"><span data-stu-id="413a1-103">Get started with semantic analysis</span></span>

<span data-ttu-id="413a1-104">Ce tutoriel suppose que vous êtes familiarisé avec l’API Syntaxe.</span><span class="sxs-lookup"><span data-stu-id="413a1-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="413a1-105">L’article [Bien démarrer avec l’analyse syntaxique](syntax-analysis.md) fournit une introduction suffisante.</span><span class="sxs-lookup"><span data-stu-id="413a1-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="413a1-106">Dans ce tutoriel, vous découvrez les API **Symbole** et **Liaison**.</span><span class="sxs-lookup"><span data-stu-id="413a1-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="413a1-107">Ces API fournissent des informations sur la _signification sémantique_ d’un programme.</span><span class="sxs-lookup"><span data-stu-id="413a1-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="413a1-108">Elles vous permettent de poser et de répondre à des questions sur les types représentés par un symbole dans votre programme.</span><span class="sxs-lookup"><span data-stu-id="413a1-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

<span data-ttu-id="413a1-109">Vous devez installer le SDK **.NET Compiler Platform** :</span><span class="sxs-lookup"><span data-stu-id="413a1-109">You'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="413a1-110">Présentation des compilations et des symboles</span><span class="sxs-lookup"><span data-stu-id="413a1-110">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="413a1-111">Au fil de votre utilisation du SDK du compilateur .NET, vous allez mieux comprendre les différences entre l’API Syntaxe et l’API Sémantique.</span><span class="sxs-lookup"><span data-stu-id="413a1-111">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="413a1-112">**L’API Syntaxe** vous permet d’examiner la _structure_ d’un programme.</span><span class="sxs-lookup"><span data-stu-id="413a1-112">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="413a1-113">Cependant, des informations plus détaillées sur la sémantique ou la _signification_ d’un programme sont souvent nécessaires.</span><span class="sxs-lookup"><span data-stu-id="413a1-113">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="413a1-114">Même si un fichier de code libre ou un extrait C# de Visual Basic ou du code peut être analysé de manière syntaxique de manière isolée, il n’est pas judicieux de poser des questions telles que « quel est le type de cette variable » dans un vide.</span><span class="sxs-lookup"><span data-stu-id="413a1-114">While a loose code file or snippet of Visual Basic or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="413a1-115">La signification d’un nom de type peut dépendre de références d’assembly, d’importations d’espaces de noms ou d’autres fichiers de code.</span><span class="sxs-lookup"><span data-stu-id="413a1-115">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="413a1-116">Ces questions sont traitées avec **l’API Sémantique**, plus précisément avec la classe <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="413a1-116">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="413a1-117">Une instance de <xref:Microsoft.CodeAnalysis.Compilation> est analogue à un projet tel qu’il est vu par le compilateur et représente tout ce qui est nécessaire pour compiler un programme Visual Basic ou C#.</span><span class="sxs-lookup"><span data-stu-id="413a1-117">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="413a1-118">La **compilation** comprend l’ensemble des fichiers sources à compiler, les références d’assembly et les options du compilateur.</span><span class="sxs-lookup"><span data-stu-id="413a1-118">The **compilation** includes the set of source files to be compiled, assembly references, and compiler options.</span></span> <span data-ttu-id="413a1-119">Vous pouvez analyser la signification du code en utilisant toutes les autres informations de ce contexte.</span><span class="sxs-lookup"><span data-stu-id="413a1-119">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="413a1-120">Une <xref:Microsoft.CodeAnalysis.Compilation> vous permet de rechercher des **symboles**, qui sont des entités comme des types, des espaces de noms, des membres et des variables, qui sont référencées par des noms et d’autres expressions.</span><span class="sxs-lookup"><span data-stu-id="413a1-120">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="413a1-121">Le processus consistant à associer des noms et des expressions à des **symboles** est appelé la **liaison**.</span><span class="sxs-lookup"><span data-stu-id="413a1-121">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="413a1-122">Comme <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> est une classe abstraite avec des dérivés spécifiques à un langage.</span><span class="sxs-lookup"><span data-stu-id="413a1-122">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="413a1-123">Quand vous créez une instance de compilation, vous devez appeler une méthode de fabrique sur la classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (ou <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="413a1-123">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="413a1-124">Interrogation des symboles</span><span class="sxs-lookup"><span data-stu-id="413a1-124">Querying symbols</span></span>

<span data-ttu-id="413a1-125">Dans ce tutoriel, vous examinez à nouveau le programme « Hello World ».</span><span class="sxs-lookup"><span data-stu-id="413a1-125">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="413a1-126">Cette fois-ci, vous interrogez les symboles du programme pour comprendre quels types ces symboles représentent.</span><span class="sxs-lookup"><span data-stu-id="413a1-126">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="413a1-127">Vous interrogez les types dans un espace de noms et vous découvrez comment trouver les méthodes disponibles sur un type.</span><span class="sxs-lookup"><span data-stu-id="413a1-127">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

<span data-ttu-id="413a1-128">Vous pouvez trouver le code complet de cet exemple dans [notre dépôt GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="413a1-128">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="413a1-129">Les types de l’arborescence de syntaxe utilisent l’héritage pour décrire les différents éléments de syntaxe qui sont valides à différents emplacements du programme.</span><span class="sxs-lookup"><span data-stu-id="413a1-129">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="413a1-130">Utiliser ces API signifie souvent effectuer un cast des propriétés ou des membres de collection vers des types dérivés spécifiques.</span><span class="sxs-lookup"><span data-stu-id="413a1-130">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="413a1-131">Dans les exemples suivants, l’affectation et les casts sont des instructions distinctes, qui utilisent des variables typées explicitement.</span><span class="sxs-lookup"><span data-stu-id="413a1-131">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="413a1-132">Vous pouvez lire le code pour voir les types de retour de l’API et le type à l’exécution des objets retournés.</span><span class="sxs-lookup"><span data-stu-id="413a1-132">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="413a1-133">Dans la pratique, il est plus courant d’utiliser des variables typées implicitement et de se baser sur des noms d’API pour décrire le type des objets examinés.</span><span class="sxs-lookup"><span data-stu-id="413a1-133">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="413a1-134">Créez un projet C# **Outil d’analyse du code autonome** :</span><span class="sxs-lookup"><span data-stu-id="413a1-134">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="413a1-135">Dans Visual Studio, choisissez **Fichier** > **Nouveau** > **Projet** pour afficher la boîte de dialogue Nouveau projet.</span><span class="sxs-lookup"><span data-stu-id="413a1-135">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="413a1-136">Sous **Visual C#**  > **Extensibilité**, choisissez **Outil d’analyse du code autonome**.</span><span class="sxs-lookup"><span data-stu-id="413a1-136">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="413a1-137">Nommez votre projet « **SemanticQuickStart** » et cliquez sur OK.</span><span class="sxs-lookup"><span data-stu-id="413a1-137">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="413a1-138">Vous allez analyser le programme simple « Hello World! »</span><span class="sxs-lookup"><span data-stu-id="413a1-138">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="413a1-139">montré précédemment.</span><span class="sxs-lookup"><span data-stu-id="413a1-139">program shown earlier.</span></span>
<span data-ttu-id="413a1-140">Ajoutez le texte pour le programme Hello World en tant que constante dans votre classe `Program` :</span><span class="sxs-lookup"><span data-stu-id="413a1-140">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="413a1-141">Ensuite, ajoutez le code suivant pour générer l’arborescence de syntaxe pour le texte du code dans la constante `programText`.</span><span class="sxs-lookup"><span data-stu-id="413a1-141">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="413a1-142">Ajoutez la ligne suivante à votre méthode `Main` :</span><span class="sxs-lookup"><span data-stu-id="413a1-142">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="413a1-143">Ensuite, générez une <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> à partir de l’arborescence que vous avez déjà créée.</span><span class="sxs-lookup"><span data-stu-id="413a1-143">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="413a1-144">L’exemple « Hello World » est basé sur les types <xref:System.String> et <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="413a1-144">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="413a1-145">Vous devez référencer l’assembly qui déclare ces deux types dans votre compilation.</span><span class="sxs-lookup"><span data-stu-id="413a1-145">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="413a1-146">Ajoutez la ligne suivante à votre méthode `Main` pour créer une compilation de votre arborescence de syntaxe, en incluant la référence à l’assembly approprié :</span><span class="sxs-lookup"><span data-stu-id="413a1-146">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="413a1-147">La méthode <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> ajoute des références à la compilation.</span><span class="sxs-lookup"><span data-stu-id="413a1-147">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="413a1-148">La méthode <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> charge un assembly en tant que référence.</span><span class="sxs-lookup"><span data-stu-id="413a1-148">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> method loads an assembly as a reference.</span></span>

## <a name="querying-the-semantic-model"></a><span data-ttu-id="413a1-149">Interrogation du modèle sémantique</span><span class="sxs-lookup"><span data-stu-id="413a1-149">Querying the semantic model</span></span>

<span data-ttu-id="413a1-150">Une fois que vous avez une <xref:Microsoft.CodeAnalysis.Compilation>, vous pouvez la demander pour un <xref:Microsoft.CodeAnalysis.SemanticModel> pour n’importe quelle <xref:Microsoft.CodeAnalysis.SyntaxTree> contenue dans <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="413a1-150">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="413a1-151">Vous pouvez considérer le modèle sémantique comme étant la source de toutes les informations que vous obtiendriez normalement d’IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="413a1-151">You can think of the semantic model as the source for all the information you would normally get from intellisense.</span></span> <span data-ttu-id="413a1-152">Un <xref:Microsoft.CodeAnalysis.SemanticModel> peut répondre à des questions comme « Quels noms se trouvent dans l’étendue à cet emplacement ? », « Quels membres sont accessibles à partir de cette méthode ? », « Quelles variables sont utilisées dans ce bloc de texte ? » et « À quoi ce nom ou cette expression font-ils référence ? ».</span><span class="sxs-lookup"><span data-stu-id="413a1-152">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?", "What members are accessible from this method?", "What variables are used in this block of text?", and "What does this name/expression refer to?"</span></span> <span data-ttu-id="413a1-153">Ajoutez cette instruction pour créer le modèle sémantique :</span><span class="sxs-lookup"><span data-stu-id="413a1-153">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="413a1-154">Liaison d’un nom</span><span class="sxs-lookup"><span data-stu-id="413a1-154">Binding a name</span></span>

<span data-ttu-id="413a1-155"><xref:Microsoft.CodeAnalysis.Compilation> crée <xref:Microsoft.CodeAnalysis.SemanticModel> à partir de <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="413a1-155">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="413a1-156">Après avoir créé le modèle, vous pouvez l’interroger pour rechercher la première directive `using` et récupérer les informations des symboles pour l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="413a1-156">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="413a1-157">Ajoutez ces deux lignes à votre méthode `Main` pour créer le modèle sémantique et pour récupérer le symbole pour la première instruction using :</span><span class="sxs-lookup"><span data-stu-id="413a1-157">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="413a1-158">Le code précédent montre comment lier le nom dans la première directive `using` pour récupérer un <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> pour l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="413a1-158">The preceding code shows how to bind the name in the first `using` directive to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="413a1-159">Le code précédent montre aussi que vous utilisez le **modèle de syntaxe** pour trouver la structure du code ; vous utilisez le **modèle sémantique** pour comprendre sa signification.</span><span class="sxs-lookup"><span data-stu-id="413a1-159">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="413a1-160">Le **modèle de syntaxe** recherche la chaîne `System` dans l’instruction using.</span><span class="sxs-lookup"><span data-stu-id="413a1-160">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="413a1-161">Le **modèle sémantique** a toutes les informations sur les types définis dans l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="413a1-161">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="413a1-162">À partir de l’objet <xref:Microsoft.CodeAnalysis.SymbolInfo>, vous pouvez obtenir <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> en utilisant la propriété <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="413a1-162">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="413a1-163">Cette propriété retourne le symbole auquel cette expression fait référence.</span><span class="sxs-lookup"><span data-stu-id="413a1-163">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="413a1-164">Pour les expressions qui ne font référence à rien (comme les littéraux numériques), cette propriété est `null`.</span><span class="sxs-lookup"><span data-stu-id="413a1-164">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="413a1-165">Quand <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> n’est pas null, <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> indique le type du symbole.</span><span class="sxs-lookup"><span data-stu-id="413a1-165">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="413a1-166">Dans cet exemple, la propriété <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> est un <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="413a1-166">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="413a1-167">Ajoutez le code suivant à votre méthode `Main`.</span><span class="sxs-lookup"><span data-stu-id="413a1-167">Add the following code to your `Main` method.</span></span> <span data-ttu-id="413a1-168">Il récupère le symbole pour l’espace de noms `System`, puis affiche tous les espaces de noms enfants déclarés dans l’espace de noms `System` :</span><span class="sxs-lookup"><span data-stu-id="413a1-168">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="413a1-169">Exécutez le programme ; vous devez normalement voir la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="413a1-169">Run the program and you should see the following output:</span></span>

```output
System.Collections
System.Configuration
System.Deployment
System.Diagnostics
System.Globalization
System.IO
System.Numerics
System.Reflection
System.Resources
System.Runtime
System.Security
System.StubHelpers
System.Text
System.Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="413a1-170">La sortie n’inclut pas chaque espace de noms qui est un espace de noms enfant de l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="413a1-170">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="413a1-171">Elle affiche chaque espace de noms qui est présent dans cette compilation, qui référence seulement l’assembly où `System.String` est déclaré.</span><span class="sxs-lookup"><span data-stu-id="413a1-171">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="413a1-172">Les espaces de noms déclarés dans d’autres assemblys ne sont pas connus de cette compilation.</span><span class="sxs-lookup"><span data-stu-id="413a1-172">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="413a1-173">Liaison d’une expression</span><span class="sxs-lookup"><span data-stu-id="413a1-173">Binding an expression</span></span>

<span data-ttu-id="413a1-174">Le code précédent montre comment trouver un symbole en le liant à un nom.</span><span class="sxs-lookup"><span data-stu-id="413a1-174">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="413a1-175">D’autres expressions existent dans un programme C# qui peuvent être liées, mais qui ne sont pas des noms.</span><span class="sxs-lookup"><span data-stu-id="413a1-175">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="413a1-176">Pour montrer cette possibilité, accédons à la liaison vers un littéral de chaîne simple.</span><span class="sxs-lookup"><span data-stu-id="413a1-176">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="413a1-177">Le programme « Hello World » contient un <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, : la chaîne « Hello, World! »</span><span class="sxs-lookup"><span data-stu-id="413a1-177">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="413a1-178">affichée dans la console.</span><span class="sxs-lookup"><span data-stu-id="413a1-178">string displayed to the console.</span></span>

<span data-ttu-id="413a1-179">Vous trouvez la chaîne « Hello, World! »</span><span class="sxs-lookup"><span data-stu-id="413a1-179">You find the "Hello, World!"</span></span> <span data-ttu-id="413a1-180">en recherchant le seul littéral de chaîne dans le programme.</span><span class="sxs-lookup"><span data-stu-id="413a1-180">string by locating the single string literal in the program.</span></span> <span data-ttu-id="413a1-181">Ensuite, une fois que vous avez localisé le nœud de syntaxe, vous obtenez les informations de type pour ce nœud auprès du modèle sémantique.</span><span class="sxs-lookup"><span data-stu-id="413a1-181">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="413a1-182">Ajoutez le code suivant à votre méthode `Main` :</span><span class="sxs-lookup"><span data-stu-id="413a1-182">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="413a1-183">La struct <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> inclut une propriété <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> qui permet d’accéder aux informations sémantiques sur le type du littéral.</span><span class="sxs-lookup"><span data-stu-id="413a1-183">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="413a1-184">Dans cet exemple, il s’agit du type `string`.</span><span class="sxs-lookup"><span data-stu-id="413a1-184">In this example, that's the `string` type.</span></span> <span data-ttu-id="413a1-185">Ajoutez une déclaration qui affecte cette propriété à une variable locale :</span><span class="sxs-lookup"><span data-stu-id="413a1-185">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="413a1-186">Pour terminer ce tutoriel, construisons une requête LINQ qui crée une séquence de toutes les méthodes publiques déclarées sur le type `string` qui retournent un type `string`.</span><span class="sxs-lookup"><span data-stu-id="413a1-186">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="413a1-187">Cette requête est complexe : nous allons donc la construire ligne par ligne, puis la reconstruire pour former une seule requête.</span><span class="sxs-lookup"><span data-stu-id="413a1-187">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="413a1-188">La source de cette requête est la séquence de tous les membres déclarés sur le type `string` :</span><span class="sxs-lookup"><span data-stu-id="413a1-188">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="413a1-189">Cette séquence source contient tous les membres, notamment les propriétés et les champs ; filtrez-la avec la méthode <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> pour trouver les éléments qui sont des objets <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="413a1-189">That source sequence contains all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="413a1-190">Ensuite, ajoutez un autre filtre pour retourner seulement les méthodes qui sont publiques et qui retournent un type `string` :</span><span class="sxs-lookup"><span data-stu-id="413a1-190">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="413a1-191">Sélectionnez seulement la propriété name et seulement les noms distincts en supprimant les surcharges :</span><span class="sxs-lookup"><span data-stu-id="413a1-191">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="413a1-192">Vous pouvez aussi créer toute la requête avec la syntaxe de requête LINQ, puis afficher tous les noms de méthode dans la console :</span><span class="sxs-lookup"><span data-stu-id="413a1-192">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#13 "Build and display the results of the query.")]

<span data-ttu-id="413a1-193">Générez et exécutez le programme.</span><span class="sxs-lookup"><span data-stu-id="413a1-193">Build and run the program.</span></span> <span data-ttu-id="413a1-194">Vous devez voir la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="413a1-194">You should see the following output:</span></span>

```output
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```

<span data-ttu-id="413a1-195">Vous avez utilisé l’API Sémantique pour rechercher et afficher des informations sur les symboles qui font partie de ce programme.</span><span class="sxs-lookup"><span data-stu-id="413a1-195">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
