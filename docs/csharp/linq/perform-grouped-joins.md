---
title: Effectuer des jointures groupées (LINQ en C#)
description: Découvrez comment effectuer des jointures groupées à l’aide de LINQ en C#.
ms.date: 04/22/2020
ms.assetid: 9667daf9-a5fd-4b43-a5c4-a9c2b744000e
ms.openlocfilehash: 6411479c5fe6cb0ee79a0cd3df6de2f4d42c26a2
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90542807"
---
# <a name="perform-grouped-joins"></a><span data-ttu-id="a3996-103">Effectuer des jointures groupées</span><span class="sxs-lookup"><span data-stu-id="a3996-103">Perform grouped joins</span></span>

<span data-ttu-id="a3996-104">La jointure groupée est utile pour produire des structures de données hiérarchiques.</span><span class="sxs-lookup"><span data-stu-id="a3996-104">The group join is useful for producing hierarchical data structures.</span></span> <span data-ttu-id="a3996-105">Elle associe chaque élément de la première collection à un jeu d’éléments corrélés de la deuxième collection.</span><span class="sxs-lookup"><span data-stu-id="a3996-105">It pairs each element from the first collection with a set of correlated elements from the second collection.</span></span>

<span data-ttu-id="a3996-106">Par exemple, une classe ou une table de base de données relationnelle nommée `Student` peut contenir deux champs : `Id` et `Name`.</span><span class="sxs-lookup"><span data-stu-id="a3996-106">For example, a class or a relational database table named `Student` might contain two fields: `Id` and `Name`.</span></span> <span data-ttu-id="a3996-107">Une deuxième classe ou table de base de données relationnelle nommée `Course` peut contenir deux champs : `StudentId` et `CourseTitle`.</span><span class="sxs-lookup"><span data-stu-id="a3996-107">A second class or relational database table named `Course` might contain two fields: `StudentId` and `CourseTitle`.</span></span> <span data-ttu-id="a3996-108">Une jointure groupée de ces deux sources de données, basée sur les champs `Student.Id` et `Course.StudentId` correspondants, regroupe chaque `Student` avec une collection d’objets `Course` (qui peut être vide).</span><span class="sxs-lookup"><span data-stu-id="a3996-108">A group join of these two data sources, based on matching `Student.Id` and `Course.StudentId`, would group each `Student` with a collection of `Course` objects (which might be empty).</span></span>

> [!NOTE]
> <span data-ttu-id="a3996-109">Chaque élément de la première collection apparaît dans le jeu de résultats d’une jointure groupée, même si des éléments corrélés sont trouvés dans la deuxième collection.</span><span class="sxs-lookup"><span data-stu-id="a3996-109">Each element of the first collection appears in the result set of a group join regardless of whether correlated elements are found in the second collection.</span></span> <span data-ttu-id="a3996-110">Si aucun élément corrélé n’est trouvé, la séquence d’éléments corrélés pour cet élément est vide.</span><span class="sxs-lookup"><span data-stu-id="a3996-110">In the case where no correlated elements are found, the sequence of correlated elements for that element is empty.</span></span> <span data-ttu-id="a3996-111">Le sélecteur de résultats a donc accès à chaque élément de la première collection.</span><span class="sxs-lookup"><span data-stu-id="a3996-111">The result selector therefore has access to every element of the first collection.</span></span> <span data-ttu-id="a3996-112">Cela n’est pas le cas du sélecteur de résultats dans une jointure non groupée, qui ne peut pas accéder à des éléments de la première collection qui n’ont aucune correspondance dans la deuxième collection.</span><span class="sxs-lookup"><span data-stu-id="a3996-112">This differs from the result selector in a non-group join, which cannot access elements from the first collection that have no match in the second collection.</span></span>

> [!WARNING]
> <span data-ttu-id="a3996-113"><xref:System.Linq.Enumerable.GroupJoin%2A?displayProperty=nameWithType> n’a aucun équivalent direct dans les termes de base de données relationnelle traditionnels.</span><span class="sxs-lookup"><span data-stu-id="a3996-113"><xref:System.Linq.Enumerable.GroupJoin%2A?displayProperty=nameWithType> has no direct equivalent in traditional relational database terms.</span></span> <span data-ttu-id="a3996-114">Toutefois, cette méthode implémente un sur-ensemble de jointures internes et de jointures externes gauches.</span><span class="sxs-lookup"><span data-stu-id="a3996-114">However, this method does implement a superset of inner joins and left outer joins.</span></span> <span data-ttu-id="a3996-115">Ces deux opérations peuvent être écrites en termes de jointure groupée.</span><span class="sxs-lookup"><span data-stu-id="a3996-115">Both of these operations can be written in terms of a grouped join.</span></span> <span data-ttu-id="a3996-116">Pour plus d’informations, consultez [join, opérations](../programming-guide/concepts/linq/join-operations.md) et [Entity Framework Core, GroupJoin](/ef/core/querying/complex-query-operators#groupjoin).</span><span class="sxs-lookup"><span data-stu-id="a3996-116">For more information, see [Join Operations](../programming-guide/concepts/linq/join-operations.md) and [Entity Framework Core, GroupJoin](/ef/core/querying/complex-query-operators#groupjoin).</span></span>

<span data-ttu-id="a3996-117">Le premier exemple de cet article montre comment effectuer une jointure groupée.</span><span class="sxs-lookup"><span data-stu-id="a3996-117">The first example in this article shows you how to perform a group join.</span></span> <span data-ttu-id="a3996-118">Le deuxième exemple montre comment utiliser une jointure groupée pour créer des éléments XML.</span><span class="sxs-lookup"><span data-stu-id="a3996-118">The second example shows you how to use a group join to create XML elements.</span></span>

## <a name="example---group-join"></a><span data-ttu-id="a3996-119">Exemple – Jointure groupée</span><span class="sxs-lookup"><span data-stu-id="a3996-119">Example - Group join</span></span>

<span data-ttu-id="a3996-120">L’exemple suivant effectue une jointure groupée d’objets de types `Person` et `Pet` où `Person` correspond à la propriété `Pet.Owner`.</span><span class="sxs-lookup"><span data-stu-id="a3996-120">The following example performs a group join of objects of type `Person` and `Pet` based on the `Person` matching the `Pet.Owner` property.</span></span> <span data-ttu-id="a3996-121">Contrairement à une jointure non groupée qui produirait une paire d’éléments pour chaque correspondance, la jointure groupée produit un seul objet résultant pour chaque élément de la première collection, qui est un objet `Person` dans cet exemple.</span><span class="sxs-lookup"><span data-stu-id="a3996-121">Unlike a non-group join, which would produce a pair of elements for each match, the group join produces only one resulting object for each element of the first collection, which in this example is a `Person` object.</span></span> <span data-ttu-id="a3996-122">Les éléments correspondants de la deuxième collection, qui sont des objets `Pet` dans cet exemple, sont regroupés dans une collection.</span><span class="sxs-lookup"><span data-stu-id="a3996-122">The corresponding elements from the second collection, which in this example are `Pet` objects, are grouped into a collection.</span></span> <span data-ttu-id="a3996-123">Enfin, le sélecteur de résultats crée un type anonyme pour chaque correspondance qui se compose de `Person.FirstName` et d’une collection d’objets `Pet`.</span><span class="sxs-lookup"><span data-stu-id="a3996-123">Finally, the result selector function creates an anonymous type for each match that consists of `Person.FirstName` and a collection of `Pet` objects.</span></span>

[!code-csharp[CsLINQProgJoining#5](~/samples/snippets/csharp/concepts/linq/how-to-perform-grouped-joins_1.cs)]

## <a name="example---group-join-to-create-xml"></a><span data-ttu-id="a3996-124">Exemple – Jointure groupée pour créer des éléments XLM</span><span class="sxs-lookup"><span data-stu-id="a3996-124">Example - Group join to create XML</span></span>

<span data-ttu-id="a3996-125">Les jointures groupées sont appropriées pour créer des éléments XML à l’aide de LINQ to XML.</span><span class="sxs-lookup"><span data-stu-id="a3996-125">Group joins are ideal for creating XML by using LINQ to XML.</span></span> <span data-ttu-id="a3996-126">L’exemple suivant est similaire à l’exemple précédent, sauf qu’au lieu de créer des types anonymes, le sélecteur de résultats crée des éléments XML qui représentent les objets joints.</span><span class="sxs-lookup"><span data-stu-id="a3996-126">The following example is similar to the previous example except that instead of creating anonymous types, the result selector function creates XML elements that represent the joined objects.</span></span>

[!code-csharp[CsLINQProgJoining#6](~/samples/snippets/csharp/concepts/linq/how-to-perform-grouped-joins_2.cs)]

## <a name="see-also"></a><span data-ttu-id="a3996-127">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="a3996-127">See also</span></span>

- <xref:System.Linq.Enumerable.Join%2A>
- <xref:System.Linq.Enumerable.GroupJoin%2A>
- [<span data-ttu-id="a3996-128">Effectuer des jointures internes</span><span class="sxs-lookup"><span data-stu-id="a3996-128">Perform inner joins</span></span>](perform-inner-joins.md)
- [<span data-ttu-id="a3996-129">Effectuer des jointures externes gauches</span><span class="sxs-lookup"><span data-stu-id="a3996-129">Perform left outer joins</span></span>](perform-left-outer-joins.md)
- [<span data-ttu-id="a3996-130">Types anonymes</span><span class="sxs-lookup"><span data-stu-id="a3996-130">Anonymous types</span></span>](../programming-guide/classes-and-structs/anonymous-types.md)
