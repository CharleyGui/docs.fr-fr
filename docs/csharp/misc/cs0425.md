---
description: Erreur du compilateur CS0425
title: Erreur du compilateur CS0425
ms.date: 07/20/2015
f1_keywords:
- CS0425
helpviewer_keywords:
- CS0425
ms.assetid: cec0391c-a641-43bc-8557-92b23f6ca685
ms.openlocfilehash: 34a599c8ee6d8d4b32844c690f9ece6989b9caf8
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91177031"
---
# <a name="compiler-error-cs0425"></a><span data-ttu-id="853a1-103">Erreur du compilateur CS0425</span><span class="sxs-lookup"><span data-stu-id="853a1-103">Compiler Error CS0425</span></span>

<span data-ttu-id="853a1-104">Les contraintes pour le paramètre de type 'paramètre de type' de la méthode 'méthode' doivent correspondre aux contraintes pour le paramètre de type 'paramètre de type' de la méthode d’interface 'méthode'.</span><span class="sxs-lookup"><span data-stu-id="853a1-104">The constraints for type parameter 'type parameter' of method 'method' must match the constraints for type parameter 'type parameter' of interface method 'method'.</span></span> <span data-ttu-id="853a1-105">Utilisez plutôt une implémentation d’interface explicite.</span><span class="sxs-lookup"><span data-stu-id="853a1-105">Consider using an explicit interface implementation instead.</span></span>  
  
 <span data-ttu-id="853a1-106">Cette erreur se produit quand une méthode générique virtuelle est substituée dans une classe dérivée et que les contraintes de la méthode de la classe dérivée ne correspondent pas aux contraintes de la méthode de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="853a1-106">This error occurs if a virtual generic method is overridden in a derived class and the constraints on the method in the derived class do not match the constraints on the method in the base class.</span></span> <span data-ttu-id="853a1-107">Pour éviter cette erreur, assurez-vous que la clause `where` est identique dans les deux déclarations, ou implémentez l’interface explicitement.</span><span class="sxs-lookup"><span data-stu-id="853a1-107">To avoid this error, make sure the `where` clause is identical in both declarations, or implement the interface explicitly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="853a1-108">Exemple</span><span class="sxs-lookup"><span data-stu-id="853a1-108">Example</span></span>  

 <span data-ttu-id="853a1-109">L’exemple suivant génère l’erreur CS0425 :</span><span class="sxs-lookup"><span data-stu-id="853a1-109">The following example generates CS0425:</span></span>  
  
```csharp  
// CS0425.cs  
  
class C1  
{  
}  
  
class C2  
{  
}  
  
interface IBase  
{  
    void F<ItemType>(ItemType item) where ItemType : C1;  
}  
  
class Derived : IBase  
{  
    public void F<ItemType>(ItemType item) where ItemType : C2  // CS0425  
    {  
    }  
}  
  
class CMain  
{  
    public static void Main()  
    {  
    }  
}  
```  
  
## <a name="example"></a><span data-ttu-id="853a1-110">Exemple</span><span class="sxs-lookup"><span data-stu-id="853a1-110">Example</span></span>  

 <span data-ttu-id="853a1-111">La correspondance des contraintes ne doit pas forcément être exacte. Il suffit que l’ensemble de contraintes possède la même signification.</span><span class="sxs-lookup"><span data-stu-id="853a1-111">The constraints do not have to be a literal match, as long as the set of constraints has the same meaning.</span></span> <span data-ttu-id="853a1-112">Par exemple, le code suivant est acceptable :</span><span class="sxs-lookup"><span data-stu-id="853a1-112">For example, the following is okay:</span></span>  
  
```csharp  
// CS0425b.cs  
  
interface J<Z>  
{  
}  
  
interface I<S>  
{  
    void F<T>(S s, T t) where T: J<S>, J<int>;  
}  
  
class C : I<int>  
{  
    public void F<X>(int s, X x) where X : J<int>  
    {  
    }  
  
    public static void Main()  
    {  
    }  
}  
```
