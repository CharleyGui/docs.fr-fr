---
title: Critères spéciaux - Guide C#
description: En savoir plus sur les expressions de critères spéciaux en langage C#
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 2dd1401e3ef22a02f327e44ff884182ee3e22278
ms.sourcegitcommit: b1f4756120deaecb8b554477bb040620f69a4209
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/03/2020
ms.locfileid: "89414992"
---
# <a name="pattern-matching"></a><span data-ttu-id="89f63-103">Critères spéciaux</span><span class="sxs-lookup"><span data-stu-id="89f63-103">Pattern Matching</span></span>

<span data-ttu-id="89f63-104">Les modèles vérifient qu’une valeur a une certaine *forme* et peuvent *extraire* des informations de la valeur quand celle-ci a la forme correspondante.</span><span class="sxs-lookup"><span data-stu-id="89f63-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="89f63-105">Les critères spéciaux offrent une syntaxe plus concise pour les algorithmes que vous utilisez déjà aujourd’hui.</span><span class="sxs-lookup"><span data-stu-id="89f63-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="89f63-106">Vous pouvez déjà créer des algorithmes de critères spéciaux à l’aide de la syntaxe existante.</span><span class="sxs-lookup"><span data-stu-id="89f63-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="89f63-107">Pour cela, vous écrivez des instructions `if` ou `switch` qui testent une valeur.</span><span class="sxs-lookup"><span data-stu-id="89f63-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="89f63-108">Ensuite, quand ces instructions correspondent, vous extrayez et utilisez les informations de cette valeur.</span><span class="sxs-lookup"><span data-stu-id="89f63-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="89f63-109">Les nouveaux éléments de syntaxe étendent les instructions que vous connaissez déjà : `is` et `switch`.</span><span class="sxs-lookup"><span data-stu-id="89f63-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="89f63-110">Ces nouvelles extensions permettent à la fois de tester une valeur et d’extraire les informations de cette valeur.</span><span class="sxs-lookup"><span data-stu-id="89f63-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="89f63-111">Dans cet article, nous allons examiner la nouvelle syntaxe pour voir en quoi elle rend le code plus lisible et plus concis.</span><span class="sxs-lookup"><span data-stu-id="89f63-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="89f63-112">Les critères spéciaux permettent d’utiliser des idiomes dans lesquels le code et les données sont séparés, contrairement aux conceptions orientées objet où les données et les méthodes qui les manipulent sont étroitement couplées.</span><span class="sxs-lookup"><span data-stu-id="89f63-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="89f63-113">Pour illustrer ces nouveaux idiomes, nous allons manipuler des structures représentant des formes géométriques à l’aide d’instructions de critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="89f63-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="89f63-114">Vous savez probablement déjà concevoir des hiérarchies de classes et créer des [méthodes virtuelles et méthodes substituées](methods.md#inherited) pour personnaliser le comportement d’un objet en fonction de son type à l’exécution.</span><span class="sxs-lookup"><span data-stu-id="89f63-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="89f63-115">Ces techniques ne sont pas possibles avec des données qui ne sont pas structurées dans une hiérarchie de classes.</span><span class="sxs-lookup"><span data-stu-id="89f63-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="89f63-116">Quand les données et les méthodes sont séparées, vous avez besoin d’autres outils.</span><span class="sxs-lookup"><span data-stu-id="89f63-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="89f63-117">Les nouvelles constructions de *critères spéciaux* utilisent une syntaxe simplifiée pour examiner les données et manipuler le flux de contrôle en fonction de la condition de ces données.</span><span class="sxs-lookup"><span data-stu-id="89f63-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="89f63-118">Vous écrivez déjà des instructions `if` et `switch` qui testent la valeur d’une variable.</span><span class="sxs-lookup"><span data-stu-id="89f63-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="89f63-119">Vous écrivez déjà des instructions `is` qui testent le type d’une variable.</span><span class="sxs-lookup"><span data-stu-id="89f63-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="89f63-120">Les *critères spéciaux* ajoutent de nouvelles fonctionnalités à ces instructions.</span><span class="sxs-lookup"><span data-stu-id="89f63-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="89f63-121">Dans cet article, vous allez créer une méthode qui calcule la surface de différentes formes géométriques.</span><span class="sxs-lookup"><span data-stu-id="89f63-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="89f63-122">Pour cela, vous n’allez pas utiliser de techniques orientées objet, ni créer une hiérarchie de classes pour les différentes formes.</span><span class="sxs-lookup"><span data-stu-id="89f63-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="89f63-123">Vous allez utiliser des *critères spéciaux* à la place.</span><span class="sxs-lookup"><span data-stu-id="89f63-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="89f63-124">Tout au long de cet exemple, comparez ce code avec le même code structuré comme une hiérarchie d’objets.</span><span class="sxs-lookup"><span data-stu-id="89f63-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="89f63-125">Quand les données à interroger et à manipuler ne constituent pas une hiérarchie de classes, les critères spéciaux permettent de réaliser des conceptions élégantes.</span><span class="sxs-lookup"><span data-stu-id="89f63-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="89f63-126">Au lieu de commencer avec une définition de forme abstraite et d’ajouter ensuite différentes classes de formes spécifiques, écrivez d’abord les définitions de données simples pour chacune des formes géométriques :</span><span class="sxs-lookup"><span data-stu-id="89f63-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="89f63-127">À partir de ces structures, écrivez une méthode qui calcule la surface d’une forme.</span><span class="sxs-lookup"><span data-stu-id="89f63-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="89f63-128">Expression du modèle de type `is`</span><span class="sxs-lookup"><span data-stu-id="89f63-128">The `is` type pattern expression</span></span>

<span data-ttu-id="89f63-129">Avant C# 7.0, vous deviez tester chaque type dans une série d’instructions `if` et `is` :</span><span class="sxs-lookup"><span data-stu-id="89f63-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="89f63-130">Le code ci-dessus est une expression standard du *modèle de type* : vous testez une variable pour déterminer son type et vous effectuez une action différente en fonction de ce type.</span><span class="sxs-lookup"><span data-stu-id="89f63-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="89f63-131">Vous pouvez simplifier ce code en ajoutant des extensions à l’expression `is` pour assigner une variable si le test réussit :</span><span class="sxs-lookup"><span data-stu-id="89f63-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="89f63-132">Dans cette version mise à jour, l’expression `is` teste la variable et l’assigne à une nouvelle variable du type approprié.</span><span class="sxs-lookup"><span data-stu-id="89f63-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="89f63-133">Remarquez également que cette version inclut le type `Rectangle`, qui est un `struct`.</span><span class="sxs-lookup"><span data-stu-id="89f63-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="89f63-134">La nouvelle expression `is` peut être utilisée avec des types valeur et des types référence.</span><span class="sxs-lookup"><span data-stu-id="89f63-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="89f63-135">Les règles de langage des expressions de critères spéciaux vous aident à éviter une utilisation incorrecte des résultats d’une expression de correspondance.</span><span class="sxs-lookup"><span data-stu-id="89f63-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="89f63-136">Dans l’exemple ci-dessus, les variables `s`, `c` et `r` sont uniquement dans la portée et assignées de manière définitive quand les expressions de critères spéciaux respectives retournent le résultat `true`.</span><span class="sxs-lookup"><span data-stu-id="89f63-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="89f63-137">Si vous essayez d’utiliser l’une de ces variables à un autre emplacement, votre code génère des erreurs de compilateur.</span><span class="sxs-lookup"><span data-stu-id="89f63-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="89f63-138">Examinons ces deux règles en détail, en commençant par la portée.</span><span class="sxs-lookup"><span data-stu-id="89f63-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="89f63-139">La variable `c` est dans la portée uniquement dans la branche `else` de la première instruction `if`.</span><span class="sxs-lookup"><span data-stu-id="89f63-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="89f63-140">La variable `s` est dans la portée dans la méthode `ComputeAreaModernIs`.</span><span class="sxs-lookup"><span data-stu-id="89f63-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="89f63-141">Cela est dû au fait que chaque branche d’une instruction `if` établit une portée distincte pour les variables,</span><span class="sxs-lookup"><span data-stu-id="89f63-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="89f63-142">ce que ne fait pas l’instruction `if` proprement dite.</span><span class="sxs-lookup"><span data-stu-id="89f63-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="89f63-143">Cela signifie que les variables déclarées dans l' `if` instruction se trouvent dans la même portée que l' `if` instruction (dans ce cas, la méthode).</span><span class="sxs-lookup"><span data-stu-id="89f63-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case).</span></span> <span data-ttu-id="89f63-144">Ce comportement n’est pas propre aux critères spéciaux. C’est le comportement défini pour les portées de variables et pour les instructions `if` et `else`.</span><span class="sxs-lookup"><span data-stu-id="89f63-144">This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="89f63-145">Les variables `c` et `s` sont assignées quand les instructions `if` respectives ont la valeur true, selon la règle d’assignation définitive quand le résultat est true.</span><span class="sxs-lookup"><span data-stu-id="89f63-145">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="89f63-146">Les exemples de cette rubrique utilisent la construction recommandée où une expression de critères spéciaux `is` assigne de manière définitive la variable de correspondance dans la branche `true` de l’instruction `if`.</span><span class="sxs-lookup"><span data-stu-id="89f63-146">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="89f63-147">Vous pourriez inverser la logique en écrivant `if (!(shape is Square s))`. La variable `s` serait alors assignée de manière définitive uniquement dans la branche `false`.</span><span class="sxs-lookup"><span data-stu-id="89f63-147">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="89f63-148">Cette pratique est possible dans C#, mais elle est déconseillée, car elle repose sur une logique plus compliquée à suivre.</span><span class="sxs-lookup"><span data-stu-id="89f63-148">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="89f63-149">Ces règles limitent le risque d’accéder accidentellement au résultat d’une expression de critères spéciaux dont le test n’a pas réussi.</span><span class="sxs-lookup"><span data-stu-id="89f63-149">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="89f63-150">Utilisation des instructions de critères spéciaux `switch`</span><span class="sxs-lookup"><span data-stu-id="89f63-150">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="89f63-151">Au fil du temps, vous aurez peut-être besoin de prendre en charge d’autres types de formes.</span><span class="sxs-lookup"><span data-stu-id="89f63-151">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="89f63-152">Si vous avez de plus en plus de conditions à tester, utiliser les expressions de critères spéciaux `is` peut devenir compliqué.</span><span class="sxs-lookup"><span data-stu-id="89f63-152">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="89f63-153">En plus de nécessiter des instructions `if` pour chaque type à vérifier, les expressions `is` permettent uniquement de vérifier si l’entrée correspond à un type unique.</span><span class="sxs-lookup"><span data-stu-id="89f63-153">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="89f63-154">Dans ce cas, les expressions de critères spéciaux `switch` sont plus adaptées.</span><span class="sxs-lookup"><span data-stu-id="89f63-154">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span>

<span data-ttu-id="89f63-155">L’instruction `switch` standard était une expression de modèle, qui prenait en charge le modèle de constante.</span><span class="sxs-lookup"><span data-stu-id="89f63-155">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="89f63-156">Vous pouviez comparer une variable à n’importe quelle constante utilisée dans une instruction `case` :</span><span class="sxs-lookup"><span data-stu-id="89f63-156">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="89f63-157">Le seul modèle pris en charge par l’instruction `switch` était le modèle de constante.</span><span class="sxs-lookup"><span data-stu-id="89f63-157">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="89f63-158">De plus, il était limité aux types numériques et au type `string`.</span><span class="sxs-lookup"><span data-stu-id="89f63-158">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="89f63-159">Ces restrictions ayant été supprimées, vous pouvez maintenant écrire une instruction `switch` en utilisant le modèle de type :</span><span class="sxs-lookup"><span data-stu-id="89f63-159">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="89f63-160">L’instruction de critères spéciaux `switch` utilise une syntaxe qui est familière aux développeurs ayant utilisé l’instruction `switch` de style C standard.</span><span class="sxs-lookup"><span data-stu-id="89f63-160">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="89f63-161">Chaque instruction `case` est évaluée, et le code en-dessous de la condition qui correspond à la variable d’entrée est exécuté.</span><span class="sxs-lookup"><span data-stu-id="89f63-161">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="89f63-162">L’exécution du code ne continue pas d’une expression case à la suivante, car la syntaxe de l’instruction `case` impose que chaque `case` se termine par `break`, `return` ou `goto`.</span><span class="sxs-lookup"><span data-stu-id="89f63-162">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="89f63-163">Les instructions `goto` pour accéder à une autre étiquette sont valides uniquement pour le modèle de constante (l’instruction switch standard).</span><span class="sxs-lookup"><span data-stu-id="89f63-163">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="89f63-164">Il y a de nouvelles règles importantes qui régissent l’instruction `switch`.</span><span class="sxs-lookup"><span data-stu-id="89f63-164">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="89f63-165">Les restrictions sur le type de la variable dans l’expression `switch` ont été supprimées.</span><span class="sxs-lookup"><span data-stu-id="89f63-165">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="89f63-166">Vous pouvez maintenant utiliser tous les types, comme le type `object` dans cet exemple.</span><span class="sxs-lookup"><span data-stu-id="89f63-166">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="89f63-167">Les expressions case ne sont plus limitées à des valeurs de constante.</span><span class="sxs-lookup"><span data-stu-id="89f63-167">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="89f63-168">Avec la suppression de cette limitation, la réorganisation des sections `switch` peut changer le comportement d’un programme.</span><span class="sxs-lookup"><span data-stu-id="89f63-168">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="89f63-169">Quand les expressions étaient limitées à des valeurs de constante, une seule étiquette `case` pouvait correspondre à la valeur de l’expression `switch`.</span><span class="sxs-lookup"><span data-stu-id="89f63-169">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="89f63-170">La conséquence de cette règle, associée à la règle selon laquelle une section `switch` ne devait pas passer à la section suivante, était que les sections `switch` pouvaient être réorganisées dans n’importe quel ordre sans que cela change le comportement du programme.</span><span class="sxs-lookup"><span data-stu-id="89f63-170">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="89f63-171">Maintenant, avec les expressions `switch` généralisées, l’ordre de chaque section est important.</span><span class="sxs-lookup"><span data-stu-id="89f63-171">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="89f63-172">Les expressions `switch` sont évaluées dans l’ordre textuel.</span><span class="sxs-lookup"><span data-stu-id="89f63-172">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="89f63-173">L’exécution passe à la première étiquette `switch` qui correspond à l’expression `switch`.</span><span class="sxs-lookup"><span data-stu-id="89f63-173">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="89f63-174">Le cas `default` n’est exécuté que si aucune autre étiquette case ne correspond.</span><span class="sxs-lookup"><span data-stu-id="89f63-174">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="89f63-175">L’expression case `default` est évaluée en dernier, quel que soit son ordre textuel.</span><span class="sxs-lookup"><span data-stu-id="89f63-175">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="89f63-176">S’il n’existe aucun cas `default` ni aucune correspondance avec les autres instructions `case`, l’exécution passe à l’instruction suivant l’instruction `switch`.</span><span class="sxs-lookup"><span data-stu-id="89f63-176">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="89f63-177">Aucun code d’étiquettes `case` n’est exécuté.</span><span class="sxs-lookup"><span data-stu-id="89f63-177">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="89f63-178">Clauses `when` dans les expressions `case`</span><span class="sxs-lookup"><span data-stu-id="89f63-178">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="89f63-179">Vous pouvez créer des expressions case spéciales pour les formes de surface 0 en ajoutant une clause `when` dans l’étiquette `case`.</span><span class="sxs-lookup"><span data-stu-id="89f63-179">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="89f63-180">Un carré avec une longueur de côté de 0, ou un cercle de rayon 0, a une surface égale à 0.</span><span class="sxs-lookup"><span data-stu-id="89f63-180">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="89f63-181">Vous spécifiez cette condition en ajoutant une clause `when` dans l’étiquette `case` :</span><span class="sxs-lookup"><span data-stu-id="89f63-181">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="89f63-182">Cette modification illustre quelques points importants relatifs à la nouvelle syntaxe.</span><span class="sxs-lookup"><span data-stu-id="89f63-182">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="89f63-183">Tout d’abord, plusieurs étiquettes `case` peuvent être appliquées à une même section `switch`.</span><span class="sxs-lookup"><span data-stu-id="89f63-183">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="89f63-184">Le bloc d’instructions est exécuté quand l’une de ces étiquettes est `true`.</span><span class="sxs-lookup"><span data-stu-id="89f63-184">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="89f63-185">Dans ce cas, si l’expression `switch` est un cercle ou un carré de surface 0, la méthode retourne la constante 0.</span><span class="sxs-lookup"><span data-stu-id="89f63-185">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="89f63-186">Cet exemple introduit deux variables différentes dans les deux étiquettes `case` du premier bloc `switch`.</span><span class="sxs-lookup"><span data-stu-id="89f63-186">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="89f63-187">Notez que les instructions de ce bloc `switch` n’utilisent ni la variable `c` (pour le cercle), ni la variable `s` (pour le carré).</span><span class="sxs-lookup"><span data-stu-id="89f63-187">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="89f63-188">Aucune de ces variables n’est assignée de manière définitive dans ce bloc `switch`.</span><span class="sxs-lookup"><span data-stu-id="89f63-188">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="89f63-189">Si l’une de ces étiquettes case correspond, cela signifie qu’une des variables a été assignée.</span><span class="sxs-lookup"><span data-stu-id="89f63-189">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="89f63-190">Toutefois, il est impossible de déterminer *laquelle* a été assignée au moment de la compilation, car les deux cas peuvent correspondre à l’exécution.</span><span class="sxs-lookup"><span data-stu-id="89f63-190">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="89f63-191">C’est pourquoi, la plupart du temps, quand on utilise plusieurs étiquettes `case` dans le même bloc, on n’introduit pas de nouvelle variable dans l’instruction `case` ou on ne l’utilise que dans la clause `when`.</span><span class="sxs-lookup"><span data-stu-id="89f63-191">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="89f63-192">Après avoir ajouté ces formes de surface 0, ajoutez deux autres types de formes, un rectangle et un triangle :</span><span class="sxs-lookup"><span data-stu-id="89f63-192">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="89f63-193">Avec cet ensemble de modifications, vous avez ajouté des étiquettes `case` pour l’expression case dégénérée, ainsi que des étiquettes et des blocs pour chacune des nouvelles formes.</span><span class="sxs-lookup"><span data-stu-id="89f63-193">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span>

<span data-ttu-id="89f63-194">Enfin, vous pouvez ajouter un cas `null` pour que l’argument ne soit pas `null` :</span><span class="sxs-lookup"><span data-stu-id="89f63-194">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="89f63-195">Le comportement spécial pour le `null` modèle est intéressant, car la constante du `null` modèle n’a pas de type mais peut être convertie en un type référence ou un type valeur Nullable.</span><span class="sxs-lookup"><span data-stu-id="89f63-195">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable value type.</span></span> <span data-ttu-id="89f63-196">Plutôt que de convertir une valeur `null` en un type quelconque, le langage définit qu’une valeur `null` ne correspond à aucun modèle de type, quel que soit le type de la variable au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="89f63-196">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="89f63-197">En raison de ce comportement, le nouveau modèle de type basé sur `switch` est cohérent par rapport à l’instruction `is` : les instructions `is` retournent toujours `false` quand la valeur vérifiée est `null`.</span><span class="sxs-lookup"><span data-stu-id="89f63-197">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="89f63-198">Il est aussi plus simple : une fois le type vérifié, aucun autre contrôle de valeur Null n’est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="89f63-198">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="89f63-199">On constate en effet qu’aucune vérification de ce type ne figure dans les blocs de cas des exemples ci-dessus : ces contrôles ne sont pas requis dans la mesure où la correspondance avec le modèle de type garantit une valeur non Null.</span><span class="sxs-lookup"><span data-stu-id="89f63-199">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="89f63-200">Déclarations `var` dans les expressions `case`</span><span class="sxs-lookup"><span data-stu-id="89f63-200">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="89f63-201">L’introduction de `var` comme l’une des expressions de correspondance fournit de nouvelles règles pour les critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="89f63-201">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="89f63-202">La première règle est que la déclaration `var` suit les règles standard d’inférence de type, à savoir que le type est supposé être le type statique de l’expression switch.</span><span class="sxs-lookup"><span data-stu-id="89f63-202">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="89f63-203">Avec cette règle, il y a toujours correspondance du type.</span><span class="sxs-lookup"><span data-stu-id="89f63-203">From that rule, the type always matches.</span></span>

<span data-ttu-id="89f63-204">La deuxième règle est qu’une déclaration `var` n’a pas le contrôle de valeur Null que comportent d’autres expressions de modèle de type.</span><span class="sxs-lookup"><span data-stu-id="89f63-204">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="89f63-205">La variable peut donc être Null, et une vérification de valeur Null est alors nécessaire.</span><span class="sxs-lookup"><span data-stu-id="89f63-205">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="89f63-206">Ces deux règles signifient que, dans de nombreux cas, une déclaration `var` dans une expression `case` remplit les mêmes conditions qu’une expression `default`.</span><span class="sxs-lookup"><span data-stu-id="89f63-206">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="89f63-207">Étant donné qu’une expression case non définie par défaut est toujours préférée à l’expression case `default`, l’expression case `default` n’est jamais exécutée.</span><span class="sxs-lookup"><span data-stu-id="89f63-207">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="89f63-208">Le compilateur n’émet pas d’avertissement pour signaler qu’une expression case `default` écrite ne peut pas s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="89f63-208">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="89f63-209">Cela est cohérent avec le comportement actuel de l’instruction `switch` où tous les cas possibles ont été répertoriés.</span><span class="sxs-lookup"><span data-stu-id="89f63-209">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="89f63-210">La troisième règle présente les cas où l’utilisation d’une expression case `var` peut être appropriée.</span><span class="sxs-lookup"><span data-stu-id="89f63-210">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="89f63-211">Supposons que vous utilisiez des critères spéciaux dont l’entrée est une chaîne et que vous recherchiez des valeurs de commande connues.</span><span class="sxs-lookup"><span data-stu-id="89f63-211">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="89f63-212">Vous pouvez écrire un code similaire à celui-ci :</span><span class="sxs-lookup"><span data-stu-id="89f63-212">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="89f63-213">L’instruction case `var` correspond à une valeur `null`, une chaîne vide ou une chaîne composée uniquement d’espaces blancs.</span><span class="sxs-lookup"><span data-stu-id="89f63-213">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="89f63-214">On remarque que le code ci-dessus utilise l’opérateur `?.` pour empêcher la levée accidentelle d’une <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="89f63-214">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="89f63-215">Le cas `default` gère toutes les autres valeurs de chaîne qui ne sont pas comprises par cet analyseur de commande.</span><span class="sxs-lookup"><span data-stu-id="89f63-215">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="89f63-216">Il s’agit d’un exemple où vous pouvez envisager d’utiliser une expression case `var` différente d’une expression `default`.</span><span class="sxs-lookup"><span data-stu-id="89f63-216">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="89f63-217">Conclusions</span><span class="sxs-lookup"><span data-stu-id="89f63-217">Conclusions</span></span>

<span data-ttu-id="89f63-218">Les *constructions de critères spéciaux* permettent de gérer facilement le flux de contrôle entre différents types et variables qui ne sont pas liés par une hiérarchie d’héritage.</span><span class="sxs-lookup"><span data-stu-id="89f63-218">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="89f63-219">Vous pouvez également contrôler la logique pour utiliser n’importe quelle condition testée sur la variable.</span><span class="sxs-lookup"><span data-stu-id="89f63-219">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="89f63-220">Ces constructions permettent d’utiliser les modèles et les idiomes dont vous aurez davantage besoin à mesure que vous créez d’autres applications distribuées, où les données et les méthodes qui les manipulent sont séparées.</span><span class="sxs-lookup"><span data-stu-id="89f63-220">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="89f63-221">Vous remarquerez que les structs de formes utilisés dans cet exemple ne contiennent pas de méthodes, mais seulement des propriétés en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="89f63-221">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="89f63-222">Les critères spéciaux peuvent être utilisés avec tous les types de données.</span><span class="sxs-lookup"><span data-stu-id="89f63-222">Pattern Matching works with any data type.</span></span> <span data-ttu-id="89f63-223">Vous écrivez des expressions qui examinent l’objet et vous prenez des décisions de flux de contrôle en fonction de ces conditions.</span><span class="sxs-lookup"><span data-stu-id="89f63-223">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="89f63-224">Comparez le code de cet exemple avec la conception qui résulterait de la création d’une hiérarchie de classes pour une `Shape` abstraite et des formes dérivées spécifiques, chacune avec sa propre implémentation d’une méthode virtuelle pour calculer la surface.</span><span class="sxs-lookup"><span data-stu-id="89f63-224">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="89f63-225">Les expressions de critères spéciaux vous seront souvent d’une grande utilité quand vous voudrez manipuler des données en gérant les questions de stockage de données séparément des questions de comportement.</span><span class="sxs-lookup"><span data-stu-id="89f63-225">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="89f63-226">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="89f63-226">See also</span></span>

- [<span data-ttu-id="89f63-227">Didacticiel : utilisation des fonctionnalités de critères spéciaux pour étendre des types de données</span><span class="sxs-lookup"><span data-stu-id="89f63-227">Tutorial: Using pattern matching features to extend data types</span></span>](tutorials/pattern-matching.md)
