---
title: Méthodes - Guide du C#
description: Vue d’ensemble des méthodes, des paramètres de méthode et des valeurs de retour des méthodes
ms.technology: csharp-fundamentals
ms.date: 05/21/2018
ms.assetid: 577a8527-1081-4b36-9b9e-0685b6553c6e
ms.openlocfilehash: ea07553d20ea6c18bac048a2e8d697f665bfb949
ms.sourcegitcommit: 0802ac583585110022beb6af8ea0b39188b77c43
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/25/2020
ms.locfileid: "96031674"
---
# <a name="methods-in-c"></a><span data-ttu-id="e2b8e-103">Méthodes dans (C#)</span><span class="sxs-lookup"><span data-stu-id="e2b8e-103">Methods in (C#)</span></span>

<span data-ttu-id="e2b8e-104">Une méthode est un bloc de code qui contient une série d'instructions.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-104">A method is a code block that contains a series of statements.</span></span> <span data-ttu-id="e2b8e-105">Un programme provoque l'exécution des instructions en appelant la méthode et en spécifiant les éventuels arguments de méthode requis.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-105">A program causes the statements to be executed by calling the method and specifying any required method arguments.</span></span> <span data-ttu-id="e2b8e-106">En C#, chaque instruction exécutée est effectuée dans le contexte d'une méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-106">In C#, every executed instruction is performed in the context of a method.</span></span> <span data-ttu-id="e2b8e-107">La méthode `Main` est le point d’entrée de chaque application C# et elle est appelée par le Common Language Runtime (CLR) au démarrage du programme.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-107">The `Main` method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.</span></span>

> [!NOTE]
> <span data-ttu-id="e2b8e-108">Cette rubrique décrit les méthodes nommées.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-108">This topic discusses named methods.</span></span> <span data-ttu-id="e2b8e-109">Pour plus d’informations sur les fonctions anonymes, consultez [Fonctions anonymes](programming-guide/statements-expressions-operators/anonymous-functions.md).</span><span class="sxs-lookup"><span data-stu-id="e2b8e-109">For information about anonymous functions, see [Anonymous Functions](programming-guide/statements-expressions-operators/anonymous-functions.md).</span></span>

<a name="signatures"></a>

## <a name="method-signatures"></a><span data-ttu-id="e2b8e-110">Signatures de méthode</span><span class="sxs-lookup"><span data-stu-id="e2b8e-110">Method signatures</span></span>

<span data-ttu-id="e2b8e-111">Les méthodes sont déclarées dans une `class` ou une `struct` en spécifiant :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-111">Methods are declared in a `class` or `struct` by specifying:</span></span>

- <span data-ttu-id="e2b8e-112">Un niveau d’accès facultatif, comme `public` ou `private`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-112">An optional access level, such as `public` or `private`.</span></span> <span data-ttu-id="e2b8e-113">La valeur par défaut est `private`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-113">The default is `private`.</span></span>
- <span data-ttu-id="e2b8e-114">Des modificateurs facultatifs, comme `abstract` ou `sealed`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-114">Optional modifiers such as `abstract` or `sealed`.</span></span>
- <span data-ttu-id="e2b8e-115">La valeur de retour, ou `void` si la méthode n’en a pas.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-115">The return value, or `void` if the method has none.</span></span>
- <span data-ttu-id="e2b8e-116">Nom de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-116">The method name.</span></span>
- <span data-ttu-id="e2b8e-117">Des paramètres de méthodes.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-117">Any method parameters.</span></span> <span data-ttu-id="e2b8e-118">Les paramètres de méthode sont placés entre parenthèses et séparés par des virgules.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-118">Method parameters are enclosed in parentheses and are separated by commas.</span></span> <span data-ttu-id="e2b8e-119">Des parenthèses vides indiquent que la méthode ne requiert aucun paramètre.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-119">Empty parentheses indicate that the method requires no parameters.</span></span>

<span data-ttu-id="e2b8e-120">Ces parties forment ensemble la signature de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-120">These parts together form the method signature.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e2b8e-121">Un type de retour d'une méthode ne fait pas partie de la signature de la méthode à des fins de surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-121">A return type of a method is not part of the signature of the method for the purposes of method overloading.</span></span> <span data-ttu-id="e2b8e-122">Toutefois, il fait partie de la signature de la méthode lors de la détermination de la compatibilité entre un délégué et la méthode vers laquelle il pointe.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-122">However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</span></span>

<span data-ttu-id="e2b8e-123">L’exemple suivant définit une classe nommée `Motorcycle` qui contient cinq méthodes :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-123">The following example defines a class named `Motorcycle` that contains five methods:</span></span>

[!code-csharp[csSnippets.Methods#40](../../samples/snippets/csharp/concepts/methods/methods40.cs#40)]

<span data-ttu-id="e2b8e-124">Notez que la classe `Motorcycle` inclut une méthode surchargée, `Drive`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-124">Note that the `Motorcycle` class includes an overloaded method, `Drive`.</span></span> <span data-ttu-id="e2b8e-125">Deux méthodes ont le même nom, mais doivent être différenciées par leurs types de paramètre.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-125">Two methods have the same name, but must be differentiated by their parameter types.</span></span>

<a name="invocation"></a>

## <a name="method-invocation"></a><span data-ttu-id="e2b8e-126">Appel de méthode</span><span class="sxs-lookup"><span data-stu-id="e2b8e-126">Method invocation</span></span>

<span data-ttu-id="e2b8e-127">Les méthodes peuvent être *d’instance* ou *statiques*.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-127">Methods can be either *instance* or *static*.</span></span> <span data-ttu-id="e2b8e-128">L’appel d’une méthode d’instance nécessite l’instanciation d’un objet et l’appel de la méthode sur cet objet ; une méthode d’instance agit sur cette instance et sur ses données.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-128">Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data.</span></span> <span data-ttu-id="e2b8e-129">Vous appelez une méthode statique en référençant le nom du type auquel la méthode appartient ; les méthodes statiques n’agissent pas sur les données d’une instance.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-129">You invoke a static method by referencing the name of the type to which the method belongs; static methods do not operate on instance data.</span></span> <span data-ttu-id="e2b8e-130">Une tentative d’appeler une méthode statique via une instance d’objet génère une erreur du compilateur.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-130">Attempting to call a static method through an object instance generates a compiler error.</span></span>

<span data-ttu-id="e2b8e-131">Appeler une méthode est comme accéder à un champ.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-131">Calling a method is like accessing a field.</span></span> <span data-ttu-id="e2b8e-132">Après le nom d’objet (si vous appelez une méthode d’instance) ou le nom de type (si vous appelez une méthode `static`), ajoutez un point, le nom de la méthode et des parenthèses.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-132">After the object name (if you are calling an instance method) or the type name (if you are calling a `static` method), add a period, the name of the method, and parentheses.</span></span> <span data-ttu-id="e2b8e-133">Les arguments sont répertoriés entre parenthèses et séparés par des virgules.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-133">Arguments are listed within the parentheses and are separated by commas.</span></span>

<span data-ttu-id="e2b8e-134">La définition de la méthode spécifie les noms et types des paramètres requis.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-134">The method definition specifies the names and types of any parameters that are required.</span></span> <span data-ttu-id="e2b8e-135">Quand un appelant appelle la méthode, il fournit des valeurs réelles, appelées « arguments », pour chaque paramètre.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-135">When a caller invokes the method, it provides concrete values, called arguments, for each parameter.</span></span> <span data-ttu-id="e2b8e-136">Les arguments doivent être compatibles avec le type de paramètre, mais le nom de l’argument, si un nom est utilisé dans le code appelant, ne doit pas nécessairement être le même que celui du paramètre défini dans la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-136">The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method.</span></span> <span data-ttu-id="e2b8e-137">Dans l’exemple suivant, la méthode `Square` comprend un seul paramètre de type `int` nommé *i*.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-137">In the following example, the `Square` method includes a single parameter of type `int` named *i*.</span></span> <span data-ttu-id="e2b8e-138">Le premier appel de la méthode passe à la méthode `Square` une variable de type `int` nommée *num*, le deuxième appel passe une constante numérique et le troisième appel passe une expression.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-138">The first method call passes the `Square` method a variable of type `int` named *num*; the second, a numeric constant; and the third, an expression.</span></span>

[!code-csharp[csSnippets.Methods#74](../../samples/snippets/csharp/concepts/methods/params74.cs#74)]

<span data-ttu-id="e2b8e-139">La forme la plus courante des appels de méthode utilise des arguments de position ; elle fournit les arguments dans le même ordre que celui des paramètres de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-139">The most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters.</span></span> <span data-ttu-id="e2b8e-140">Les méthodes de la classe `Motorcycle` peuvent donc être appelées comme dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-140">The methods of the `Motorcycle` class can therefore be called as in the following example.</span></span> <span data-ttu-id="e2b8e-141">Par exemple, l’appel à la méthode `Drive` comprend deux arguments qui correspondent aux deux paramètres de la syntaxe de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-141">The call to the `Drive` method, for example, includes two arguments that correspond to the two parameters in the method's syntax.</span></span> <span data-ttu-id="e2b8e-142">Le premier devient la valeur du paramètre `miles` et le deuxième devient la valeur du paramètre `speed`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-142">The first becomes the value of the `miles` parameter, the second the value of the `speed` parameter.</span></span>

[!code-csharp[csSnippets.Methods#41](../../samples/snippets/csharp/concepts/methods/methods40.cs#41)]

<span data-ttu-id="e2b8e-143">Vous pouvez également utiliser des *arguments nommés* au lieu des arguments positionnels lors de l’appel d’une méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-143">You can also use *named arguments* instead of positional arguments when invoking a method.</span></span> <span data-ttu-id="e2b8e-144">Lors de l’utilisation d’arguments nommés, vous spécifiez le nom du paramètre suivi de deux-points (« : ») et de l’argument.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-144">When using named arguments, you specify the parameter name followed by a colon (":") and the argument.</span></span> <span data-ttu-id="e2b8e-145">Les arguments de la méthode peuvent apparaître dans n’importe quel ordre, dès lors que tous les arguments nécessaires sont présents.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-145">Arguments to the method can appear in any order, as long as all required arguments are present.</span></span> <span data-ttu-id="e2b8e-146">L’exemple suivant utilise des arguments nommés pour appeler la méthode `TestMotorcycle.Drive`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-146">The following example uses named arguments to invoke the `TestMotorcycle.Drive` method.</span></span> <span data-ttu-id="e2b8e-147">Dans cet exemple, les arguments nommés sont passés dans l’ordre inverse de celui de la liste des paramètres de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-147">In this example, the named arguments are passed in the opposite order from the method's parameter list.</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/named1.cs#45)]

<span data-ttu-id="e2b8e-148">Vous pouvez appeler une méthode en utilisant à la fois des arguments positionnels et des arguments nommés.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-148">You can invoke a method using both positional arguments and named arguments.</span></span> <span data-ttu-id="e2b8e-149">Toutefois, les arguments positionnels peuvent uniquement suivre des arguments nommés lorsque les arguments nommés sont dans les positions appropriées.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-149">However, positional arguments can only follow named arguments when the named arguments are in the correct positions.</span></span> <span data-ttu-id="e2b8e-150">L’exemple suivant appelle la méthode `TestMotorcycle.Drive` de l’exemple précédent en utilisant un argument positionnel et un argument nommé.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-150">The following example invokes the `TestMotorcycle.Drive` method from the previous example using one positional argument and one named argument.</span></span>

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/named2.cs#46)]

<a name="inherited"></a>

## <a name="inherited-and-overridden-methods"></a><span data-ttu-id="e2b8e-151">Méthodes hérités et remplacées</span><span class="sxs-lookup"><span data-stu-id="e2b8e-151">Inherited and overridden methods</span></span>

<span data-ttu-id="e2b8e-152">En plus des membres qui sont définis explicitement dans un type, un type hérite des membres définis dans ses classes de base.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-152">In addition to the members that are explicitly defined in a type, a type inherits members defined in its base classes.</span></span> <span data-ttu-id="e2b8e-153">Comme tous les types du système de types managés héritent directement ou indirectement de la classe <xref:System.Object>, tous les types héritent ses membres, comme <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType> et <xref:System.Object.ToString>.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-153">Since all types in the managed type system inherit directly or indirectly from the <xref:System.Object> class, all types inherit its members, such as <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType>, and <xref:System.Object.ToString>.</span></span> <span data-ttu-id="e2b8e-154">L’exemple suivant définit une classe `Person`, instancie deux objets `Person` et appelle la méthode `Person.Equals` pour déterminer si les deux objets sont égaux.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-154">The following example defines a `Person` class, instantiates two `Person` objects, and calls the `Person.Equals` method to determine whether the two objects are equal.</span></span> <span data-ttu-id="e2b8e-155">La méthode `Equals` n’est cependant pas définie dans la classe `Person` ; elle est héritée de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-155">The `Equals` method, however, is not defined in the `Person` class; it is inherited from <xref:System.Object>.</span></span>

[!code-csharp[csSnippets.Methods#104](../../samples/snippets/csharp/concepts/methods/inherited1.cs#104)]

<span data-ttu-id="e2b8e-156">Vous pouvez remplacer des membres hérités par des types en utilisant le mot clé `override` et en fournissant une implémentation de la méthode remplacée.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-156">Types can override inherited members by using the `override` keyword and providing an implementation for the overridden method.</span></span> <span data-ttu-id="e2b8e-157">La signature de la méthode doit être identique à celle de la méthode remplacée.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-157">The method signature must be the same as that of the overridden method.</span></span> <span data-ttu-id="e2b8e-158">L’exemple suivant est semblable au précédent, sauf qu’il remplace la méthode <xref:System.Object.Equals(System.Object)>.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-158">The following example is like the previous one, except that it overrides the <xref:System.Object.Equals(System.Object)> method.</span></span> <span data-ttu-id="e2b8e-159">(Il remplace aussi la méthode <xref:System.Object.GetHashCode>, car les deux méthodes sont destinées à fournir des résultats cohérents.)</span><span class="sxs-lookup"><span data-stu-id="e2b8e-159">(It also overrides the <xref:System.Object.GetHashCode> method, since the two methods are intended to provide consistent results.)</span></span>

[!code-csharp[csSnippets.Methods#105](../../samples/snippets/csharp/concepts/methods/overridden1.cs#105)]

<a name="passing"></a>

## <a name="passing-parameters"></a><span data-ttu-id="e2b8e-160">Passage de paramètres</span><span class="sxs-lookup"><span data-stu-id="e2b8e-160">Passing parameters</span></span>

<span data-ttu-id="e2b8e-161">Les types en C# sont des *types valeur* ou des *types référence*.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-161">Types in C# are either *value types* or *reference types*.</span></span> <span data-ttu-id="e2b8e-162">Pour obtenir la liste des types valeur intégrés, consultez [types](./tour-of-csharp/types.md).</span><span class="sxs-lookup"><span data-stu-id="e2b8e-162">For a list of built-in value types, see [Types](./tour-of-csharp/types.md).</span></span> <span data-ttu-id="e2b8e-163">Par défaut, les types valeur et les types référence sont passés par valeur à une méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-163">By default, both value types and reference types are passed to a method by value.</span></span>

<a name="byval"></a>

### <a name="passing-parameters-by-value"></a><span data-ttu-id="e2b8e-164">Passage de paramètres par valeur</span><span class="sxs-lookup"><span data-stu-id="e2b8e-164">Passing parameters by value</span></span>

<span data-ttu-id="e2b8e-165">Quand un type valeur est passé par valeur à une méthode, c’est une copie de l’objet, et non pas l’objet lui-même, qui est passée à la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-165">When a value type is passed to a method by value, a copy of the object instead of the object itself is passed to the method.</span></span> <span data-ttu-id="e2b8e-166">Par conséquent, les modifications de l’objet dans la méthode appelée n’ont pas d’effet sur l’objet d’origine quand le contrôle retourne à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-166">Therefore, changes to the object in the called method have no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="e2b8e-167">L’exemple suivant passe un type valeur à une méthode par valeur, et la méthode appelée tente de changer la valeur du type valeur.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-167">The following example passes a value type to a method by value, and the called method attempts to change the value type's value.</span></span> <span data-ttu-id="e2b8e-168">Il définit une variable de type `int`, qui est un type valeur, initialise sa valeur à 20 et la passe à une méthode nommée `ModifyValue` qui change la valeur de la variable en 30.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-168">It defines a variable of type `int`, which is a value type, initializes its value to 20, and passes it to a method named `ModifyValue` that changes the variable's value to 30.</span></span> <span data-ttu-id="e2b8e-169">Quand la méthode retourne, la valeur de la variable reste cependant inchangée.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-169">When the method returns, however, the variable's value remains unchanged.</span></span>

[!code-csharp[csSnippets.Methods#10](../../samples/snippets/csharp/concepts/methods/byvalue10.cs#10)]

<span data-ttu-id="e2b8e-170">Quand un objet d’un type référence est passé par valeur à une méthode, c’est une référence à l’objet qui est passée par valeur.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-170">When an object of a reference type is passed to a method by value, a reference to the object is passed by value.</span></span> <span data-ttu-id="e2b8e-171">Autrement dit, la méthode ne reçoit pas l’objet lui-même mais un argument qui indique l’emplacement de l’objet.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-171">That is, the method receives not the object itself, but an argument that indicates the location of the object.</span></span> <span data-ttu-id="e2b8e-172">Si vous modifiez un membre de l’objet en utilisant cette référence, la modification est répercutée dans l’objet quand le contrôle retourne à la méthode appelante.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-172">If you change a member of the object by using this reference, the change is reflected in the object when control returns to the calling method.</span></span> <span data-ttu-id="e2b8e-173">Cependant, remplacer l’objet passé à la méthode n’a pas d’effet sur l’objet d’origine quand le contrôle retourne à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-173">However, replacing the object passed to the method has no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="e2b8e-174">L’exemple suivant définit une classe (qui est un type référence) nommée `SampleRefType`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-174">The following example defines a class (which is a reference type) named `SampleRefType`.</span></span> <span data-ttu-id="e2b8e-175">Il instancie un objet `SampleRefType`, affecte la valeur 44 à son champ `value` et passe l’objet à la méthode `ModifyObject`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-175">It instantiates a `SampleRefType` object, assigns 44 to its `value` field, and passes the object to the `ModifyObject` method.</span></span> <span data-ttu-id="e2b8e-176">L’exemple fait essentiellement la même chose que l’exemple précédent : il passe un argument par valeur à une méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-176">This example does essentially the same thing as the previous example -- it passes an argument by value to a method.</span></span> <span data-ttu-id="e2b8e-177">Cependant, comme il utilise un type référence, le résultat est différent.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-177">But because a reference type is used, the result is different.</span></span> <span data-ttu-id="e2b8e-178">La modification apportée dans `ModifyObject` au champ `obj.value` change également en 33 le champ `value` de l’argument `rt` dans la méthode `Main`, comme le montre le résultat de l’exemple.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-178">The modification that is made in `ModifyObject` to the `obj.value` field also changes the `value` field of the argument, `rt`, in the `Main` method to 33, as the output from the example shows.</span></span>

[!code-csharp[csSnippets.Methods#42](../../samples/snippets/csharp/concepts/methods/byvalue42.cs#42)]

<a name="byref"></a>

### <a name="passing-parameters-by-reference"></a><span data-ttu-id="e2b8e-179">Passage de paramètres par référence</span><span class="sxs-lookup"><span data-stu-id="e2b8e-179">Passing parameters by reference</span></span>

<span data-ttu-id="e2b8e-180">On passe un paramètre par référence quand on souhaite changer la valeur d’un argument dans une méthode et refléter cette modification lorsque le contrôle revient à la méthode appelante.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-180">You pass a parameter by reference when you want to change the value of an argument in a method and want to reflect that change when control returns to the calling method.</span></span> <span data-ttu-id="e2b8e-181">Pour passer un paramètre par référence, vous utilisez le [`ref`](language-reference/keywords/ref.md) [`out`](language-reference/keywords/out-parameter-modifier.md) mot clé ou.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-181">To pass a parameter by reference, you use the [`ref`](language-reference/keywords/ref.md) or [`out`](language-reference/keywords/out-parameter-modifier.md) keyword.</span></span> <span data-ttu-id="e2b8e-182">Vous pouvez également passer une valeur par référence pour éviter de copier tout en empêchant les modifications à l’aide du [`in`](language-reference/keywords/in-parameter-modifier.md) mot clé.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-182">You can also pass a value by reference to avoid copying but still prevent modifications using the [`in`](language-reference/keywords/in-parameter-modifier.md) keyword.</span></span>

<span data-ttu-id="e2b8e-183">L’exemple suivant est identique au précédent, sauf que la valeur est passée par référence à la méthode `ModifyValue`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-183">The following example is identical to the previous one, except the value is passed by reference to the `ModifyValue` method.</span></span> <span data-ttu-id="e2b8e-184">Quand la valeur du paramètre est modifiée dans la méthode `ModifyValue`, le changement de la valeur est reflété quand le contrôle retourne à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-184">When the value of the parameter is modified in the `ModifyValue` method, the change in value is reflected when control returns to the caller.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref106.cs#106)]

<span data-ttu-id="e2b8e-185">Un modèle courant qui utilise des paramètres par référence implique la permutation des valeurs des variables.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-185">A common pattern that uses by ref parameters involves swapping the values of variables.</span></span> <span data-ttu-id="e2b8e-186">Vous passez deux variables à une méthode par référence, et la méthode permute leur contenu.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-186">You pass two variables to a method by reference, and the method swaps their contents.</span></span> <span data-ttu-id="e2b8e-187">L’exemple suivant permute des valeurs d’entier.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-187">The following example swaps integer values.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/swap107.cs#107)]

<span data-ttu-id="e2b8e-188">Passer un paramètre de type référence vous permet de changer la valeur de la référence elle-même, au lieu de la valeur de ses éléments ou champs individuels.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-188">Passing a reference-type parameter allows you to change the value of the reference itself, rather than the value of its individual elements or fields.</span></span>

<a name="paramarray"></a>

### <a name="parameter-arrays"></a><span data-ttu-id="e2b8e-189">Tableaux de paramètres</span><span class="sxs-lookup"><span data-stu-id="e2b8e-189">Parameter arrays</span></span>

<span data-ttu-id="e2b8e-190">Parfois, l’obligation de spécifier le nombre exact d’arguments de votre méthode est restrictive.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-190">Sometimes, the requirement that you specify the exact number of arguments to your method is restrictive.</span></span> <span data-ttu-id="e2b8e-191">En utilisant le mot clé `params` pour indiquer qu’un paramètre est un tableau de paramètres, vous permettez que votre méthode soit appelée avec un nombre variable d’arguments.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-191">By using the `params` keyword to indicate that a parameter is a parameter array, you allow your method to be called with a variable number of arguments.</span></span> <span data-ttu-id="e2b8e-192">Le paramètre marqué avec le mot clé `params` doit être un type tableau. Ce doit être le dernier paramètre de la liste de paramètres de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-192">The parameter tagged with the `params` keyword must be an array type, and it must be the last parameter in the method's parameter list.</span></span>

<span data-ttu-id="e2b8e-193">Un appelant peut ensuite appeler la méthode de l’une des quatre manières suivantes :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-193">A caller can then invoke the method in either of four ways:</span></span>

- <span data-ttu-id="e2b8e-194">En passant un tableau du type approprié, qui contient le nombre d’éléments souhaité.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-194">By passing an array of the appropriate type that contains the desired number of elements.</span></span>
- <span data-ttu-id="e2b8e-195">En passant une liste d’arguments individuels séparés par des virgules et du type approprié à la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-195">By passing a comma-separated list of individual arguments of the appropriate type to the method.</span></span>
- <span data-ttu-id="e2b8e-196">En passant `null` .</span><span class="sxs-lookup"><span data-stu-id="e2b8e-196">By passing `null`.</span></span>
- <span data-ttu-id="e2b8e-197">En ne fournissant pas d’argument au tableau de paramètres.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-197">By not providing an argument to the parameter array.</span></span>

<span data-ttu-id="e2b8e-198">L’exemple suivant définit une méthode nommée `GetVowels` qui retourne toutes les voyelles à partir d’un tableau de paramètres.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-198">The following example defines a method named `GetVowels` that returns all the vowels from a parameter array.</span></span> <span data-ttu-id="e2b8e-199">La `Main` méthode illustre les quatre façons d’appeler la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-199">The `Main` method illustrates all four ways of invoking the method.</span></span> <span data-ttu-id="e2b8e-200">Les appelants n’ont pas nécessairement à fournir tous les arguments pour les paramètres qui incluent le modificateur `params`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-200">Callers are not required to supply any arguments for parameters that include the `params` modifier.</span></span> <span data-ttu-id="e2b8e-201">Dans ce cas, le paramètre est un tableau vide.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-201">In that case, the parameter is an empty array.</span></span>

[!code-csharp[csSnippets.Methods#75](~/samples/snippets/csharp/concepts/methods/params75.cs#75)]

<a name="optional"></a>

## <a name="optional-parameters-and-arguments"></a><span data-ttu-id="e2b8e-202">Paramètres et arguments facultatifs</span><span class="sxs-lookup"><span data-stu-id="e2b8e-202">Optional parameters and arguments</span></span>

<span data-ttu-id="e2b8e-203">Une définition de méthode peut spécifier que ses paramètres sont obligatoires ou facultatifs.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-203">A method definition can specify that its parameters are required or that they are optional.</span></span> <span data-ttu-id="e2b8e-204">Par défaut, les paramètres sont obligatoires.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-204">By default, parameters are required.</span></span> <span data-ttu-id="e2b8e-205">Vous spécifiez des paramètres facultatifs en incluant la valeur par défaut du paramètre dans la définition de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-205">Optional parameters are specified by including the parameter's default value in the method definition.</span></span> <span data-ttu-id="e2b8e-206">Quand la méthode est appelée, si aucun argument n’est fourni pour un paramètre facultatif, c’est la valeur par défaut qui est utilisée à la place.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-206">When the method is called, if no argument is supplied for an optional parameter, the default value is used instead.</span></span>

<span data-ttu-id="e2b8e-207">La valeur par défaut du paramètre doit être affectée par un des types d’expressions suivants :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-207">The parameter's default value must be assigned by one of the following kinds of expressions:</span></span>

- <span data-ttu-id="e2b8e-208">Une constante, comme une chaîne littérale ou un nombre.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-208">A constant, such as a literal string or number.</span></span>
- <span data-ttu-id="e2b8e-209">Une expression de la forme `new ValType()`, où `ValType` est un type valeur.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-209">An expression of the form `new ValType()`, where `ValType` is a value type.</span></span> <span data-ttu-id="e2b8e-210">Notez que ceci appelle le constructeur sans paramètre implicite du type valeur, qui n’est pas un membre réel du type.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-210">Note that this invokes the value type's implicit parameterless constructor, which is not an actual member of the type.</span></span>
- <span data-ttu-id="e2b8e-211">Une expression de la forme `default(ValType)`, où `ValType` est un type valeur.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-211">An expression of the form `default(ValType)`, where `ValType` is a value type.</span></span>

<span data-ttu-id="e2b8e-212">Si une méthode comprend à la fois des paramètres obligatoires et des paramètres facultatifs, les paramètres facultatifs sont définis à la fin de la liste des paramètres, après tous les paramètres obligatoires.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-212">If a method includes both required and optional parameters, optional parameters are defined at the end of the parameter list, after all required parameters.</span></span>

<span data-ttu-id="e2b8e-213">L’exemple suivant définit une méthode, `ExampleMethod`, qui a un paramètre obligatoire et deux paramètres facultatifs.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-213">The following example defines a method, `ExampleMethod`, that has one required and two optional parameters.</span></span>

[!code-csharp[csSnippets.Methods#21](../../samples/snippets/csharp/concepts/methods/optional1.cs#21)]

<span data-ttu-id="e2b8e-214">Si une méthode avec plusieurs arguments facultatifs est appelée en utilisant des arguments positionnels, l’appelant doit fournir un argument pour tous les paramètres facultatifs, du premier au dernier pour lequel un argument est fourni.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-214">If a method with multiple optional arguments is invoked using positional arguments, the caller must supply an argument for all optional parameters from the first one to the last one for which an argument is supplied.</span></span> <span data-ttu-id="e2b8e-215">Par exemple, dans le cas de la méthode `ExampleMethod`, si l’appelant fournit un argument pour le paramètre `description`, il doit également en fournir un pour le paramètre `optionalInt`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-215">In the case of the  `ExampleMethod` method, for example, if the caller supplies an argument for the `description` parameter, it must also supply one for the `optionalInt` parameter.</span></span> <span data-ttu-id="e2b8e-216">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` est un appel de méthode valide. `opt.ExampleMethod(2, , "Addition of 2 and 0");` génère une erreur du compilateur « Argument manquant ».</span><span class="sxs-lookup"><span data-stu-id="e2b8e-216">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` is a valid method call; `opt.ExampleMethod(2, , "Addition of 2 and 0");` generates an "Argument missing" compiler error.</span></span>

<span data-ttu-id="e2b8e-217">Si une méthode est appelée en utilisant des arguments nommés ou une combinaison d’arguments positionnels et nommés, l’appelant peut omettre les arguments qui suivent le dernier argument positionnel dans l’appel de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-217">If a method is called using named arguments or a combination of positional and named arguments, the caller can omit any arguments that follow the last positional argument in the method call.</span></span>

<span data-ttu-id="e2b8e-218">L’exemple suivant appelle la méthode `ExampleMethod` trois fois.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-218">The following example calls the `ExampleMethod` method three times.</span></span>  <span data-ttu-id="e2b8e-219">Les deux premiers appels de la méthode utilisent des arguments positionnels.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-219">The first two method calls use positional arguments.</span></span> <span data-ttu-id="e2b8e-220">Le premier omet les deux arguments facultatifs, tandis que le deuxième omet le dernier argument.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-220">The first omits both optional arguments, while the second omits the last argument.</span></span> <span data-ttu-id="e2b8e-221">Le troisième appel de méthode fournit un argument positionnel pour le paramètre requis, mais utilise un argument nommé pour fournir une valeur au `description` paramètre tout en omettant l' `optionalInt` argument.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-221">The third method call supplies a positional argument for the required parameter but uses a named argument to supply a value to the `description` parameter while omitting the `optionalInt` argument.</span></span>

[!code-csharp[csSnippets.Methods#22](../../samples/snippets/csharp/concepts/methods/optional1.cs#22)]

<span data-ttu-id="e2b8e-222">L’utilisation de paramètres facultatifs affecte la *résolution de la surcharge*, qui est la façon dont le compilateur C# détermine quelle surcharge particulière doit être appelée par un appel de méthode, comme suit :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-222">The use of optional parameters affects *overload resolution*, or the way in which the C# compiler determines which particular overload should be invoked by a method call, as follows:</span></span>

- <span data-ttu-id="e2b8e-223">Une méthode, un indexeur ou un constructeur est un candidat pour l’exécution si chacun de ses paramètres est facultatif ou correspond, par nom ou par position, à un seul argument dans l’instruction appelante, et que cet argument peut être converti vers le type du paramètre.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-223">A method, indexer, or constructor is a candidate for execution if each of its parameters either is optional or corresponds, by name or by position, to a single argument in the calling statement, and that argument can be converted to the type of the parameter.</span></span>
- <span data-ttu-id="e2b8e-224">Si plusieurs candidats sont trouvés, les règles de résolution de surcharge des conversions préférées sont appliquées aux arguments qui sont explicitement spécifiés.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-224">If more than one candidate is found, overload resolution rules for preferred conversions are applied to the arguments that are explicitly specified.</span></span> <span data-ttu-id="e2b8e-225">Les arguments omis pour les paramètres facultatifs sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-225">Omitted arguments for optional parameters are ignored.</span></span>
- <span data-ttu-id="e2b8e-226">Si deux candidats sont jugés de qualité équivalente, la préférence va à celui qui n’a pas de paramètres facultatifs pour lesquels des arguments ont été omis dans l’appel.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-226">If two candidates are judged to be equally good, preference goes to a candidate that does not have optional parameters for which arguments were omitted in the call.</span></span> <span data-ttu-id="e2b8e-227">Ceci est une conséquence d’une préférence générale dans la résolution de la surcharge pour les candidats qui ont le moins de paramètres.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-227">This is a consequence of a general preference in overload resolution for candidates that have fewer parameters.</span></span>

<a name="return"></a>

## <a name="return-values"></a><span data-ttu-id="e2b8e-228">Valeurs retournées</span><span class="sxs-lookup"><span data-stu-id="e2b8e-228">Return values</span></span>

<span data-ttu-id="e2b8e-229">Les méthodes peuvent retourner une valeur à l'appelant.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-229">Methods can return a value to the caller.</span></span> <span data-ttu-id="e2b8e-230">Si le type de retour (le type qui figure avant le nom de la méthode) n’est pas `void`, la méthode peut retourner la valeur en utilisant le mot clé `return`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-230">If the return type (the type listed before the method name) is not `void`, the method can return the value by using the `return` keyword.</span></span> <span data-ttu-id="e2b8e-231">Une instruction avec le mot clé `return` suivi d’une variable, d’une constante ou d’une expression qui correspond au type de retour retourne cette valeur à l’appelant de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-231">A statement with the `return` keyword followed by a variable, constant, or expression that matches the return type will return that value to the method caller.</span></span> <span data-ttu-id="e2b8e-232">Les méthodes dotées d'un type de retour non void doivent utiliser le mot clé `return` pour retourner une valeur.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-232">Methods with a non-void return type are required to use the `return` keyword to return a value.</span></span> <span data-ttu-id="e2b8e-233">Le mot clé `return` arrête également l'exécution de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-233">The `return` keyword also stops the execution of the method.</span></span>

<span data-ttu-id="e2b8e-234">Si le type de retour est `void`, une instruction `return` sans valeur est quand même utile pour arrêter l'exécution de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-234">If the return type is `void`, a `return` statement without a value is still useful to stop the execution of the method.</span></span> <span data-ttu-id="e2b8e-235">Sans le mot clé `return` , la méthode arrête de s'exécuter quand elle atteint la fin du bloc de code.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-235">Without the `return` keyword, the method will stop executing when it reaches the end of the code block.</span></span>

<span data-ttu-id="e2b8e-236">Par exemple, ces deux méthodes utilisent le mot clé `return` pour retourner des entiers :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-236">For example, these two methods use the `return` keyword to return integers:</span></span>

[!code-csharp[csSnippets.Methods#44](../../samples/snippets/csharp/concepts/methods/return44.cs#44)]

<span data-ttu-id="e2b8e-237">Pour utiliser une valeur retournée à partir d'une méthode, la méthode d'appel peut utiliser l'appel de méthode proprement dit partout où une valeur du même type peut suffire.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-237">To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.</span></span> <span data-ttu-id="e2b8e-238">Vous pouvez également affecter la valeur de retour à une variable.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-238">You can also assign the return value to a variable.</span></span> <span data-ttu-id="e2b8e-239">Par exemple, les deux exemples de code suivants remplissent le même objectif :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-239">For example, the following two code examples accomplish the same goal:</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/return44.cs#45)]

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/return44.cs#46)]

<span data-ttu-id="e2b8e-240">L'utilisation d'une variable locale, dans cet exemple, `result`, pour stocker une valeur est facultative.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-240">Using a local variable, in this case, `result`, to store a value is optional.</span></span> <span data-ttu-id="e2b8e-241">Elle peut favoriser la lisibilité du code ou s'avérer nécessaire si vous avez besoin de stocker la valeur d'origine de l'argument pour la portée entière de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-241">It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</span></span>

<span data-ttu-id="e2b8e-242">Vous voulez parfois que votre méthode retourne plusieurs valeurs.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-242">Sometimes, you want your method to return more than a single value.</span></span> <span data-ttu-id="e2b8e-243">À compter de C# 7.0, vous pouvez faire cela facilement en utilisant des *types tuple* et des *littéraux de tuple*.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-243">Starting with C# 7.0, you can do this easily by using *tuple types* and *tuple literals*.</span></span> <span data-ttu-id="e2b8e-244">Le type tuple définit les types de données des éléments du tuple.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-244">The tuple type defines the data types of the tuple's elements.</span></span> <span data-ttu-id="e2b8e-245">Les littéraux de tuple fournissent les valeurs réelles du tuple retourné.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-245">Tuple literals provide the actual values of the returned tuple.</span></span> <span data-ttu-id="e2b8e-246">Dans l’exemple suivant, `(string, string, string, int)` définit le type tuple retourné par la méthode `GetPersonalInfo`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-246">In the following example, `(string, string, string, int)` defines the tuple type that is returned by the `GetPersonalInfo` method.</span></span> <span data-ttu-id="e2b8e-247">L’expression `(per.FirstName, per.MiddleName, per.LastName, per.Age)` est le littéral de tuple ; la méthode retourne le prénom, le deuxième prénom et le nom, ainsi que l’âge pour un objet `PersonInfo`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-247">The expression `(per.FirstName, per.MiddleName, per.LastName, per.Age)` is the tuple literal; the method returns the first, middle, and last name, along with the age, of a `PersonInfo` object.</span></span>

```csharp
public (string, string, string, int) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
```

<span data-ttu-id="e2b8e-248">L’appelant peut alors consommer le tuple retourné avec du code comme celui-ci :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-248">The caller can then consume the returned tuple with code like the following:</span></span>

```csharp
var person = GetPersonalInfo("111111111")
Console.WriteLine($"{person.Item1} {person.Item3}: age = {person.Item4}");
```

<span data-ttu-id="e2b8e-249">Vous pouvez aussi affecter des noms aux éléments du tuple dans la définition du type tuple.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-249">Names can also be assigned to the tuple elements in the tuple type definition.</span></span> <span data-ttu-id="e2b8e-250">L’exemple suivant montre une autre version de la méthode `GetPersonalInfo` qui utilise des éléments nommés :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-250">The following example shows an alternate version of the `GetPersonalInfo` method that uses named elements:</span></span>

```csharp
public (string FName, string MName, string LName, int Age) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
```

<span data-ttu-id="e2b8e-251">L’appel précédent de la méthode `GetPersonInfo` peut alors être modifié comme suit :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-251">The previous call to the `GetPersonInfo` method can then be modified as follows:</span></span>

```csharp
var person = GetPersonalInfo("111111111");
Console.WriteLine($"{person.FName} {person.LName}: age = {person.Age}");
```

<span data-ttu-id="e2b8e-252">Si un tableau est passé comme argument à une méthode et que celle-ci modifie la valeur d’éléments individuels, il n’est pas nécessaire que la méthode retourne le tableau, même si vous pouvez choisir de le faire pour la qualité du style ou pour obtenir un flux fonctionnel de valeurs.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-252">If a method is passed an array as an argument and modifies the value of individual elements, it is not necessary for the method to return the array, although you may choose to do so for good style or functional flow of values.</span></span>  <span data-ttu-id="e2b8e-253">La raison en est que C# passe tous les types référence par valeur et que la valeur d’une référence de tableau est le pointeur vers ce tableau.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-253">This is because C# passes all reference types by value, and the value of an array reference is the pointer to the array.</span></span> <span data-ttu-id="e2b8e-254">Dans l’exemple suivant, les modifications apportées au contenu du tableau `values` qui sont effectuées dans la méthode `DoubleValues` sont observables par tout code ayant une référence au tableau.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-254">In the following example, changes to the contents of the `values` array that are made in the `DoubleValues` method are observable by any code that has a reference to the array.</span></span>

[!code-csharp[csSnippets.Methods#101](../../samples/snippets/csharp/concepts/methods/returnarray1.cs#101)]

<a name="extension"></a>

## <a name="extension-methods"></a><span data-ttu-id="e2b8e-255">Méthodes d’extension</span><span class="sxs-lookup"><span data-stu-id="e2b8e-255">Extension methods</span></span>

<span data-ttu-id="e2b8e-256">En règle générale, il existe deux façons d’ajouter une méthode à un type existant :</span><span class="sxs-lookup"><span data-stu-id="e2b8e-256">Ordinarily, there are two ways to add a method to an existing type:</span></span>

- <span data-ttu-id="e2b8e-257">Modifier le code source pour ce type.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-257">Modify the source code for that type.</span></span> <span data-ttu-id="e2b8e-258">Vous ne pouvez évidemment pas le faire si vous ne disposez pas du code source du type.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-258">You cannot do this, of course, if you do not own the type's source code.</span></span> <span data-ttu-id="e2b8e-259">D’autre part, ceci devient une modification d’importance si vous ajoutez aussi des champs de données privés pour prendre en charge la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-259">And this becomes a breaking change if you also add any private data fields to support the method.</span></span>
- <span data-ttu-id="e2b8e-260">Définir la nouvelle méthode dans une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-260">Define the new method in a derived class.</span></span> <span data-ttu-id="e2b8e-261">Vous ne pouvez pas ajouter une méthode de cette façon en utilisant l’héritage pour d’autres types, comme des structures et des énumérations.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-261">A method cannot be added in this way using inheritance for other types, such as structures and enumerations.</span></span> <span data-ttu-id="e2b8e-262">Vous ne pouvez pas non plus l’utiliser pour « ajouter » une méthode à une classe scellée.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-262">Nor can it be used to "add" a method to a sealed class.</span></span>

<span data-ttu-id="e2b8e-263">Les méthodes d’extension vous permettent d’« ajouter » une méthode à un type existant sans modifier le type lui-même, ou en implémentant la nouvelle méthode dans un type hérité.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-263">Extension methods let you "add" a method to an existing type without modifying the type itself or implementing the new method in an inherited type.</span></span> <span data-ttu-id="e2b8e-264">La méthode d’extension ne doit pas non plus nécessairement se trouver dans le même assembly que le type qu’elle étend.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-264">The extension method also does not have to reside in the same assembly as the type it extends.</span></span> <span data-ttu-id="e2b8e-265">Vous appelez une méthode d’extension comme si elle était un membre défini d’un type.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-265">You call an extension method as if it were a defined member of a type.</span></span>

<span data-ttu-id="e2b8e-266">Pour plus d’informations, consultez [Méthodes d’extension](programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="e2b8e-266">For more information, see [Extension Methods](programming-guide/classes-and-structs/extension-methods.md).</span></span>

<a name="async"></a>

## <a name="async-methods"></a><span data-ttu-id="e2b8e-267">Méthodes async</span><span class="sxs-lookup"><span data-stu-id="e2b8e-267">Async Methods</span></span>

<span data-ttu-id="e2b8e-268">La fonctionnalité async vous permet d'appeler des méthodes asynchrones sans utiliser de rappels explicites ni fractionner manuellement votre code entre plusieurs méthodes ou expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-268">By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</span></span>

<span data-ttu-id="e2b8e-269">Si vous marquez une méthode avec le modificateur [async](language-reference/keywords/async.md), vous pouvez utiliser l’opérateur [await](language-reference/operators/await.md) dans la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-269">If you mark a method with the [async](language-reference/keywords/async.md) modifier, you can use the [await](language-reference/operators/await.md) operator in the method.</span></span> <span data-ttu-id="e2b8e-270">Quand le contrôle atteint une expression `await` dans la méthode async, il retourne à l’appelant si la tâche attendue n’est pas terminée, et la progression dans la méthode avec le mot clé `await` est interrompue jusqu’à ce que la tâche attendue se termine.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-270">When control reaches an `await` expression in the async method, control returns to the caller if the awaited task is not completed, and progress in the method with the `await` keyword is suspended until the awaited task completes.</span></span> <span data-ttu-id="e2b8e-271">Quand la tâche est terminée, l'exécution peut reprendre dans la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-271">When the task is complete, execution can resume in the method.</span></span>

> [!NOTE]
> <span data-ttu-id="e2b8e-272">Une méthode Async retourne à l’appelant lorsqu’elle rencontre le premier objet attendu qui n’est pas encore terminé ou qu’elle atteint la fin de la méthode Async, selon ce qui se produit en premier.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-272">An async method returns to the caller when either it encounters the first awaited object that's not yet complete or it gets to the end of the async method, whichever occurs first.</span></span>

<span data-ttu-id="e2b8e-273">Une méthode async peut avoir un type de retour <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task> ou `void`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-273">An async method can have a return type of <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, or `void`.</span></span> <span data-ttu-id="e2b8e-274">Le type de retour `void` est essentiellement utilisé pour définir les gestionnaires d’événements, où un type de retour `void` est obligatoire.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-274">The `void` return type is used primarily to define event handlers, where a `void` return type is required.</span></span> <span data-ttu-id="e2b8e-275">Une méthode async qui retourne `void` ne peut pas être attendue, et l’appelant d’une méthode retournant void ne peut intercepter aucune exception levée par la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-275">An async method that returns `void` can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.</span></span> <span data-ttu-id="e2b8e-276">À compter de C# 7.0, une méthode asynchrone peut avoir [n’importe quel type de retour de type tâche](./whats-new/csharp-7.md#generalized-async-return-types).</span><span class="sxs-lookup"><span data-stu-id="e2b8e-276">Starting with C# 7.0, an async method can have [any task-like return type](./whats-new/csharp-7.md#generalized-async-return-types).</span></span>

<span data-ttu-id="e2b8e-277">Dans l’exemple suivant, `DelayAsync` est une méthode async contenant une instruction return qui retourne un entier.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-277">In the following example, `DelayAsync` is an async method that has a return statement that returns an integer.</span></span> <span data-ttu-id="e2b8e-278">Comme il s’agit d’une méthode async, la déclaration de sa méthode doit avoir un type de retour `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-278">Because it is an async method, its method declaration must have a return type of `Task<int>`.</span></span> <span data-ttu-id="e2b8e-279">Comme le type de retour est `Task<int>`, l’évaluation de l’expression `await` dans `DoSomethingAsync` produit un entier, comme l’instruction `int result = await delayTask` suivante le montre.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-279">Because the return type is `Task<int>`, the evaluation of the `await` expression in `DoSomethingAsync` produces an integer, as the following `int result = await delayTask` statement demonstrates.</span></span>

:::code language="csharp" source="programming-guide/classes-and-structs/snippets/classes-and-structs/methods/Program.cs":::

<span data-ttu-id="e2b8e-280">Une méthode async ne peut pas déclarer de paramètres [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md) ou [out](language-reference/keywords/out-parameter-modifier.md), mais elle peut appeler des méthodes qui ont ces paramètres.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-280">An async method can't declare any [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md), or [out](language-reference/keywords/out-parameter-modifier.md) parameters, but it can call methods that have such parameters.</span></span>

 <span data-ttu-id="e2b8e-281">Pour plus d’informations sur les méthodes Async, consultez [programmation asynchrone avec Async et await](async.md) et [Async (types de retour](programming-guide/concepts/async/async-return-types.md)).</span><span class="sxs-lookup"><span data-stu-id="e2b8e-281">For more information about async methods, see [Asynchronous programming with async and await](async.md) and [Async return types](programming-guide/concepts/async/async-return-types.md).</span></span>

<a name="expr"></a>

## <a name="expression-bodied-members"></a><span data-ttu-id="e2b8e-282">Membres expression-bodied</span><span class="sxs-lookup"><span data-stu-id="e2b8e-282">Expression-bodied members</span></span>

<span data-ttu-id="e2b8e-283">Il est courant d'avoir des définitions de méthode qui retournent tout simplement le résultat d'une expression immédiatement, ou qui ont une seule instruction en tant que corps de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-283">It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.</span></span>  <span data-ttu-id="e2b8e-284">Il existe un raccourci de syntaxe pour définir de telles méthodes en utilisant `=>`:</span><span class="sxs-lookup"><span data-stu-id="e2b8e-284">There is a syntax shortcut for defining such methods using `=>`:</span></span>

```csharp
public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
```

<span data-ttu-id="e2b8e-285">Si la méthode retourne `void` ou est une méthode async, alors le corps de la méthode doit être une expression d’instruction (comme avec les expressions lambda).</span><span class="sxs-lookup"><span data-stu-id="e2b8e-285">If the method returns `void` or is an async method, the body of the method must be a statement expression (same as with lambdas).</span></span>  <span data-ttu-id="e2b8e-286">Les propriétés et les indexeurs doivent être en lecture seule, et vous n’y utilisez pas le mot clé d’accesseur `get`.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-286">For properties and indexers, they must be read-only, and you do not use the `get` accessor keyword.</span></span>

<a name="iterators"></a>

## <a name="iterators"></a><span data-ttu-id="e2b8e-287">Iterators</span><span class="sxs-lookup"><span data-stu-id="e2b8e-287">Iterators</span></span>

<span data-ttu-id="e2b8e-288">Un itérateur exécute une itération personnalisée sur une collection, comme une liste ou un tableau.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-288">An iterator performs a custom iteration over a collection, such as a list or an array.</span></span> <span data-ttu-id="e2b8e-289">Un itérateur utilise l'instruction [yield return](language-reference/keywords/yield.md) pour retourner chaque élément un par un.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-289">An iterator uses the [yield return](language-reference/keywords/yield.md) statement to return each element one at a time.</span></span> <span data-ttu-id="e2b8e-290">Quand une instruction `yield return` est atteinte, l’emplacement actif est mémorisé pour que l’appelant puisse demander l’élément suivant dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-290">When a `yield return` statement is reached, the current location is remembered so that the caller can request the next element in the sequence.</span></span>

<span data-ttu-id="e2b8e-291">Le type de retour d'un itérateur peut être <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator> ou <xref:System.Collections.Generic.IEnumerator%601>.</span><span class="sxs-lookup"><span data-stu-id="e2b8e-291">The return type of an iterator can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>.</span></span>

<span data-ttu-id="e2b8e-292">Pour plus d’informations, consultez [itérateurs](programming-guide/concepts/iterators.md).</span><span class="sxs-lookup"><span data-stu-id="e2b8e-292">For more information, see [Iterators](programming-guide/concepts/iterators.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="e2b8e-293">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="e2b8e-293">See also</span></span>

- [<span data-ttu-id="e2b8e-294">Modificateurs d’accès</span><span class="sxs-lookup"><span data-stu-id="e2b8e-294">Access Modifiers</span></span>](language-reference/keywords/access-modifiers.md)
- [<span data-ttu-id="e2b8e-295">Classes statiques et membres de classe statique</span><span class="sxs-lookup"><span data-stu-id="e2b8e-295">Static Classes and Static Class Members</span></span>](programming-guide/classes-and-structs/static-classes-and-static-class-members.md)
- [<span data-ttu-id="e2b8e-296">Héritage</span><span class="sxs-lookup"><span data-stu-id="e2b8e-296">Inheritance</span></span>](programming-guide/classes-and-structs/inheritance.md)
- [<span data-ttu-id="e2b8e-297">Classes abstract et sealed et membres de classe</span><span class="sxs-lookup"><span data-stu-id="e2b8e-297">Abstract and Sealed Classes and Class Members</span></span>](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="e2b8e-298">params</span><span class="sxs-lookup"><span data-stu-id="e2b8e-298">params</span></span>](language-reference/keywords/params.md)
- [<span data-ttu-id="e2b8e-299">à</span><span class="sxs-lookup"><span data-stu-id="e2b8e-299">out</span></span>](language-reference/keywords/out-parameter-modifier.md)
- [<span data-ttu-id="e2b8e-300">ref</span><span class="sxs-lookup"><span data-stu-id="e2b8e-300">ref</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="e2b8e-301">in</span><span class="sxs-lookup"><span data-stu-id="e2b8e-301">in</span></span>](language-reference/keywords/in-parameter-modifier.md)
- [<span data-ttu-id="e2b8e-302">Passer des paramètres</span><span class="sxs-lookup"><span data-stu-id="e2b8e-302">Passing Parameters</span></span>](programming-guide/classes-and-structs/passing-parameters.md)
