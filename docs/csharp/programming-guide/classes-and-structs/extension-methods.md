---
title: Méthodes d’extension - Guide de programmation C#
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 0b35ad523fc7f0949cb5243edbdc50cd3e927999
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249218"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="a6a6b-102">Méthodes d’extension (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="a6a6b-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="a6a6b-103">Les méthodes d'extension vous permettent d'« ajouter » des méthodes à des types existants sans créer un type dérivé, ni recompiler ou modifier le type d'origine.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="a6a6b-104">Les méthodes d’extension sont des méthodes statiques, mais elles sont appelées comme si elles étaient des méthodes d’instance sur le type étendu.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="a6a6b-105">Pour le code client écrit en C, F et Visual Basic, il n’y a aucune différence apparente entre l’appel d’une méthode d’extension et les méthodes définies dans un type.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="a6a6b-106">Les méthodes d’extension les plus courantes sont les opérateurs de <xref:System.Collections.IEnumerable?displayProperty=nameWithType> requête <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> standard LINQ qui ajoutent des fonctionnalités de requête aux existants et aux types.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="a6a6b-107">Pour utiliser les opérateurs de requête standard, introduisez-les d'abord dans la portée avec une directive `using System.Linq`.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="a6a6b-108">Puis, tout type qui implémente <xref:System.Collections.Generic.IEnumerable%601> semble avoir des méthodes d'instance telles que <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, etc.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="a6a6b-109">Vous pouvez consulter ces méthodes supplémentaires dans la saisie semi-automatique des instructions IntelliSense quand vous tapez un « point » après une instance d’un type <xref:System.Collections.Generic.IEnumerable%601> tel que <xref:System.Collections.Generic.List%601> ou <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="a6a6b-110">Exemple OrderBy</span><span class="sxs-lookup"><span data-stu-id="a6a6b-110">OrderBy Example</span></span>

<span data-ttu-id="a6a6b-111">L'exemple suivant indique comment appeler la méthode `OrderBy` d'opérateur de requête standard sur un tableau d'entiers.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="a6a6b-112">L'expression entre parenthèses est une expression lambda.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="a6a6b-113">De nombreux opérateurs de requête standard prennent les expressions lambda comme paramètres, mais ce n’est pas une exigence pour les méthodes d’extension.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="a6a6b-114">Pour plus d’informations, voir [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="a6a6b-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="a6a6b-115">Les méthodes d’extension sont définies comme méthodes statiques mais sont appelées en utilisant la syntaxe de méthode d’instance.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="a6a6b-116">Leur premier paramètre précise sur quel type la méthode fonctionne.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="a6a6b-117">Le paramètre est précédé par le [modificateur](../../language-reference/keywords/this.md) de ce modificateur.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="a6a6b-118">Les méthodes d'extension sont uniquement dans la portée lorsque vous importez explicitement l'espace de noms dans votre code source avec une directive `using`.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="a6a6b-119">L'exemple suivant présente une méthode d'extension définie pour la classe <xref:System.String?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="a6a6b-120">Il est défini à l’intérieur d’une classe statique non imbriquée et non générique :</span><span class="sxs-lookup"><span data-stu-id="a6a6b-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="a6a6b-121">La méthode d'extension `WordCount` peut être mise à portée avec cette directive `using` :</span><span class="sxs-lookup"><span data-stu-id="a6a6b-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="a6a6b-122">Elle peut être appelée à partir d'une application à l'aide de cette syntaxe :</span><span class="sxs-lookup"><span data-stu-id="a6a6b-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="a6a6b-123">Vous invoquez la méthode d’extension dans votre code avec la syntaxe de méthode d’instance.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="a6a6b-124">La langue intermédiaire (IL) générée par le compilateur traduit votre code en un appel sur la méthode statique.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="a6a6b-125">Le principe de l’encapsulation n’est pas vraiment violé.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="a6a6b-126">Les méthodes d’extension ne peuvent pas accéder aux variables privées dans le type qu’elles étendent.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="a6a6b-127">Pour plus d’informations, voir [Comment implémenter et appeler une méthode d’extension personnalisée](./how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="a6a6b-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="a6a6b-128">En général, vous allez probablement appeler des méthodes d’extension beaucoup plus souvent que la mise en œuvre de votre propre.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="a6a6b-129">Comme les méthodes d'extension sont appelées à l'aide de la syntaxe de méthode d'instance, aucune connaissance particulière n'est requise pour les utiliser depuis le code client.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="a6a6b-130">Pour activer des méthodes d'extension pour un type particulier, ajoutez simplement une directive `using` pour l'espace de noms dans lequel les méthodes sont définies.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="a6a6b-131">Par exemple, pour utiliser les opérateurs de requête standard, ajoutez la directive `using` à votre code :</span><span class="sxs-lookup"><span data-stu-id="a6a6b-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="a6a6b-132">(Vous devrez peut-être également ajouter une référence à System.Core.dll.) Vous remarquerez que les opérateurs de requête standard apparaissent maintenant dans <xref:System.Collections.Generic.IEnumerable%601> IntelliSense comme méthodes supplémentaires disponibles pour la plupart des types.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="a6a6b-133">Liaison de méthodes d’extension à la compilation</span><span class="sxs-lookup"><span data-stu-id="a6a6b-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="a6a6b-134">Vous pouvez utiliser des méthodes d'extension pour étendre une classe ou une interface, mais pas pour les remplacer.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="a6a6b-135">Une méthode d'extension avec le même nom et la même signature qu'une méthode d'interface ou de classe ne sera jamais appelée.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="a6a6b-136">Au moment de la compilation, les méthodes d'extension ont toujours la priorité la plus faible par rapport aux méthodes d'instance définies dans le type lui-même.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="a6a6b-137">En d'autres termes, si un type a une méthode nommée `Process(int i)` et que vous avez une méthode d'extension avec la même signature, le compilateur créera toujours une liaison avec la méthode d'instance.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="a6a6b-138">Lorsque le compilateur rencontre un appel de méthode, il recherche d'abord une correspondance dans les méthodes d'instance du type.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="a6a6b-139">Si aucune correspondance n'est trouvée, il recherche toutes les méthodes d'extension définies pour le type et crée une liaison avec la première méthode d'extension qu'il trouve.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="a6a6b-140">L’exemple suivant montre comment le compilateur détermine quelle méthode d’extension ou méthode d’instance est choisie pour créer une liaison.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="a6a6b-141">Exemple</span><span class="sxs-lookup"><span data-stu-id="a6a6b-141">Example</span></span>

<span data-ttu-id="a6a6b-142">L’exemple suivant montre les règles que le compilateur C# suit pour déterminer s’il faut lier un appel de méthode à une méthode d’instance sur le type, ou à une méthode d’extension.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="a6a6b-143">Le classe statique `Extensions` contient des méthodes d'extension définies pour tout type qui implémente `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="a6a6b-144">Les classes `A`, `B` et `C` implémentent toutes l'interface.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="a6a6b-145">La méthode d'extension `MethodB` n'est jamais appelée car son nom et sa signature correspondent exactement aux méthodes déjà implémentées par les classes.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="a6a6b-146">Lorsque le compilateur ne peut pas trouver une méthode d’instance avec une signature correspondante, il se lie à une méthode d’extension correspondante si l’on existe.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="a6a6b-147">Modèles d’utilisation courants</span><span class="sxs-lookup"><span data-stu-id="a6a6b-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="a6a6b-148">Fonctionnalités des collections</span><span class="sxs-lookup"><span data-stu-id="a6a6b-148">Collection Functionality</span></span>

<span data-ttu-id="a6a6b-149">Dans le passé, il était courant de créer <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> des « classes de collection » qui implémentait l’interface pour un type donné et contenaient des fonctionnalités qui fonctionnaient sur des collections de ce type.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="a6a6b-150">Bien qu’il n’y ait rien de mal à créer ce type d’objet de collection, la même fonctionnalité peut être réalisée en utilisant une extension sur le <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a6a6b-151">Les extensions ont l’avantage de permettre que la <xref:System.Array?displayProperty=nameWithType> fonctionnalité <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> soit <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> appelée à partir d’une collection telle qu’une ou une telle implémentations sur ce type.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="a6a6b-152">Un exemple de ceci utilisant un tableau d’Int32 peut être trouvé [plus tôt dans cet article.](#orderby-example)</span><span class="sxs-lookup"><span data-stu-id="a6a6b-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="a6a6b-153">Fonctionnalité spécifique à la couche</span><span class="sxs-lookup"><span data-stu-id="a6a6b-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="a6a6b-154">Lors de l’utilisation d’une architecture d’oignon ou d’une autre conception d’application en couches, il est courant d’avoir un ensemble d’entités de domaine ou d’objets de transfert de données qui peuvent être utilisés pour communiquer au-delà des limites de l’application.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="a6a6b-155">Ces objets ne contiennent généralement aucune fonctionnalité, ni seulement des fonctionnalités minimales qui s’appliquent à toutes les couches de l’application.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="a6a6b-156">Les méthodes d’extension peuvent être utilisées pour ajouter des fonctionnalités spécifiques à chaque couche d’application sans charger l’objet vers le bas avec des méthodes non nécessaires ou voulues dans d’autres couches.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```aspx-csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="a6a6b-157">Extension des types prédéfinis</span><span class="sxs-lookup"><span data-stu-id="a6a6b-157">Extending Predefined Types</span></span>

<span data-ttu-id="a6a6b-158">Plutôt que de créer de nouveaux objets lorsque des fonctionnalités réutilisables doivent être créées, nous pouvons souvent étendre un type existant tel qu’un cadre .NET ou un type CLR.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type such as a .NET Framework or CLR type.</span></span> <span data-ttu-id="a6a6b-159">Par exemple, si nous n’utilisons pas de `Engine` méthodes `Query` d’extension, nous pourrions créer une classe ou une classe pour effectuer une requête sur un serveur SQL qui peut être appelé à partir de plusieurs endroits dans notre code.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="a6a6b-160">Cependant, nous pouvons <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> plutôt étendre la classe en utilisant des méthodes d’extension pour effectuer cette requête de n’importe où nous avons une connexion à un serveur SQL.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="a6a6b-161">D’autres exemples pourraient être <xref:System.String?displayProperty=nameWithType> d’ajouter des fonctionnalités <xref:System.IO.File?displayProperty=nameWithType> communes <xref:System.IO.Stream?displayProperty=nameWithType> à <xref:System.Exception?displayProperty=nameWithType> la classe, d’étendre les capacités de traitement des données et des objets, et des objets pour des fonctionnalités spécifiques de manipulation d’erreurs.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="a6a6b-162">Ces types de cas d’utilisation ne sont limités que par votre imagination et votre bon sens.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="a6a6b-163">L’extension des types prédéfinis peut être difficile avec `struct` les types parce qu’ils sont transmis par valeur aux méthodes.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="a6a6b-164">Cela signifie que toute modification de la struct est apportée à une copie de la struct.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="a6a6b-165">Ces modifications ne sont pas visibles une fois que la méthode d’extension sort.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="a6a6b-166">En commençant par C 7.2, `ref` vous pouvez ajouter le modificateur au premier argument d’une méthode d’extension.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="a6a6b-167">L’ajout du `ref` modificateur signifie que le premier argument est adopté par référence.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="a6a6b-168">Cela vous permet d’écrire des méthodes d’extension qui modifient l’état de la struct étant étendu.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="a6a6b-169">Instructions générales</span><span class="sxs-lookup"><span data-stu-id="a6a6b-169">General Guidelines</span></span>

<span data-ttu-id="a6a6b-170">Bien qu’il soit toujours considéré comme préférable d’ajouter des fonctionnalités en modifiant le code d’un objet ou en dérivant un nouveau type chaque fois qu’il est raisonnable et possible de le faire, les méthodes d’extension sont devenues une option cruciale pour créer des fonctionnalités réutilisables tout au long de la .NET Écosystème.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="a6a6b-171">Pour les occasions où la source d’origine n’est pas sous votre contrôle, quand un objet dérivé est inapproprié ou impossible, ou lorsque la fonctionnalité ne doit pas être exposée au-delà de sa portée applicable, les méthodes d’extension sont un excellent choix.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="a6a6b-172">Pour plus d’informations sur les types dérivés, voir [Héritage](./inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="a6a6b-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="a6a6b-173">Lorsque vous utilisez une méthode d’extension pour étendre un type dont le code source que vous n’êtes pas en contrôle, vous courez le risque qu’un changement dans la mise en œuvre du type provoque votre méthode d’extension à briser.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="a6a6b-174">Si vous implémentez des méthodes d’extension pour un type donné, prenez en compte les points suivants :</span><span class="sxs-lookup"><span data-stu-id="a6a6b-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="a6a6b-175">Une méthode d'extension ne sera jamais appelée si elle a la même signature qu'une méthode définie dans le type.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="a6a6b-176">Les méthodes d'extension sont mises en portée au niveau de l'espace de noms.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="a6a6b-177">Par exemple, si vous avez plusieurs classes statiques qui `Extensions`contiennent des méthodes d’extension `using Extensions;` dans un seul namespace nommé, ils seront tous mis en portée par la directive.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="a6a6b-178">Pour une bibliothèque de classes que vous avez implémentée, vous ne devez pas utiliser de méthodes d'extension pour éviter d'incrémenter le numéro de version d'un assembly.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="a6a6b-179">Si vous souhaitez ajouter une fonctionnalité importante à une bibliothèque dont le code source vous appartient, vous devez suivre les directives .NET Framework standard relatives à la gestion de version des assemblys.</span><span class="sxs-lookup"><span data-stu-id="a6a6b-179">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="a6a6b-180">Pour plus d’informations, consultez [Versioning des assemblys](../../../standard/assembly/versioning.md).</span><span class="sxs-lookup"><span data-stu-id="a6a6b-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="a6a6b-181">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="a6a6b-181">See also</span></span>

- [<span data-ttu-id="a6a6b-182">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="a6a6b-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="a6a6b-183">Exemples de programmation parallèle (il s’agit de nombreux exemples de méthodes d’extension)</span><span class="sxs-lookup"><span data-stu-id="a6a6b-183">Parallel Programming Samples (these include many example extension methods)</span></span>](https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)
- [<span data-ttu-id="a6a6b-184">Expressions lambda</span><span class="sxs-lookup"><span data-stu-id="a6a6b-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="a6a6b-185">Vue d’ensemble des opérateurs de requête standard</span><span class="sxs-lookup"><span data-stu-id="a6a6b-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="a6a6b-186">Règles de conversion pour les paramètres Instance et leur impact</span><span class="sxs-lookup"><span data-stu-id="a6a6b-186">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="a6a6b-187">Interopérabilité des méthodes d’extension entre les langages</span><span class="sxs-lookup"><span data-stu-id="a6a6b-187">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="a6a6b-188">Méthodes d’extension et délégués curryfiés</span><span class="sxs-lookup"><span data-stu-id="a6a6b-188">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="a6a6b-189">Extension method Binding and Error reporting</span><span class="sxs-lookup"><span data-stu-id="a6a6b-189">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
