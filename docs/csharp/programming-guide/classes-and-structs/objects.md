---
title: Objets - Guide de programmation C#
ms.date: 07/20/2015
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
ms.openlocfilehash: a2f5300f9647823cf2c9ac2a4a5c7c888c7dd245
ms.sourcegitcommit: 44a7cd8687f227fc6db3211ccf4783dc20235e51
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/26/2020
ms.locfileid: "77626579"
---
# <a name="objects-c-programming-guide"></a><span data-ttu-id="63bb4-102">Objets (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="63bb4-102">Objects (C# Programming Guide)</span></span>
<span data-ttu-id="63bb4-103">Une définition de classe ou de struct s’apparente à un plan qui spécifie ce que le type peut faire.</span><span class="sxs-lookup"><span data-stu-id="63bb4-103">A class or struct definition is like a blueprint that specifies what the type can do.</span></span> <span data-ttu-id="63bb4-104">Un objet est fondamentalement un bloc de mémoire qui a été alloué et configuré selon le plan.</span><span class="sxs-lookup"><span data-stu-id="63bb4-104">An object is basically a block of memory that has been allocated and configured according to the blueprint.</span></span> <span data-ttu-id="63bb4-105">Un programme peut créer de nombreux objets de la même classe.</span><span class="sxs-lookup"><span data-stu-id="63bb4-105">A program may create many objects of the same class.</span></span> <span data-ttu-id="63bb4-106">Les objets sont également appelés instances. Ils peuvent être stockés dans une variable nommée, dans un tableau ou dans une collection.</span><span class="sxs-lookup"><span data-stu-id="63bb4-106">Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</span></span> <span data-ttu-id="63bb4-107">Le code client est le code qui utilise ces variables pour appeler les méthodes et accéder aux propriétés publiques de l’objet.</span><span class="sxs-lookup"><span data-stu-id="63bb4-107">Client code is the code that uses these variables to call the methods and access the public properties of the object.</span></span> <span data-ttu-id="63bb4-108">Dans un langage orienté objet tel que C#, un programme classique se compose de plusieurs objets qui interagissent de façon dynamique.</span><span class="sxs-lookup"><span data-stu-id="63bb4-108">In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="63bb4-109">Les types statiques se comportent différemment de ce qui est décrit ici.</span><span class="sxs-lookup"><span data-stu-id="63bb4-109">Static types behave differently than what is described here.</span></span> <span data-ttu-id="63bb4-110">Pour plus d’informations, consultez [Classes statiques et membres de classe statique](./static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="63bb4-110">For more information, see [Static Classes and Static Class Members](./static-classes-and-static-class-members.md).</span></span>
  
## <a name="struct-instances-vs-class-instances"></a><span data-ttu-id="63bb4-111">Instances struct et instances de classe</span><span class="sxs-lookup"><span data-stu-id="63bb4-111">Struct Instances vs. Class Instances</span></span>  
 <span data-ttu-id="63bb4-112">Étant donné que les classes sont des types référence, une variable d’un objet de classe conserve une référence à l’adresse de l’objet sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="63bb4-112">Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</span></span> <span data-ttu-id="63bb4-113">Si un deuxième objet du même type est assigné au premier objet, les deux variables font référence à l’objet à cette adresse.</span><span class="sxs-lookup"><span data-stu-id="63bb4-113">If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</span></span> <span data-ttu-id="63bb4-114">Ce point est abordé en détail plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="63bb4-114">This point is discussed in more detail later in this topic.</span></span>  
  
 <span data-ttu-id="63bb4-115">Les instances de classes sont créées à l’aide de l’[opérateur new](../../language-reference/operators/new-operator.md).</span><span class="sxs-lookup"><span data-stu-id="63bb4-115">Instances of classes are created by using the [new operator](../../language-reference/operators/new-operator.md).</span></span> <span data-ttu-id="63bb4-116">Dans l’exemple suivant, `Person` est le type, et `person1` et `person 2` sont des instances, ou objets, de ce type.</span><span class="sxs-lookup"><span data-stu-id="63bb4-116">In the following example, `Person` is the type and `person1` and `person 2` are instances, or objects, of that type.</span></span>  
  
 [!code-csharp[csProgGuideStatements#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#30)]  
  
 <span data-ttu-id="63bb4-117">Étant donné que les structs sont des types valeur, une variable d’un objet de struct conserve une copie de l’objet entier.</span><span class="sxs-lookup"><span data-stu-id="63bb4-117">Because structs are value types, a variable of a struct object holds a copy of the entire object.</span></span> <span data-ttu-id="63bb4-118">Les instances de structs peuvent également être créées à l’aide de l’opérateur `new`, mais cela n’est pas obligatoire, comme illustré dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="63bb4-118">Instances of structs can also be created by using the `new` operator, but this is not required, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#31)]  
  
 <span data-ttu-id="63bb4-119">La mémoire pour `p1` et `p2` est allouée sur la pile de threads.</span><span class="sxs-lookup"><span data-stu-id="63bb4-119">The memory for both `p1` and `p2` is allocated on the thread stack.</span></span> <span data-ttu-id="63bb4-120">Cette mémoire est récupérée avec le type ou la méthode où elle est déclarée.</span><span class="sxs-lookup"><span data-stu-id="63bb4-120">That memory is reclaimed along with the type or method in which it is declared.</span></span> <span data-ttu-id="63bb4-121">C’est l’une des raisons pour lesquelles les structs sont copiés au moment de l’assignation.</span><span class="sxs-lookup"><span data-stu-id="63bb4-121">This is one reason why structs are copied on assignment.</span></span> <span data-ttu-id="63bb4-122">En revanche, la mémoire allouée pour une instance de classe est récupérée automatiquement (garbage collection) par le common language runtime quand toutes les références à l’objet sont hors de la portée.</span><span class="sxs-lookup"><span data-stu-id="63bb4-122">By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</span></span> <span data-ttu-id="63bb4-123">Il n’est pas possible de détruire de façon déterministe un objet de classe comme vous pouvez le faire dans C++.</span><span class="sxs-lookup"><span data-stu-id="63bb4-123">It is not possible to deterministically destroy a class object like you can in C++.</span></span> <span data-ttu-id="63bb4-124">Pour plus d’informations sur l’opération de garbage collection dans le .NET Framework, consultez [Garbage collection](../../../standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="63bb4-124">For more information about garbage collection in the .NET Framework, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="63bb4-125">L’allocation et la libération de mémoire sur le tas managé sont des opérations très optimisées dans le common language runtime.</span><span class="sxs-lookup"><span data-stu-id="63bb4-125">The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</span></span> <span data-ttu-id="63bb4-126">Dans la plupart des cas, il n’y a pas de différence significative sur le plan des performances entre l’allocation d’une instance de classe sur le tas et l’allocation d’une instance de struct sur la pile.</span><span class="sxs-lookup"><span data-stu-id="63bb4-126">In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</span></span>
  
## <a name="object-identity-vs-value-equality"></a><span data-ttu-id="63bb4-127">Identité de l’objet et égalité de la valeur</span><span class="sxs-lookup"><span data-stu-id="63bb4-127">Object Identity vs. Value Equality</span></span>  
 <span data-ttu-id="63bb4-128">Quand vous effectuez une comparaison d’égalité entre deux objets, vous devez d’abord décider si vous souhaitez savoir si les deux variables représentent le même objet en mémoire, ou si les valeurs d’un ou de plusieurs de leurs champs sont équivalentes.</span><span class="sxs-lookup"><span data-stu-id="63bb4-128">When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</span></span> <span data-ttu-id="63bb4-129">Si vous projetez de comparer les valeurs, vous devez établir si les objets sont des instances de types valeur (structs) ou de types référence (classes, délégués, tableaux).</span><span class="sxs-lookup"><span data-stu-id="63bb4-129">If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</span></span>  
  
- <span data-ttu-id="63bb4-130">Pour déterminer si deux instances de classe référencent le même emplacement en mémoire (ce qui signifie qu’elles ont la même *identité*), utilisez la méthode statique <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="63bb4-130">To determine whether two class instances refer to the same location in memory (which means that they have the same *identity*), use the static <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="63bb4-131">(<xref:System.Object?displayProperty=nameWithType> est la classe de base implicite pour tous les types valeur et types référence, y compris les classes et structs définis par l’utilisateur.)</span><span class="sxs-lookup"><span data-stu-id="63bb4-131">(<xref:System.Object?displayProperty=nameWithType> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</span></span>  
  
- <span data-ttu-id="63bb4-132">Pour déterminer si les champs d’instance dans deux instances de struct ont les mêmes valeurs, utilisez la méthode <xref:System.ValueType.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63bb4-132">To determine whether the instance fields in two struct instances have the same values, use the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="63bb4-133">Comme tous les structs héritent implicitement de <xref:System.ValueType?displayProperty=nameWithType>, vous appelez directement la méthode sur votre objet, comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="63bb4-133">Because all structs implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, you call the method directly on your object as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#32)]  
  
 <span data-ttu-id="63bb4-134">L’implémentation <xref:System.ValueType?displayProperty=nameWithType> de `Equals` utilise la réflexion, car elle doit être en mesure de déterminer la nature des champs dans chaque struct.</span><span class="sxs-lookup"><span data-stu-id="63bb4-134">The <xref:System.ValueType?displayProperty=nameWithType> implementation of `Equals` uses reflection because it must be able to determine what the fields are in any struct.</span></span> <span data-ttu-id="63bb4-135">Quand vous créez vos propres structs, substituez la méthode `Equals` pour fournir un algorithme d’égalité efficace qui est propre à votre type.</span><span class="sxs-lookup"><span data-stu-id="63bb4-135">When creating your own structs, override the `Equals` method to provide an efficient equality algorithm that is specific to your type.</span></span>  
  
- <span data-ttu-id="63bb4-136">Pour déterminer si les valeurs des champs dans deux instances de classe sont égales, vous pouvez utiliser la méthode <xref:System.Object.Equals%2A> ou l’[opérateur ==](../../language-reference/operators/equality-operators.md#equality-operator-).</span><span class="sxs-lookup"><span data-stu-id="63bb4-136">To determine whether the values of the fields in two class instances are equal, you might be able to use the <xref:System.Object.Equals%2A> method or the [== operator](../../language-reference/operators/equality-operators.md#equality-operator-).</span></span> <span data-ttu-id="63bb4-137">Toutefois, utilisez-les uniquement si la classe les a substitués ou surchargés pour fournir une définition personnalisée de ce que signifie « égalité » pour les objets de ce type.</span><span class="sxs-lookup"><span data-stu-id="63bb4-137">However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</span></span> <span data-ttu-id="63bb4-138">La classe peut également implémenter l’interface <xref:System.IEquatable%601> ou <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="63bb4-138">The class might also implement the <xref:System.IEquatable%601> interface or the <xref:System.Collections.Generic.IEqualityComparer%601> interface.</span></span> <span data-ttu-id="63bb4-139">Les deux interfaces fournissent des méthodes qui peuvent être utilisées pour tester l’égalité des valeurs.</span><span class="sxs-lookup"><span data-stu-id="63bb4-139">Both interfaces provide methods that can be used to test value equality.</span></span> <span data-ttu-id="63bb4-140">Quand vous concevez vos propres classes qui substituent `Equals`, veillez à suivre les instructions indiquées dans [comment définir l’égalité des valeurs pour un type](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) et <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63bb4-140">When designing your own classes that override `Equals`, make sure to follow the guidelines stated in [How to define value equality for a type](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) and <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span>
  
## <a name="related-sections"></a><span data-ttu-id="63bb4-141">Sections connexes</span><span class="sxs-lookup"><span data-stu-id="63bb4-141">Related Sections</span></span>  
 <span data-ttu-id="63bb4-142">Pour plus d'informations :</span><span class="sxs-lookup"><span data-stu-id="63bb4-142">For more information:</span></span>  
  
- [<span data-ttu-id="63bb4-143">Classes</span><span class="sxs-lookup"><span data-stu-id="63bb4-143">Classes</span></span>](./classes.md)  
  
- [<span data-ttu-id="63bb4-144">Structures</span><span class="sxs-lookup"><span data-stu-id="63bb4-144">Structs</span></span>](./structs.md)  
  
- [<span data-ttu-id="63bb4-145">Constructeurs</span><span class="sxs-lookup"><span data-stu-id="63bb4-145">Constructors</span></span>](./constructors.md)  
  
- [<span data-ttu-id="63bb4-146">Finaliseurs</span><span class="sxs-lookup"><span data-stu-id="63bb4-146">Finalizers</span></span>](./destructors.md)  
  
- [<span data-ttu-id="63bb4-147">Événements</span><span class="sxs-lookup"><span data-stu-id="63bb4-147">Events</span></span>](../events/index.md)  
  
## <a name="see-also"></a><span data-ttu-id="63bb4-148">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="63bb4-148">See also</span></span>

- [<span data-ttu-id="63bb4-149">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="63bb4-149">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="63bb4-150">object</span><span class="sxs-lookup"><span data-stu-id="63bb4-150">object</span></span>](../../language-reference/builtin-types/reference-types.md)
- [<span data-ttu-id="63bb4-151">Héritage</span><span class="sxs-lookup"><span data-stu-id="63bb4-151">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="63bb4-152">class</span><span class="sxs-lookup"><span data-stu-id="63bb4-152">class</span></span>](../../language-reference/keywords/class.md)
- [<span data-ttu-id="63bb4-153">struct</span><span class="sxs-lookup"><span data-stu-id="63bb4-153">struct</span></span>](../../language-reference/builtin-types/struct.md)
- [<span data-ttu-id="63bb4-154">Opérateur new</span><span class="sxs-lookup"><span data-stu-id="63bb4-154">new Operator</span></span>](../../language-reference/operators/new-operator.md)
- [<span data-ttu-id="63bb4-155">Système de type commun</span><span class="sxs-lookup"><span data-stu-id="63bb4-155">Common Type System</span></span>](../../../standard/base-types/common-type-system.md)
