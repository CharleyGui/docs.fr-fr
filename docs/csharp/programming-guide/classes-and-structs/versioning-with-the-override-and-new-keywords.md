---
title: Versioning avec les mots clés override et new - Guide de programmation C#
description: En savoir plus sur le contrôle de version pour les classes de base et dérivées en C#, et comment spécifier si une méthode est destinée à substituer ou masquer une méthode héritée.
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, versioning
- C# language, override and new
ms.assetid: 88247d07-bd0d-49e9-a619-45ccbbfdf0c5
ms.openlocfilehash: c2630741e1055a14dd5b9e4445d660cfd68891b0
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/21/2020
ms.locfileid: "86863862"
---
# <a name="versioning-with-the-override-and-new-keywords-c-programming-guide"></a><span data-ttu-id="a7aaf-103">Versioning avec les mots clés override et new (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="a7aaf-103">Versioning with the Override and New Keywords (C# Programming Guide)</span></span>
<span data-ttu-id="a7aaf-104">Le langage C# est conçu de telle sorte que la gestion de version entre les classes de [base](../../language-reference/keywords/base.md) et les classes dérivées dans différentes bibliothèques puisse évoluer et préserver une compatibilité descendante.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-104">The C# language is designed so that versioning between [base](../../language-reference/keywords/base.md) and derived classes in different libraries can evolve and maintain backward compatibility.</span></span> <span data-ttu-id="a7aaf-105">Cela signifie, par exemple, que l’introduction dans une [classe](../../language-reference/keywords/class.md) de base d’un nouveau membre portant le même nom qu’un membre dans une classe dérivée est totalement prise en charge par C# et n’engendre pas de comportement imprévisible.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-105">This means, for example, that the introduction of a new member in a base [class](../../language-reference/keywords/class.md) with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior.</span></span> <span data-ttu-id="a7aaf-106">Cela signifie également qu'une classe doit indiquer de façon explicite si une méthode est conçue pour se substituer à une méthode héritée ou s'il s'agit d'une nouvelle méthode qui masque une méthode héritée portant un nom similaire.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-106">It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.</span></span>  
  
 <span data-ttu-id="a7aaf-107">Dans C#, les classes dérivées peuvent contenir des méthodes portant le même nom que des méthodes de classe de base.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-107">In C#, derived classes can contain methods with the same name as base class methods.</span></span>  

- <span data-ttu-id="a7aaf-108">Si la méthode dans la classe dérivée n’est pas précédée des mots clés [new](../../language-reference/keywords/new-modifier.md) ou [override](../../language-reference/keywords/override.md), le compilateur émet un avertissement et la méthode se comporte comme si le mot clé `new` était présent.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-108">If the method in the derived class is not preceded by [new](../../language-reference/keywords/new-modifier.md) or [override](../../language-reference/keywords/override.md) keywords, the compiler will issue a warning and the method will behave as if the `new` keyword were present.</span></span>  
  
- <span data-ttu-id="a7aaf-109">Si la méthode dans la classe dérivée est précédée du mot clé `new`, la méthode est définie comme étant indépendante de la méthode dans la classe de base.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-109">If the method in the derived class is preceded with the `new` keyword, the method is defined as being independent of the method in the base class.</span></span>  
  
- <span data-ttu-id="a7aaf-110">Si la méthode dans la classe dérivée est précédée du mot clé `override`, les objets de la classe dérivée appelleront cette méthode plutôt que la méthode de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-110">If the method in the derived class is preceded with the `override` keyword, objects of the derived class will call that method instead of the base class method.</span></span>  

- <span data-ttu-id="a7aaf-111">Afin d’appliquer le `override` mot clé à la méthode dans la classe dérivée, la méthode de classe de base doit être définie comme étant [virtuelle](../../language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="a7aaf-111">In order to apply the `override` keyword to the method in the derived class, the base class method must be defined [virtual](../../language-reference/keywords/virtual.md).</span></span>
  
- <span data-ttu-id="a7aaf-112">La méthode de la classe de base peut être appelée à partir de la classe dérivée à l’aide du mot clé `base`.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-112">The base class method can be called from within the derived class using the `base` keyword.</span></span>  
  
- <span data-ttu-id="a7aaf-113">Les mots clés `override`, `virtual` et `new` peuvent également être appliqués aux propriétés, indexeurs et événements.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-113">The `override`, `virtual`, and `new` keywords can also be applied to properties, indexers, and events.</span></span>  
  
 <span data-ttu-id="a7aaf-114">Par défaut, les méthodes C# ne sont pas virtuelles.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-114">By default, C# methods are not virtual.</span></span> <span data-ttu-id="a7aaf-115">Si une méthode est déclarée comme virtuelle, toute classe héritant de la méthode peut implémenter sa propre version.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-115">If a method is declared as virtual, any class inheriting the method can implement its own version.</span></span> <span data-ttu-id="a7aaf-116">Pour créer une méthode virtuelle, le modificateur `virtual` est utilisé dans la déclaration de méthode de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-116">To make a method virtual, the `virtual` modifier is used in the method declaration of the base class.</span></span> <span data-ttu-id="a7aaf-117">La classe dérivée peut ensuite remplacer la méthode virtuelle de base avec le mot clé `override` ou masquer la méthode virtuelle dans la classe de base avec le mot clé `new`.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-117">The derived class can then override the base virtual method by using the `override` keyword or hide the virtual method in the base class by using the `new` keyword.</span></span> <span data-ttu-id="a7aaf-118">Si ni le mot clé `override` ni le mot clé `new` ne sont spécifiés, le compilateur émettra un avertissement et la méthode dans la classe dérivée masquera la méthode dans la classe de base.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-118">If neither the `override` keyword nor the `new` keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.</span></span>  
  
 <span data-ttu-id="a7aaf-119">Pour illustrer ceci dans un exemple pratique, supposons un instant que la Société A ait créé une classe nommée `GraphicsClass` que votre programme utilise.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-119">To demonstrate this in practice, assume for a moment that Company A has created a class named `GraphicsClass`, which your program uses.</span></span> <span data-ttu-id="a7aaf-120">Les éléments suivants représentent `GraphicsClass` :</span><span class="sxs-lookup"><span data-stu-id="a7aaf-120">The following is `GraphicsClass`:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#27)]  
  
 <span data-ttu-id="a7aaf-121">Votre société utilise cette classe, et vous l’utilisez pour dériver votre propre classe, en ajoutant une nouvelle méthode :</span><span class="sxs-lookup"><span data-stu-id="a7aaf-121">Your company uses this class, and you use it to derive your own class, adding a new method:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#28)]  
  
 <span data-ttu-id="a7aaf-122">Votre application est utilisée sans problèmes, jusqu’à ce que la Société A publie une nouvelle version de `GraphicsClass`, qui ressemble au code suivant :</span><span class="sxs-lookup"><span data-stu-id="a7aaf-122">Your application is used without problems, until Company A releases a new version of `GraphicsClass`, which resembles the following code:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#29)]  
  
 <span data-ttu-id="a7aaf-123">La nouvelle version de `GraphicsClass` contient maintenant une méthode nommée `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-123">The new version of `GraphicsClass` now contains a method named `DrawRectangle`.</span></span> <span data-ttu-id="a7aaf-124">Initialement, rien ne se produit.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-124">Initially, nothing occurs.</span></span> <span data-ttu-id="a7aaf-125">La nouvelle version est encore compatible au format binaire avec l’ancienne version.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-125">The new version is still binary compatible with the old version.</span></span> <span data-ttu-id="a7aaf-126">Tous les logiciels que vous avez déployés continueront de fonctionner, même si la nouvelle classe est installée sur ces systèmes informatiques.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-126">Any software that you have deployed will continue to work, even if the new class is installed on those computer systems.</span></span> <span data-ttu-id="a7aaf-127">Tout appel existant à la méthode `DrawRectangle` continuera de faire référence à votre version, dans votre classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-127">Any existing calls to the method `DrawRectangle` will continue to reference your version, in your derived class.</span></span>  
  
 <span data-ttu-id="a7aaf-128">Toutefois, dès que vous recompilerez votre application à l’aide de la nouvelle version de `GraphicsClass`, vous recevrez un avertissement du compilateur, CS0108.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-128">However, as soon as you recompile your application by using the new version of `GraphicsClass`, you will receive a warning from the compiler, CS0108.</span></span> <span data-ttu-id="a7aaf-129">Cet avertissement vous informe que vous devez envisager la façon dont vous souhaitez que votre méthode `DrawRectangle` se comporte dans votre application.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-129">This warning informs you that you have to consider how you want your `DrawRectangle` method to behave in your application.</span></span>  
  
 <span data-ttu-id="a7aaf-130">Si vous souhaitez que votre méthode remplace la nouvelle méthode de la classe de base, utilisez le mot clé `override` :</span><span class="sxs-lookup"><span data-stu-id="a7aaf-130">If you want your method to override the new base class method, use the `override` keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#30)]  
  
 <span data-ttu-id="a7aaf-131">Le mot clé `override` garantit que tous les objets dérivés de `YourDerivedGraphicsClass` utiliseront la version de classe dérivée de `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-131">The `override` keyword makes sure that any objects derived from `YourDerivedGraphicsClass` will use the derived class version of `DrawRectangle`.</span></span> <span data-ttu-id="a7aaf-132">Les objets dérivés de `YourDerivedGraphicsClass` peuvent toujours accéder à la version de la classe de base de `DrawRectangle` à l’aide du mot clé base :</span><span class="sxs-lookup"><span data-stu-id="a7aaf-132">Objects derived from `YourDerivedGraphicsClass` can still access the base class version of `DrawRectangle` by using the base keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#44)]  
  
 <span data-ttu-id="a7aaf-133">Si vous ne souhaitez pas que votre méthode se substitue à la nouvelle méthode de la classe de base, prenez en compte les considérations suivantes.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-133">If you do not want your method to override the new base class method, the following considerations apply.</span></span> <span data-ttu-id="a7aaf-134">Pour éviter toute confusion entre les deux méthodes, vous pouvez renommer votre méthode.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-134">To avoid confusion between the two methods, you can rename your method.</span></span> <span data-ttu-id="a7aaf-135">Ceci peut prendre du temps et constituer un risque d’erreur ou bien ne pas être tout simplement pratique dans certains cas.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-135">This can be time-consuming and error-prone, and just not practical in some cases.</span></span> <span data-ttu-id="a7aaf-136">Toutefois, si votre projet est relativement petit, vous pouvez utiliser les options de refactorisation de Visual Studio pour renommer la méthode.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-136">However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method.</span></span> <span data-ttu-id="a7aaf-137">Pour plus d’informations, consultez [Refactorisation des classes et des types (Concepteur de classes)](/visualstudio/ide/class-designer/refactoring-classes-and-types).</span><span class="sxs-lookup"><span data-stu-id="a7aaf-137">For more information, see [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/class-designer/refactoring-classes-and-types).</span></span>  
  
 <span data-ttu-id="a7aaf-138">Sinon, vous pouvez éviter de recevoir l’avertissement à l’aide du mot clé `new` dans la définition de votre classe dérivée :</span><span class="sxs-lookup"><span data-stu-id="a7aaf-138">Alternatively, you can prevent the warning by using the keyword `new` in your derived class definition:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#31)]  
  
 <span data-ttu-id="a7aaf-139">L’utilisation du mot clé `new` indique au compilateur que votre définition masque la définition qui est contenue dans la classe de base.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-139">Using the `new` keyword tells the compiler that your definition hides the definition that is contained in the base class.</span></span> <span data-ttu-id="a7aaf-140">Il s'agit du comportement par défaut.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-140">This is the default behavior.</span></span>  
  
## <a name="override-and-method-selection"></a><span data-ttu-id="a7aaf-141">Substitution et sélection de méthode</span><span class="sxs-lookup"><span data-stu-id="a7aaf-141">Override and Method Selection</span></span>  
 <span data-ttu-id="a7aaf-142">Lorsqu'une méthode est appelée sur une classe, le compilateur C# sélectionne la meilleure méthode à appeler si plusieurs méthodes sont compatibles avec l'appel, comme lorsque deux méthodes portent les mêmes noms et dont les paramètres sont compatibles avec les paramètres transmis.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-142">When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed.</span></span> <span data-ttu-id="a7aaf-143">Les méthodes suivantes seraient compatibles :</span><span class="sxs-lookup"><span data-stu-id="a7aaf-143">The following methods would be compatible:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#32)]  
  
 <span data-ttu-id="a7aaf-144">Quand `DoWork` est appelée sur une instance de `Derived`, le compilateur C# essaie d’abord de rendre l’appel compatible avec les versions de `DoWork` déclarées à l’origine sur `Derived`.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-144">When `DoWork` is called on an instance of `Derived`, the C# compiler will first try to make the call compatible with the versions of `DoWork` declared originally on `Derived`.</span></span> <span data-ttu-id="a7aaf-145">Les méthodes override ne sont pas considérées comme déclarées sur une classe ; il s’agit de nouvelles implémentations d’une méthode déclarée sur une classe de base.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-145">Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class.</span></span> <span data-ttu-id="a7aaf-146">Le compilateur C# essaiera de faire correspondre l’appel à une méthode substituée portant le même nom et avec des paramètres compatibles uniquement s’il ne parvient pas à faire correspondre l’appel de méthode à une méthode d’origine sur `Derived`.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-146">Only if the C# compiler cannot match the method call to an original method on `Derived` will it try to match the call to an overridden method with the same name and compatible parameters.</span></span> <span data-ttu-id="a7aaf-147">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="a7aaf-147">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#33](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#33)]  
  
 <span data-ttu-id="a7aaf-148">Étant donné que la variable `val` peut être convertie implicitement en un double, le compilateur C# appelle `DoWork(double)` au lieu de `DoWork(int)`.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-148">Because the variable `val` can be converted to a double implicitly, the C# compiler calls `DoWork(double)` instead of `DoWork(int)`.</span></span> <span data-ttu-id="a7aaf-149">Il existe deux façons d’éviter ceci.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-149">There are two ways to avoid this.</span></span> <span data-ttu-id="a7aaf-150">Premièrement, évitez de déclarer de nouvelles méthodes portant le même nom que des méthodes virtuelles.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-150">First, avoid declaring new methods with the same name as virtual methods.</span></span> <span data-ttu-id="a7aaf-151">Deuxièmement, vous pouvez indiquer au compilateur C# d’appeler la méthode virtuelle en le faisant chercher dans la liste de méthodes de la classe de base par casting de l’instance `Derived` en `Base`.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-151">Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of `Derived` to `Base`.</span></span> <span data-ttu-id="a7aaf-152">Étant donné que la méthode est virtuelle, l’implémentation de `DoWork(int)` sur `Derived` sera appelée.</span><span class="sxs-lookup"><span data-stu-id="a7aaf-152">Because the method is virtual, the implementation of `DoWork(int)` on `Derived` will be called.</span></span> <span data-ttu-id="a7aaf-153">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="a7aaf-153">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#34](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#34)]  
  
 <span data-ttu-id="a7aaf-154">Pour obtenir d’autres exemples des mots clés `new` et `override`, consultez [Savoir quand utiliser les mots clés override et new](./knowing-when-to-use-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="a7aaf-154">For more examples of `new` and `override`, see [Knowing When to Use Override and New Keywords](./knowing-when-to-use-override-and-new-keywords.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a7aaf-155">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="a7aaf-155">See also</span></span>

- [<span data-ttu-id="a7aaf-156">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="a7aaf-156">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="a7aaf-157">Classes et structs</span><span class="sxs-lookup"><span data-stu-id="a7aaf-157">Classes and Structs</span></span>](./index.md)
- [<span data-ttu-id="a7aaf-158">Méthodes</span><span class="sxs-lookup"><span data-stu-id="a7aaf-158">Methods</span></span>](./methods.md)
- [<span data-ttu-id="a7aaf-159">Héritage</span><span class="sxs-lookup"><span data-stu-id="a7aaf-159">Inheritance</span></span>](./inheritance.md)
