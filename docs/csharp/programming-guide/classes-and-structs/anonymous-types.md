---
title: Types anonymes - Guide de programmation C#
description: Les types anonymes en C# encapsulent un jeu de propriétés en lecture seule dans un objet sans avoir à définir explicitement un type. Le compilateur génère un nom.
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: f60c1ea4f3f029ec3b81a4197a711523ec372df9
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91186157"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="a8ff9-104">Types anonymes (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="a8ff9-104">Anonymous Types (C# Programming Guide)</span></span>

<span data-ttu-id="a8ff9-105">Les types anonymes permettent d'encapsuler un ensemble de propriétés en lecture seule dans un unique objet sans avoir à définir explicitement un type.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-105">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="a8ff9-106">Le nom du type est généré par le compilateur et n'est pas disponible au niveau du code source.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-106">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="a8ff9-107">Le type de chaque propriété est déduit par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-107">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="a8ff9-108">Vous créez des types anonymes en utilisant l’opérateur [new](../../language-reference/operators/new-operator.md) avec un initialiseur d’objet.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-108">You create anonymous types by using the [new](../../language-reference/operators/new-operator.md) operator together with an object initializer.</span></span> <span data-ttu-id="a8ff9-109">Pour plus d’informations sur les initialiseurs d’objets, consultez [Initialiseurs d’objets et de collections](./object-and-collection-initializers.md).</span><span class="sxs-lookup"><span data-stu-id="a8ff9-109">For more information about object initializers, see [Object and Collection Initializers](./object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="a8ff9-110">L'exemple suivant montre un type anonyme qui est initialisé avec deux propriétés nommées `Amount` et `Message`.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-110">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="a8ff9-111">Les types anonymes sont en règle générale utilisés dans la clause [select](../../language-reference/keywords/select-clause.md) d’une expression de requête pour retourner un sous-ensemble de propriétés de chaque objet dans la séquence source.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-111">Anonymous types typically are used in the [select](../../language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="a8ff9-112">Pour plus d’informations sur les requêtes, consultez [LINQ en C#](../../linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="a8ff9-112">For more information about queries, see [LINQ in C#](../../linq/index.md).</span></span>  
  
 <span data-ttu-id="a8ff9-113">Les types anonymes contiennent une ou plusieurs propriétés en lecture seule publiques.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-113">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="a8ff9-114">Aucun autre type de membres de classe, tels que des méthodes ou des événements, n'est valide.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-114">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="a8ff9-115">L'expression qui est utilisée pour initialiser une propriété ne peut pas être `null`, une fonction anonyme ou un type pointeur.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-115">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="a8ff9-116">Le scénario le plus courant consiste à initialiser un type anonyme avec les propriétés d'un autre type.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-116">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="a8ff9-117">Dans l'exemple suivant, une classe existe qui porte le nom `Product`.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-117">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="a8ff9-118">La classe `Product` comprend des propriétés `Color` et `Price`, ainsi que d'autres propriétés qui ne vous intéressent pas.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-118">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="a8ff9-119">La variable `products` est une collection d'objets `Product`.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-119">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="a8ff9-120">La déclaration de type anonyme commence par le mot clé `new`.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-120">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="a8ff9-121">La déclaration initialise un nouveau type qui utilise uniquement deux propriétés de `Product`.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-121">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="a8ff9-122">Une quantité réduite de données est ainsi retournée dans la requête.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-122">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="a8ff9-123">Si vous n'indiquez pas les noms de membre dans le type anonyme, le compilateur attribue aux membres de type anonyme le même nom que celui de la propriété utilisée pour les initialiser.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-123">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="a8ff9-124">Vous devez fournir un nom pour une propriété qui est initialisée avec une expression, comme indiqué dans l'exemple précédent.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-124">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="a8ff9-125">Dans l'exemple suivant, les noms des propriétés du type anonyme sont `Color` et `Price`.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-125">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csRef30Features/CS/csref30.cs#81)]  
  
 <span data-ttu-id="a8ff9-126">Quand vous utilisez un type anonyme pour initialiser une variable, vous déclarez la variable en tant que variable locale implicitement typée en utilisant [var](../../language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="a8ff9-126">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../language-reference/keywords/var.md).</span></span> <span data-ttu-id="a8ff9-127">Le nom de type ne peut pas être spécifié dans la déclaration de variable, car seul le compilateur a accès au nom sous-jacent du type anonyme.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-127">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="a8ff9-128">Pour plus d’informations sur `var`, consultez [Variables locales implicitement typées](./implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="a8ff9-128">For more information about `var`, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="a8ff9-129">Vous pouvez créer un tableau d'éléments typés anonymement en associant une variable locale implicitement typée et un tableau typé implicitement, comme indiqué dans l'exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-129">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="a8ff9-130">Notes</span><span class="sxs-lookup"><span data-stu-id="a8ff9-130">Remarks</span></span>  

 <span data-ttu-id="a8ff9-131">Les types anonymes sont des types [class](../../language-reference/keywords/class.md) qui dérivent directement d’[object](../../language-reference/builtin-types/reference-types.md) et qui ne peuvent pas être castés en type à l’exception du type [object](../../language-reference/builtin-types/reference-types.md).</span><span class="sxs-lookup"><span data-stu-id="a8ff9-131">Anonymous types are [class](../../language-reference/keywords/class.md) types that derive directly from [object](../../language-reference/builtin-types/reference-types.md), and that cannot be cast to any type except [object](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="a8ff9-132">Le compilateur fournit un nom pour chaque type anonyme, bien que votre application ne puisse pas y accéder.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-132">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="a8ff9-133">Du point de vue du CLR, un type anonyme n'est pas différent des autres types de référence.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-133">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="a8ff9-134">Si plusieurs initialiseurs d'objet dans un assembly spécifient une séquence de propriétés dans le même ordre et qui sont du même type et portent le même nom, le compilateur traite les objets comme des instances du même type.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-134">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="a8ff9-135">Elles partagent les mêmes informations de type générées par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-135">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="a8ff9-136">Vous ne pouvez pas déclarer un champ, une propriété, un événement ou le type de retour d'une méthode comme ayant un type anonyme.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-136">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="a8ff9-137">De même, vous ne pouvez pas déclarer un paramètre formel d'une méthode, d'une propriété, d'un constructeur ou d'un indexeur comme ayant un type anonyme.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-137">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="a8ff9-138">Pour passer un type anonyme, ou une collection qui contient des types anonymes, en tant qu'argument d'une méthode, vous pouvez déclarer le paramètre comme objet de type.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-138">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="a8ff9-139">Cependant, cela va à l'encontre de l'objectif du typage fort.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-139">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="a8ff9-140">Si vous devez stocker les résultats de requête ou les passer en dehors des limites de la méthode, utilisez un struct ordinaire ou une classe au lieu d'un type anonyme.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-140">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="a8ff9-141">Dans la mesure où les méthodes <xref:System.Object.Equals%2A> et <xref:System.Object.GetHashCode%2A> dans les types anonymes sont définies selon les termes des méthodes `Equals` et `GetHashCode` des propriétés, deux instances du même type anonyme sont égales si toutes leurs propriétés sont égales.</span><span class="sxs-lookup"><span data-stu-id="a8ff9-141">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a8ff9-142">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="a8ff9-142">See also</span></span>

- [<span data-ttu-id="a8ff9-143">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="a8ff9-143">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="a8ff9-144">Initialiseurs d’objets et de collections</span><span class="sxs-lookup"><span data-stu-id="a8ff9-144">Object and Collection Initializers</span></span>](./object-and-collection-initializers.md)
- [<span data-ttu-id="a8ff9-145">Mise en route de LINQ en C#</span><span class="sxs-lookup"><span data-stu-id="a8ff9-145">Getting Started with LINQ in C#</span></span>](../concepts/linq/index.md)
- [<span data-ttu-id="a8ff9-146">LINQ en C#</span><span class="sxs-lookup"><span data-stu-id="a8ff9-146">LINQ in C#</span></span>](../../linq/index.md)
