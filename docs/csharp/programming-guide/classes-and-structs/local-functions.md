---
title: Fonctions locales - Guide de programmation C#
description: Les fonctions locales en C# sont des méthodes privées qui sont imbriquées dans un autre membre et peuvent être appelées à partir de leur membre conteneur.
ms.date: 10/16/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 75accda2e40443073274ece4d8964c13a0945dad
ms.sourcegitcommit: dfcbc096ad7908cd58a5f0aeabd2256f05266bac
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/21/2020
ms.locfileid: "92332898"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="a17e5-103">Fonctions locales (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="a17e5-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="a17e5-104">À compter de C# 7.0, C# prend en charge les *fonctions locales*.</span><span class="sxs-lookup"><span data-stu-id="a17e5-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="a17e5-105">Les fonctions locales sont des méthodes privées d’un type qui sont imbriqués dans un autre membre.</span><span class="sxs-lookup"><span data-stu-id="a17e5-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="a17e5-106">Elles ne peuvent être appelées qu’à partir de leur membre conteneur.</span><span class="sxs-lookup"><span data-stu-id="a17e5-106">They can only be called from their containing member.</span></span> <span data-ttu-id="a17e5-107">Les fonctions locales peuvent être déclarées et appelées dans et à partir des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="a17e5-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="a17e5-108">Méthodes, tout particulièrement les méthodes iterator et async</span><span class="sxs-lookup"><span data-stu-id="a17e5-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="a17e5-109">Constructeurs</span><span class="sxs-lookup"><span data-stu-id="a17e5-109">Constructors</span></span>
- <span data-ttu-id="a17e5-110">Accesseurs de propriété</span><span class="sxs-lookup"><span data-stu-id="a17e5-110">Property accessors</span></span>
- <span data-ttu-id="a17e5-111">Accesseurs d’événement</span><span class="sxs-lookup"><span data-stu-id="a17e5-111">Event accessors</span></span>
- <span data-ttu-id="a17e5-112">Méthodes anonymes</span><span class="sxs-lookup"><span data-stu-id="a17e5-112">Anonymous methods</span></span>
- <span data-ttu-id="a17e5-113">Expressions lambda</span><span class="sxs-lookup"><span data-stu-id="a17e5-113">Lambda expressions</span></span>
- <span data-ttu-id="a17e5-114">Finaliseurs</span><span class="sxs-lookup"><span data-stu-id="a17e5-114">Finalizers</span></span>
- <span data-ttu-id="a17e5-115">Autres fonctions locales</span><span class="sxs-lookup"><span data-stu-id="a17e5-115">Other local functions</span></span>

<span data-ttu-id="a17e5-116">En revanche, les fonctions locales ne peuvent pas être déclarées à l’intérieur d’un membre expression-bodied.</span><span class="sxs-lookup"><span data-stu-id="a17e5-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="a17e5-117">Dans certains cas, vous pouvez utiliser une expression lambda pour implémenter la fonctionnalité également prise en charge par une fonction locale.</span><span class="sxs-lookup"><span data-stu-id="a17e5-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="a17e5-118">Pour une comparaison, consultez [fonctions locales et expressions lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="a17e5-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="a17e5-119">Les fonctions locales permettent de clarifier l’objectif de votre code.</span><span class="sxs-lookup"><span data-stu-id="a17e5-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="a17e5-120">Toute personne lisant votre code peut voir que la méthode ne peut pas être appelée, sauf par la méthode conteneur.</span><span class="sxs-lookup"><span data-stu-id="a17e5-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="a17e5-121">Pour les projets d’équipe, elles empêchent aussi à un autre développeur d’appeler par inadvertance la méthode directement à partir d’un autre emplacement dans la classe ou le struct.</span><span class="sxs-lookup"><span data-stu-id="a17e5-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="a17e5-122">Syntaxe des fonctions locales</span><span class="sxs-lookup"><span data-stu-id="a17e5-122">Local function syntax</span></span>

<span data-ttu-id="a17e5-123">Une fonction locale est définie en tant que méthode imbriquée à l’intérieur d’un membre conteneur.</span><span class="sxs-lookup"><span data-stu-id="a17e5-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="a17e5-124">Sa définition présente la syntaxe suivante :</span><span class="sxs-lookup"><span data-stu-id="a17e5-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="a17e5-125">Vous pouvez utiliser les modificateurs suivants avec une fonction locale :</span><span class="sxs-lookup"><span data-stu-id="a17e5-125">You can use the following modifiers with a local function:</span></span>

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- <span data-ttu-id="a17e5-126">[`static`](../../language-reference/keywords/static.md) (en C# 8,0 et versions ultérieures).</span><span class="sxs-lookup"><span data-stu-id="a17e5-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 and later).</span></span> <span data-ttu-id="a17e5-127">Une fonction locale statique ne peut pas capturer les variables locales ou l’état de l’instance.</span><span class="sxs-lookup"><span data-stu-id="a17e5-127">A static local function can't capture local variables or instance state.</span></span>
- <span data-ttu-id="a17e5-128">[`extern`](../../language-reference/keywords/extern.md) (en C# 9,0 et versions ultérieures).</span><span class="sxs-lookup"><span data-stu-id="a17e5-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 and later).</span></span> <span data-ttu-id="a17e5-129">Une fonction locale externe doit être `static` .</span><span class="sxs-lookup"><span data-stu-id="a17e5-129">An external local function must be `static`.</span></span>

<span data-ttu-id="a17e5-130">Toutes les variables locales définies dans le membre conteneur, y compris ses paramètres de méthode, sont accessibles dans une fonction locale non statique.</span><span class="sxs-lookup"><span data-stu-id="a17e5-130">All local variables that are defined in the containing member, including its method parameters, are accessible in a non-static local function.</span></span>

<span data-ttu-id="a17e5-131">Contrairement à une définition de méthode, une définition de fonction locale ne peut pas inclure le modificateur d’accès au membre.</span><span class="sxs-lookup"><span data-stu-id="a17e5-131">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="a17e5-132">Comme toutes les fonctions locales sont privées, l’inclusion d’un modificateur d’accès, tel que le mot clé `private`, génère l’erreur de compilateur CS0106 : « Le modificateur « private » n’est pas valide pour cet élément ».</span><span class="sxs-lookup"><span data-stu-id="a17e5-132">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

<span data-ttu-id="a17e5-133">L’exemple suivant définit une fonction locale nommée `AppendPathSeparator` qui est privée pour une méthode nommée `GetText` :</span><span class="sxs-lookup"><span data-stu-id="a17e5-133">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="Basic" :::

<span data-ttu-id="a17e5-134">À compter de C# 9,0, vous pouvez appliquer des attributs à une fonction locale, à ses paramètres et à ses paramètres de type, comme le montre l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="a17e5-134">Beginning with C# 9.0, you can apply attributes to a local function, its parameters and type parameters, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="WithAttributes" :::

<span data-ttu-id="a17e5-135">L’exemple précédent utilise un [attribut spécial](../../language-reference/attributes/nullable-analysis.md) pour aider le compilateur dans une analyse statique dans un contexte Nullable.</span><span class="sxs-lookup"><span data-stu-id="a17e5-135">The preceding example uses a [special attribute](../../language-reference/attributes/nullable-analysis.md) to assist the compiler in static analysis in a nullable context.</span></span>

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="a17e5-136">Fonctions locales et exceptions</span><span class="sxs-lookup"><span data-stu-id="a17e5-136">Local functions and exceptions</span></span>

<span data-ttu-id="a17e5-137">L’une des caractéristiques intéressantes des fonctions locales est qu’elles permettent l’affichage immédiat des exceptions.</span><span class="sxs-lookup"><span data-stu-id="a17e5-137">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="a17e5-138">Pour les itérateurs de méthode, les exceptions apparaissent uniquement au moment où la séquence retournée est énumérée, et non à la récupération de l’itérateur.</span><span class="sxs-lookup"><span data-stu-id="a17e5-138">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="a17e5-139">Pour les méthodes async, les exceptions levées dans une méthode async sont observées quand la tâche retournée est attendue.</span><span class="sxs-lookup"><span data-stu-id="a17e5-139">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="a17e5-140">L’exemple suivant définit une `OddSequence` méthode qui énumère les nombres impairs dans une plage spécifiée.</span><span class="sxs-lookup"><span data-stu-id="a17e5-140">The following example defines an `OddSequence` method that enumerates odd numbers in a specified range.</span></span> <span data-ttu-id="a17e5-141">Sachant qu’elle passe à la méthode d’énumérateur `OddSequence` un nombre supérieur à 100, la méthode lève une exception <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="a17e5-141">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="a17e5-142">Comme le montre la sortie de l’exemple, l’exception apparaît uniquement au moment d’itérer les nombres, et non à la récupération de l’énumérateur.</span><span class="sxs-lookup"><span data-stu-id="a17e5-142">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithoutLocal.cs" :::

<span data-ttu-id="a17e5-143">Si vous placez la logique d’itérateur dans une fonction locale, les exceptions de validation d’argument sont levées lorsque vous récupérez l’énumérateur, comme le montre l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="a17e5-143">If you put iterator logic into a local function, argument validation exceptions are thrown when you retrieve the enumerator, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithLocal.cs" :::

<span data-ttu-id="a17e5-144">Vous pouvez utiliser des fonctions locales de la même façon avec les opérations asynchrones.</span><span class="sxs-lookup"><span data-stu-id="a17e5-144">You can use local functions in a similar way with asynchronous operations.</span></span> <span data-ttu-id="a17e5-145">Exceptions levées dans une surface de méthode Async lorsque la tâche correspondante est attendue.</span><span class="sxs-lookup"><span data-stu-id="a17e5-145">Exceptions thrown in an async method surface when the corresponding task is awaited.</span></span> <span data-ttu-id="a17e5-146">Les fonctions locales permettent à votre code d’échouer rapidement et à votre exception d’être à la fois levée et observée de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="a17e5-146">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="a17e5-147">L’exemple suivant utilise une méthode asynchrone nommée `GetMultipleAsync` visant à marquer une pause pendant un nombre défini de secondes et retourner une valeur qui est un multiple aléatoire de ce nombre de secondes.</span><span class="sxs-lookup"><span data-stu-id="a17e5-147">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="a17e5-148">Le délai maximal est de 5 secondes ; une exception <xref:System.ArgumentOutOfRangeException> est obtenue si la valeur est supérieure à 5.</span><span class="sxs-lookup"><span data-stu-id="a17e5-148">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="a17e5-149">Comme le montre l’exemple suivant, l’exception levée lorsqu’une valeur de 6 est passée à la `GetMultipleAsync` méthode est observée uniquement lorsque la tâche est attendue.</span><span class="sxs-lookup"><span data-stu-id="a17e5-149">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is observed only when the task is awaited.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithoutLocal.cs" :::

<span data-ttu-id="a17e5-150">Comme avec l’itérateur de méthode, vous pouvez refactoriser l’exemple précédent et placer le code de l’opération asynchrone dans une fonction locale.</span><span class="sxs-lookup"><span data-stu-id="a17e5-150">Like with the method iterator, you can refactor the preceding example and put the code of asynchronous operation in a local function.</span></span> <span data-ttu-id="a17e5-151">Comme le montre la sortie de l’exemple suivant, le <xref:System.ArgumentOutOfRangeException> est levé dès que la `GetMultiple` méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="a17e5-151">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is thrown as soon as the `GetMultiple` method is called.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithLocal.cs" :::

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="a17e5-152">Fonctions locales et expressions lambda</span><span class="sxs-lookup"><span data-stu-id="a17e5-152">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="a17e5-153">À première vue, les fonctions locales et les [expressions lambda](../../language-reference/operators/lambda-expressions.md) sont très similaires.</span><span class="sxs-lookup"><span data-stu-id="a17e5-153">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="a17e5-154">Souvent, le choix d’utiliser des expressions lambda ou des fonctions locales est une question de style et de préférences personnelles.</span><span class="sxs-lookup"><span data-stu-id="a17e5-154">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="a17e5-155">Toutefois, il existe de réelles différences qui vous feront utiliser les unes ou les autres et que vous devez connaître.</span><span class="sxs-lookup"><span data-stu-id="a17e5-155">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="a17e5-156">Examinons les différences entre l’implémentation de l’algorithme factoriel avec une fonction locale et une expression lambda.</span><span class="sxs-lookup"><span data-stu-id="a17e5-156">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="a17e5-157">Voici la version à l’aide d’une fonction locale :</span><span class="sxs-lookup"><span data-stu-id="a17e5-157">Here's the version using a local function:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLocal" :::

<span data-ttu-id="a17e5-158">Cette version utilise des expressions lambda :</span><span class="sxs-lookup"><span data-stu-id="a17e5-158">This version uses lambda expressions:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLambda" :::

### <a name="naming"></a><span data-ttu-id="a17e5-159">Dénomination</span><span class="sxs-lookup"><span data-stu-id="a17e5-159">Naming</span></span>

<span data-ttu-id="a17e5-160">Les fonctions locales sont nommées explicitement comme les méthodes.</span><span class="sxs-lookup"><span data-stu-id="a17e5-160">Local functions are explicitly named like methods.</span></span> <span data-ttu-id="a17e5-161">Les expressions lambda sont des méthodes anonymes qui doivent être assignées à des variables d’un `delegate` type, généralement des `Action` `Func` types ou.</span><span class="sxs-lookup"><span data-stu-id="a17e5-161">Lambda expressions are anonymous methods and need to be assigned to variables of a `delegate` type, typically either `Action` or `Func` types.</span></span> <span data-ttu-id="a17e5-162">Lorsque vous déclarez une fonction locale, le processus est semblable à l’écriture d’une méthode normale ; vous déclarez un type de retour et une signature de fonction.</span><span class="sxs-lookup"><span data-stu-id="a17e5-162">When you declare a local function, the process is like writing a normal method; you declare a return type and a function signature.</span></span>

### <a name="function-signatures-and-lambda-expression-types"></a><span data-ttu-id="a17e5-163">Signatures de fonctions et types d’expression lambda</span><span class="sxs-lookup"><span data-stu-id="a17e5-163">Function signatures and lambda expression types</span></span>

<span data-ttu-id="a17e5-164">Les expressions lambda s’appuient sur le type de la `Action` / `Func` variable qu’elles sont assignées pour déterminer les types d’arguments et de retour.</span><span class="sxs-lookup"><span data-stu-id="a17e5-164">Lambda expressions rely on the type of the `Action`/`Func` variable that they're assigned to determine the argument and return types.</span></span> <span data-ttu-id="a17e5-165">Dans les fonctions locales, étant donné que la syntaxe est très similaire à l’écriture d’une méthode normale, les types d’argument et le type de retour font déjà partie de la déclaration de fonction.</span><span class="sxs-lookup"><span data-stu-id="a17e5-165">In local functions, since the syntax is much like writing a normal method, argument types and return type are already part of the function declaration.</span></span>

### <a name="definite-assignment"></a><span data-ttu-id="a17e5-166">Assignation définie</span><span class="sxs-lookup"><span data-stu-id="a17e5-166">Definite assignment</span></span>

<span data-ttu-id="a17e5-167">Les expressions lambda sont des objets qui sont déclarés et assignés au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="a17e5-167">Lambda expressions are objects that are declared and assigned at runtime.</span></span> <span data-ttu-id="a17e5-168">Pour qu’une expression lambda soit utilisée, elle doit être assignée de manière définitive : la `Action` / `Func` variable à laquelle elle sera assignée doit être déclarée et l’expression lambda assignée à celle-ci.</span><span class="sxs-lookup"><span data-stu-id="a17e5-168">In order for a lambda expression to be used, it needs to be definitely assigned: the `Action`/`Func` variable that it will be assigned to must be declared and the lambda expression assigned to it.</span></span> <span data-ttu-id="a17e5-169">Notez que `LambdaFactorial` doit déclarer et initialiser l’expression lambda `nthFactorial` avant de la définir.</span><span class="sxs-lookup"><span data-stu-id="a17e5-169">Notice that `LambdaFactorial` must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="a17e5-170">Si ce n’est pas le cas, cela entraîne une erreur de compilation due au fait que vous référencez `nthFactorial` avant de lui affecter une valeur.</span><span class="sxs-lookup"><span data-stu-id="a17e5-170">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>

<span data-ttu-id="a17e5-171">Les fonctions locales sont définies au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="a17e5-171">Local functions are defined at compile time.</span></span> <span data-ttu-id="a17e5-172">Comme elles ne sont pas affectées à des variables, elles peuvent être référencées à partir de n’importe quel emplacement de code **où elles se trouvent dans la portée**; dans notre premier exemple `LocalFunctionFactorial` , nous pourrions déclarer notre fonction locale soit au-dessus soit au-dessous de l' `return` instruction et ne déclenchent aucune erreur du compilateur.</span><span class="sxs-lookup"><span data-stu-id="a17e5-172">As they're not assigned to variables, they can be referenced from any code location **where it is in scope**; in our first example `LocalFunctionFactorial`, we could declare our local function either above or below the `return` statement and not trigger any compiler errors.</span></span>

<span data-ttu-id="a17e5-173">Ces différences font que les algorithmes récursifs sont plus faciles à créer en utilisant des fonctions locales.</span><span class="sxs-lookup"><span data-stu-id="a17e5-173">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="a17e5-174">Vous pouvez déclarer et définir une fonction locale qui s’appelle elle-même.</span><span class="sxs-lookup"><span data-stu-id="a17e5-174">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="a17e5-175">Les expressions lambda doivent être déclarées et une valeur par défaut doit leur être affectée avant qu’elles puissent être réaffectées à un corps référençant la même expression lambda.</span><span class="sxs-lookup"><span data-stu-id="a17e5-175">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

### <a name="implementation-as-a-delegate"></a><span data-ttu-id="a17e5-176">Implémentation en tant que délégué</span><span class="sxs-lookup"><span data-stu-id="a17e5-176">Implementation as a delegate</span></span>

<span data-ttu-id="a17e5-177">Les expressions lambda sont converties en délégués lorsqu’elles sont déclarées.</span><span class="sxs-lookup"><span data-stu-id="a17e5-177">Lambda expressions are converted to delegates when they're declared.</span></span> <span data-ttu-id="a17e5-178">Les fonctions locales sont plus flexibles dans la mesure où elles peuvent être écrites comme une méthode traditionnelle *ou* en tant que délégué.</span><span class="sxs-lookup"><span data-stu-id="a17e5-178">Local functions are more flexible in that they can be written like a traditional method *or* as a delegate.</span></span> <span data-ttu-id="a17e5-179">Les fonctions locales sont converties en délégués uniquement lorsqu’elles sont ***utilisées*** en tant que délégué.</span><span class="sxs-lookup"><span data-stu-id="a17e5-179">Local functions are only converted to delegates when ***used*** as a delegate.</span></span>

<span data-ttu-id="a17e5-180">Si vous déclarez une fonction locale et la référencez uniquement en l’appelant comme une méthode, elle ne sera pas convertie en délégué.</span><span class="sxs-lookup"><span data-stu-id="a17e5-180">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span>

### <a name="variable-capture"></a><span data-ttu-id="a17e5-181">Capture de variables</span><span class="sxs-lookup"><span data-stu-id="a17e5-181">Variable capture</span></span>

<span data-ttu-id="a17e5-182">Les règles d' [assignation définie](../../../../_csharplang/spec/variables.md#definite-assignment) affectent également toutes les variables capturées par la fonction locale ou l’expression lambda.</span><span class="sxs-lookup"><span data-stu-id="a17e5-182">The rules of [definite assignment](../../../../_csharplang/spec/variables.md#definite-assignment) also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="a17e5-183">Le compilateur peut effectuer une analyse statique qui permet aux fonctions locales d’affecter de manière définitive des variables capturées dans la portée englobante.</span><span class="sxs-lookup"><span data-stu-id="a17e5-183">The compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="a17e5-184">Prenons l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="a17e5-184">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="a17e5-185">Le compilateur peut déterminer que `LocalFunction` affecte `y` de manière définitive lorsqu’elle est appelée.</span><span class="sxs-lookup"><span data-stu-id="a17e5-185">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="a17e5-186">Dans la mesure où `LocalFunction` est appelée avant l’instruction `return`, `y` est affecté de manière définitive à l’instruction `return`.</span><span class="sxs-lookup"><span data-stu-id="a17e5-186">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="a17e5-187">Notez que lorsqu’une fonction locale capture des variables dans la portée englobante, la fonction locale est implémentée en tant que type délégué.</span><span class="sxs-lookup"><span data-stu-id="a17e5-187">Note that when a local function captures variables in the enclosing scope, the local function is implemented as a delegate type.</span></span>

### <a name="heap-allocations"></a><span data-ttu-id="a17e5-188">Allocations de tas</span><span class="sxs-lookup"><span data-stu-id="a17e5-188">Heap allocations</span></span>

<span data-ttu-id="a17e5-189">En fonction de leur utilisation, les fonctions locales peuvent éviter les allocations de tas qui sont toujours nécessaires pour les expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="a17e5-189">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="a17e5-190">Si une fonction locale n’est jamais convertie en délégué, et si aucune des variables capturées par la fonction locale n’est capturée par d’autres expressions lambda ou fonctions locales converties en délégués, le compilateur peut éviter les allocations de tas.</span><span class="sxs-lookup"><span data-stu-id="a17e5-190">If a local function is never converted to a delegate, and none of the variables captured by the local function are captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="a17e5-191">Penchons-nous sur cet exemple asynchrone :</span><span class="sxs-lookup"><span data-stu-id="a17e5-191">Consider this async example:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLambda" :::

<span data-ttu-id="a17e5-192">La fermeture de cette expression lambda contient les variables `address`, `index` et `name`.</span><span class="sxs-lookup"><span data-stu-id="a17e5-192">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="a17e5-193">Dans le cas des fonctions locales, l’objet qui implémente la fermeture peut être un type `struct`.</span><span class="sxs-lookup"><span data-stu-id="a17e5-193">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="a17e5-194">Ce type de struct serait transmis par référence à la fonction locale.</span><span class="sxs-lookup"><span data-stu-id="a17e5-194">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="a17e5-195">Cette différence d’implémentation évite une allocation.</span><span class="sxs-lookup"><span data-stu-id="a17e5-195">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="a17e5-196">L’instanciation nécessaire pour les expressions lambda signifie des allocations de mémoire supplémentaires, qui peuvent être un facteur influençant les performances dans les chemins de code critiques au niveau du temps.</span><span class="sxs-lookup"><span data-stu-id="a17e5-196">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="a17e5-197">Les fonctions locales n’entraînent pas cette charge supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="a17e5-197">Local functions do not incur this overhead.</span></span> <span data-ttu-id="a17e5-198">Dans l’exemple ci-dessus, la version des fonctions locales a deux allocations moins nombreuses que la version de l’expression lambda.</span><span class="sxs-lookup"><span data-stu-id="a17e5-198">In the example above, the local functions version has two fewer allocations than the lambda expression version.</span></span>

<span data-ttu-id="a17e5-199">Si vous savez que votre fonction locale ne sera pas convertie en un délégué et qu’aucune des variables capturées par celle-ci n’est capturée par d’autres expressions lambda ou fonctions locales converties en délégués, vous pouvez vous assurer que votre fonction locale évite d’être allouée sur le tas en la déclarant comme une `static` fonction locale.</span><span class="sxs-lookup"><span data-stu-id="a17e5-199">If you know that your local function won't be converted to a delegate and none of the variables captured by it are captured by other lambdas or local functions that are converted to delegates, you can guarantee that your local function avoids being allocated on the heap by declaring it as a `static` local function.</span></span> <span data-ttu-id="a17e5-200">Notez que cette fonctionnalité est disponible dans C# 8,0 et versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="a17e5-200">Note that this feature is available in C# 8.0 and newer.</span></span>

> [!NOTE]
> <span data-ttu-id="a17e5-201">L’équivalent de cette méthode avec une fonction locale fait aussi appel à une classe pour la fermeture.</span><span class="sxs-lookup"><span data-stu-id="a17e5-201">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="a17e5-202">Le fait que la fermeture d’une fonction locale soit implémentée en tant que `class` ou `struct` est un détail d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="a17e5-202">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="a17e5-203">Une fonction locale peut utiliser un type `struct` contrairement à une expression lambda qui utilise toujours un type `class`.</span><span class="sxs-lookup"><span data-stu-id="a17e5-203">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLocal" :::

### <a name="usage-of-the-yield-keyword"></a><span data-ttu-id="a17e5-204">Utilisation du `yield` mot clé</span><span class="sxs-lookup"><span data-stu-id="a17e5-204">Usage of the `yield` keyword</span></span>

<span data-ttu-id="a17e5-205">Ultime avantage non décrit dans cet exemple : les fonctions locales peuvent être implémentées en tant qu’itérateurs, en utilisant la syntaxe `yield return` pour produire une séquence de valeurs.</span><span class="sxs-lookup"><span data-stu-id="a17e5-205">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="YieldReturn" :::

<span data-ttu-id="a17e5-206">L' `yield return` instruction n’est pas autorisée dans les expressions lambda, consultez [Erreur du compilateur CS1621](../../misc/cs1621.md).</span><span class="sxs-lookup"><span data-stu-id="a17e5-206">The `yield return` statement is not allowed in lambda expressions, see [compiler error CS1621](../../misc/cs1621.md).</span></span>

<span data-ttu-id="a17e5-207">Alors que les fonctions locales peuvent sembler redondantes par rapport aux expressions lambda, elles ont en réalité des objectifs différents et des utilisations différentes.</span><span class="sxs-lookup"><span data-stu-id="a17e5-207">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="a17e5-208">Les fonctions locales sont plus efficaces dans le cas où vous voulez écrire une fonction qui est appelée seulement dans le contexte d’une autre méthode.</span><span class="sxs-lookup"><span data-stu-id="a17e5-208">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="a17e5-209">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="a17e5-209">See also</span></span>

- [<span data-ttu-id="a17e5-210">Méthodes</span><span class="sxs-lookup"><span data-stu-id="a17e5-210">Methods</span></span>](methods.md)
