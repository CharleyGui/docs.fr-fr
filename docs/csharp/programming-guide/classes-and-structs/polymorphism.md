---
title: Polymorphisme - Guide de programmation C#
ms.date: 02/08/2020
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 169ba2a1307a301c80b3d9ccac45f4ac9f707921
ms.sourcegitcommit: 44a7cd8687f227fc6db3211ccf4783dc20235e51
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/26/2020
ms.locfileid: "77626286"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="4e1f5-102">Polymorphisme (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="4e1f5-102">Polymorphism (C# Programming Guide)</span></span>

<span data-ttu-id="4e1f5-103">Le polymorphisme est souvent considéré comme le troisième pilier d'une programmation orientée objet, après l'encapsulation et l'héritage.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="4e1f5-104">Le polymorphisme est le mot grec qui signifie « plusieurs formes » et il prend deux aspects distincts :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>
  
- <span data-ttu-id="4e1f5-105">Au moment de l’exécution, les objets d’une classe dérivée peuvent être traités comme des objets d’une classe de base dans les paramètres de méthode et les collections ou les tableaux.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="4e1f5-106">Lorsque ce polymorphisme se produit, le type déclaré de l’objet n’est plus identique à son type au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-106">When this polymorphism occurs, the object's declared type is no longer identical to its run-time type.</span></span>
- <span data-ttu-id="4e1f5-107">Les classes de base peuvent définir et implémenter des *méthodes* [virtuelles](../../language-reference/keywords/virtual.md) , et les classes dérivées peuvent les [substituer](../../language-reference/keywords/override.md) , ce qui signifie qu’elles fournissent leur propre définition et implémentation.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-107">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="4e1f5-108">Au moment de l'exécution, quand le code client appelle la méthode, le CLR recherche le type au moment de l'exécution et appelle cette substitution de la méthode virtuelle.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="4e1f5-109">Dans votre code source, vous pouvez appeler une méthode sur une classe de base et provoquer l’exécution de la version d’une classe dérivée de la méthode.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-109">In your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>

<span data-ttu-id="4e1f5-110">Les méthodes virtuelles vous permettent d'utiliser des groupes d'objets liés de façon uniforme.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="4e1f5-111">Par exemple, si vous avez une application de dessin qui permet à un utilisateur de créer différents types de formes sur une surface de dessin.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="4e1f5-112">Vous ne savez pas au moment de la compilation les types de formes spécifiques que l'utilisateur va créer.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="4e1f5-113">Cependant, l'application doit conserver une trace des différents types de formes créés et les mettre à jour en réponse aux actions de la souris.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="4e1f5-114">Vous pouvez utiliser le polymorphisme pour résoudre ce problème en deux étapes :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-114">You can use polymorphism to solve this problem in two basic steps:</span></span>

1. <span data-ttu-id="4e1f5-115">Créer une hiérarchie de classe dans laquelle chaque classe de forme dérive d'une classe de base commune.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>
1. <span data-ttu-id="4e1f5-116">Utiliser une méthode virtuelle pour appeler la méthode appropriée dans une classe dérivée via un seul appel à la méthode de classe de base.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>

<span data-ttu-id="4e1f5-117">Tout d'abord, créez une classe de base appelée `Shape`, et des classes dérivées telles que `Rectangle`, `Circle`, et `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="4e1f5-118">Donnez à la classe `Shape` une méthode virtuelle appelée `Draw`, et substituez-la dans chaque classe dérivée pour dessiner une forme spécifique représentée par la classe.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="4e1f5-119">Créez un objet `List<Shape>` et ajoutez-y un `Circle`, `Triangle`et `Rectangle`.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-119">Create a `List<Shape>` object and add a `Circle`, `Triangle`, and `Rectangle` to it.</span></span> 

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#PolymorphismOverview)]

<span data-ttu-id="4e1f5-120">Pour mettre à jour la surface de dessin, utilisez une boucle [foreach](../../language-reference/keywords/foreach-in.md) pour l’itération dans la liste et appelez la méthode `Draw` sur chaque objet `Shape` de la liste.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-120">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="4e1f5-121">Bien que chaque objet de la liste ait un type déclaré de `Shape`, il s’agit du type au moment de l’exécution (la version substituée de la méthode dans chaque classe dérivée) qui sera appelée.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-121">Even though each object in the list has a declared type of `Shape`, it's the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UsePolymorphism)]

<span data-ttu-id="4e1f5-122">En C#, chaque type est polymorphique, car tous les types, y compris les types définis par l'utilisateur, héritent de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  

## <a name="polymorphism-overview"></a><span data-ttu-id="4e1f5-123">Vue d’ensemble du polymorphisme</span><span class="sxs-lookup"><span data-stu-id="4e1f5-123">Polymorphism overview</span></span>

### <a name="virtual-members"></a><span data-ttu-id="4e1f5-124">Membres virtuels</span><span class="sxs-lookup"><span data-stu-id="4e1f5-124">Virtual members</span></span>

<span data-ttu-id="4e1f5-125">Lorsqu’une classe dérivée hérite d’une classe de base, elle obtient toutes les méthodes, les champs, les propriétés et les événements de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-125">When a derived class inherits from a base class, it gains all the methods, fields, properties, and events of the base class.</span></span> <span data-ttu-id="4e1f5-126">Le concepteur de la classe dérivée peut choisir un comportement différent pour les méthodes virtuelles :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-126">The designer of the derived class can different choices for the behavior of virtual methods:</span></span>

- <span data-ttu-id="4e1f5-127">La classe dérivée peut substituer des membres virtuels dans la classe de base, définissant un nouveau comportement.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-127">The derived class may override virtual members in the base class, defining new behavior.</span></span>
- <span data-ttu-id="4e1f5-128">La classe dérivée hérite de la méthode de classe de base la plus proche sans la substituer, en préservant le comportement existant, mais en permettant à d’autres classes dérivées de substituer la méthode.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-128">The derived class inherit the closest base class method without overriding it, preserving the existing behavior but enabling further derived classes to override the method.</span></span>
- <span data-ttu-id="4e1f5-129">La classe dérivée peut définir une nouvelle implémentation non virtuelle de ces membres qui masquent les implémentations de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-129">The derived class may define new non-virtual implementation of those members that hide the base class implementations.</span></span>

<span data-ttu-id="4e1f5-130">Une classe dérivée ne peut substituer un membre de classe de base que si le membre de classe de base est déclaré comme étant [virtual](../../language-reference/keywords/virtual.md) ou [abstract](../../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="4e1f5-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="4e1f5-131">Le membre dérivé doit utiliser le mot clé [override](../../language-reference/keywords/override.md) pour indiquer explicitement que la méthode est conçue pour participer à l’appel virtuel.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-131">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="4e1f5-132">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-132">The following code provides an example:</span></span>

[!code-csharp[Virtual overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="4e1f5-133">Les champs ne peuvent pas être virtuels ; seules les méthodes, les propriétés, les événements et les indexeurs peuvent être virtuels.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-133">Fields cannot be virtual; only methods, properties, events, and indexers can be virtual.</span></span> <span data-ttu-id="4e1f5-134">Quand une classe dérivée est substituée à un membre virtuel, ce membre est appelé lors de l'accès à une instance de cette classe en tant qu'instance de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="4e1f5-135">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-135">The following code provides an example:</span></span>

[!code-csharp[Virtual overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="4e1f5-136">Les méthodes et propriétés virtuelles permettent aux classes dérivées d'étendre une classe de base sans avoir besoin d'utiliser l'implémentation de classe de base d'une méthode.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="4e1f5-137">Pour plus d’informations, consultez [Versioning avec les mots clés override et new](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="4e1f5-137">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="4e1f5-138">Une interface fournit un autre moyen pour définir une méthode ou un ensemble de méthodes dont l'implémentation est confiée aux classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="4e1f5-139">Pour plus d’informations, consultez [Interfaces](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="4e1f5-139">For more information, see [Interfaces](../interfaces/index.md).</span></span>

### <a name="hide-base-class-members-with-new-members"></a><span data-ttu-id="4e1f5-140">Masquer les membres de la classe de base avec les nouveaux membres</span><span class="sxs-lookup"><span data-stu-id="4e1f5-140">Hide base class members with new members</span></span>

<span data-ttu-id="4e1f5-141">Si vous souhaitez que votre classe dérivée ait un membre portant le même nom qu’un membre dans une classe de base, vous pouvez utiliser le mot clé [New](../../language-reference/keywords/new-modifier.md) pour masquer le membre de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-141">If you want your derived class to have a member with the same name as a member in a base class, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword to hide the base class member.</span></span> <span data-ttu-id="4e1f5-142">Le mot clé `new` est placé avec le type de retour d'un membre de classe qui est remplacé.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="4e1f5-143">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-143">The following code provides an example:</span></span>

[!code-csharp[New method overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#NewMethods)]

<span data-ttu-id="4e1f5-144">Les membres masqués de la classe de base sont accessibles à partir du code client en effectuant un cast de l’instance de la classe dérivée vers une instance de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-144">Hidden base class members may be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="4e1f5-145">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-145">For example:</span></span>

[!code-csharp[New method overview usage](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UseNewMethods)]

### <a name="prevent-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="4e1f5-146">Empêcher les classes dérivées de substituer des membres virtuels</span><span class="sxs-lookup"><span data-stu-id="4e1f5-146">Prevent derived classes from overriding virtual members</span></span>  

<span data-ttu-id="4e1f5-147">Les membres virtuels restent virtuels, quel que soit le nombre de classes déclarées entre le membre virtuel et la classe qui l’a déclaré à l’origine.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-147">Virtual members remain virtual, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="4e1f5-148">Si la classe `A` déclare un membre virtuel, et que la classe `B` dérive de `A`, et que la classe `C` dérive de `B`, Class `C` hérite du membre virtuel et peut le substituer, que la classe `B` ait déclaré ou non une substitution pour ce membre.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-148">If class `A` declares a virtual member, and class `B` derives from `A`, and class `C` derives from `B`, class `C` inherits the virtual member, and may override it, regardless of whether class `B` declared an override for that member.</span></span> <span data-ttu-id="4e1f5-149">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-149">The following code provides an example:</span></span>

[!code-csharp[Basic hierarchy](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#FirstHierarchy)]

<span data-ttu-id="4e1f5-150">Une classe dérivée peut arrêter l’héritage virtuel en déclarant une substitution comme étant [sealed](../../language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="4e1f5-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="4e1f5-151">L’arrêt de l’héritage nécessite de placer le mot clé `sealed` avant le mot clé `override` dans la déclaration de membre de classe.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-151">Stopping inheritance requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="4e1f5-152">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-152">The following code provides an example:</span></span>

[!code-csharp[A sealed overridden member](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#SealedOverride)]

<span data-ttu-id="4e1f5-153">Dans l’exemple précédent, la méthode `DoWork` n’est plus virtuelle à une classe dérivée de `C`.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from `C`.</span></span> <span data-ttu-id="4e1f5-154">Elle est toujours virtuelle pour les instances de `C`, même si elles sont converties en type `B` ou de type `A`.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-154">It's still virtual for instances of `C`, even if they're cast to type `B` or type `A`.</span></span> <span data-ttu-id="4e1f5-155">Les méthodes sealed peuvent être remplacées par des classes dérivées à l’aide du mot clé `new`, comme le montre l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-155">Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>

[!code-csharp[New method declaration](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#NewDeclaration)]

<span data-ttu-id="4e1f5-156">Dans ce cas, si `DoWork` est appelé sur `D` à l’aide d’une variable de type `D`, la nouvelle `DoWork` est appelée.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-156">In this case, if `DoWork` is called on `D` using a variable of type `D`, the new `DoWork` is called.</span></span> <span data-ttu-id="4e1f5-157">Si une variable de type `C`, `B`ou `A` est utilisée pour accéder à une instance de `D`, un appel à `DoWork` suit les règles d’héritage virtuel, en routant ces appels à l’implémentation de `DoWork` sur la classe `C`.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-157">If a variable of type `C`, `B`, or `A` is used to access an instance of `D`, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class `C`.</span></span>

### <a name="access-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="4e1f5-158">Accéder aux membres virtuels de la classe de base à partir de classes dérivées</span><span class="sxs-lookup"><span data-stu-id="4e1f5-158">Access base class virtual members from derived classes</span></span>

<span data-ttu-id="4e1f5-159">Une classe dérivée qui a remplacé ou écrasé une méthode ou une propriété peut encore accéder à la méthode ou à la propriété dans la classe de base avec le mot clé `base`.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-159">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="4e1f5-160">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="4e1f5-160">The following code provides an example:</span></span>

```csharp
public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
        //Perform Derived's work here
        //...
        // Call DoWork on base class
        base.DoWork();
    }
}
```

<span data-ttu-id="4e1f5-161">Pour plus d'informations, consultez [base](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="4e1f5-161">For more information, see [base](../../language-reference/keywords/base.md).</span></span>

> [!NOTE]
> <span data-ttu-id="4e1f5-162">Il est recommandé que les membres virtuels utilisent `base` pour appeler l'implémentation de classe de base de ce membre dans leur propre implémentation.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-162">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="4e1f5-163">L'exécution du comportement de classe de base permet à la classe dérivée de se concentrer sur l'implémentation du comportement spécifique à la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-163">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="4e1f5-164">Si l'implémentation de classe de base n'est pas appelée, la classe dérivée doit rendre son comportement compatible avec le comportement de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="4e1f5-164">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="4e1f5-165">Contenu de cette section</span><span class="sxs-lookup"><span data-stu-id="4e1f5-165">In this section</span></span>

- [<span data-ttu-id="4e1f5-166">Versioning avec les mots clés override et new</span><span class="sxs-lookup"><span data-stu-id="4e1f5-166">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)
- [<span data-ttu-id="4e1f5-167">Savoir quand utiliser les mots clés override et new</span><span class="sxs-lookup"><span data-stu-id="4e1f5-167">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)
- [<span data-ttu-id="4e1f5-168">Comment substituer la méthode ToString</span><span class="sxs-lookup"><span data-stu-id="4e1f5-168">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)

## <a name="see-also"></a><span data-ttu-id="4e1f5-169">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="4e1f5-169">See also</span></span>

- [<span data-ttu-id="4e1f5-170">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="4e1f5-170">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="4e1f5-171">Héritage</span><span class="sxs-lookup"><span data-stu-id="4e1f5-171">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="4e1f5-172">Classes abstract et sealed et membres de classe</span><span class="sxs-lookup"><span data-stu-id="4e1f5-172">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="4e1f5-173">Méthodes</span><span class="sxs-lookup"><span data-stu-id="4e1f5-173">Methods</span></span>](./methods.md)
- [<span data-ttu-id="4e1f5-174">Événements</span><span class="sxs-lookup"><span data-stu-id="4e1f5-174">Events</span></span>](../events/index.md)
- [<span data-ttu-id="4e1f5-175">Propriétés</span><span class="sxs-lookup"><span data-stu-id="4e1f5-175">Properties</span></span>](./properties.md)
- [<span data-ttu-id="4e1f5-176">Indexeurs</span><span class="sxs-lookup"><span data-stu-id="4e1f5-176">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="4e1f5-177">Types</span><span class="sxs-lookup"><span data-stu-id="4e1f5-177">Types</span></span>](../types/index.md)
