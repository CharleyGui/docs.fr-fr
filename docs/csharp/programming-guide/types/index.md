---
title: Types - Guide de programmation C#
description: En savoir plus sur les types en programmation C#, tels que les types intégrés, les types personnalisés, les types valeur et les types référence.
ms.date: 11/19/2020
helpviewer_keywords:
- value types [C#]
- reference types [C#]
- types [C#]
- C# language, data types
- common type system [C#]
- data types [C#]
- C# language, types
- strong typing [C#]
ms.assetid: f782d7cc-035e-4500-b1b1-36a9881130ad
ms.openlocfilehash: c347dbc6af46d4c334445d606d7cedfdf17e43f6
ms.sourcegitcommit: 30e9e11dfd90112b8eec6406186ba3533f21eba1
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2020
ms.locfileid: "95098708"
---
# <a name="types-c-programming-guide"></a><span data-ttu-id="e5d27-103">Types (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="e5d27-103">Types (C# Programming Guide)</span></span>

## <a name="types-variables-and-values"></a><span data-ttu-id="e5d27-104">Types, variables et valeurs</span><span class="sxs-lookup"><span data-stu-id="e5d27-104">Types, variables, and values</span></span>

<span data-ttu-id="e5d27-105">C# est un langage fortement typé.</span><span class="sxs-lookup"><span data-stu-id="e5d27-105">C# is a strongly typed language.</span></span> <span data-ttu-id="e5d27-106">Chaque variable et chaque constante ont un type, tout comme chaque expression qui fournit une valeur.</span><span class="sxs-lookup"><span data-stu-id="e5d27-106">Every variable and constant has a type, as does every expression that evaluates to a value.</span></span> <span data-ttu-id="e5d27-107">Chaque déclaration de méthode spécifie un nom, un nombre de paramètres, ainsi que le type et le type (valeur, référence ou sortie) pour chaque paramètre d’entrée et pour la valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="e5d27-107">Every method declaration specifies a name, number of parameters, and type and kind (value, reference, or output) for each input parameter and for the return value.</span></span> <span data-ttu-id="e5d27-108">La bibliothèque de classes .NET définit un ensemble de types numériques intégrés et des types plus complexes qui représentent un large éventail de constructions logiques, telles que le système de fichiers, les connexions réseau, les collections et les tableaux d’objets, ainsi que les dates.</span><span class="sxs-lookup"><span data-stu-id="e5d27-108">The .NET class library defines a set of built-in numeric types and more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.</span></span> <span data-ttu-id="e5d27-109">Un programme C# classique utilise des types de la bibliothèque de classes et des types définis par l’utilisateur qui modélisent les concepts propres au domaine du problème du programme.</span><span class="sxs-lookup"><span data-stu-id="e5d27-109">A typical C# program uses types from the class library and user-defined types that model the concepts that are specific to the program's problem domain.</span></span>

<span data-ttu-id="e5d27-110">Les informations stockées dans un type peuvent inclure les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="e5d27-110">The information stored in a type can include the following items:</span></span>

- <span data-ttu-id="e5d27-111">Espace de stockage nécessaire pour une variable du type.</span><span class="sxs-lookup"><span data-stu-id="e5d27-111">The storage space that a variable of the type requires.</span></span>
- <span data-ttu-id="e5d27-112">Valeurs minimale et maximale que le type peut représenter.</span><span class="sxs-lookup"><span data-stu-id="e5d27-112">The maximum and minimum values that it can represent.</span></span>
- <span data-ttu-id="e5d27-113">Membres (méthodes, champs, événements, etc.) que le type contient.</span><span class="sxs-lookup"><span data-stu-id="e5d27-113">The members (methods, fields, events, and so on) that it contains.</span></span>
- <span data-ttu-id="e5d27-114">Type de base dont le type est hérité.</span><span class="sxs-lookup"><span data-stu-id="e5d27-114">The base type it inherits from.</span></span>
- <span data-ttu-id="e5d27-115">Interface (s) qu’il implémente.</span><span class="sxs-lookup"><span data-stu-id="e5d27-115">The interface(s) it implements.</span></span>
- <span data-ttu-id="e5d27-116">Emplacement où sera allouée la mémoire pour les variables au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="e5d27-116">The location where the memory for variables will be allocated at run time.</span></span>
- <span data-ttu-id="e5d27-117">Sortes d’opérations autorisées.</span><span class="sxs-lookup"><span data-stu-id="e5d27-117">The kinds of operations that are permitted.</span></span>

<span data-ttu-id="e5d27-118">Le compilateur utilise les informations de type pour s’assurer que toutes les opérations effectuées dans votre code sont de *type sécurisé*.</span><span class="sxs-lookup"><span data-stu-id="e5d27-118">The compiler uses type information to make sure all operations that are performed in your code are *type safe*.</span></span> <span data-ttu-id="e5d27-119">Par exemple, si vous déclarez une variable de type [int](../../language-reference/builtin-types/integral-numeric-types.md), le compilateur vous permet d’utiliser la variable dans des opérations d’addition et de soustraction.</span><span class="sxs-lookup"><span data-stu-id="e5d27-119">For example, if you declare a variable of type [int](../../language-reference/builtin-types/integral-numeric-types.md), the compiler allows you to use the variable in addition and subtraction operations.</span></span> <span data-ttu-id="e5d27-120">Si vous essayez d’effectuer ces mêmes opérations avec une variable de type [bool](../../language-reference/builtin-types/bool.md), le compilateur génère une erreur, comme illustré dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="e5d27-120">If you try to perform those same operations on a variable of type [bool](../../language-reference/builtin-types/bool.md), the compiler generates an error, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="TypeSafeExample":::

> [!NOTE]
> <span data-ttu-id="e5d27-121">Développeurs C et C++ : notez que dans C#, [bool](../../language-reference/builtin-types/bool.md) n’est pas convertible en [int](../../language-reference/builtin-types/integral-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-121">C and C++ developers, notice that in C#, [bool](../../language-reference/builtin-types/bool.md) is not convertible to [int](../../language-reference/builtin-types/integral-numeric-types.md).</span></span>

<span data-ttu-id="e5d27-122">Le compilateur incorpore les informations de type dans le fichier exécutable sous forme de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="e5d27-122">The compiler embeds the type information into the executable file as metadata.</span></span> <span data-ttu-id="e5d27-123">Le common language runtime (CLR) utilise ces métadonnées au moment de l’exécution pour garantir que le type est sécurisé lorsqu’il alloue et libère de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="e5d27-123">The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</span></span>

### <a name="specifying-types-in-variable-declarations"></a><span data-ttu-id="e5d27-124">Spécification de types dans les déclarations de variable</span><span class="sxs-lookup"><span data-stu-id="e5d27-124">Specifying types in variable declarations</span></span>

<span data-ttu-id="e5d27-125">Lorsque vous déclarez une variable ou une constante dans un programme, vous devez spécifier son type ou utiliser le mot clé [var](../../language-reference/keywords/var.md) pour permettre au compilateur de déduire le type.</span><span class="sxs-lookup"><span data-stu-id="e5d27-125">When you declare a variable or constant in a program, you must either specify its type or use the [var](../../language-reference/keywords/var.md) keyword to let the compiler infer the type.</span></span> <span data-ttu-id="e5d27-126">L’exemple suivant montre des déclarations de variable qui utilisent des types numériques intégrés et des types complexes définis par l’utilisateur :</span><span class="sxs-lookup"><span data-stu-id="e5d27-126">The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="Declarations":::

<span data-ttu-id="e5d27-127">Les types de paramètres de méthode et de valeurs de retour sont spécifiés dans la déclaration de méthode.</span><span class="sxs-lookup"><span data-stu-id="e5d27-127">The types of method parameters and return values are specified in the method declaration.</span></span> <span data-ttu-id="e5d27-128">La signature suivante présente une méthode qui requiert [int](../../language-reference/builtin-types/integral-numeric-types.md) comme argument d’entrée et retourne une chaîne :</span><span class="sxs-lookup"><span data-stu-id="e5d27-128">The following signature shows a method that requires an [int](../../language-reference/builtin-types/integral-numeric-types.md) as an input argument and returns a string:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="GetName":::

<span data-ttu-id="e5d27-129">Une fois que vous avez déclaré une variable, vous ne pouvez pas la redéclarer avec un nouveau type et vous ne pouvez pas assigner une valeur qui n’est pas compatible avec son type déclaré.</span><span class="sxs-lookup"><span data-stu-id="e5d27-129">After you declare a variable, you can't redeclare it with a new type, and you can't assign a value not compatible with its declared type.</span></span> <span data-ttu-id="e5d27-130">Par exemple, vous ne pouvez pas déclarer un [int](../../language-reference/builtin-types/integral-numeric-types.md) et lui assigner une valeur booléenne `true` .</span><span class="sxs-lookup"><span data-stu-id="e5d27-130">For example, you can't declare an [int](../../language-reference/builtin-types/integral-numeric-types.md) and then assign it a Boolean value of `true`.</span></span> <span data-ttu-id="e5d27-131">Toutefois, les valeurs peuvent être converties en d’autres types, par exemple quand elles sont assignées à de nouvelles variables ou passées en tant qu’arguments de méthode.</span><span class="sxs-lookup"><span data-stu-id="e5d27-131">However, values can be converted to other types, for example when they're assigned to new variables or passed as method arguments.</span></span> <span data-ttu-id="e5d27-132">Une *conversion de type* qui n’entraîne pas de perte de données est effectuée automatiquement par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="e5d27-132">A *type conversion* that doesn't cause data loss is performed automatically by the compiler.</span></span> <span data-ttu-id="e5d27-133">Une conversion susceptible de causer la perte de données exige une variable *cast* dans le code source.</span><span class="sxs-lookup"><span data-stu-id="e5d27-133">A conversion that might cause data loss requires a *cast* in the source code.</span></span>

<span data-ttu-id="e5d27-134">Pour plus d’informations, consultez [Cast et conversions de types](./casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-134">For more information, see [Casting and Type Conversions](./casting-and-type-conversions.md).</span></span>

## <a name="built-in-types"></a><span data-ttu-id="e5d27-135">Types intégrés</span><span class="sxs-lookup"><span data-stu-id="e5d27-135">Built-in types</span></span>

<span data-ttu-id="e5d27-136">C# fournit un jeu standard de types intégrés pour représenter les entiers, les valeurs à virgule flottante, les expressions booléennes, les caractères de texte, les valeurs décimales et d’autres types de données.</span><span class="sxs-lookup"><span data-stu-id="e5d27-136">C# provides a standard set of built-in types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.</span></span> <span data-ttu-id="e5d27-137">Il existe également des types `string` et `object` intégrés.</span><span class="sxs-lookup"><span data-stu-id="e5d27-137">There are also built-in `string` and `object` types.</span></span> <span data-ttu-id="e5d27-138">Ces types peuvent être utilisés dans n’importe quel programme C#.</span><span class="sxs-lookup"><span data-stu-id="e5d27-138">These types are available for you to use in any C# program.</span></span> <span data-ttu-id="e5d27-139">Pour obtenir la liste complète des types intégrés, consultez [types intégrés](../../language-reference/builtin-types/built-in-types.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-139">For the complete list of the built-in types, see [Built-in types](../../language-reference/builtin-types/built-in-types.md).</span></span>

## <a name="custom-types"></a><span data-ttu-id="e5d27-140">Types personnalisés</span><span class="sxs-lookup"><span data-stu-id="e5d27-140">Custom types</span></span>

<span data-ttu-id="e5d27-141">Vous utilisez les constructions [struct](../../language-reference/builtin-types/struct.md), [classe](../../language-reference/keywords/class.md), [interface](../../language-reference/keywords/interface.md) et [enum](../../language-reference/builtin-types/enum.md) pour créer vos propres types personnalisés.</span><span class="sxs-lookup"><span data-stu-id="e5d27-141">You use the [struct](../../language-reference/builtin-types/struct.md), [class](../../language-reference/keywords/class.md), [interface](../../language-reference/keywords/interface.md), and [enum](../../language-reference/builtin-types/enum.md) constructs to create your own custom types.</span></span> <span data-ttu-id="e5d27-142">La bibliothèque de classes .NET est une collection de types personnalisés fournie par Microsoft que vous pouvez utiliser dans vos propres applications.</span><span class="sxs-lookup"><span data-stu-id="e5d27-142">The .NET class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.</span></span> <span data-ttu-id="e5d27-143">Par défaut, les types les plus fréquemment utilisés dans la bibliothèque de classes sont disponibles dans tous les programmes C#.</span><span class="sxs-lookup"><span data-stu-id="e5d27-143">By default, the most frequently used types in the class library are available in any C# program.</span></span> <span data-ttu-id="e5d27-144">D’autres deviennent disponibles uniquement lorsque vous ajoutez explicitement une référence de projet à l’assembly dans lequel elles sont définies.</span><span class="sxs-lookup"><span data-stu-id="e5d27-144">Others become available only when you explicitly add a project reference to the assembly in which they're defined.</span></span> <span data-ttu-id="e5d27-145">Une fois que le compilateur a une référence à l’assembly, vous pouvez déclarer des variables (et des constantes) des types déclarés dans cet assembly dans le code source.</span><span class="sxs-lookup"><span data-stu-id="e5d27-145">After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.</span></span> <span data-ttu-id="e5d27-146">Pour plus d’informations, consultez [Bibliothèque de classes .NET](../../../standard/class-library-overview.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-146">For more information, see [.NET Class Library](../../../standard/class-library-overview.md).</span></span>

## <a name="the-common-type-system"></a><span data-ttu-id="e5d27-147">Système de type commun</span><span class="sxs-lookup"><span data-stu-id="e5d27-147">The common type system</span></span>

<span data-ttu-id="e5d27-148">Il est important de comprendre deux points fondamentaux concernant le système de type dans .NET :</span><span class="sxs-lookup"><span data-stu-id="e5d27-148">It's important to understand two fundamental points about the type system in .NET:</span></span>

- <span data-ttu-id="e5d27-149">Il prend en charge le principe d’héritage.</span><span class="sxs-lookup"><span data-stu-id="e5d27-149">It supports the principle of inheritance.</span></span> <span data-ttu-id="e5d27-150">Les types peuvent dériver d’autres types, appelés *types de base*.</span><span class="sxs-lookup"><span data-stu-id="e5d27-150">Types can derive from other types, called *base types*.</span></span> <span data-ttu-id="e5d27-151">Le type dérivé hérite (avec certaines restrictions) des méthodes, des propriétés et des autres membres du type de base.</span><span class="sxs-lookup"><span data-stu-id="e5d27-151">The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.</span></span> <span data-ttu-id="e5d27-152">Le type de base peut à son tour dériver d’un autre type, auquel cas le type dérivé hérite des membres des deux types de base dans sa hiérarchie d’héritage.</span><span class="sxs-lookup"><span data-stu-id="e5d27-152">The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.</span></span> <span data-ttu-id="e5d27-153">Tous les types, notamment les types numériques intégrés comme <xref:System.Int32?displayProperty=nameWithType> (mot clé C# : [int](../../language-reference/builtin-types/integral-numeric-types.md)), dérivent au final d’un seul type de base, qui est <xref:System.Object?displayProperty=nameWithType> (mot clé C# : [object](../../language-reference/builtin-types/reference-types.md)).</span><span class="sxs-lookup"><span data-stu-id="e5d27-153">All types, including built-in numeric types such as <xref:System.Int32?displayProperty=nameWithType> (C# keyword: [int](../../language-reference/builtin-types/integral-numeric-types.md)), derive ultimately from a single base type, which is <xref:System.Object?displayProperty=nameWithType> (C# keyword: [object](../../language-reference/builtin-types/reference-types.md)).</span></span> <span data-ttu-id="e5d27-154">Cette hiérarchie de types unifiée est appelée [Système de type commun](../../../standard/base-types/common-type-system.md) (CTS).</span><span class="sxs-lookup"><span data-stu-id="e5d27-154">This unified type hierarchy is called the [Common Type System](../../../standard/base-types/common-type-system.md) (CTS).</span></span> <span data-ttu-id="e5d27-155">Pour plus d’informations sur l’héritage dans C#, consultez [Héritage](../classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-155">For more information about inheritance in C#, see [Inheritance](../classes-and-structs/inheritance.md).</span></span>
- <span data-ttu-id="e5d27-156">Chaque type du CTS est défini comme *type valeur* ou *type référence*.</span><span class="sxs-lookup"><span data-stu-id="e5d27-156">Each type in the CTS is defined as either a *value type* or a *reference type*.</span></span> <span data-ttu-id="e5d27-157">Ces types incluent tous les types personnalisés dans la bibliothèque de classes .NET et également vos propres types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e5d27-157">These types include all custom types in the .NET class library and also your own user-defined types.</span></span> <span data-ttu-id="e5d27-158">Les types que vous définissez à l’aide du mot clé [struct](../../language-reference/builtin-types/struct.md) sont des types valeur ; tous les types numériques intégrés sont `structs`.</span><span class="sxs-lookup"><span data-stu-id="e5d27-158">Types that you define by using the [struct](../../language-reference/builtin-types/struct.md) keyword are value types; all the built-in numeric types are `structs`.</span></span> <span data-ttu-id="e5d27-159">Les types que vous définissez à l’aide du mot clé [class](../../language-reference/keywords/class.md) sont des types référence.</span><span class="sxs-lookup"><span data-stu-id="e5d27-159">Types that you define by using the [class](../../language-reference/keywords/class.md) keyword are reference types.</span></span> <span data-ttu-id="e5d27-160">Les types référence et les types valeur ne suivent pas les mêmes règles de compilation et ont un comportement différent au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="e5d27-160">Reference types and value types have different compile-time rules, and different run-time behavior.</span></span>

<span data-ttu-id="e5d27-161">L’illustration suivante montre la relation entre les types valeur et les types référence dans le CTS.</span><span class="sxs-lookup"><span data-stu-id="e5d27-161">The following illustration shows the relationship between value types and reference types in the CTS.</span></span>

<span data-ttu-id="e5d27-162">L’image suivante montre les types valeur et les types référence dans CTS :</span><span class="sxs-lookup"><span data-stu-id="e5d27-162">The following image shows value types and reference types in the CTS:</span></span>

![Capture d’écran montrant des types valeur et des types référence dans CTS.](./media/index/value-reference-types-common-type-system.png)

> [!NOTE]
> <span data-ttu-id="e5d27-164">Vous pouvez voir que les types couramment utilisés sont tous organisés dans l’espace de noms <xref:System>.</span><span class="sxs-lookup"><span data-stu-id="e5d27-164">You can see that the most commonly used types are all organized in the <xref:System> namespace.</span></span> <span data-ttu-id="e5d27-165">Toutefois, l’espace de noms qui contient un type n’a aucune incidence sur le fait qu’il s’agisse d’un type valeur ou d’un type référence.</span><span class="sxs-lookup"><span data-stu-id="e5d27-165">However, the namespace in which a type is contained has no relation to whether it is a value type or reference type.</span></span>

### <a name="value-types"></a><span data-ttu-id="e5d27-166">Types de valeur</span><span class="sxs-lookup"><span data-stu-id="e5d27-166">Value types</span></span>

<span data-ttu-id="e5d27-167">Les types valeur dérivent de <xref:System.ValueType?displayProperty=nameWithType>, qui dérive de <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e5d27-167">Value types derive from <xref:System.ValueType?displayProperty=nameWithType>, which derives from <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e5d27-168">Les types qui dérivent de <xref:System.ValueType?displayProperty=nameWithType> ont un comportement spécial dans le CLR.</span><span class="sxs-lookup"><span data-stu-id="e5d27-168">Types that derive from <xref:System.ValueType?displayProperty=nameWithType> have special behavior in the CLR.</span></span> <span data-ttu-id="e5d27-169">Les variables de type valeur contiennent directement leurs valeurs, ce qui signifie que la mémoire est allouée inline dans le contexte où la variable est déclarée.</span><span class="sxs-lookup"><span data-stu-id="e5d27-169">Value type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared.</span></span> <span data-ttu-id="e5d27-170">Il n’existe pas d’allocation de tas ou de charge de garbage collection distincte pour les variables de type valeur.</span><span class="sxs-lookup"><span data-stu-id="e5d27-170">There's no separate heap allocation or garbage collection overhead for value-type variables.</span></span>

<span data-ttu-id="e5d27-171">Il existe deux catégories de types valeur : [struct](../../language-reference/builtin-types/struct.md) et [enum](../../language-reference/builtin-types/enum.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-171">There are two categories of value types: [struct](../../language-reference/builtin-types/struct.md) and [enum](../../language-reference/builtin-types/enum.md).</span></span>

<span data-ttu-id="e5d27-172">Les types numériques intégrés sont des structs et ont des champs et des méthodes auxquels vous pouvez accéder :</span><span class="sxs-lookup"><span data-stu-id="e5d27-172">The built-in numeric types are structs, and they have fields and methods that you can access:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="ConstantByte":::

<span data-ttu-id="e5d27-173">Mais vous les déclarez et leur assignez des valeurs comme s’il s’agissait de types non agrégés simples :</span><span class="sxs-lookup"><span data-stu-id="e5d27-173">But you declare and assign values to them as if they're simple non-aggregate types:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="NonAggregateTypes":::

<span data-ttu-id="e5d27-174">Les types valeur sont *sealed*, ce qui signifie que vous ne pouvez pas dériver un type de n’importe quel type valeur, par exemple <xref:System.Int32?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="e5d27-174">Value types are *sealed*, which means that you can't derive a type from any value type, for example <xref:System.Int32?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e5d27-175">Vous ne pouvez pas définir un struct pour hériter d’une classe ou d’un struct défini par l’utilisateur, car un struct peut uniquement hériter de <xref:System.ValueType?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="e5d27-175">You can't define a struct to inherit from any user-defined class or struct because a struct can only inherit from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e5d27-176">Toutefois, un struct peut implémenter une ou plusieurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="e5d27-176">However, a struct can implement one or more interfaces.</span></span> <span data-ttu-id="e5d27-177">Vous pouvez effectuer un cast d’un type struct en n’importe quel type d’interface qu’il implémente ; ce Cast entraîne une opération de *boxing* pour encapsuler le struct à l’intérieur d’un objet de type référence sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="e5d27-177">You can cast a struct type to any interface type that it implements; this cast causes a *boxing* operation to wrap the struct inside a reference type object on the managed heap.</span></span> <span data-ttu-id="e5d27-178">Les opérations de boxing se produisent quand vous passez un type valeur à une méthode qui prend un <xref:System.Object?displayProperty=nameWithType> ou tout type d’interface comme paramètre d’entrée.</span><span class="sxs-lookup"><span data-stu-id="e5d27-178">Boxing operations occur when you pass a value type to a method that takes a <xref:System.Object?displayProperty=nameWithType> or any interface type as an input parameter.</span></span> <span data-ttu-id="e5d27-179">Pour plus d’informations, consultez [Conversion boxing et unboxing](./boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-179">For more information, see [Boxing and Unboxing](./boxing-and-unboxing.md).</span></span>

<span data-ttu-id="e5d27-180">Vous utilisez le mot clé [struct](../../language-reference/builtin-types/struct.md) pour créer vos propres types valeur personnalisés.</span><span class="sxs-lookup"><span data-stu-id="e5d27-180">You use the [struct](../../language-reference/builtin-types/struct.md) keyword to create your own custom value types.</span></span> <span data-ttu-id="e5d27-181">En règle générale, un struct est utilisé comme conteneur pour un petit jeu de variables connexes, comme le montre l'exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="e5d27-181">Typically, a struct is used as a container for a small set of related variables, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="Coords":::

<span data-ttu-id="e5d27-182">Pour plus d’informations sur les structs, consultez [types structure](../../language-reference/builtin-types/struct.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-182">For more information about structs, see [Structure types](../../language-reference/builtin-types/struct.md).</span></span> <span data-ttu-id="e5d27-183">Pour plus d’informations sur les types valeur, consultez [types valeur](../../language-reference/builtin-types/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-183">For more information about value types, see [Value types](../../language-reference/builtin-types/value-types.md).</span></span>

<span data-ttu-id="e5d27-184">L’autre catégorie de types valeur est [enum](../../language-reference/builtin-types/enum.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-184">The other category of value types is [enum](../../language-reference/builtin-types/enum.md).</span></span> <span data-ttu-id="e5d27-185">Un enum définit un jeu de constantes intégrales nommées.</span><span class="sxs-lookup"><span data-stu-id="e5d27-185">An enum defines a set of named integral constants.</span></span> <span data-ttu-id="e5d27-186">Par exemple l’énumération <xref:System.IO.FileMode?displayProperty=nameWithType> dans la bibliothèque de classes du .NET contient un ensemble d’entiers constants nommés qui spécifient comment un fichier doit être ouvert.</span><span class="sxs-lookup"><span data-stu-id="e5d27-186">For example, the <xref:System.IO.FileMode?displayProperty=nameWithType> enumeration in the .NET class library contains a set of named constant integers that specify how a file should be opened.</span></span> <span data-ttu-id="e5d27-187">Il est défini comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="e5d27-187">It's defined as shown in the following example:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="EnumFileMode":::

<span data-ttu-id="e5d27-188">La constante `System.IO.FileMode.Create` a la valeur 2.</span><span class="sxs-lookup"><span data-stu-id="e5d27-188">The `System.IO.FileMode.Create` constant has a value of 2.</span></span> <span data-ttu-id="e5d27-189">Toutefois, le nom est bien plus explicite pour les êtres humains qui lisent le code source. pour cette raison, il est préférable d’utiliser des énumérations au lieu de nombres littéraux constants.</span><span class="sxs-lookup"><span data-stu-id="e5d27-189">However, the name is much more meaningful for humans reading the source code, and for that reason it's better to use enumerations instead of constant literal numbers.</span></span> <span data-ttu-id="e5d27-190">Pour plus d’informations, consultez <xref:System.IO.FileMode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e5d27-190">For more information, see <xref:System.IO.FileMode?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="e5d27-191">Toutes les énumérations héritent de <xref:System.Enum?displayProperty=nameWithType>, qui hérite de <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e5d27-191">All enums inherit from <xref:System.Enum?displayProperty=nameWithType>, which inherits from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e5d27-192">Toutes les règles qui s’appliquent aux structs s’appliquent également aux enums.</span><span class="sxs-lookup"><span data-stu-id="e5d27-192">All the rules that apply to structs also apply to enums.</span></span> <span data-ttu-id="e5d27-193">Pour plus d’informations sur les enums, consultez [types énumération](../../language-reference/builtin-types/enum.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-193">For more information about enums, see [Enumeration types](../../language-reference/builtin-types/enum.md).</span></span>

### <a name="reference-types"></a><span data-ttu-id="e5d27-194">Types référence</span><span class="sxs-lookup"><span data-stu-id="e5d27-194">Reference types</span></span>

<span data-ttu-id="e5d27-195">Un type qui est défini comme une [classe](../../language-reference/keywords/class.md), un [délégué](../../language-reference/builtin-types/reference-types.md), un tableau ou une [interface](../../language-reference/keywords/interface.md) est un *type référence*.</span><span class="sxs-lookup"><span data-stu-id="e5d27-195">A type that is defined as a [class](../../language-reference/keywords/class.md), [delegate](../../language-reference/builtin-types/reference-types.md), array, or [interface](../../language-reference/keywords/interface.md) is a *reference type*.</span></span> <span data-ttu-id="e5d27-196">Au moment de l’exécution, quand vous déclarez une variable de type référence, celle-ci contient la valeur [null](../../language-reference/keywords/null.md) tant que vous n’avez pas explicitement créé un objet à l’aide de l’opérateur [new](../../language-reference/operators/new-operator.md) ou que vous ne lui avez pas assigné un objet créé ailleurs à l’aide de `new`, comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="e5d27-196">At run time, when you declare a variable of a reference type, the variable contains the value [null](../../language-reference/keywords/null.md) until you explicitly create an object by using the [new](../../language-reference/operators/new-operator.md) operator, or assign it an object that has been created elsewhere by using `new`, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="DeclarationAndAssignment":::

<span data-ttu-id="e5d27-197">Une interface doit être initialisée avec un objet de classe qui l’implémente.</span><span class="sxs-lookup"><span data-stu-id="e5d27-197">An interface must be initialized together with a class object that implements it.</span></span> <span data-ttu-id="e5d27-198">Si `MyClass` implémente `IMyInterface`, vous créez une instance de `IMyInterface` comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="e5d27-198">If `MyClass` implements `IMyInterface`, you create an instance of `IMyInterface` as shown in the following example:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="InterfaceDeclaration":::

<span data-ttu-id="e5d27-199">Quand l’objet est créé, la mémoire est allouée sur le tas managé et la variable contient uniquement une référence à l’emplacement de l’objet.</span><span class="sxs-lookup"><span data-stu-id="e5d27-199">When the object is created, the memory is allocated on the managed heap, and the variable holds only a reference to the location of the object.</span></span> <span data-ttu-id="e5d27-200">Les types sur le tas managé nécessitent une surcharge lorsqu’ils sont alloués et lorsqu’ils sont récupérés par la fonctionnalité de gestion automatique de la mémoire du CLR, appelée *garbage collection*.</span><span class="sxs-lookup"><span data-stu-id="e5d27-200">Types on the managed heap require overhead both when they're allocated and when they're reclaimed by the automatic memory management functionality of the CLR, which is known as *garbage collection*.</span></span> <span data-ttu-id="e5d27-201">Toutefois, garbage collection est également hautement optimisé et, dans la plupart des scénarios, il ne crée pas de problème de performances.</span><span class="sxs-lookup"><span data-stu-id="e5d27-201">However, garbage collection is also highly optimized, and in most scenarios it doesn't create a performance issue.</span></span> <span data-ttu-id="e5d27-202">Pour plus d’informations sur le garbage collection, consultez [Gestion automatique de la mémoire](../../../standard/automatic-memory-management.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-202">For more information about garbage collection, see [Automatic Memory Management](../../../standard/automatic-memory-management.md).</span></span>

<span data-ttu-id="e5d27-203">Tous les tableaux sont des types référence, même si leurs éléments sont des types valeur.</span><span class="sxs-lookup"><span data-stu-id="e5d27-203">All arrays are reference types, even if their elements are value types.</span></span> <span data-ttu-id="e5d27-204">Les tableaux dérivent implicitement de la classe <xref:System.Array?displayProperty=nameWithType>, mais vous les déclarez et vous les utilisez avec la syntaxe simplifiée fournie par C#, comme illustré dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="e5d27-204">Arrays implicitly derive from the <xref:System.Array?displayProperty=nameWithType> class, but you declare and use them with the simplified syntax that is provided by C#, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="ArrayDeclaration":::

<span data-ttu-id="e5d27-205">Les types référence prennent en charge l’héritage.</span><span class="sxs-lookup"><span data-stu-id="e5d27-205">Reference types fully support inheritance.</span></span> <span data-ttu-id="e5d27-206">Lorsque vous créez une classe, vous pouvez hériter de toute autre interface ou classe qui n’est pas définie comme [sealed](../../language-reference/keywords/sealed.md), et d’autres classes peuvent hériter de votre classe et substituer vos méthodes virtuelles.</span><span class="sxs-lookup"><span data-stu-id="e5d27-206">When you create a class, you can inherit from any other interface or class that isn't defined as [sealed](../../language-reference/keywords/sealed.md), and other classes can inherit from your class and override your virtual methods.</span></span> <span data-ttu-id="e5d27-207">Pour plus d’informations sur la création de vos propres classes, consultez [Classes et structures](../classes-and-structs/index.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-207">For more information about how to create your own classes, see [Classes and Structs](../classes-and-structs/index.md).</span></span> <span data-ttu-id="e5d27-208">Pour plus d’informations sur l’héritage et les méthodes virtuelles, consultez [Héritage](../classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-208">For more information about inheritance and virtual methods, see [Inheritance](../classes-and-structs/inheritance.md).</span></span>

## <a name="types-of-literal-values"></a><span data-ttu-id="e5d27-209">Types de valeurs littérales</span><span class="sxs-lookup"><span data-stu-id="e5d27-209">Types of literal values</span></span>

<span data-ttu-id="e5d27-210">Dans C#, les valeurs littérales reçoivent un type du compilateur.</span><span class="sxs-lookup"><span data-stu-id="e5d27-210">In C#, literal values receive a type from the compiler.</span></span> <span data-ttu-id="e5d27-211">Vous pouvez spécifier la façon dont un littéral numérique doit être typé en ajoutant une lettre à la fin du nombre.</span><span class="sxs-lookup"><span data-stu-id="e5d27-211">You can specify how a numeric literal should be typed by appending a letter to the end of the number.</span></span> <span data-ttu-id="e5d27-212">Par exemple, pour spécifier que la valeur 4,56 doit être traitée comme une valeur float, ajoutez « f » ou « F » après le nombre : `4.56f`.</span><span class="sxs-lookup"><span data-stu-id="e5d27-212">For example, to specify that the value 4.56 should be treated as a float, append an "f" or "F" after the number: `4.56f`.</span></span> <span data-ttu-id="e5d27-213">Si aucune lettre n’est ajoutée, le compilateur déduit un type pour le littéral.</span><span class="sxs-lookup"><span data-stu-id="e5d27-213">If no letter is appended, the compiler will infer a type for the literal.</span></span> <span data-ttu-id="e5d27-214">Pour plus d’informations sur les types qui peuvent être spécifiés avec des suffixes de lettres, consultez [types numériques intégraux](../../language-reference/builtin-types/integral-numeric-types.md) et [types numériques à virgule flottante](../../language-reference/builtin-types/floating-point-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-214">For more information about which types can be specified with letter suffixes, see [Integral numeric types](../../language-reference/builtin-types/integral-numeric-types.md) and [Floating-point numeric types](../../language-reference/builtin-types/floating-point-numeric-types.md).</span></span>

<span data-ttu-id="e5d27-215">Étant donné que les littéraux sont typés et que tous les types dérivent en fin de compte <xref:System.Object?displayProperty=nameWithType> , vous pouvez écrire et compiler du code tel que le code suivant :</span><span class="sxs-lookup"><span data-stu-id="e5d27-215">Because literals are typed, and all types derive ultimately from <xref:System.Object?displayProperty=nameWithType>, you can write and compile code such as the following code:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="ConvertTypes":::

## <a name="generic-types"></a><span data-ttu-id="e5d27-216">Types génériques</span><span class="sxs-lookup"><span data-stu-id="e5d27-216">Generic types</span></span>

<span data-ttu-id="e5d27-217">Un type peut être déclaré avec un ou plusieurs *paramètres de type* qui servent d’espace réservé pour le type réel (le *type concret*) que le code client fournit lorsqu’il crée une instance du type.</span><span class="sxs-lookup"><span data-stu-id="e5d27-217">A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type.</span></span> <span data-ttu-id="e5d27-218">Ces types sont appelés *types génériques*.</span><span class="sxs-lookup"><span data-stu-id="e5d27-218">Such types are called *generic types*.</span></span> <span data-ttu-id="e5d27-219">Par exemple, le type .NET <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> a un paramètre de type qui, par Convention, porte le nom *T*. Lorsque vous créez une instance du type, vous spécifiez le type des objets que la liste doit contenir, par exemple String :</span><span class="sxs-lookup"><span data-stu-id="e5d27-219">For example, the .NET type <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="GenericType":::

<span data-ttu-id="e5d27-220">L’utilisation du paramètre de type rend possible la réutilisation de la même classe pour contenir tout type d’élément, sans avoir à convertir chaque élément en [object](../../language-reference/builtin-types/reference-types.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-220">The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="e5d27-221">Les classes de collection génériques sont appelées *collections fortement typées* , car le compilateur connaît le type spécifique des éléments de la collection et peut déclencher une erreur au moment de la compilation si, par exemple, vous tentez d’ajouter un entier à l' `stringList` objet dans l’exemple précédent.</span><span class="sxs-lookup"><span data-stu-id="e5d27-221">Generic collection classes are called *strongly typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile time if, for example, you try to add an integer to the `stringList` object in the previous example.</span></span> <span data-ttu-id="e5d27-222">Pour plus d’informations, consultez [Génériques](../generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-222">For more information, see [Generics](../generics/index.md).</span></span>

## <a name="implicit-types-anonymous-types-and-nullable-value-types"></a><span data-ttu-id="e5d27-223">Types implicites, types anonymes et types valeur Nullable</span><span class="sxs-lookup"><span data-stu-id="e5d27-223">Implicit types, anonymous types, and nullable value types</span></span>

<span data-ttu-id="e5d27-224">Comme indiqué précédemment, vous pouvez attribuer implicitement un type à une variable locale (mais pas les membres de la classe) à l’aide du mot clé [var](../../language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-224">As stated previously, you can implicitly type a local variable (but not class members) by using the [var](../../language-reference/keywords/var.md) keyword.</span></span> <span data-ttu-id="e5d27-225">La variable reçoit toujours un type au moment de la compilation, mais le type est fourni par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="e5d27-225">The variable still receives a type at compile time, but the type is provided by the compiler.</span></span> <span data-ttu-id="e5d27-226">Pour plus d’informations, consultez [Variables locales implicitement typées](../classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-226">For more information, see [Implicitly Typed Local Variables](../classes-and-structs/implicitly-typed-local-variables.md).</span></span>

<span data-ttu-id="e5d27-227">Il peut être difficile de créer un type nommé pour des ensembles simples de valeurs associées que vous ne souhaitez pas stocker ou passer en dehors des limites de la méthode.</span><span class="sxs-lookup"><span data-stu-id="e5d27-227">It can be inconvenient to create a named type for simple sets of related values that you don't intend to store or pass outside method boundaries.</span></span> <span data-ttu-id="e5d27-228">Vous pouvez alors créer des *types anonymes*.</span><span class="sxs-lookup"><span data-stu-id="e5d27-228">You can create *anonymous types* for this purpose.</span></span> <span data-ttu-id="e5d27-229">Pour plus d’informations, consultez [types anonymes](../classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-229">For more information, see [Anonymous Types](../classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="e5d27-230">Les types valeur ordinaires ne peuvent pas avoir une valeur [null](../../language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-230">Ordinary value types can't have a value of [null](../../language-reference/keywords/null.md).</span></span> <span data-ttu-id="e5d27-231">Toutefois, vous pouvez créer des types valeur Nullable en ajoutant un `?` après le type.</span><span class="sxs-lookup"><span data-stu-id="e5d27-231">However, you can create nullable value types by appending a `?` after the type.</span></span> <span data-ttu-id="e5d27-232">Par exemple, `int?` est un type `int` qui peut également avoir la valeur [null](../../language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-232">For example, `int?` is an `int` type that can also have the value [null](../../language-reference/keywords/null.md).</span></span> <span data-ttu-id="e5d27-233">Les types valeur Nullable sont des instances du type struct générique <xref:System.Nullable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="e5d27-233">Nullable value types are instances of the generic struct type <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e5d27-234">Les types valeur Nullable sont particulièrement utiles lorsque vous passez des données vers et à partir de bases de données dans lesquelles les valeurs numériques peuvent être null.</span><span class="sxs-lookup"><span data-stu-id="e5d27-234">Nullable value types are especially useful when you're passing data to and from databases in which numeric values might be null.</span></span> <span data-ttu-id="e5d27-235">Pour plus d’informations, consultez [types valeur Nullable](../../language-reference/builtin-types/nullable-value-types.md).</span><span class="sxs-lookup"><span data-stu-id="e5d27-235">For more information, see [Nullable value types](../../language-reference/builtin-types/nullable-value-types.md).</span></span>

## <a name="compile-time-type-and-runtime-type"></a><span data-ttu-id="e5d27-236">Type au moment de la compilation et type d’exécution</span><span class="sxs-lookup"><span data-stu-id="e5d27-236">Compile-time type and runtime type</span></span>

<span data-ttu-id="e5d27-237">Une variable peut avoir différents types au moment de la compilation et au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="e5d27-237">A variable can have different compile-time and run-time types.</span></span> <span data-ttu-id="e5d27-238">Le *type au moment* de la compilation est le type déclaré ou déduit de la variable dans le code source.</span><span class="sxs-lookup"><span data-stu-id="e5d27-238">The *compile-time type* is the declared or inferred type of the variable in the source code.</span></span> <span data-ttu-id="e5d27-239">Le *type au moment* de l’exécution est le type de l’instance référencée par cette variable.</span><span class="sxs-lookup"><span data-stu-id="e5d27-239">The *run-time type* is the type of the instance referred to by that variable.</span></span> <span data-ttu-id="e5d27-240">Ces deux types sont souvent les mêmes, comme dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="e5d27-240">Often those two types are the same, as in the following example:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="CompileTimeType":::

<span data-ttu-id="e5d27-241">Dans d’autres cas, le type au moment de la compilation est différent, comme indiqué dans les deux exemples suivants :</span><span class="sxs-lookup"><span data-stu-id="e5d27-241">In other cases, the compile-time type is different, as shown in the following two examples:</span></span>

:::code language="csharp" source="snippets/index/Program.cs" id="RuntimeTypes":::

<span data-ttu-id="e5d27-242">Dans les deux exemples précédents, le type au moment de l’exécution est un `string` .</span><span class="sxs-lookup"><span data-stu-id="e5d27-242">In both of the preceding examples, the run-time type is a `string`.</span></span> <span data-ttu-id="e5d27-243">Le type au moment de la compilation est `object` sur la première ligne et `IEnumerable<char>` dans la seconde.</span><span class="sxs-lookup"><span data-stu-id="e5d27-243">The compile-time type is `object` in the first line, and `IEnumerable<char>` in the second.</span></span>

<span data-ttu-id="e5d27-244">Si les deux types sont différents pour une variable, il est important de comprendre quand le type au moment de la compilation et le type au moment de l’exécution s’appliquent.</span><span class="sxs-lookup"><span data-stu-id="e5d27-244">If the two types are different for a variable, it's important to understand when the compile-time type and the run-time type apply.</span></span> <span data-ttu-id="e5d27-245">Le type au moment de la compilation détermine toutes les actions effectuées par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="e5d27-245">The compile-time type determines all the actions taken by the compiler.</span></span> <span data-ttu-id="e5d27-246">Ces actions du compilateur incluent la résolution de l’appel de méthode, la résolution de surcharge et les casts implicites et explicites disponibles.</span><span class="sxs-lookup"><span data-stu-id="e5d27-246">These compiler actions include method call resolution, overload resolution, and available implicit and explicit casts.</span></span> <span data-ttu-id="e5d27-247">Le type au moment de l’exécution détermine toutes les actions qui sont résolues au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="e5d27-247">The run-time type determines all actions that are resolved at run time.</span></span> <span data-ttu-id="e5d27-248">Ces actions au moment de l’exécution incluent la répartition des appels de méthode virtuelle, l’évaluation `is` et les `switch` expressions, ainsi que d’autres API de test de type.</span><span class="sxs-lookup"><span data-stu-id="e5d27-248">These run-time actions include dispatching virtual method calls, evaluating `is` and `switch` expressions, and other type testing APIs.</span></span> <span data-ttu-id="e5d27-249">Pour mieux comprendre comment votre code interagit avec les types, identifiez l’action qui s’applique à ce type.</span><span class="sxs-lookup"><span data-stu-id="e5d27-249">To better understand how your code interacts with types, recognize which action applies to which type.</span></span>

## <a name="related-sections"></a><span data-ttu-id="e5d27-250">Sections connexes</span><span class="sxs-lookup"><span data-stu-id="e5d27-250">Related sections</span></span>

<span data-ttu-id="e5d27-251">Pour plus d’informations, consultez les articles suivants :</span><span class="sxs-lookup"><span data-stu-id="e5d27-251">For more information, see the following articles:</span></span>

- [<span data-ttu-id="e5d27-252">Cast et conversions de types</span><span class="sxs-lookup"><span data-stu-id="e5d27-252">Casting and Type Conversions</span></span>](./casting-and-type-conversions.md)
- [<span data-ttu-id="e5d27-253">Conversion boxing et unboxing</span><span class="sxs-lookup"><span data-stu-id="e5d27-253">Boxing and Unboxing</span></span>](./boxing-and-unboxing.md)
- [<span data-ttu-id="e5d27-254">Utilisation du type dynamic</span><span class="sxs-lookup"><span data-stu-id="e5d27-254">Using Type dynamic</span></span>](./using-type-dynamic.md)
- [<span data-ttu-id="e5d27-255">Types valeur</span><span class="sxs-lookup"><span data-stu-id="e5d27-255">Value Types</span></span>](../../language-reference/builtin-types/value-types.md)
- [<span data-ttu-id="e5d27-256">Types référence</span><span class="sxs-lookup"><span data-stu-id="e5d27-256">Reference Types</span></span>](../../language-reference/keywords/reference-types.md)
- [<span data-ttu-id="e5d27-257">Classes et structs</span><span class="sxs-lookup"><span data-stu-id="e5d27-257">Classes and Structs</span></span>](../classes-and-structs/index.md)
- [<span data-ttu-id="e5d27-258">Types anonymes</span><span class="sxs-lookup"><span data-stu-id="e5d27-258">Anonymous Types</span></span>](../classes-and-structs/anonymous-types.md)
- [<span data-ttu-id="e5d27-259">Génériques</span><span class="sxs-lookup"><span data-stu-id="e5d27-259">Generics</span></span>](../generics/index.md)

## <a name="c-language-specification"></a><span data-ttu-id="e5d27-260">spécification du langage C#</span><span class="sxs-lookup"><span data-stu-id="e5d27-260">C# language specification</span></span>

[!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="e5d27-261">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="e5d27-261">See also</span></span>

- [<span data-ttu-id="e5d27-262">Référence C#</span><span class="sxs-lookup"><span data-stu-id="e5d27-262">C# Reference</span></span>](../../language-reference/index.md)
- [<span data-ttu-id="e5d27-263">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="e5d27-263">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="e5d27-264">Conversion des types de données XML</span><span class="sxs-lookup"><span data-stu-id="e5d27-264">Conversion of XML Data Types</span></span>](../../../standard/data/xml/conversion-of-xml-data-types.md)
- [<span data-ttu-id="e5d27-265">Types intégraux</span><span class="sxs-lookup"><span data-stu-id="e5d27-265">Integral types</span></span>](../../language-reference/builtin-types/integral-numeric-types.md)
