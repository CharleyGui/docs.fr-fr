---
title: Cast et conversions de types - Guide de programmation C#
description: En savoir plus sur le cast et les conversions de types, telles que les conversions implicites, explicites et définies par l’utilisateur.
ms.date: 07/06/2020
helpviewer_keywords:
- type conversion [C#]
- data type conversion [C#]
- numeric conversions [C#]
- conversions [C#], type
- casting [C#]
- converting types [C#]
ms.assetid: 568df58a-d292-4b55-93ba-601578722878
ms.openlocfilehash: 040b5679b1e6666a7f0308e5990781a2ef86c530
ms.sourcegitcommit: 552b4b60c094559db9d8178fa74f5bafaece0caf
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/29/2020
ms.locfileid: "87381955"
---
# <a name="casting-and-type-conversions-c-programming-guide"></a><span data-ttu-id="6d147-103">Cast et conversions de types (guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="6d147-103">Casting and type conversions (C# Programming Guide)</span></span>

<span data-ttu-id="6d147-104">C# étant typé statiquement au moment de la compilation, une fois qu’une variable est déclarée elle ne peut plus être redéclarée et aucune valeur d’un autre type ne peut lui être assignée, sauf si ce type peut être converti de manière implicite au type de la variable.</span><span class="sxs-lookup"><span data-stu-id="6d147-104">Because C# is statically-typed at compile time, after a variable is declared, it cannot be declared again or assigned a value of another type unless that type is implicitly convertible to the variable's type.</span></span> <span data-ttu-id="6d147-105">Par exemple, `string` ne peut pas être converti implicitement en `int`.</span><span class="sxs-lookup"><span data-stu-id="6d147-105">For example, the `string` cannot be implicitly converted to `int`.</span></span> <span data-ttu-id="6d147-106">Après avoir déclaré `i` comme `int`, vous ne pouvez donc pas lui assigner la chaîne « Hello », comme l’illustre le code suivant :</span><span class="sxs-lookup"><span data-stu-id="6d147-106">Therefore, after you declare `i` as an `int`, you cannot assign the string "Hello" to it, as the following code shows:</span></span>

```csharp
int i;

// error CS0029: Cannot implicitly convert type 'string' to 'int'
i = "Hello";
```

<span data-ttu-id="6d147-107">Cependant, vous pouvez être amené à copier une valeur dans un paramètre de variable ou de méthode d’un autre type.</span><span class="sxs-lookup"><span data-stu-id="6d147-107">However, you might sometimes need to copy a value into a variable or method parameter of another type.</span></span> <span data-ttu-id="6d147-108">C’est notamment le cas si vous avez une variable de type entier que vous devez passer à une méthode dont le paramètre est de type `double`.</span><span class="sxs-lookup"><span data-stu-id="6d147-108">For example, you might have an integer variable that you need to pass to a method whose parameter is typed as `double`.</span></span> <span data-ttu-id="6d147-109">Il peut également arriver que vous deviez assigner une variable de classe à une variable de type interface.</span><span class="sxs-lookup"><span data-stu-id="6d147-109">Or you might need to assign a class variable to a variable of an interface type.</span></span> <span data-ttu-id="6d147-110">Les opérations de ce genre sont appelées « *conversions de types* ».</span><span class="sxs-lookup"><span data-stu-id="6d147-110">These kinds of operations are called *type conversions*.</span></span> <span data-ttu-id="6d147-111">En C#, vous pouvez effectuer les conversions suivantes :</span><span class="sxs-lookup"><span data-stu-id="6d147-111">In C#, you can perform the following kinds of conversions:</span></span>

- <span data-ttu-id="6d147-112">**Conversions implicites**: aucune syntaxe spéciale n’est requise, car la conversion échoue toujours et aucune donnée n’est perdue.</span><span class="sxs-lookup"><span data-stu-id="6d147-112">**Implicit conversions**: No special syntax is required because the conversion always succeeds and no data will be lost.</span></span> <span data-ttu-id="6d147-113">Citons par exemple les conversions de types intégraux en d’autres plus importants, et les conversions de classes dérivées en classes de base.</span><span class="sxs-lookup"><span data-stu-id="6d147-113">Examples include conversions from smaller to larger integral types, and conversions from derived classes to base classes.</span></span>

- <span data-ttu-id="6d147-114">**Conversions explicites (CASTS)**: les conversions explicites requièrent une [expression de cast](../../language-reference/operators/type-testing-and-cast.md#cast-expression).</span><span class="sxs-lookup"><span data-stu-id="6d147-114">**Explicit conversions (casts)**: Explicit conversions require a [cast expression](../../language-reference/operators/type-testing-and-cast.md#cast-expression).</span></span> <span data-ttu-id="6d147-115">Un cast est exigé quand les informations peuvent être perdues durant la conversion, ou quand la conversion peut échouer pour d’autres raisons.</span><span class="sxs-lookup"><span data-stu-id="6d147-115">Casting is required when information might be lost in the conversion, or when the conversion might not succeed for other reasons.</span></span> <span data-ttu-id="6d147-116">Exemples classiques : conversion numérique en type qui a moins de précision ou une plus petite plage, et conversion d’une instance de classe de base en classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="6d147-116">Typical examples include numeric conversion to a type that has less precision or a smaller range, and conversion of a base-class instance to a derived class.</span></span>

- <span data-ttu-id="6d147-117">**Conversions définies par l’utilisateur** : les conversions définies par l’utilisateur sont effectuées par des méthodes spéciales que vous pouvez définir pour permettre des conversions explicites ou implicites entre des types personnalisés qui n’ont pas de relation classe de base/classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="6d147-117">**User-defined conversions**: User-defined conversions are performed by special methods that you can define to enable explicit and implicit conversions between custom types that do not have a base class–derived class relationship.</span></span> <span data-ttu-id="6d147-118">Pour plus d’informations, consultez [Opérateurs de conversion définie par l’utilisateur](../../language-reference/operators/user-defined-conversion-operators.md).</span><span class="sxs-lookup"><span data-stu-id="6d147-118">For more information, see [User-defined conversion operators](../../language-reference/operators/user-defined-conversion-operators.md).</span></span>

- <span data-ttu-id="6d147-119">**Conversions avec les classes d’assistance** : pour effectuer une conversion entre des types non compatibles, tels que des entiers et des objets <xref:System.DateTime?displayProperty=nameWithType> ou des chaînes hexadécimales et des tableaux d’octets, vous pouvez utiliser la classe <xref:System.BitConverter?displayProperty=nameWithType>, la classe <xref:System.Convert?displayProperty=nameWithType> et les méthodes `Parse` des types numériques intégrés, comme <xref:System.Int32.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6d147-119">**Conversions with helper classes**: To convert between non-compatible types, such as integers and <xref:System.DateTime?displayProperty=nameWithType> objects, or hexadecimal strings and byte arrays, you can use the <xref:System.BitConverter?displayProperty=nameWithType> class, the <xref:System.Convert?displayProperty=nameWithType> class, and the `Parse` methods of the built-in numeric types, such as <xref:System.Int32.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6d147-120">Pour plus d’informations, consultez [Comment convertir un tableau d’octets en int](./how-to-convert-a-byte-array-to-an-int.md), [Comment convertir une chaîne en nombre](./how-to-convert-a-string-to-a-number.md)et [Comment effectuer une conversion entre des chaînes hexadécimales et des types numériques](./how-to-convert-between-hexadecimal-strings-and-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="6d147-120">For more information, see [How to convert a byte array to an int](./how-to-convert-a-byte-array-to-an-int.md), [How to convert a string to a number](./how-to-convert-a-string-to-a-number.md), and [How to convert between hexadecimal strings and numeric types](./how-to-convert-between-hexadecimal-strings-and-numeric-types.md).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="6d147-121">Conversions implicites</span><span class="sxs-lookup"><span data-stu-id="6d147-121">Implicit conversions</span></span>

<span data-ttu-id="6d147-122">Pour les types numériques intégrés, une conversion implicite peut être effectuée quand la valeur à stocker peut tenir dans la variable sans être tronquée ni arrondie.</span><span class="sxs-lookup"><span data-stu-id="6d147-122">For built-in numeric types, an implicit conversion can be made when the value to be stored can fit into the variable without being truncated or rounded off.</span></span> <span data-ttu-id="6d147-123">Pour les types intégraux, cela signifie que la plage du type de source est un sous-ensemble approprié de la plage du type cible.</span><span class="sxs-lookup"><span data-stu-id="6d147-123">For integral types, this means the range of the source type is a proper subset of the range for the target type.</span></span> <span data-ttu-id="6d147-124">Par exemple, une variable de type [long](../../language-reference/builtin-types/integral-numeric-types.md) (entier sur 64 bits) peut stocker n’importe quelle valeur pouvant être stockée par un [int](../../language-reference/builtin-types/integral-numeric-types.md) (entier sur 32 bits).</span><span class="sxs-lookup"><span data-stu-id="6d147-124">For example, a variable of type [long](../../language-reference/builtin-types/integral-numeric-types.md) (64-bit integer) can store any value that an [int](../../language-reference/builtin-types/integral-numeric-types.md) (32-bit integer) can store.</span></span> <span data-ttu-id="6d147-125">Dans l’exemple suivant, le compilateur convertit implicitement la valeur de `num` à droite en type `long` avant de l’assigner à `bigNum`.</span><span class="sxs-lookup"><span data-stu-id="6d147-125">In the following example, the compiler implicitly converts the value of `num` on the right to a type `long` before assigning it to `bigNum`.</span></span>

[!code-csharp[csProgGuideTypes#34](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#34)]

<span data-ttu-id="6d147-126">Pour obtenir la liste complète de toutes les conversions numériques implicites, consultez la section [conversions numériques implicites](../../language-reference/builtin-types/numeric-conversions.md#implicit-numeric-conversions) de l’article [conversions numériques intégrées](../../language-reference/builtin-types/numeric-conversions.md) .</span><span class="sxs-lookup"><span data-stu-id="6d147-126">For a complete list of all implicit numeric conversions, see the [Implicit numeric conversions](../../language-reference/builtin-types/numeric-conversions.md#implicit-numeric-conversions) section of the [Built-in numeric conversions](../../language-reference/builtin-types/numeric-conversions.md) article.</span></span>

<span data-ttu-id="6d147-127">Pour les types référence, il existe toujours une conversion implicite entre une classe et l’une de ses interfaces ou classes de base directes ou indirectes.</span><span class="sxs-lookup"><span data-stu-id="6d147-127">For reference types, an implicit conversion always exists from a class to any one of its direct or indirect base classes or interfaces.</span></span> <span data-ttu-id="6d147-128">Aucune syntaxe spéciale n’est nécessaire, car une classe dérivée contient toujours tous les membres d’une classe de base.</span><span class="sxs-lookup"><span data-stu-id="6d147-128">No special syntax is necessary because a derived class always contains all the members of a base class.</span></span>

```csharp
Derived d = new Derived();

// Always OK.
Base b = d;
```

## <a name="explicit-conversions"></a><span data-ttu-id="6d147-129">Conversions explicites</span><span class="sxs-lookup"><span data-stu-id="6d147-129">Explicit conversions</span></span>

<span data-ttu-id="6d147-130">Toutefois, si une conversion ne peut pas être réalisée sans risque de perte d’informations, le compilateur exige une conversion explicite, aussi appelée *cast*.</span><span class="sxs-lookup"><span data-stu-id="6d147-130">However, if a conversion cannot be made without a risk of losing information, the compiler requires that you perform an explicit conversion, which is called a *cast*.</span></span> <span data-ttu-id="6d147-131">Un cast est un moyen d’informer explicitement le compilateur que vous avez l’intention d’effectuer la conversion et que vous savez que la perte de données peut se produire, ou le cast peut échouer au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="6d147-131">A cast is a way of explicitly informing the compiler that you intend to make the conversion and that you are aware that data loss might occur, or the cast may fail at runtime.</span></span> <span data-ttu-id="6d147-132">Pour effectuer un cast, spécifiez le type voulu entre parenthèses devant la valeur ou la variable à convertir.</span><span class="sxs-lookup"><span data-stu-id="6d147-132">To perform a cast, specify the type that you are casting to in parentheses in front of the value or variable to be converted.</span></span> <span data-ttu-id="6d147-133">Le programme suivant convertit un [double](../../language-reference/builtin-types/floating-point-numeric-types.md) en [int](../../language-reference/builtin-types/integral-numeric-types.md). Le programme ne se compilera pas sans le cast.</span><span class="sxs-lookup"><span data-stu-id="6d147-133">The following program casts a [double](../../language-reference/builtin-types/floating-point-numeric-types.md) to an [int](../../language-reference/builtin-types/integral-numeric-types.md). The program will not compile without the cast.</span></span>

[!code-csharp[csProgGuideTypes#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#2)]

<span data-ttu-id="6d147-134">Pour obtenir la liste complète des conversions numériques explicites prises en charge, consultez la section [conversions numériques explicites](../../language-reference/builtin-types/numeric-conversions.md#explicit-numeric-conversions) de l’article [conversions numériques intégrées](../../language-reference/builtin-types/numeric-conversions.md) .</span><span class="sxs-lookup"><span data-stu-id="6d147-134">For a complete list of supported explicit numeric conversions, see the [Explicit numeric conversions](../../language-reference/builtin-types/numeric-conversions.md#explicit-numeric-conversions) section of the [Built-in numeric conversions](../../language-reference/builtin-types/numeric-conversions.md) article.</span></span>

<span data-ttu-id="6d147-135">Pour les types référence, un cast explicite est exigé si vous devez effectuer une conversion d’un type de base en type dérivé :</span><span class="sxs-lookup"><span data-stu-id="6d147-135">For reference types, an explicit cast is required if you need to convert from a base type to a derived type:</span></span>

```csharp
// Create a new derived type.
Giraffe g = new Giraffe();

// Implicit conversion to base type is safe.
Animal a = g;

// Explicit conversion is required to cast back
// to derived type. Note: This will compile but will
// throw an exception at run time if the right-side
// object is not in fact a Giraffe.
Giraffe g2 = (Giraffe)a;
```

<span data-ttu-id="6d147-136">Une opération cast entre types référence ne change pas le type au moment de l’exécution de l’objet sous-jacent. Elle change seulement le type de la valeur utilisée comme référence à cet objet.</span><span class="sxs-lookup"><span data-stu-id="6d147-136">A cast operation between reference types does not change the run-time type of the underlying object; it only changes the type of the value that is being used as a reference to that object.</span></span> <span data-ttu-id="6d147-137">Pour plus d’informations, consultez [Polymorphisme](../classes-and-structs/polymorphism.md).</span><span class="sxs-lookup"><span data-stu-id="6d147-137">For more information, see [Polymorphism](../classes-and-structs/polymorphism.md).</span></span>

## <a name="type-conversion-exceptions-at-run-time"></a><span data-ttu-id="6d147-138">Exceptions de conversion de type au moment de l’exécution</span><span class="sxs-lookup"><span data-stu-id="6d147-138">Type conversion exceptions at run time</span></span>

<span data-ttu-id="6d147-139">Dans certaines conversions de types référence, le compilateur ne peut pas déterminer si un cast sera valide.</span><span class="sxs-lookup"><span data-stu-id="6d147-139">In some reference type conversions, the compiler cannot determine whether a cast will be valid.</span></span> <span data-ttu-id="6d147-140">Il est possible qu’une opération cast dont la compilation fonctionne échoue au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="6d147-140">It is possible for a cast operation that compiles correctly to fail at run time.</span></span> <span data-ttu-id="6d147-141">Comme l’illustre l’exemple suivant, un cast de type qui échoue au moment de l’exécution provoque la levée d’une exception <xref:System.InvalidCastException>.</span><span class="sxs-lookup"><span data-stu-id="6d147-141">As shown in the following example, a type cast that fails at run time will cause an <xref:System.InvalidCastException> to be thrown.</span></span>

[!code-csharp[csProgGuideTypes#41](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#41)]

<span data-ttu-id="6d147-142">La `Test` méthode a un `Animal` paramètre, par conséquent le cast explicite `a` de l’argument en un `Reptile` fait une supposition dangereuse.</span><span class="sxs-lookup"><span data-stu-id="6d147-142">The `Test` method has an `Animal` parameter, thus explicitly casting the argument `a` to a `Reptile` makes a dangerous assumption.</span></span> <span data-ttu-id="6d147-143">Il est plus sûr de ne pas faire d’hypothèses, mais de vérifier le type.</span><span class="sxs-lookup"><span data-stu-id="6d147-143">It is safer to not make assumptions, but rather check the type.</span></span> <span data-ttu-id="6d147-144">C# fournit l’opérateur [is](../../language-reference/operators/type-testing-and-cast.md#is-operator) pour vous permettre de tester la compatibilité avant d’effectuer réellement un cast.</span><span class="sxs-lookup"><span data-stu-id="6d147-144">C# provides the [is](../../language-reference/operators/type-testing-and-cast.md#is-operator) operator to enable you to test for compatibility before actually performing a cast.</span></span> <span data-ttu-id="6d147-145">Pour plus d’informations, consultez [Comment effectuer un cast en toute sécurité à l’aide de critères spéciaux et des opérateurs As et is](../../how-to/safely-cast-using-pattern-matching-is-and-as-operators.md).</span><span class="sxs-lookup"><span data-stu-id="6d147-145">For more information, see [How to safely cast using pattern matching and the as and is operators](../../how-to/safely-cast-using-pattern-matching-is-and-as-operators.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="6d147-146">spécification du langage C#</span><span class="sxs-lookup"><span data-stu-id="6d147-146">C# language specification</span></span>

<span data-ttu-id="6d147-147">Pour plus d’informations, consultez la section [Conversions](~/_csharplang/spec/conversions.md) de la [spécification du langage C#](~/_csharplang/spec/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="6d147-147">For more information, see the [Conversions](~/_csharplang/spec/conversions.md) section of the [C# language specification](~/_csharplang/spec/introduction.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="6d147-148">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="6d147-148">See also</span></span>

- [<span data-ttu-id="6d147-149">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="6d147-149">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="6d147-150">Types</span><span class="sxs-lookup"><span data-stu-id="6d147-150">Types</span></span>](./index.md)
- [<span data-ttu-id="6d147-151">Expression Cast</span><span class="sxs-lookup"><span data-stu-id="6d147-151">Cast expression</span></span>](../../language-reference/operators/type-testing-and-cast.md#cast-expression)
- [<span data-ttu-id="6d147-152">Opérateurs de conversion définie par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="6d147-152">User-defined conversion operators</span></span>](../../language-reference/operators/user-defined-conversion-operators.md)
- <span data-ttu-id="6d147-153">[Conversion de type généralisée](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/yy580hbd(v=vs.120))</span><span class="sxs-lookup"><span data-stu-id="6d147-153">[Generalized Type Conversion](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/yy580hbd(v=vs.120))</span></span>
- [<span data-ttu-id="6d147-154">Comment convertir une chaîne en nombre</span><span class="sxs-lookup"><span data-stu-id="6d147-154">How to convert a string to a number</span></span>](./how-to-convert-a-string-to-a-number.md)
