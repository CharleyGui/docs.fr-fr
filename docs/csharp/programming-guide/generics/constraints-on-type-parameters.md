---
title: Contraintes sur les paramètres de type - Guide de programmation C#
description: En savoir plus sur les contraintes sur les paramètres de type. Les contraintes indiquent au compilateur les fonctionnalités que doit avoir un argument de type.
ms.date: 04/12/2018
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.openlocfilehash: 91807fa05ce49b8507ee6913ff2620452fcbfab5
ms.sourcegitcommit: 6f58a5f75ceeb936f8ee5b786e9adb81a9a3bee9
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/28/2020
ms.locfileid: "87301942"
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="3ece4-104">Contraintes sur les paramètres de type (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="3ece4-104">Constraints on type parameters (C# Programming Guide)</span></span>

<span data-ttu-id="3ece4-105">Les contraintes informent le compilateur sur les fonctionnalités que doit avoir un argument de type.</span><span class="sxs-lookup"><span data-stu-id="3ece4-105">Constraints inform the compiler about the capabilities a type argument must have.</span></span> <span data-ttu-id="3ece4-106">Sans contrainte, l’argument de type peut être n’importe quel type.</span><span class="sxs-lookup"><span data-stu-id="3ece4-106">Without any constraints, the type argument could be any type.</span></span> <span data-ttu-id="3ece4-107">Le compilateur peut seulement deviner les membres de <xref:System.Object?displayProperty=nameWithType>, qui est la classe de base par excellence de tous les types .NET.</span><span class="sxs-lookup"><span data-stu-id="3ece4-107">The compiler can only assume the members of <xref:System.Object?displayProperty=nameWithType>, which is the ultimate base class for any .NET type.</span></span> <span data-ttu-id="3ece4-108">Pour plus d’informations, consultez [Pourquoi utiliser des contraintes](#why-use-constraints).</span><span class="sxs-lookup"><span data-stu-id="3ece4-108">For more information, see [Why use constraints](#why-use-constraints).</span></span> <span data-ttu-id="3ece4-109">Si le code client utilise un type qui ne satisfait pas une contrainte, le compilateur émet une erreur.</span><span class="sxs-lookup"><span data-stu-id="3ece4-109">If client code uses a type that doesn't satisfy a constraint, the compiler issues an error.</span></span> <span data-ttu-id="3ece4-110">Les contraintes sont spécifiées à l’aide du mot clé contextuel `where`.</span><span class="sxs-lookup"><span data-stu-id="3ece4-110">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="3ece4-111">Le tableau suivant liste les sept types de contrainte :</span><span class="sxs-lookup"><span data-stu-id="3ece4-111">The following table lists the seven types of constraints:</span></span>

|<span data-ttu-id="3ece4-112">Contrainte</span><span class="sxs-lookup"><span data-stu-id="3ece4-112">Constraint</span></span>|<span data-ttu-id="3ece4-113">Description</span><span class="sxs-lookup"><span data-stu-id="3ece4-113">Description</span></span>|
|----------------|-----------------|
|`where T : struct`|<span data-ttu-id="3ece4-114">L’argument de type doit être un type valeur n’acceptant pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="3ece4-114">The type argument must be a non-nullable value type.</span></span> <span data-ttu-id="3ece4-115">Pour plus d’informations sur les types valeur Nullable, consultez [types valeur Nullable](../../language-reference/builtin-types/nullable-value-types.md).</span><span class="sxs-lookup"><span data-stu-id="3ece4-115">For information about nullable value types, see [Nullable value types](../../language-reference/builtin-types/nullable-value-types.md).</span></span> <span data-ttu-id="3ece4-116">Étant donné que tous les types valeur ont un constructeur sans paramètre accessible, la `struct` contrainte implique la `new()` contrainte et ne peut pas être combinée avec la `new()` contrainte.</span><span class="sxs-lookup"><span data-stu-id="3ece4-116">Because all value types have an accessible parameterless constructor, the `struct` constraint implies the `new()` constraint and can't be combined with the `new()` constraint.</span></span> <span data-ttu-id="3ece4-117">Vous ne pouvez pas associer la `struct` contrainte à la `unmanaged` contrainte.</span><span class="sxs-lookup"><span data-stu-id="3ece4-117">You can't combine the `struct` constraint with the `unmanaged` constraint.</span></span>|
|`where T : class`|<span data-ttu-id="3ece4-118">L’argument de type doit être un type référence.</span><span class="sxs-lookup"><span data-stu-id="3ece4-118">The type argument must be a reference type.</span></span> <span data-ttu-id="3ece4-119">Cette contrainte s’applique également à tous les types de classe, d’interface, de délégué ou de tableau.</span><span class="sxs-lookup"><span data-stu-id="3ece4-119">This constraint applies also to any class, interface, delegate, or array type.</span></span> <span data-ttu-id="3ece4-120">Dans un contexte Nullable en C# 8,0 ou une version ultérieure, `T` doit être un type de référence non Nullable.</span><span class="sxs-lookup"><span data-stu-id="3ece4-120">In a nullable context in C# 8.0 or later, `T` must be a non-nullable reference type.</span></span> |
|`where T : class?`|<span data-ttu-id="3ece4-121">L’argument de type doit être un type référence, Nullable ou non Nullable.</span><span class="sxs-lookup"><span data-stu-id="3ece4-121">The type argument must be a reference type, either nullable or non-nullable.</span></span> <span data-ttu-id="3ece4-122">Cette contrainte s’applique également à tous les types de classe, d’interface, de délégué ou de tableau.</span><span class="sxs-lookup"><span data-stu-id="3ece4-122">This constraint applies also to any class, interface, delegate, or array type.</span></span>|
|`where T : notnull`|<span data-ttu-id="3ece4-123">L’argument de type doit être un type non Nullable.</span><span class="sxs-lookup"><span data-stu-id="3ece4-123">The type argument must be a non-nullable type.</span></span> <span data-ttu-id="3ece4-124">L’argument peut être un type référence non Nullable en C# 8,0 ou version ultérieure, ou un type valeur qui n’autorise pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="3ece4-124">The argument can be a non-nullable reference type in C# 8.0 or later, or a non-nullable value type.</span></span> |
|`where T : unmanaged`|<span data-ttu-id="3ece4-125">L’argument de type doit être un type non [managé](../../language-reference/builtin-types/unmanaged-types.md)qui n’accepte pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="3ece4-125">The type argument must be a non-nullable [unmanaged type](../../language-reference/builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="3ece4-126">La `unmanaged` contrainte implique la `struct` contrainte et ne peut pas être combinée avec `struct` les `new()` contraintes ou.</span><span class="sxs-lookup"><span data-stu-id="3ece4-126">The `unmanaged` constraint implies the `struct` constraint and can't be combined with either the `struct` or `new()` constraints.</span></span>|
|`where T : new()`|<span data-ttu-id="3ece4-127">L’argument de type doit avoir un constructeur sans paramètre public.</span><span class="sxs-lookup"><span data-stu-id="3ece4-127">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="3ece4-128">Quand vous utilisez la contrainte `new()` avec d’autres contraintes, elle doit être spécifiée en dernier.</span><span class="sxs-lookup"><span data-stu-id="3ece4-128">When used together with other constraints, the `new()` constraint must be specified last.</span></span> <span data-ttu-id="3ece4-129">La `new()` contrainte ne peut pas être combinée avec les `struct` `unmanaged` contraintes et.</span><span class="sxs-lookup"><span data-stu-id="3ece4-129">The `new()` constraint can't be combined with the `struct` and `unmanaged` constraints.</span></span>|
|<span data-ttu-id="3ece4-130">`where T :` *\<base class name>*</span><span class="sxs-lookup"><span data-stu-id="3ece4-130">`where T :` *\<base class name>*</span></span>|<span data-ttu-id="3ece4-131">L’argument de type doit être la classe de base spécifiée ou en dériver.</span><span class="sxs-lookup"><span data-stu-id="3ece4-131">The type argument must be or derive from the specified base class.</span></span> <span data-ttu-id="3ece4-132">Dans un contexte Nullable en C# 8,0 et versions ultérieures, `T` doit être un type de référence non Nullable dérivé de la classe de base spécifiée.</span><span class="sxs-lookup"><span data-stu-id="3ece4-132">In a nullable context in C# 8.0 and later, `T` must be a non-nullable reference type derived from the specified base class.</span></span> |
|<span data-ttu-id="3ece4-133">`where T :` *\<base class name>?*</span><span class="sxs-lookup"><span data-stu-id="3ece4-133">`where T :` *\<base class name>?*</span></span>|<span data-ttu-id="3ece4-134">L’argument de type doit être la classe de base spécifiée ou en dériver.</span><span class="sxs-lookup"><span data-stu-id="3ece4-134">The type argument must be or derive from the specified base class.</span></span> <span data-ttu-id="3ece4-135">Dans un contexte Nullable en C# 8,0 et versions ultérieures, `T` peut être un type Nullable ou non Nullable dérivé de la classe de base spécifiée.</span><span class="sxs-lookup"><span data-stu-id="3ece4-135">In a nullable context in C# 8.0 and later, `T` may be either a nullable or non-nullable type derived from the specified base class.</span></span> |
|<span data-ttu-id="3ece4-136">`where T :` *\<interface name>*</span><span class="sxs-lookup"><span data-stu-id="3ece4-136">`where T :` *\<interface name>*</span></span>|<span data-ttu-id="3ece4-137">L’argument de type doit être ou implémenter l’interface spécifiée.</span><span class="sxs-lookup"><span data-stu-id="3ece4-137">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="3ece4-138">Plusieurs contraintes d’interface peuvent être spécifiées.</span><span class="sxs-lookup"><span data-stu-id="3ece4-138">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="3ece4-139">L’interface qui impose les contraintes peut également être générique.</span><span class="sxs-lookup"><span data-stu-id="3ece4-139">The constraining interface can also be generic.</span></span> <span data-ttu-id="3ece4-140">Dans un contexte Nullable en C# 8,0 et versions ultérieures, `T` doit être un type non Nullable qui implémente l’interface spécifiée.</span><span class="sxs-lookup"><span data-stu-id="3ece4-140">In a nullable context in C# 8.0 and later, `T` must be a non-nullable type that implements the specified interface.</span></span>|
|<span data-ttu-id="3ece4-141">`where T :` *\<interface name>?*</span><span class="sxs-lookup"><span data-stu-id="3ece4-141">`where T :` *\<interface name>?*</span></span>|<span data-ttu-id="3ece4-142">L’argument de type doit être ou implémenter l’interface spécifiée.</span><span class="sxs-lookup"><span data-stu-id="3ece4-142">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="3ece4-143">Plusieurs contraintes d’interface peuvent être spécifiées.</span><span class="sxs-lookup"><span data-stu-id="3ece4-143">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="3ece4-144">L’interface qui impose les contraintes peut également être générique.</span><span class="sxs-lookup"><span data-stu-id="3ece4-144">The constraining interface can also be generic.</span></span> <span data-ttu-id="3ece4-145">Dans un contexte Nullable en C# 8,0, `T` peut être un type de référence Nullable, un type de référence non Nullable ou un type valeur.</span><span class="sxs-lookup"><span data-stu-id="3ece4-145">In a nullable context in C# 8.0, `T` may be a nullable reference type, a non-nullable reference type, or a value type.</span></span> <span data-ttu-id="3ece4-146">`T`n’est pas un type valeur Nullable.</span><span class="sxs-lookup"><span data-stu-id="3ece4-146">`T` may not be a nullable value type.</span></span>|
|`where T : U`|<span data-ttu-id="3ece4-147">L’argument de type fourni pour `T` doit être ou dériver de l’argument fourni pour `U` .</span><span class="sxs-lookup"><span data-stu-id="3ece4-147">The type argument supplied for `T` must be or derive from the argument supplied for `U`.</span></span> <span data-ttu-id="3ece4-148">Dans un contexte Nullable, si `U` est un type référence qui n’accepte pas les valeurs NULL, `T` doit être un type référence non Nullable.</span><span class="sxs-lookup"><span data-stu-id="3ece4-148">In a nullable context, if `U` is a non-nullable reference type, `T` must be non-nullable reference type.</span></span> <span data-ttu-id="3ece4-149">Si `U` est un type de référence Nullable, `T` peut avoir la valeur null ou n’accepte pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="3ece4-149">If `U` is a nullable reference type, `T` may be either nullable or non-nullable.</span></span> |

## <a name="why-use-constraints"></a><span data-ttu-id="3ece4-150">Pourquoi utiliser des contraintes</span><span class="sxs-lookup"><span data-stu-id="3ece4-150">Why use constraints</span></span>

<span data-ttu-id="3ece4-151">Les contraintes spécifient les capacités et les attentes d’un paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="3ece4-151">Constraints specify the capabilities and expectations of a type parameter.</span></span> <span data-ttu-id="3ece4-152">La déclaration de ces contraintes signifie que vous pouvez utiliser les opérations et les appels de méthode du type de contrainte.</span><span class="sxs-lookup"><span data-stu-id="3ece4-152">Declaring those constraints means you can use the operations and method calls of the constraining type.</span></span> <span data-ttu-id="3ece4-153">Si votre classe ou méthode générique utilise une opération sur les membres génériques au-delà de l’assignation simple ou l’appel de toute méthode non prise en charge par <xref:System.Object?displayProperty=nameWithType> , vous devez appliquer des contraintes au paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="3ece4-153">If your generic class or method uses any operation on the generic members beyond simple assignment or calling any methods not supported by <xref:System.Object?displayProperty=nameWithType>, you'll have to apply constraints to the type parameter.</span></span> <span data-ttu-id="3ece4-154">Par exemple, la contrainte de classe de base indique au compilateur que seuls les objets de ce type ou dérivés de ce type seront utilisés comme arguments de type.</span><span class="sxs-lookup"><span data-stu-id="3ece4-154">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="3ece4-155">Une fois que le compilateur a cette garantie, il peut autoriser les méthodes de ce type à être appelées dans la classe générique.</span><span class="sxs-lookup"><span data-stu-id="3ece4-155">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="3ece4-156">L’exemple de code suivant illustre la fonctionnalité que vous pouvez ajouter à la classe `GenericList<T>` (dans [Introduction aux génériques](../../../standard/generics/index.md)) en appliquant une contrainte de classe de base.</span><span class="sxs-lookup"><span data-stu-id="3ece4-156">The following code example demonstrates the functionality you can add to the `GenericList<T>` class (in [Introduction to Generics](../../../standard/generics/index.md)) by applying a base class constraint.</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#9)]

<span data-ttu-id="3ece4-157">La contrainte permet à la classe générique d’utiliser la propriété `Employee.Name`.</span><span class="sxs-lookup"><span data-stu-id="3ece4-157">The constraint enables the generic class to use the `Employee.Name` property.</span></span> <span data-ttu-id="3ece4-158">La contrainte spécifie que tous les éléments de type `T` sont soit un objet `Employee`, soit un objet qui hérite de `Employee`, et rien d’autre.</span><span class="sxs-lookup"><span data-stu-id="3ece4-158">The constraint specifies that all items of type `T` are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>

<span data-ttu-id="3ece4-159">Plusieurs contraintes peuvent être appliquées au même paramètre de type, et les contraintes elles-mêmes peuvent être des types génériques, comme suit :</span><span class="sxs-lookup"><span data-stu-id="3ece4-159">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#10)]

<span data-ttu-id="3ece4-160">En appliquant la contrainte `where T : class`, évitez d’utiliser les opérateurs `==` et `!=` sur le paramètre de type, car ces opérateurs testent uniquement l’identité des références, et non l’égalité des valeurs.</span><span class="sxs-lookup"><span data-stu-id="3ece4-160">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="3ece4-161">Ce comportement se produit même si ces opérateurs sont surchargés dans un type qui est utilisé comme argument.</span><span class="sxs-lookup"><span data-stu-id="3ece4-161">This behavior occurs even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="3ece4-162">Le code suivant illustre ce point ; la sortie a la valeur false même si la classe <xref:System.String> surcharge l’opérateur `==`.</span><span class="sxs-lookup"><span data-stu-id="3ece4-162">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#11)]

<span data-ttu-id="3ece4-163">Le compilateur sait uniquement que `T` est un type référence au moment de la compilation et doit utiliser les opérateurs par défaut qui sont valides pour tous les types référence.</span><span class="sxs-lookup"><span data-stu-id="3ece4-163">The compiler only knows that `T` is a reference type at compile time and must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="3ece4-164">Si vous devez tester l’égalité des valeurs, il est recommandé d’appliquer également la contrainte `where T : IEquatable<T>` ou `where T : IComparable<T>` et d’implémenter l’interface dans toute classe qui sera utilisée pour construire la classe générique.</span><span class="sxs-lookup"><span data-stu-id="3ece4-164">If you must test for value equality, the recommended way is to also apply the `where T : IEquatable<T>` or `where T : IComparable<T>` constraint and implement the interface in any class that will be used to construct the generic class.</span></span>

## <a name="constraining-multiple-parameters"></a><span data-ttu-id="3ece4-165">Utilisation de contraintes dans plusieurs paramètres</span><span class="sxs-lookup"><span data-stu-id="3ece4-165">Constraining multiple parameters</span></span>

<span data-ttu-id="3ece4-166">Vous pouvez appliquer des contraintes à plusieurs paramètres et plusieurs contraintes à un seul paramètre, comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="3ece4-166">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#12)]

## <a name="unbounded-type-parameters"></a><span data-ttu-id="3ece4-167">Paramètres de type unbounded</span><span class="sxs-lookup"><span data-stu-id="3ece4-167">Unbounded type parameters</span></span>

 <span data-ttu-id="3ece4-168">Les paramètres de type qui n’ont aucune contrainte, tels que T dans la classe publique `SampleClass<T>{}`, sont appelés paramètres de type unbounded.</span><span class="sxs-lookup"><span data-stu-id="3ece4-168">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="3ece4-169">Les paramètres de type unbounded obéissent aux règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="3ece4-169">Unbounded type parameters have the following rules:</span></span>

- <span data-ttu-id="3ece4-170">Les `!=` `==` opérateurs et ne peuvent pas être utilisés, car il n’y a aucune garantie que l’argument de type concret prendra en charge ces opérateurs.</span><span class="sxs-lookup"><span data-stu-id="3ece4-170">The `!=` and `==` operators can't be used because there's no guarantee that the concrete type argument will support these operators.</span></span>
- <span data-ttu-id="3ece4-171">Ils peuvent être convertis vers et depuis `System.Object` ou être explicitement convertis vers tout type d’interface.</span><span class="sxs-lookup"><span data-stu-id="3ece4-171">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>
- <span data-ttu-id="3ece4-172">Vous pouvez les comparer à [null](../../language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="3ece4-172">You can compare them to [null](../../language-reference/keywords/null.md).</span></span> <span data-ttu-id="3ece4-173">Si un paramètre unbounded est comparé à `null`, la comparaison retourne toujours la valeur false si l’argument de type est un type valeur.</span><span class="sxs-lookup"><span data-stu-id="3ece4-173">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>

## <a name="type-parameters-as-constraints"></a><span data-ttu-id="3ece4-174">Paramètres de type en tant que contraintes</span><span class="sxs-lookup"><span data-stu-id="3ece4-174">Type parameters as constraints</span></span>

<span data-ttu-id="3ece4-175">L’utilisation d’un paramètre de type générique comme contrainte est utile quand une fonction membre dotée de son propre paramètre de type doit contraindre ce paramètre au paramètre du type conteneur, comme le montre l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="3ece4-175">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#13)]

<span data-ttu-id="3ece4-176">Dans l’exemple précédent, `T` est une contrainte de type dans le contexte de la méthode `Add` et un paramètre de type unbounded dans le contexte de la classe `List`.</span><span class="sxs-lookup"><span data-stu-id="3ece4-176">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>

<span data-ttu-id="3ece4-177">Les paramètres de type peuvent également être utilisés comme contraintes dans les définitions de classes génériques.</span><span class="sxs-lookup"><span data-stu-id="3ece4-177">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="3ece4-178">Le paramètre de type doit être déclaré entre crochets pointus, ainsi que tous les autres paramètres de type :</span><span class="sxs-lookup"><span data-stu-id="3ece4-178">The type parameter must be declared within the angle brackets together with any other type parameters:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#14)]

<span data-ttu-id="3ece4-179">L’utilité des paramètres de type en tant que contraintes avec les classes génériques est limitée, car le compilateur ne peut rien deviner à propos du paramètre de type en dehors du fait qu’il dérive de `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="3ece4-179">The usefulness of type parameters as constraints with generic classes is limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="3ece4-180">Utilisez des paramètres de type en tant que contraintes sur les classes génériques dans les scénarios dans lesquels vous souhaitez mettre en application une relation d’héritage entre deux paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="3ece4-180">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>

## <a name="notnull-constraint"></a><span data-ttu-id="3ece4-181">Contrainte NotNull</span><span class="sxs-lookup"><span data-stu-id="3ece4-181">NotNull constraint</span></span>

<span data-ttu-id="3ece4-182">À compter de C# 8,0 dans un contexte Nullable, vous pouvez utiliser la `notnull` contrainte pour spécifier que l’argument de type doit être un type valeur n’acceptant pas les valeurs null ou un type référence non Nullable.</span><span class="sxs-lookup"><span data-stu-id="3ece4-182">Beginning with C# 8.0 in a nullable context, you can use the `notnull` constraint to specify that the type argument must be a non-nullable value type or non-nullable reference type.</span></span> <span data-ttu-id="3ece4-183">La `notnull` contrainte ne peut être utilisée que dans un `nullable enable` contexte.</span><span class="sxs-lookup"><span data-stu-id="3ece4-183">The `notnull` constraint can only be used in a `nullable enable` context.</span></span> <span data-ttu-id="3ece4-184">Le compilateur génère un avertissement si vous ajoutez la `notnull` contrainte dans un contexte oublie Nullable.</span><span class="sxs-lookup"><span data-stu-id="3ece4-184">The compiler generates a warning if you add the `notnull` constraint in a nullable oblivious context.</span></span>

<span data-ttu-id="3ece4-185">Contrairement à d’autres contraintes, lorsqu’un argument de type viole la `notnull` contrainte, le compilateur génère un avertissement lorsque ce code est compilé dans un `nullable enable` contexte.</span><span class="sxs-lookup"><span data-stu-id="3ece4-185">Unlike other constraints, when a type argument violates the `notnull` constraint, the compiler generates a warning when that code is compiled in a `nullable enable` context.</span></span> <span data-ttu-id="3ece4-186">Si le code est compilé dans un contexte oublie Nullable, le compilateur ne génère pas d’avertissements ni d’erreurs.</span><span class="sxs-lookup"><span data-stu-id="3ece4-186">If the code is compiled in a nullable oblivious context, the compiler doesn't generate any warnings or errors.</span></span>

<span data-ttu-id="3ece4-187">À compter de C# 8,0 dans un contexte Nullable, la `class` contrainte spécifie que l’argument de type doit être un type de référence n’acceptant pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="3ece4-187">Beginning with C# 8.0 in a nullable context, the `class` constraint specifies that the type argument must be a non-nullable reference type.</span></span> <span data-ttu-id="3ece4-188">Dans un contexte Nullable, lorsqu’un paramètre de type est un type référence Nullable, le compilateur génère un avertissement.</span><span class="sxs-lookup"><span data-stu-id="3ece4-188">In a nullable context, when a type parameter is a nullable reference type, the compiler generates a warning.</span></span>

## <a name="unmanaged-constraint"></a><span data-ttu-id="3ece4-189">Contrainte non managée</span><span class="sxs-lookup"><span data-stu-id="3ece4-189">Unmanaged constraint</span></span>

<span data-ttu-id="3ece4-190">À compter de C# 7,3, vous pouvez utiliser la `unmanaged` contrainte pour spécifier que le paramètre de type doit être un [type non managé](../../language-reference/builtin-types/unmanaged-types.md)qui n’accepte pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="3ece4-190">Beginning with C# 7.3, you can use the `unmanaged` constraint to specify that the type parameter must be a non-nullable [unmanaged type](../../language-reference/builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="3ece4-191">La contrainte `unmanaged` vous permet d’écrire des routines réutilisables à appliquer aux types qui peuvent être manipulés comme blocs de mémoire, comme illustré dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="3ece4-191">The `unmanaged` constraint enables you to write reusable routines to work with types that can be manipulated as blocks of memory, as shown in the following example:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#15)]

<span data-ttu-id="3ece4-192">La méthode précédente doit être compilée dans un contexte `unsafe`, car elle utilise l’opérateur `sizeof` sur un type qui n’est pas connu pour être un type intégré.</span><span class="sxs-lookup"><span data-stu-id="3ece4-192">The preceding method must be compiled in an `unsafe` context because it uses the `sizeof` operator on a type not known to be a built-in type.</span></span> <span data-ttu-id="3ece4-193">Sans la contrainte `unmanaged`, l’opérateur `sizeof` n’est pas disponible.</span><span class="sxs-lookup"><span data-stu-id="3ece4-193">Without the `unmanaged` constraint, the `sizeof` operator is unavailable.</span></span>

<span data-ttu-id="3ece4-194">La `unmanaged` contrainte implique la `struct` contrainte et ne peut pas être associée à celle-ci.</span><span class="sxs-lookup"><span data-stu-id="3ece4-194">The `unmanaged` constraint implies the `struct` constraint and can't be combined with it.</span></span> <span data-ttu-id="3ece4-195">Étant donné que la `struct` contrainte implique la `new()` contrainte, la contrainte `unmanaged` ne peut pas être combinée à la contrainte `new()` .</span><span class="sxs-lookup"><span data-stu-id="3ece4-195">Because the `struct` constraint implies the `new()` constraint, the `unmanaged` constraint can't be combined with the `new()` constraint as well.</span></span>

## <a name="delegate-constraints"></a><span data-ttu-id="3ece4-196">Contraintes de délégué</span><span class="sxs-lookup"><span data-stu-id="3ece4-196">Delegate constraints</span></span>

<span data-ttu-id="3ece4-197">À partir de C# 7.3, vous pouvez aussi utiliser <xref:System.Delegate?displayProperty=nameWithType> ou <xref:System.MulticastDelegate?displayProperty=nameWithType> comme contrainte de classe de base.</span><span class="sxs-lookup"><span data-stu-id="3ece4-197">Also beginning with C# 7.3, you can use <xref:System.Delegate?displayProperty=nameWithType> or <xref:System.MulticastDelegate?displayProperty=nameWithType> as a base class constraint.</span></span> <span data-ttu-id="3ece4-198">Le CLR a toujours autorisé cette contrainte, contrairement au langage C#.</span><span class="sxs-lookup"><span data-stu-id="3ece4-198">The CLR always allowed this constraint, but the C# language disallowed it.</span></span> <span data-ttu-id="3ece4-199">La contrainte `System.Delegate` vous permet d’écrire du code qui fonctionne avec les délégués en mode type sécurisé.</span><span class="sxs-lookup"><span data-stu-id="3ece4-199">The `System.Delegate` constraint enables you to write code that works with delegates in a type-safe manner.</span></span> <span data-ttu-id="3ece4-200">Le code suivant définit une méthode d’extension qui combine deux délégués à condition qu’ils soient du même type :</span><span class="sxs-lookup"><span data-stu-id="3ece4-200">The following code defines an extension method that combines two delegates provided they're the same type:</span></span>

[!code-csharp[using the delegate constraint](snippets/GenericWhereConstraints.cs#16)]

<span data-ttu-id="3ece4-201">Vous pouvez utiliser la méthode ci-dessus pour combiner des délégués qui sont du même type :</span><span class="sxs-lookup"><span data-stu-id="3ece4-201">You can use the above method to combine delegates that are the same type:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#17)]

<span data-ttu-id="3ece4-202">Si vous supprimez les commentaires de la dernière ligne, il ne sera pas compilé.</span><span class="sxs-lookup"><span data-stu-id="3ece4-202">If you uncomment the last line, it won't compile.</span></span> <span data-ttu-id="3ece4-203">`first`Et `test` sont des types délégués, mais il s’agit de types délégués différents.</span><span class="sxs-lookup"><span data-stu-id="3ece4-203">Both `first` and `test` are delegate types, but they're different delegate types.</span></span>

## <a name="enum-constraints"></a><span data-ttu-id="3ece4-204">Contraintes d’enum</span><span class="sxs-lookup"><span data-stu-id="3ece4-204">Enum constraints</span></span>

<span data-ttu-id="3ece4-205">À compter de C# 7.3, vous pouvez également spécifier le type <xref:System.Enum?displayProperty=nameWithType> comme contrainte de classe de base.</span><span class="sxs-lookup"><span data-stu-id="3ece4-205">Beginning in C# 7.3, you can also specify the <xref:System.Enum?displayProperty=nameWithType> type as a base class constraint.</span></span> <span data-ttu-id="3ece4-206">Le CLR a toujours autorisé cette contrainte, contrairement au langage C#.</span><span class="sxs-lookup"><span data-stu-id="3ece4-206">The CLR always allowed this constraint, but the C# language disallowed it.</span></span> <span data-ttu-id="3ece4-207">Les génériques utilisant `System.Enum` fournissent une programmation de type sécurisé aux résultats de cache issus de l’utilisation de méthodes statiques dans `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="3ece4-207">Generics using `System.Enum` provide type-safe programming to cache results from using the static methods in `System.Enum`.</span></span> <span data-ttu-id="3ece4-208">L’exemple suivant recherche toutes les valeurs valides d’un type enum, puis génère un dictionnaire qui mappe ces valeurs à sa représentation sous forme de chaîne.</span><span class="sxs-lookup"><span data-stu-id="3ece4-208">The following sample finds all the valid values for an enum type, and then builds a dictionary that maps those values to its string representation.</span></span>

[!code-csharp[using the enum constraint](snippets/GenericWhereConstraints.cs#18)]

<span data-ttu-id="3ece4-209">`Enum.GetValues`et `Enum.GetName` utilisent la réflexion, ce qui a des répercussions sur les performances.</span><span class="sxs-lookup"><span data-stu-id="3ece4-209">`Enum.GetValues` and `Enum.GetName` use reflection, which has performance implications.</span></span> <span data-ttu-id="3ece4-210">Vous pouvez appeler `EnumNamedValues` pour générer une collection qui est mise en cache et réutilisée au lieu de répéter les appels qui requièrent la réflexion.</span><span class="sxs-lookup"><span data-stu-id="3ece4-210">You can call `EnumNamedValues` to build a collection that is cached and reused rather than repeating the calls that require reflection.</span></span>

<span data-ttu-id="3ece4-211">Vous pouvez l’utiliser comme montré dans l’exemple suivant pour créer un enum et générer un dictionnaire de ses valeurs et de ses noms :</span><span class="sxs-lookup"><span data-stu-id="3ece4-211">You could use it as shown in the following sample to create an enum and build a dictionary of its values and names:</span></span>

[!code-csharp[enum definition](snippets/GenericWhereConstraints.cs#19)]

[!code-csharp[using the enum constrained method](snippets/GenericWhereConstraints.cs#20)]

## <a name="see-also"></a><span data-ttu-id="3ece4-212">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="3ece4-212">See also</span></span>

- <xref:System.Collections.Generic>
- [<span data-ttu-id="3ece4-213">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="3ece4-213">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="3ece4-214">Introduction aux génériques</span><span class="sxs-lookup"><span data-stu-id="3ece4-214">Introduction to Generics</span></span>](./index.md)
- [<span data-ttu-id="3ece4-215">Classes génériques</span><span class="sxs-lookup"><span data-stu-id="3ece4-215">Generic Classes</span></span>](./generic-classes.md)
- [<span data-ttu-id="3ece4-216">nouvelle contrainte</span><span class="sxs-lookup"><span data-stu-id="3ece4-216">new Constraint</span></span>](../../language-reference/keywords/new-constraint.md)
