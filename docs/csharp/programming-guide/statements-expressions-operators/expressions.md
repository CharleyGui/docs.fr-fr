---
title: Expressions - Guide de programmation C#
description: En savoir plus sur les expressions dans la programmation C#, telles que l’appel, la requête, l’expression lambda, les littéraux et les noms simples.
ms.date: 05/11/2017
helpviewer_keywords:
- expressions [C#]
- C# language, expressions
ms.assetid: c7d8feb0-0e58-4f94-8bf6-4d070550a832
ms.openlocfilehash: 5bcfdae27c30bd5d845f621ac4b5b20ff37612a0
ms.sourcegitcommit: 552b4b60c094559db9d8178fa74f5bafaece0caf
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/29/2020
ms.locfileid: "87381825"
---
# <a name="expressions-c-programming-guide"></a><span data-ttu-id="36ac6-103">Expressions (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="36ac6-103">Expressions (C# Programming Guide)</span></span>

<span data-ttu-id="36ac6-104">Une *expression* est une séquence d’un ou plusieurs opérandes et de zéro, un ou plusieurs [opérateurs](../../language-reference/operators/index.md) qui peuvent être évalués à une valeur, un objet, une méthode ou un espace de noms unique.</span><span class="sxs-lookup"><span data-stu-id="36ac6-104">An *expression* is a sequence of one or more operands and zero or more [operators](../../language-reference/operators/index.md) that can be evaluated to a single value, object, method, or namespace.</span></span> <span data-ttu-id="36ac6-105">Elle peut être constituée d’une valeur littérale, d’un appel de méthode, d’un opérateur et de ses opérandes, ou d’un *nom simple*.</span><span class="sxs-lookup"><span data-stu-id="36ac6-105">Expressions can consist of a literal value, a method invocation, an operator and its operands, or a *simple name*.</span></span> <span data-ttu-id="36ac6-106">Un nom simple peut être le nom d'une variable, d'un membre de type, d'un paramètre de méthode, d'un espace de noms ou d'un type.</span><span class="sxs-lookup"><span data-stu-id="36ac6-106">Simple names can be the name of a variable, type member, method parameter, namespace or type.</span></span>  
  
 <span data-ttu-id="36ac6-107">Les expressions peuvent utiliser des opérateurs qui à leur tour utilisent d’autres expressions en tant que paramètres, ou des appels de méthode dont les paramètres sont à leur tour d’autres appels de méthode. Leur complexité est donc très variable.</span><span class="sxs-lookup"><span data-stu-id="36ac6-107">Expressions can use operators that in turn use other expressions as parameters, or method calls whose parameters are in turn other method calls, so expressions can range from simple to very complex.</span></span> <span data-ttu-id="36ac6-108">Voici deux exemples d’expressions :</span><span class="sxs-lookup"><span data-stu-id="36ac6-108">Following are two examples of expressions:</span></span>  
  
```csharp  
((x < 10) && ( x > 5)) || ((x > 20) && (x < 25));

System.Convert.ToInt32("35");  
```  
  
## <a name="expression-values"></a><span data-ttu-id="36ac6-109">Valeurs d’expressions</span><span class="sxs-lookup"><span data-stu-id="36ac6-109">Expression values</span></span>

 <span data-ttu-id="36ac6-110">Dans la plupart des contextes dans lesquels les expressions sont utilisées, par exemple dans les instructions ou les paramètres de méthode, l’expression est supposée correspondre à une valeur.</span><span class="sxs-lookup"><span data-stu-id="36ac6-110">In most of the contexts in which expressions are used, for example in statements or method parameters, the expression is expected to evaluate to some value.</span></span> <span data-ttu-id="36ac6-111">Si x et y sont des entiers, l’expression `x + y` correspond à une valeur numérique.</span><span class="sxs-lookup"><span data-stu-id="36ac6-111">If x and y are integers, the expression `x + y` evaluates to a numeric value.</span></span> <span data-ttu-id="36ac6-112">L’expression `new MyClass()` correspond à une référence à une nouvelle instance d’une classe `MyClass`.</span><span class="sxs-lookup"><span data-stu-id="36ac6-112">The expression `new MyClass()` evaluates to a reference to a new instance of a `MyClass` class.</span></span> <span data-ttu-id="36ac6-113">L’expression `myClass.ToString()` correspond à une chaîne, car c’est le type de retour de la méthode.</span><span class="sxs-lookup"><span data-stu-id="36ac6-113">The expression `myClass.ToString()` evaluates to a string because that is the return type of the method.</span></span> <span data-ttu-id="36ac6-114">Toutefois, même si un espace de noms est considéré comme une expression, il ne correspond pas à une valeur et ne peut donc jamais être le résultat final d’une expression.</span><span class="sxs-lookup"><span data-stu-id="36ac6-114">However, although a namespace name is classified as an expression, it does not evaluate to a value and therefore can never be the final result of any expression.</span></span> <span data-ttu-id="36ac6-115">Vous ne pouvez pas passer un nom d’espace de noms à un paramètre de méthode, ni l’utiliser dans une nouvelle expression ou l’affecter à une variable.</span><span class="sxs-lookup"><span data-stu-id="36ac6-115">You cannot pass a namespace name to a method parameter, or use it in a new expression, or assign it to a variable.</span></span> <span data-ttu-id="36ac6-116">Vous pouvez l’utiliser uniquement en tant que sous-expression dans une expression plus longue.</span><span class="sxs-lookup"><span data-stu-id="36ac6-116">You can only use it as a sub-expression in a larger expression.</span></span> <span data-ttu-id="36ac6-117">Il en va de même pour les types (par opposition aux objets <xref:System.Type?displayProperty=nameWithType>), aux noms de groupes de méthodes (par opposition aux méthodes spécifiques) et aux accesseurs d’événements [add](../../language-reference/keywords/add.md) et [remove](../../language-reference/keywords/remove.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-117">The same is true for types (as distinct from <xref:System.Type?displayProperty=nameWithType> objects), method group names (as distinct from specific methods), and event [add](../../language-reference/keywords/add.md) and [remove](../../language-reference/keywords/remove.md) accessors.</span></span>  
  
 <span data-ttu-id="36ac6-118">Chaque valeur possède un type associé.</span><span class="sxs-lookup"><span data-stu-id="36ac6-118">Every value has an associated type.</span></span> <span data-ttu-id="36ac6-119">Par exemple, si x et y sont toutes deux des variables de type `int`, la valeur de l’expression `x + y` est également de type `int`.</span><span class="sxs-lookup"><span data-stu-id="36ac6-119">For example, if x and y are both variables of type `int`, the value of the expression `x + y` is also typed as `int`.</span></span> <span data-ttu-id="36ac6-120">Si la valeur est assignée à une variable d’un type différent, ou si x et y sont des types différents, les règles de conversion de type sont appliquées.</span><span class="sxs-lookup"><span data-stu-id="36ac6-120">If the value is assigned to a variable of a different type, or if x and y are different types, the rules of type conversion are applied.</span></span> <span data-ttu-id="36ac6-121">Pour plus d’informations sur le fonctionnement de ces conversions, consultez [Cast et conversions de types](../types/casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-121">For more information about how such conversions work, see [Casting and Type Conversions](../types/casting-and-type-conversions.md).</span></span>  
  
## <a name="overflows"></a><span data-ttu-id="36ac6-122">Dépassement de capacité</span><span class="sxs-lookup"><span data-stu-id="36ac6-122">Overflows</span></span>

 <span data-ttu-id="36ac6-123">Les expressions numériques peuvent provoquer des dépassements de capacité si la valeur est supérieure à la valeur maximale du type de la valeur.</span><span class="sxs-lookup"><span data-stu-id="36ac6-123">Numeric expressions may cause overflows if the value is larger than the maximum value of the value's type.</span></span> <span data-ttu-id="36ac6-124">Pour plus d’informations, consultez [case à cocher activée et désactivée](../../language-reference/keywords/checked-and-unchecked.md) et la section [conversions numériques explicites](../../language-reference/builtin-types/numeric-conversions.md#explicit-numeric-conversions) de l’article [conversions numériques intégrées](../../language-reference/builtin-types/numeric-conversions.md) .</span><span class="sxs-lookup"><span data-stu-id="36ac6-124">For more information, see [Checked and Unchecked](../../language-reference/keywords/checked-and-unchecked.md) and the [Explicit numeric conversions](../../language-reference/builtin-types/numeric-conversions.md#explicit-numeric-conversions) section of the [Built-in numeric conversions](../../language-reference/builtin-types/numeric-conversions.md) article.</span></span>
  
## <a name="operator-precedence-and-associativity"></a><span data-ttu-id="36ac6-125">Priorité des opérateurs et associativité</span><span class="sxs-lookup"><span data-stu-id="36ac6-125">Operator precedence and associativity</span></span>

 <span data-ttu-id="36ac6-126">Le mode d’évaluation de l’expression est régi par les règles de priorité des opérateurs et d’associativité.</span><span class="sxs-lookup"><span data-stu-id="36ac6-126">The manner in which an expression is evaluated is governed by the rules of associativity and operator precedence.</span></span> <span data-ttu-id="36ac6-127">Pour plus d’informations, consultez [Opérateurs](../../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-127">For more information, see [Operators](../../language-reference/operators/index.md).</span></span>  
  
 <span data-ttu-id="36ac6-128">La plupart des expressions, sauf les expressions d’assignation et les expressions d’appel de méthode, doivent être incorporées dans une instruction.</span><span class="sxs-lookup"><span data-stu-id="36ac6-128">Most expressions, except assignment expressions and method invocation expressions, must be embedded in a statement.</span></span> <span data-ttu-id="36ac6-129">Pour plus d’informations, consultez [Instructions](./statements.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-129">For more information, see [Statements](./statements.md).</span></span>  
  
## <a name="literals-and-simple-names"></a><span data-ttu-id="36ac6-130">Littéraux et noms simples</span><span class="sxs-lookup"><span data-stu-id="36ac6-130">Literals and simple names</span></span>

 <span data-ttu-id="36ac6-131">Les deux types d’expressions les plus simples sont les littéraux et les noms simples.</span><span class="sxs-lookup"><span data-stu-id="36ac6-131">The two simplest types of expressions are literals and simple names.</span></span> <span data-ttu-id="36ac6-132">Un littéral est une valeur constante qui n’a aucun nom.</span><span class="sxs-lookup"><span data-stu-id="36ac6-132">A literal is a constant value that has no name.</span></span> <span data-ttu-id="36ac6-133">Par exemple, dans l’exemple de code suivant, `5` et `"Hello World"` sont des valeurs littérales :</span><span class="sxs-lookup"><span data-stu-id="36ac6-133">For example, in the following code example, both `5` and `"Hello World"` are literal values:</span></span>  
  
 [!code-csharp[csProgGuideStatements#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#2)]  
  
 <span data-ttu-id="36ac6-134">Pour plus d’informations sur les littéraux, consultez [Types](/dotnet/csharp/language-reference/keywords).</span><span class="sxs-lookup"><span data-stu-id="36ac6-134">For more information on literals, see [Types](/dotnet/csharp/language-reference/keywords).</span></span>  
  
 <span data-ttu-id="36ac6-135">Dans l’exemple précédent, `i` et `s` sont des noms simples qui identifient des variables locales.</span><span class="sxs-lookup"><span data-stu-id="36ac6-135">In the preceding example, both `i` and `s` are simple names that identify local variables.</span></span> <span data-ttu-id="36ac6-136">Quand ces variables sont utilisées dans une expression, le nom de la variable prend la valeur qui est stockée actuellement à l’emplacement de la variable en mémoire.</span><span class="sxs-lookup"><span data-stu-id="36ac6-136">When those variables are used in an expression, the variable name evaluates to the value that is currently stored in the variable's location in memory.</span></span> <span data-ttu-id="36ac6-137">Ceci est illustré dans l'exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="36ac6-137">This is shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#3)]

## <a name="invocation-expressions"></a><span data-ttu-id="36ac6-138">Appel d’expressions</span><span class="sxs-lookup"><span data-stu-id="36ac6-138">Invocation expressions</span></span>

 <span data-ttu-id="36ac6-139">Dans l’exemple de code suivant, l’appel à `DoWork` est une expression d’appel.</span><span class="sxs-lookup"><span data-stu-id="36ac6-139">In the following code example, the call to `DoWork` is an invocation expression.</span></span>  
  
```csharp
DoWork();  
```  
  
 <span data-ttu-id="36ac6-140">Un appel de méthode nécessite le nom de la méthode, soit comme nom (comme dans l’exemple précédent), soit comme le résultat d’une autre expression, suivi de parenthèses et des éventuels paramètres de méthode.</span><span class="sxs-lookup"><span data-stu-id="36ac6-140">A method invocation requires the name of the method, either as a name as in the previous example, or as the result of another expression, followed by parenthesis and any method parameters.</span></span> <span data-ttu-id="36ac6-141">Pour plus d’informations, consultez [Méthodes](../classes-and-structs/methods.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-141">For more information, see [Methods](../classes-and-structs/methods.md).</span></span> <span data-ttu-id="36ac6-142">Un appel de délégué utilise le nom d’un délégué et des paramètres de méthode entre parenthèses.</span><span class="sxs-lookup"><span data-stu-id="36ac6-142">A delegate invocation uses the name of a delegate and method parameters in parenthesis.</span></span> <span data-ttu-id="36ac6-143">Pour plus d'informations, consultez [Délégués](../delegates/index.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-143">For more information, see [Delegates](../delegates/index.md).</span></span> <span data-ttu-id="36ac6-144">Les appels de méthode et les appels de délégué sont évalués à la valeur de retour de la méthode, si celle-ci retourne une valeur.</span><span class="sxs-lookup"><span data-stu-id="36ac6-144">Method invocations and delegate invocations evaluate to the return value of the method, if the method returns a value.</span></span> <span data-ttu-id="36ac6-145">Les méthodes qui retournent void ne peuvent pas être utilisées à la place d’une valeur dans une expression.</span><span class="sxs-lookup"><span data-stu-id="36ac6-145">Methods that return void cannot be used in place of a value in an expression.</span></span>  

## <a name="query-expressions"></a><span data-ttu-id="36ac6-146">Expressions de requête</span><span class="sxs-lookup"><span data-stu-id="36ac6-146">Query expressions</span></span>

 <span data-ttu-id="36ac6-147">Les mêmes règles relatives aux expressions s’appliquent en général aux expressions de requête.</span><span class="sxs-lookup"><span data-stu-id="36ac6-147">The same rules for expressions in general apply to query expressions.</span></span> <span data-ttu-id="36ac6-148">Pour plus d’informations, consultez [LINQ](../../linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-148">For more information, see [LINQ](../../linq/index.md).</span></span>  
  
## <a name="lambda-expressions"></a><span data-ttu-id="36ac6-149">Expressions lambda</span><span class="sxs-lookup"><span data-stu-id="36ac6-149">Lambda expressions</span></span>

 <span data-ttu-id="36ac6-150">Les expressions lambda représentent des « méthodes inline » qui n’ont aucun nom mais qui peuvent avoir des paramètres d’entrée et plusieurs instructions.</span><span class="sxs-lookup"><span data-stu-id="36ac6-150">Lambda expressions represent "inline methods" that have no name but can have input parameters and multiple statements.</span></span> <span data-ttu-id="36ac6-151">Elles sont largement utilisées dans LINQ pour passer des arguments aux méthodes.</span><span class="sxs-lookup"><span data-stu-id="36ac6-151">They are used extensively in LINQ to pass arguments to methods.</span></span> <span data-ttu-id="36ac6-152">Les expressions lambda sont compilées en délégués ou en arborescences de l’expression en fonction du contexte dans lequel elles sont utilisées.</span><span class="sxs-lookup"><span data-stu-id="36ac6-152">Lambda expressions are compiled to either delegates or expression trees depending on the context in which they are used.</span></span> <span data-ttu-id="36ac6-153">Pour plus d’informations, consultez [expressions lambda](lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-153">For more information, see [Lambda Expressions](lambda-expressions.md).</span></span>  
  
## <a name="expression-trees"></a><span data-ttu-id="36ac6-154">Arborescences de l’expression</span><span class="sxs-lookup"><span data-stu-id="36ac6-154">Expression trees</span></span>

<span data-ttu-id="36ac6-155">Les arborescences de l’expression permettent de représenter des expressions en tant que structures de données.</span><span class="sxs-lookup"><span data-stu-id="36ac6-155">Expression trees enable expressions to be represented as data structures.</span></span> <span data-ttu-id="36ac6-156">Elles sont largement utilisées par les fournisseurs LINQ pour traduire des expressions de requête en code explicite dans un autre contexte, comme une base de données SQL.</span><span class="sxs-lookup"><span data-stu-id="36ac6-156">They are used extensively by LINQ providers to translate query expressions into code that is meaningful in some other context, such as a SQL database.</span></span> <span data-ttu-id="36ac6-157">Pour plus d’informations, consultez [Arborescences d’expressions (C#)](../concepts/expression-trees/index.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-157">For more information, see [Expression Trees (C#)](../concepts/expression-trees/index.md).</span></span>
  
## <a name="expression-body-definitions"></a><span data-ttu-id="36ac6-158">Définitions de corps d’expression</span><span class="sxs-lookup"><span data-stu-id="36ac6-158">Expression body definitions</span></span>

<span data-ttu-id="36ac6-159">C# prend en charge les *membres expression-bodied*, qui vous permettent de fournir une définition de corps d’expression concise pour des méthodes, des constructeurs, des finaliseurs, des propriétés et des indexeurs.</span><span class="sxs-lookup"><span data-stu-id="36ac6-159">C# supports *expression-bodied members*, which allow you to supply a concise expression body definition for methods, constructors, finalizers, properties, and indexers.</span></span> <span data-ttu-id="36ac6-160">Pour plus d’informations, consultez [Membres expression-bodied](expression-bodied-members.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-160">For more information, see [Expression-bodied members](expression-bodied-members.md).</span></span>

## <a name="remarks"></a><span data-ttu-id="36ac6-161">Notes</span><span class="sxs-lookup"><span data-stu-id="36ac6-161">Remarks</span></span>

 <span data-ttu-id="36ac6-162">Chaque fois qu’un accès à un indexeur d’objet, une variable ou une propriété d’objet est identifié à partir d’une expression, la valeur de cet élément est utilisée comme valeur de l’expression.</span><span class="sxs-lookup"><span data-stu-id="36ac6-162">Whenever a variable, object property, or object indexer access is identified from an expression, the value of that item is used as the value of the expression.</span></span> <span data-ttu-id="36ac6-163">Une expression peut être placée n’importe où en C# où une valeur ou un objet est obligatoire, tant que l’expression correspond finalement au type obligatoire.</span><span class="sxs-lookup"><span data-stu-id="36ac6-163">An expression can be placed anywhere in C# where a value or object is required, as long as the expression ultimately evaluates to the required type.</span></span>  

## <a name="c-language-specification"></a><span data-ttu-id="36ac6-164">spécification du langage C#</span><span class="sxs-lookup"><span data-stu-id="36ac6-164">C# language specification</span></span>

<span data-ttu-id="36ac6-165">Pour plus d’informations, consultez la section [Expressions](~/_csharplang/spec/expressions.md) de la [Spécification du langage C#](~/_csharplang/spec/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="36ac6-165">For more information, see the [Expressions](~/_csharplang/spec/expressions.md) section of the [C# language specification](~/_csharplang/spec/introduction.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="36ac6-166">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="36ac6-166">See also</span></span>

- [<span data-ttu-id="36ac6-167">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="36ac6-167">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="36ac6-168">Opérateurs</span><span class="sxs-lookup"><span data-stu-id="36ac6-168">Operators</span></span>](../../language-reference/operators/index.md)
- [<span data-ttu-id="36ac6-169">Méthodes</span><span class="sxs-lookup"><span data-stu-id="36ac6-169">Methods</span></span>](../classes-and-structs/methods.md)
- [<span data-ttu-id="36ac6-170">Délégués</span><span class="sxs-lookup"><span data-stu-id="36ac6-170">Delegates</span></span>](../delegates/index.md)
- [<span data-ttu-id="36ac6-171">Types</span><span class="sxs-lookup"><span data-stu-id="36ac6-171">Types</span></span>](../types/index.md)
- [<span data-ttu-id="36ac6-172">LINQ</span><span class="sxs-lookup"><span data-stu-id="36ac6-172">LINQ</span></span>](../../linq/index.md)
