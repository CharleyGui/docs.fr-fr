---
title: Éléments ignorés - Guide C#
description: Décrit la prise en charge par C# des éléments ignorés, qui sont des variables qui peuvent être ignorées, et les différentes façons dont les éléments ignorés peuvent être utilisés.
ms.technology: csharp-fundamentals
ms.date: 09/22/2020
ms.openlocfilehash: 4de48aebaeb896b198b2e9f2431c6a38ba11469e
ms.sourcegitcommit: d2db216e46323f73b32ae312c9e4135258e5d68e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/22/2020
ms.locfileid: "90869326"
---
# <a name="discards---c-guide"></a><span data-ttu-id="80e65-103">Éléments ignorés - Guide C#</span><span class="sxs-lookup"><span data-stu-id="80e65-103">Discards - C# Guide</span></span>

<span data-ttu-id="80e65-104">À compter de C# 7.0, les éléments ignorés sont pris en charge. Il s’agit de variables temporaires factices, qui sont inutilisées de façon intentionnelle dans le code d’une application.</span><span class="sxs-lookup"><span data-stu-id="80e65-104">Starting with C# 7.0, C# supports discards, which are temporary, dummy variables that are intentionally unused in application code.</span></span> <span data-ttu-id="80e65-105">Les éléments ignorés sont équivalents à des variables non affectées : elles n’ont pas de valeur.</span><span class="sxs-lookup"><span data-stu-id="80e65-105">Discards are equivalent to unassigned variables; they do not have a value.</span></span> <span data-ttu-id="80e65-106">Comme il n’existe qu’une seule variable d’élément ignoré et qu’un stockage ne peut même pas lui être alloué, les éléments ignorés peuvent réduire les allocations de mémoire.</span><span class="sxs-lookup"><span data-stu-id="80e65-106">Because there is only a single discard variable, and that variable may not even be allocated storage, discards can reduce memory allocations.</span></span> <span data-ttu-id="80e65-107">Dans la mesure où elles éclairent l’intention de votre code, elles améliorent sa lisibilité et sa maintenabilité.</span><span class="sxs-lookup"><span data-stu-id="80e65-107">Because they make the intent of your code clear, they enhance its readability and maintainability.</span></span>

<span data-ttu-id="80e65-108">Vous indiquez qu’une variable est un élément ignoré en lui affectant comme nom le trait de soulignement (`_`).</span><span class="sxs-lookup"><span data-stu-id="80e65-108">You indicate that a variable is a discard by assigning it the underscore (`_`) as its name.</span></span> <span data-ttu-id="80e65-109">Par exemple, l’appel de méthode suivant retourne un tuple de 3 éléments dans lequel les première et deuxième valeurs sont ignorées et dans lequel *area* est une variable précédemment déclarée à laquelle vous devez affecter le troisième composant correspondant retourné par *GetCityInformation* :</span><span class="sxs-lookup"><span data-stu-id="80e65-109">For example, the following method call returns a 3-tuple in which the first and second values are discards and *area* is a previously declared variable to be set to the corresponding third component returned by *GetCityInformation*:</span></span>

```csharp
(_, _, area) = city.GetCityInformation(cityName);
```

<span data-ttu-id="80e65-110">Dans C# 7,0 et versions ultérieures, les éléments ignorés sont pris en charge dans les affectations dans les contextes suivants :</span><span class="sxs-lookup"><span data-stu-id="80e65-110">In C# 7.0 and later, discards are supported in assignments in the following contexts:</span></span>

- <span data-ttu-id="80e65-111">Déconstruction d' [deconstruction](deconstruct.md)un tuple et d’un objet.</span><span class="sxs-lookup"><span data-stu-id="80e65-111">Tuple and object [deconstruction](deconstruct.md).</span></span>
- <span data-ttu-id="80e65-112">Critères spéciaux avec [is](language-reference/keywords/is.md) et [switch](language-reference/keywords/switch.md).</span><span class="sxs-lookup"><span data-stu-id="80e65-112">Pattern matching with [is](language-reference/keywords/is.md) and [switch](language-reference/keywords/switch.md).</span></span>
- <span data-ttu-id="80e65-113">Appels à des méthodes avec des paramètres `out`.</span><span class="sxs-lookup"><span data-stu-id="80e65-113">Calls to methods with `out` parameters.</span></span>
- <span data-ttu-id="80e65-114">Un `_` autonome quand aucun `_` n’est dans l’étendue.</span><span class="sxs-lookup"><span data-stu-id="80e65-114">A standalone `_` when no `_` is in scope.</span></span>

<span data-ttu-id="80e65-115">À compter de C# 9,0, vous pouvez utiliser des éléments ignorés pour spécifier les paramètres d’entrée inutilisés d’une expression lambda.</span><span class="sxs-lookup"><span data-stu-id="80e65-115">Beginning with C# 9.0, you can use discards to specify unused input parameters of a lambda expression.</span></span> <span data-ttu-id="80e65-116">Pour plus d’informations, consultez la section [paramètres d’entrée d’une expression lambda](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) de l’article [expressions lambda](language-reference/operators/lambda-expressions.md) .</span><span class="sxs-lookup"><span data-stu-id="80e65-116">For more information, see the [Input parameters of a lambda expression](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="80e65-117">Quand `_` est un élément ignoré valide, une tentative de récupérer sa valeur ou de l’utiliser dans une opération d’affectation génère l’erreur de compilateur CS0301, « Le nom '\_' n’existe pas dans le contexte actuel ».</span><span class="sxs-lookup"><span data-stu-id="80e65-117">When `_` is a valid discard, attempting to retrieve its value or use it in an assignment operation generates compiler error CS0301, "The name '\_' does not exist in the current context".</span></span> <span data-ttu-id="80e65-118">La raison en est qu’aucune valeur n’est affectée à `_` et qu’il n’est même pas possible de lui affecter un emplacement de stockage.</span><span class="sxs-lookup"><span data-stu-id="80e65-118">This is because `_` is not assigned a value, and may not even be assigned a storage location.</span></span> <span data-ttu-id="80e65-119">S’il s’agissait d’une variable réelle, vous ne pourriez pas ignorer plus d’une valeur, comme l’a fait l’exemple précédent.</span><span class="sxs-lookup"><span data-stu-id="80e65-119">If it were an actual variable, you could not discard more than one value, as the previous example did.</span></span>

## <a name="tuple-and-object-deconstruction"></a><span data-ttu-id="80e65-120">Déconstruction de tuple et d’objet</span><span class="sxs-lookup"><span data-stu-id="80e65-120">Tuple and object deconstruction</span></span>

<span data-ttu-id="80e65-121">Les éléments ignorés sont particulièrement utiles pour travailler avec des tuples quand le code de votre application utilise certains éléments d’un tuple mais ignore les autres.</span><span class="sxs-lookup"><span data-stu-id="80e65-121">Discards are particularly useful in working with tuples when your application code uses some tuple elements but ignores others.</span></span> <span data-ttu-id="80e65-122">Par exemple, la méthode `QueryCityDataForYears` suivante retourne un tuple de 6 éléments avec le nom d’une ville, sa région, une année, la population de la ville pour cette année, une seconde année et la population de la ville pour cette seconde année.</span><span class="sxs-lookup"><span data-stu-id="80e65-122">For example, the following `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="80e65-123">L’exemple montre la différence de population entre ces deux années.</span><span class="sxs-lookup"><span data-stu-id="80e65-123">The example shows the change in population between those two years.</span></span> <span data-ttu-id="80e65-124">Parmi les données disponibles dans le tuple, nous ne sommes pas intéressés par la région de la ville, et nous connaissons le nom de la ville et les deux dates au moment du design.</span><span class="sxs-lookup"><span data-stu-id="80e65-124">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="80e65-125">Par conséquent, nous sommes intéressés seulement par les deux valeurs de la population stockées dans le tuple et nous pouvons gérer ses valeurs restantes comme éléments ignorés.</span><span class="sxs-lookup"><span data-stu-id="80e65-125">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

<span data-ttu-id="80e65-126">Pour plus d’informations sur la déconstruction de tuples avec des éléments ignorés, consultez [Déconstruction de tuples et d’autres types](deconstruct.md#deconstructing-tuple-elements-with-discards).</span><span class="sxs-lookup"><span data-stu-id="80e65-126">For more information on deconstructing tuples with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-tuple-elements-with-discards).</span></span>

<span data-ttu-id="80e65-127">La méthode `Deconstruct` d’une classe, d’un struct ou d’une interface vous permet aussi de récupérer et de déconstruire un ensemble spécifique de données d’un objet.</span><span class="sxs-lookup"><span data-stu-id="80e65-127">The `Deconstruct` method of a class, structure, or interface also allows you to retrieve and deconstruct a specific set of data from an object.</span></span> <span data-ttu-id="80e65-128">Vous pouvez utiliser des éléments ignorés quand vous êtes intéressé seulement par un sous-ensemble des valeurs déconstruites.</span><span class="sxs-lookup"><span data-stu-id="80e65-128">You can use discards when you are interested in working with only a subset of the deconstructed values.</span></span> <span data-ttu-id="80e65-129">L’exemple suivant déconstruit un objet `Person` en quatre chaînes (le prénom, le nom, la ville et l’État), mais ignore le nom et l’État.</span><span class="sxs-lookup"><span data-stu-id="80e65-129">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state), but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs)]

<span data-ttu-id="80e65-130">Pour plus d’informations sur la déconstruction de types définis par l’utilisateur avec des éléments ignorés, consultez [Déconstruction de tuples et d’autres types](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span><span class="sxs-lookup"><span data-stu-id="80e65-130">For more information on deconstructing user-defined types with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span></span>

## <a name="pattern-matching-with-switch-and-is"></a><span data-ttu-id="80e65-131">Critères spéciaux avec `switch` et `is`</span><span class="sxs-lookup"><span data-stu-id="80e65-131">Pattern matching with `switch` and `is`</span></span>

<span data-ttu-id="80e65-132">Le *modèle d’élément ignoré* peut être utilisé dans des critères spéciaux avec les mots clés [is](language-reference/keywords/is.md) et [switch](language-reference/keywords/switch.md).</span><span class="sxs-lookup"><span data-stu-id="80e65-132">The *discard pattern* can be used in pattern matching with the [is](language-reference/keywords/is.md) and [switch](language-reference/keywords/switch.md) keywords.</span></span> <span data-ttu-id="80e65-133">Chaque expression correspond toujours au modèle d’élément ignoré.</span><span class="sxs-lookup"><span data-stu-id="80e65-133">Every expression always matches the discard pattern.</span></span>

<span data-ttu-id="80e65-134">L’exemple suivant définit une méthode `ProvidesFormatInfo` qui utilise des instructions [is](language-reference/keywords/is.md) pour déterminer si un objet fournit une implémentation de <xref:System.IFormatProvider> et teste si l’objet est `null`.</span><span class="sxs-lookup"><span data-stu-id="80e65-134">The following example defines a `ProvidesFormatInfo` method that uses [is](language-reference/keywords/is.md) statements to determine whether an object provides an <xref:System.IFormatProvider> implementation and tests whether the object is `null`.</span></span> <span data-ttu-id="80e65-135">Il utilise également le modèle d’élément ignoré pour gérer les objets non null de n’importe quel autre type.</span><span class="sxs-lookup"><span data-stu-id="80e65-135">It also uses the discard pattern to handle non-null objects of any other type.</span></span>

[!code-csharp[discard-pattern](../../samples/snippets/csharp/programming-guide/discards/discard-pattern2.cs)]

## <a name="calls-to-methods-with-out-parameters"></a><span data-ttu-id="80e65-136">Appels à des méthodes avec des paramètres out</span><span class="sxs-lookup"><span data-stu-id="80e65-136">Calls to methods with out parameters</span></span>

<span data-ttu-id="80e65-137">Quand vous appelez la méthode `Deconstruct` pour déconstruire un type défini par l’utilisateur (une instance d’une classe, d’une structure ou d’une interface), vous pouvez ignorer les valeurs d’arguments `out` individuels.</span><span class="sxs-lookup"><span data-stu-id="80e65-137">When calling the `Deconstruct` method to deconstruct a user-defined type (an instance of a class, structure, or interface), you can discard the values of individual `out` arguments.</span></span> <span data-ttu-id="80e65-138">Vous pouvez cependant aussi ignorer la valeur d’arguments `out` lors de l’appel de n’importe quelle méthode avec un paramètre out.</span><span class="sxs-lookup"><span data-stu-id="80e65-138">But you can also discard the value of `out` arguments when calling any method with an out parameter.</span></span>

<span data-ttu-id="80e65-139">L’exemple suivant appelle la méthode [DateTime.TryParse (String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) pour déterminer si la représentation sous forme de chaîne d’une date est valide dans la culture actuelle.</span><span class="sxs-lookup"><span data-stu-id="80e65-139">The following example calls the [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) method to determine whether the string representation of a date is valid in the current culture.</span></span> <span data-ttu-id="80e65-140">Comme l’exemple concerne ici uniquement la validation de la chaîne de date et pas son analyse pour extraire la date, l’argument `out` de la méthode est un élément ignoré.</span><span class="sxs-lookup"><span data-stu-id="80e65-140">Because the example is concerned only with validating the date string and not with parsing it to extract the date, the `out` argument to the method is a discard.</span></span>

[!code-csharp[discard-with-out](../../samples/snippets/csharp/programming-guide/discards/discard-out1.cs)]

## <a name="a-standalone-discard"></a><span data-ttu-id="80e65-141">Élément ignoré autonome</span><span class="sxs-lookup"><span data-stu-id="80e65-141">A standalone discard</span></span>

<span data-ttu-id="80e65-142">Vous pouvez utiliser un élément ignoré autonome pour indiquer une variable que vous choisissez d’ignorer.</span><span class="sxs-lookup"><span data-stu-id="80e65-142">You can use a standalone discard to indicate any variable that you choose to ignore.</span></span> <span data-ttu-id="80e65-143">L’exemple suivant utilise un élément ignoré autonome pour ignorer l’objet <xref:System.Threading.Tasks.Task> retourné par une opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="80e65-143">The following example uses a standalone discard to ignore the <xref:System.Threading.Tasks.Task> object returned by an asynchronous operation.</span></span> <span data-ttu-id="80e65-144">Ceci a pour effet de supprimer l’exception levée par l’opération au moment où elle se termine.</span><span class="sxs-lookup"><span data-stu-id="80e65-144">This has the effect of suppressing the exception that the operation throws as it is about to complete.</span></span>

[!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard1.cs)]

<span data-ttu-id="80e65-145">Notez que `_` est aussi un identificateur valide.</span><span class="sxs-lookup"><span data-stu-id="80e65-145">Note that `_` is also a valid identifier.</span></span> <span data-ttu-id="80e65-146">Quand il est utilisé en dehors d’un contexte pris en charge, `_` est traité non pas comme élément ignoré, mais comme variable valide.</span><span class="sxs-lookup"><span data-stu-id="80e65-146">When used outside of a supported context, `_` is treated not as a discard but as a valid variable.</span></span> <span data-ttu-id="80e65-147">Si un identificateur nommé `_` est déjà dans l’étendue, l’utilisation de `_` comme élément ignoré autonome peut provoquer :</span><span class="sxs-lookup"><span data-stu-id="80e65-147">If an identifier named `_` is already in scope, the use of `_` as a standalone discard can result in:</span></span>

- <span data-ttu-id="80e65-148">Une modification accidentelle de la valeur de la variable `_` dans l’étendue en lui affectant la valeur de l’élément ignoré prévu.</span><span class="sxs-lookup"><span data-stu-id="80e65-148">Accidental modification of the value of the in-scope `_` variable by assigning it the value of the intended discard.</span></span> <span data-ttu-id="80e65-149">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="80e65-149">For example:</span></span>

   [!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard2.cs#1)]

- <span data-ttu-id="80e65-150">Une erreur de compilateur pour violation de sécurité du type.</span><span class="sxs-lookup"><span data-stu-id="80e65-150">A compiler error for violating type safety.</span></span> <span data-ttu-id="80e65-151">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="80e65-151">For example:</span></span>

   [!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard2.cs#2)]

- <span data-ttu-id="80e65-152">Erreur du compilateur CS0136 : « Impossible de déclarer une variable locale ou un paramètre nommé ‘\_’ dans cette portée, car ce nom est utilisé dans une portée locale englobante pour définir une variable locale ou un paramètre. »</span><span class="sxs-lookup"><span data-stu-id="80e65-152">Compiler error CS0136, "A local or parameter named '\_' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter."</span></span> <span data-ttu-id="80e65-153">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="80e65-153">For example:</span></span>

   [!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard2.cs#3)]

## <a name="see-also"></a><span data-ttu-id="80e65-154">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="80e65-154">See also</span></span>

- [<span data-ttu-id="80e65-155">Déconstruction de tuples et d’autres types</span><span class="sxs-lookup"><span data-stu-id="80e65-155">Deconstructing tuples and other types</span></span>](deconstruct.md)
- [<span data-ttu-id="80e65-156">`is` mot</span><span class="sxs-lookup"><span data-stu-id="80e65-156">`is` keyword</span></span>](language-reference/keywords/is.md)
- [<span data-ttu-id="80e65-157">`switch` mot</span><span class="sxs-lookup"><span data-stu-id="80e65-157">`switch` keyword</span></span>](language-reference/keywords/switch.md)
