---
title: Nouveautés de C# 9,0-Guide C#
description: Profitez d’une vue d’ensemble des nouvelles fonctionnalités disponibles dans C# 9,0.
ms.date: 09/04/2020
ms.openlocfilehash: c165ca764d93b74aac21028ed3e55e80f2a23ee0
ms.sourcegitcommit: 4d45bda8cd9558ea8af4be591e3d5a29360c1ece
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/02/2020
ms.locfileid: "91654905"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="40910-103">Nouveautés dans C# 9.0</span><span class="sxs-lookup"><span data-stu-id="40910-103">What's new in C# 9.0</span></span>

<span data-ttu-id="40910-104">C# 9,0 ajoute les fonctionnalités et améliorations suivantes au langage C# :</span><span class="sxs-lookup"><span data-stu-id="40910-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="40910-105">Enregistrements</span><span class="sxs-lookup"><span data-stu-id="40910-105">Records</span></span>](#record-types)
- [<span data-ttu-id="40910-106">Setter init uniquement</span><span class="sxs-lookup"><span data-stu-id="40910-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="40910-107">Instructions de niveau supérieur</span><span class="sxs-lookup"><span data-stu-id="40910-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="40910-108">Améliorations des critères spéciaux</span><span class="sxs-lookup"><span data-stu-id="40910-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="40910-109">Entiers dimensionnés natifs</span><span class="sxs-lookup"><span data-stu-id="40910-109">Native sized integers</span></span>
- <span data-ttu-id="40910-110">Pointeurs fonction</span><span class="sxs-lookup"><span data-stu-id="40910-110">Function pointers</span></span>
- <span data-ttu-id="40910-111">Supprimer l’émission de l’indicateur localsinit</span><span class="sxs-lookup"><span data-stu-id="40910-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="40910-112">Nouvelles expressions typées cibles</span><span class="sxs-lookup"><span data-stu-id="40910-112">Target-typed new expressions</span></span>
- <span data-ttu-id="40910-113">fonctions anonymes statiques</span><span class="sxs-lookup"><span data-stu-id="40910-113">static anonymous functions</span></span>
- <span data-ttu-id="40910-114">Expressions conditionnelles typées cible</span><span class="sxs-lookup"><span data-stu-id="40910-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="40910-115">Types de retour covariant</span><span class="sxs-lookup"><span data-stu-id="40910-115">Covariant return types</span></span>
- <span data-ttu-id="40910-116">`GetEnumerator`Prise en charge des extensions pour les `foreach` boucles</span><span class="sxs-lookup"><span data-stu-id="40910-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="40910-117">Paramètres d’abandon lambda</span><span class="sxs-lookup"><span data-stu-id="40910-117">Lambda discard parameters</span></span>
- <span data-ttu-id="40910-118">Attributs sur des fonctions locales</span><span class="sxs-lookup"><span data-stu-id="40910-118">Attributes on local functions</span></span>
- <span data-ttu-id="40910-119">Initialiseurs de module</span><span class="sxs-lookup"><span data-stu-id="40910-119">Module initializers</span></span>
- <span data-ttu-id="40910-120">Nouvelles fonctionnalités pour les méthodes partielles</span><span class="sxs-lookup"><span data-stu-id="40910-120">New features for partial methods</span></span>

<span data-ttu-id="40910-121">C# 9,0 est pris en charge sur **.net 5**.</span><span class="sxs-lookup"><span data-stu-id="40910-121">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="40910-122">Pour plus d’informations, consultez contrôle de [version du langage C#](../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="40910-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

## <a name="record-types"></a><span data-ttu-id="40910-123">Types d’enregistrements</span><span class="sxs-lookup"><span data-stu-id="40910-123">Record types</span></span>

<span data-ttu-id="40910-124">C# 9,0 introduit les ***types d’enregistrements***, qui sont un type référence qui fournit des méthodes synthétisées pour fournir une sémantique de valeur pour l’égalité.</span><span class="sxs-lookup"><span data-stu-id="40910-124">C# 9.0 introduces ***record types***, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="40910-125">Les enregistrements sont immuables par défaut.</span><span class="sxs-lookup"><span data-stu-id="40910-125">Records are immutable by default.</span></span>

<span data-ttu-id="40910-126">Les types d’enregistrements facilitent la création de types référence immuables dans .NET.</span><span class="sxs-lookup"><span data-stu-id="40910-126">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="40910-127">Historiquement, les types .NET sont largement classés comme types référence (y compris les classes et les types anonymes) et les types valeur (y compris les structs et les tuples).</span><span class="sxs-lookup"><span data-stu-id="40910-127">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="40910-128">Bien que les types de valeurs immuables soient recommandés, les types valeur mutables n’introduisent pas souvent des erreurs.</span><span class="sxs-lookup"><span data-stu-id="40910-128">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="40910-129">Les variables de type valeur contiennent les valeurs afin que les modifications soient apportées à une copie des données d’origine lorsque les types valeur sont passés aux méthodes.</span><span class="sxs-lookup"><span data-stu-id="40910-129">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="40910-130">Il existe également de nombreux avantages par rapport aux types de référence immuables.</span><span class="sxs-lookup"><span data-stu-id="40910-130">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="40910-131">Ces avantages sont plus prononcés dans les programmes simultanés avec des données partagées.</span><span class="sxs-lookup"><span data-stu-id="40910-131">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="40910-132">Malheureusement, C# vous obligeait à écrire un peu de code supplémentaire pour créer des types de référence immuables.</span><span class="sxs-lookup"><span data-stu-id="40910-132">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="40910-133">Les enregistrements fournissent une déclaration de type pour un type référence immuable qui utilise une sémantique de valeur pour l’égalité.</span><span class="sxs-lookup"><span data-stu-id="40910-133">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="40910-134">Les méthodes synthétisées pour l’égalité et les codes de hachage considèrent deux enregistrements comme égaux si leurs propriétés sont toutes égales.</span><span class="sxs-lookup"><span data-stu-id="40910-134">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="40910-135">Tenez compte de cette définition :</span><span class="sxs-lookup"><span data-stu-id="40910-135">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="40910-136">La définition d’enregistrement crée un `Person` type qui contient deux propriétés ReadOnly : `FirstName` et `LastName` .</span><span class="sxs-lookup"><span data-stu-id="40910-136">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="40910-137">Le `Person` type est un type référence.</span><span class="sxs-lookup"><span data-stu-id="40910-137">The `Person` type is a reference type.</span></span> <span data-ttu-id="40910-138">Si vous avez regardé le langage intermédiaire, il s’agit d’une classe.</span><span class="sxs-lookup"><span data-stu-id="40910-138">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="40910-139">Elle est immuable dans la mesure où aucune des propriétés ne peut être modifiée une fois qu’elle a été créée.</span><span class="sxs-lookup"><span data-stu-id="40910-139">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="40910-140">Lorsque vous définissez un type d’enregistrement, le compilateur synthétise plusieurs autres méthodes pour vous :</span><span class="sxs-lookup"><span data-stu-id="40910-140">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="40910-141">Méthodes pour les comparaisons d’égalité basées sur des valeurs</span><span class="sxs-lookup"><span data-stu-id="40910-141">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="40910-142">Remplacer pour <xref:System.Object.GetHashCode></span><span class="sxs-lookup"><span data-stu-id="40910-142">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="40910-143">Copier et cloner des membres</span><span class="sxs-lookup"><span data-stu-id="40910-143">Copy and Clone members</span></span>
- <span data-ttu-id="40910-144">`PrintMembers` et <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="40910-144">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="40910-145">Les enregistrements prennent en charge l’héritage.</span><span class="sxs-lookup"><span data-stu-id="40910-145">Records support inheritance.</span></span> <span data-ttu-id="40910-146">Vous pouvez déclarer un nouvel enregistrement dérivé de `Person` comme suit :</span><span class="sxs-lookup"><span data-stu-id="40910-146">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="40910-147">Vous pouvez également sceller les enregistrements pour éviter toute dérivation supplémentaire :</span><span class="sxs-lookup"><span data-stu-id="40910-147">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="40910-148">Le compilateur synthétise différentes versions des méthodes ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="40910-148">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="40910-149">Les signatures de méthode dépendent de si le type d’enregistrement est sealed et si la classe de base directe est Object.</span><span class="sxs-lookup"><span data-stu-id="40910-149">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="40910-150">Les enregistrements doivent avoir les fonctionnalités suivantes :</span><span class="sxs-lookup"><span data-stu-id="40910-150">Records should have the following capabilities:</span></span>

- <span data-ttu-id="40910-151">L’égalité est basée sur la valeur et comprend une vérification de la correspondance des types.</span><span class="sxs-lookup"><span data-stu-id="40910-151">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="40910-152">Par exemple, un `Student` ne peut pas être égal à un `Person` , même si les deux enregistrements partagent le même nom.</span><span class="sxs-lookup"><span data-stu-id="40910-152">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="40910-153">Une représentation sous forme de chaîne cohérente est générée pour les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="40910-153">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="40910-154">Les enregistrements prennent en charge la construction de copie.</span><span class="sxs-lookup"><span data-stu-id="40910-154">Records support copy construction.</span></span> <span data-ttu-id="40910-155">La bonne construction de copie doit inclure des hiérarchies d’héritage et des propriétés ajoutées par les développeurs.</span><span class="sxs-lookup"><span data-stu-id="40910-155">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="40910-156">Les enregistrements peuvent être copiés avec modification.</span><span class="sxs-lookup"><span data-stu-id="40910-156">Records can be copied with modification.</span></span> <span data-ttu-id="40910-157">Ces opérations de copie et de modification prennent en charge la mutation non destructrice.</span><span class="sxs-lookup"><span data-stu-id="40910-157">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="40910-158">En plus des `Equals` surcharges familières, `operator ==` et `operator !=` , le compilateur synthétise une nouvelle `EqualityContract` propriété.</span><span class="sxs-lookup"><span data-stu-id="40910-158">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="40910-159">La propriété retourne un `Type` objet qui correspond au type de l’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="40910-159">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="40910-160">Si le type de base est `object` , la propriété est `virtual` .</span><span class="sxs-lookup"><span data-stu-id="40910-160">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="40910-161">Si le type de base est un autre type d’enregistrement, la propriété est un `override` .</span><span class="sxs-lookup"><span data-stu-id="40910-161">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="40910-162">Si le type d’enregistrement est `sealed` , la propriété est `sealed` .</span><span class="sxs-lookup"><span data-stu-id="40910-162">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="40910-163">La synthèse `GetHashCode` utilise le `GetHashCode` de toutes les propriétés et les champs déclarés dans le type de base et le type d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="40910-163">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="40910-164">Ces méthodes synthétisées appliquent l’égalité basée sur les valeurs dans une hiérarchie d’héritage.</span><span class="sxs-lookup"><span data-stu-id="40910-164">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="40910-165">Cela signifie qu’un `Student` ne sera jamais considéré comme égal à un `Person` portant le même nom.</span><span class="sxs-lookup"><span data-stu-id="40910-165">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="40910-166">Les types des deux enregistrements doivent correspondre, et toutes les propriétés partagées entre les types d’enregistrements sont égales.</span><span class="sxs-lookup"><span data-stu-id="40910-166">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="40910-167">Les enregistrements ont également un constructeur synthétisé et une méthode de clonage pour créer des copies.</span><span class="sxs-lookup"><span data-stu-id="40910-167">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="40910-168">Le constructeur synthétisé a un argument du type d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="40910-168">The synthesized constructor has one argument of the record type.</span></span> <span data-ttu-id="40910-169">Il génère un nouvel enregistrement avec les mêmes valeurs pour toutes les propriétés de l’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="40910-169">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="40910-170">Ce constructeur est privé si l’enregistrement est sealed, sinon il est protégé.</span><span class="sxs-lookup"><span data-stu-id="40910-170">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="40910-171">La méthode « Clone » synthétisée prend en charge la construction de copie pour les hiérarchies d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="40910-171">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="40910-172">Le terme « clone » est placé entre guillemets, car le nom réel est généré par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="40910-172">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="40910-173">Vous ne pouvez pas créer une méthode nommée `Clone` dans un type d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="40910-173">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="40910-174">La méthode « Clone » synthétisée renvoie le type d’enregistrement copié à l’aide de la répartition virtuelle.</span><span class="sxs-lookup"><span data-stu-id="40910-174">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="40910-175">Le compilateur ajoute des modificateurs différents pour la méthode « Clone » en fonction des modificateurs d’accès sur le `record` :</span><span class="sxs-lookup"><span data-stu-id="40910-175">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="40910-176">Si le type d’enregistrement est `abstract` , la méthode « Clone » est également `abstract` .</span><span class="sxs-lookup"><span data-stu-id="40910-176">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="40910-177">Si le type de base n’est pas `object` , la méthode est également `override` .</span><span class="sxs-lookup"><span data-stu-id="40910-177">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="40910-178">Pour les types d’enregistrements qui ne sont pas `abstract` lorsque le type de base est `object` :</span><span class="sxs-lookup"><span data-stu-id="40910-178">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="40910-179">Si l’enregistrement est `sealed` , aucun modificateur supplémentaire n’est ajouté à la méthode « Clone » (ce qui signifie qu’il ne l’est pas `virtual` ).</span><span class="sxs-lookup"><span data-stu-id="40910-179">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="40910-180">Si l’enregistrement n’est pas `sealed` , la méthode « Clone » est `virtual` .</span><span class="sxs-lookup"><span data-stu-id="40910-180">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="40910-181">Pour les types d’enregistrements qui ne sont `abstract` pas lorsque le type de base n’est pas `object` :</span><span class="sxs-lookup"><span data-stu-id="40910-181">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="40910-182">Si l’enregistrement est `sealed` , la méthode « Clone » est également `sealed` .</span><span class="sxs-lookup"><span data-stu-id="40910-182">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="40910-183">Si l’enregistrement n’est pas `sealed` , la méthode « Clone » est `override` .</span><span class="sxs-lookup"><span data-stu-id="40910-183">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="40910-184">Le résultat de toutes ces règles est l’égalité est implémentée de manière cohérente dans n’importe quelle hiérarchie de types d’enregistrements.</span><span class="sxs-lookup"><span data-stu-id="40910-184">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="40910-185">Deux enregistrements sont égaux si leurs propriétés sont égales et que leurs types sont identiques, comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="40910-185">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="40910-186">Le compilateur synthétise deux méthodes qui prennent en charge la sortie imprimée : une <xref:System.Object.ToString> substitution et `PrintMembers` .</span><span class="sxs-lookup"><span data-stu-id="40910-186">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="40910-187">`PrintMembers`Prend <xref:System.Text.StringBuilder?displayProperty=nameWithType> comme argument.</span><span class="sxs-lookup"><span data-stu-id="40910-187">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="40910-188">Elle ajoute une liste séparée par des virgules de noms et de valeurs de propriété pour toutes les propriétés du type d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="40910-188">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="40910-189">`PrintMembers` appelle l’implémentation de base pour tous les enregistrements dérivés d’autres enregistrements.</span><span class="sxs-lookup"><span data-stu-id="40910-189">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="40910-190">La <xref:System.Object.ToString> substitution retourne la chaîne produite par `PrintMembers` , entourée de `{` et de `}` .</span><span class="sxs-lookup"><span data-stu-id="40910-190">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="40910-191">Par exemple, la <xref:System.Object.ToString> méthode pour `Student` retourne un `string` semblable au code suivant :</span><span class="sxs-lookup"><span data-stu-id="40910-191">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="40910-192">Les exemples indiqués jusqu’à présent utilisent la syntaxe traditionnelle pour déclarer des propriétés.</span><span class="sxs-lookup"><span data-stu-id="40910-192">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="40910-193">Il existe une forme plus concise appelée ***enregistrements positionnels***.</span><span class="sxs-lookup"><span data-stu-id="40910-193">There's a more concise form called ***positional records***.</span></span>  <span data-ttu-id="40910-194">Voici les trois types d’enregistrements définis précédemment en tant qu’enregistrements positionnels :</span><span class="sxs-lookup"><span data-stu-id="40910-194">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="40910-195">Ces déclarations créent les mêmes fonctionnalités que la version antérieure (avec quelques fonctionnalités supplémentaires décrites dans la section suivante).</span><span class="sxs-lookup"><span data-stu-id="40910-195">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="40910-196">Ces déclarations se terminent par un point-virgule au lieu de crochets, car ces enregistrements n’ajoutent pas de méthodes supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="40910-196">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="40910-197">Vous pouvez ajouter un corps et inclure également des méthodes supplémentaires :</span><span class="sxs-lookup"><span data-stu-id="40910-197">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="40910-198">Le compilateur produit une `Deconstruct` méthode pour les enregistrements positionnels.</span><span class="sxs-lookup"><span data-stu-id="40910-198">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="40910-199">La `Deconstruct` méthode a des paramètres qui correspondent aux noms de toutes les propriétés publiques dans le type d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="40910-199">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="40910-200">La `Deconstruct` méthode peut être utilisée pour déconstruire l’enregistrement dans ses propriétés de composant :</span><span class="sxs-lookup"><span data-stu-id="40910-200">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="40910-201">Enfin, les enregistrements prennent en charge ***les expressions-***.</span><span class="sxs-lookup"><span data-stu-id="40910-201">Finally, records support ***with-expressions***.</span></span> <span data-ttu-id="40910-202">Une instruction ***with-expression*** demande au compilateur de créer une copie d’un enregistrement, mais *avec* les propriétés spécifiées modifiées :</span><span class="sxs-lookup"><span data-stu-id="40910-202">A ***with-expression*** instructs the compiler to create a copy of a record, but *with* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="40910-203">La ligne ci-dessus crée un nouvel `Person` enregistrement où la `LastName` propriété est une copie de `person` , et le `FirstName` est « Paul ».</span><span class="sxs-lookup"><span data-stu-id="40910-203">The above line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is "Paul".</span></span> <span data-ttu-id="40910-204">Vous pouvez définir n’importe quel nombre de propriétés dans une expression with.</span><span class="sxs-lookup"><span data-stu-id="40910-204">You can set any number of properties in a with-expression.</span></span>  <span data-ttu-id="40910-205">Tous les membres synthétisés, à l’exception de la méthode « Clone », peuvent être écrits par vous-même.</span><span class="sxs-lookup"><span data-stu-id="40910-205">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="40910-206">Si un type d’enregistrement a une méthode qui correspond à la signature d’une méthode synthétisée, le compilateur ne synthétise pas cette méthode.</span><span class="sxs-lookup"><span data-stu-id="40910-206">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="40910-207">L' `Dog` exemple d’enregistrement précédent contient une méthode codée à la main <xref:System.String.ToString> à titre d’exemple.</span><span class="sxs-lookup"><span data-stu-id="40910-207">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="40910-208">Setter init uniquement</span><span class="sxs-lookup"><span data-stu-id="40910-208">Init only setters</span></span>

<span data-ttu-id="40910-209">Les ***accesseurs set init only*** fournissent une syntaxe cohérente pour initialiser les membres d’un objet.</span><span class="sxs-lookup"><span data-stu-id="40910-209">***Init only setters*** provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="40910-210">Les initialiseurs de propriété permettent de savoir clairement quelle valeur définit la propriété.</span><span class="sxs-lookup"><span data-stu-id="40910-210">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="40910-211">L’inconvénient est que ces propriétés doivent pouvoir être définies.</span><span class="sxs-lookup"><span data-stu-id="40910-211">The downside is that those properties must be settable.</span></span> <span data-ttu-id="40910-212">À compter de C# 9,0, vous pouvez créer des `init` accesseurs au lieu d' `set` accesseurs pour les propriétés et les indexeurs.</span><span class="sxs-lookup"><span data-stu-id="40910-212">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="40910-213">Les appelants peuvent utiliser la syntaxe de l’initialiseur de propriété pour définir ces valeurs dans les expressions de création, mais ces propriétés sont en lecture seule une fois que la construction est terminée.</span><span class="sxs-lookup"><span data-stu-id="40910-213">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="40910-214">Les Setters init uniquement fournissent une fenêtre pour modifier l’État.</span><span class="sxs-lookup"><span data-stu-id="40910-214">Init only setters provide a window to change state.</span></span> <span data-ttu-id="40910-215">Cette fenêtre se ferme à la fin de la phase de construction.</span><span class="sxs-lookup"><span data-stu-id="40910-215">That window closes when the construction phase ends.</span></span> <span data-ttu-id="40910-216">La phase de construction se termine effectivement après toute initialisation, y compris les initialiseurs de propriété et les expressions with-.</span><span class="sxs-lookup"><span data-stu-id="40910-216">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="40910-217">L’exemple précédent pour les enregistrements positionnels illustre l’utilisation d’un accesseur Set init-only pour définir une propriété à l’aide d’une expression with.</span><span class="sxs-lookup"><span data-stu-id="40910-217">The preceding example for positional records demonstrates using an init-only setter to set a property using a with expression.</span></span> <span data-ttu-id="40910-218">Vous pouvez déclarer des accesseurs set init uniquement dans n’importe quel type que vous écrivez.</span><span class="sxs-lookup"><span data-stu-id="40910-218">You can declare init only setters in any type you write.</span></span> <span data-ttu-id="40910-219">Par exemple, le struct suivant définit une structure d’observation météorologique :</span><span class="sxs-lookup"><span data-stu-id="40910-219">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="40910-220">Les appelants peuvent utiliser la syntaxe de l’initialiseur de propriété pour définir les valeurs, tout en préservant l’immuabilité :</span><span class="sxs-lookup"><span data-stu-id="40910-220">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="40910-221">Toutefois, la modification d’une observation après l’initialisation est une erreur en affectant à une propriété init-only en dehors de l’initialisation :</span><span class="sxs-lookup"><span data-stu-id="40910-221">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="40910-222">Les Setters init uniquement peuvent être utiles pour définir des propriétés de classe de base à partir de classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="40910-222">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="40910-223">Ils peuvent également définir des propriétés dérivées par le biais d’assistances dans une classe de base.</span><span class="sxs-lookup"><span data-stu-id="40910-223">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="40910-224">Les enregistrements positionnels déclarent des propriétés à l’aide des accesseurs set init only.</span><span class="sxs-lookup"><span data-stu-id="40910-224">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="40910-225">Ces accesseurs set sont utilisés dans les expressions with.</span><span class="sxs-lookup"><span data-stu-id="40910-225">Those setters are used in with-expressions.</span></span> <span data-ttu-id="40910-226">Vous pouvez déclarer des Setters init uniquement pour n’importe quel `class` ou `struct` vous définissez.</span><span class="sxs-lookup"><span data-stu-id="40910-226">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="40910-227">Instructions de niveau supérieur</span><span class="sxs-lookup"><span data-stu-id="40910-227">Top-level statements</span></span>

<span data-ttu-id="40910-228">***Les instructions de niveau supérieur*** suppriment la cérémonie inutile de nombreuses applications.</span><span class="sxs-lookup"><span data-stu-id="40910-228">***Top-level statements*** remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="40910-229">Prenons le « Hello World ! » canonique.</span><span class="sxs-lookup"><span data-stu-id="40910-229">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="40910-230">table</span><span class="sxs-lookup"><span data-stu-id="40910-230">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="40910-231">Il n’y a qu’une seule ligne de code qui fait quoi que ce soit.</span><span class="sxs-lookup"><span data-stu-id="40910-231">There’s only one line of code that does anything.</span></span> <span data-ttu-id="40910-232">Avec les instructions de niveau supérieur, vous pouvez remplacer tout ce qui est réutilisable par l' `using` instruction et la ligne unique qui effectue le travail :</span><span class="sxs-lookup"><span data-stu-id="40910-232">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="40910-233">Si vous souhaitez un programme à une seule ligne, vous pouvez supprimer la `using` directive et utiliser le nom de type complet :</span><span class="sxs-lookup"><span data-stu-id="40910-233">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="40910-234">Un seul fichier de votre application peut utiliser des instructions de niveau supérieur.</span><span class="sxs-lookup"><span data-stu-id="40910-234">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="40910-235">Si le compilateur trouve des instructions de niveau supérieur dans plusieurs fichiers sources, il s’agit d’une erreur.</span><span class="sxs-lookup"><span data-stu-id="40910-235">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="40910-236">C’est également une erreur si vous combinez des instructions de niveau supérieur avec une méthode de point d’entrée de programme déclarée, généralement une `Main` méthode.</span><span class="sxs-lookup"><span data-stu-id="40910-236">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="40910-237">Dans un sens, vous pouvez penser qu’un fichier contient les instructions qui seraient normalement dans la `Main` méthode d’une `Program` classe.</span><span class="sxs-lookup"><span data-stu-id="40910-237">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="40910-238">L’une des utilisations les plus courantes de cette fonctionnalité est la création de documents pédagogiques.</span><span class="sxs-lookup"><span data-stu-id="40910-238">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="40910-239">Les développeurs C# débutants peuvent écrire le « Hello World ! » canonique</span><span class="sxs-lookup"><span data-stu-id="40910-239">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="40910-240">dans une ou deux lignes de code.</span><span class="sxs-lookup"><span data-stu-id="40910-240">in one or two lines of code.</span></span> <span data-ttu-id="40910-241">Aucune des cérémonie supplémentaires n’est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="40910-241">None of the extra ceremony is needed.</span></span> <span data-ttu-id="40910-242">Toutefois, les développeurs chevronnés trouveront de nombreuses utilisations pour cette fonctionnalité également.</span><span class="sxs-lookup"><span data-stu-id="40910-242">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="40910-243">Les instructions de niveau supérieur permettent une expérience de type script pour les expérimentations similaires à celles fournies par les blocs-notes Jupyter.</span><span class="sxs-lookup"><span data-stu-id="40910-243">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="40910-244">Les instructions de niveau supérieur sont idéales pour les petits programmes et utilitaires de console.</span><span class="sxs-lookup"><span data-stu-id="40910-244">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="40910-245">Azure Functions est un cas d’usage idéal pour les instructions de niveau supérieur.</span><span class="sxs-lookup"><span data-stu-id="40910-245">Azure functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="40910-246">Plus important encore, les instructions de niveau supérieur ne limitent pas la portée ou la complexité de votre application.</span><span class="sxs-lookup"><span data-stu-id="40910-246">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="40910-247">Ces instructions peuvent accéder ou utiliser n’importe quelle classe .NET.</span><span class="sxs-lookup"><span data-stu-id="40910-247">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="40910-248">Ils ne limitent pas non plus l’utilisation des arguments de ligne de commande ou des valeurs de retour.</span><span class="sxs-lookup"><span data-stu-id="40910-248">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="40910-249">Les instructions de niveau supérieur peuvent accéder à un tableau de chaînes nommées args.</span><span class="sxs-lookup"><span data-stu-id="40910-249">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="40910-250">Si les instructions de niveau supérieur retournent une valeur entière, cette valeur devient le code de retour de l’entier d’une méthode synthétisée `Main` .</span><span class="sxs-lookup"><span data-stu-id="40910-250">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="40910-251">Les instructions de niveau supérieur peuvent contenir des expressions Async.</span><span class="sxs-lookup"><span data-stu-id="40910-251">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="40910-252">Dans ce cas, le point d’entrée synthétisé retourne un `Task` , ou `Task<int>` .</span><span class="sxs-lookup"><span data-stu-id="40910-252">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="40910-253">Améliorations des critères spéciaux</span><span class="sxs-lookup"><span data-stu-id="40910-253">Pattern matching enhancements</span></span>

<span data-ttu-id="40910-254">C# 9 comprend de nouvelles améliorations de la mise en correspondance des modèles :</span><span class="sxs-lookup"><span data-stu-id="40910-254">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="40910-255">Les ***modèles de type*** correspondent à une variable est un type</span><span class="sxs-lookup"><span data-stu-id="40910-255">***Type patterns*** match a variable is a type</span></span>
- <span data-ttu-id="40910-256">Les ***modèles entre parenthèses*** appliquent ou mettent en évidence la précédence des combinaisons de modèles</span><span class="sxs-lookup"><span data-stu-id="40910-256">***Parenthesized patterns*** enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="40910-257">***Les `and` modèles conjonctives*** nécessitent que les deux modèles correspondent</span><span class="sxs-lookup"><span data-stu-id="40910-257">***Conjunctive `and` patterns*** require both patterns to match</span></span>
- <span data-ttu-id="40910-258">***Les `or` modèles disjonctive*** nécessitent un modèle de correspondance</span><span class="sxs-lookup"><span data-stu-id="40910-258">***Disjunctive `or` patterns*** require either pattern to match</span></span>
- <span data-ttu-id="40910-259">Les \*\*\* `not` modèles de négation\*\*\* requièrent qu’un modèle ne corresponde pas</span><span class="sxs-lookup"><span data-stu-id="40910-259">***Negated `not` patterns*** require that a pattern doesn’t match</span></span>
- <span data-ttu-id="40910-260">Les ***modèles relationnels*** requièrent que l’entrée soit inférieure à, supérieure à, inférieure ou égale à une constante donnée, ou supérieure ou égale à celle-ci.</span><span class="sxs-lookup"><span data-stu-id="40910-260">***Relational patterns*** require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="40910-261">Ces modèles enrichissent la syntaxe des modèles.</span><span class="sxs-lookup"><span data-stu-id="40910-261">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="40910-262">Prenons les exemples suivants :</span><span class="sxs-lookup"><span data-stu-id="40910-262">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="40910-263">En guise d’alternative, avec des parenthèses facultatives pour qu’elle soit claire et qu’elle `and` a une priorité plus élevée que `or` :</span><span class="sxs-lookup"><span data-stu-id="40910-263">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="40910-264">L’une des utilisations les plus courantes est une nouvelle syntaxe pour un contrôle de valeur NULL :</span><span class="sxs-lookup"><span data-stu-id="40910-264">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="40910-265">L’un de ces modèles peut être utilisé dans n’importe quel contexte où les modèles sont autorisés : `is` les expressions de modèle, les `switch` expressions, les modèles imbriqués et le modèle de l’étiquette d’une `switch` instruction `case` .</span><span class="sxs-lookup"><span data-stu-id="40910-265">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="40910-266">Performances et interopérabilité</span><span class="sxs-lookup"><span data-stu-id="40910-266">Performance and interop</span></span>

<span data-ttu-id="40910-267">Trois nouvelles fonctionnalités améliorent la prise en charge de l’interopérabilité native et des bibliothèques de bas niveau qui requièrent des performances élevées : les entiers de taille native, les pointeurs de fonction et l’omission de l' `localsinit` indicateur.</span><span class="sxs-lookup"><span data-stu-id="40910-267">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="40910-268">Les entiers de taille native, `nint` et `nuint` , sont des types entiers.</span><span class="sxs-lookup"><span data-stu-id="40910-268">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="40910-269">Elles sont exprimées par les types sous-jacents <xref:System.IntPtr?displayProperty=nameWithType> et <xref:System.UIntPtr?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="40910-269">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="40910-270">Le compilateur recadre les conversions et les opérations supplémentaires pour ces types comme des ints natifs.</span><span class="sxs-lookup"><span data-stu-id="40910-270">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="40910-271">Les entiers de taille native définissent des propriétés pour `MaxValue` ou `MinValue` .</span><span class="sxs-lookup"><span data-stu-id="40910-271">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="40910-272">Ces valeurs ne peuvent pas être exprimées comme des constantes de compilation, car elles dépendent de la taille native d’un entier sur l’ordinateur cible.</span><span class="sxs-lookup"><span data-stu-id="40910-272">These values can't be expressed as compile time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="40910-273">Ces valeurs sont en lecture seule au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="40910-273">Those values are readonly at runtime.</span></span> <span data-ttu-id="40910-274">Vous pouvez utiliser des valeurs constantes pour `nint` dans la plage [ `int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="40910-274">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="40910-275">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="40910-275">`int.MaxValue`].</span></span> <span data-ttu-id="40910-276">Vous pouvez utiliser des valeurs constantes pour `nuint` dans la plage [ `uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="40910-276">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="40910-277">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="40910-277">`uint.MaxValue`].</span></span> <span data-ttu-id="40910-278">Le compilateur exécute un repli constant pour tous les opérateurs unaires et binaires à l’aide des <xref:System.Int32?displayProperty=nameWithType> <xref:System.UInt32?displayProperty=nameWithType> types et.</span><span class="sxs-lookup"><span data-stu-id="40910-278">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="40910-279">Si le résultat ne tient pas dans 32 bits, l’opération est exécutée au moment de l’exécution et n’est pas considérée comme une constante.</span><span class="sxs-lookup"><span data-stu-id="40910-279">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="40910-280">Les entiers de taille native peuvent augmenter les performances dans les scénarios où les calculs d’entiers sont largement utilisés et doivent avoir les performances les plus rapides possibles.</span><span class="sxs-lookup"><span data-stu-id="40910-280">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="40910-281">Les pointeurs fonction fournissent une syntaxe simple pour accéder aux opcodes IL `ldftn` et `calli` .</span><span class="sxs-lookup"><span data-stu-id="40910-281">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="40910-282">Vous pouvez déclarer des pointeurs de fonction à l’aide de la nouvelle `delegate*` syntaxe.</span><span class="sxs-lookup"><span data-stu-id="40910-282">You can declare function pointers using new `delegate*` syntax.</span></span> <span data-ttu-id="40910-283">Un `delegate*` type est un type pointeur.</span><span class="sxs-lookup"><span data-stu-id="40910-283">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="40910-284">L’appel du `delegate*` type utilise `calli` , contrairement à un délégué qui utilise `callvirt` sur la `Invoke()` méthode.</span><span class="sxs-lookup"><span data-stu-id="40910-284">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="40910-285">Syntaxiquement, les appels sont identiques.</span><span class="sxs-lookup"><span data-stu-id="40910-285">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="40910-286">L’appel du pointeur de fonction utilise la `managed` Convention d’appel.</span><span class="sxs-lookup"><span data-stu-id="40910-286">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="40910-287">Vous ajoutez le `unmanaged` mot clé après la `delegate*` syntaxe pour déclarer que vous souhaitez la `unmanaged` Convention d’appel.</span><span class="sxs-lookup"><span data-stu-id="40910-287">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="40910-288">D’autres conventions d’appel peuvent être spécifiées à l’aide d’attributs sur la `delegate*` déclaration.</span><span class="sxs-lookup"><span data-stu-id="40910-288">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="40910-289">Enfin, vous pouvez ajouter le <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> pour indiquer au compilateur de ne pas émettre l' `localsinit` indicateur.</span><span class="sxs-lookup"><span data-stu-id="40910-289">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="40910-290">Cet indicateur indique au CLR d’initialiser à zéro toutes les variables locales.</span><span class="sxs-lookup"><span data-stu-id="40910-290">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="40910-291">L' `localsinit` indicateur a été le comportement par défaut pour C# depuis 1,0.</span><span class="sxs-lookup"><span data-stu-id="40910-291">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="40910-292">Toutefois, l’initialisation sans zéro supplémentaire peut avoir un impact mesurable sur les performances dans certains scénarios.</span><span class="sxs-lookup"><span data-stu-id="40910-292">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="40910-293">En particulier, lorsque vous utilisez `stackalloc` .</span><span class="sxs-lookup"><span data-stu-id="40910-293">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="40910-294">Dans ce cas, vous pouvez ajouter le <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> .</span><span class="sxs-lookup"><span data-stu-id="40910-294">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="40910-295">Vous pouvez l’ajouter à une méthode ou une propriété unique, ou à un `class` , `struct` , `interface` ou même un module.</span><span class="sxs-lookup"><span data-stu-id="40910-295">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="40910-296">Cet attribut n’affecte pas `abstract` les méthodes ; il affecte le code généré pour l’implémentation.</span><span class="sxs-lookup"><span data-stu-id="40910-296">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="40910-297">Ces fonctionnalités peuvent améliorer les performances dans certains scénarios.</span><span class="sxs-lookup"><span data-stu-id="40910-297">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="40910-298">Elles doivent être utilisées uniquement après un test minutieux avant et après l’adoption.</span><span class="sxs-lookup"><span data-stu-id="40910-298">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="40910-299">Le code impliquant des entiers de taille native doit être testé sur plusieurs plateformes cibles avec différentes tailles d’entier.</span><span class="sxs-lookup"><span data-stu-id="40910-299">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="40910-300">Les autres fonctionnalités nécessitent du code non sécurisé.</span><span class="sxs-lookup"><span data-stu-id="40910-300">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="40910-301">Fonctionnalités d’ajustement et de fin</span><span class="sxs-lookup"><span data-stu-id="40910-301">Fit and finish features</span></span>

<span data-ttu-id="40910-302">La plupart des autres fonctionnalités vous aident à écrire du code plus efficacement.</span><span class="sxs-lookup"><span data-stu-id="40910-302">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="40910-303">En C# 9,0, vous pouvez omettre le type dans une [ `new` expression](../language-reference/operators/new-operator.md) lorsque le type de l’objet créé est déjà connu.</span><span class="sxs-lookup"><span data-stu-id="40910-303">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="40910-304">L’utilisation la plus courante est dans les déclarations de champ :</span><span class="sxs-lookup"><span data-stu-id="40910-304">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="40910-305">Le type cible `new` peut également être utilisé lorsque vous devez créer un nouvel objet à passer en tant qu’argument à une méthode.</span><span class="sxs-lookup"><span data-stu-id="40910-305">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="40910-306">Envisagez une `ForecastFor()` méthode avec la signature suivante :</span><span class="sxs-lookup"><span data-stu-id="40910-306">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="40910-307">Vous pouvez l’appeler comme suit :</span><span class="sxs-lookup"><span data-stu-id="40910-307">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="40910-308">Une autre utilisation intéressante de cette fonctionnalité est de l’associer aux propriétés init only pour initialiser un nouvel objet :</span><span class="sxs-lookup"><span data-stu-id="40910-308">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="40910-309">Vous pouvez retourner une instance créée par le constructeur par défaut à l’aide d’une `return new();` instruction.</span><span class="sxs-lookup"><span data-stu-id="40910-309">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="40910-310">Une fonctionnalité similaire améliore la résolution de type cible des [expressions conditionnelles](../language-reference/operators/conditional-operator.md).</span><span class="sxs-lookup"><span data-stu-id="40910-310">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="40910-311">Avec cette modification, les deux expressions n’ont pas besoin d’une conversion implicite de l’une à l’autre, mais elles peuvent toutes deux avoir des conversions implicites en un type cible.</span><span class="sxs-lookup"><span data-stu-id="40910-311">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="40910-312">Vous ne remarquerez probablement pas cette modification.</span><span class="sxs-lookup"><span data-stu-id="40910-312">You likely won’t notice this change.</span></span> <span data-ttu-id="40910-313">Ce que vous remarquerez, c’est que certaines expressions conditionnelles qui nécessitaient auparavant des casts ou ne seraient pas compilées.</span><span class="sxs-lookup"><span data-stu-id="40910-313">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="40910-314">À compter de C# 9,0, vous pouvez ajouter le `static` modificateur aux [expressions lambda](../language-reference/operators/lambda-expressions.md) ou aux [méthodes anonymes](../language-reference/operators/delegate-operator.md).</span><span class="sxs-lookup"><span data-stu-id="40910-314">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="40910-315">Les expressions lambda statiques sont analogues aux `static` fonctions locales : une méthode lambda statique ou anonyme ne peut pas capturer les variables locales ou l’état de l’instance.</span><span class="sxs-lookup"><span data-stu-id="40910-315">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="40910-316">Le `static` modificateur empêche la capture accidentelle d’autres variables.</span><span class="sxs-lookup"><span data-stu-id="40910-316">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="40910-317">Les types de retour covariants fournissent la flexibilité pour les types de retour des fonctions substituées.</span><span class="sxs-lookup"><span data-stu-id="40910-317">Covariant return types provide flexibility for the return types of overridden functions.</span></span> <span data-ttu-id="40910-318">Une fonction virtuelle substituée peut retourner un type dérivé du type de retour déclaré dans la méthode de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="40910-318">An overridden virtual function can return a type derived from the return type declared in the base class method.</span></span> <span data-ttu-id="40910-319">Cela peut être utile pour les enregistrements et pour d’autres types qui prennent en charge les méthodes de fabrique ou de clonage virtuel.</span><span class="sxs-lookup"><span data-stu-id="40910-319">This can be useful for Records, and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="40910-320">En outre, la [ `foreach` boucle](../language-reference/keywords/foreach-in.md) reconnaît et utilise une méthode d’extension `GetEnumerator` qui, autrement, satisfait le `foreach` modèle.</span><span class="sxs-lookup"><span data-stu-id="40910-320">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="40910-321">Ce changement signifie `foreach` qu’il est cohérent avec d’autres constructions basées sur des modèles, telles que le modèle asynchrone et la déconstruction basée sur des modèles.</span><span class="sxs-lookup"><span data-stu-id="40910-321">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="40910-322">Dans la pratique, cette modification signifie que vous pouvez ajouter la `foreach` prise en charge à n’importe quel type.</span><span class="sxs-lookup"><span data-stu-id="40910-322">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="40910-323">Vous devez limiter son utilisation à lorsque l’énumération d’un objet est logique dans votre conception.</span><span class="sxs-lookup"><span data-stu-id="40910-323">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="40910-324">Ensuite, vous pouvez utiliser des éléments ignorés comme paramètres pour les expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="40910-324">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="40910-325">Cela vous permet d’éviter de nommer l’argument et le compilateur peut ne pas l’utiliser.</span><span class="sxs-lookup"><span data-stu-id="40910-325">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="40910-326">Vous utilisez `_` pour n’importe quel argument.</span><span class="sxs-lookup"><span data-stu-id="40910-326">You use the `_` for any argument.</span></span> <span data-ttu-id="40910-327">Pour plus d’informations, consultez la section [paramètres d’entrée d’une expression lambda](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) de l’article [expressions lambda](../language-reference/operators/lambda-expressions.md) .</span><span class="sxs-lookup"><span data-stu-id="40910-327">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="40910-328">Enfin, vous pouvez maintenant appliquer des attributs à des fonctions locales.</span><span class="sxs-lookup"><span data-stu-id="40910-328">Finally, you can now apply attributes to local functions.</span></span> <span data-ttu-id="40910-329">Par exemple, vous pouvez appliquer des annotations d’attribut Nullable aux fonctions locales.</span><span class="sxs-lookup"><span data-stu-id="40910-329">For example, you can apply nullable attribute annotations to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="40910-330">Prise en charge des générateurs de code</span><span class="sxs-lookup"><span data-stu-id="40910-330">Support for code generators</span></span>

<span data-ttu-id="40910-331">Deux fonctionnalités finales prennent en charge les générateurs de code C#.</span><span class="sxs-lookup"><span data-stu-id="40910-331">Two final features support C# code generators.</span></span> <span data-ttu-id="40910-332">Les générateurs de code C# sont un composant que vous pouvez écrire et qui est semblable à un Roslyn Analyzer ou à un correctif de code.</span><span class="sxs-lookup"><span data-stu-id="40910-332">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="40910-333">La différence est que les générateurs de code analysent le code et écrivent de nouveaux fichiers de code source dans le cadre du processus de compilation.</span><span class="sxs-lookup"><span data-stu-id="40910-333">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="40910-334">Un générateur de code standard recherche des attributs ou d’autres conventions dans le code.</span><span class="sxs-lookup"><span data-stu-id="40910-334">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="40910-335">Un générateur de code lit des attributs ou d’autres éléments de code à l’aide des API d’analyse Roslyn.</span><span class="sxs-lookup"><span data-stu-id="40910-335">A code generator read attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="40910-336">À partir de ces informations, il ajoute un nouveau code à la compilation.</span><span class="sxs-lookup"><span data-stu-id="40910-336">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="40910-337">Les générateurs de source peuvent uniquement ajouter du code ; ils ne sont pas autorisés à modifier le code existant dans la compilation.</span><span class="sxs-lookup"><span data-stu-id="40910-337">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="40910-338">Les deux fonctionnalités ajoutées pour les générateurs de code sont les extensions de la ***syntaxe de méthode partielle***et les ***initialiseurs de module***.</span><span class="sxs-lookup"><span data-stu-id="40910-338">The two features added for code generators are extensions to ***partial method syntax***, and ***module initializers***.</span></span> <span data-ttu-id="40910-339">Tout d’abord, les modifications apportées aux méthodes partielles.</span><span class="sxs-lookup"><span data-stu-id="40910-339">First, the changes to partial methods.</span></span> <span data-ttu-id="40910-340">Avant C# 9,0, les méthodes partielles sont, `private` mais ne peuvent pas spécifier un modificateur d’accès, ont un `void` retour et ne peuvent pas avoir de `out` paramètres.</span><span class="sxs-lookup"><span data-stu-id="40910-340">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="40910-341">Ces restrictions signifiaient que si aucune implémentation de méthode n’est fournie, le compilateur supprime tous les appels à la méthode partielle.</span><span class="sxs-lookup"><span data-stu-id="40910-341">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="40910-342">C# 9,0 supprime ces restrictions, mais exige que les déclarations de méthode partielles aient une implémentation.</span><span class="sxs-lookup"><span data-stu-id="40910-342">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="40910-343">Les générateurs de code peuvent fournir cette implémentation.</span><span class="sxs-lookup"><span data-stu-id="40910-343">Code generators can provide that implementation.</span></span> <span data-ttu-id="40910-344">Pour éviter d’introduire une modification avec rupture, le compilateur considère toute méthode partielle sans modificateur d’accès pour suivre les anciennes règles.</span><span class="sxs-lookup"><span data-stu-id="40910-344">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="40910-345">Si la méthode partielle comprend le `private` modificateur d’accès, les nouvelles règles gouvernent cette méthode partielle.</span><span class="sxs-lookup"><span data-stu-id="40910-345">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="40910-346">La deuxième nouvelle fonctionnalité pour les générateurs de code est les ***initialiseurs de module***.</span><span class="sxs-lookup"><span data-stu-id="40910-346">The second new feature for code generators is ***module initializers***.</span></span> <span data-ttu-id="40910-347">Les initialiseurs de module sont des méthodes auxquelles l' <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribut est attaché.</span><span class="sxs-lookup"><span data-stu-id="40910-347">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="40910-348">Ces méthodes sont appelées par le runtime lors du chargement de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="40910-348">These methods will be called by the runtime when the assembly loads.</span></span> <span data-ttu-id="40910-349">Méthode d’initialiseur de module :</span><span class="sxs-lookup"><span data-stu-id="40910-349">A module initializer method:</span></span>

- <span data-ttu-id="40910-350">Doit être statique</span><span class="sxs-lookup"><span data-stu-id="40910-350">Must be static</span></span>
- <span data-ttu-id="40910-351">Doit être sans paramètre</span><span class="sxs-lookup"><span data-stu-id="40910-351">Must be parameterless</span></span>
- <span data-ttu-id="40910-352">Doit retourner void</span><span class="sxs-lookup"><span data-stu-id="40910-352">Must return void</span></span>
- <span data-ttu-id="40910-353">Ne doit pas être une méthode générique</span><span class="sxs-lookup"><span data-stu-id="40910-353">Must not be a generic method</span></span>
- <span data-ttu-id="40910-354">Ne doit pas être contenu dans une classe générique</span><span class="sxs-lookup"><span data-stu-id="40910-354">Must not be contained in a generic class</span></span>
- <span data-ttu-id="40910-355">Doit être accessible à partir du module conteneur</span><span class="sxs-lookup"><span data-stu-id="40910-355">Must be accessible from the containing module</span></span>

<span data-ttu-id="40910-356">Ce dernier point à puce signifie effectivement que la méthode et sa classe conteneur doivent être internes ou publiques.</span><span class="sxs-lookup"><span data-stu-id="40910-356">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="40910-357">La méthode ne peut pas être une fonction locale.</span><span class="sxs-lookup"><span data-stu-id="40910-357">The method can't be a local function.</span></span>
