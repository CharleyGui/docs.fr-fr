---
title: Nouveautés de C# 6 | Guide C#
description: Découvrez les nouvelles fonctionnalités de C# version 6
ms.date: 12/12/2018
ms.openlocfilehash: da40b4c9d4af0094fdd907c542e971ba55086e0f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79399391"
---
# <a name="whats-new-in-c-6"></a><span data-ttu-id="a523a-103">Nouveautés de C# 6</span><span class="sxs-lookup"><span data-stu-id="a523a-103">What's New in C# 6</span></span>

<span data-ttu-id="a523a-104">La version Release 6.0 de C# comprenait de nombreuses fonctionnalités qui améliorent la productivité des développeurs.</span><span class="sxs-lookup"><span data-stu-id="a523a-104">The 6.0 release of C# contained many features that improve productivity for developers.</span></span> <span data-ttu-id="a523a-105">Globalement, ces fonctionnalités vous permettent d’écrire du code plus concis et également plus lisible.</span><span class="sxs-lookup"><span data-stu-id="a523a-105">The overall effect of these features is that you write more concise code that is also more readable.</span></span> <span data-ttu-id="a523a-106">La syntaxe est moins formelle concernant de nombreuses pratiques courantes.</span><span class="sxs-lookup"><span data-stu-id="a523a-106">The syntax contains less ceremony for many common practices.</span></span> <span data-ttu-id="a523a-107">Moins de formalisme permet de voir plus facilement l’intention de conception.</span><span class="sxs-lookup"><span data-stu-id="a523a-107">It's easier to see the design intent with less ceremony.</span></span> <span data-ttu-id="a523a-108">En apprenant bien ces fonctionnalités, vous gagnez en productivité et écrivez du code plus lisible.</span><span class="sxs-lookup"><span data-stu-id="a523a-108">Learn these features well, and you'll be more productive and write more readable code.</span></span> <span data-ttu-id="a523a-109">Vous pouvez également vous concentrer davantage sur vos fonctionnalités que sur les constructions du langage.</span><span class="sxs-lookup"><span data-stu-id="a523a-109">You can concentrate more on your features than on the constructs of the language.</span></span>

<span data-ttu-id="a523a-110">La suite de cet article fournit une vue d’ensemble de ces fonctionnalités, avec des liens pour explorer chacune d’entre elles.</span><span class="sxs-lookup"><span data-stu-id="a523a-110">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span> <span data-ttu-id="a523a-111">Vous pouvez également explorer les fonctionnalités dans une [exploration interactive sur C# 6](../tutorials/exploration/csharp-6.yml) dans la section des tutoriels.</span><span class="sxs-lookup"><span data-stu-id="a523a-111">You can also explore the features in an [interactive exploration on C# 6](../tutorials/exploration/csharp-6.yml) in the tutorials section.</span></span>

## <a name="read-only-auto-properties"></a><span data-ttu-id="a523a-112">Auto-properties en lecture seule</span><span class="sxs-lookup"><span data-stu-id="a523a-112">Read-only auto-properties</span></span>

<span data-ttu-id="a523a-113">Les *auto-properties en lecture seule* offrent une syntaxe plus concise pour créer des types immuables.</span><span class="sxs-lookup"><span data-stu-id="a523a-113">*Read-only auto-properties* provide a more concise syntax to create immutable types.</span></span> <span data-ttu-id="a523a-114">Vous déclarez l’auto-property avec uniquement un accesseur get :</span><span class="sxs-lookup"><span data-stu-id="a523a-114">You declare the auto-property with only a get accessor:</span></span>

[!code-csharp[ReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)]

<span data-ttu-id="a523a-115">Les propriétés `FirstName` et `LastName` peuvent être définies seulement dans le corps du constructeur de la même classe :</span><span class="sxs-lookup"><span data-stu-id="a523a-115">The `FirstName` and `LastName` properties can be set only in the body of the constructor of the same class:</span></span>

[!code-csharp[ReadOnlyAutoPropertyConstructor](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)]

<span data-ttu-id="a523a-116">Tenter de définir `LastName` dans une autre méthode génère une erreur de compilation `CS0200` :</span><span class="sxs-lookup"><span data-stu-id="a523a-116">Trying to set `LastName` in another method generates a `CS0200` compilation error:</span></span>

```csharp
public class Student
{
    public string LastName { get;  }

    public void ChangeName(string newLastName)
    {
        // Generates CS0200: Property or indexer cannot be assigned to -- it is read only
        LastName = newLastName;
    }
}
```

<span data-ttu-id="a523a-117">Cette fonctionnalité permet une véritable prise en charge du langage pour la création de types immuables et utilise la syntaxe d’auto-property plus concise et plus pratique.</span><span class="sxs-lookup"><span data-stu-id="a523a-117">This feature enables true language support for creating immutable types and uses the more concise and convenient auto-property syntax.</span></span>

<span data-ttu-id="a523a-118">Si l’ajout de cette syntaxe ne supprime pas une méthode accessible, il s’agit d’un [changement compatible binaire](version-update-considerations.md#binary-compatible-changes).</span><span class="sxs-lookup"><span data-stu-id="a523a-118">If adding this syntax doesn't remove an accessible method, it's a [binary compatible change](version-update-considerations.md#binary-compatible-changes).</span></span>

## <a name="auto-property-initializers"></a><span data-ttu-id="a523a-119">Initialiseurs de propriétés automatiques</span><span class="sxs-lookup"><span data-stu-id="a523a-119">Auto-property initializers</span></span>

<span data-ttu-id="a523a-120">Les *initialiseurs de propriétés automatiques* vous permettent de déclarer la valeur initiale d’une propriété automatique dans le cadre de la déclaration de la propriété.</span><span class="sxs-lookup"><span data-stu-id="a523a-120">*Auto-property initializers* let you declare the initial value for an auto-property as part of the property declaration.</span></span>

[!code-csharp[Initialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)]

<span data-ttu-id="a523a-121">Le membre `Grades` est initialisé à l’emplacement où il est déclaré.</span><span class="sxs-lookup"><span data-stu-id="a523a-121">The `Grades` member is initialized where it's declared.</span></span> <span data-ttu-id="a523a-122">Il est ainsi plus facile d’effectuer l’initialisation une seule fois.</span><span class="sxs-lookup"><span data-stu-id="a523a-122">That makes it easier to perform the initialization exactly once.</span></span> <span data-ttu-id="a523a-123">L’initialisation fait partie de la déclaration de propriété, facilitant ainsi la mise en correspondance de l’allocation de stockage et de l’interface publique pour les objets `Student`.</span><span class="sxs-lookup"><span data-stu-id="a523a-123">The initialization is part of the property declaration, making it easier to equate the storage allocation with the public interface for `Student` objects.</span></span>

## <a name="expression-bodied-function-members"></a><span data-ttu-id="a523a-124">Membres de fonction expression-bodied</span><span class="sxs-lookup"><span data-stu-id="a523a-124">Expression-bodied function members</span></span>

<span data-ttu-id="a523a-125">De nombreux membres que vous écrivez sont des instructions uniques qui pourraient être des expressions simples.</span><span class="sxs-lookup"><span data-stu-id="a523a-125">Many members that you write are single statements that could be single expressions.</span></span> <span data-ttu-id="a523a-126">Écrivez un membre expression-bodied à la place.</span><span class="sxs-lookup"><span data-stu-id="a523a-126">Write an expression-bodied member instead.</span></span> <span data-ttu-id="a523a-127">Cela fonctionne pour les méthodes et les propriétés en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="a523a-127">It works for methods and read-only properties.</span></span> <span data-ttu-id="a523a-128">Par exemple, une substitution de `ToString()` est souvent un excellent candidat :</span><span class="sxs-lookup"><span data-stu-id="a523a-128">For example, an override of `ToString()` is often a great candidate:</span></span>

[!code-csharp[ToStringExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)]

<span data-ttu-id="a523a-129">Vous pouvez également utiliser cette syntaxe pour les propriétés en lecture seule :</span><span class="sxs-lookup"><span data-stu-id="a523a-129">You can also use this syntax for read-only properties:</span></span>

[!code-csharp[FullNameExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

<span data-ttu-id="a523a-130">La modification d’un membre existant en un membre expression-bodied est une [modification compatible binaire](version-update-considerations.md#binary-compatible-changes).</span><span class="sxs-lookup"><span data-stu-id="a523a-130">Changing an existing member to an expression bodied member is a [binary compatible change](version-update-considerations.md#binary-compatible-changes).</span></span>

## <a name="using-static"></a><span data-ttu-id="a523a-131">using static</span><span class="sxs-lookup"><span data-stu-id="a523a-131">using static</span></span>

<span data-ttu-id="a523a-132">L’amélioration de *using static* vous permet d’importer les méthodes statiques d’une classe unique.</span><span class="sxs-lookup"><span data-stu-id="a523a-132">The *using static* enhancement enables you to import the static methods of a single class.</span></span> <span data-ttu-id="a523a-133">Vous spécifiez la classe que vous utilisez :</span><span class="sxs-lookup"><span data-stu-id="a523a-133">You specify the class you're using:</span></span>

[!code-csharp[UsingStaticMath](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)]

<span data-ttu-id="a523a-134"><xref:System.Math> ne contient aucune méthode d’instance.</span><span class="sxs-lookup"><span data-stu-id="a523a-134">The <xref:System.Math> does not contain any instance methods.</span></span> <span data-ttu-id="a523a-135">Vous pouvez également utiliser `using static` pour importer les méthodes statiques d’une classe pour une classe qui comprend à la fois des méthodes statiques et des méthodes d’instance.</span><span class="sxs-lookup"><span data-stu-id="a523a-135">You can also use `using static` to import a class' static methods for a class that has both static and instance methods.</span></span> <span data-ttu-id="a523a-136">Un des exemples les plus utiles est <xref:System.String> :</span><span class="sxs-lookup"><span data-stu-id="a523a-136">One of the most useful examples is <xref:System.String>:</span></span>

[!code-csharp[UsingStatic](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)]

> [!NOTE]
> <span data-ttu-id="a523a-137">Vous devez utiliser le nom de classe complet, `System.String`, dans une instruction static using.</span><span class="sxs-lookup"><span data-stu-id="a523a-137">You must use the fully qualified class name, `System.String`  in a static using statement.</span></span>  <span data-ttu-id="a523a-138">Vous ne pouvez pas utiliser le mot clé `string` à la place.</span><span class="sxs-lookup"><span data-stu-id="a523a-138">You cannot use the `string` keyword instead.</span></span>

<span data-ttu-id="a523a-139">Quand elles sont importées à partir d’une instruction `static using`, les méthodes d’extension ne sont dans la portée que si elles sont appelées à l’aide de la syntaxe d’invocation de méthode d’extension.</span><span class="sxs-lookup"><span data-stu-id="a523a-139">When imported from a `static using` statement, extension methods are only in scope when called using the extension method invocation syntax.</span></span> <span data-ttu-id="a523a-140">Elle ne sont pas dans la portée si elles sont appelées en tant que méthode statique.</span><span class="sxs-lookup"><span data-stu-id="a523a-140">They aren't in scope when called as a static method.</span></span> <span data-ttu-id="a523a-141">Ce sera souvent le cas dans les requêtes LINQ.</span><span class="sxs-lookup"><span data-stu-id="a523a-141">You'll often see this in LINQ queries.</span></span> <span data-ttu-id="a523a-142">Vous pouvez importer le modèle LINQ en important <xref:System.Linq.Enumerable> ou <xref:System.Linq.Queryable>.</span><span class="sxs-lookup"><span data-stu-id="a523a-142">You can import the LINQ pattern by importing <xref:System.Linq.Enumerable>, or <xref:System.Linq.Queryable>.</span></span>

[!code-csharp[UsingStaticLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)]

<span data-ttu-id="a523a-143">Vous appelez généralement les méthodes d’extension à l’aide d’expressions d’appel de méthode d’extension.</span><span class="sxs-lookup"><span data-stu-id="a523a-143">You typically call extension methods using extension method invocation expressions.</span></span> <span data-ttu-id="a523a-144">Pour lever toute ambiguïté, ajoutez le nom de la classe dans les rares cas où vous les appelez à l’aide de la syntaxe d’appel de méthode statique.</span><span class="sxs-lookup"><span data-stu-id="a523a-144">Adding the class name in the rare case where you call them using static method call syntax resolves ambiguity.</span></span>

<span data-ttu-id="a523a-145">La directive `static using` importe également n’importe quel type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="a523a-145">The `static using` directive also imports any nested types.</span></span> <span data-ttu-id="a523a-146">Vous pouvez référencer tous les types imbriqués sans qualification.</span><span class="sxs-lookup"><span data-stu-id="a523a-146">You can reference any nested types without qualification.</span></span>

## <a name="null-conditional-operators"></a><span data-ttu-id="a523a-147">Null - Opérateurs conditionnel</span><span class="sxs-lookup"><span data-stu-id="a523a-147">Null-conditional operators</span></span>

<span data-ttu-id="a523a-148">L’*opérateur conditionnel null* rend ces vérifications de valeur null beaucoup plus faciles et plus fluides.</span><span class="sxs-lookup"><span data-stu-id="a523a-148">The *null conditional operator* makes null checks much easier and fluid.</span></span> <span data-ttu-id="a523a-149">Remplacez l’accès aux membres `.` par `?.` :</span><span class="sxs-lookup"><span data-stu-id="a523a-149">Replace the member access `.` with `?.`:</span></span>

[!code-csharp[NullConditional](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)]

<span data-ttu-id="a523a-150">Dans l’exemple précédent, la valeur `null` est assignée à la variable `first` si l’objet person a la valeur `null`.</span><span class="sxs-lookup"><span data-stu-id="a523a-150">In the preceding example, the variable `first` is assigned `null` if the person object is `null`.</span></span> <span data-ttu-id="a523a-151">Sinon, la valeur de la propriété `FirstName` lui est assignée.</span><span class="sxs-lookup"><span data-stu-id="a523a-151">Otherwise, it is assigned the value of the `FirstName` property.</span></span> <span data-ttu-id="a523a-152">Plus important encore, le `?.` signifie que cette ligne de code ne génère pas de `NullReferenceException` si la variable `person` a la valeur `null`.</span><span class="sxs-lookup"><span data-stu-id="a523a-152">Most importantly, the `?.` means that this line of code doesn't generate a `NullReferenceException` if the `person` variable is `null`.</span></span> <span data-ttu-id="a523a-153">Au lieu de cela, elle court-circuite et retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="a523a-153">Instead, it short-circuits and returns `null`.</span></span> <span data-ttu-id="a523a-154">Vous pouvez également utiliser un opérateur conditionnel null pour l’accès au tableau ou à l’indexeur.</span><span class="sxs-lookup"><span data-stu-id="a523a-154">You can also use a null conditional operator for array or indexer access.</span></span> <span data-ttu-id="a523a-155">Remplacez `[]` par `?[]` dans l’expression d’index.</span><span class="sxs-lookup"><span data-stu-id="a523a-155">Replace `[]` with `?[]` in the index expression.</span></span>

<span data-ttu-id="a523a-156">L’expression suivante retourne un `string`, quelle que soit la valeur de `person`.</span><span class="sxs-lookup"><span data-stu-id="a523a-156">The following expression returns a `string`, regardless of the value of `person`.</span></span> <span data-ttu-id="a523a-157">Vous pouvez utiliser cette construction avec l’opérateur de *fusion null* pour assigner des valeurs par défaut quand l’une des propriétés a la valeur `null`.</span><span class="sxs-lookup"><span data-stu-id="a523a-157">You often use this construct with the *null coalescing* operator to assign default values when one of the properties is `null`.</span></span> <span data-ttu-id="a523a-158">Quand l’expression court-circuite, la valeur `null` retournée est typée pour correspondre à l’expression complète.</span><span class="sxs-lookup"><span data-stu-id="a523a-158">When the expression short-circuits, the `null` value returned is typed to match the full expression.</span></span>

[!code-csharp[NullCoalescing](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)]

<span data-ttu-id="a523a-159">Vous pouvez également utiliser `?.` pour appeler des méthodes de manière conditionnelle.</span><span class="sxs-lookup"><span data-stu-id="a523a-159">You can also use `?.` to conditionally invoke methods.</span></span> <span data-ttu-id="a523a-160">L’utilisation la plus courante de fonctions membres avec l’opérateur conditionnel null consiste à appeler en toute sécurité des délégués (ou des gestionnaires d’événements) qui peuvent avoir la valeur `null`.</span><span class="sxs-lookup"><span data-stu-id="a523a-160">The most common use of member functions  with the null conditional operator is to safely invoke delegates (or event handlers) that may be `null`.</span></span>  <span data-ttu-id="a523a-161">Appelez la méthode `Invoke` du délégué à l’aide de l’opérateur `?.` pour accéder au membre.</span><span class="sxs-lookup"><span data-stu-id="a523a-161">You'll call the delegate's `Invoke` method using the `?.` operator to access the member.</span></span> <span data-ttu-id="a523a-162">Vous trouverez un exemple dans l’article relatif aux [modèles de délégués](../delegates-patterns.md#handling-null-delegates).</span><span class="sxs-lookup"><span data-stu-id="a523a-162">You can see an example in the [delegate patterns](../delegates-patterns.md#handling-null-delegates) article.</span></span>

<span data-ttu-id="a523a-163">Les règles de l’opérateur `?.` garantissent que la partie gauche de l’opérateur n’est évalué qu’une seule fois.</span><span class="sxs-lookup"><span data-stu-id="a523a-163">The rules of the `?.` operator ensure that the left-hand side of the operator is evaluated only once.</span></span> <span data-ttu-id="a523a-164">De nombreux idiomes sont permis, notamment l’exemple suivant qui utilise des gestionnaires d’événements :</span><span class="sxs-lookup"><span data-stu-id="a523a-164">It enables many idioms, including the following example using event handlers:</span></span>

```csharp
// preferred in C# 6:
this.SomethingHappened?.Invoke(this, eventArgs);
```

<span data-ttu-id="a523a-165">Le fait de vérifier que le côté gauche n’est évalué qu’une seule fois vous permet également d’utiliser n’importe quelle expression, notamment des appels de méthode, à gauche du `?.`</span><span class="sxs-lookup"><span data-stu-id="a523a-165">Ensuring that the left side is evaluated only once also enables you to use any expression, including method calls, on the left side of the `?.`</span></span>

## <a name="string-interpolation"></a><span data-ttu-id="a523a-166">Interpolation de chaîne</span><span class="sxs-lookup"><span data-stu-id="a523a-166">String interpolation</span></span>

<span data-ttu-id="a523a-167">Avec C# 6, la nouvelle fonctionnalité d’[interpolation de chaîne](../language-reference/tokens/interpolated.md) vous permet d’incorporer des expressions dans une chaîne.</span><span class="sxs-lookup"><span data-stu-id="a523a-167">With C# 6, the new [string interpolation](../language-reference/tokens/interpolated.md) feature enables you to embed expressions in a string.</span></span> <span data-ttu-id="a523a-168">Il vous suffit de faire précéder la chaîne de `$` et d’utiliser des expressions entre `{` et `}` à la place d’ordinaux :</span><span class="sxs-lookup"><span data-stu-id="a523a-168">Simply preface the string with `$`and use expressions between `{` and `}` instead of ordinals:</span></span>

[!code-csharp[stringInterpolation](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

<span data-ttu-id="a523a-169">Cet exemple utilise des propriétés pour les expressions substituées.</span><span class="sxs-lookup"><span data-stu-id="a523a-169">This example uses properties for the substituted expressions.</span></span> <span data-ttu-id="a523a-170">Vous pouvez utiliser n’importe quelle expression.</span><span class="sxs-lookup"><span data-stu-id="a523a-170">You can use any expression.</span></span> <span data-ttu-id="a523a-171">Par exemple, vous pourrez calculer la moyenne pondérée cumulative d’un étudiant dans le cadre de l’interpolation :</span><span class="sxs-lookup"><span data-stu-id="a523a-171">For example, you could compute a student's grade point average as part of the interpolation:</span></span>

[!code-csharp[stringInterpolationFormat](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)]

<span data-ttu-id="a523a-172">La ligne de code précédente met en forme la valeur de `Grades.Average()` sous la forme d’un nombre à virgule flottante à deux décimales.</span><span class="sxs-lookup"><span data-stu-id="a523a-172">The preceding line of code formats the value for `Grades.Average()` as a floating-point number with two decimal places.</span></span>

<span data-ttu-id="a523a-173">Souvent, vous devrez mettre en forme la chaîne produite à l’aide d’une culture spécifique.</span><span class="sxs-lookup"><span data-stu-id="a523a-173">Often, you may need to format the string produced using a specific culture.</span></span> <span data-ttu-id="a523a-174">Vous utilisez le fait que l’objet résultant d’une interpolation de chaîne peut être converti implicitement en <xref:System.FormattableString?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a523a-174">You use the fact that the object produced by a string interpolation can be implicitly converted to <xref:System.FormattableString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a523a-175">L’instance <xref:System.FormattableString> contient la chaîne de format composite et les résultats de l’évaluation des expressions avant leur conversion en chaînes.</span><span class="sxs-lookup"><span data-stu-id="a523a-175">The <xref:System.FormattableString> instance contains the composite format string and the results of evaluating the expressions before converting them to strings.</span></span> <span data-ttu-id="a523a-176">Utilisez la méthode <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> pour spécifier la culture lors de la mise en forme d’une chaîne.</span><span class="sxs-lookup"><span data-stu-id="a523a-176">Use the <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> method to specify the culture when formatting a string.</span></span> <span data-ttu-id="a523a-177">L’exemple suivant produit une chaîne en utilisant la culture allemande (de-DE).</span><span class="sxs-lookup"><span data-stu-id="a523a-177">The following example produces a string using the German (de-DE) culture.</span></span> <span data-ttu-id="a523a-178">(Par défaut, la culture allemande utilise le caractère « , » comme séparateur décimal et « . » comme séparateur des milliers.)</span><span class="sxs-lookup"><span data-stu-id="a523a-178">(By default, the German culture uses the ',' character for the decimal separator, and the '.' character as the thousands separator.)</span></span>

```csharp
FormattableString str = $"Average grade is {s.Grades.Average()}";
var gradeStr = str.ToString(new System.Globalization.CultureInfo("de-DE"));
```

<span data-ttu-id="a523a-179">Pour bien démarrer avec l’interpolation de chaîne, consultez le tutoriel interactif [Interpolation de chaîne en C#](../tutorials/exploration/interpolated-strings.yml), l’article [Interpolation de chaîne](../language-reference/tokens/interpolated.md) et le tutoriel [Interpolation de chaîne en C#](../tutorials/string-interpolation.md).</span><span class="sxs-lookup"><span data-stu-id="a523a-179">To get started with string interpolation, see the [String interpolation in C#](../tutorials/exploration/interpolated-strings.yml) interactive tutorial, the [String interpolation](../language-reference/tokens/interpolated.md) article, and the [String interpolation in C#](../tutorials/string-interpolation.md) tutorial.</span></span>

## <a name="exception-filters"></a><span data-ttu-id="a523a-180">Filtres d’exceptions</span><span class="sxs-lookup"><span data-stu-id="a523a-180">Exception filters</span></span>

<span data-ttu-id="a523a-181">Les *filtres d’exception* sont des clauses qui déterminent quand une clause catch donnée doit être appliquée.</span><span class="sxs-lookup"><span data-stu-id="a523a-181">*Exception Filters* are clauses that determine when a given catch clause should be applied.</span></span> <span data-ttu-id="a523a-182">Si l’expression utilisée pour un filtre d’exception prend la valeur `true`, la clause catch effectue son traitement normal sur une exception.</span><span class="sxs-lookup"><span data-stu-id="a523a-182">If the expression used for an exception filter evaluates to `true`, the catch clause performs its normal processing on an exception.</span></span> <span data-ttu-id="a523a-183">Si l’expression prend la valeur `false`, la clause `catch` est ignorée.</span><span class="sxs-lookup"><span data-stu-id="a523a-183">If the expression evaluates to `false`, then the `catch` clause is skipped.</span></span> <span data-ttu-id="a523a-184">Une de leurs utilisations consiste à examiner les informations concernant une exception pour déterminer si une clause `catch` peut la traiter :</span><span class="sxs-lookup"><span data-stu-id="a523a-184">One use is to examine information about an exception to determine if a `catch` clause can process the exception:</span></span>

[!code-csharp[ExceptionFilter](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)]

## <a name="the-nameof-expression"></a><span data-ttu-id="a523a-185">Expression `nameof`</span><span class="sxs-lookup"><span data-stu-id="a523a-185">The `nameof` expression</span></span>

<span data-ttu-id="a523a-186">L’expression [nameof](../language-reference/operators/nameof.md) prend comme valeur le nom d’un symbole.</span><span class="sxs-lookup"><span data-stu-id="a523a-186">The [nameof](../language-reference/operators/nameof.md) expression evaluates to the name of a symbol.</span></span> <span data-ttu-id="a523a-187">C’est un très bon moyen d’obtenir les outils fonctionnant chaque fois que vous avez besoin du nom d’une variable, d’une propriété ou d’un champ de membre.</span><span class="sxs-lookup"><span data-stu-id="a523a-187">It's a great way to get tools working whenever you need the name of a variable, a property, or a member field.</span></span> <span data-ttu-id="a523a-188">L’une des utilisations les plus courantes de `nameof` est la fourniture du nom d’un symbole qui a provoqué une exception :</span><span class="sxs-lookup"><span data-stu-id="a523a-188">One of the most common uses for `nameof` is to provide the name of a symbol that caused an exception:</span></span>

[!code-csharp[nameof](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)]

<span data-ttu-id="a523a-189">Une autre utilisation concerne les applications XAML qui implémentent l’interface `INotifyPropertyChanged` :</span><span class="sxs-lookup"><span data-stu-id="a523a-189">Another use is with XAML-based applications that implement the `INotifyPropertyChanged` interface:</span></span>

[!code-csharp[nameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)]

## <a name="await-in-catch-and-finally-blocks"></a><span data-ttu-id="a523a-190">await dans des blocs catch et finally</span><span class="sxs-lookup"><span data-stu-id="a523a-190">Await in Catch and Finally blocks</span></span>

<span data-ttu-id="a523a-191">C# 5 présentait plusieurs restrictions concernant les emplacements où vous pouviez placer des expressions `await`.</span><span class="sxs-lookup"><span data-stu-id="a523a-191">C# 5 had several limitations around where you could place `await` expressions.</span></span> <span data-ttu-id="a523a-192">Avec C# 6, vous pouvez maintenant utiliser `await` dans des expressions `catch` ou `finally`.</span><span class="sxs-lookup"><span data-stu-id="a523a-192">With C# 6, you can now use `await` in `catch` or `finally` expressions.</span></span> <span data-ttu-id="a523a-193">C’est le plus souvent le cas avec les scénarios de journalisation :</span><span class="sxs-lookup"><span data-stu-id="a523a-193">This is most often used with logging scenarios:</span></span>

[!code-csharp[AwaitFinally](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)]

<span data-ttu-id="a523a-194">Les détails d’implémentation relatifs à l’ajout de la prise en charge d’`await` dans des clauses `catch` et `finally` garantissent que le comportement est cohérent avec celui du code synchrone.</span><span class="sxs-lookup"><span data-stu-id="a523a-194">The implementation details for adding `await` support inside `catch` and `finally` clauses ensure that the behavior is consistent with the behavior for synchronous code.</span></span> <span data-ttu-id="a523a-195">Quand le code exécuté dans une clause `catch` ou `finally` est déclenché, l’exécution recherche une clause `catch` appropriée dans le bloc voisin suivant.</span><span class="sxs-lookup"><span data-stu-id="a523a-195">When code executed in a `catch` or `finally` clause throws, execution looks for a suitable `catch` clause in the next surrounding block.</span></span> <span data-ttu-id="a523a-196">S’il existait une exception actuelle, elle est perdue.</span><span class="sxs-lookup"><span data-stu-id="a523a-196">If there was a current exception, that exception is lost.</span></span> <span data-ttu-id="a523a-197">Il en va de même pour les expressions await dans les clauses `catch` et `finally` : une clause `catch` appropriée est recherchée, et l’exception actuelle, le cas échéant, est perdue.</span><span class="sxs-lookup"><span data-stu-id="a523a-197">The same happens with awaited expressions in `catch` and `finally` clauses: a suitable `catch` is searched for, and the current exception, if any, is lost.</span></span>  

> [!NOTE]
> <span data-ttu-id="a523a-198">De ce fait, il est recommandé d’écrire les clauses `catch` et `finally` avec précaution, afin d’éviter d’introduire de nouvelles exceptions.</span><span class="sxs-lookup"><span data-stu-id="a523a-198">This behavior is the reason it's recommended to write `catch` and `finally` clauses carefully, to avoid introducing new exceptions.</span></span>

## <a name="initialize-associative-collections-using-indexers"></a><span data-ttu-id="a523a-199">Initialiser des collections associatives à l’aide d’indexeurs</span><span class="sxs-lookup"><span data-stu-id="a523a-199">Initialize associative collections using indexers</span></span>

<span data-ttu-id="a523a-200">Les *initialiseurs d’index* constituent l’une des deux fonctionnalités qui améliorent la cohérence des initialiseurs de collection avec l’utilisation des index.</span><span class="sxs-lookup"><span data-stu-id="a523a-200">*Index Initializers* is one of two features that make collection initializers more consistent with index usage.</span></span> <span data-ttu-id="a523a-201">Dans les versions précédentes de C#, vous pouviez utiliser des *initialiseurs de collection* avec des collections de styles de séquence, notamment <xref:System.Collections.Generic.Dictionary%602>, en ajoutant des accolades autour des paires clé-valeur :</span><span class="sxs-lookup"><span data-stu-id="a523a-201">In earlier releases of C#, you could use *collection initializers* with sequence style collections, including <xref:System.Collections.Generic.Dictionary%602>, by adding braces around key and value pairs:</span></span>

[!code-csharp[ListInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#CollectionInitializer)]

<span data-ttu-id="a523a-202">Vous pouvez les utiliser avec des collections <xref:System.Collections.Generic.Dictionary%602> et d’autres types où la méthode `Add` accessible accepte plusieurs arguments.</span><span class="sxs-lookup"><span data-stu-id="a523a-202">You can use them with <xref:System.Collections.Generic.Dictionary%602> collections and other types where the accessible `Add` method accepts more than one argument.</span></span> <span data-ttu-id="a523a-203">La nouvelle syntaxe prend en charge l’affectation à l’aide d’un index dans la collection :</span><span class="sxs-lookup"><span data-stu-id="a523a-203">The new syntax supports assignment using an index into the collection:</span></span>

[!code-csharp[DictionaryInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)]

<span data-ttu-id="a523a-204">Cette fonctionnalité signifie que les conteneurs associatifs peuvent être initialisés à l’aide d’une syntaxe similaire à ce qui a été mis en place pour les conteneurs de séquence depuis plusieurs versions.</span><span class="sxs-lookup"><span data-stu-id="a523a-204">This feature means that associative containers can be initialized using syntax similar to what's been in place for sequence containers for several versions.</span></span>

## <a name="extension-add-methods-in-collection-initializers"></a><span data-ttu-id="a523a-205">Méthodes `Add` d’extension dans des initialiseurs de collections</span><span class="sxs-lookup"><span data-stu-id="a523a-205">Extension `Add` methods in collection initializers</span></span>

<span data-ttu-id="a523a-206">La possibilité d’utiliser une *méthode d’extension* pour la méthode `Add` constitue une autre fonctionnalité qui simplifie l’initialisation des collections.</span><span class="sxs-lookup"><span data-stu-id="a523a-206">Another feature that makes collection initialization easier is the ability to use an *extension method* for the `Add` method.</span></span> <span data-ttu-id="a523a-207">Elle a été ajoutée à des fins de parité avec Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a523a-207">This feature was added for parity with Visual Basic.</span></span> <span data-ttu-id="a523a-208">Cette fonctionnalité est particulièrement utile pour ajouter sémantiquement de nouveaux éléments quand vous avez une classe de collection personnalisée dont une méthode porte un nom différent.</span><span class="sxs-lookup"><span data-stu-id="a523a-208">The feature is most useful when you have a custom collection class that has a method with a different name to semantically add new items.</span></span>

## <a name="improved-overload-resolution"></a><span data-ttu-id="a523a-209">Résolution de surcharge améliorée</span><span class="sxs-lookup"><span data-stu-id="a523a-209">Improved overload resolution</span></span>

<span data-ttu-id="a523a-210">Il est probable que vous ne remarquerez pas cette dernière fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="a523a-210">This last feature is one you probably won't notice.</span></span> <span data-ttu-id="a523a-211">La précédente version du compilateur C# pouvait trouver, dans certaines constructions, des appels de méthode impliquant des expressions lambda ambigües.</span><span class="sxs-lookup"><span data-stu-id="a523a-211">There were constructs where the previous version of the C# compiler may have found some method calls involving lambda expressions ambiguous.</span></span> <span data-ttu-id="a523a-212">Prenons la méthode suivante :</span><span class="sxs-lookup"><span data-stu-id="a523a-212">Consider this method:</span></span>

[!code-csharp[AsyncMethod](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)]

<span data-ttu-id="a523a-213">Dans les versions antérieures de C#, l’appel de cette méthode à l’aide de la syntaxe de groupe de méthodes échouait :</span><span class="sxs-lookup"><span data-stu-id="a523a-213">In earlier versions of C#, calling that method using the method group syntax would fail:</span></span>

[!code-csharp[MethodGroup](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)]

<span data-ttu-id="a523a-214">Le compilateur précédent ne pouvait pas faire correctement la distinction entre `Task.Run(Action)` et `Task.Run(Func<Task>())`.</span><span class="sxs-lookup"><span data-stu-id="a523a-214">The earlier compiler couldn't distinguish correctly between `Task.Run(Action)` and `Task.Run(Func<Task>())`.</span></span> <span data-ttu-id="a523a-215">Dans les versions précédentes, vous deviez utiliser une expression lambda comme argument :</span><span class="sxs-lookup"><span data-stu-id="a523a-215">In previous versions, you'd need to use a lambda expression as an argument:</span></span>

[!code-csharp[Lambda](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)]

<span data-ttu-id="a523a-216">Le compilateur C# 6 détermine correctement que `Task.Run(Func<Task>())` constitue un meilleur choix.</span><span class="sxs-lookup"><span data-stu-id="a523a-216">The C# 6 compiler correctly determines that `Task.Run(Func<Task>())` is a better choice.</span></span>

### <a name="deterministic-compiler-output"></a><span data-ttu-id="a523a-217">Sortie du compilateur Deterministic</span><span class="sxs-lookup"><span data-stu-id="a523a-217">Deterministic compiler output</span></span>

<span data-ttu-id="a523a-218">L’option `-deterministic` fait en sorte que le compilateur génère un assembly de sortie identique octet par octet pour les compilations successives d’un même fichier source.</span><span class="sxs-lookup"><span data-stu-id="a523a-218">The `-deterministic` option instructs the compiler to produce a byte-for-byte identical output assembly for successive compilations of the same source files.</span></span>

<span data-ttu-id="a523a-219">Par défaut, chaque compilation génère une sortie unique.</span><span class="sxs-lookup"><span data-stu-id="a523a-219">By default, every compilation produces unique output on each compilation.</span></span> <span data-ttu-id="a523a-220">Le compilateur ajoute un horodateur et un GUID généré à partir de nombres aléatoires.</span><span class="sxs-lookup"><span data-stu-id="a523a-220">The compiler adds a timestamp, and a GUID generated from random numbers.</span></span> <span data-ttu-id="a523a-221">Vous utilisez cette option si vous souhaitez comparer la sortie octet par octet afin de garantir la cohérence entre les builds.</span><span class="sxs-lookup"><span data-stu-id="a523a-221">You use this option if you want to compare the byte-for-byte output to ensure consistency across builds.</span></span>

<span data-ttu-id="a523a-222">Pour plus d’informations, consultez l’article [Option du compilateur -deterministic](../language-reference/compiler-options/deterministic-compiler-option.md).</span><span class="sxs-lookup"><span data-stu-id="a523a-222">For more information, see the [-deterministic compiler option](../language-reference/compiler-options/deterministic-compiler-option.md) article.</span></span>
