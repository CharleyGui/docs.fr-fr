---
title: 'Définir des types et leurs membres-visite guidée de C #'
description: Les blocs de construction des programmes sont des types. Découvrez comment créer des classes, des structs, des interfaces, etc. en C#.
ms.date: 08/06/2020
ms.openlocfilehash: b1ce24611fec6fdf01d5ecb8d6ae974e147c78c5
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216601"
---
# <a name="types-and-members"></a><span data-ttu-id="111a8-104">Types et membres</span><span class="sxs-lookup"><span data-stu-id="111a8-104">Types and members</span></span>

<span data-ttu-id="111a8-105">En tant que langage orienté objet, C# prend en charge les concepts d’encapsulation, d’héritage et de polymorphisme.</span><span class="sxs-lookup"><span data-stu-id="111a8-105">As an object-oriented language, C# supports the concepts of encapsulation, inheritance, and polymorphism.</span></span> <span data-ttu-id="111a8-106">Une classe peut hériter directement d’une classe parente et peut implémenter un nombre quelconque d’interfaces.</span><span class="sxs-lookup"><span data-stu-id="111a8-106">A class may inherit directly from one parent class, and it may implement any number of interfaces.</span></span> <span data-ttu-id="111a8-107">Les méthodes qui substituent des méthodes virtuelles dans une classe parente requièrent le mot-clé `override` pour éviter toute redéfinition accidentelle.</span><span class="sxs-lookup"><span data-stu-id="111a8-107">Methods that override virtual methods in a parent class require the `override` keyword as a way to avoid accidental redefinition.</span></span> <span data-ttu-id="111a8-108">En C#, un struct est semblable à une classe légère ; Il s’agit d’un type alloué par la pile qui peut implémenter des interfaces mais ne prend pas en charge l’héritage.</span><span class="sxs-lookup"><span data-stu-id="111a8-108">In C#, a struct is like a lightweight class; it's a stack-allocated type that can implement interfaces but doesn't support inheritance.</span></span> <span data-ttu-id="111a8-109">C# fournit également des enregistrements, qui sont des types de classe dont l’objectif est principalement le stockage des valeurs de données.</span><span class="sxs-lookup"><span data-stu-id="111a8-109">C# also provides records, which are class types whose purpose is primarily storing data values.</span></span>

## <a name="classes-and-objects"></a><span data-ttu-id="111a8-110">Classes et objets</span><span class="sxs-lookup"><span data-stu-id="111a8-110">Classes and objects</span></span>

<span data-ttu-id="111a8-111">Les *Classes* sont le type le plus fondamental de C#.</span><span class="sxs-lookup"><span data-stu-id="111a8-111">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="111a8-112">Une classe est une structure de données qui combine l’état (champs) et les actions (méthodes et autres fonctions membres) en une seule unité.</span><span class="sxs-lookup"><span data-stu-id="111a8-112">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="111a8-113">Une classe fournit une définition pour les *instances* de la classe, également appelées *objets*.</span><span class="sxs-lookup"><span data-stu-id="111a8-113">A class provides a definition for *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="111a8-114">Les classes prennent en charge *l’héritage* et le *polymorphisme*, des mécanismes par lesquels les *classes dérivées* peuvent étendre et spécialiser les *classes de base*.</span><span class="sxs-lookup"><span data-stu-id="111a8-114">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="111a8-115">Les nouvelles classes sont créées à l’aide des déclarations de classe.</span><span class="sxs-lookup"><span data-stu-id="111a8-115">New classes are created using class declarations.</span></span> <span data-ttu-id="111a8-116">Une déclaration de classe commence par un en-tête.</span><span class="sxs-lookup"><span data-stu-id="111a8-116">A class declaration starts with a header.</span></span> <span data-ttu-id="111a8-117">L’en-tête spécifie :</span><span class="sxs-lookup"><span data-stu-id="111a8-117">The header specifies:</span></span>

- <span data-ttu-id="111a8-118">Attributs et modificateurs de la classe</span><span class="sxs-lookup"><span data-stu-id="111a8-118">The attributes and modifiers of the class</span></span>
- <span data-ttu-id="111a8-119">Nom de la classe.</span><span class="sxs-lookup"><span data-stu-id="111a8-119">The name of the class</span></span>
- <span data-ttu-id="111a8-120">Classe de base (en cas d’héritage d’une [classe de base](#base-classes))</span><span class="sxs-lookup"><span data-stu-id="111a8-120">The base class (when inheriting from a [base class](#base-classes))</span></span>
- <span data-ttu-id="111a8-121">Interfaces implémentées par la classe.</span><span class="sxs-lookup"><span data-stu-id="111a8-121">The interfaces implemented by the class.</span></span>

<span data-ttu-id="111a8-122">L’en-tête est suivi par le corps de la classe, qui se compose d’une liste de déclarations de membres écrites entre les délimiteurs `{` et `}`.</span><span class="sxs-lookup"><span data-stu-id="111a8-122">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="111a8-123">Le code suivant illustre une déclaration d’une classe simple nommée `Point` :</span><span class="sxs-lookup"><span data-stu-id="111a8-123">The following code shows a declaration of a simple class named `Point`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointClass":::

<span data-ttu-id="111a8-124">Les instances de classes sont créées à l’aide de l’opérateur `new`, qui alloue la mémoire pour une nouvelle instance, appelle un constructeur pour initialiser l’instance et retourne une référence à l’instance.</span><span class="sxs-lookup"><span data-stu-id="111a8-124">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="111a8-125">Les instructions suivantes créent deux `Point` objets et stockent les références à ces objets dans deux variables :</span><span class="sxs-lookup"><span data-stu-id="111a8-125">The following statements create two `Point` objects and store references to those objects in two variables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePoints":::

<span data-ttu-id="111a8-126">La mémoire occupée par un objet est automatiquement libérée lorsque l’objet n’est plus accessible.</span><span class="sxs-lookup"><span data-stu-id="111a8-126">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="111a8-127">Il n’est pas nécessaire ou possible de libérer explicitement des objets en C#.</span><span class="sxs-lookup"><span data-stu-id="111a8-127">It's not necessary or possible to explicitly deallocate objects in C#.</span></span>

### <a name="type-parameters"></a><span data-ttu-id="111a8-128">Paramètres de type</span><span class="sxs-lookup"><span data-stu-id="111a8-128">Type parameters</span></span>

<span data-ttu-id="111a8-129">Les classes génériques définissent les [ \* **paramètres de type** _](../programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="111a8-129">Generic classes define [\***type parameters** _](../programming-guide/generics/index.md).</span></span> <span data-ttu-id="111a8-130">Les paramètres de type sont une liste de noms de paramètre de type entre crochets pointus.</span><span class="sxs-lookup"><span data-stu-id="111a8-130">Type parameters are a list of type parameter names enclosed in angle brackets.</span></span> <span data-ttu-id="111a8-131">Les paramètres de type suivent le nom de la classe.</span><span class="sxs-lookup"><span data-stu-id="111a8-131">Type parameters follow the class name.</span></span> <span data-ttu-id="111a8-132">Les paramètres de type peuvent ensuite être utilisés dans le corps des déclarations de classe pour définir les membres de la classe.</span><span class="sxs-lookup"><span data-stu-id="111a8-132">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="111a8-133">Dans l’exemple suivant, les paramètres de type de `Pair` sont `TFirst` et `TSecond` :</span><span class="sxs-lookup"><span data-stu-id="111a8-133">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DefinePairClass":::

<span data-ttu-id="111a8-134">Un type de classe déclaré pour prendre des paramètres de type est appelé un _generic type de classe \*.</span><span class="sxs-lookup"><span data-stu-id="111a8-134">A class type that is declared to take type parameters is called a _generic class type\*.</span></span> <span data-ttu-id="111a8-135">Les types struct, interface et Delegate peuvent également être génériques.</span><span class="sxs-lookup"><span data-stu-id="111a8-135">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="111a8-136">Lorsque la classe générique est utilisée, des arguments de type doivent être fournis pour chacun des paramètres de type :</span><span class="sxs-lookup"><span data-stu-id="111a8-136">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePairObject":::

<span data-ttu-id="111a8-137">Un type générique avec des arguments de type fournis, comme `Pair<int,string>` ci-dessus, est appelé un *type construit*.</span><span class="sxs-lookup"><span data-stu-id="111a8-137">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

### <a name="base-classes"></a><span data-ttu-id="111a8-138">Classes de base</span><span class="sxs-lookup"><span data-stu-id="111a8-138">Base classes</span></span>

<span data-ttu-id="111a8-139">Une déclaration de classe peut spécifier une classe de base.</span><span class="sxs-lookup"><span data-stu-id="111a8-139">A class declaration may specify a base class.</span></span> <span data-ttu-id="111a8-140">Suivez les paramètres Name et type de la classe avec le signe deux-points et le nom de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="111a8-140">Follow the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="111a8-141">L’omission d’une spécification de classe de base revient à dériver du type `object`.</span><span class="sxs-lookup"><span data-stu-id="111a8-141">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="111a8-142">Dans l’exemple suivant, la classe de base de `Point3D` est `Point` .</span><span class="sxs-lookup"><span data-stu-id="111a8-142">In the following example, the base class of `Point3D` is `Point`.</span></span> <span data-ttu-id="111a8-143">Dans le premier exemple, la classe de base de `Point` est `object` :</span><span class="sxs-lookup"><span data-stu-id="111a8-143">From the first example, the base class of `Point` is `object`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="Create3DPoint":::

<span data-ttu-id="111a8-144">Une classe hérite des membres de sa classe de base.</span><span class="sxs-lookup"><span data-stu-id="111a8-144">A class inherits the members of its base class.</span></span> <span data-ttu-id="111a8-145">L’héritage signifie qu’une classe contient implicitement tous les membres de sa classe de base.</span><span class="sxs-lookup"><span data-stu-id="111a8-145">Inheritance means that a class implicitly contains almost all members of its base class.</span></span> <span data-ttu-id="111a8-146">Une classe n’hérite pas de l’instance et des constructeurs statiques, et du finaliseur.</span><span class="sxs-lookup"><span data-stu-id="111a8-146">A class doesn't inherit the instance and static constructors, and the finalizer.</span></span> <span data-ttu-id="111a8-147">Une classe dérivée peut ajouter de nouveaux membres aux membres qu’elle hérite, mais elle ne peut pas supprimer la définition d’un membre hérité.</span><span class="sxs-lookup"><span data-stu-id="111a8-147">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="111a8-148">Dans l’exemple précédent, `Point3D` hérite des `X` `Y` membres et de `Point` , et chaque `Point3D` instance contient trois propriétés, `X` , `Y` et `Z` .</span><span class="sxs-lookup"><span data-stu-id="111a8-148">In the previous example, `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.</span></span>

<span data-ttu-id="111a8-149">Il existe une conversion implicite d’un type de classe vers un de ses types de classe de base.</span><span class="sxs-lookup"><span data-stu-id="111a8-149">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="111a8-150">Une variable d’un type de classe peut référencer une instance de cette classe ou une instance de toute classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="111a8-150">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="111a8-151">Par exemple, pour les déclarations de classe précédentes, une variable de type `Point` peut faire référence à un objet `Point` ou `Point3D` :</span><span class="sxs-lookup"><span data-stu-id="111a8-151">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplicitCastToBase":::

## <a name="structs"></a><span data-ttu-id="111a8-152">Structs</span><span class="sxs-lookup"><span data-stu-id="111a8-152">Structs</span></span>

<span data-ttu-id="111a8-153">Les classes définissent des types qui prennent en charge l’héritage et le polymorphisme.</span><span class="sxs-lookup"><span data-stu-id="111a8-153">Classes define types that support inheritance and polymorphism.</span></span> <span data-ttu-id="111a8-154">Elles vous permettent de créer des comportements sophistiqués basés sur des hiérarchies de classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="111a8-154">They enable you to create sophisticated behaviors based on hierarchies of derived classes.</span></span> <span data-ttu-id="111a8-155">En revanche, les types [ \* **struct** _](../language-reference/builtin-types/struct.md) sont des types plus simples dont l’objectif principal est de stocker des valeurs de données.</span><span class="sxs-lookup"><span data-stu-id="111a8-155">By contrast, [\***struct** _](../language-reference/builtin-types/struct.md) types are simpler types whose primary purpose is to store data values.</span></span> <span data-ttu-id="111a8-156">Les structs ne peuvent pas déclarer un type de base ; ils dérivent implicitement de <xref:System.ValueType?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="111a8-156">Structs can't declare a base type; they implicitly derive from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="111a8-157">Vous ne pouvez pas dériver `struct` d’autres types à partir d’un `struct` type.</span><span class="sxs-lookup"><span data-stu-id="111a8-157">You can't derive other `struct` types from a `struct` type.</span></span> <span data-ttu-id="111a8-158">Ils sont implicitement sealed.</span><span class="sxs-lookup"><span data-stu-id="111a8-158">They're implicitly sealed.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointStruct":::

## <a name="interfaces"></a><span data-ttu-id="111a8-159">Interfaces</span><span class="sxs-lookup"><span data-stu-id="111a8-159">Interfaces</span></span>

<span data-ttu-id="111a8-160">Une [_*_interface_*_](../programming-guide/interfaces/index.md) définit un contrat qui peut être implémenté par des classes et des structs.</span><span class="sxs-lookup"><span data-stu-id="111a8-160">An [_*_interface_*_](../programming-guide/interfaces/index.md) defines a contract that can be implemented by classes and structs.</span></span> <span data-ttu-id="111a8-161">Une interface peut contenir des méthodes, des propriétés, des événements et des indexeurs.</span><span class="sxs-lookup"><span data-stu-id="111a8-161">An interface can contain methods, properties, events, and indexers.</span></span> <span data-ttu-id="111a8-162">En général, une interface ne fournit pas d’implémentations des membres qu’elle définit. elle spécifie simplement les membres qui doivent être fournis par les classes ou les structs qui implémentent l’interface.</span><span class="sxs-lookup"><span data-stu-id="111a8-162">An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.</span></span>

<span data-ttu-id="111a8-163">Les interfaces peuvent utiliser _*_l’héritage multiple_*_.</span><span class="sxs-lookup"><span data-stu-id="111a8-163">Interfaces may employ _*_multiple inheritance_*_.</span></span> <span data-ttu-id="111a8-164">Dans l’exemple suivant, l’interface `IComboBox` hérite à la fois de `ITextBox` et `IListBox`.</span><span class="sxs-lookup"><span data-stu-id="111a8-164">In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FirstInterfaces":::

<span data-ttu-id="111a8-165">Les classes et les structs peuvent implémenter plusieurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="111a8-165">Classes and structs can implement multiple interfaces.</span></span> <span data-ttu-id="111a8-166">Dans l’exemple suivant, la classe `EditBox` implémente à la fois `IControl` et `IDataBound`.</span><span class="sxs-lookup"><span data-stu-id="111a8-166">In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplementInterfaces":::

<span data-ttu-id="111a8-167">Lorsqu’une classe ou un struct implémente une interface spécifique, les instances de cette classe ou struct peuvent être converties implicitement en ce type d’interface.</span><span class="sxs-lookup"><span data-stu-id="111a8-167">When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type.</span></span> <span data-ttu-id="111a8-168">Par exemple</span><span class="sxs-lookup"><span data-stu-id="111a8-168">For example</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UseInterfaces":::

## <a name="enums"></a><span data-ttu-id="111a8-169">Énumérations</span><span class="sxs-lookup"><span data-stu-id="111a8-169">Enums</span></span>

<span data-ttu-id="111a8-170">Un type [_*_enum_*_](../language-reference/builtin-types/enum.md) définit un ensemble de valeurs constantes.</span><span class="sxs-lookup"><span data-stu-id="111a8-170">An [_*_Enum_*_](../language-reference/builtin-types/enum.md) type defines a set of constant values.</span></span> <span data-ttu-id="111a8-171">L’exemple suivant `enum` déclare des constantes qui définissent des légumes racines différents :</span><span class="sxs-lookup"><span data-stu-id="111a8-171">The following `enum` declares constants that define different root vegetables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="EnumDeclaration":::

<span data-ttu-id="111a8-172">Vous pouvez également définir un `enum` à utiliser en combinaison comme indicateurs.</span><span class="sxs-lookup"><span data-stu-id="111a8-172">You can also define an `enum` to be used in combination as flags.</span></span> <span data-ttu-id="111a8-173">La déclaration suivante déclare un jeu d’indicateurs pour les quatre saisons.</span><span class="sxs-lookup"><span data-stu-id="111a8-173">The following declaration declares a set of flags for the four seasons.</span></span> <span data-ttu-id="111a8-174">Toute combinaison de saisons peut être appliquée, y compris une `All` valeur qui inclut toutes les saisons :</span><span class="sxs-lookup"><span data-stu-id="111a8-174">Any combination of the seasons may be applied, including an `All` value that includes all seasons:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FlagsEnumDeclaration":::

<span data-ttu-id="111a8-175">L’exemple suivant montre des déclarations des deux énumérations précédentes :</span><span class="sxs-lookup"><span data-stu-id="111a8-175">The following example shows declarations of both the preceding enums:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UsingEnums":::

## <a name="nullable-types"></a><span data-ttu-id="111a8-176">Types Nullable</span><span class="sxs-lookup"><span data-stu-id="111a8-176">Nullable types</span></span>

<span data-ttu-id="111a8-177">Les variables de tout type peuvent être déclarées comme n' _*_acceptant pas les valeurs NULL_*_ ou _*_null_*_.</span><span class="sxs-lookup"><span data-stu-id="111a8-177">Variables of any type may be declared as _*_non-nullable_*_ or _*_nullable_*_.</span></span> <span data-ttu-id="111a8-178">Une variable Nullable peut contenir une `null` valeur supplémentaire, ce qui n’indique aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="111a8-178">A nullable variable can hold an additional `null` value, indicating no value.</span></span> <span data-ttu-id="111a8-179">Les types valeur Nullable (structs ou enums) sont représentés par <xref:System.Nullable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="111a8-179">Nullable Value types (structs or enums) are represented by <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="111a8-180">Les types référence non Nullable et Nullable sont représentés par le type référence sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="111a8-180">Non-nullable and Nullable Reference types are both represented by the underlying reference type.</span></span> <span data-ttu-id="111a8-181">La distinction est représentée par les métadonnées lues par le compilateur et certaines bibliothèques.</span><span class="sxs-lookup"><span data-stu-id="111a8-181">The distinction is represented by metadata read by the compiler and some libraries.</span></span> <span data-ttu-id="111a8-182">Le compilateur fournit des avertissements quand des références Nullable sont déréférencées sans avoir d’abord vérifié leur valeur par rapport à `null` .</span><span class="sxs-lookup"><span data-stu-id="111a8-182">The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`.</span></span> <span data-ttu-id="111a8-183">Le compilateur fournit également des avertissements lorsque des références non Nullable se voient affecter une valeur qui peut être `null` .</span><span class="sxs-lookup"><span data-stu-id="111a8-183">The compiler also provides warnings when non-nullable references are assigned a value that may be `null`.</span></span> <span data-ttu-id="111a8-184">L’exemple suivant déclare un _*_entier Nullable_*_, en l’initialisant à `null` .</span><span class="sxs-lookup"><span data-stu-id="111a8-184">The following example declares a _*_nullable int_*_, initializing it to `null`.</span></span> <span data-ttu-id="111a8-185">Ensuite, il définit la valeur sur `5` .</span><span class="sxs-lookup"><span data-stu-id="111a8-185">Then, it sets the value to `5`.</span></span> <span data-ttu-id="111a8-186">Il illustre le même concept avec une _*_chaîne Nullable_*_.</span><span class="sxs-lookup"><span data-stu-id="111a8-186">It demonstrates the same concept with a _*_nullable string_*_.</span></span> <span data-ttu-id="111a8-187">Pour plus d’informations, consultez [types valeur Nullable](../language-reference/builtin-types/nullable-value-types.md) et [types référence Nullable](../nullable-references.md).</span><span class="sxs-lookup"><span data-stu-id="111a8-187">For more information, see [nullable value types](../language-reference/builtin-types/nullable-value-types.md) and [nullable reference types](../nullable-references.md).</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareNullable":::

## <a name="tuples"></a><span data-ttu-id="111a8-188">Tuples</span><span class="sxs-lookup"><span data-stu-id="111a8-188">Tuples</span></span>

<span data-ttu-id="111a8-189">C# prend en charge les [_ *_tuples_* \*](../language-reference/builtin-types/value-tuples.md), qui fournit une syntaxe concise pour regrouper plusieurs éléments de données dans une structure de données légère.</span><span class="sxs-lookup"><span data-stu-id="111a8-189">C# supports [_ *_tuples_*\*](../language-reference/builtin-types/value-tuples.md), which provides concise syntax to group multiple data elements in a lightweight data structure.</span></span> <span data-ttu-id="111a8-190">Vous instanciez un tuple en déclarant les types et les noms des membres entre `(` et `)` , comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="111a8-190">You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareTuples":::

<span data-ttu-id="111a8-191">Les tuples offrent une alternative à la structure de données avec plusieurs membres, sans utiliser les blocs de construction décrits dans l’article suivant.</span><span class="sxs-lookup"><span data-stu-id="111a8-191">Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="111a8-192">[Précédent](index.md) 
> [Suivant](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="111a8-192">[Previous](index.md)
[Next](program-building-blocks.md)</span></span>
