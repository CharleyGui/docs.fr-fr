---
title: Les blocs de construction des programmes C#»
description: En savoir plus sur les membres, les expressions et les instructions C#. Les types contiennent des membres que vous écrivez. Ces membres sont générés à partir d’instructions et d’expressions.
ms.date: 08/06/2020
ms.openlocfilehash: 0ac45eee180b60062a328fca9ab5c63a1537debe
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216614"
---
# <a name="program-building-blocks"></a><span data-ttu-id="7a67a-105">Blocs de construction de programme</span><span class="sxs-lookup"><span data-stu-id="7a67a-105">Program building blocks</span></span>

<span data-ttu-id="7a67a-106">Les types décrits dans l’article précédent sont générés à l’aide des blocs de construction suivants : [ \* **members** _](../programming-guide/classes-and-structs/members.md), [ _*_expressions_*_ et _*_instructions_*_](../programming-guide/statements-expressions-operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="7a67a-106">The types described in the previous article are built using these building blocks: [\***members** _](../programming-guide/classes-and-structs/members.md), [_*_expressions_*_, and _*_statements_*_](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="7a67a-107">Membres</span><span class="sxs-lookup"><span data-stu-id="7a67a-107">Members</span></span>

<span data-ttu-id="7a67a-108">Les membres d’un `class` sont soit des membres _*_statiques_*_ , soit des _*_membres d’instance_*_.</span><span class="sxs-lookup"><span data-stu-id="7a67a-108">The members of a `class` are either _*_static members_*_ or _*_instance members_*_.</span></span> <span data-ttu-id="7a67a-109">Les membres statiques appartiennent à des classes, et les membres d’instance appartiennent à des objets (instances de classes).</span><span class="sxs-lookup"><span data-stu-id="7a67a-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="7a67a-110">La liste suivante fournit une vue d’ensemble des types de membres qu’une classe peut contenir.</span><span class="sxs-lookup"><span data-stu-id="7a67a-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="7a67a-111">_ \* Constantes \* \* : valeurs constantes associées à la classe</span><span class="sxs-lookup"><span data-stu-id="7a67a-111">_\*Constants\*\*: Constant values associated with the class</span></span>
- <span data-ttu-id="7a67a-112">**Fields**: variables associées à la classe</span><span class="sxs-lookup"><span data-stu-id="7a67a-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="7a67a-113">**Méthodes**: actions qui peuvent être effectuées par la classe</span><span class="sxs-lookup"><span data-stu-id="7a67a-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="7a67a-114">**Propriétés**: actions associées à la lecture et à l’écriture des propriétés nommées de la classe</span><span class="sxs-lookup"><span data-stu-id="7a67a-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="7a67a-115">**Indexeurs**: actions associées à l’indexation d’instances de la classe comme un tableau</span><span class="sxs-lookup"><span data-stu-id="7a67a-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="7a67a-116">**Événements**: notifications qui peuvent être générées par la classe</span><span class="sxs-lookup"><span data-stu-id="7a67a-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="7a67a-117">**Opérateurs**: conversions et opérateurs d’expression pris en charge par la classe</span><span class="sxs-lookup"><span data-stu-id="7a67a-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="7a67a-118">**Constructeurs**: actions requises pour initialiser des instances de la classe ou la classe elle-même</span><span class="sxs-lookup"><span data-stu-id="7a67a-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="7a67a-119">**Finaliseurs**: actions effectuées avant que les instances de la classe soient définitivement ignorées</span><span class="sxs-lookup"><span data-stu-id="7a67a-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="7a67a-120">**Types**: types imbriqués déclarés par la classe</span><span class="sxs-lookup"><span data-stu-id="7a67a-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="7a67a-121">Accessibilité</span><span class="sxs-lookup"><span data-stu-id="7a67a-121">Accessibility</span></span>

<span data-ttu-id="7a67a-122">Chaque membre d’une classe a une accessibilité associée, qui contrôle les zones de texte de programme qui peuvent accéder au membre.</span><span class="sxs-lookup"><span data-stu-id="7a67a-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="7a67a-123">Il existe six formes possibles d’accessibilité.</span><span class="sxs-lookup"><span data-stu-id="7a67a-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="7a67a-124">Les modificateurs d’accès sont résumés ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="7a67a-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="7a67a-125">`public`: L’accès n’est pas limité.</span><span class="sxs-lookup"><span data-stu-id="7a67a-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="7a67a-126">`private`: L’accès est limité à cette classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="7a67a-127">`protected`: L’accès est limité à cette classe ou aux classes dérivées de cette classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="7a67a-128">`internal`: L’accès est limité à l’assembly actuel ( `.exe` ou `.dll` ).</span><span class="sxs-lookup"><span data-stu-id="7a67a-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="7a67a-129">`protected internal`: L’accès est limité à cette classe, aux classes dérivées de cette classe ou aux classes au sein du même assembly.</span><span class="sxs-lookup"><span data-stu-id="7a67a-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="7a67a-130">`private protected`: L’accès est limité à cette classe ou aux classes dérivées de ce type dans le même assembly.</span><span class="sxs-lookup"><span data-stu-id="7a67a-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="7a67a-131">Champs</span><span class="sxs-lookup"><span data-stu-id="7a67a-131">Fields</span></span>

<span data-ttu-id="7a67a-132">Un *champ* est une variable qui est associée à une classe ou une instance d’une classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="7a67a-133">Un champ déclaré avec le modificateur static définit un champ statique.</span><span class="sxs-lookup"><span data-stu-id="7a67a-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="7a67a-134">Un champ statique identifie exactement un seul emplacement de stockage.</span><span class="sxs-lookup"><span data-stu-id="7a67a-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="7a67a-135">Quel que soit le nombre d’instances d’une classe qui sont créées, il n’y a qu’une seule copie d’un champ statique.</span><span class="sxs-lookup"><span data-stu-id="7a67a-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="7a67a-136">Un champ déclaré sans le modificateur static définit un champ d’instance.</span><span class="sxs-lookup"><span data-stu-id="7a67a-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="7a67a-137">Chaque instance d’une classe contient une copie distincte de tous les champs d’instance de cette classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="7a67a-138">Dans l’exemple suivant, chaque instance de la `Color` classe a une copie distincte des `R` champs d' `G` instance, et `B` , mais il n’existe qu’une seule copie des `Black` `White` `Red` `Green` `Blue` champs statiques,,, et :</span><span class="sxs-lookup"><span data-stu-id="7a67a-138">In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="7a67a-139">Comme indiqué dans l’exemple précédent, les *champs en lecture seule* peuvent être déclarés avec un modificateur `readonly`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="7a67a-140">L’assignation à un champ en lecture seule ne peut se produire que dans le cadre de la déclaration du champ ou dans un constructeur de la même classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="7a67a-141">Méthodes</span><span class="sxs-lookup"><span data-stu-id="7a67a-141">Methods</span></span>

<span data-ttu-id="7a67a-142">Une *méthode* est un membre qui implémente un calcul ou une action qui peut être effectuée par un objet ou une classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="7a67a-143">Les *méthodes statiques* sont accessibles à travers la classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="7a67a-144">Les *méthodes d’instance* sont accessibles via des instances de la classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="7a67a-145">Les méthodes peuvent avoir une liste de *paramètres*, qui représentent des valeurs ou des références variables passées à la méthode.</span><span class="sxs-lookup"><span data-stu-id="7a67a-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="7a67a-146">Les méthodes ont un *type de retour*, qui spécifie le type de la valeur calculée et retournée par la méthode.</span><span class="sxs-lookup"><span data-stu-id="7a67a-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="7a67a-147">Le type de retour d’une méthode est `void` s’il ne retourne pas de valeur.</span><span class="sxs-lookup"><span data-stu-id="7a67a-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="7a67a-148">Comme les types, les méthodes peuvent également être un jeu de paramètres de type pour lesquels les arguments de type doivent être spécifiés lorsque la méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="7a67a-149">Contrairement aux types, les arguments de type peuvent souvent être déduits à partir des arguments d’un appel de méthode et n’ont pas à être fournis explicitement.</span><span class="sxs-lookup"><span data-stu-id="7a67a-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="7a67a-150">La *signature* d’une méthode doit être unique dans la classe dans laquelle la méthode est déclarée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="7a67a-151">La signature d’une méthode se compose du nom de la méthode, du nombre de paramètres de type, du nombre, des modificateurs et des types de ses paramètres.</span><span class="sxs-lookup"><span data-stu-id="7a67a-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="7a67a-152">La signature d’une méthode n’inclut pas le type de retour.</span><span class="sxs-lookup"><span data-stu-id="7a67a-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="7a67a-153">Quand un corps de méthode est une expression unique, la méthode peut être définie à l’aide d’un format d’expression compact, comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="7a67a-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="7a67a-154">Paramètres</span><span class="sxs-lookup"><span data-stu-id="7a67a-154">Parameters</span></span>

<span data-ttu-id="7a67a-155">Les paramètres sont utilisés pour passer des valeurs ou des références variables aux méthodes.</span><span class="sxs-lookup"><span data-stu-id="7a67a-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="7a67a-156">Les paramètres d’une méthode obtiennent leurs valeurs réelles à partir des *arguments* qui sont spécifiés lorsque la méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="7a67a-157">Il existe quatre types de paramètres : les paramètres de valeur, les paramètres de référence, les paramètres de sortie et les tableaux de paramètres.</span><span class="sxs-lookup"><span data-stu-id="7a67a-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="7a67a-158">Un *paramètre de valeur* est utilisé pour passer des arguments en entrée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="7a67a-159">Un paramètre de valeur correspond à une variable locale qui obtient sa valeur initiale de l’argument qui a été transmis pour le paramètre.</span><span class="sxs-lookup"><span data-stu-id="7a67a-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="7a67a-160">Les modifications apportées à un paramètre de valeur n’affectent pas l’argument qui a été transmis pour le paramètre.</span><span class="sxs-lookup"><span data-stu-id="7a67a-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="7a67a-161">Les paramètres de valeur peuvent être facultatifs, en spécifiant une valeur par défaut afin que les arguments correspondants puissent être omis.</span><span class="sxs-lookup"><span data-stu-id="7a67a-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="7a67a-162">Un *paramètre de référence* est utilisé pour passer des arguments par référence.</span><span class="sxs-lookup"><span data-stu-id="7a67a-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="7a67a-163">L’argument passé pour un paramètre de référence doit être une variable avec une valeur définie.</span><span class="sxs-lookup"><span data-stu-id="7a67a-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="7a67a-164">Pendant l’exécution de la méthode, le paramètre de référence représente le même emplacement de stockage que la variable d’argument.</span><span class="sxs-lookup"><span data-stu-id="7a67a-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="7a67a-165">Un paramètre de référence est déclaré avec le modificateur `ref`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="7a67a-166">L'exemple suivant illustre l'utilisation des paramètres `ref`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="7a67a-167">Un *paramètre de sortie* est utilisé pour passer des arguments par référence.</span><span class="sxs-lookup"><span data-stu-id="7a67a-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="7a67a-168">Il est similaire à un paramètre de référence, sauf qu’il ne nécessite pas d’affecter explicitement une valeur à l’argument fourni par l’appelant.</span><span class="sxs-lookup"><span data-stu-id="7a67a-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="7a67a-169">Un paramètre de sortie est déclaré avec le modificateur `out`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="7a67a-170">L’exemple suivant montre l’utilisation de paramètres `out` à l’aide de la syntaxe introduite dans C# 7.</span><span class="sxs-lookup"><span data-stu-id="7a67a-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="7a67a-171">Un *tableau de paramètres* autorise le passage d’un nombre variable d’arguments à une méthode.</span><span class="sxs-lookup"><span data-stu-id="7a67a-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="7a67a-172">Un tableau de paramètres est déclaré avec le modificateur `params`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="7a67a-173">Seul le dernier paramètre d’une méthode peut être un tableau de paramètres, et le type d’un tableau de paramètres doit être un type tableau unidimensionnel.</span><span class="sxs-lookup"><span data-stu-id="7a67a-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="7a67a-174">Les `Write` `WriteLine` méthodes et de la <xref:System.Console?displayProperty=nameWithType> classe sont de bons exemples d’utilisation des tableaux de paramètres.</span><span class="sxs-lookup"><span data-stu-id="7a67a-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="7a67a-175">Elles sont déclarées comme suit.</span><span class="sxs-lookup"><span data-stu-id="7a67a-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="7a67a-176">Dans une méthode qui utilise un tableau de paramètres, le tableau de paramètres se comporte exactement comme un paramètre ordinaire de type tableau.</span><span class="sxs-lookup"><span data-stu-id="7a67a-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="7a67a-177">Toutefois, dans un appel d’une méthode avec un tableau de paramètres, il est possible de passer un argument unique du type de tableau de paramètres ou un nombre quelconque d’arguments du type d’élément du tableau de paramètres.</span><span class="sxs-lookup"><span data-stu-id="7a67a-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="7a67a-178">Dans ce cas, une instance de tableau est automatiquement créée et initialisée avec les arguments donnés.</span><span class="sxs-lookup"><span data-stu-id="7a67a-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="7a67a-179">Cet exemple</span><span class="sxs-lookup"><span data-stu-id="7a67a-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="7a67a-180">revient à écrire ce qui suit.</span><span class="sxs-lookup"><span data-stu-id="7a67a-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="7a67a-181">Corps de la méthode et variables locales</span><span class="sxs-lookup"><span data-stu-id="7a67a-181">Method body and local variables</span></span>

<span data-ttu-id="7a67a-182">Le corps d’une méthode spécifie les instructions à exécuter lorsque la méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="7a67a-183">Un corps de méthode peut déclarer des variables qui sont spécifiques à l’appel de la méthode.</span><span class="sxs-lookup"><span data-stu-id="7a67a-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="7a67a-184">Ces variables sont appelées *variables locales*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="7a67a-185">Une déclaration de variable locale spécifie un nom de type, un nom de variable et éventuellement une valeur initiale.</span><span class="sxs-lookup"><span data-stu-id="7a67a-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="7a67a-186">L’exemple suivant déclare une variable locale `i` avec une valeur initiale de zéro et une variable locale `j` sans valeur initiale.</span><span class="sxs-lookup"><span data-stu-id="7a67a-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="7a67a-187">C# requiert qu’une variable locale soit *assignée de manière définitive* avant de pouvoir obtenir sa valeur.</span><span class="sxs-lookup"><span data-stu-id="7a67a-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="7a67a-188">Par exemple, si la déclaration de la précédente `i` n’inclut pas de valeur initiale, le compilateur signale une erreur pour les utilisations ultérieures de, `i` car n' `i` est pas définitivement assignée à ces points dans le programme.</span><span class="sxs-lookup"><span data-stu-id="7a67a-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="7a67a-189">Une méthode peut utiliser les instructions `return` pour retourner le contrôle à son appelant.</span><span class="sxs-lookup"><span data-stu-id="7a67a-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="7a67a-190">Dans une méthode retournant `void` , les `return` instructions ne peuvent pas spécifier une expression.</span><span class="sxs-lookup"><span data-stu-id="7a67a-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="7a67a-191">Dans une méthode avec un type de retour non void, les instructions `return` doivent inclure une expression qui calcule la valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="7a67a-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="7a67a-192">Méthodes statiques et d’instance</span><span class="sxs-lookup"><span data-stu-id="7a67a-192">Static and instance methods</span></span>

<span data-ttu-id="7a67a-193">Une méthode déclarée avec un `static` modificateur est une *méthode statique*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="7a67a-194">Une méthode statique ne fonctionne pas sur une instance spécifique et peut uniquement accéder directement aux membres statiques.</span><span class="sxs-lookup"><span data-stu-id="7a67a-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="7a67a-195">Une méthode déclarée sans `static` modificateur est une *méthode d’instance*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="7a67a-196">Une méthode d’instance opère sur une instance spécifique et peut accéder aux membres statiques et d’instance.</span><span class="sxs-lookup"><span data-stu-id="7a67a-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="7a67a-197">L’instance sur laquelle une méthode d’instance a été appelée est explicitement accessible en tant que `this`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="7a67a-198">Il s’agit d’une erreur qui consiste à faire référence à `this` dans une méthode statique.</span><span class="sxs-lookup"><span data-stu-id="7a67a-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="7a67a-199">La classe `Entity` suivante a à la fois des statiques et des membres d’instance.</span><span class="sxs-lookup"><span data-stu-id="7a67a-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="7a67a-200">Chaque `Entity` instance contient un numéro de série (et probablement d’autres informations qui ne sont pas indiquées ici).</span><span class="sxs-lookup"><span data-stu-id="7a67a-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="7a67a-201">Le constructeur `Entity` (qui est similaire à une méthode d’instance) initialise la nouvelle instance avec le numéro de série suivant.</span><span class="sxs-lookup"><span data-stu-id="7a67a-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="7a67a-202">Étant donné que le constructeur est un membre d’instance, il est autorisé à accéder à la fois au `_serialNo` champ d’instance et au `s_nextSerialNo` champ statique.</span><span class="sxs-lookup"><span data-stu-id="7a67a-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="7a67a-203">Les méthodes statiques `GetNextSerialNo` et `SetNextSerialNo` peuvent accéder au champ statique `s_nextSerialNo`, mais ce serait une erreur pour eux d’accéder directement au champ d’instance `_serialNo`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="7a67a-204">L’exemple suivant illustre l’utilisation de la `Entity` classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="7a67a-205">Les `SetNextSerialNo` `GetNextSerialNo` méthodes statiques et sont appelées sur la classe, tandis que la `GetSerialNo` méthode d’instance est appelée sur des instances de la classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="7a67a-206">Méthodes virtuelles, de substitution et abstraites</span><span class="sxs-lookup"><span data-stu-id="7a67a-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="7a67a-207">Lorsqu’une déclaration de méthode d’instance inclut un modificateur `virtual`, la méthode est appelée *méthode virtuelle*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="7a67a-208">Si aucun modificateur virtuel n’est présent, la méthode est appelée *méthode non virtuelle*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="7a67a-209">Lorsqu’une méthode virtuelle est appelée, le *type au moment de l’exécution* de l’instance pour laquelle cet appel prend place détermine l’implémentation de méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="7a67a-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="7a67a-210">Dans un appel de méthode non virtuelle, le *type lors de la compilation* de l’instance est le facteur déterminant.</span><span class="sxs-lookup"><span data-stu-id="7a67a-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="7a67a-211">Une méthode virtuelle peut être *substituée* dans une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="7a67a-212">Lorsqu’une déclaration de méthode d’instance comprend un modificateur override, la méthode substitue une méthode virtuelle héritée ayant la même signature.</span><span class="sxs-lookup"><span data-stu-id="7a67a-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="7a67a-213">Une déclaration de méthode virtuelle introduit une nouvelle méthode.</span><span class="sxs-lookup"><span data-stu-id="7a67a-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="7a67a-214">Une déclaration de méthode override spécialise une méthode virtuelle héritée existante en fournissant une nouvelle implémentation de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="7a67a-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="7a67a-215">Une *méthode abstraite* est une méthode virtuelle sans implémentation.</span><span class="sxs-lookup"><span data-stu-id="7a67a-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="7a67a-216">Une méthode abstraite est déclarée avec le `abstract` modificateur et est autorisée uniquement dans une classe abstraite.</span><span class="sxs-lookup"><span data-stu-id="7a67a-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="7a67a-217">Une méthode abstraite doit être remplacée dans chaque classe dérivée non abstraite.</span><span class="sxs-lookup"><span data-stu-id="7a67a-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="7a67a-218">L’exemple suivant déclare une classe abstraite, `Expression`, qui représente un nœud d’arborescence de l’expression et trois classes dérivées, `Constant`, `VariableReference` et `Operation`, qui implémentent des nœuds d’arborescence de l’expression pour les références variables, les constantes et les opérations arithmétiques.</span><span class="sxs-lookup"><span data-stu-id="7a67a-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="7a67a-219">(Cet exemple est similaire à, mais n’est pas associé aux types d’arborescence d’expression).</span><span class="sxs-lookup"><span data-stu-id="7a67a-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="7a67a-220">Les quatre classes précédentes permet de modéliser des expressions arithmétiques.</span><span class="sxs-lookup"><span data-stu-id="7a67a-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="7a67a-221">Par exemple, en utilisant des instances de ces classes, l’expression `x + 3` peut être représentée comme suit.</span><span class="sxs-lookup"><span data-stu-id="7a67a-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="7a67a-222">La méthode `Evaluate` d’une instance `Expression` est appelée pour évaluer l’expression donnée et produire une valeur `double`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="7a67a-223">La méthode prend un argument `Dictionary` qui contient des noms de variables (comme clés des entrées) et des valeurs (comme valeurs des entrées).</span><span class="sxs-lookup"><span data-stu-id="7a67a-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="7a67a-224">Comme `Evaluate` est une méthode abstraite, les classes non abstraites dérivées de `Expression` doivent remplacer `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="7a67a-225">Une implémentation de `Constant` de `Evaluate` renvoie simplement la constante stockée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="7a67a-226">Une implémentation de `VariableReference` recherche le nom de variable dans le dictionnaire et renvoie la valeur résultante.</span><span class="sxs-lookup"><span data-stu-id="7a67a-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="7a67a-227">Une implémentation de `Operation` évalue d’abord les opérandes de gauche et de droite (en appelant de manière récursive leurs méthodes `Evaluate`), puis effectue l’opération arithmétique donnée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="7a67a-228">Le programme suivant utilise les classes `Expression` pour évaluer l’expression `x * (y + 2)` pour différentes valeurs de `x` et `y`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="7a67a-229">Surcharge de méthode</span><span class="sxs-lookup"><span data-stu-id="7a67a-229">Method overloading</span></span>

<span data-ttu-id="7a67a-230">La *surcharge* de méthode permet d’avoir plusieurs méthodes dans la même classe avec le même nom, tant qu’elles ont des signatures uniques.</span><span class="sxs-lookup"><span data-stu-id="7a67a-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="7a67a-231">Lors de la compilation d’un appel à une méthode surchargée, le compilateur utilise *la résolution de surcharge* pour déterminer la méthode spécifique à appeler.</span><span class="sxs-lookup"><span data-stu-id="7a67a-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="7a67a-232">La résolution de surcharge recherche l’unique méthode qui correspond le mieux aux arguments.</span><span class="sxs-lookup"><span data-stu-id="7a67a-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="7a67a-233">Si aucune meilleure correspondance ne peut être trouvée, une erreur est signalée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="7a67a-234">L’exemple suivant montre la résolution de surcharge en action.</span><span class="sxs-lookup"><span data-stu-id="7a67a-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="7a67a-235">Le commentaire pour chaque appel de la `UsageExample` méthode indique la méthode appelée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="7a67a-236">Comme indiqué dans l’exemple, une méthode particulière peut toujours être sélectionnée en effectuant un cast explicite des arguments vers les types de paramètres et les arguments de type exacts.</span><span class="sxs-lookup"><span data-stu-id="7a67a-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="7a67a-237">Autres fonctions membres</span><span class="sxs-lookup"><span data-stu-id="7a67a-237">Other function members</span></span>

<span data-ttu-id="7a67a-238">Les membres qui contiennent du code exécutable sont collectivement regroupés sous les *membres de fonction* d’une classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="7a67a-239">La section précédente décrit les méthodes, qui sont les principaux types de fonctions membres.</span><span class="sxs-lookup"><span data-stu-id="7a67a-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="7a67a-240">Cette section décrit les autres types de fonctions membres pris en charge par C# : constructeurs, propriétés, indexeurs, événements, opérateurs et finaliseurs.</span><span class="sxs-lookup"><span data-stu-id="7a67a-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="7a67a-241">L’exemple suivant montre une classe générique appelée `MyList<T>` , qui implémente une liste d’objets pouvant être augmentée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="7a67a-242">La classe contient plusieurs exemples des types les plus courants de membres de fonction.</span><span class="sxs-lookup"><span data-stu-id="7a67a-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="7a67a-243">Constructeurs</span><span class="sxs-lookup"><span data-stu-id="7a67a-243">Constructors</span></span>

<span data-ttu-id="7a67a-244">C# prend en charge les constructeurs statiques et d’instance.</span><span class="sxs-lookup"><span data-stu-id="7a67a-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="7a67a-245">Un *constructeur d’instance* est un membre qui implémente les actions requises pour initialiser une instance d’une classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="7a67a-246">Un *constructeur statique* est un membre qui implémente les actions requises pour initialiser une classe lorsqu’elle est chargée pour la première fois.</span><span class="sxs-lookup"><span data-stu-id="7a67a-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="7a67a-247">Un constructeur est déclaré comme une méthode sans aucun type de retour et le même nom que la classe contenante.</span><span class="sxs-lookup"><span data-stu-id="7a67a-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="7a67a-248">Si une déclaration de constructeur comprend un `static` modificateur, elle déclare un constructeur statique.</span><span class="sxs-lookup"><span data-stu-id="7a67a-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="7a67a-249">Dans le cas contraire, elle déclare un constructeur d’instance.</span><span class="sxs-lookup"><span data-stu-id="7a67a-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="7a67a-250">Les constructeurs d’instance peuvent être surchargés et avoir des paramètres facultatifs.</span><span class="sxs-lookup"><span data-stu-id="7a67a-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="7a67a-251">Par exemple, la classe `MyList<T>` déclare un constructeur d’instance avec un seul paramètre `int` facultatif.</span><span class="sxs-lookup"><span data-stu-id="7a67a-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="7a67a-252">Les constructeurs d’instance sont appelés en utilisant l’opérateur `new`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="7a67a-253">Les instructions suivantes allouent deux instances `MyList<string>` à l’aide du constructeur de la classe `MyList` avec et sans l’argument facultatif.</span><span class="sxs-lookup"><span data-stu-id="7a67a-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="7a67a-254">Contrairement aux autres membres, les constructeurs d’instance ne sont pas hérités.</span><span class="sxs-lookup"><span data-stu-id="7a67a-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="7a67a-255">Une classe n’a pas de constructeurs d’instance autres que ceux qui sont réellement déclarés dans la classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="7a67a-256">Si aucun constructeur d’instance n’est fourni pour une classe, un constructeur vide sans paramètre est fourni automatiquement.</span><span class="sxs-lookup"><span data-stu-id="7a67a-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="7a67a-257">Propriétés</span><span class="sxs-lookup"><span data-stu-id="7a67a-257">Properties</span></span>

<span data-ttu-id="7a67a-258">Les *propriétés* sont une extension naturelle des champs.</span><span class="sxs-lookup"><span data-stu-id="7a67a-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="7a67a-259">Les deux sont des membres nommés avec des types associés, et la syntaxe pour accéder aux champs et propriétés est la même.</span><span class="sxs-lookup"><span data-stu-id="7a67a-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="7a67a-260">Toutefois, contrairement aux champs, les propriétés ne désignent pas les emplacements de stockage.</span><span class="sxs-lookup"><span data-stu-id="7a67a-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="7a67a-261">Au lieu de cela, les propriétés ont des *accesseurs* qui spécifient les instructions exécutées lorsque leurs valeurs sont lues ou écrites.</span><span class="sxs-lookup"><span data-stu-id="7a67a-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="7a67a-262">Une propriété est déclarée comme un champ, sauf que la déclaration se termine par un accesseur Get ou un accesseur Set écrit entre les délimiteurs `{` et `}` au lieu de se terminer par un point-virgule.</span><span class="sxs-lookup"><span data-stu-id="7a67a-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="7a67a-263">Une propriété qui a à la fois un accesseur get et un accesseur Set est une *propriété en lecture-écriture*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-263">A property that has both a get accessor and a set accessor is a *read-write property*.</span></span> <span data-ttu-id="7a67a-264">Une propriété qui possède uniquement un accesseur Get est une *propriété en lecture seule*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-264">A property that has only a get accessor is a *read-only property*.</span></span> <span data-ttu-id="7a67a-265">Une propriété qui a uniquement un accesseur Set est une *propriété en écriture seule*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-265">A property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="7a67a-266">Un accesseur get correspond à une méthode sans paramètre avec une valeur de retour du type de la propriété.</span><span class="sxs-lookup"><span data-stu-id="7a67a-266">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="7a67a-267">Un accesseur set correspond à une méthode avec un paramètre unique nommé valeur et aucun type de retour.</span><span class="sxs-lookup"><span data-stu-id="7a67a-267">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="7a67a-268">L’accesseur Get calcule la valeur de la propriété.</span><span class="sxs-lookup"><span data-stu-id="7a67a-268">The get accessor computes the value of the property.</span></span> <span data-ttu-id="7a67a-269">L’accesseur Set fournit une nouvelle valeur pour la propriété.</span><span class="sxs-lookup"><span data-stu-id="7a67a-269">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="7a67a-270">Lorsque la propriété est la cible d’une assignation, ou l’opérande de `++` ou `--` , l’accesseur Set est appelé.</span><span class="sxs-lookup"><span data-stu-id="7a67a-270">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="7a67a-271">Dans les autres cas où la propriété est référencée, l’accesseur Get est appelé.</span><span class="sxs-lookup"><span data-stu-id="7a67a-271">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="7a67a-272">La classe `MyList<T>` déclare deux propriétés, `Count` et `Capacity`, qui sont respectivement en lecture seule et en lecture-écriture.</span><span class="sxs-lookup"><span data-stu-id="7a67a-272">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="7a67a-273">Le code suivant est un exemple d’utilisation de ces propriétés :</span><span class="sxs-lookup"><span data-stu-id="7a67a-273">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="7a67a-274">C# prend en charge les propriétés d’instance et les propriétés statiques, similaires aux champs et aux méthodes.</span><span class="sxs-lookup"><span data-stu-id="7a67a-274">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="7a67a-275">Les propriétés statiques sont déclarées avec le modificateur static, et les propriétés d’instance sont déclarées sans.</span><span class="sxs-lookup"><span data-stu-id="7a67a-275">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="7a67a-276">Le ou les accesseurs d’une propriété peuvent être virtuels.</span><span class="sxs-lookup"><span data-stu-id="7a67a-276">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="7a67a-277">Lorsqu’une déclaration de propriété inclut un modificateur `virtual`, `abstract` ou `override`, elle s’applique aux accesseurs de la propriété.</span><span class="sxs-lookup"><span data-stu-id="7a67a-277">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="7a67a-278">Indexeurs</span><span class="sxs-lookup"><span data-stu-id="7a67a-278">Indexers</span></span>

<span data-ttu-id="7a67a-279">Un *indexeur* est un membre qui permet l’indexation des objets de la même façon en tant que tableau.</span><span class="sxs-lookup"><span data-stu-id="7a67a-279">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="7a67a-280">Un indexeur est déclaré comme une propriété, sauf que le nom du membre est `this`, suivi d’une liste de paramètres écrits entre les délimiteurs `[` et `]`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-280">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="7a67a-281">Les paramètres sont disponibles dans le ou les accesseurs de l’indexeur.</span><span class="sxs-lookup"><span data-stu-id="7a67a-281">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="7a67a-282">Similaires aux propriétés, les indexeurs peuvent être en lecture-écriture, en lecture seule et en écriture seule, et les accesseurs d’un indexeur peuvent être virtuels.</span><span class="sxs-lookup"><span data-stu-id="7a67a-282">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="7a67a-283">La classe `MyList<T>` déclare un indexeur en lecture-écriture unique qui prend un paramètre `int`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-283">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="7a67a-284">L’indexeur rend possible l’indexation des instances `MyList<T>` avec des valeurs `int`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-284">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="7a67a-285">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="7a67a-285">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="7a67a-286">Les indexeurs peuvent être surchargés.</span><span class="sxs-lookup"><span data-stu-id="7a67a-286">Indexers can be overloaded.</span></span> <span data-ttu-id="7a67a-287">Une classe peut déclarer plusieurs indexeurs tant que le nombre ou les types de leurs paramètres diffèrent.</span><span class="sxs-lookup"><span data-stu-id="7a67a-287">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="7a67a-288">Événements</span><span class="sxs-lookup"><span data-stu-id="7a67a-288">Events</span></span>

<span data-ttu-id="7a67a-289">Un *événement* est un membre qui permet à une classe ou un objet de fournir des notifications.</span><span class="sxs-lookup"><span data-stu-id="7a67a-289">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="7a67a-290">Un événement est déclaré comme un champ, sauf que la déclaration comprend un `event` mot clé et que le type doit être un type délégué.</span><span class="sxs-lookup"><span data-stu-id="7a67a-290">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="7a67a-291">Dans une classe qui déclare un membre d’événement, l’événement se comporte de la même façon qu’un champ d’un type délégué (à condition que l’événement ne soit pas abstrait et ne déclare pas d’accesseurs).</span><span class="sxs-lookup"><span data-stu-id="7a67a-291">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="7a67a-292">Le champ stocke une référence à un délégué qui représente les gestionnaires d’événements qui ont été ajoutés à l’événement.</span><span class="sxs-lookup"><span data-stu-id="7a67a-292">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="7a67a-293">Si aucun gestionnaire d’événements n’est présent, le champ est `null`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-293">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="7a67a-294">La classe `MyList<T>` déclare un membre d’événement unique appelé `Changed`, qui indique qu’un nouvel élément a été ajouté à la liste.</span><span class="sxs-lookup"><span data-stu-id="7a67a-294">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="7a67a-295">L’événement Changed est déclenché par la méthode virtuelle `OnChanged`, qui vérifie si l’événement est `null` (ce qui signifie qu’aucun gestionnaire n’est présent).</span><span class="sxs-lookup"><span data-stu-id="7a67a-295">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="7a67a-296">La notion de déclenchement d’un événement est équivalente précisément à l’appel du délégué représenté par l’événement.</span><span class="sxs-lookup"><span data-stu-id="7a67a-296">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="7a67a-297">Il n’existe aucune construction de langage spéciale pour déclencher des événements.</span><span class="sxs-lookup"><span data-stu-id="7a67a-297">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="7a67a-298">Les clients réagissent aux événements via les *gestionnaires d’événements*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-298">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="7a67a-299">Les gestionnaires d’événements sont joints à l’aide de l’opérateur `+=` et supprimés à l’aide de l’opérateur `-=`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-299">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="7a67a-300">L'exemple suivant joint un gestionnaire d'événements à l'événement `Changed` d’un `MyList<string>`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-300">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="7a67a-301">Pour les scénarios avancés où le contrôle du stockage sous-jacent d’un événement est souhaité, une déclaration d’événement peut fournir explicitement des `add` `remove` accesseurs et, qui sont similaires à l' `set` accesseur d’une propriété.</span><span class="sxs-lookup"><span data-stu-id="7a67a-301">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="7a67a-302">Opérateurs</span><span class="sxs-lookup"><span data-stu-id="7a67a-302">Operators</span></span>

<span data-ttu-id="7a67a-303">Un *opérateur* est un membre qui définit la signification de l’application d’un opérateur d’expression particulière aux instances d’une classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-303">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="7a67a-304">Trois types d’opérateurs peuvent être définis : les opérateurs unaires, les opérateurs binaires et les opérateurs de conversion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-304">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="7a67a-305">Tous les opérateurs doivent être déclarés comme `public` et `static`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-305">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="7a67a-306">La `MyList<T>` classe déclare deux opérateurs, `operator ==` et `operator !=` .</span><span class="sxs-lookup"><span data-stu-id="7a67a-306">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="7a67a-307">Ces opérateurs substitués donnent une nouvelle signification aux expressions qui appliquent ces opérateurs aux `MyList` instances.</span><span class="sxs-lookup"><span data-stu-id="7a67a-307">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="7a67a-308">Plus précisément, les opérateurs définissent l’égalité de deux `MyList<T>` instances en comparant chacun des objets contenus à l’aide de leurs `Equals` méthodes.</span><span class="sxs-lookup"><span data-stu-id="7a67a-308">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="7a67a-309">L’exemple suivant utilise l’opérateur `==` pour comparer deux instances de `MyList<int>`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-309">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="7a67a-310">La première `Console.WriteLine` génère `True`, car les deux listes contiennent le même nombre d’objets avec les mêmes valeurs dans le même ordre.</span><span class="sxs-lookup"><span data-stu-id="7a67a-310">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="7a67a-311">Si `MyList<T>` n’avait pas défini `operator ==`, la première `Console.WriteLine` aurait affiché `False`, car `a` et `b` référencent des instances `MyList<int>` différentes.</span><span class="sxs-lookup"><span data-stu-id="7a67a-311">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="7a67a-312">Finaliseurs</span><span class="sxs-lookup"><span data-stu-id="7a67a-312">Finalizers</span></span>

<span data-ttu-id="7a67a-313">Un *finaliseur* est un membre qui implémente les actions requises pour finaliser une instance d’une classe.</span><span class="sxs-lookup"><span data-stu-id="7a67a-313">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="7a67a-314">En règle générale, un finaliseur est nécessaire pour libérer des ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="7a67a-314">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="7a67a-315">Les finaliseurs ne peuvent pas avoir de paramètres, ils ne peuvent pas avoir de modificateurs d’accessibilité et ils ne peuvent pas être appelés explicitement.</span><span class="sxs-lookup"><span data-stu-id="7a67a-315">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="7a67a-316">Le finaliseur pour une instance est appelé automatiquement lors du nettoyage de la mémoire (garbage collection).</span><span class="sxs-lookup"><span data-stu-id="7a67a-316">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="7a67a-317">Pour plus d’informations, consultez l’article sur les [finaliseurs](../programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="7a67a-317">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="7a67a-318">Le récupérateur de mémoire est libre de déterminer quand collecter des objets et exécuter des finaliseurs.</span><span class="sxs-lookup"><span data-stu-id="7a67a-318">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="7a67a-319">Plus précisément, le minutage des appels du finaliseur n’est pas déterministe, et les finaliseurs peuvent être exécutés sur n’importe quel thread.</span><span class="sxs-lookup"><span data-stu-id="7a67a-319">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="7a67a-320">Pour ces raisons et d’autres, les classes doivent implémenter des finaliseurs uniquement lorsqu’aucune des autres solutions n’est envisageable.</span><span class="sxs-lookup"><span data-stu-id="7a67a-320">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="7a67a-321">L’instruction `using` fournit une meilleure approche pour la destruction d’objets.</span><span class="sxs-lookup"><span data-stu-id="7a67a-321">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="7a67a-322">Expressions</span><span class="sxs-lookup"><span data-stu-id="7a67a-322">Expressions</span></span>

<span data-ttu-id="7a67a-323">Les *expressions* sont construites à partir de *d’opérandes* et *d’opérateurs*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-323">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="7a67a-324">Les opérateurs d’une expression indiquent les opérations à appliquer aux opérandes.</span><span class="sxs-lookup"><span data-stu-id="7a67a-324">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="7a67a-325">Parmi les exemples d’opérateurs figurent `+`, `-`, `*`, `/` et `new`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-325">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="7a67a-326">Les littéraux, les champs, les variables locales et les expressions sont des exemples d’opérandes.</span><span class="sxs-lookup"><span data-stu-id="7a67a-326">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="7a67a-327">Quand une expression contient plusieurs opérateurs, la *priorité* des opérateurs contrôle l’ordre dans lequel ils sont évalués.</span><span class="sxs-lookup"><span data-stu-id="7a67a-327">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="7a67a-328">Par exemple, l’expression `x + y * z` est évaluée comme `x + (y * z)`, car l’opérateur `*` a une priorité plus élevée que `+`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-328">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="7a67a-329">Lorsqu’un opérande se produit entre deux opérateurs de même priorité, *l’associativité* des opérateurs détermine l’ordre dans lequel les opérations sont effectuées :</span><span class="sxs-lookup"><span data-stu-id="7a67a-329">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="7a67a-330">À l’exception des opérateurs d’assignation et de fusion Null, tous les opérateurs binaires sont *associatifs à gauche*, ce qui signifie que les opérations sont effectuées de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="7a67a-330">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="7a67a-331">Par exemple, `x + y + z` est évalué comme étant `(x + y) + z`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-331">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="7a67a-332">Les opérateurs d’assignation, les opérateurs de fusion Null `??` et `??=` l’opérateur conditionnel `?:` sont *associatifs à droite*, ce qui signifie que les opérations sont exécutées de droite à gauche.</span><span class="sxs-lookup"><span data-stu-id="7a67a-332">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="7a67a-333">Par exemple, `x = y = z` est évalué comme étant `x = (y = z)`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-333">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="7a67a-334">La priorité et l’associativité peuvent être contrôlées à l’aide de parenthèses.</span><span class="sxs-lookup"><span data-stu-id="7a67a-334">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="7a67a-335">Par exemple, `x + y * z` multiplie d’abord `y` par `z`, puis ajoute le résultat à `x`, mais `(x + y) * z` ajoute d’abord `x` et `y`, puis multiplie le résultat par `z`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-335">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="7a67a-336">La plupart des opérateurs peuvent être [*surchargés*](../language-reference/operators/operator-overloading.md).</span><span class="sxs-lookup"><span data-stu-id="7a67a-336">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="7a67a-337">La surcharge d’opérateur autorise la spécification d’implémentations d’opérateurs définies par l’utilisateur pour les opérations où l’un des deux opérandes ou les deux sont d’un type classe ou struct défini par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="7a67a-337">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="7a67a-338">C# met à votre disposition de nombreux opérateurs pour effectuer des opérations [arithmétiques](../language-reference/operators/arithmetic-operators.md), [logiques](../language-reference/operators/boolean-logical-operators.md), [au niveau du bit et de décalage](../language-reference/operators/bitwise-and-shift-operators.md) et des comparaisons d’[égalité](../language-reference/operators/equality-operators.md) et d’[ordre](../language-reference/operators/comparison-operators.md) .</span><span class="sxs-lookup"><span data-stu-id="7a67a-338">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="7a67a-339">Pour obtenir la liste complète des opérateurs C# classés par niveau de priorité, consultez [Opérateurs C#](../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="7a67a-339">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="7a67a-340">Instructions</span><span class="sxs-lookup"><span data-stu-id="7a67a-340">Statements</span></span>

<span data-ttu-id="7a67a-341">Les actions d’un programme sont exprimées à l’aide *d’instructions*.</span><span class="sxs-lookup"><span data-stu-id="7a67a-341">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="7a67a-342">C# prend en charge plusieurs types d’instructions, dont plusieurs sont définies en termes d’instructions incorporées.</span><span class="sxs-lookup"><span data-stu-id="7a67a-342">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="7a67a-343">Un *bloc* autorise l’écriture de plusieurs instructions dans les contextes où une seule instruction est autorisée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-343">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="7a67a-344">Un bloc se compose d’une liste d’instructions écrites entre les délimiteurs `{` et `}`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-344">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="7a67a-345">Les *instructions de déclaration* sont utilisées pour déclarer des variables locales et des constantes.</span><span class="sxs-lookup"><span data-stu-id="7a67a-345">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="7a67a-346">Les *instructions d’expression* sont utilisées pour évaluer des expressions.</span><span class="sxs-lookup"><span data-stu-id="7a67a-346">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="7a67a-347">Les expressions qui peuvent être utilisées en tant qu’instructions comprennent les appels de méthode, les allocations d’objet avec l’opérateur `new`, les affectations avec `=` et les opérateurs d’assignation composée, les opérations d’incrémentation et de décrémentation à l’aide des opérateurs `++` et `--` et les expressions `await`.</span><span class="sxs-lookup"><span data-stu-id="7a67a-347">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="7a67a-348">Les *instructions de sélection* sont utilisées pour sélectionner un nombre d’instructions possibles pour l’exécution en fonction de la valeur d’une expression.</span><span class="sxs-lookup"><span data-stu-id="7a67a-348">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="7a67a-349">Ce groupe contient les `if` `switch` instructions et.</span><span class="sxs-lookup"><span data-stu-id="7a67a-349">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="7a67a-350">Les *instructions d’itération* servent à exécuter à plusieurs reprises une instruction incorporée.</span><span class="sxs-lookup"><span data-stu-id="7a67a-350">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="7a67a-351">Ce groupe contient les `while` `do` instructions,, `for` et `foreach` .</span><span class="sxs-lookup"><span data-stu-id="7a67a-351">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="7a67a-352">Les *instructions de saut* sont utilisées pour transférer le contrôle.</span><span class="sxs-lookup"><span data-stu-id="7a67a-352">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="7a67a-353">Ce groupe contient les `break` `continue` instructions,, `goto` , `throw` , `return` et `yield` .</span><span class="sxs-lookup"><span data-stu-id="7a67a-353">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="7a67a-354">L’instruction `try`...`catch` est utilisée pour intercepter les exceptions qui se produisent pendant l’exécution d’un bloc, et l’instruction `try`...`finally` permet de spécifier que le code de finalisation est toujours exécuté, qu’une exception se soit produite ou non.</span><span class="sxs-lookup"><span data-stu-id="7a67a-354">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="7a67a-355">Les instructions `checked` et `unchecked` permettent de contrôler le contexte de dépassement de capacité pour les conversions et les opérations arithmétiques de type intégral.</span><span class="sxs-lookup"><span data-stu-id="7a67a-355">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="7a67a-356">L’instruction `lock` est utilisée pour obtenir le verrou d’exclusion mutuelle pour un objet donné, exécuter une instruction, puis libérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="7a67a-356">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="7a67a-357">L’instruction `using` est utilisée pour obtenir une ressource, exécuter une instruction puis supprimer cette ressource.</span><span class="sxs-lookup"><span data-stu-id="7a67a-357">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="7a67a-358">La liste suivante répertorie les types d’instructions qui peuvent être utilisés :</span><span class="sxs-lookup"><span data-stu-id="7a67a-358">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="7a67a-359">Déclaration de variable locale.</span><span class="sxs-lookup"><span data-stu-id="7a67a-359">Local variable declaration.</span></span>
* <span data-ttu-id="7a67a-360">Déclaration de constante locale.</span><span class="sxs-lookup"><span data-stu-id="7a67a-360">Local constant declaration.</span></span>
* <span data-ttu-id="7a67a-361">Instruction d’expression.</span><span class="sxs-lookup"><span data-stu-id="7a67a-361">Expression statement.</span></span>
* <span data-ttu-id="7a67a-362">`if` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-362">`if` statement.</span></span>
* <span data-ttu-id="7a67a-363">`switch` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-363">`switch` statement.</span></span>
* <span data-ttu-id="7a67a-364">`while` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-364">`while` statement.</span></span>
* <span data-ttu-id="7a67a-365">`do` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-365">`do` statement.</span></span>
* <span data-ttu-id="7a67a-366">`for` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-366">`for` statement.</span></span>
* <span data-ttu-id="7a67a-367">`foreach` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-367">`foreach` statement.</span></span>
* <span data-ttu-id="7a67a-368">`break` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-368">`break` statement.</span></span>
* <span data-ttu-id="7a67a-369">`continue` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-369">`continue` statement.</span></span>
* <span data-ttu-id="7a67a-370">`goto` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-370">`goto` statement.</span></span>
* <span data-ttu-id="7a67a-371">`return` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-371">`return` statement.</span></span>
* <span data-ttu-id="7a67a-372">`yield` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-372">`yield` statement.</span></span>
* <span data-ttu-id="7a67a-373">`throw` instructions et `try` instructions.</span><span class="sxs-lookup"><span data-stu-id="7a67a-373">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="7a67a-374">`checked``unchecked`instructions et.</span><span class="sxs-lookup"><span data-stu-id="7a67a-374">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="7a67a-375">`lock` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-375">`lock` statement.</span></span>
* <span data-ttu-id="7a67a-376">`using` gestion.</span><span class="sxs-lookup"><span data-stu-id="7a67a-376">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="7a67a-377">[Précédent](types.md) 
> [Suivant](features.md)</span><span class="sxs-lookup"><span data-stu-id="7a67a-377">[Previous](types.md)
[Next](features.md)</span></span>
