---
title: Visite guidée du langage C# - Guide du langage C#
description: Novice en matière de langage C# ? Découvrez les principes de base du langage. Commencez par cette vue d’ensemble.
ms.date: 01/28/2021
ms.openlocfilehash: 016edf331d8cbdca2902cb033963b6aea11df513
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216640"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="cb00c-105">Visite guidée du langage C#</span><span class="sxs-lookup"><span data-stu-id="cb00c-105">A tour of the C# language</span></span>

<span data-ttu-id="cb00c-106">C# (prononcé « voir Sharp ») est un langage de programmation moderne, orienté objet et de type sécurisé.</span><span class="sxs-lookup"><span data-stu-id="cb00c-106">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="cb00c-107">C# permet aux développeurs de créer de nombreux types d’applications sécurisées et fiables qui s’exécutent dans l’écosystème .NET.</span><span class="sxs-lookup"><span data-stu-id="cb00c-107">C# enables developers to build many types of secure and robust applications that run in the .NET ecosystem.</span></span> <span data-ttu-id="cb00c-108">C# prend sa source dans la famille de langages C et sera immédiatement reconnaissable aux programmeurs en C, C++, Java et JavaScript.</span><span class="sxs-lookup"><span data-stu-id="cb00c-108">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="cb00c-109">Cette visite guidée fournit une vue d’ensemble des principaux composants du langage dans C# 8 et versions antérieures.</span><span class="sxs-lookup"><span data-stu-id="cb00c-109">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="cb00c-110">Si vous souhaitez explorer le langage par le biais d’exemples interactifs, consultez la présentation des didacticiels [C#](../tutorials/intro-to-csharp/index.md) .</span><span class="sxs-lookup"><span data-stu-id="cb00c-110">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="cb00c-111">C# est un langage de programmation orienté objet et **orienté composant**.</span><span class="sxs-lookup"><span data-stu-id="cb00c-111">C# is an object-oriented, \***component-oriented** _ programming language.</span></span> <span data-ttu-id="cb00c-112">C# fournit des constructions de langage pour prendre en charge directement ces concepts, en faisant de C# un langage naturel dans lequel créer et utiliser des composants logiciels.</span><span class="sxs-lookup"><span data-stu-id="cb00c-112">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="cb00c-113">Depuis son origine, C# a ajouté des fonctionnalités pour prendre en charge de nouvelles charges de travail et des pratiques de conception de logiciels émergentes.</span><span class="sxs-lookup"><span data-stu-id="cb00c-113">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="cb00c-114">Plusieurs fonctionnalités C# permettent de créer des applications robustes et durables.</span><span class="sxs-lookup"><span data-stu-id="cb00c-114">Several C# features help create robust and durable applications.</span></span> <span data-ttu-id="cb00c-115">Le [_*_garbage collection_*_](../../standard/garbage-collection/index.md) libère automatiquement la mémoire occupée par des objets inutilisés inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="cb00c-115">[_*_Garbage collection_*_](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="cb00c-116">Les [_*_types Nullable_*_](../nullable-references.md) protègent les variables qui ne font pas référence aux objets alloués.</span><span class="sxs-lookup"><span data-stu-id="cb00c-116">[_*_Nullable types_*_](../nullable-references.md) guard against variables that don't refer to allocated objects.</span></span> <span data-ttu-id="cb00c-117">La [_*_gestion des exceptions_*_](../programming-guide/exceptions/index.md) offre une approche structurée et extensible de la détection et de la récupération des erreurs.</span><span class="sxs-lookup"><span data-stu-id="cb00c-117">[_*_Exception handling_*_](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="cb00c-118">Les [_*_expressions lambda_*_](../language-reference/operators/lambda-expressions.md) prennent en charge les techniques de programmation fonctionnelle.</span><span class="sxs-lookup"><span data-stu-id="cb00c-118">[_*_Lambda expressions_*_](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="cb00c-119">La syntaxe [_*_LINQ (Language Integrated Query)_*_](../linq/index.md) crée un modèle commun pour l’utilisation des données de n’importe quelle source.</span><span class="sxs-lookup"><span data-stu-id="cb00c-119">[_*_Language Integrated Query (LINQ)_*_](../linq/index.md) syntax creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="cb00c-120">La prise en charge linguistique pour les [_*_opérations asynchrones_*_](../programming-guide/concepts/async/index.md) fournit la syntaxe pour la création de systèmes distribués.</span><span class="sxs-lookup"><span data-stu-id="cb00c-120">Language support for [_*_asynchronous operations_*_](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="cb00c-121">C# possède un [_*_système de type unifié_*_](../programming-guide/types/index.md).</span><span class="sxs-lookup"><span data-stu-id="cb00c-121">C# has a [_*_unified type system_*_](../programming-guide/types/index.md).</span></span> <span data-ttu-id="cb00c-122">Tous les types C#, y compris les types primitifs tels que `int` et `double`, héritent d’un seul type `object` racine.</span><span class="sxs-lookup"><span data-stu-id="cb00c-122">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="cb00c-123">Tous les types partagent un ensemble d’opérations courantes.</span><span class="sxs-lookup"><span data-stu-id="cb00c-123">All types share a set of common operations.</span></span> <span data-ttu-id="cb00c-124">Les valeurs de n’importe quel type peuvent être stockées, transportées et exploitées de manière cohérente.</span><span class="sxs-lookup"><span data-stu-id="cb00c-124">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="cb00c-125">En outre, C# prend en charge les [types référence](../language-reference/builtin-types/reference-types.md) définis par l’utilisateur et les [types valeur](../language-reference/builtin-types/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="cb00c-125">Furthermore, C# supports both user-defined [reference types](../language-reference/builtin-types/reference-types.md) and [value types](../language-reference/builtin-types/value-types.md).</span></span> <span data-ttu-id="cb00c-126">C# permet l’allocation dynamique d’objets et le stockage en ligne de structures légères.</span><span class="sxs-lookup"><span data-stu-id="cb00c-126">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span> <span data-ttu-id="cb00c-127">C# prend en charge des méthodes et des types génériques, ce qui améliore la sécurité et les performances de type.</span><span class="sxs-lookup"><span data-stu-id="cb00c-127">C# supports generic methods and types, which provide increased type safety and performance.</span></span> <span data-ttu-id="cb00c-128">C# fournit des itérateurs, qui permettent aux implémenteurs de classes de collection de définir des comportements personnalisés pour le code client.</span><span class="sxs-lookup"><span data-stu-id="cb00c-128">C# provides iterators, which enable implementers of collection classes to define custom behaviors for client code.</span></span>

<span data-ttu-id="cb00c-129">C# met l’accent sur le contrôle de _*_version_*_ pour s’assurer que les programmes et les bibliothèques peuvent évoluer au fil du temps d’une manière compatible.</span><span class="sxs-lookup"><span data-stu-id="cb00c-129">C# emphasizes _*_versioning_*_ to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="cb00c-130">Les aspects de la conception de C# qui ont été directement influencés par les considérations relatives à la gestion des versions incluent les `virtual` `override` modificateurs et séparés, les règles de résolution de surcharge de méthode et la prise en charge des déclarations de membres d’interface explicites.</span><span class="sxs-lookup"><span data-stu-id="cb00c-130">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="net-architecture"></a><span data-ttu-id="cb00c-131">Architecture .NET</span><span class="sxs-lookup"><span data-stu-id="cb00c-131">.NET architecture</span></span>

<span data-ttu-id="cb00c-132">Les programmes C# s’exécutent sur .NET, un système d’exécution virtuel appelé le common language runtime (CLR) et un ensemble de bibliothèques de classes.</span><span class="sxs-lookup"><span data-stu-id="cb00c-132">C# programs run on .NET, a virtual execution system called the common language runtime (CLR) and a set of class libraries.</span></span> <span data-ttu-id="cb00c-133">Le CLR est l’implémentation par Microsoft de l’infrastructure de langage commun (CLI), une norme internationale.</span><span class="sxs-lookup"><span data-stu-id="cb00c-133">The CLR is the implementation by Microsoft of the common language infrastructure (CLI), an international standard.</span></span> <span data-ttu-id="cb00c-134">L’interface CLI est la base de la création d’environnements d’exécution et de développement dans lesquels les langages et les bibliothèques fonctionnent ensemble de façon transparente.</span><span class="sxs-lookup"><span data-stu-id="cb00c-134">The CLI is the basis for creating execution and development environments in which languages and libraries work together seamlessly.</span></span>

<span data-ttu-id="cb00c-135">Le code source écrit en C# est compilé dans un [langage intermédiaire (il)](../../standard/managed-code.md) conforme à la spécification CLI.</span><span class="sxs-lookup"><span data-stu-id="cb00c-135">Source code written in C# is compiled into an [intermediate language (IL)](../../standard/managed-code.md) that conforms to the CLI specification.</span></span> <span data-ttu-id="cb00c-136">Le code de langage intermédiaire et les ressources, telles que les bitmaps et les chaînes, sont stockés dans un assembly, en général avec une extension de _.dll \*.</span><span class="sxs-lookup"><span data-stu-id="cb00c-136">The IL code and resources, such as bitmaps and strings, are stored in an assembly, typically with an extension of _.dll\*.</span></span> <span data-ttu-id="cb00c-137">Un assembly contient un manifeste qui fournit des informations sur les types, la version et la culture de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="cb00c-137">An assembly contains a manifest that provides information about the assembly's types, version, and culture.</span></span>

<span data-ttu-id="cb00c-138">Lorsque le programme C# est exécuté, l’assembly est chargé dans le CLR.</span><span class="sxs-lookup"><span data-stu-id="cb00c-138">When the C# program is executed, the assembly is loaded into the CLR.</span></span> <span data-ttu-id="cb00c-139">Le CLR effectue une compilation juste-à-temps (JIT) pour convertir le code de langage intermédiaire en instructions machine natives.</span><span class="sxs-lookup"><span data-stu-id="cb00c-139">The CLR performs Just-In-Time (JIT) compilation to convert the IL code to native machine instructions.</span></span> <span data-ttu-id="cb00c-140">Le CLR fournit d’autres services liés à la garbage collection automatique, à la gestion des exceptions et à la gestion des ressources.</span><span class="sxs-lookup"><span data-stu-id="cb00c-140">The CLR provides other services related to automatic garbage collection, exception handling, and resource management.</span></span> <span data-ttu-id="cb00c-141">Le code exécuté par le CLR est parfois appelé « code managé », contrairement à « code non managé », qui est compilé dans un langage machine natif ciblant une plateforme spécifique.</span><span class="sxs-lookup"><span data-stu-id="cb00c-141">Code that's executed by the CLR is sometimes referred to as "managed code," in contrast to "unmanaged code," which is compiled into native machine language that targets a specific platform.</span></span>

<span data-ttu-id="cb00c-142">L’interopérabilité des langages est une fonctionnalité clé de .NET.</span><span class="sxs-lookup"><span data-stu-id="cb00c-142">Language interoperability is a key feature of .NET.</span></span> <span data-ttu-id="cb00c-143">Le code de langage intermédiaire produit par le compilateur C# est conforme à la spécification de type commun (CTS).</span><span class="sxs-lookup"><span data-stu-id="cb00c-143">IL code produced by the C# compiler conforms to the Common Type Specification (CTS).</span></span> <span data-ttu-id="cb00c-144">Le code de langage intermédiaire généré à partir de C# peut interagir avec le code généré à partir des versions .NET de F #, Visual Basic, C++ ou l’un des plus de 20 autres langages compatibles CTS.</span><span class="sxs-lookup"><span data-stu-id="cb00c-144">IL code generated from C# can interact with code that was generated from the .NET versions of F#, Visual Basic, C++, or any of more than 20 other CTS-compliant languages.</span></span> <span data-ttu-id="cb00c-145">Un seul assembly peut contenir plusieurs modules écrits dans différents langages .NET, et les types peuvent se référencer mutuellement comme s’ils avaient été écrits dans le même langage.</span><span class="sxs-lookup"><span data-stu-id="cb00c-145">A single assembly may contain multiple modules written in different .NET languages, and the types can reference each other as if they were written in the same language.</span></span>

<span data-ttu-id="cb00c-146">Outre les services d’exécution, .NET comprend également des bibliothèques étendues.</span><span class="sxs-lookup"><span data-stu-id="cb00c-146">In addition to the run time services, .NET also includes extensive libraries.</span></span> <span data-ttu-id="cb00c-147">Ces bibliothèques prennent en charge de nombreuses charges de travail différentes.</span><span class="sxs-lookup"><span data-stu-id="cb00c-147">These libraries support many different workloads.</span></span> <span data-ttu-id="cb00c-148">Elles sont organisées en espaces de noms qui fournissent un large éventail de fonctionnalités utiles pour tout, de l’entrée de fichier à la sortie de la manipulation de chaînes à l’analyse XML, aux infrastructures d’application Web pour Windows Forms contrôles.</span><span class="sxs-lookup"><span data-stu-id="cb00c-148">They're organized into namespaces that provide a wide variety of useful functionality for everything from file input and output to string manipulation to XML parsing, to web application frameworks to Windows Forms controls.</span></span> <span data-ttu-id="cb00c-149">L’application C# classique utilise largement la bibliothèque de classes .NET pour gérer les tâches courantes de « plomberie ».</span><span class="sxs-lookup"><span data-stu-id="cb00c-149">The typical C# application uses the .NET class library extensively to handle common "plumbing" chores.</span></span>

<span data-ttu-id="cb00c-150">Pour plus d’informations sur .NET, consultez [vue d’ensemble de .net](../../core/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="cb00c-150">For more information about .NET, see [Overview of .NET](../../core/introduction.md).</span></span>

## <a name="hello-world"></a><span data-ttu-id="cb00c-151">Hello World</span><span class="sxs-lookup"><span data-stu-id="cb00c-151">Hello world</span></span>

<span data-ttu-id="cb00c-152">Le programme « Hello, World » est souvent utilisé pour présenter un langage de programmation.</span><span class="sxs-lookup"><span data-stu-id="cb00c-152">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="cb00c-153">Le voici en C# :</span><span class="sxs-lookup"><span data-stu-id="cb00c-153">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="cb00c-154">Le programme « Hello, World » commence par une directive `using` qui fait référence à l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="cb00c-154">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="cb00c-155">Les espaces de noms représentent un moyen hiérarchique d’organiser les bibliothèques et les programmes C#.</span><span class="sxs-lookup"><span data-stu-id="cb00c-155">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="cb00c-156">Les espaces de noms contiennent des types et d’autres espaces de noms ; par exemple, l’espace de noms `System` contient plusieurs types, notamment la classe `Console` référencée dans le programme, et d’autres espaces de noms, tels que `IO` et `Collections`.</span><span class="sxs-lookup"><span data-stu-id="cb00c-156">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="cb00c-157">Une directive `using` qui fait référence à un espace de noms donné permet l’utilisation non qualifiée des types membres de cet espace de noms.</span><span class="sxs-lookup"><span data-stu-id="cb00c-157">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="cb00c-158">En raison de la directive `using`, le programme peut utiliser `Console.WriteLine` comme raccourci pour `System.Console.WriteLine`.</span><span class="sxs-lookup"><span data-stu-id="cb00c-158">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="cb00c-159">La classe `Hello` déclarée par le programme « Hello, World » a un membre unique, la méthode nommée `Main`.</span><span class="sxs-lookup"><span data-stu-id="cb00c-159">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="cb00c-160">La `Main` méthode est déclarée avec le `static` modificateur.</span><span class="sxs-lookup"><span data-stu-id="cb00c-160">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="cb00c-161">Si les méthodes d’instance peuvent faire référence à une instance d’objet englobante particulière avec le mot clé `this`, les méthodes statiques fonctionnent sans référence à un objet particulier.</span><span class="sxs-lookup"><span data-stu-id="cb00c-161">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="cb00c-162">Par Convention, une méthode statique nommée `Main` sert de point d’entrée d’un programme C#.</span><span class="sxs-lookup"><span data-stu-id="cb00c-162">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="cb00c-163">La sortie du programme est générée par la méthode `WriteLine` de la classe `Console` dans l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="cb00c-163">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="cb00c-164">Cette classe est fournie par les bibliothèques de classes standard, qui, par défaut, sont référencées automatiquement par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="cb00c-164">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="cb00c-165">Types et variables</span><span class="sxs-lookup"><span data-stu-id="cb00c-165">Types and variables</span></span>

<span data-ttu-id="cb00c-166">Il existe deux genres de types en C# : les *types référence* et les *types valeur*.</span><span class="sxs-lookup"><span data-stu-id="cb00c-166">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="cb00c-167">Les variables des types valeur contiennent directement leurs données.</span><span class="sxs-lookup"><span data-stu-id="cb00c-167">Variables of value types directly contain their data.</span></span> <span data-ttu-id="cb00c-168">Les variables des types référence stockent des références à leurs données, qui sont les derniers appelés objets.</span><span class="sxs-lookup"><span data-stu-id="cb00c-168">Variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="cb00c-169">Avec les types référence, il est possible que deux variables référencent le même objet et que les opérations sur une variable affectent l’objet référencé par l’autre variable.</span><span class="sxs-lookup"><span data-stu-id="cb00c-169">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="cb00c-170">Avec les types valeur, les variables ont chacune leur propre copie des données, et il n’est pas possible pour les opérations sur l’une d’affecter l’autre (à l’exception des `ref` `out` variables de paramètre et).</span><span class="sxs-lookup"><span data-stu-id="cb00c-170">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="cb00c-171">Un \***identifier** _ est un nom de variable.</span><span class="sxs-lookup"><span data-stu-id="cb00c-171">An \***identifier** _ is a variable name.</span></span> <span data-ttu-id="cb00c-172">Un identificateur est une séquence de caractères Unicode sans espace blanc.</span><span class="sxs-lookup"><span data-stu-id="cb00c-172">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="cb00c-173">Un identificateur peut être un mot réservé C#, s’il est préfixé par `@` .</span><span class="sxs-lookup"><span data-stu-id="cb00c-173">An identifier may be a C# reserved word, if it's prefixed by `@`.</span></span> <span data-ttu-id="cb00c-174">L’utilisation d’un mot réservé comme identificateur peut être utile lors de l’interaction avec d’autres langages.</span><span class="sxs-lookup"><span data-stu-id="cb00c-174">Using a reserved word as an identifier can be useful when interacting with other languages.</span></span>

<span data-ttu-id="cb00c-175">Les types valeur de C# sont divisés en _simple types \*, *types ENUM*, types *struct*, *types valeur Nullable* et *types valeur de tuple*.</span><span class="sxs-lookup"><span data-stu-id="cb00c-175">C#'s value types are further divided into _simple types\*, *enum types*, *struct types*, *nullable value types*, and *tuple value types*.</span></span> <span data-ttu-id="cb00c-176">Les types référence de C# sont encore divisés en *types classe*, *types interface*, *types tableau* et *types délégués*.</span><span class="sxs-lookup"><span data-stu-id="cb00c-176">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="cb00c-177">Le schéma suivant fournit une vue d’ensemble du système de type de C#.</span><span class="sxs-lookup"><span data-stu-id="cb00c-177">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="cb00c-178">Types de valeur</span><span class="sxs-lookup"><span data-stu-id="cb00c-178">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="cb00c-179">Types simples</span><span class="sxs-lookup"><span data-stu-id="cb00c-179">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="cb00c-180">[Intégrale signé](../language-reference/builtin-types/integral-numeric-types.md): `sbyte` , `short` , `int` , `long`</span><span class="sxs-lookup"><span data-stu-id="cb00c-180">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="cb00c-181">[Entier non signé](../language-reference/builtin-types/integral-numeric-types.md): `byte` , `ushort` , `uint` , `ulong`</span><span class="sxs-lookup"><span data-stu-id="cb00c-181">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="cb00c-182">[Caractères Unicode](../../standard/base-types/character-encoding-introduction.md): `char` , qui représente une unité de code UTF-16</span><span class="sxs-lookup"><span data-stu-id="cb00c-182">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="cb00c-183">[Virgule flottante binaire IEEE](../language-reference/builtin-types/floating-point-numeric-types.md): `float` , `double`</span><span class="sxs-lookup"><span data-stu-id="cb00c-183">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="cb00c-184">Virgule [flottante décimale haute précision](../language-reference/builtin-types/floating-point-numeric-types.md):`decimal`</span><span class="sxs-lookup"><span data-stu-id="cb00c-184">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="cb00c-185">Boolean : `bool` , qui représente des valeurs booléennes, les valeurs qui sont `true` ou `false`</span><span class="sxs-lookup"><span data-stu-id="cb00c-185">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="cb00c-186">Types ENUM</span><span class="sxs-lookup"><span data-stu-id="cb00c-186">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="cb00c-187">Types définis par l’utilisateur sous la forme `enum E {...}` .</span><span class="sxs-lookup"><span data-stu-id="cb00c-187">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="cb00c-188">Un type `enum` est un type distinct avec des constantes nommées.</span><span class="sxs-lookup"><span data-stu-id="cb00c-188">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="cb00c-189">Chaque type `enum` a un type sous-jacent qui doit être un des huit types intégraux.</span><span class="sxs-lookup"><span data-stu-id="cb00c-189">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="cb00c-190">L’ensemble de valeurs d’un type `enum` est le même que l’ensemble de valeurs du type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="cb00c-190">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="cb00c-191">Types struct</span><span class="sxs-lookup"><span data-stu-id="cb00c-191">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="cb00c-192">Types définis par l'utilisateur de la forme `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="cb00c-192">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="cb00c-193">Types valeur Nullable</span><span class="sxs-lookup"><span data-stu-id="cb00c-193">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="cb00c-194">Extensions de tous les autres types de valeurs avec une valeur `null`</span><span class="sxs-lookup"><span data-stu-id="cb00c-194">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="cb00c-195">Types de valeur de Tuple</span><span class="sxs-lookup"><span data-stu-id="cb00c-195">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="cb00c-196">Types définis par l'utilisateur de la forme `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="cb00c-196">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="cb00c-197">Types référence</span><span class="sxs-lookup"><span data-stu-id="cb00c-197">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="cb00c-198">Types de classe</span><span class="sxs-lookup"><span data-stu-id="cb00c-198">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="cb00c-199">Classe de base fondamentale de tous les autres types : `object`</span><span class="sxs-lookup"><span data-stu-id="cb00c-199">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="cb00c-200">[Chaînes Unicode](../../standard/base-types/character-encoding-introduction.md): `string` , qui représente une séquence d’unités de code UTF-16</span><span class="sxs-lookup"><span data-stu-id="cb00c-200">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="cb00c-201">Types définis par l'utilisateur de la forme `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="cb00c-201">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="cb00c-202">Types d'interface</span><span class="sxs-lookup"><span data-stu-id="cb00c-202">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="cb00c-203">Types définis par l'utilisateur de la forme `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="cb00c-203">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="cb00c-204">Types tableau</span><span class="sxs-lookup"><span data-stu-id="cb00c-204">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="cb00c-205">Unidimensionnel, multidimensionnel et en escalier.</span><span class="sxs-lookup"><span data-stu-id="cb00c-205">Single-dimensional, multi-dimensional, and jagged.</span></span> <span data-ttu-id="cb00c-206">Par exemple : `int[]` , `int[,]` et `int[][]`</span><span class="sxs-lookup"><span data-stu-id="cb00c-206">For example: `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="cb00c-207">Types délégués</span><span class="sxs-lookup"><span data-stu-id="cb00c-207">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="cb00c-208">Types définis par l'utilisateur de la forme `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="cb00c-208">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="cb00c-209">Les programmes C# utilisent les *déclarations de type* pour créer de nouveaux types.</span><span class="sxs-lookup"><span data-stu-id="cb00c-209">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="cb00c-210">Une déclaration de type spécifie le nom et les membres du nouveau type.</span><span class="sxs-lookup"><span data-stu-id="cb00c-210">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="cb00c-211">Six des catégories de types C# sont définissables par l’utilisateur : types de classes, types struct, types interface, types ENUM, types délégués et types valeur de Tuple.</span><span class="sxs-lookup"><span data-stu-id="cb00c-211">Six of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, delegate types, and tuple value types.</span></span>

- <span data-ttu-id="cb00c-212">Un type `class` définit une structure de données qui contient des données membres (champs) et des fonctions membres (méthodes, propriétés, etc.).</span><span class="sxs-lookup"><span data-stu-id="cb00c-212">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="cb00c-213">Les types de classes prennent en charge l’héritage unique et le polymorphisme, des mécanismes par lesquels les classes dérivées peuvent étendre et spécialiser les classes de base.</span><span class="sxs-lookup"><span data-stu-id="cb00c-213">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="cb00c-214">Un type `struct` est similaire à un type de classe dans la mesure où il représente une structure avec des membres de données et des membres de fonctions.</span><span class="sxs-lookup"><span data-stu-id="cb00c-214">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="cb00c-215">Toutefois, contrairement aux classes, les structs sont des types valeur et ne nécessitent généralement pas d’allocation de tas.</span><span class="sxs-lookup"><span data-stu-id="cb00c-215">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="cb00c-216">Les types struct ne prennent pas en charge l’héritage spécifié par l’utilisateur, et tous les types struct héritent implicitement du type `object` .</span><span class="sxs-lookup"><span data-stu-id="cb00c-216">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="cb00c-217">Un `interface` type définit un contrat comme un jeu nommé de membres publics.</span><span class="sxs-lookup"><span data-stu-id="cb00c-217">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="cb00c-218">Un `class` ou `struct` qui implémente un `interface` doit fournir des implémentations des membres de l’interface.</span><span class="sxs-lookup"><span data-stu-id="cb00c-218">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="cb00c-219">Une `interface` peut hériter de plusieurs interfaces de base, et une `class` ou `struct` peut implémenter plusieurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="cb00c-219">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="cb00c-220">Un type `delegate` représente des références aux méthodes avec une liste de paramètres et un type de retour particuliers.</span><span class="sxs-lookup"><span data-stu-id="cb00c-220">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="cb00c-221">Les délégués permettent de traiter les méthodes en tant qu’entités qui peuvent être affectées à des variables et passées comme paramètres.</span><span class="sxs-lookup"><span data-stu-id="cb00c-221">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="cb00c-222">Les délégués sont semblables aux types de fonction fournis par les langages fonctionnels.</span><span class="sxs-lookup"><span data-stu-id="cb00c-222">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="cb00c-223">Elles sont également similaires au concept de pointeurs de fonction qui se trouvent dans d’autres langages.</span><span class="sxs-lookup"><span data-stu-id="cb00c-223">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="cb00c-224">Contrairement aux pointeurs de fonction, les délégués sont orientés objet et de type sécurisé.</span><span class="sxs-lookup"><span data-stu-id="cb00c-224">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="cb00c-225">Les `class` types,, `struct` `interface` et `delegate` prennent tous en charge les génériques, dans lesquels ils peuvent être paramétrés avec d’autres types.</span><span class="sxs-lookup"><span data-stu-id="cb00c-225">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="cb00c-226">C# prend en charge les tableaux unidimensionnels et multidimensionnels de tout type.</span><span class="sxs-lookup"><span data-stu-id="cb00c-226">C# supports single-dimensional and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="cb00c-227">Contrairement aux types indiqués ci-dessus, les types de tableau ne doivent pas nécessairement être déclarés avant de pouvoir être utilisés.</span><span class="sxs-lookup"><span data-stu-id="cb00c-227">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="cb00c-228">Au lieu de cela, les types de tableaux sont construits en ajoutant des crochets à un nom de type.</span><span class="sxs-lookup"><span data-stu-id="cb00c-228">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="cb00c-229">Par exemple, `int[]` est un tableau unidimensionnel de `int` , `int[,]` est un tableau à deux dimensions de `int` , et `int[][]` est un tableau unidimensionnel de tableaux unidimensionnels, ou un tableau en escalier, de `int` .</span><span class="sxs-lookup"><span data-stu-id="cb00c-229">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.</span></span>

<span data-ttu-id="cb00c-230">Les types Nullable ne nécessitent pas une définition distincte.</span><span class="sxs-lookup"><span data-stu-id="cb00c-230">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="cb00c-231">Pour chaque type non Nullable `T` , il existe un type Nullable correspondant `T?` qui peut contenir une valeur supplémentaire, `null` .</span><span class="sxs-lookup"><span data-stu-id="cb00c-231">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="cb00c-232">Par exemple, `int?` est un type qui peut contenir n’importe quel entier 32 bits ou la valeur `null` , et `string?` est un type qui peut contenir n’importe quelle `string` valeur ou `null` .</span><span class="sxs-lookup"><span data-stu-id="cb00c-232">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="cb00c-233">Le système de type C# est unifié de telle façon qu’une valeur de n’importe quel type peut être traitée comme un `object` .</span><span class="sxs-lookup"><span data-stu-id="cb00c-233">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="cb00c-234">Chaque type dans C# dérive directement ou indirectement du type `object`, et `object` est la classe de base fondamentale de tous les types.</span><span class="sxs-lookup"><span data-stu-id="cb00c-234">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="cb00c-235">Les valeurs des types référence sont considérées comme des objets simplement en affichant les valeurs en tant que type `object`.</span><span class="sxs-lookup"><span data-stu-id="cb00c-235">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="cb00c-236">Les valeurs des types valeur sont considérées comme des objets en effectuant des opérations de *boxing* et *d’unboxing*.</span><span class="sxs-lookup"><span data-stu-id="cb00c-236">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="cb00c-237">Dans l’exemple suivant, une valeur `int` est convertie en `object` et à nouveau en `int`.</span><span class="sxs-lookup"><span data-stu-id="cb00c-237">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="cb00c-238">Quand une valeur d’un type de valeur est assignée à une `object` référence, un « Box » est alloué pour contenir la valeur.</span><span class="sxs-lookup"><span data-stu-id="cb00c-238">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="cb00c-239">Cette zone est une instance d’un type référence, et la valeur est copiée dans cette zone.</span><span class="sxs-lookup"><span data-stu-id="cb00c-239">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="cb00c-240">À l’inverse, lorsqu’une `object` référence est castée en un type valeur, une vérification est effectuée que le référencé `object` est une zone du type valeur correct.</span><span class="sxs-lookup"><span data-stu-id="cb00c-240">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="cb00c-241">Si la vérification est réussie, la valeur dans la zone est copiée dans le type valeur.</span><span class="sxs-lookup"><span data-stu-id="cb00c-241">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="cb00c-242">Le système de type unifié de C# signifie que les types valeur sont traités comme `object` des références « à la demande ».</span><span class="sxs-lookup"><span data-stu-id="cb00c-242">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="cb00c-243">En raison de l’unification, les bibliothèques à usage général qui utilisent le type `object` peuvent être utilisées avec tous les types qui dérivent de `object` , y compris les types référence et les types valeur.</span><span class="sxs-lookup"><span data-stu-id="cb00c-243">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="cb00c-244">Il existe plusieurs types de *variables* en C#, y compris les champs, les éléments de tableau, les variables locales et les paramètres.</span><span class="sxs-lookup"><span data-stu-id="cb00c-244">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="cb00c-245">Les variables représentent des emplacements de stockage.</span><span class="sxs-lookup"><span data-stu-id="cb00c-245">Variables represent storage locations.</span></span> <span data-ttu-id="cb00c-246">Chaque variable a un type qui détermine les valeurs qui peuvent être stockées dans la variable, comme indiqué ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="cb00c-246">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="cb00c-247">Type de valeur n’acceptant pas Null</span><span class="sxs-lookup"><span data-stu-id="cb00c-247">Non-nullable value type</span></span>
  - <span data-ttu-id="cb00c-248">Une valeur de ce type exact</span><span class="sxs-lookup"><span data-stu-id="cb00c-248">A value of that exact type</span></span>
- <span data-ttu-id="cb00c-249">Types valeur Nullable</span><span class="sxs-lookup"><span data-stu-id="cb00c-249">Nullable value type</span></span>
  - <span data-ttu-id="cb00c-250">Une valeur `null` ou une valeur de ce type exact</span><span class="sxs-lookup"><span data-stu-id="cb00c-250">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="cb00c-251">objet</span><span class="sxs-lookup"><span data-stu-id="cb00c-251">object</span></span>
  - <span data-ttu-id="cb00c-252">Une référence `null`, une référence à un objet de tout type référence ou une référence à une valeur boxed de n’importe quel type valeur</span><span class="sxs-lookup"><span data-stu-id="cb00c-252">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="cb00c-253">Type de classe</span><span class="sxs-lookup"><span data-stu-id="cb00c-253">Class type</span></span>
  - <span data-ttu-id="cb00c-254">Une référence `null`, une référence à une instance de ce type de classe ou une référence à une instance d’une classe dérivée de ce type de classe</span><span class="sxs-lookup"><span data-stu-id="cb00c-254">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="cb00c-255">Type d'interface</span><span class="sxs-lookup"><span data-stu-id="cb00c-255">Interface type</span></span>
  - <span data-ttu-id="cb00c-256">Une référence `null`, une référence à une instance d’un type de classe qui implémente ce type d’interface ou une référence à une valeur boxed d’un type valeur qui implémente ce type d’interface</span><span class="sxs-lookup"><span data-stu-id="cb00c-256">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="cb00c-257">Type tableau</span><span class="sxs-lookup"><span data-stu-id="cb00c-257">Array type</span></span>
  - <span data-ttu-id="cb00c-258">Une référence `null`, une référence à une instance de ce type de tableau ou une instance d’un type de tableau compatible</span><span class="sxs-lookup"><span data-stu-id="cb00c-258">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="cb00c-259">Type délégué</span><span class="sxs-lookup"><span data-stu-id="cb00c-259">Delegate type</span></span>
  - <span data-ttu-id="cb00c-260">Une référence `null` ou une référence à une instance d’un type délégué compatible</span><span class="sxs-lookup"><span data-stu-id="cb00c-260">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="cb00c-261">Structure du programme</span><span class="sxs-lookup"><span data-stu-id="cb00c-261">Program structure</span></span>

<span data-ttu-id="cb00c-262">Les concepts clés de l’organisation en C# sont les [ \* **programmes** _](../programming-guide/inside-a-program/index.md), les [_*_espaces de noms_*_](../programming-guide/namespaces/index.md), les [_*_types_*_](../programming-guide/types/index.md), [_*_les membres_*_](../programming-guide/classes-and-structs/members.md)et les [_*_assemblys_*_](../../standard/assembly/index.md).</span><span class="sxs-lookup"><span data-stu-id="cb00c-262">The key organizational concepts in C# are [\***programs** _](../programming-guide/inside-a-program/index.md), [_*_namespaces_*_](../programming-guide/namespaces/index.md), [_*_types_*_](../programming-guide/types/index.md), [_*_members_*_](../programming-guide/classes-and-structs/members.md), and [_*_assemblies_*_](../../standard/assembly/index.md).</span></span> <span data-ttu-id="cb00c-263">Les programmes déclarent des types qui contiennent des membres et peuvent être organisés en espaces de noms.</span><span class="sxs-lookup"><span data-stu-id="cb00c-263">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="cb00c-264">Les classes, les structs et les interfaces sont des exemples de types.</span><span class="sxs-lookup"><span data-stu-id="cb00c-264">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="cb00c-265">Les champs, méthodes, propriétés et événements sont des exemples de membres.</span><span class="sxs-lookup"><span data-stu-id="cb00c-265">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="cb00c-266">Lorsque les programmes C# sont compilés, ils sont empaquetés physiquement dans des assemblys.</span><span class="sxs-lookup"><span data-stu-id="cb00c-266">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="cb00c-267">Les assemblys ont généralement l’extension de fichier `.exe` ou `.dll` , selon qu’ils implémentent des _*_applications_*_ ou des _*_bibliothèques_*_, respectivement.</span><span class="sxs-lookup"><span data-stu-id="cb00c-267">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement _*_applications_*_ or _*_libraries_*_, respectively.</span></span>

<span data-ttu-id="cb00c-268">Prenons l’exemple d’un assembly qui contient le code suivant :</span><span class="sxs-lookup"><span data-stu-id="cb00c-268">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="cb00c-269">Le nom qualifié complet de cette classe est `Acme.Collections.Stack`.</span><span class="sxs-lookup"><span data-stu-id="cb00c-269">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="cb00c-270">La classe contient plusieurs membres : un champ nommé `top`, deux méthodes nommées `Push` et `Pop`, et une classe imbriquée nommée `Entry`.</span><span class="sxs-lookup"><span data-stu-id="cb00c-270">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="cb00c-271">La classe `Entry` contient trois membres en plus : un champ nommé `next`, un autre nommé `data` et un constructeur.</span><span class="sxs-lookup"><span data-stu-id="cb00c-271">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="cb00c-272">`Stack`Est une classe _generic \*.</span><span class="sxs-lookup"><span data-stu-id="cb00c-272">The `Stack` is a _generic\* class.</span></span> <span data-ttu-id="cb00c-273">Il a un paramètre de type, `T` qui est remplacé par un type concret lorsqu’il est utilisé.</span><span class="sxs-lookup"><span data-stu-id="cb00c-273">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="cb00c-274">Une *pile* est une collection « First in-Last out » (Filo).</span><span class="sxs-lookup"><span data-stu-id="cb00c-274">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="cb00c-275">De nouveaux éléments sont ajoutés en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="cb00c-275">New elements are added to the top of the stack.</span></span> <span data-ttu-id="cb00c-276">Lorsqu’un élément est supprimé, il est supprimé du haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="cb00c-276">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="cb00c-277">Les assemblys contiennent le code exécutable sous forme d’instructions de langage intermédiaire (IL) et des informations symboliques sous la forme de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="cb00c-277">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="cb00c-278">Avant son exécution, le compilateur juste-à-temps (JIT) du Common Language Runtime .NET convertit le code IL dans un assembly en code spécifique au processeur.</span><span class="sxs-lookup"><span data-stu-id="cb00c-278">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="cb00c-279">Étant donné qu’un assembly est une unité autodescriptive de fonctionnalité contenant à la fois du code et des métadonnées, il n’est pas nécessaire d’utiliser des `#include` directives et des fichiers d’en-tête en C#.</span><span class="sxs-lookup"><span data-stu-id="cb00c-279">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="cb00c-280">Les membres et types publics contenus dans un assembly particulier sont disponibles dans un programme C# par simple référence à cet assembly lors de la compilation du programme.</span><span class="sxs-lookup"><span data-stu-id="cb00c-280">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="cb00c-281">Par exemple, ce programme utilise la classe `Acme.Collections.Stack` à partir de l’assembly `acme.dll` :</span><span class="sxs-lookup"><span data-stu-id="cb00c-281">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="cb00c-282">Pour compiler ce programme, vous devez *référencer* l’assembly contenant la classe Stack définie dans l’exemple précédent.</span><span class="sxs-lookup"><span data-stu-id="cb00c-282">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="cb00c-283">Les programmes C# peuvent être stockés dans plusieurs fichiers sources.</span><span class="sxs-lookup"><span data-stu-id="cb00c-283">C# programs can be stored in several source files.</span></span> <span data-ttu-id="cb00c-284">Lorsqu’un programme C# est compilé, tous les fichiers sources sont traités ensemble, et les fichiers sources peuvent se référencer librement.</span><span class="sxs-lookup"><span data-stu-id="cb00c-284">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="cb00c-285">Conceptuellement, c’est comme si tous les fichiers sources étaient concaténés dans un fichier volumineux avant d’être traités.</span><span class="sxs-lookup"><span data-stu-id="cb00c-285">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="cb00c-286">Les déclarations anticipées ne sont jamais nécessaires en C#, car, à quelques exceptions près, l’ordre de déclaration n’est pas significatif.</span><span class="sxs-lookup"><span data-stu-id="cb00c-286">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="cb00c-287">C# ne limite pas un fichier source à la déclaration d’un seul type public et n’exige pas que le nom du fichier source corresponde à un type déclaré dans le fichier source.</span><span class="sxs-lookup"><span data-stu-id="cb00c-287">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="cb00c-288">D’autres Articles de cette présentation expliquent ces blocs organisationnels.</span><span class="sxs-lookup"><span data-stu-id="cb00c-288">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="cb00c-289">Next</span><span class="sxs-lookup"><span data-stu-id="cb00c-289">Next</span></span>](types.md)
