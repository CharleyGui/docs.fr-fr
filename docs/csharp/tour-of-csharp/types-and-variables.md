---
title: Variables et types C# - Visite guidée du langage C#
description: En savoir plus sur la définition des types et la déclaration de variables en C#
ms.date: 04/24/2020
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: a14291d1eec4d090b0275875326c5a580e5abe9d
ms.sourcegitcommit: cb27c01a8b0b4630148374638aff4e2221f90b22
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/09/2020
ms.locfileid: "86174125"
---
# <a name="types-and-variables"></a><span data-ttu-id="4ff57-103">Types et variables</span><span class="sxs-lookup"><span data-stu-id="4ff57-103">Types and variables</span></span>

<span data-ttu-id="4ff57-104">Il existe deux genres de types en C# : les *types référence* et les *types valeur*.</span><span class="sxs-lookup"><span data-stu-id="4ff57-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="4ff57-105">Les variables des types valeur contiennent directement leurs données alors que les variables des types référence contiennent des références à leurs données, connues sous le nom d’objets.</span><span class="sxs-lookup"><span data-stu-id="4ff57-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="4ff57-106">Avec les types référence, deux variables peuvent faire référence au même objet et, par conséquent, les opérations sur une variable peuvent affecter l’objet référencé par l’autre variable.</span><span class="sxs-lookup"><span data-stu-id="4ff57-106">With reference types, it's possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="4ff57-107">Avec les types valeur, les variables ont chacune leur propre copie des données, et il n’est pas possible pour les opérations sur l’une d’affecter l’autre (à l’exception des `ref` `out` variables de paramètre et).</span><span class="sxs-lookup"><span data-stu-id="4ff57-107">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="4ff57-108">Les types de valeur C# sont divisés en *types simples*, *types ENUM*, *types struct*et *types valeur Nullable*.</span><span class="sxs-lookup"><span data-stu-id="4ff57-108">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="4ff57-109">Les types référence de C# sont encore divisés en *types classe*, *types interface*, *types tableau*et *types délégués*.</span><span class="sxs-lookup"><span data-stu-id="4ff57-109">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="4ff57-110">Le schéma suivant fournit une vue d’ensemble du système de type de C#.</span><span class="sxs-lookup"><span data-stu-id="4ff57-110">The following outline provides an overview of C#'s type system.</span></span>

- <span data-ttu-id="4ff57-111">[Types valeur][ValueTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-111">[Value types][ValueTypes]</span></span>
  - <span data-ttu-id="4ff57-112">[Types simples][SimpleTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-112">[Simple types][SimpleTypes]</span></span>
    - <span data-ttu-id="4ff57-113">Entier signé : `sbyte`, `short`, `int`, `long`</span><span class="sxs-lookup"><span data-stu-id="4ff57-113">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="4ff57-114">Entier non signé : `byte`, `ushort`, `uint`, `ulong`</span><span class="sxs-lookup"><span data-stu-id="4ff57-114">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="4ff57-115">Caractères Unicode : `char`</span><span class="sxs-lookup"><span data-stu-id="4ff57-115">Unicode characters: `char`</span></span>
    - <span data-ttu-id="4ff57-116">Virgule flottante pour valeur binaire IEEE : `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="4ff57-116">IEEE binary floating-point: `float`, `double`</span></span>
    - <span data-ttu-id="4ff57-117">Virgule flottante pour valeur décimale haute précision : `decimal`</span><span class="sxs-lookup"><span data-stu-id="4ff57-117">High-precision decimal floating-point: `decimal`</span></span>
    - <span data-ttu-id="4ff57-118">Booléen : `bool`</span><span class="sxs-lookup"><span data-stu-id="4ff57-118">Boolean: `bool`</span></span>
  - <span data-ttu-id="4ff57-119">[Types ENUM][EnumTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-119">[Enum types][EnumTypes]</span></span>
    - <span data-ttu-id="4ff57-120">Types définis par l'utilisateur de la forme `enum E {...}`</span><span class="sxs-lookup"><span data-stu-id="4ff57-120">User-defined types of the form `enum E {...}`</span></span>
  - <span data-ttu-id="4ff57-121">[Types struct][StructTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-121">[Struct types][StructTypes]</span></span>
    - <span data-ttu-id="4ff57-122">Types définis par l'utilisateur de la forme `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="4ff57-122">User-defined types of the form `struct S {...}`</span></span>
  - <span data-ttu-id="4ff57-123">[Types valeur Nullable][NullableTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-123">[Nullable value types][NullableTypes]</span></span>
    - <span data-ttu-id="4ff57-124">Extensions de tous les autres types de valeurs avec une valeur `null`</span><span class="sxs-lookup"><span data-stu-id="4ff57-124">Extensions of all other value types with a `null` value</span></span>
  - <span data-ttu-id="4ff57-125">[Types de valeur de Tuple][TupleTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-125">[Tuple value types][TupleTypes]</span></span>
    - <span data-ttu-id="4ff57-126">Types définis par l'utilisateur de la forme `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="4ff57-126">User-defined types of the form `(T1, T2, ...)`</span></span>
- <span data-ttu-id="4ff57-127">[Types référence][ReferenceTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-127">[Reference types][ReferenceTypes]</span></span>
  - <span data-ttu-id="4ff57-128">[Types de classe][ClassTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-128">[Class types][ClassTypes]</span></span>
    - <span data-ttu-id="4ff57-129">Classe de base fondamentale de tous les autres types : `object`</span><span class="sxs-lookup"><span data-stu-id="4ff57-129">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="4ff57-130">Chaînes Unicode : `string`</span><span class="sxs-lookup"><span data-stu-id="4ff57-130">Unicode strings: `string`</span></span>
    - <span data-ttu-id="4ff57-131">Types définis par l'utilisateur de la forme `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="4ff57-131">User-defined types of the form `class C {...}`</span></span>
  - <span data-ttu-id="4ff57-132">[Types d'interface][InterfaceTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-132">[Interface types][InterfaceTypes]</span></span>
    - <span data-ttu-id="4ff57-133">Types définis par l'utilisateur de la forme `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="4ff57-133">User-defined types of the form `interface I {...}`</span></span>
  - <span data-ttu-id="4ff57-134">[Types tableau][ArrayTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-134">[Array types][ArrayTypes]</span></span>
    - <span data-ttu-id="4ff57-135">Uni et multidimensionnels, par exemple `int[]` et `int[,]`</span><span class="sxs-lookup"><span data-stu-id="4ff57-135">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
  - <span data-ttu-id="4ff57-136">[Types délégués][DelegateTypes]</span><span class="sxs-lookup"><span data-stu-id="4ff57-136">[Delegate types][DelegateTypes]</span></span>
    - <span data-ttu-id="4ff57-137">Types définis par l'utilisateur de la forme `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="4ff57-137">User-defined types of the form `delegate int D(...)`</span></span>

[ValueTypes]: ../language-reference/builtin-types/value-types.md
[SimpleTypes]: ../language-reference/builtin-types/value-types.md#built-in-value-types
[EnumTypes]: ../language-reference/builtin-types/enum.md
[StructTypes]: ../language-reference/builtin-types/struct.md
[NullableTypes]: ../language-reference/builtin-types/nullable-value-types.md
[TupleTypes]: ../language-reference/builtin-types/value-tuples.md
[ReferenceTypes]: ../language-reference/keywords/reference-types.md
[ClassTypes]: ../language-reference/keywords/class.md
[InterfaceTypes]: ../language-reference/keywords/interface.md
[DelegateTypes]: ../language-reference/keywords/delegate.md
[ArrayTypes]: ../programming-guide/arrays/index.md

<span data-ttu-id="4ff57-138">Pour plus d’informations sur les types numériques, consultez [Types intégraux](../language-reference/builtin-types/integral-numeric-types.md) et [Tableau des types à virgule flottante](../language-reference/builtin-types/floating-point-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="4ff57-138">For more information about numeric types, see [Integral types](../language-reference/builtin-types/integral-numeric-types.md) and [Floating-point types table](../language-reference/builtin-types/floating-point-numeric-types.md).</span></span>

<span data-ttu-id="4ff57-139">Le type de C# `bool` est utilisé pour représenter des valeurs booléennes, qui sont des valeurs `true` ou `false` .</span><span class="sxs-lookup"><span data-stu-id="4ff57-139">C#'s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="4ff57-140">Le traitement des caractères et chaînes dans le langage C# utilise l’encodage Unicode.</span><span class="sxs-lookup"><span data-stu-id="4ff57-140">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="4ff57-141">Le type `char` représente une unité de code UTF-16, et le type `string` représente une séquence d’unités de code UTF-16.</span><span class="sxs-lookup"><span data-stu-id="4ff57-141">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="4ff57-142">Les programmes C# utilisent les *déclarations de type* pour créer de nouveaux types.</span><span class="sxs-lookup"><span data-stu-id="4ff57-142">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="4ff57-143">Une déclaration de type spécifie le nom et les membres du nouveau type.</span><span class="sxs-lookup"><span data-stu-id="4ff57-143">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="4ff57-144">Cinq des catégories de types C# sont définissables par l’utilisateur : types classe, types struct, types interface, types ENUM et types délégués.</span><span class="sxs-lookup"><span data-stu-id="4ff57-144">Five of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="4ff57-145">Un type `class` définit une structure de données qui contient des données membres (champs) et des fonctions membres (méthodes, propriétés, etc.).</span><span class="sxs-lookup"><span data-stu-id="4ff57-145">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="4ff57-146">Les types de classes prennent en charge l’héritage unique et le polymorphisme, des mécanismes par lesquels les classes dérivées peuvent étendre et spécialiser les classes de base.</span><span class="sxs-lookup"><span data-stu-id="4ff57-146">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="4ff57-147">Un type `struct` est similaire à un type de classe dans la mesure où il représente une structure avec des membres de données et des membres de fonctions.</span><span class="sxs-lookup"><span data-stu-id="4ff57-147">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="4ff57-148">Toutefois, contrairement aux classes, les structs sont des types valeur et ne nécessitent généralement pas d’allocation de tas.</span><span class="sxs-lookup"><span data-stu-id="4ff57-148">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="4ff57-149">Les types struct ne prennent pas en charge l’héritage spécifié par l’utilisateur, et tous les types struct héritent implicitement du type `object` .</span><span class="sxs-lookup"><span data-stu-id="4ff57-149">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="4ff57-150">Un type `interface` définit un contrat en tant que jeu nommé de membres de la fonction publique.</span><span class="sxs-lookup"><span data-stu-id="4ff57-150">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="4ff57-151">Un `class` ou `struct` qui implémente un `interface` doit fournir des implémentations des membres de la fonction de l’interface.</span><span class="sxs-lookup"><span data-stu-id="4ff57-151">A `class` or `struct` that implements an `interface` must provide implementations of the interface's function members.</span></span> <span data-ttu-id="4ff57-152">Une `interface` peut hériter de plusieurs interfaces de base, et une `class` ou `struct` peut implémenter plusieurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="4ff57-152">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="4ff57-153">Un type `delegate` représente des références aux méthodes avec une liste de paramètres et un type de retour particuliers.</span><span class="sxs-lookup"><span data-stu-id="4ff57-153">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="4ff57-154">Les délégués permettent de traiter les méthodes en tant qu’entités qui peuvent être affectées à des variables et passées comme paramètres.</span><span class="sxs-lookup"><span data-stu-id="4ff57-154">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="4ff57-155">Les délégués sont semblables aux types de fonction fournis par les langages fonctionnels.</span><span class="sxs-lookup"><span data-stu-id="4ff57-155">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="4ff57-156">Elles sont également similaires au concept de pointeurs de fonction qui se trouvent dans d’autres langages.</span><span class="sxs-lookup"><span data-stu-id="4ff57-156">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="4ff57-157">Contrairement aux pointeurs de fonction, les délégués sont orientés objet et de type sécurisé.</span><span class="sxs-lookup"><span data-stu-id="4ff57-157">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="4ff57-158">Les `class` types,, `struct` `interface` et `delegate` prennent tous en charge les génériques, dans lesquels ils peuvent être paramétrés avec d’autres types.</span><span class="sxs-lookup"><span data-stu-id="4ff57-158">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="4ff57-159">Un type `enum` est un type distinct avec des constantes nommées.</span><span class="sxs-lookup"><span data-stu-id="4ff57-159">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="4ff57-160">Chaque type `enum` a un type sous-jacent qui doit être un des huit types intégraux.</span><span class="sxs-lookup"><span data-stu-id="4ff57-160">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="4ff57-161">L’ensemble de valeurs d’un type `enum` est le même que l’ensemble de valeurs du type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="4ff57-161">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="4ff57-162">C# prend en charge les tableaux uni et multidimensionnels de tout type.</span><span class="sxs-lookup"><span data-stu-id="4ff57-162">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="4ff57-163">Contrairement aux types indiqués ci-dessus, les types de tableau ne doivent pas nécessairement être déclarés avant de pouvoir être utilisés.</span><span class="sxs-lookup"><span data-stu-id="4ff57-163">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="4ff57-164">Au lieu de cela, les types de tableaux sont construits en ajoutant des crochets à un nom de type.</span><span class="sxs-lookup"><span data-stu-id="4ff57-164">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="4ff57-165">Par exemple, `int[]` est un tableau unidimensionnel de `int`, `int[,]` est un tableau bidimensionnel de `int`, et `int[][]` est un tableau unidimensionnel d’un tableau unidimensionnel de `int`.</span><span class="sxs-lookup"><span data-stu-id="4ff57-165">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="4ff57-166">Les types valeur Nullable n’ont pas non plus besoin d’être déclarés avant de pouvoir être utilisés.</span><span class="sxs-lookup"><span data-stu-id="4ff57-166">Nullable value types also don't have to be declared before they can be used.</span></span> <span data-ttu-id="4ff57-167">Pour chaque type valeur qui n’autorise pas les valeurs null `T` , il existe un type valeur Nullable correspondant `T?` qui peut contenir une valeur supplémentaire, `null` .</span><span class="sxs-lookup"><span data-stu-id="4ff57-167">For each non-nullable value type `T`, there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="4ff57-168">Par exemple, `int?` est un type qui peut contenir un entier 32 bits ou la valeur `null`.</span><span class="sxs-lookup"><span data-stu-id="4ff57-168">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="4ff57-169">Le système de type C# est unifié de telle façon qu’une valeur de n’importe quel type peut être traitée comme un `object` .</span><span class="sxs-lookup"><span data-stu-id="4ff57-169">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="4ff57-170">Chaque type dans C# dérive directement ou indirectement du type `object`, et `object` est la classe de base fondamentale de tous les types.</span><span class="sxs-lookup"><span data-stu-id="4ff57-170">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="4ff57-171">Les valeurs des types référence sont considérées comme des objets simplement en affichant les valeurs en tant que type `object`.</span><span class="sxs-lookup"><span data-stu-id="4ff57-171">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="4ff57-172">Les valeurs des types valeur sont considérées comme des objets en effectuant des opérations de *boxing* et *d’unboxing*.</span><span class="sxs-lookup"><span data-stu-id="4ff57-172">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="4ff57-173">Dans l’exemple suivant, une valeur `int` est convertie en `object` et à nouveau en `int`.</span><span class="sxs-lookup"><span data-stu-id="4ff57-173">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="4ff57-174">Quand une valeur d’un type de valeur est assignée à une `object` référence, un « Box » est alloué pour contenir la valeur.</span><span class="sxs-lookup"><span data-stu-id="4ff57-174">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="4ff57-175">Cette zone est une instance d’un type référence, et la valeur est copiée dans cette zone.</span><span class="sxs-lookup"><span data-stu-id="4ff57-175">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="4ff57-176">À l’inverse, lorsqu’une `object` référence est castée en un type valeur, une vérification est effectuée que le référencé `object` est une zone du type valeur correct.</span><span class="sxs-lookup"><span data-stu-id="4ff57-176">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="4ff57-177">Si la vérification est réussie, la valeur dans la zone est copiée dans le type valeur.</span><span class="sxs-lookup"><span data-stu-id="4ff57-177">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="4ff57-178">Le système de type unifié de C# signifie que les types valeur sont traités comme `object` des références « à la demande ».</span><span class="sxs-lookup"><span data-stu-id="4ff57-178">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="4ff57-179">En raison de l’unification, les bibliothèques à usage général qui utilisent le type `object` peuvent être utilisées avec tous les types qui dérivent de `object` , y compris les types référence et les types valeur.</span><span class="sxs-lookup"><span data-stu-id="4ff57-179">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="4ff57-180">Il existe plusieurs types de *variables* en C#, y compris les champs, les éléments de tableau, les variables locales et les paramètres.</span><span class="sxs-lookup"><span data-stu-id="4ff57-180">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="4ff57-181">Les variables représentent des emplacements de stockage, et chaque variable possède un type qui détermine les valeurs pouvant être stockées dans la variable, comme indiqué ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="4ff57-181">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="4ff57-182">Type de valeur n’acceptant pas Null</span><span class="sxs-lookup"><span data-stu-id="4ff57-182">Non-nullable value type</span></span>
  - <span data-ttu-id="4ff57-183">Une valeur de ce type exact</span><span class="sxs-lookup"><span data-stu-id="4ff57-183">A value of that exact type</span></span>
- <span data-ttu-id="4ff57-184">Types valeur Nullable</span><span class="sxs-lookup"><span data-stu-id="4ff57-184">Nullable value type</span></span>
  - <span data-ttu-id="4ff57-185">Une valeur `null` ou une valeur de ce type exact</span><span class="sxs-lookup"><span data-stu-id="4ff57-185">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="4ff57-186">object</span><span class="sxs-lookup"><span data-stu-id="4ff57-186">object</span></span>
  - <span data-ttu-id="4ff57-187">Une référence `null`, une référence à un objet de tout type référence ou une référence à une valeur boxed de n’importe quel type valeur</span><span class="sxs-lookup"><span data-stu-id="4ff57-187">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="4ff57-188">Type de classe</span><span class="sxs-lookup"><span data-stu-id="4ff57-188">Class type</span></span>
  - <span data-ttu-id="4ff57-189">Une référence `null`, une référence à une instance de ce type de classe ou une référence à une instance d’une classe dérivée de ce type de classe</span><span class="sxs-lookup"><span data-stu-id="4ff57-189">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="4ff57-190">Type d'interface</span><span class="sxs-lookup"><span data-stu-id="4ff57-190">Interface type</span></span>
  - <span data-ttu-id="4ff57-191">Une référence `null`, une référence à une instance d’un type de classe qui implémente ce type d’interface ou une référence à une valeur boxed d’un type valeur qui implémente ce type d’interface</span><span class="sxs-lookup"><span data-stu-id="4ff57-191">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="4ff57-192">Type tableau</span><span class="sxs-lookup"><span data-stu-id="4ff57-192">Array type</span></span>
  - <span data-ttu-id="4ff57-193">Une référence `null`, une référence à une instance de ce type de tableau ou une instance d’un type de tableau compatible</span><span class="sxs-lookup"><span data-stu-id="4ff57-193">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="4ff57-194">Type délégué</span><span class="sxs-lookup"><span data-stu-id="4ff57-194">Delegate type</span></span>
  - <span data-ttu-id="4ff57-195">Une référence `null` ou une référence à une instance d’un type délégué compatible</span><span class="sxs-lookup"><span data-stu-id="4ff57-195">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="4ff57-196">[Précédent](program-structure.md) 
>  [Suivant](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="4ff57-196">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
