---
title: Types tuple - Guide C#
description: En savoir plus sur les types tuple nommés et sans nom en C#
ms.date: 05/15/2018
ms.technology: csharp-fundamentals
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 9ce9e1d4395d1a75f36004384ec215c615cd9802
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79156907"
---
# <a name="c-tuple-types"></a><span data-ttu-id="e4151-103">Types tuple C#</span><span class="sxs-lookup"><span data-stu-id="e4151-103">C# tuple types</span></span>

<span data-ttu-id="e4151-104">Les tuples C# sont des types que vous définissez à l’aide d’une syntaxe simplifiée.</span><span class="sxs-lookup"><span data-stu-id="e4151-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="e4151-105">Les avantages incluent une syntaxe simplifiée, des règles de conversion basées sur le nombre (appelé « cardinalité ») et les types d’éléments, ainsi que des règles cohérentes pour les copies, les tests d’égalité et les affectations.</span><span class="sxs-lookup"><span data-stu-id="e4151-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="e4151-106">En échange, les tuples ne prennent pas en charge certains idiomes orientés objet associés à l’héritage.</span><span class="sxs-lookup"><span data-stu-id="e4151-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="e4151-107">Vous pouvez bénéficier d’une présentation des tuples dans la section correspondante de l’article [Nouveautés de C# 7.0](whats-new/csharp-7.md#tuples).</span><span class="sxs-lookup"><span data-stu-id="e4151-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="e4151-108">Dans cet article, vous allez apprendre les règles de langage régissant les tuples dans C# 7.0 et ultérieur, découvrir différentes façons de les utiliser et bénéficier de conseils de base sur l’utilisation des tuples.</span><span class="sxs-lookup"><span data-stu-id="e4151-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="e4151-109">Les nouvelles fonctionnalités des tuples exigent les types <xref:System.ValueTuple>.</span><span class="sxs-lookup"><span data-stu-id="e4151-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="e4151-110">Vous devez ajouter le [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) paquet NuGet afin de l’utiliser sur les plates-formes qui n’incluent pas les types.</span><span class="sxs-lookup"><span data-stu-id="e4151-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="e4151-111">Ces fonctionnalités sont semblables à celles d’autres langages qui reposent sur les types fournis dans le framework.</span><span class="sxs-lookup"><span data-stu-id="e4151-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="e4151-112">`async` et `await` qui reposent sur l’interface `INotifyCompletion`, et LINQ qui repose sur `IEnumerable<T>` en sont des exemples.</span><span class="sxs-lookup"><span data-stu-id="e4151-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="e4151-113">Toutefois, le mécanisme de remise change à mesure que le .NET dépend de moins en moins de la plateforme.</span><span class="sxs-lookup"><span data-stu-id="e4151-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="e4151-114">Le .NET Framework n’est pas toujours émis à la même cadence que le compilateur de langage.</span><span class="sxs-lookup"><span data-stu-id="e4151-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="e4151-115">Quand les nouvelles fonctionnalités de langage reposent sur de nouveaux types, ces types sont disponibles sous la forme de packages NuGet au moment de l’émission des fonctionnalités de langage.</span><span class="sxs-lookup"><span data-stu-id="e4151-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="e4151-116">À mesure que ces nouveaux types sont ajoutés à l’API .NET Standard et remis dans le cadre du framework, les packages NuGet ne sont plus obligatoires.</span><span class="sxs-lookup"><span data-stu-id="e4151-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="e4151-117">Commençons par passer en revue les raisons d’ajouter la nouvelle prise en charge des tuples.</span><span class="sxs-lookup"><span data-stu-id="e4151-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="e4151-118">Les méthodes retournent un objet unique.</span><span class="sxs-lookup"><span data-stu-id="e4151-118">Methods return a single object.</span></span> <span data-ttu-id="e4151-119">Les tuples vous permettent d’empaqueter plus aisément plusieurs valeurs dans cet objet unique.</span><span class="sxs-lookup"><span data-stu-id="e4151-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="e4151-120">Le .NET Framework possède déjà des classes `Tuple` génériques.</span><span class="sxs-lookup"><span data-stu-id="e4151-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="e4151-121">Ces classes, toutefois, présentaient deux limitations majeures.</span><span class="sxs-lookup"><span data-stu-id="e4151-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="e4151-122">Premièrement, les classes `Tuple` nommaient leurs propriétés `Item1`, `Item2`, etc.</span><span class="sxs-lookup"><span data-stu-id="e4151-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="e4151-123">Ces noms ne comportent aucune information sémantique.</span><span class="sxs-lookup"><span data-stu-id="e4151-123">Those names carry no semantic information.</span></span> <span data-ttu-id="e4151-124">L’utilisation de ces types `Tuple` ne permet pas de communiquer la signification de chacune de ces propriétés.</span><span class="sxs-lookup"><span data-stu-id="e4151-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="e4151-125">Les nouvelles fonctionnalités de langage vous permettent de déclarer et d’utiliser des noms sémantiquement explicites pour les éléments d’un tuple.</span><span class="sxs-lookup"><span data-stu-id="e4151-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="e4151-126">Les classes `Tuple` entraînent des problèmes de performances car elles sont des types référence.</span><span class="sxs-lookup"><span data-stu-id="e4151-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="e4151-127">Utiliser un des types `Tuple` signifie allouer des objets.</span><span class="sxs-lookup"><span data-stu-id="e4151-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="e4151-128">Sur des chemins réactifs, l’allocation de nombreux petits objets peut avoir un impact mesurable sur les performances de votre application.</span><span class="sxs-lookup"><span data-stu-id="e4151-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="e4151-129">Par conséquent, la prise en charge du langage pour les tuples tire parti des nouveaux structs `ValueTuple`.</span><span class="sxs-lookup"><span data-stu-id="e4151-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="e4151-130">Pour éviter ces faiblesses, vous pouvez créer une `class` ou un `struct` pour fournir plusieurs éléments.</span><span class="sxs-lookup"><span data-stu-id="e4151-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="e4151-131">Malheureusement, cela génère un surplus de travail et masque votre intention de conception.</span><span class="sxs-lookup"><span data-stu-id="e4151-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="e4151-132">La création d’un `struct` ou d’une `class` implique la définition d’un type avec des données et un comportement.</span><span class="sxs-lookup"><span data-stu-id="e4151-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="e4151-133">Souvent, vous souhaitez simplement stocker plusieurs valeurs dans un objet unique.</span><span class="sxs-lookup"><span data-stu-id="e4151-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="e4151-134">Les fonctionnalités du langage et les structs génériques `ValueTuple` appliquent la règle stipulant que vous ne pouvez pas ajouter de comportement (méthodes) à ces types tuple.</span><span class="sxs-lookup"><span data-stu-id="e4151-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="e4151-135">Tous les types `ValueTuple` sont des *structs mutables*.</span><span class="sxs-lookup"><span data-stu-id="e4151-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="e4151-136">Chaque champ de membre est un champ public.</span><span class="sxs-lookup"><span data-stu-id="e4151-136">Each member field is a public field.</span></span> <span data-ttu-id="e4151-137">Cela les rend très légers.</span><span class="sxs-lookup"><span data-stu-id="e4151-137">That makes them very lightweight.</span></span> <span data-ttu-id="e4151-138">Toutefois, cela signifie que les tuples ne doivent pas être utilisés quand l’immuabilité est importante.</span><span class="sxs-lookup"><span data-stu-id="e4151-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="e4151-139">Les tuples sont des conteneurs de données plus simples et plus flexibles que les types `class` et `struct`.</span><span class="sxs-lookup"><span data-stu-id="e4151-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="e4151-140">Examinons ces différences.</span><span class="sxs-lookup"><span data-stu-id="e4151-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="e4151-141">Tuples nommés et sans nom</span><span class="sxs-lookup"><span data-stu-id="e4151-141">Named and unnamed tuples</span></span>

<span data-ttu-id="e4151-142">Le struct `ValueTuple` possède des champs nommés `Item1`, `Item2`, `Item3`, etc., similaires aux propriétés définies dans les types `Tuple` existants.</span><span class="sxs-lookup"><span data-stu-id="e4151-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="e4151-143">Ces noms sont les seuls noms que vous pouvez utiliser pour les *tuples sans nom*.</span><span class="sxs-lookup"><span data-stu-id="e4151-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="e4151-144">Quand vous ne fournissez pas de nom de champ alternatif à un tuple, vous avez créé un tuple sans nom :</span><span class="sxs-lookup"><span data-stu-id="e4151-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="e4151-145">Le tuple dans l’exemple précédent a été paralé à l’aide de constantes littérales et n’aura pas de noms d’éléments créés à l’aide de *projections de noms de champ de tuple* dans C 7.1.</span><span class="sxs-lookup"><span data-stu-id="e4151-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="e4151-146">Toutefois, quand vous initialisez un tuple, vous pouvez utiliser les nouvelles fonctionnalités de langage qui donnent de meilleurs noms aux différents champs.</span><span class="sxs-lookup"><span data-stu-id="e4151-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="e4151-147">Cette opération crée un *tuple nommé*.</span><span class="sxs-lookup"><span data-stu-id="e4151-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="e4151-148">Les tuples nommés ont toujours des éléments appelés `Item1`, `Item2`, `Item3`, etc.</span><span class="sxs-lookup"><span data-stu-id="e4151-148">Named tuples still have elements named `Item1`, `Item2`, `Item3` and so on.</span></span>
<span data-ttu-id="e4151-149">Cependant, ils ont également des synonymes pour tous les éléments que vous avez nommés.</span><span class="sxs-lookup"><span data-stu-id="e4151-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="e4151-150">Vous créez un tuple nommé en spécifiant le nom de chaque élément.</span><span class="sxs-lookup"><span data-stu-id="e4151-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="e4151-151">Une méthode consiste à spécifier les noms dans le cadre de l’initialisation du tuple :</span><span class="sxs-lookup"><span data-stu-id="e4151-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="e4151-152">Ces synonymes sont gérés par le compilateur et le langage pour vous permettre d’utiliser efficacement les tuples nommés.</span><span class="sxs-lookup"><span data-stu-id="e4151-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="e4151-153">Les IDE et les éditeurs peuvent lire ces noms sémantiques à l’aide des API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="e4151-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="e4151-154">Vous pouvez référencer les éléments d’un tuple nommé par ces noms sémantiques n’importe où dans le même assembly.</span><span class="sxs-lookup"><span data-stu-id="e4151-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="e4151-155">Le compilateur remplace les noms que vous avez définis par les équivalents `Item*` lors de la génération de la sortie compilée.</span><span class="sxs-lookup"><span data-stu-id="e4151-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="e4151-156">Le langage MSIL (Microsoft Intermediate Language) compilé n’inclut pas les noms que vous avez donnés à ces éléments.</span><span class="sxs-lookup"><span data-stu-id="e4151-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="e4151-157">À partir de C# 7.1, les noms de champ d’un tuple peuvent être fournis à partir de variables utilisées pour initialiser le tuple.</span><span class="sxs-lookup"><span data-stu-id="e4151-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="e4151-158">Ils sont appelés **[initialiseurs de projection de tuple](#tuple-projection-initializers)**.</span><span class="sxs-lookup"><span data-stu-id="e4151-158">This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="e4151-159">Le code suivant crée un tuple nommé `accumulation` avec les éléments `count` (un entier) et `sum` (un double).</span><span class="sxs-lookup"><span data-stu-id="e4151-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="e4151-160">Le compilateur doit communiquer les noms que vous avez créés pour les tuples qui sont retournés à partir des propriétés et méthodes publiques.</span><span class="sxs-lookup"><span data-stu-id="e4151-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="e4151-161">Dans ces cas, le compilateur ajoute un attribut <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> sur la méthode.</span><span class="sxs-lookup"><span data-stu-id="e4151-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="e4151-162">Cet attribut contient une propriété de liste <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> qui contient les noms attribués à chacun des éléments du tuple.</span><span class="sxs-lookup"><span data-stu-id="e4151-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="e4151-163">Les outils de développement, tels que Visual Studio, lisent également ces métadonnées et fournissent IntelliSense et d’autres fonctionnalités qui utilisent les noms des champs de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="e4151-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="e4151-164">Il est important de comprendre les notions de base sous-jacentes des nouveaux tuples et du type `ValueTuple` afin de comprendre les règles d’affectation des tuples nommés entre eux.</span><span class="sxs-lookup"><span data-stu-id="e4151-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="e4151-165">Initialiseurs de projection de tuple</span><span class="sxs-lookup"><span data-stu-id="e4151-165">Tuple projection initializers</span></span>

<span data-ttu-id="e4151-166">En général, les initialiseurs de projection de tuple fonctionnent en utilisant les noms de champ ou de variable de la partie droite d’une instruction d’initialisation de tuple.</span><span class="sxs-lookup"><span data-stu-id="e4151-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="e4151-167">Si un nom explicite est fourni, il est prioritaire sur n’importe quel nom projeté.</span><span class="sxs-lookup"><span data-stu-id="e4151-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="e4151-168">Par exemple, dans l’initialiseur suivant, les éléments sont `explicitFieldOne` et `explicitFieldTwo`, et non `localVariableOne` et `localVariableTwo`:</span><span class="sxs-lookup"><span data-stu-id="e4151-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="e4151-169">Pour tous les champs où un nom explicite n’est pas spécifié, un nom implicite applicable est projeté.</span><span class="sxs-lookup"><span data-stu-id="e4151-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="e4151-170">Il n’existe aucune obligation de fournir des noms sémantiques, explicitement ou implicitement.</span><span class="sxs-lookup"><span data-stu-id="e4151-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="e4151-171">L’initialiseur suivant a des noms de champ `Item1` dont la valeur est `42`, et `stringContent` dont la valeur est « The answer to everything » :</span><span class="sxs-lookup"><span data-stu-id="e4151-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="e4151-172">Il existe deux conditions où les noms de champ de candidat ne sont pas projetés sur le champ de tuple :</span><span class="sxs-lookup"><span data-stu-id="e4151-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="e4151-173">Lorsque le nom du candidat est un nom de tuple réservé.</span><span class="sxs-lookup"><span data-stu-id="e4151-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="e4151-174">Exemples `Item3` `ToString`incluent `Rest`, , ou .</span><span class="sxs-lookup"><span data-stu-id="e4151-174">Examples include `Item3`, `ToString`, or `Rest`.</span></span>
1. <span data-ttu-id="e4151-175">Lorsque le nom du candidat est un doublon d’un autre nom de champ de tuple, explicite ou implicite.</span><span class="sxs-lookup"><span data-stu-id="e4151-175">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="e4151-176">Ces conditions évitent toute ambiguïté.</span><span class="sxs-lookup"><span data-stu-id="e4151-176">These conditions avoid ambiguity.</span></span> <span data-ttu-id="e4151-177">Ces noms provoqueraient une ambiguïté s’ils étaient utilisés comme noms de champ pour un champ dans un tuple.</span><span class="sxs-lookup"><span data-stu-id="e4151-177">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="e4151-178">Aucune de ces conditions n’entraîne d’erreur au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="e4151-178">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="e4151-179">Au lieu de cela, les éléments sans noms projetés n’ont pas de noms sémantiques projetés.</span><span class="sxs-lookup"><span data-stu-id="e4151-179">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="e4151-180">Les exemples suivants illustrent ces conditions :</span><span class="sxs-lookup"><span data-stu-id="e4151-180">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="e4151-181">Ces cas de figure n’entraînent aucune erreur du compilateur, car ce serait une modification avec rupture du code écrit en C# 7.0 si les projections de nom de champ de tuple n’étaient pas disponibles.</span><span class="sxs-lookup"><span data-stu-id="e4151-181">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="e4151-182">Égalité et tuples</span><span class="sxs-lookup"><span data-stu-id="e4151-182">Equality and tuples</span></span>

<span data-ttu-id="e4151-183">À compter de C# 7.3, les types tuple prennent en charge les opérateurs `==` et `!=`.</span><span class="sxs-lookup"><span data-stu-id="e4151-183">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="e4151-184">Ces opérateurs fonctionnent en comparant, dans l’ordre, chaque membre de l’argument de gauche à chaque membre de l’argument de droite.</span><span class="sxs-lookup"><span data-stu-id="e4151-184">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="e4151-185">Ces comparaisons se court-circuitent.</span><span class="sxs-lookup"><span data-stu-id="e4151-185">These comparisons short-circuit.</span></span> <span data-ttu-id="e4151-186">Elles arrêtent l’évaluation des membres dès qu’une paire n’est pas égale.</span><span class="sxs-lookup"><span data-stu-id="e4151-186">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="e4151-187">Les exemples de code suivants utilisent `==`, mais toutes les règles de comparaison s’appliquent à `!=`.</span><span class="sxs-lookup"><span data-stu-id="e4151-187">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="e4151-188">L’exemple de code suivant montre une comparaison d’égalité pour deux paires d’entiers :</span><span class="sxs-lookup"><span data-stu-id="e4151-188">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="e4151-189">Il existe plusieurs règles qui rendent les tests d’égalité de tuple plus pratiques.</span><span class="sxs-lookup"><span data-stu-id="e4151-189">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="e4151-190">L’égalité de tuple effectue des [conversions de type «lifted»](~/_csharplang/spec/conversions.md#lifted-conversion-operators) si un des tuples est un tuple nullable, comme indiqué dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="e4151-190">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="e4151-191">L’égalité de tuple effectue également des conversions implicites sur chaque membre de deux tuples.</span><span class="sxs-lookup"><span data-stu-id="e4151-191">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="e4151-192">Cela inclut les conversions « lifted », les conversions étendues ou d’autres conversions implicites.</span><span class="sxs-lookup"><span data-stu-id="e4151-192">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="e4151-193">Les exemples suivants montrent qu'un tuple entier à 2 éléments peut être comparé à un tuple long à 2 éléments en raison de la conversion implicite d'entier à long :</span><span class="sxs-lookup"><span data-stu-id="e4151-193">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="e4151-194">Les noms des membres du tuple ne participent pas aux tests d'égalité.</span><span class="sxs-lookup"><span data-stu-id="e4151-194">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="e4151-195">Cependant, si l'un des opérandes est un tuple littéral avec des noms explicites, le compilateur génère une alerte CS8383 si ces noms ne correspondent pas aux noms des autres opérandes.</span><span class="sxs-lookup"><span data-stu-id="e4151-195">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="e4151-196">Si les deux opérandes sont des tuples littéraux, l'avertissement est généré pour l'opérande de droite, comme le montre l'exemple ci-dessous :</span><span class="sxs-lookup"><span data-stu-id="e4151-196">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="e4151-197">Enfin, les tuples peuvent contenir des tuples imbriqués.</span><span class="sxs-lookup"><span data-stu-id="e4151-197">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="e4151-198">L’égalité de tuple compare la « forme » de chaque opérande via des tuples imbriqués, comme le montre l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="e4151-198">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="e4151-199">Comparer deux tuples pour vérifier leur égalité (ou leur inégalité) lorsqu’ils ont des formes différentes est une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="e4151-199">It's a compile time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="e4151-200">Le compilateur ne tentera pas de déconstruire des tuples imbriqués afin de les comparer.</span><span class="sxs-lookup"><span data-stu-id="e4151-200">The compiler won't attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="e4151-201">Affectation et tuples</span><span class="sxs-lookup"><span data-stu-id="e4151-201">Assignment and tuples</span></span>

<span data-ttu-id="e4151-202">Le langage prend en charge l’affectation entre les types de tuples ayant le même nombre d’éléments, où chaque élément de la partie droite peut être converti implicitement en son élément correspondant de la partie gauche.</span><span class="sxs-lookup"><span data-stu-id="e4151-202">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="e4151-203">D’autres conversions ne sont pas prises en compte pour les affectations.</span><span class="sxs-lookup"><span data-stu-id="e4151-203">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="e4151-204">Affecter un tuple à un autre lorsqu’ils ont des formes différentes est une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="e4151-204">It's a compile time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="e4151-205">Le compilateur ne tentera pas de déconstruire des tuples imbriqués afin de les affecter.</span><span class="sxs-lookup"><span data-stu-id="e4151-205">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="e4151-206">Examinons les types d’affectation qui sont autorisés entre les types tuple.</span><span class="sxs-lookup"><span data-stu-id="e4151-206">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="e4151-207">Prenez en compte les variables utilisées dans les exemples suivants :</span><span class="sxs-lookup"><span data-stu-id="e4151-207">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="e4151-208">Les deux premières variables, `unnamed` et `anonymous`, n’ont pas de noms sémantiques fournis pour les éléments.</span><span class="sxs-lookup"><span data-stu-id="e4151-208">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="e4151-209">Les noms des champs sont `Item1` et `Item2`.</span><span class="sxs-lookup"><span data-stu-id="e4151-209">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="e4151-210">Les deux dernières variables, `named` et `differentName`, ont des noms sémantiques fournis pour les éléments.</span><span class="sxs-lookup"><span data-stu-id="e4151-210">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="e4151-211">Ces deux tuples ont des noms différents pour les éléments.</span><span class="sxs-lookup"><span data-stu-id="e4151-211">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="e4151-212">Ces quatre tuples ont le même nombre d’éléments (appelé « cardinalité ») et les types de ces éléments sont identiques.</span><span class="sxs-lookup"><span data-stu-id="e4151-212">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="e4151-213">Par conséquent, toutes ces affectations fonctionnent :</span><span class="sxs-lookup"><span data-stu-id="e4151-213">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="e4151-214">Notez que les noms des tuples ne sont pas affectés.</span><span class="sxs-lookup"><span data-stu-id="e4151-214">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="e4151-215">Les valeurs des éléments sont affectées suivant l’ordre des éléments dans le tuple.</span><span class="sxs-lookup"><span data-stu-id="e4151-215">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="e4151-216">Des tuples de types différents ou n’ayant pas le même nombre d’éléments ne sont pas attribuables :</span><span class="sxs-lookup"><span data-stu-id="e4151-216">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="e4151-217">Tuples comme valeurs de retour de méthode</span><span class="sxs-lookup"><span data-stu-id="e4151-217">Tuples as method return values</span></span>

<span data-ttu-id="e4151-218">L’une des utilisations les plus courantes des tuples est en tant que valeur de retour de méthode.</span><span class="sxs-lookup"><span data-stu-id="e4151-218">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="e4151-219">Examinons en détail un exemple.</span><span class="sxs-lookup"><span data-stu-id="e4151-219">Let's walk through one example.</span></span> <span data-ttu-id="e4151-220">Considérons cette méthode qui calcule l’écart type d’une suite de nombres :</span><span class="sxs-lookup"><span data-stu-id="e4151-220">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="e4151-221">Ces exemples calculent l’écart-type empirique non corrigé.</span><span class="sxs-lookup"><span data-stu-id="e4151-221">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="e4151-222">La formule de l’écart-type empirique corrigé diviserait la somme des écarts au carré par rapport à la moyenne par (N-1) au lieu de N, comme avec la méthode d’extension `Average`.</span><span class="sxs-lookup"><span data-stu-id="e4151-222">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span> <span data-ttu-id="e4151-223">Pour plus d’informations sur les différences entre ces formules de calcul d’écart-type, consultez un texte de statistiques.</span><span class="sxs-lookup"><span data-stu-id="e4151-223">Consult a statistics text for more details on the differences between these formulas for standard deviation.</span></span>

<span data-ttu-id="e4151-224">Le code précédent utilise la formule classique de calcul de l’écart-type.</span><span class="sxs-lookup"><span data-stu-id="e4151-224">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="e4151-225">Elle génère la réponse correcte, mais constitue une implémentation peu efficace.</span><span class="sxs-lookup"><span data-stu-id="e4151-225">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="e4151-226">Cette méthode énumère deux fois la suite : une fois pour générer la moyenne et une fois pour générer la moyenne quadratique des écarts par rapport à la moyenne.</span><span class="sxs-lookup"><span data-stu-id="e4151-226">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="e4151-227">(Souvenez-vous que les requêtes LINQ sont évaluées de manière différée, de sorte que le calcul des écarts par rapport à la moyenne et de la moyenne de ces écarts effectue une seule énumération.)</span><span class="sxs-lookup"><span data-stu-id="e4151-227">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="e4151-228">Il existe une formule alternative qui calcule l’écart-type à l’aide d’une seule énumération de la suite.</span><span class="sxs-lookup"><span data-stu-id="e4151-228">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="e4151-229">Ce calcul génère deux valeurs en énumérant la suite : la somme de tous les éléments de la suite et la somme de chaque valeur au carré :</span><span class="sxs-lookup"><span data-stu-id="e4151-229">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="e4151-230">Cette version énumère une seule fois la séquence.</span><span class="sxs-lookup"><span data-stu-id="e4151-230">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="e4151-231">Toutefois, ce code n’est pas réutilisable.</span><span class="sxs-lookup"><span data-stu-id="e4151-231">But it's not reusable code.</span></span> <span data-ttu-id="e4151-232">En poursuivant votre travail, vous trouverez que de nombreux calculs statistiques différents utilisent le nombre d’éléments dans la suite, la somme de la suite et la somme des carrés de la suite.</span><span class="sxs-lookup"><span data-stu-id="e4151-232">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="e4151-233">Refactorisons cette méthode et écrivons une méthode utilitaire qui génère ces trois valeurs.</span><span class="sxs-lookup"><span data-stu-id="e4151-233">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="e4151-234">Les trois valeurs peuvent toutes être retournées sous forme de tuple.</span><span class="sxs-lookup"><span data-stu-id="e4151-234">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="e4151-235">Mettons à jour cette méthode afin de stocker dans un tuple les trois valeurs calculées pendant l’énumération.</span><span class="sxs-lookup"><span data-stu-id="e4151-235">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="e4151-236">La version suivante est créée :</span><span class="sxs-lookup"><span data-stu-id="e4151-236">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="e4151-237">La prise en charge de la refactorisation par Visual Studio facilite l’extraction des fonctionnalités pour les statistiques principales dans une méthode privée.</span><span class="sxs-lookup"><span data-stu-id="e4151-237">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="e4151-238">Cela vous donne une méthode `private static` qui retourne le type tuple avec les trois valeurs de `Sum`, `SumOfSquares` et `Count` :</span><span class="sxs-lookup"><span data-stu-id="e4151-238">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]

<span data-ttu-id="e4151-239">Le langage met à votre disposition plusieurs autres options, si vous souhaitez apporter quelques modifications rapides à la main.</span><span class="sxs-lookup"><span data-stu-id="e4151-239">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="e4151-240">Tout d’abord, vous pouvez utiliser la déclaration `var` pour initialiser le résultat de tuple à partir de l’appel de la méthode `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="e4151-240">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="e4151-241">Vous pouvez également créer trois variables discrètes à l’intérieur de la méthode `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="e4151-241">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="e4151-242">Le code suivant montre la version finale :</span><span class="sxs-lookup"><span data-stu-id="e4151-242">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="e4151-243">Cette version finale peut être utilisée pour toute méthode qui a besoin de ces trois valeurs ou d’un sous-ensemble quelconque d’entre elles.</span><span class="sxs-lookup"><span data-stu-id="e4151-243">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="e4151-244">Le langage prend en charge d’autres options pour gérer les noms des éléments dans ces méthodes retournant des tuples.</span><span class="sxs-lookup"><span data-stu-id="e4151-244">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="e4151-245">Vous pouvez supprimer les noms des champs de la déclaration de la valeur de retour et retourner un tuple sans nom :</span><span class="sxs-lookup"><span data-stu-id="e4151-245">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="e4151-246">Les champs de ce tuple sont nommés `Item1`, `Item2`, et `Item3`.</span><span class="sxs-lookup"><span data-stu-id="e4151-246">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="e4151-247">Il est recommandé de fournir des noms sémantiques aux éléments de tuples retournés par les méthodes.</span><span class="sxs-lookup"><span data-stu-id="e4151-247">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="e4151-248">Un autre idiome pour lequel les tuples peuvent être très utiles est lorsque vous créez des requêtes LINQ.</span><span class="sxs-lookup"><span data-stu-id="e4151-248">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="e4151-249">Le résultat final est une projection qui contient certaines propriétés des objets sélectionnés, mais pas toutes.</span><span class="sxs-lookup"><span data-stu-id="e4151-249">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="e4151-250">En règle générale, vous devez projeter les résultats de la requête dans une suite d’objets constituant un type anonyme.</span><span class="sxs-lookup"><span data-stu-id="e4151-250">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="e4151-251">Cela présentait de nombreuses limitations, principalement parce que les types anonymes ne pouvaient pas facilement être nommés dans le type de retour pour une méthode.</span><span class="sxs-lookup"><span data-stu-id="e4151-251">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="e4151-252">Des coûts importants accompagnaient les alternatives utilisant `object` ou `dynamic` comme type du résultat.</span><span class="sxs-lookup"><span data-stu-id="e4151-252">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="e4151-253">Il est aisé de retourner une séquence d’un type tuple, et les noms et types des éléments sont disponibles au moment de la compilation et via les outils de l’IDE.</span><span class="sxs-lookup"><span data-stu-id="e4151-253">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="e4151-254">Considérons, par exemple, une application d’agenda.</span><span class="sxs-lookup"><span data-stu-id="e4151-254">For example, consider a ToDo application.</span></span> <span data-ttu-id="e4151-255">Vous pouvez définir une classe similaire à la suivante pour représenter une entrée unique dans la liste des tâches :</span><span class="sxs-lookup"><span data-stu-id="e4151-255">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="e4151-256">Vos applications mobiles peuvent prendre en charge une forme compacte des éléments de tâche en cours qui affiche uniquement le titre.</span><span class="sxs-lookup"><span data-stu-id="e4151-256">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="e4151-257">Cette requête LINQ effectuerait une projection incluant uniquement l’ID et le titre.</span><span class="sxs-lookup"><span data-stu-id="e4151-257">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="e4151-258">Une méthode retournant une suite de tuples exprime bien cette conception :</span><span class="sxs-lookup"><span data-stu-id="e4151-258">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="e4151-259">Dans C# 7.1, les projections de tuple vous permettent de créer des tuples nommés à l’aide d’éléments, d’une manière semblable au nommage des propriétés dans les types anonymes.</span><span class="sxs-lookup"><span data-stu-id="e4151-259">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="e4151-260">Dans le code ci-dessus, l’instruction `select` dans la projection de requête crée un tuple qui a les éléments `ID` et `Title`.</span><span class="sxs-lookup"><span data-stu-id="e4151-260">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="e4151-261">Le tuple nommé peut faire partie de la signature.</span><span class="sxs-lookup"><span data-stu-id="e4151-261">The named tuple can be part of the signature.</span></span> <span data-ttu-id="e4151-262">Il permet au compilateur et aux outils de l’IDE de vérifier de façon statique que vous utilisez correctement le résultat.</span><span class="sxs-lookup"><span data-stu-id="e4151-262">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="e4151-263">Le tuple nommé contient également les informations de type statique, si bien qu’il n’est pas nécessaire d’utiliser des fonctionnalités d’exécution coûteuses telles que la réflexion ou la liaison dynamique pour utiliser les résultats.</span><span class="sxs-lookup"><span data-stu-id="e4151-263">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="e4151-264">Déconstruction</span><span class="sxs-lookup"><span data-stu-id="e4151-264">Deconstruction</span></span>

<span data-ttu-id="e4151-265">Vous pouvez désassembler tous les éléments d’un tuple en *déconstruisant* le tuple retourné par une méthode.</span><span class="sxs-lookup"><span data-stu-id="e4151-265">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="e4151-266">Il existe trois approches différentes de la déconstruction des tuples.</span><span class="sxs-lookup"><span data-stu-id="e4151-266">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="e4151-267">Tout d’abord, vous pouvez déclarer explicitement le type de chacun des champs à l’intérieur des parenthèses afin de créer des variables discrètes pour tous les éléments du tuple :</span><span class="sxs-lookup"><span data-stu-id="e4151-267">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="e4151-268">Vous pouvez également déclarer des variables implicitement typées pour chaque champ d’un tuple à l’aide du mot clé `var` en dehors des parenthèses :</span><span class="sxs-lookup"><span data-stu-id="e4151-268">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="e4151-269">Il est également possible d’utiliser le mot clé `var` avec une ou toutes les déclarations de variables à l’intérieur des parenthèses.</span><span class="sxs-lookup"><span data-stu-id="e4151-269">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span>

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="e4151-270">Vous ne pouvez pas utiliser un type spécifique en dehors des parenthèses, même si tous les champs du tuple ont le même type.</span><span class="sxs-lookup"><span data-stu-id="e4151-270">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="e4151-271">Vous pouvez également déconstruire des tuple avec des déclarations existantes :</span><span class="sxs-lookup"><span data-stu-id="e4151-271">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
> <span data-ttu-id="e4151-272">Vous ne pouvez pas mélanger des déclarations existantes avec des déclarations à l’intérieur des parenthèses.</span><span class="sxs-lookup"><span data-stu-id="e4151-272">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="e4151-273">Par exemple, ce qui suit n’est pas autorisé : `(var x, y) = MyMethod();`.</span><span class="sxs-lookup"><span data-stu-id="e4151-273">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="e4151-274">L’erreur CS8184 est générée, car *x* est déclaré à l’intérieur des parenthèses et *y* a été précédemment déclaré ailleurs.</span><span class="sxs-lookup"><span data-stu-id="e4151-274">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="e4151-275">Déconstruction de types définis par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="e4151-275">Deconstructing user-defined types</span></span>

<span data-ttu-id="e4151-276">N’importe quel type tuple peut être déconstruit comme indiqué ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="e4151-276">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="e4151-277">Il est également facile d’activer la déconstruction sur n’importe quel type défini par l’utilisateur (classes, structs ou même interfaces).</span><span class="sxs-lookup"><span data-stu-id="e4151-277">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="e4151-278">L’auteur du type peut définir une ou plusieurs méthodes `Deconstruct` qui affectent des valeurs à un nombre quelconque de variables `out` qui représentent les éléments de données qui composent le type.</span><span class="sxs-lookup"><span data-stu-id="e4151-278">The type author can define one or more `Deconstruct` methods that assign values to any number of `out` variables representing the data elements that make up the type.</span></span> <span data-ttu-id="e4151-279">Par exemple, le type `Person` suivant définit une méthode `Deconstruct` qui déconstruit un objet person en éléments représentant le prénom et le nom de famille :</span><span class="sxs-lookup"><span data-stu-id="e4151-279">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="e4151-280">La méthode deconstruct permet l’attribution à partir d’un objet `Person` de deux chaînes représentant les propriétés `FirstName` et `LastName` :</span><span class="sxs-lookup"><span data-stu-id="e4151-280">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="e4151-281">Vous pouvez activer la déconstruction même pour des types que vous n’avez pas créés.</span><span class="sxs-lookup"><span data-stu-id="e4151-281">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="e4151-282">La méthode `Deconstruct` peut être une méthode d’extension qui désassemble les membres de données accessibles d’un objet.</span><span class="sxs-lookup"><span data-stu-id="e4151-282">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="e4151-283">L’exemple ci-dessous montre un type `Student`, dérivé du type `Person`, et une méthode d’extension qui déconstruit un objet `Student` en trois variables, qui représentent les propriétés `FirstName`, `LastName` et `GPA` :</span><span class="sxs-lookup"><span data-stu-id="e4151-283">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="e4151-284">Un objet `Student` a désormais deux méthodes `Deconstruct` accessibles : la méthode d’extension déclarée pour les types `Student` et le membre du type `Person`.</span><span class="sxs-lookup"><span data-stu-id="e4151-284">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="e4151-285">Les deux sont dans la portée et cela permet à un objet `Student` d’être déconstruit en deux ou trois variables.</span><span class="sxs-lookup"><span data-stu-id="e4151-285">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="e4151-286">Si vous affectez un étudiant à trois variables, le prénom, le nom de famille et la moyenne pondérée cumulative (GPA) sont tous retournés.</span><span class="sxs-lookup"><span data-stu-id="e4151-286">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="e4151-287">Si vous affectez un étudiant à deux variables, seuls le prénom et le nom de famille sont retournés.</span><span class="sxs-lookup"><span data-stu-id="e4151-287">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="e4151-288">Vous devez être prudent en définissant plusieurs méthodes `Deconstruct` dans une classe ou une hiérarchie de classes.</span><span class="sxs-lookup"><span data-stu-id="e4151-288">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="e4151-289">Plusieurs méthodes `Deconstruct` ayant le même nombre de paramètres `out` peuvent rapidement entraîner des ambiguïtés.</span><span class="sxs-lookup"><span data-stu-id="e4151-289">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="e4151-290">Les appelants peuvent ne pas être en mesure d’appeler facilement la méthode `Deconstruct` souhaitée.</span><span class="sxs-lookup"><span data-stu-id="e4151-290">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="e4151-291">Cet exemple présente un risque minimal d’appel ambigu, car la méthode `Deconstruct` pour `Person` a deux paramètres de sortie, et la méthode `Deconstruct` pour `Student` en a trois.</span><span class="sxs-lookup"><span data-stu-id="e4151-291">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="e4151-292">Les opérateurs de déconstruction ne participent pas aux tests d’égalité.</span><span class="sxs-lookup"><span data-stu-id="e4151-292">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="e4151-293">L’exemple suivant génère une erreur de compilation CS0019 :</span><span class="sxs-lookup"><span data-stu-id="e4151-293">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="e4151-294">La méthode `Deconstruct` pourrait convertir l’objet `Person``p` en un tuple contenant les deux chaînes, mais elle ne s’applique pas dans le contexte des tests d’égalité.</span><span class="sxs-lookup"><span data-stu-id="e4151-294">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="tuples-as-out-parameters"></a><span data-ttu-id="e4151-295">Tuples comme paramètres</span><span class="sxs-lookup"><span data-stu-id="e4151-295">Tuples as out parameters</span></span>

<span data-ttu-id="e4151-296">Tuples peut être utilisé comme paramètres *eux-mêmes*.</span><span class="sxs-lookup"><span data-stu-id="e4151-296">Tuples can be used as out parameters *themselves*.</span></span> <span data-ttu-id="e4151-297">À ne pas confondre avec toute ambiguïté mentionnée précédemment dans la section [Déconstruction.](#deconstruction)</span><span class="sxs-lookup"><span data-stu-id="e4151-297">Not to be confused with any ambiguity previously mentioned in the [Deconstruction](#deconstruction) section.</span></span> <span data-ttu-id="e4151-298">Dans un appel de méthode, vous n’avez qu’à décrire la forme du tuple :</span><span class="sxs-lookup"><span data-stu-id="e4151-298">In a method call, you need only describe the tuple's shape:</span></span>

[!code-csharp[TuplesAsOutParameters](~/samples/snippets/csharp/tuples/program.cs#01_TupleAsOutVariable "Tuples as out parameters")]

<span data-ttu-id="e4151-299">Alternativement, vous pouvez utiliser un tuple [_anonyme_](#named-and-unnamed-tuples) `Item1` et `Item2`se référer à ses champs comme et :</span><span class="sxs-lookup"><span data-stu-id="e4151-299">Alternatively, you could use an [_unnamed_](#named-and-unnamed-tuples) tuple and refer to its fields as `Item1` and `Item2`:</span></span>

```csharp
dict.TryGetValue(2, out (int, string) pair);
// ...
Console.WriteLine($"{pair.Item1}: {pair.Item2}");
```

## <a name="conclusion"></a><span data-ttu-id="e4151-300">Conclusion</span><span class="sxs-lookup"><span data-stu-id="e4151-300">Conclusion</span></span>

<span data-ttu-id="e4151-301">La nouvelle prise en charge du langage et de la bibliothèque pour les tuples nommés facilite grandement l’utilisation de conceptions utilisant des structures de données qui stockent plusieurs éléments mais ne définissent pas de comportement, telles que les classes et les structs.</span><span class="sxs-lookup"><span data-stu-id="e4151-301">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="e4151-302">Il est facile et rapide d’utiliser des tuples pour ces types.</span><span class="sxs-lookup"><span data-stu-id="e4151-302">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="e4151-303">Vous obtenez tous les avantages d’une vérification de type statique, sans avoir à créer de types au moyen de la syntaxe `class` ou `struct` plus détaillée.</span><span class="sxs-lookup"><span data-stu-id="e4151-303">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="e4151-304">Même ainsi, ils sont particulièrement utiles pour les méthodes utilitaires `private` ou `internal`.</span><span class="sxs-lookup"><span data-stu-id="e4151-304">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="e4151-305">Créez des types définis par l’utilisateur, des types `class` ou `struct`, quand vos méthodes publiques retournent une valeur comportant plusieurs éléments.</span><span class="sxs-lookup"><span data-stu-id="e4151-305">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
