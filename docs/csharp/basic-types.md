---
title: Types de base - Guide C#
description: Découvrez les types de base (numérique, chaîne et objet) disponibles dans tous les programmes C#
ms.date: 10/10/2016
ms.assetid: 95c686ba-ae4f-440e-8e94-0dbd6e04d11f
ms.openlocfilehash: 3619e1dc9a82c7f120680c198c327252744444b4
ms.sourcegitcommit: 10986410e59ff29f2ec55c6759bde3eb4d1a00cb
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/31/2019
ms.locfileid: "66422099"
---
# <a name="types-variables-and-values"></a><span data-ttu-id="01aee-103">Types, variables et valeurs</span><span class="sxs-lookup"><span data-stu-id="01aee-103">Types, variables, and values</span></span>

<span data-ttu-id="01aee-104">C# est un langage fortement typé.</span><span class="sxs-lookup"><span data-stu-id="01aee-104">C# is a strongly-typed language.</span></span> <span data-ttu-id="01aee-105">Chaque variable et chaque constante ont un type, tout comme chaque expression qui fournit une valeur.</span><span class="sxs-lookup"><span data-stu-id="01aee-105">Every variable and constant has a type, as does every expression that evaluates to a value.</span></span> <span data-ttu-id="01aee-106">Chaque signature de méthode spécifie un type pour chaque paramètre d’entrée et pour la valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="01aee-106">Every method signature specifies a type for each input parameter and for the return value.</span></span> <span data-ttu-id="01aee-107">La bibliothèque de classes .NET Framework définit un ensemble de types numériques intégrés, ainsi que des types plus complexes qui représentent un large éventail de constructions logiques, telles que le système de fichiers, les connexions réseau, les collections et tableaux d’objets, et les dates.</span><span class="sxs-lookup"><span data-stu-id="01aee-107">The .NET Framework class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.</span></span> <span data-ttu-id="01aee-108">Un programme C# classique utilise des types fournis dans la bibliothèque de classes, mais aussi des types définis par l’utilisateur qui modélisent les concepts propres au domaine du problème du programme.</span><span class="sxs-lookup"><span data-stu-id="01aee-108">A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.</span></span>  
  
<span data-ttu-id="01aee-109">Un type peut stocker les informations suivantes :</span><span class="sxs-lookup"><span data-stu-id="01aee-109">The information stored in a type can include the following:</span></span>  
  
- <span data-ttu-id="01aee-110">Espace de stockage nécessaire pour une variable du type.</span><span class="sxs-lookup"><span data-stu-id="01aee-110">The storage space that a variable of the type requires.</span></span>  
  
- <span data-ttu-id="01aee-111">Valeurs minimale et maximale que le type peut représenter.</span><span class="sxs-lookup"><span data-stu-id="01aee-111">The maximum and minimum values that it can represent.</span></span>  
  
- <span data-ttu-id="01aee-112">Membres (méthodes, champs, événements, etc.) que le type contient.</span><span class="sxs-lookup"><span data-stu-id="01aee-112">The members (methods, fields, events, and so on) that it contains.</span></span>  
  
- <span data-ttu-id="01aee-113">Type de base dont le type est hérité.</span><span class="sxs-lookup"><span data-stu-id="01aee-113">The base type it inherits from.</span></span>  
  
- <span data-ttu-id="01aee-114">Emplacement où sera allouée la mémoire pour les variables au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="01aee-114">The location where the memory for variables will be allocated at run time.</span></span>  
  
- <span data-ttu-id="01aee-115">Sortes d’opérations autorisées.</span><span class="sxs-lookup"><span data-stu-id="01aee-115">The kinds of operations that are permitted.</span></span>  
  
<span data-ttu-id="01aee-116">Le compilateur utilise les informations de type pour s’assurer que toutes les opérations qui sont effectuées dans votre code sont de *type safe*.</span><span class="sxs-lookup"><span data-stu-id="01aee-116">The compiler uses type information to make sure that all operations that are performed in your code are *type safe*.</span></span> <span data-ttu-id="01aee-117">Par exemple, si vous déclarez une variable de type [int](language-reference/keywords/int.md), le compilateur vous permet d’utiliser la variable dans des opérations d’addition et de soustraction.</span><span class="sxs-lookup"><span data-stu-id="01aee-117">For example, if you declare a variable of type [int](language-reference/keywords/int.md), the compiler allows you to use the variable in addition and subtraction operations.</span></span> <span data-ttu-id="01aee-118">Si vous essayez d’effectuer ces mêmes opérations avec une variable de type [bool](language-reference/keywords/bool.md), le compilateur génère une erreur, comme illustré dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="01aee-118">If you try to perform those same operations on a variable of type [bool](language-reference/keywords/bool.md), the compiler generates an error, as shown in the following example:</span></span>  
  
[!code-csharp[Type Safety](../../samples/snippets/csharp/concepts/basic-types/type-safety.cs)]  
  
> [!NOTE]  
> <span data-ttu-id="01aee-119">Développeurs C et C++ : notez que dans C#, [bool](language-reference/keywords/bool.md) n’est pas convertible en [int](language-reference/keywords/int.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-119">C and C++ developers, notice that in C#, [bool](language-reference/keywords/bool.md) is not convertible to [int](language-reference/keywords/int.md).</span></span>  
  
<span data-ttu-id="01aee-120">Le compilateur incorpore les informations de type dans le fichier exécutable sous forme de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="01aee-120">The compiler embeds the type information into the executable file as metadata.</span></span> <span data-ttu-id="01aee-121">Le common language runtime (CLR) utilise ces métadonnées au moment de l’exécution pour garantir la cohérence des types quand il alloue et libère de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="01aee-121">The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</span></span>  

## <a name="specifying-types-in-variable-declarations"></a><span data-ttu-id="01aee-122">Spécification de types dans les déclarations de variable</span><span class="sxs-lookup"><span data-stu-id="01aee-122">Specifying types in variable declarations</span></span>

<span data-ttu-id="01aee-123">Quand vous déclarez une variable ou une constante dans un programme, vous devez spécifier son type ou utiliser le mot clé [var](language-reference/keywords/var.md) pour permettre au compilateur de déduire le type.</span><span class="sxs-lookup"><span data-stu-id="01aee-123">When you declare a variable or constant in a program, you must either specify its type or use the [var](language-reference/keywords/var.md) keyword to let the compiler infer the type.</span></span> <span data-ttu-id="01aee-124">L’exemple suivant montre des déclarations de variable qui utilisent des types numériques intégrés et des types complexes définis par l’utilisateur :</span><span class="sxs-lookup"><span data-stu-id="01aee-124">The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</span></span>  
  
[!code-csharp[Variable Declaration](../../samples/snippets/csharp/concepts/basic-types/variable-declaration.cs)]  
  
<span data-ttu-id="01aee-125">Les types de paramètres de méthode et de valeurs de retour sont spécifiés dans la signature de méthode.</span><span class="sxs-lookup"><span data-stu-id="01aee-125">The types of method parameters and return values are specified in the method signature.</span></span> <span data-ttu-id="01aee-126">La signature suivante présente une méthode qui requiert [int](language-reference/keywords/int.md) comme argument d’entrée et retourne une chaîne :</span><span class="sxs-lookup"><span data-stu-id="01aee-126">The following signature shows a method that requires an [int](language-reference/keywords/int.md) as an input argument and returns a string:</span></span>  
  
[!code-csharp[Method Signature](../../samples/snippets/csharp/concepts/basic-types/method-signature.cs)]  
  
<span data-ttu-id="01aee-127">Après qu’une variable est déclarée, elle ne peut pas être déclarée de nouveau avec un nouveau type et elle ne peut pas être définie sur une valeur qui n’est pas compatible avec son type déclaré.</span><span class="sxs-lookup"><span data-stu-id="01aee-127">After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.</span></span> <span data-ttu-id="01aee-128">Par exemple, vous ne pouvez pas déclarer une variable de type [int](language-reference/keywords/int.md) et lui assigner la valeur booléenne [true](language-reference/keywords/true-literal.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-128">For example, you cannot declare an [int](language-reference/keywords/int.md) and then assign it a Boolean value of [true](language-reference/keywords/true-literal.md).</span></span> <span data-ttu-id="01aee-129">Toutefois, les valeurs peuvent être converties en d’autres types, par exemple, quand elles sont assignées à de nouvelles variables ou passées comme arguments de méthode.</span><span class="sxs-lookup"><span data-stu-id="01aee-129">However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.</span></span> <span data-ttu-id="01aee-130">Une *conversion de type* qui ne cause pas de perte de données est effectuée automatiquement par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="01aee-130">A *type conversion* that does not cause data loss is performed automatically by the compiler.</span></span> <span data-ttu-id="01aee-131">Une conversion susceptible de causer la perte de données nécessite un *cast* dans le code source.</span><span class="sxs-lookup"><span data-stu-id="01aee-131">A conversion that might cause data loss requires a *cast* in the source code.</span></span>

<span data-ttu-id="01aee-132">Pour plus d’informations, consultez [Cast et conversions de types](programming-guide/types/casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-132">For more information, see [Casting and type conversions](programming-guide/types/casting-and-type-conversions.md).</span></span>

## <a name="built-in-types"></a><span data-ttu-id="01aee-133">Types intégrés</span><span class="sxs-lookup"><span data-stu-id="01aee-133">Built-in types</span></span>

<span data-ttu-id="01aee-134">C# fournit un jeu standard de types numériques intégrés pour représenter les nombres entiers, les valeurs à virgule flottante, les expressions booléennes, les caractères de texte, les valeurs décimales et d’autres types de données.</span><span class="sxs-lookup"><span data-stu-id="01aee-134">C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.</span></span> <span data-ttu-id="01aee-135">Il existe également des types **string** et **object** intégrés,</span><span class="sxs-lookup"><span data-stu-id="01aee-135">There are also built-in **string** and **object** types.</span></span> <span data-ttu-id="01aee-136">que vous pouvez utiliser dans n’importe quel programme C#.</span><span class="sxs-lookup"><span data-stu-id="01aee-136">These are available for you to use in any C# program.</span></span> <span data-ttu-id="01aee-137">Pour plus d’informations sur les types intégrés, consultez [Tableaux de référence des types intégrés](language-reference/keywords/built-in-types-table.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-137">For a more information about the built-in types, see [Reference table for built-in types](language-reference/keywords/built-in-types-table.md).</span></span>  
  
## <a name="custom-types"></a><span data-ttu-id="01aee-138">Types personnalisés</span><span class="sxs-lookup"><span data-stu-id="01aee-138">Custom types</span></span>

<span data-ttu-id="01aee-139">Utilisez des constructions [struct](language-reference/keywords/class.md), [class](language-reference/keywords/class.md), [interface](language-reference/keywords/interface.md) et [enum](language-reference/keywords/enum.md) pour créer vos propres types personnalisés.</span><span class="sxs-lookup"><span data-stu-id="01aee-139">You use the [struct](language-reference/keywords/class.md), [class](language-reference/keywords/class.md), [interface](language-reference/keywords/interface.md), and [enum](language-reference/keywords/enum.md) constructs to create your own custom types.</span></span> <span data-ttu-id="01aee-140">La bibliothèque de classes .NET Framework est une collection de types personnalisés fournie par Microsoft que vous pouvez utiliser dans vos propres applications.</span><span class="sxs-lookup"><span data-stu-id="01aee-140">The .NET Framework class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.</span></span> <span data-ttu-id="01aee-141">Par défaut, les types les plus fréquemment utilisés dans la bibliothèque de classes sont disponibles dans tous les programmes C#.</span><span class="sxs-lookup"><span data-stu-id="01aee-141">By default, the most frequently used types in the class library are available in any C# program.</span></span> <span data-ttu-id="01aee-142">Les autres types sont disponibles uniquement si vous ajoutez explicitement une référence de projet à l’assembly dans lequel ils sont définis.</span><span class="sxs-lookup"><span data-stu-id="01aee-142">Others become available only when you explicitly add a project reference to the assembly in which they are defined.</span></span> <span data-ttu-id="01aee-143">Une fois que le compilateur a une référence à l’assembly, vous pouvez déclarer des variables (et des constantes) des types déclarés dans cet assembly dans le code source.</span><span class="sxs-lookup"><span data-stu-id="01aee-143">After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.</span></span>
  
## <a name="generic-types"></a><span data-ttu-id="01aee-144">Types génériques</span><span class="sxs-lookup"><span data-stu-id="01aee-144">Generic types</span></span>

<span data-ttu-id="01aee-145">Un type peut être déclaré avec un ou plusieurs *paramètres de type* qui servent d’espace réservé pour le type réel (le *type concret*) que le code client fournit quand il crée une instance du type.</span><span class="sxs-lookup"><span data-stu-id="01aee-145">A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type.</span></span> <span data-ttu-id="01aee-146">Ces types sont appelés *types génériques*.</span><span class="sxs-lookup"><span data-stu-id="01aee-146">Such types are called *generic types*.</span></span> <span data-ttu-id="01aee-147">Par exemple, le type .NET Framework <xref:System.Collections.Generic.List%601> a un paramètre de type qui, par convention, porte le nom *T*. Lorsque vous créez une instance du type, vous spécifiez le type des objets contenus dans la liste, par exemple, une chaîne :</span><span class="sxs-lookup"><span data-stu-id="01aee-147">For example, the .NET Framework type <xref:System.Collections.Generic.List%601> has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</span></span>  
  
[!code-csharp[Generic types](../../samples/snippets/csharp/concepts/basic-types/generic-type.cs)]
  
<span data-ttu-id="01aee-148">L’utilisation du paramètre de type rend possible la réutilisation de la même classe pour contenir tout type d’élément, sans avoir à convertir chaque élément en [object](language-reference/keywords/object.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-148">The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](language-reference/keywords/object.md).</span></span> <span data-ttu-id="01aee-149">Les classes de collections génériques sont appelées *collections fortement typées*, car le compilateur connaît le type spécifique des éléments de chaque collection et il peut déclencher une erreur au moment de la compilation. C’est le cas, par exemple, si vous essayez d’ajouter un entier à l’objet `strings` dans l’exemple précédent.</span><span class="sxs-lookup"><span data-stu-id="01aee-149">Generic collection classes are called *strongly-typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `strings` object in the previous example.</span></span> <span data-ttu-id="01aee-150">Pour plus d’informations, consultez [Génériques](programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-150">For more information, see [Generics](programming-guide/generics/index.md).</span></span>

## <a name="implicit-types-anonymous-types-and-tuple-types"></a><span data-ttu-id="01aee-151">Types implicites, types anonymes et types tuple</span><span class="sxs-lookup"><span data-stu-id="01aee-151">Implicit types, anonymous types, and tuple types</span></span>

<span data-ttu-id="01aee-152">Comme indiqué précédemment, vous pouvez assigner implicitement un type à une variable locale (mais pas les membres de la classe) à l’aide du mot clé [var](language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-152">As stated previously, you can implicitly type a local variable (but not class members) by using the [var](language-reference/keywords/var.md) keyword.</span></span> <span data-ttu-id="01aee-153">La variable reçoit toujours un type au moment de la compilation, mais le type est fourni par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="01aee-153">The variable still receives a type at compile time, but the type is provided by the compiler.</span></span> <span data-ttu-id="01aee-154">Pour plus d’informations, consultez [Variables locales implicitement typées](programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-154">For more information, see [Implicitly typed local variables](programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
<span data-ttu-id="01aee-155">Dans certains cas, il est difficile de créer un type nommé pour des ensembles simples de valeurs associées que vous ne souhaitez pas stocker ou passer hors de la portée de la méthode.</span><span class="sxs-lookup"><span data-stu-id="01aee-155">In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.</span></span> <span data-ttu-id="01aee-156">Vous pouvez alors créer des *types anonymes*.</span><span class="sxs-lookup"><span data-stu-id="01aee-156">You can create *anonymous types* for this purpose.</span></span> <span data-ttu-id="01aee-157">Pour plus d’informations, consultez [Types anonymes](programming-guide/classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-157">For more information, see [Anonymous types](programming-guide/classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="01aee-158">Il est courant de vouloir retourner plusieurs valeurs d’une méthode.</span><span class="sxs-lookup"><span data-stu-id="01aee-158">It's common to want to return more than one value from a method.</span></span> <span data-ttu-id="01aee-159">Vous pouvez créer des *types tuple* qui retournent plusieurs valeurs dans un seul appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="01aee-159">You can create *tuple types* that return multiple values in a single method call.</span></span> <span data-ttu-id="01aee-160">Pour plus d’informations, consultez [Tuples](tuples.md)</span><span class="sxs-lookup"><span data-stu-id="01aee-160">For more information, see [Tuples](tuples.md)</span></span>

## <a name="the-common-type-system"></a><span data-ttu-id="01aee-161">Système de type commun (CTS)</span><span class="sxs-lookup"><span data-stu-id="01aee-161">The Common type system</span></span>

<span data-ttu-id="01aee-162">Il est important de comprendre ces deux points fondamentaux à propos du système de type dans le .NET Framework :</span><span class="sxs-lookup"><span data-stu-id="01aee-162">It is important to understand two fundamental points about the type system in the .NET Framework:</span></span>  
  
- <span data-ttu-id="01aee-163">Le système prend en charge le principe d’héritage.</span><span class="sxs-lookup"><span data-stu-id="01aee-163">It supports the principle of inheritance.</span></span> <span data-ttu-id="01aee-164">Les types peuvent dériver d’autres types, appelés *types de base*.</span><span class="sxs-lookup"><span data-stu-id="01aee-164">Types can derive from other types, called *base types*.</span></span> <span data-ttu-id="01aee-165">Le type dérivé hérite (avec certaines restrictions) des méthodes, des propriétés et des autres membres du type de base.</span><span class="sxs-lookup"><span data-stu-id="01aee-165">The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.</span></span> <span data-ttu-id="01aee-166">Le type de base peut, à son tour, dériver d’un autre type, auquel cas le type dérivé hérite des membres des deux types de base dans sa hiérarchie d’héritage.</span><span class="sxs-lookup"><span data-stu-id="01aee-166">The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.</span></span> <span data-ttu-id="01aee-167">Tous les types, y compris les types numériques intégrés tels que <xref:System.Int32> (mot clé C# : `int`), dérivent au final d’un seul type de base, qui est <xref:System.Object> (mot clé C# : `object`).</span><span class="sxs-lookup"><span data-stu-id="01aee-167">All types, including built-in numeric types such as <xref:System.Int32> (C# keyword: `int`), derive ultimately from a single base type, which is <xref:System.Object> (C# keyword: `object`).</span></span> <span data-ttu-id="01aee-168">Cette hiérarchie de types unifiée est appelée [Système de type commun](../standard/common-type-system.md) (CTS).</span><span class="sxs-lookup"><span data-stu-id="01aee-168">This unified type hierarchy is called the [Common type system](../standard/common-type-system.md) (CTS).</span></span> <span data-ttu-id="01aee-169">Pour plus d’informations sur l’héritage dans C#, consultez [Héritage](programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-169">For more information about inheritance in C#, see [Inheritance](programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
- <span data-ttu-id="01aee-170">Chaque type du CTS est défini comme *type valeur* ou *type référence*.</span><span class="sxs-lookup"><span data-stu-id="01aee-170">Each type in the CTS is defined as either a *value type* or a *reference type*.</span></span> <span data-ttu-id="01aee-171">Cela inclut tous les types personnalisés fournis dans la bibliothèque de classes .NET Framework, ainsi que les types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="01aee-171">This includes all custom types in the .NET Framework class library and also your own user-defined types.</span></span> <span data-ttu-id="01aee-172">Les types que vous définissez à l’aide du mot clé [struct](language-reference/keywords/struct.md) sont des types valeur ; tous les types numériques intégrés sont des **structs**.</span><span class="sxs-lookup"><span data-stu-id="01aee-172">Types that you define by using the [struct](language-reference/keywords/struct.md) keyword are value types; all the built-in numeric types are **structs**.</span></span> <span data-ttu-id="01aee-173">Pour plus d’informations sur les types valeur, consultez [Structs](structs.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-173">For more information about value types, see [Structs](structs.md).</span></span> <span data-ttu-id="01aee-174">Les types que vous définissez à l’aide du mot clé [class](language-reference/keywords/class.md) sont des types référence.</span><span class="sxs-lookup"><span data-stu-id="01aee-174">Types that you define by using the [class](language-reference/keywords/class.md) keyword are reference types.</span></span> <span data-ttu-id="01aee-175">Pour plus d’informations sur les types référence, consultez [Classes](classes.md).</span><span class="sxs-lookup"><span data-stu-id="01aee-175">For more information about reference types, see [Classes](classes.md).</span></span> <span data-ttu-id="01aee-176">Les types référence et les types valeur ne suivent pas les mêmes règles de compilation et ont un comportement différent au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="01aee-176">Reference types and value types have different compile-time rules, and different run-time behavior.</span></span>

## <a name="see-also"></a><span data-ttu-id="01aee-177">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="01aee-177">See also</span></span>

- [<span data-ttu-id="01aee-178">Structs</span><span class="sxs-lookup"><span data-stu-id="01aee-178">Structs</span></span>](structs.md)
- [<span data-ttu-id="01aee-179">Classes</span><span class="sxs-lookup"><span data-stu-id="01aee-179">Classes</span></span>](classes.md)
