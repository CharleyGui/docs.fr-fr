### YamlMime:Tutorial
title: Explorer C# 6 - Tutoriel interactif sur C#
metadata:
  title: Explorer C# 6 - Essayer les nouvelles fonctionnalités de C# 6 de manière interactive à l’aide d’un navigateur
  description: Dans ce tutoriel, vous allez utiliser votre navigateur pour explorer C# 6 de manière interactive. Vous allez découvrir les nouveaux idiomes que vous pouvez utiliser avec C# 6 pour créer du code plus concis et plus lisible.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: b43400a0fdae338744c521cf7ddb2bfce79fc43c
  ms.sourcegitcommit: c4e9d05644c9cb89de5ce6002723de107ea2e2c4
  ms.translationtype: HT
  ms.contentlocale: fr-FR
  ms.lasthandoff: 05/19/2019
  ms.locfileid: "65881026"
items:
- durationInMinutes: 1
  content: >
    Ce tutoriel vous permet d’explorer C# 6 de manière interactive à l’aide de votre navigateur et d’afficher les résultats de la compilation et de l’exécution de votre code. Il contient une série de leçons qui modifient les pratiques antérieures propres à C# et mettent en avant les fonctionnalités plus récentes et plus concises de C# 6. La suite de cet article fournit une vue d’ensemble de ces fonctionnalités, avec des liens pour explorer chacune d’entre elles.
- title: Les auto-properties en lecture seule prennent en charge les types en lecture seule
  durationInMinutes: 2
  content: "Deux améliorations apportées à la syntaxe des auto-properties facilitent l’utilisation des auto-properties à d’autres niveaux : les auto-properties en lecture seule et les initialiseurs d’auto-properties. Prenons l’exemple de ce petit programme :\n\n[!code-csharp[Starter](../../../../samples/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n Passez en mode Focus, copiez le code précédent dans la fenêtre C# Interactive. Cliquez ensuite sur *Exécuter* pour voir ce que fait le code. `AllCaps` a pour effet secondaire indésirable de modifier les valeurs de propriété et de retourner la chaîne en majuscules. L’auteur de la classe `Person` souhaitait que les chaînes `FirstName` et `LastName` soient en lecture seule. Avec C# 6, vous pouvez clairement indiquer cette intention. Supprimez `private set` des deux propriétés pour créer une auto-property en lecture seule. Cliquez sur *Exécuter* pour voir que le compilateur repère les deux emplacements où les propriétés `FirstName` et `LastName` sont modifiées alors qu’elles n’auraient pas dû l’être. Vous pouvez remplacer la méthode `AllCaps` par le code suivant pour corriger l’erreur du compilateur :\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\nÀ l’aide de cette nouvelle syntaxe, le compilateur garantit que les propriétés sont immuables.\n"
- title: Initialiser les champs de stockage pour les auto-properties
  durationInMinutes: 1
  content: "La nouvelle syntaxe de C# 6 vous permet d’utiliser des initialiseurs pour les auto-properties. Cela est d’autant plus important que les classes développent de nouvelles fonctionnalités. Ajoutez une propriété de deuxième prénom et un nouveau constructeur qui prend trois chaînes pour votre classe `Person` :\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\nL’affectation sur la propriété `MiddleName` est un initialiseur. Il initialise le champ de stockage généré par le compilateur pour le deuxième prénom.\n"
- title: Membres expression-bodied
  durationInMinutes: 2
  content: >
    Les membres expression-bodied fournissent une syntaxe simplifiée pour les méthodes légères. La classe `Person` a deux excellents candidats. Examinez la déclaration de `ToString` :


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    Remplacez cette déclaration de `ToString` par le code suivant :


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    Essayez la même chose avec la méthode `AllCaps`. L’amélioration est modeste. Toutefois, si vous l’utilisez judicieusement, vous obtenez un code beaucoup plus lisible, en particulier pour les objets de transfert de données (DTO) et d’autres types avec un comportement minimal.
- title: Importation d’une classe unique
  durationInMinutes: 2
  content: "Si vous utilisez à plusieurs reprises les méthodes statiques d’une seule classe dans votre code, le fait d’inclure chaque fois le nom de la classe occulte le sens de votre code. La classe `Person` importe actuellement l’espace de noms `System`, même si seul <xref:System.Console?displayProperty=nameWithType> est utilisé. Modifiez l’instruction `using` comme ceci :\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\nL’instruction `static using` devient plus utile dans les grands programmes qui utilisent massivement une seule classe avec plusieurs méthodes statiques, comme la classe [`string`](xref:System.String) ou la classe <xref:System.Math?displayProperty=nameWithType>.\n"
- title: Un meilleur format de chaîne
  durationInMinutes: 2
  content: "C# 6 contient une nouvelle syntaxe pour la composition de chaînes à partir d’une chaîne et des expressions intégrées qui sont évaluées pour produire d’autres valeurs de chaîne. Vous pouvez changer les méthodes `ToString` et `AllCaps` pour qu’elles utilisent cette syntaxe :\n\n[!code-csharp[StringInterpolation](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\nAu lieu d’arguments positionnels entre `{` et `}`, vous écrivez directement les expressions C#. Vous pouvez faire la même chose dans la méthode `Main`. Remplacez le code existant par le code ci-dessous :\n\n[!code-csharp[InterpolationMain](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\nVous n’êtes pas limité à une seule variable dans ces expressions. Commençons par un nouvel exemple que nous allons modifier pour illustrer les autres expressions qu’il est possible d’utiliser avec l’interpolation de chaîne. Collez le code suivant dans la fenêtre interactive dans la méthode `Main` :\n\n[!code-csharp[Phrases](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \n\nVous pouvez supprimer la variable locale `average` et effectuer ce calcul dans le cadre de l’expression de chaîne interpolée. Remplacez les deux dernières lignes par ce qui suit :\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\nEn exécutant l’exemple précédent, vous pouvez voir que la sortie de `Average` a plus de décimales que vous ne le souhaitez. La syntaxe d’interpolation de chaîne prend en charge toutes les chaînes de format disponibles en utilisant des méthodes de mise en forme précédentes. Vous spécifiez la chaîne de format entre les accolades. Ajoutez un `:` après l’expression à mettre en forme :\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: Vérifications null simples et rapides
  durationInMinutes: 2
  content: "L’opérateur `?.` (conditionnel null) facilite l’écriture d’une logique qui prend en compte les valeurs `null` de manière fluide, sans vérifications `if` supplémentaires. Pour explorer la fonctionnalité, commencez par copier le code suivant dans la fenêtre interactive pour l’essayer :\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\nL’exception <xref:System.NullReferenceException> est levée quand vous exécutez l’exemple. Remplacez l’opérateur d’accès aux membres `.` par l’**opérateur null conditionnel** :\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\nAprès ce changement, aucune sortie n’est générée. Cela est dû au fait que le résultat de `s?.Length` est un `int?` alors que le résultat de `s.Length` est un `int`. Dans cet exemple, `s?.Length` est `null`. Le `?.` retourne `null` si son opérande gauche est `null`. Si le type de l’opérande droit est un type valeur, l’opérateur `?.` retourne un type nullable pour ce type. En plus de `?.`, vous pouvez utiliser `?[]` pour accéder à un tableau ou à un indexeur. Exécutez le code suivant dans la fenêtre interactive :\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n Plusieurs opérateurs conditionnels peuvent être combinés dans une seule expression. Un opérande gauche `null` produit un résultat `null`, ce qui permet d’éviter que des clauses if imbriquées n’aient accès aux membres de membres. Par exemple, essayez le code suivant dans la fenêtre interactive :\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n Vous pouvez simplifier l’exemple précédent en utilisant l’**opérateur de fusion null** pour fournir une valeur par défaut :\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n L’**opérateur conditionnel null** vous aide à écrire du code qui clarifie votre logique métier tout en testant de manière fluide la présence de valeurs `null`.\n"
- title: Filtres d’exceptions
  durationInMinutes: 2
  content: "Les filtres d’exception vous permettent d’intercepter une exception en fonction d’une condition donnée. Une utilisation type consiste à créer une méthode de filtrage qui journalise les exceptions, mais qui ne les gère jamais. Un filtre d’exception est une expression booléenne qui a la valeur `true` quand la clause `catch` doit être exécutée et `false` quand l’exception ne doit pas être interceptée par la clause `catch`. Exécutez le code suivant dans la fenêtre interactive : Il journalise le type d’exception et le message dans la console. Il retourne `false`, ce qui indique que l’exception ne peut pas être gérée. Essayez le programme dans la fenêtre interactive.\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\nVous devez voir le message de la méthode `LogException`, suivi du message d’exception par défaut. Juste pour voir, remplacez l’instruction `return false` par `return true` et réexécutez le code. L’exception est maintenant interceptée et le programme s’exécute jusqu’au bout.\n\nAu-delà des scénarios de journalisation, les filtres d’exception peuvent être particulièrement utiles quand une propriété de l’exception détermine l’action à entreprendre. Par exemple, vous pouvez regarder à l’intérieur d’un <xref:System.AggregateException> pour voir les exceptions qu’il contient et prendre les mesures appropriées en fonction de l’exception spécifique.\n"
- title: Utilisation de nameof
  durationInMinutes: 2
  content: "L’opérateur `nameof` retourne le nom d’une variable, d’un type ou d’un membre de type. Pour découvrir son fonctionnement, essayez le code suivant dans la fenêtre interactive :\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\nLa sortie correspond au nom de la variable ou du type. Même si vous avez fourni le nom complet du type (par exemple, `System.String`), l’opérateur `nameof` retourne le nom non complet. Cette fonctionnalité est particulièrement utile quand vous avez besoin de convertir un nom de paramètre ou de propriété en chaîne. Citons par exemple la capture du nom d’un argument pour lever une exception <xref:System.ArgumentNullException> ou <xref:System.ArgumentException>, ou celle du nom d’une propriété modifiée lors de l’implémentation d’<xref:System.ComponentModel.INotifyPropertyChanged>. \n"
- title: Syntaxe d’initialisation d’un nouvel objet
  durationInMinutes: 2
  content: "La syntaxe de l’initialiseur d’objet prend désormais en charge l’initialisation d’*indexeurs*, ainsi que des propriétés et des champs. Cet ajout facilite l’initialisation de dictionnaires et d’autres types. Commencez par un dictionnaire. Exécutez le code suivant dans la fenêtre interactive :\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\nCette syntaxe, qui définit une valeur dans un indexeur, peut être utilisée pour tout type qui a un accesseur set accessible sur un indexeur.\n\nUn second changement facilite l’activation de la syntaxe d’initialiseur pour les types qui représentent des séquences. Les initialiseurs de collection peuvent être utilisés sur toute classe qui implémente <xref:System.Collections.IEnumerable> et qui a une méthode `Add` accessible publiquement. Cette méthode `Add` peut maintenant être une méthode d’extension. \n\nL’exemple suivant montre un scénario pour cette syntaxe. Il crée une classe `Path` qui implémente `IEnumerable<Point3D>` et qui a une méthode pour ajouter des points qui prennent trois arguments. La classe `Extensions` crée une méthode `Add` supplémentaire pour ajouter un nouveau point à partir de ses trois composants. Cet exemple ne s’exécute actuellement pas de manière interactive en raison de restrictions dans l’environnement.\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: >
    Vous venez d’explorer les nouvelles fonctionnalités de C# 6. Essayez-les à présent par vous-même dans vos applications.
