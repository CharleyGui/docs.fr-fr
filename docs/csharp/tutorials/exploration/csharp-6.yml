### YamlMime:Tutorial
title: <span data-ttu-id="bdeef-101">Explorer C# 6 - Tutoriel interactif sur C#</span><span class="sxs-lookup"><span data-stu-id="bdeef-101">Explore C# 6 - C# interactive C# tutorial</span></span>
metadata:
  title: Explorer C# 6 - Essayer les nouvelles fonctionnalités de C# 6 de manière interactive à l’aide d’un navigateur
  description: Dans ce tutoriel, vous allez utiliser votre navigateur pour explorer C# 6 de manière interactive. Vous allez découvrir les nouveaux idiomes que vous pouvez utiliser avec C# 6 pour créer du code plus concis et plus lisible.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: f6f4b95b0c9afd9f70d4eba41500fc8a26606c78
  ms.sourcegitcommit: c70542d02736e082e8dac67dad922c19249a8893
  ms.translationtype: MT
  ms.contentlocale: fr-FR
  ms.lasthandoff: 09/05/2019
  ms.locfileid: "70374324"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="bdeef-105">Ce tutoriel vous permet d’explorer C# 6 de manière interactive à l’aide de votre navigateur et d’afficher les résultats de la compilation et de l’exécution de votre code.</span><span class="sxs-lookup"><span data-stu-id="bdeef-105">This tutorial lets you explore C# 6 interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="bdeef-106">Il contient une série de leçons qui modifient les pratiques antérieures propres à C# et mettent en avant les fonctionnalités plus récentes et plus concises de C# 6.</span><span class="sxs-lookup"><span data-stu-id="bdeef-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 6 features.</span></span> <span data-ttu-id="bdeef-107">La suite de cet article fournit une vue d’ensemble de ces fonctionnalités, avec des liens pour explorer chacune d’entre elles.</span><span class="sxs-lookup"><span data-stu-id="bdeef-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="bdeef-108">Les auto-properties en lecture seule prennent en charge les types en lecture seule</span><span class="sxs-lookup"><span data-stu-id="bdeef-108">Read-only auto-properties enable read-only types</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"bdeef-109\">Deux améliorations apportées à la syntaxe des auto-properties facilitent l’utilisation des auto-properties à d’autres niveaux : les auto-properties en lecture seule et les initialiseurs d’auto-properties.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-109\">Two enhancements to auto-property syntax make it easier to use auto-properties in more places: read-only auto-properties and auto-property initializers.</span></span> <span data-ttu-id=\"bdeef-110\">Prenons l’exemple de ce petit programme :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-110\">Consider this small program:</span></span>\n\n[!code-csharp[Starter](../../../../samples/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n <span data-ttu-id=\"bdeef-111\">Passez en mode Focus, copiez le code précédent dans la fenêtre C# Interactive.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-111\">Enter Focus mode, copy the preceding code into the C# interactive window.</span></span> <span data-ttu-id=\"bdeef-112\">Cliquez ensuite sur *Exécuter* pour voir ce que fait le code.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-112\">Then, click *Run* to see what the code does.</span></span> <span data-ttu-id=\"bdeef-113\">`AllCaps` a pour effet secondaire indésirable de modifier les valeurs de propriété et de retourner la chaîne en majuscules.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-113\">`AllCaps` has the undesirable side effect of modifying the property values along with returning the uppercase string.</span></span> <span data-ttu-id=\"bdeef-114\">L’auteur de la classe `Person` souhaitait que les chaînes `FirstName` et `LastName` soient en lecture seule.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-114\">The author of the `Person` class intended the strings for `FirstName` and `LastName` to be read-only.</span></span> <span data-ttu-id=\"bdeef-115\">Avec C# 6, vous pouvez clairement indiquer cette intention.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-115\">With C# 6, you can make that intent clear.</span></span> <span data-ttu-id=\"bdeef-116\">Supprimez `private set` des deux propriétés pour créer une auto-property en lecture seule.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-116\">Remove the `private set` from both properties to create a read-only auto property.</span></span> <span data-ttu-id=\"bdeef-117\">Cliquez sur *Exécuter* pour voir que le compilateur repère les deux emplacements où les propriétés `FirstName` et `LastName` sont modifiées alors qu’elles n’auraient pas dû l’être.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-117\">Click *Run* to see that the compiler spots the two locations where the `FirstName` and `LastName` properties are changed when they should not have been.</span></span> <span data-ttu-id=\"bdeef-118\">Vous pouvez remplacer la méthode `AllCaps` par le code suivant pour corriger l’erreur du compilateur :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-118\">You can change the `AllCaps` method to the following code to fix the compiler error:</span></span>\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\n<span data-ttu-id=\"bdeef-119\">À l’aide de cette nouvelle syntaxe, le compilateur garantit que les propriétés sont immuables.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-119\">Using this new syntax, the compiler ensures that the properties are immutable.</span></span>\n"
- title: <span data-ttu-id="bdeef-120">Initialiser les champs de stockage pour les auto-properties</span><span class="sxs-lookup"><span data-stu-id="bdeef-120">Initialize backing fields for auto-properties</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"bdeef-121\">La nouvelle syntaxe de C# 6 vous permet d’utiliser des initialiseurs pour les auto-properties.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-121\">New syntax in C# 6 enables you to use initializers for auto-properties.</span></span> <span data-ttu-id=\"bdeef-122\">Cela est d’autant plus important que les classes développent de nouvelles fonctionnalités.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-122\">This becomes more important as classes grow new capabilities.</span></span> <span data-ttu-id=\"bdeef-123\">Ajoutez une propriété de deuxième prénom et un nouveau constructeur qui prend trois chaînes pour votre classe `Person` :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-123\">Add a middle name property, and a new constructor that takes three strings to your `Person` class:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\n<span data-ttu-id=\"bdeef-124\">L’affectation sur la propriété `MiddleName` est un initialiseur.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-124\">The assignment on the `MiddleName` property is an initializer.</span></span> <span data-ttu-id=\"bdeef-125\">Il initialise le champ de stockage généré par le compilateur pour le deuxième prénom.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-125\">It initializes the compiler-generated backing field for the middle name.</span></span>\n"
- title: <span data-ttu-id="bdeef-126">Membres expression-bodied</span><span class="sxs-lookup"><span data-stu-id="bdeef-126">Expression-bodied members</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="bdeef-127">Les membres expression-bodied fournissent une syntaxe simplifiée pour les méthodes légères.</span><span class="sxs-lookup"><span data-stu-id="bdeef-127">Expression-bodied members provide a lightweight syntax for lightweight methods.</span></span> <span data-ttu-id="bdeef-128">La classe `Person` a deux excellents candidats.</span><span class="sxs-lookup"><span data-stu-id="bdeef-128">The `Person` class has two great candidates.</span></span> <span data-ttu-id="bdeef-129">Examinez la déclaration de `ToString` :</span><span class="sxs-lookup"><span data-stu-id="bdeef-129">Look at the declaration of `ToString`:</span></span>


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    <span data-ttu-id="bdeef-130">Remplacez cette déclaration de `ToString` par le code suivant :</span><span class="sxs-lookup"><span data-stu-id="bdeef-130">Replace that declaration of `ToString` with the following code:</span></span>


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    <span data-ttu-id="bdeef-131">Essayez la même chose avec la méthode `AllCaps`.</span><span class="sxs-lookup"><span data-stu-id="bdeef-131">Try the same with the `AllCaps` method.</span></span> <span data-ttu-id="bdeef-132">L’amélioration est modeste. Toutefois, si vous l’utilisez judicieusement, vous obtenez un code beaucoup plus lisible, en particulier pour les objets de transfert de données (DTO) et d’autres types avec un comportement minimal.</span><span class="sxs-lookup"><span data-stu-id="bdeef-132">This is a small improvement, but when used wisely it creates much more readable code, especially for Data Transfer Objects (DTOs) and other types with minimal behavior.</span></span>
- title: <span data-ttu-id="bdeef-133">Importation d’une classe unique</span><span class="sxs-lookup"><span data-stu-id="bdeef-133">Importing a single class</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"bdeef-134\">Si vous utilisez à plusieurs reprises les méthodes statiques d’une seule classe dans votre code, le fait d’inclure chaque fois le nom de la classe occulte le sens de votre code.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-134\">If you repeatedly use one class' static methods throughout your code, including the class name each time obscures the meaning of your code.</span></span> <span data-ttu-id=\"bdeef-135\">La classe `Person` importe actuellement l’espace de noms `System`, même si seul <xref:System.Console?displayProperty=nameWithType> est utilisé.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-135\">The `Person` class currently imports the `System` namespace, even though only <xref:System.Console?displayProperty=nameWithType> is used.</span></span> <span data-ttu-id=\"bdeef-136\">Modifiez l’instruction `using` comme ceci :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-136\">Modify the `using` statement as follows:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\n<span data-ttu-id=\"bdeef-137\">L’instruction `static using` devient plus utile dans les grands programmes qui utilisent massivement une seule classe avec plusieurs méthodes statiques, comme la classe [`string`](xref:System.String) ou la classe <xref:System.Math?displayProperty=nameWithType>.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-137\">The `static using` statement becomes more useful in larger programs that make extensive use of a single class with many static methods, like the [`string`](xref:System.String) class or the <xref:System.Math?displayProperty=nameWithType> class.</span></span>\n"
- title: <span data-ttu-id="bdeef-138">Un meilleur format de chaîne</span><span class="sxs-lookup"><span data-stu-id="bdeef-138">A better string format</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"bdeef-139\">C# 6 contient une nouvelle syntaxe pour la composition de chaînes à partir d’une chaîne et des expressions intégrées qui sont évaluées pour produire d’autres valeurs de chaîne.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-139\">C# 6 contains new syntax for composing strings from a string and embedded expressions that are evaluated to produce other string values.</span></span> <span data-ttu-id=\"bdeef-140\">Vous pouvez changer les méthodes `ToString` et `AllCaps` pour qu’elles utilisent cette syntaxe :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-140\">You can change the `ToString` and `AllCaps` methods to use this syntax:</span></span>\n\n[!code-csharp[StringInterpolation](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\n<span data-ttu-id=\"bdeef-141\">Au lieu d’arguments positionnels entre `{` et `}`, vous écrivez directement les expressions C#.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-141\">Instead of positional arguments between the `{` and `}`, you write C# expressions directly.</span></span> <span data-ttu-id=\"bdeef-142\">Vous pouvez faire la même chose dans la méthode `Main`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-142\">You can do the same in the `Main` method.</span></span> <span data-ttu-id=\"bdeef-143\">Remplacez le code existant par le code ci-dessous :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-143\">Replace the existing code with the following:</span></span>\n\n[!code-csharp[InterpolationMain](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\n<span data-ttu-id=\"bdeef-144\">Vous n’êtes pas limité à une seule variable dans ces expressions.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-144\">You're not limited to a single variable in these expressions.</span></span> <span data-ttu-id=\"bdeef-145\">Commençons par un nouvel exemple que nous allons modifier pour illustrer les autres expressions qu’il est possible d’utiliser avec l’interpolation de chaîne.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-145\">Let's start with a new example and modify it to demonstrate other expressions you can use with string interpolation.</span></span> <span data-ttu-id=\"bdeef-146\">Collez le code suivant dans la fenêtre interactive dans la méthode `Main` :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-146\">Paste the following code into the interactive window in the `Main` method:</span></span>\n\n[!code-csharp[Phrases](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \n\n<span data-ttu-id=\"bdeef-147\">Vous pouvez supprimer la variable locale `average` et effectuer ce calcul dans le cadre de l’expression de chaîne interpolée.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-147\">You can remove the local variable `average` and perform that calculation as part of the interpolated string expression.</span></span> <span data-ttu-id=\"bdeef-148\">Remplacez les deux dernières lignes par ce qui suit :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-148\">Replace the last two lines with the following:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\n<span data-ttu-id=\"bdeef-149\">En exécutant l’exemple précédent, vous pouvez voir que la sortie de `Average` a plus de décimales que vous ne le souhaitez.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-149\">Running the preceding example, you would find that the output for `Average` has more decimal places than you would like.</span></span> <span data-ttu-id=\"bdeef-150\">La syntaxe d’interpolation de chaîne prend en charge toutes les chaînes de format disponibles en utilisant des méthodes de mise en forme précédentes.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-150\">The string interpolation syntax supports all the format strings available using earlier formatting methods.</span></span> <span data-ttu-id=\"bdeef-151\">Vous spécifiez la chaîne de format entre les accolades.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-151\">You specify the format string inside the braces.</span></span> <span data-ttu-id=\"bdeef-152\">Ajoutez un `:` après l’expression à mettre en forme :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-152\">Add a `:` following the expression to format:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: <span data-ttu-id="bdeef-153">Vérifications null simples et rapides</span><span class="sxs-lookup"><span data-stu-id="bdeef-153">Quick and easy null checks</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"bdeef-154\">L’opérateur `?.` (conditionnel null) facilite l’écriture d’une logique qui prend en compte les valeurs `null` de manière fluide, sans vérifications `if` supplémentaires.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-154\">The `?.` (null conditional) operator makes it easier to write logic that takes `null` values into account seamlessly, without extra `if` checks.</span></span> <span data-ttu-id=\"bdeef-155\">Pour explorer la fonctionnalité, commencez par copier le code suivant dans la fenêtre interactive pour l’essayer :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-155\">To explore the feature, start by copying the following code into the interactive window to try it:</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\n<span data-ttu-id=\"bdeef-156\">L’exception <xref:System.NullReferenceException> est levée quand vous exécutez l’exemple.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-156\">It throws a <xref:System.NullReferenceException> when you run the sample.</span></span> <span data-ttu-id=\"bdeef-157\">Remplacez l’opérateur d’accès aux membres `.` par l’**opérateur null conditionnel** :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-157\">Change the `.` member access operator to the **null conditional operator**:</span></span>\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\n<span data-ttu-id=\"bdeef-158\">Après ce changement, aucune sortie n’est générée.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-158\">After this change, there's no output.</span></span> <span data-ttu-id=\"bdeef-159\">Cela est dû au fait que le résultat de `s?.Length` est un `int?` alors que le résultat de `s.Length` est un `int`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-159\">That's because the result of `s?.Length` is an `int?` when the result of `s.Length` is an `int`.</span></span> <span data-ttu-id=\"bdeef-160\">Dans cet exemple, `s?.Length` est `null`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-160\">In this example, `s?.Length` is `null`.</span></span> <span data-ttu-id=\"bdeef-161\">Le `?.` retourne `null` si son opérande gauche est `null`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-161\">The `?.` returns `null` if its left operand is `null`.</span></span> <span data-ttu-id=\"bdeef-162\">Si le type de l’opérande droit est un type valeur, l’opérateur `?.` retourne un type nullable pour ce type.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-162\">If the type of the right operand is a value type, the `?.` operator returns a nullable type for that type.</span></span> <span data-ttu-id=\"bdeef-163\">En plus de `?.`, vous pouvez utiliser `?[]` pour accéder à un tableau ou à un indexeur.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-163\">In addition to `?.` you can use `?[]` for array or indexer access.</span></span> <span data-ttu-id=\"bdeef-164\">Exécutez le code suivant dans la fenêtre interactive :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-164\">Try the following code in the interactive window:</span></span>\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n <span data-ttu-id=\"bdeef-165\">Plusieurs opérateurs conditionnels peuvent être combinés dans une seule expression.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-165\">Multiple conditional operators can be combined into a single expression.</span></span> <span data-ttu-id=\"bdeef-166\">Un opérande gauche `null` produit un résultat `null`, ce qui permet d’éviter que des clauses if imbriquées n’aient accès aux membres de membres.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-166\">A `null` left operand produces a `null` result, making it easy to avoid nested if clauses to access members of members.</span></span> <span data-ttu-id=\"bdeef-167\">Par exemple, essayez le code suivant dans la fenêtre interactive :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-167\">For example, try the following code in the interactive window:</span></span>\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n <span data-ttu-id=\"bdeef-168\">Vous pouvez simplifier l’exemple précédent en utilisant l’**opérateur de fusion null** pour fournir une valeur par défaut :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-168\">The preceding example can be simplified by using the **null coalescing operator** to provide a default value:</span></span>\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n <span data-ttu-id=\"bdeef-169\">L’**opérateur conditionnel null** vous aide à écrire du code qui clarifie votre logique métier tout en testant de manière fluide la présence de valeurs `null`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-169\">The **null conditional operator** helps you write code that makes your core logic clear while seamlessly testing for `null` values.</span></span>\n"
- title: <span data-ttu-id="bdeef-170">Filtres d’exceptions</span><span class="sxs-lookup"><span data-stu-id="bdeef-170">Exception filters</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"bdeef-171\">Les filtres d’exception vous permettent d’intercepter une exception en fonction d’une condition donnée.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-171\">Exception filters enable you to catch an exception based on some condition.</span></span> <span data-ttu-id=\"bdeef-172\">Une utilisation type consiste à créer une méthode de filtrage qui journalise les exceptions, mais qui ne les gère jamais.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-172\">A typical use is to create a filter method that logs exceptions, but never handles those exceptions.</span></span> <span data-ttu-id=\"bdeef-173\">Un filtre d’exception est une expression booléenne qui a la valeur `true` quand la clause `catch` doit être exécutée et `false` quand l’exception ne doit pas être interceptée par la clause `catch`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-173\">An exception filter is a boolean expression that is `true` when the `catch` clause should be executed, and `false` when the exception should not be caught by the `catch` clause.</span></span> <span data-ttu-id=\"bdeef-174\">Exécutez le code suivant dans la fenêtre interactive : Il journalise le type d’exception et le message dans la console.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-174\">Try the following code in the interactive window: It logs the exception type and message to the console.</span></span> <span data-ttu-id=\"bdeef-175\">Il retourne `false`, ce qui indique que l’exception ne peut pas être gérée.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-175\">It returns `false` which indicates that the exception can't be handled.</span></span> <span data-ttu-id=\"bdeef-176\">Essayez le programme dans la fenêtre interactive.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-176\">Try the program in the interactive window.</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\n<span data-ttu-id=\"bdeef-177\">Vous devez voir le message de la méthode `LogException`, suivi du message d’exception par défaut.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-177\">You should see the message from the `LogException` method, followed by the default exception message.</span></span> <span data-ttu-id=\"bdeef-178\">Juste pour voir, remplacez l’instruction `return false` par `return true` et réexécutez le code.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-178\">Just to experiment, change the `return false` statement to `return true` and run this again.</span></span> <span data-ttu-id=\"bdeef-179\">L’exception est maintenant interceptée et le programme s’exécute jusqu’au bout.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-179\">Now, the exception is caught and the program runs to completion.</span></span>\n\n<span data-ttu-id=\"bdeef-180\">Au-delà des scénarios de journalisation, les filtres d’exception peuvent être particulièrement utiles quand une propriété de l’exception détermine l’action à entreprendre.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-180\">Beyond logging scenarios, exception filters can be most useful when a property of the exception determines what action to take.</span></span> <span data-ttu-id=\"bdeef-181\">Par exemple, vous pouvez regarder à l’intérieur d’un <xref:System.AggregateException> pour voir les exceptions qu’il contient et prendre les mesures appropriées en fonction de l’exception spécifique.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-181\">For example, you can look inside an <xref:System.AggregateException> to see what the contained exceptions are and take some appropriate action depending on the specific exception.</span></span>\n"
- title: <span data-ttu-id="bdeef-182">Utilisation de nameof</span><span class="sxs-lookup"><span data-stu-id="bdeef-182">Using nameof</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"bdeef-183\">L’opérateur `nameof` retourne le nom d’une variable, d’un type ou d’un membre de type.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-183\">The `nameof` operator returns the name of any variable, a type, or a type's member.</span></span> <span data-ttu-id=\"bdeef-184\">Pour découvrir son fonctionnement, essayez le code suivant dans la fenêtre interactive :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-184\">Try the following code in the interactive window to see how it works:</span></span>\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\n<span data-ttu-id=\"bdeef-185\">La sortie correspond au nom de la variable ou du type.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-185\">The output matches the name of the variable or type.</span></span> <span data-ttu-id=\"bdeef-186\">Même si vous avez fourni le nom complet du type (par exemple, `System.String`), l’opérateur `nameof` retourne le nom non complet.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-186\">Even when you provided the fully qualified type name (such as `System.String`) the `nameof` operator returns the unqualified name.</span></span> <span data-ttu-id=\"bdeef-187\">Cette fonctionnalité est particulièrement utile quand vous avez besoin de convertir un nom de paramètre ou de propriété en chaîne.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-187\">This feature is most useful when you need to convert a parameter or property name to a string.</span></span> <span data-ttu-id=\"bdeef-188\">Citons par exemple la capture du nom d’un argument pour lever une exception <xref:System.ArgumentNullException> ou <xref:System.ArgumentException>, ou celle du nom d’une propriété modifiée lors de l’implémentation d’<xref:System.ComponentModel.INotifyPropertyChanged>.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-188\">Examples include capturing the name of an argument for throwing a <xref:System.ArgumentNullException> or <xref:System.ArgumentException>, or capturing the name of a changed property when implementing <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span> \n"
- title: <span data-ttu-id="bdeef-189">Syntaxe d’initialisation d’un nouvel objet</span><span class="sxs-lookup"><span data-stu-id="bdeef-189">New object initialization syntax</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"bdeef-190\">La syntaxe de l’initialiseur d’objet prend désormais en charge l’initialisation d’*indexeurs*, ainsi que des propriétés et des champs.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-190\">Object initializer syntax now supports initializing *indexers* as well as properties and fields.</span></span> <span data-ttu-id=\"bdeef-191\">Cet ajout facilite l’initialisation de dictionnaires et d’autres types.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-191\">This addition makes it easier to initialize dictionaries and other types.</span></span> <span data-ttu-id=\"bdeef-192\">Commencez par un dictionnaire.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-192\">Start with a dictionary.</span></span> <span data-ttu-id=\"bdeef-193\">Exécutez le code suivant dans la fenêtre interactive :</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-193\">Run the following code in the interactive window:</span></span>\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\n<span data-ttu-id=\"bdeef-194\">Cette syntaxe, qui définit une valeur dans un indexeur, peut être utilisée pour tout type qui a un accesseur set accessible sur un indexeur.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-194\">This syntax, which sets a value in an indexer, can be used for any type that has an accessible set accessor on an indexer.</span></span>\n\n<span data-ttu-id=\"bdeef-195\">Un second changement facilite l’activation de la syntaxe d’initialiseur pour les types qui représentent des séquences.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-195\">A second change makes it easier to enable initializer syntax for types that represent sequences.</span></span> <span data-ttu-id=\"bdeef-196\">Les initialiseurs de collection peuvent être utilisés sur toute classe qui implémente <xref:System.Collections.IEnumerable> et qui a une méthode `Add` accessible publiquement.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-196\">Collection initializers can be used on any class that implements <xref:System.Collections.IEnumerable> and has a publicly accessible `Add` method.</span></span> <span data-ttu-id=\"bdeef-197\">Cette méthode `Add` peut maintenant être une méthode d’extension.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-197\">That `Add` method can now be an extension method.</span></span> \n\n<span data-ttu-id=\"bdeef-198\">L’exemple suivant montre un scénario pour cette syntaxe.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-198\">The following example shows one scenario for this syntax.</span></span> <span data-ttu-id=\"bdeef-199\">Il crée une classe `Path` qui implémente `IEnumerable<Point3D>` et qui a une méthode pour ajouter des points qui prennent trois arguments.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-199\">It creates a `Path` class that implements `IEnumerable<Point3D>` and has a method to add points that take three arguments.</span></span> <span data-ttu-id=\"bdeef-200\">La classe `Extensions` crée une méthode `Add` supplémentaire pour ajouter un nouveau point à partir de ses trois composants.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-200\">The `Extensions` class creates an additional `Add` method to add a new point from its three components.</span></span> <span data-ttu-id=\"bdeef-201\">Cet exemple ne s’exécute actuellement pas de manière interactive en raison de restrictions dans l’environnement.</span><span class=\"sxs-lookup\"><span data-stu-id=\"bdeef-201\">This sample does not currently run interactively due to restrictions in the environment.</span></span>\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: >
    <span data-ttu-id="bdeef-202">Vous venez d’explorer les nouvelles fonctionnalités de C# 6.</span><span class="sxs-lookup"><span data-stu-id="bdeef-202">You've completed an exploration of the new features in C# 6.</span></span> <span data-ttu-id="bdeef-203">Essayez-les à présent par vous-même dans vos applications.</span><span class="sxs-lookup"><span data-stu-id="bdeef-203">Now try them yourself in your applications.</span></span>
