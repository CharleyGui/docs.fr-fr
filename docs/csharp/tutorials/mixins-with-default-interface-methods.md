---
title: Créer des types mixin à l’aide de méthodes d’interface par défaut
description: À l’aide des membres d’interface par défaut, vous pouvez étendre les interfaces avec des implémentations par défaut facultatives pour les implémenteurs.
ms.technology: csharp-advanced-concepts
ms.date: 10/04/2019
ms.openlocfilehash: 798413f0071159893de39f3e190a9b2693571bb7
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/29/2019
ms.locfileid: "73039276"
---
# <a name="tutorial-mix-in-functionality-when-creating-classes-using-interfaces-with-default-interface-methods"></a><span data-ttu-id="ee2c9-103">Didacticiel : mélanger les fonctionnalités lors de la création de classes à l’aide d’interfaces avec les méthodes d’interface par défaut</span><span class="sxs-lookup"><span data-stu-id="ee2c9-103">Tutorial: Mix in functionality when creating classes using interfaces with default interface methods</span></span>

<span data-ttu-id="ee2c9-104">Depuis C# 8.0 sur .NET Core 3.0, vous pouvez définir une implémentation lorsque vous déclarez un membre d’une interface.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="ee2c9-105">Cette fonctionnalité offre de nouvelles fonctionnalités qui vous permettent de définir des implémentations par défaut pour les fonctionnalités déclarées dans les interfaces.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-105">This feature provides new capabilities where you can define default implementations for features declared in interfaces.</span></span> <span data-ttu-id="ee2c9-106">Les classes peuvent choisir quand remplacer les fonctionnalités, quand utiliser les fonctionnalités par défaut et quand ne pas déclarer la prise en charge des fonctionnalités discrètes.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-106">Classes can pick when to override functionality, when to use the default functionality, and when not to declare support for discrete features.</span></span>

<span data-ttu-id="ee2c9-107">Dans ce tutoriel, vous allez apprendre à :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="ee2c9-108">Créez des interfaces avec des implémentations qui décrivent des fonctionnalités discrètes.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-108">Create interfaces with implementations that describe discrete features.</span></span>
> * <span data-ttu-id="ee2c9-109">Créez des classes qui utilisent les implémentations par défaut.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-109">Create classes that use the default implementations.</span></span>
> * <span data-ttu-id="ee2c9-110">Créez des classes qui remplacent une partie ou la totalité des implémentations par défaut.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-110">Create classes that override some or all of the default implementations.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="ee2c9-111">Configuration requise</span><span class="sxs-lookup"><span data-stu-id="ee2c9-111">Prerequisites</span></span>

<span data-ttu-id="ee2c9-112">Vous devez configurer votre ordinateur pour exécuter .NET Core, y compris le C# compilateur 8,0.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-112">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="ee2c9-113">Le C# compilateur 8,0 est disponible à partir de [Visual Studio 2019, 16,3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019)ou du [Kit de développement logiciel (SDK) .net Core 3,0](https://dotnet.microsoft.com/download/dotnet-core) ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-113">The C# 8.0 compiler is available starting with [Visual Studio 2019, 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) or later.</span></span>

## <a name="limitations-of-extension-methods"></a><span data-ttu-id="ee2c9-114">Limitations des méthodes d’extension</span><span class="sxs-lookup"><span data-stu-id="ee2c9-114">Limitations of extension methods</span></span>

<span data-ttu-id="ee2c9-115">L’une des façons dont vous pouvez implémenter le comportement qui s’affiche dans le cadre d’une interface est de définir des [méthodes d’extension](../programming-guide/classes-and-structs/extension-methods.md) qui fournissent le comportement par défaut.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-115">One way you can implement behavior that appears as part of an interface is to define [extension methods](../programming-guide/classes-and-structs/extension-methods.md) that provide the default behavior.</span></span> <span data-ttu-id="ee2c9-116">Les interfaces déclarent un ensemble minimal de membres tout en fournissant une plus grande surface d’exposition pour toute classe qui implémente cette interface.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-116">Interfaces declare a minimum set of members while providing a greater surface area for any class that implements that interface.</span></span> <span data-ttu-id="ee2c9-117">Par exemple, les méthodes d’extension dans <xref:System.Linq.Enumerable> fournissent l’implémentation pour toute séquence comme source d’une requête LINQ.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-117">For example, the extension methods in <xref:System.Linq.Enumerable> provide the implementation for any sequence to be the source of a LINQ query.</span></span>

<span data-ttu-id="ee2c9-118">Les méthodes d’extension sont résolues au moment de la compilation, à l’aide du type déclaré de la variable.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-118">Extension methods are resolved at compile time, using the declared type of the variable.</span></span> <span data-ttu-id="ee2c9-119">Les classes qui implémentent l’interface peuvent fournir une meilleure implémentation pour toute méthode d’extension.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-119">Classes that implement the interface can provide a better implementation for any extension method.</span></span> <span data-ttu-id="ee2c9-120">Les déclarations de variables doivent correspondre au type d’implémentation pour permettre au compilateur de choisir cette implémentation.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-120">Variable declarations must match the implementing type to enable the compiler to choose that implementation.</span></span> <span data-ttu-id="ee2c9-121">Lorsque le type au moment de la compilation correspond à l’interface, les appels de méthode sont résolus à la méthode d’extension.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-121">When the compile-time type matches the interface, method calls resolve to the extension method.</span></span> <span data-ttu-id="ee2c9-122">Une autre préoccupation avec les méthodes d’extension est que ces méthodes sont accessibles partout où la classe qui contient les méthodes d’extension est accessible.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-122">Another concern with extension methods is that those methods are accessible wherever the class containing the extension methods is accessible.</span></span> <span data-ttu-id="ee2c9-123">Les classes ne peuvent pas déclarer si elles doivent ou ne doivent pas fournir des fonctionnalités déclarées dans les méthodes d’extension.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-123">Classes cannot declare if they should or should not provide features declared in extension methods.</span></span>

<span data-ttu-id="ee2c9-124">À partir C# de 8,0, vous pouvez déclarer les implémentations par défaut en tant que méthodes d’interface.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-124">Starting with C# 8.0, you can declare the default implementations as interface methods.</span></span> <span data-ttu-id="ee2c9-125">Ensuite, chaque classe utilise automatiquement l’implémentation par défaut.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-125">Then, every class automatically uses the default implementation.</span></span> <span data-ttu-id="ee2c9-126">Toute classe pouvant fournir une meilleure implémentation peut remplacer la définition de méthode d’interface par un meilleur algorithme.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-126">Any class that can provide a better implementation can override the interface method definition with a better algorithm.</span></span> <span data-ttu-id="ee2c9-127">Dans un sens, cette technique ressemble à la façon dont vous pouvez utiliser les [méthodes d’extension](../programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="ee2c9-127">In one sense, this technique sounds similar to how you could use [extension methods](../programming-guide/classes-and-structs/extension-methods.md).</span></span>

<span data-ttu-id="ee2c9-128">Dans cet article, vous allez découvrir comment les implémentations d’interface par défaut permettent de nouveaux scénarios.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-128">In this article, you'll learn how default interface implementations enable new scenarios.</span></span>

## <a name="design-the-application"></a><span data-ttu-id="ee2c9-129">Concevoir l’application</span><span class="sxs-lookup"><span data-stu-id="ee2c9-129">Design the application</span></span>

<span data-ttu-id="ee2c9-130">Prenons l’exemple d’une application domotique.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-130">Consider a home automation application.</span></span> <span data-ttu-id="ee2c9-131">Vous disposez probablement de nombreux types d’éclairages et d’indicateurs qui peuvent être utilisés dans l’ensemble de la maison.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-131">You probably have many different types of lights and indicators that could be used throughout the house.</span></span> <span data-ttu-id="ee2c9-132">Chaque lumière doit prendre en charge les API pour les activer et les désactiver, et pour signaler l’état actuel.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-132">Every light must support APIs to turn them on and off, and to report the current state.</span></span> <span data-ttu-id="ee2c9-133">Certains éclairages et indicateurs peuvent prendre en charge d’autres fonctionnalités, telles que :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-133">Some lights and indicators may support other features, such as:</span></span>

- <span data-ttu-id="ee2c9-134">Activez le voyant, puis désactivez-le après une minuterie.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-134">Turn light on, then turn it off after a timer.</span></span>
- <span data-ttu-id="ee2c9-135">Faire clignoter la lumière pendant une période donnée.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-135">Blink the light for a period of time.</span></span>

<span data-ttu-id="ee2c9-136">Certaines de ces fonctionnalités étendues peuvent être émulées sur les appareils qui prennent en charge l’ensemble minimal.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-136">Some of these extended capabilities could be emulated in devices that support the minimal set.</span></span> <span data-ttu-id="ee2c9-137">Qui indique la fourniture d’une implémentation par défaut.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-137">That indicates providing a default implementation.</span></span> <span data-ttu-id="ee2c9-138">Pour les appareils qui ont plus de fonctionnalités intégrées, le logiciel de l’appareil utilise les fonctionnalités natives.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-138">For those devices that have more capabilities built in, the device software would use the native capabilities.</span></span> <span data-ttu-id="ee2c9-139">Pour les autres lumières, elles peuvent choisir d’implémenter l’interface et d’utiliser l’implémentation par défaut.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-139">For other lights, they could choose to implement the interface and use the default implementation.</span></span>

<span data-ttu-id="ee2c9-140">Les membres d’interface par défaut sont une meilleure solution pour ce scénario que les méthodes d’extension.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-140">Default interface members is a better solution for this scenario than extension methods.</span></span> <span data-ttu-id="ee2c9-141">Les auteurs de classe peuvent contrôler les interfaces qu’ils choisissent d’implémenter.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-141">Class authors can control which interfaces they choose to implement.</span></span> <span data-ttu-id="ee2c9-142">Les interfaces qu’ils choisissent sont disponibles en tant que méthodes.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-142">Those interfaces they choose are available as methods.</span></span> <span data-ttu-id="ee2c9-143">En outre, étant donné que les méthodes d’interface par défaut sont virtuelles par défaut, la distribution de méthode choisit toujours l’implémentation dans la classe.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-143">In addition, because default interface methods are virtual by default, the method dispatch always chooses the implementation in the class.</span></span> 

<span data-ttu-id="ee2c9-144">Créons le code pour illustrer ces différences.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-144">Let's create the code to demonstrate these differences.</span></span>

## <a name="create-interfaces"></a><span data-ttu-id="ee2c9-145">Créer des interfaces</span><span class="sxs-lookup"><span data-stu-id="ee2c9-145">Create interfaces</span></span>

<span data-ttu-id="ee2c9-146">Commencez par créer l’interface qui définit le comportement de toutes les lumières :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-146">Start by creating the interface that defines the behavior for all lights:</span></span>

[!code-csharp[Declare base interface](~/samples/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetILightInterfaceV1)]

<span data-ttu-id="ee2c9-147">Un dispositif d’éclairage de surcharge de base peut implémenter cette interface comme indiqué dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-147">A basic overhead light fixture might implement this interface as shown in the following code:</span></span>

[!code-csharp[First overhead light](~/samples/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetOverheadLightV1)]

<span data-ttu-id="ee2c9-148">Dans ce didacticiel, le code ne pilote pas les appareils IoT, mais émule ces activités en écrivant des messages sur la console.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-148">In this tutorial, the code doesn't drive IoT devices, but emulates those activities by writing messages to the console.</span></span> <span data-ttu-id="ee2c9-149">Vous pouvez explorer le code sans automatiser votre maison.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-149">You can explore the code without automating your house.</span></span>

<span data-ttu-id="ee2c9-150">Ensuite, nous allons définir l’interface pour une lumière qui peut s’éteindre automatiquement après un délai d’attente :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-150">Next, let's define the interface for a light that can automatically turn off after a timeout:</span></span>

[!code-csharp[pure Timer interface](~/samples/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetPureTimerInterface)]

<span data-ttu-id="ee2c9-151">Vous pouvez ajouter une implémentation de base à la lumière de la surcharge, mais une meilleure solution consiste à modifier cette définition d’interface pour fournir une implémentation par défaut `virtual` :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-151">You could add a basic implementation to the overhead light, but a better solution is to modify this interface definition to provide a `virtual` default implementation:</span></span>

[!code-csharp[Timer interface](~/samples/csharp/tutorials/mixins-with-interfaces/ITimerLight.cs?name=SnippetTimerLightFinal)]

<span data-ttu-id="ee2c9-152">En ajoutant cette modification, la classe `OverheadLight` peut implémenter la fonction timer en déclarant la prise en charge de l’interface :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-152">By adding that change, the `OverheadLight` class can implement the timer function by declaring support for the interface:</span></span>

```csharp
public class OverheadLight : ITimerLight { }
```

<span data-ttu-id="ee2c9-153">Un type de lumière différent peut prendre en charge un protocole plus sophistiqué.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-153">A different light type may support a more sophisticated protocol.</span></span> <span data-ttu-id="ee2c9-154">Il peut fournir sa propre implémentation pour `TurnOnFor`, comme illustré dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-154">It can provide its own implementation for `TurnOnFor`, as shown in the following code:</span></span>

[!code-csharp[Override the timer function](~/samples/csharp/tutorials/mixins-with-interfaces/HalogenLight.cs?name=SnippetHalogenLight)]

<span data-ttu-id="ee2c9-155">Contrairement aux méthodes de classe virtuelle de substitution, la déclaration de `TurnOnFor` dans la classe `HalogenLight` n’utilise pas le mot clé `override`.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-155">Unlike overriding virtual class methods, the declaration of `TurnOnFor` in the `HalogenLight` class does not use the `override` keyword.</span></span> 

## <a name="mix-and-match-capabilities"></a><span data-ttu-id="ee2c9-156">Fonctionnalités Mix et match</span><span class="sxs-lookup"><span data-stu-id="ee2c9-156">Mix and match capabilities</span></span>

<span data-ttu-id="ee2c9-157">Les avantages des méthodes d’interface par défaut deviennent plus clairs lorsque vous introduisez des fonctionnalités plus avancées.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-157">The advantages of default interface methods become clearer as you introduce more advanced capabilities.</span></span> <span data-ttu-id="ee2c9-158">L’utilisation d’interfaces vous permet de mélanger et de faire correspondre des fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-158">Using interfaces enables you to mix and match capabilities.</span></span> <span data-ttu-id="ee2c9-159">Il permet également à chaque auteur de classe de choisir entre l’implémentation par défaut et une implémentation personnalisée.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-159">It also enables each class author to choose between the default implementation and a custom implementation.</span></span> <span data-ttu-id="ee2c9-160">Nous allons ajouter une interface avec une implémentation par défaut pour une lumière clignotante :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-160">Let's add an interface with a default implementation for a blinking light:</span></span>

[!code-csharp[Define the blinking light interface](~/samples/csharp/tutorials/mixins-with-interfaces/IBlinkingLight.cs?name=SnippetBlinkingLight)]

<span data-ttu-id="ee2c9-161">L’implémentation par défaut permet à tout éclairage de clignoter.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-161">The default implementation enables any light to blink.</span></span> <span data-ttu-id="ee2c9-162">La lumière de la surcharge peut ajouter des fonctionnalités de minuterie et de clignotement à l’aide de l’implémentation par défaut :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-162">The overhead light can add both timer and blink capabilities using the default implementation:</span></span>

[!code-csharp[Use the default blink function](~/samples/csharp/tutorials/mixins-with-interfaces/OverheadLight.cs?name=SnippetOverheadLight)]

<span data-ttu-id="ee2c9-163">Un nouveau type de lumière, le `LEDLight` prend directement en charge la fonction de minuteur et la fonction Blink.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-163">A new light type, the `LEDLight` supports both the timer function and the blink function directly.</span></span> <span data-ttu-id="ee2c9-164">Ce style clair implémente à la fois les interfaces `ITimerLight` et `IBlinkingLight`, et remplace la méthode `Blink` :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-164">This light style implements both the `ITimerLight` and `IBlinkingLight` interfaces, and overrides the `Blink` method:</span></span>

[!code-csharp[Override the blink function](~/samples/csharp/tutorials/mixins-with-interfaces/LEDLight.cs?name=SnippetLEDLight)]

<span data-ttu-id="ee2c9-165">Un `ExtraFancyLight` peut prendre en charge les fonctions Blink et Timer directement :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-165">An `ExtraFancyLight` might support both blink and timer functions directly:</span></span>

[!code-csharp[Override the blink and timer function](~/samples/csharp/tutorials/mixins-with-interfaces/ExtraFancyLight.cs?name=SnippetExtraFancyLight)]

<span data-ttu-id="ee2c9-166">La `HalogenLight` que vous avez créée précédemment ne prend pas en charge le clignotement.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-166">The `HalogenLight` you created earlier doesn't support blinking.</span></span> <span data-ttu-id="ee2c9-167">Par conséquent, n’ajoutez pas le `IBlinkingLight` à la liste des interfaces prises en charge.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-167">So, don't add the `IBlinkingLight` to the list of its supported interfaces.</span></span>

## <a name="detect-the-light-types-using-pattern-matching"></a><span data-ttu-id="ee2c9-168">Détecter les types de lumière à l’aide de critères spéciaux</span><span class="sxs-lookup"><span data-stu-id="ee2c9-168">Detect the light types using pattern matching</span></span>

<span data-ttu-id="ee2c9-169">Nous allons ensuite écrire du code de test.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-169">Next, let's write some test code.</span></span> <span data-ttu-id="ee2c9-170">Vous pouvez utiliser la fonctionnalité C#de mise en [correspondance des modèles](../pattern-matching.md) de pour déterminer les capacités d’un éclairage en examinant les interfaces qu’il prend en charge.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-170">You can make use of C#'s [pattern matching](../pattern-matching.md) feature to determine a light's capabilities by examining which interfaces it supports.</span></span>  <span data-ttu-id="ee2c9-171">La méthode suivante exerce les fonctionnalités prises en charge de chaque lumière :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-171">The following method exercises the supported capabilities of each light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetTestLightFunctions)]

<span data-ttu-id="ee2c9-172">Le code suivant dans votre méthode `Main` crée chaque type de lumière dans la séquence et teste ce qui est clair :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-172">The following code in your `Main` method creates each light type in sequence and tests that light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetMainMethod)]

## <a name="how-the-compiler-determines-best-implementation"></a><span data-ttu-id="ee2c9-173">Comment le compilateur détermine la meilleure implémentation</span><span class="sxs-lookup"><span data-stu-id="ee2c9-173">How the compiler determines best implementation</span></span>

<span data-ttu-id="ee2c9-174">Ce scénario montre une interface de base sans implémentation.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-174">This scenario shows a base interface without any implementations.</span></span> <span data-ttu-id="ee2c9-175">L’ajout d’une méthode dans l’interface `ILight` introduit de nouvelles complexités.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-175">Adding a method into the `ILight` interface introduces new complexities.</span></span> <span data-ttu-id="ee2c9-176">Les règles de langage régissant les méthodes d’interface par défaut réduisent l’effet sur les classes concrètes qui implémentent plusieurs interfaces dérivées.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-176">The language rules governing default interface methods minimize the effect on the concrete classes that implement multiple derived interfaces.</span></span> <span data-ttu-id="ee2c9-177">Nous allons améliorer l’interface d’origine avec une nouvelle méthode pour montrer comment cela modifie son utilisation.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-177">Let's enhance the original interface with a new method to show how that changes its use.</span></span> <span data-ttu-id="ee2c9-178">Chaque témoin lumineux peut signaler son état d’alimentation comme une valeur énumérée :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-178">Every indicator light can report its power status as an enumerated value:</span></span>

[!code-csharp[Enumeration for power status](~/samples/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetPowerStatus)]

<span data-ttu-id="ee2c9-179">L’implémentation par défaut suppose une alimentation secteur :</span><span class="sxs-lookup"><span data-stu-id="ee2c9-179">The default implementation assumes AC power:</span></span>

[!code-csharp[Report a default power status](~/samples/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetILightInterface)]

<span data-ttu-id="ee2c9-180">Ces modifications sont compilées correctement, même si le `ExtraFancyLight` déclare la prise en charge de l’interface `ILight` et des deux interfaces dérivées, `ITimerLight` et `IBlinkingLight`.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-180">These changes compile cleanly, even though the `ExtraFancyLight` declares support for the `ILight` interface and both derived interfaces, `ITimerLight` and `IBlinkingLight`.</span></span> <span data-ttu-id="ee2c9-181">Il n’y a qu’une seule implémentation « la plus proche » déclarée dans l’interface `ILight`.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-181">There's only one "closest" implementation declared in the `ILight` interface.</span></span> <span data-ttu-id="ee2c9-182">Toute classe qui a déclaré une substitution devient l’implémentation « la plus proche ».</span><span class="sxs-lookup"><span data-stu-id="ee2c9-182">Any class that declared an override would become the one "closest" implementation.</span></span> <span data-ttu-id="ee2c9-183">Vous avez vu des exemples dans les classes précédentes qui a remplacé les membres d’autres interfaces dérivées.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-183">You saw examples in the preceding classes that overrode the members of other derived interfaces.</span></span>

<span data-ttu-id="ee2c9-184">Évitez de substituer la même méthode dans plusieurs interfaces dérivées.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-184">Avoid overriding the same method in multiple derived interfaces.</span></span> <span data-ttu-id="ee2c9-185">Si vous procédez ainsi, un appel de méthode ambigu est créé chaque fois qu’une classe implémente les deux interfaces dérivées.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-185">Doing so creates an ambiguous method call whenever a class implements both derived interfaces.</span></span> <span data-ttu-id="ee2c9-186">Le compilateur ne peut pas choisir une méthode unique pour qu’il génère une erreur.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-186">The compiler can't pick a single better method so it issues an error.</span></span> <span data-ttu-id="ee2c9-187">Par exemple, si les `IBlinkingLight` et `ITimerLight` implémentent une substitution de `PowerStatus`, le `OverheadLight` doit fournir une substitution plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-187">For example, if both the `IBlinkingLight` and `ITimerLight` implemented an override of `PowerStatus`, the `OverheadLight` would need to provide a more specific override.</span></span> <span data-ttu-id="ee2c9-188">Sinon, le compilateur ne peut pas choisir entre les implémentations dans les deux interfaces dérivées.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-188">Otherwise, the compiler can't pick between the implementations in the two derived interfaces.</span></span> <span data-ttu-id="ee2c9-189">Vous pouvez généralement éviter cette situation en conservant les définitions d’interface de petite taille et en vous concentrant sur une seule fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-189">You can usually avoid this situation by keeping interface definitions small and focused on one feature.</span></span> <span data-ttu-id="ee2c9-190">Dans ce scénario, chaque fonctionnalité d’une lumière est sa propre interface ; plusieurs interfaces sont héritées uniquement par les classes.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-190">In this scenario, each capability of a light is its own interface; multiple interfaces are only inherited by classes.</span></span>

<span data-ttu-id="ee2c9-191">Cet exemple illustre un scénario dans lequel vous pouvez définir des fonctionnalités discrètes qui peuvent être mélangées dans des classes.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-191">This sample shows one scenario where you can define discrete features that can be mixed into classes.</span></span> <span data-ttu-id="ee2c9-192">Vous déclarez tout ensemble de fonctionnalités prises en charge en déclarant les interfaces prises en charge par une classe.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-192">You declare any set of supported functionality by declaring which interfaces a class supports.</span></span> <span data-ttu-id="ee2c9-193">L’utilisation de méthodes d’interface par défaut virtuelles permet aux classes d’utiliser ou de définir une implémentation différente pour toute ou partie des méthodes d’interface.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-193">The use of virtual default interface methods enables classes to use or define a different implementation for any or all the interface methods.</span></span> <span data-ttu-id="ee2c9-194">Cette fonctionnalité de langage offre de nouvelles façons de modéliser les systèmes réels que vous créez.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-194">This language capability provides new ways to model the real-world systems you're building.</span></span> <span data-ttu-id="ee2c9-195">Les méthodes d’interface par défaut offrent un moyen plus clair d’exprimer des classes connexes qui peuvent combiner et faire correspondre des fonctionnalités différentes à l’aide d’implémentations virtuelles de ces fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="ee2c9-195">Default interface methods provide a clearer way to express related classes that may mix and match different features using virtual implementations of those capabilities.</span></span>
