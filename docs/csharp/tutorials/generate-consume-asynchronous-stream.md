---
title: Générer et consommer des flux asynchrones
description: Ce didacticiel avancé montre comment générer et utiliser des flux asynchrones. Les flux asynchrones offrent un moyen plus naturel de travailler avec des séquences de données qui peuvent être générées de façon asynchrone.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: 03254e5208a048469f4753d632de7b0d451cde40
ms.sourcegitcommit: 5988e9a29cedb8757320817deda3c08c6f44a6aa
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2020
ms.locfileid: "82200104"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="cf8dc-104">Didacticiel : générer et utiliser des flux asynchrones à l’aide de C# 8,0 et .NET Core 3,0</span><span class="sxs-lookup"><span data-stu-id="cf8dc-104">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="cf8dc-105">C# 8,0 introduit des **flux asynchrones**, qui modélisent une source de données de diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-105">C# 8.0 introduces **async streams**, which model a streaming source of data.</span></span> <span data-ttu-id="cf8dc-106">Les flux de données récupèrent et génèrent souvent des éléments de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-106">Data streams often retrieve or generate elements asynchronously.</span></span> <span data-ttu-id="cf8dc-107">Les flux asynchrones s’appuient sur les nouvelles interfaces introduites dans .NET Standard 2,1.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-107">Async streams rely on new interfaces introduced in .NET Standard 2.1.</span></span> <span data-ttu-id="cf8dc-108">Ces interfaces sont prises en charge dans .NET Core 3,0 et versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-108">These interfaces are supported in .NET Core 3.0 and later.</span></span> <span data-ttu-id="cf8dc-109">Ils fournissent un modèle de programmation naturel pour les sources de données de streaming asynchrones.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-109">They provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="cf8dc-110">Ce didacticiel vous montre comment effectuer les opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="cf8dc-111">créer une source de données qui génère une séquence d’éléments de données de façon asynchrone ;</span><span class="sxs-lookup"><span data-stu-id="cf8dc-111">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="cf8dc-112">consommer cette source de données de façon asynchrone ;</span><span class="sxs-lookup"><span data-stu-id="cf8dc-112">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="cf8dc-113">Prendre en charge l’annulation et les contextes capturés pour les flux asynchrones.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-113">Support cancellation and captured contexts for asynchronous streams.</span></span>
> - <span data-ttu-id="cf8dc-114">reconnaître quand l’interface et la source de données nouvelles sont préférables aux séquences de données synchrones précédentes.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-114">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="cf8dc-115">Prérequis</span><span class="sxs-lookup"><span data-stu-id="cf8dc-115">Prerequisites</span></span>

<span data-ttu-id="cf8dc-116">Vous devez configurer votre ordinateur pour exécuter .NET Core, y compris le compilateur C# 8,0.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-116">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="cf8dc-117">Le compilateur C# 8 est disponible à partir de [Visual Studio 2019 version 16,3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) ou du [Kit de développement logiciel (SDK) .net Core 3,0](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="cf8dc-117">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="cf8dc-118">Vous devrez créer un [jeton d’accès GitHub](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) afin de pouvoir accéder au point de terminaison GitHub GraphQL.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-118">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="cf8dc-119">Sélectionnez les autorisations suivantes pour votre jeton d’accès GitHub :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-119">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="cf8dc-120">repo:status</span><span class="sxs-lookup"><span data-stu-id="cf8dc-120">repo:status</span></span>
- <span data-ttu-id="cf8dc-121">public_repo</span><span class="sxs-lookup"><span data-stu-id="cf8dc-121">public_repo</span></span>

<span data-ttu-id="cf8dc-122">Enregistrez le jeton d’accès à un endroit sûr afin de pouvoir l’utiliser pour accéder au point de terminaison de l’API GitHub.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-122">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="cf8dc-123">Sécurisez votre jeton d’accès personnel.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-123">Keep your personal access token secure.</span></span> <span data-ttu-id="cf8dc-124">Tous les logiciels disposant de votre jeton d’accès personnel peuvent effectuer des appels d’API GitHub à l’aide de vos droits d’accès.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-124">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="cf8dc-125">Ce tutoriel suppose de connaître C# et .NET, y compris Visual Studio ou l’interface CLI .NET Core.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-125">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="cf8dc-126">Exécutez l’application de démarrage</span><span class="sxs-lookup"><span data-stu-id="cf8dc-126">Run the starter application</span></span>

<span data-ttu-id="cf8dc-127">Vous pouvez obtenir le code pour l’application de démarrage utilisée dans ce didacticiel à partir du dépôt [dotnet/docs](https://github.com/dotnet/docs) dans le dossier [CSharp/tutoriels/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) .</span><span class="sxs-lookup"><span data-stu-id="cf8dc-127">You can get the code for the starter application used in this tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) folder.</span></span>

<span data-ttu-id="cf8dc-128">L’application de démarrage est une application console qui utilise l’interface [GitHub GraphQL](https://developer.github.com/v4/) pour récupérer des problèmes récents écrits dans le référentiel [dotnet/docs](https://github.com/dotnet/docs).</span><span class="sxs-lookup"><span data-stu-id="cf8dc-128">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="cf8dc-129">Commencez par examiner le code suivant pour la méthode `Main` de l’application de démarrage :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-129">Start by looking at the following code for the starter app `Main` method:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetStarterAppMain" :::

<span data-ttu-id="cf8dc-130">Vous pouvez soit définir une variable d’environnement `GitHubKey` sur votre jeton d’accès personnel, soit remplacer le dernier argument dans l’appel par `GenEnvVariable` avec votre jeton d’accès personnel.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-130">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="cf8dc-131">Ne placez pas votre code d’accès dans le code source si vous souhaitez partager la source avec d’autres utilisateurs.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-131">Don't put your access code in source code if you'll be sharing the source with others.</span></span> <span data-ttu-id="cf8dc-132">Ne téléchargez jamais de codes d’accès dans un référentiel source partagé.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-132">Never upload access codes to a shared source repository.</span></span>

<span data-ttu-id="cf8dc-133">Après la création du client de GitHub, le code dans `Main` crée un objet de rapport de progression et un jeton d’annulation.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-133">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="cf8dc-134">Une fois que ces objets sont créés, `Main` appelle `runPagedQueryAsync` pour récupérer les 250 problèmes créés les plus récents.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-134">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="cf8dc-135">Une fois cette tâche terminée, les résultats sont affichés.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-135">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="cf8dc-136">Lorsque vous exécutez l’application de démarrage, vous pouvez faire quelques observations importantes concernant son fonctionnement.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-136">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="cf8dc-137">Vous voyez la progression signalée pour chaque page retournée à partir de GitHub.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-137">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="cf8dc-138">Vous pouvez observer un temps de pause avant le retour de chaque nouvelle page de problèmes par GitHub.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-138">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="cf8dc-139">Enfin, les problèmes ne sont affichés que lorsque les 10 pages ont été récupérées à partir de GitHub.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-139">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="cf8dc-140">Examinez l’implémentation</span><span class="sxs-lookup"><span data-stu-id="cf8dc-140">Examine the implementation</span></span>

<span data-ttu-id="cf8dc-141">L’implémentation révèle pourquoi vous avez observé le comportement décrit dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-141">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="cf8dc-142">Examinez the code for `runPagedQueryAsync` :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-142">Examine the code for `runPagedQueryAsync`:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetRunPagedQuery" :::

<span data-ttu-id="cf8dc-143">Concentrons-nous sur l’algorithme de pagination et sur la structure asynchrone du code précédent.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-143">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="cf8dc-144">(Vous pouvez consulter la [documentation de GitHub GraphQL](https://developer.github.com/v4/guides/) pour plus d’informations sur l’API GraphQL github.) La `runPagedQueryAsync` méthode énumère les problèmes du plus récent au plus ancien.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-144">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="cf8dc-145">Elle a besoin de 25 problèmes par page et examine la structure `pageInfo` de la réponse pour continuer avec la page précédente.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-145">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="cf8dc-146">Cela suit la prise en charge standard de la pagination de GraphQL pour les réponses multipages.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-146">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="cf8dc-147">La réponse inclut un objet `pageInfo` qui contient une valeur `hasPreviousPages` et une valeur `startCursor` utilisées pour demander la page précédente.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-147">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="cf8dc-148">Les problèmes se trouvent dans le tableau `nodes`.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-148">The issues are in the `nodes` array.</span></span> <span data-ttu-id="cf8dc-149">La méthode `runPagedQueryAsync` ajoute ces nœuds à un tableau qui contient tous les résultats de toutes les pages.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-149">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="cf8dc-150">Après la récupération et la restauration d’une page de résultats, `runPagedQueryAsync` signale la progression et vérifie l’annulation.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-150">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="cf8dc-151">Si l’annulation a été demandée, `runPagedQueryAsync` lève une <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-151">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="cf8dc-152">Plusieurs éléments de ce code peuvent être améliorés.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-152">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="cf8dc-153">Plus important encore, `runPagedQueryAsync` doit allouer du stockage pour tous les problèmes retournés.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-153">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="cf8dc-154">Cet exemple s’arrête à 250 problèmes, car la récupération de tous les problèmes ouverts nécessiterait beaucoup plus de mémoire pour stocker tous les problèmes récupérées.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-154">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="cf8dc-155">Les protocoles de prise en charge des rapports de progression et de l’annulation rendent l’algorithme plus difficile à comprendre lors de sa première lecture.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-155">The protocols for supporting progress reports and cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="cf8dc-156">D’autres types et API sont impliqués.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-156">More types and APIs are involved.</span></span> <span data-ttu-id="cf8dc-157">Vous devez suivre les communications via le <xref:System.Threading.CancellationTokenSource> et son associé <xref:System.Threading.CancellationToken> pour comprendre où l’annulation est demandée et où elle est accordée.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-157">You must trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="cf8dc-158">Les flux asynchrones sont mieux adaptés</span><span class="sxs-lookup"><span data-stu-id="cf8dc-158">Async streams provide a better way</span></span>

<span data-ttu-id="cf8dc-159">Les flux asynchrones et la prise en charge associée du langage résolvent tous ces problèmes.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-159">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="cf8dc-160">Le code qui génère la séquence peut désormais utiliser `yield return` pour retourner des éléments dans une méthode qui a été déclarée avec le modificateur `async`.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-160">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="cf8dc-161">Vous pouvez consommer un flux asynchrone à l’aide une boucle `await foreach` tout comme vous consommez n’importe quelle séquence à l’aide d’une boucle `foreach`.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-161">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="cf8dc-162">Ces nouvelles fonctionnalités de langage dépendent de trois nouvelles interfaces ajoutées à .NET Standard 2.1 et implémentées dans .NET Core 3.0 :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-162">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

- <xref:System.Collections.Generic.IAsyncEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IAsyncEnumerator%601?displayProperty=nameWithType>
- <xref:System.IAsyncDisposable?displayProperty=nameWithType>

<span data-ttu-id="cf8dc-163">Ces trois interfaces sont très certainement familières à la plupart des développeurs C#.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-163">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="cf8dc-164">Elles se comportent de manière similaire à leurs équivalents synchrones :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-164">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="cf8dc-165">Il est possible que le type <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType> ne soit pas familier.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-165">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cf8dc-166">Le struct `ValueTask` fournit une API similaire à la classe <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-166">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="cf8dc-167">`ValueTask` est utilisé dans ces interfaces pour des raisons de performances.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-167">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="cf8dc-168">Convertir en flux asynchrones</span><span class="sxs-lookup"><span data-stu-id="cf8dc-168">Convert to async streams</span></span>

<span data-ttu-id="cf8dc-169">Ensuite, convertissez la méthode `runPagedQueryAsync` pour générer un flux asynchrone.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-169">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="cf8dc-170">Tout d’abord, modifiez la signature de `runPagedQueryAsync` pour retourner un `IAsyncEnumerable<JToken>` et supprimer les objets de jeton d’annulation et de progression de la liste de paramètres comme indiqué dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-170">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetUpdateSignature" :::

<span data-ttu-id="cf8dc-171">Le code de démarrage traite chaque page lorsqu’elle est récupérée, comme indiqué dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-171">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetProcessPage" :::

<span data-ttu-id="cf8dc-172">Remplacez ces trois lignes par le code suivant :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-172">Replace those three lines with the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetYieldReturnPage" :::

<span data-ttu-id="cf8dc-173">Vous pouvez également supprimer la déclaration de `finalResults` plus tôt dans cette méthode et l’instruction `return` qui suit la boucle que vous avez modifiée.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-173">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="cf8dc-174">Vous avez terminé les modifications permettant de générer un flux asynchrone.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-174">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="cf8dc-175">La méthode terminée doit ressembler au code suivant :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-175">The finished method should resemble the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateAsyncStream" :::

<span data-ttu-id="cf8dc-176">Ensuite, vous modifiez le code qui utilise la collection pour consommer le flux de données asynchrone.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-176">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="cf8dc-177">Recherchez dans `Main` le code suivant, qui traite l’ensemble des problèmes :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-177">Find the following code in `Main` that processes the collection of issues:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetEnumerateOldStyle" :::

<span data-ttu-id="cf8dc-178">Remplacez-le par la boucle `await foreach` suivante :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-178">Replace that code with the following `await foreach` loop:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateAsyncStream" :::

<span data-ttu-id="cf8dc-179">La nouvelle interface <xref:System.Collections.Generic.IAsyncEnumerator%601> dérive de <xref:System.IAsyncDisposable>.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-179">The new interface <xref:System.Collections.Generic.IAsyncEnumerator%601> derives from <xref:System.IAsyncDisposable>.</span></span> <span data-ttu-id="cf8dc-180">Cela signifie que la boucle précédente disposera de façon asynchrone le flux lorsque la boucle se terminera.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-180">That means the preceding loop will asynchronously dispose the stream when the loop finishes.</span></span> <span data-ttu-id="cf8dc-181">Vous pouvez imaginer que la boucle ressemble au code suivant :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-181">You can imagine the loop looks like the following code:</span></span>

```csharp
int num = 0;
var enumerator = runPagedQueryAsync(client, PagedIssueQuery, "docs").GetEnumeratorAsync();
try
{
    while (await enumerator.MoveNextAsync())
    {
        var issue = enumerator.Current;
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
    }
} finally
{
    if (enumerator != null)
        await enumerator.DisposeAsync();
}
```

<span data-ttu-id="cf8dc-182">Par défaut, les éléments de flux sont traités dans le contexte capturé.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-182">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="cf8dc-183">Si vous souhaitez désactiver la capture du contexte, utilisez la <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> méthode d’extension.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-183">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="cf8dc-184">Pour plus d’informations sur les contextes de synchronisation et la capture du contexte actuel, consultez l’article sur l' [utilisation du modèle asynchrone basé](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)sur des tâches.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-184">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="cf8dc-185">Les flux asynchrones prennent en charge l’annulation en `async` utilisant le même protocole que les autres méthodes.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-185">Async streams support cancellation using the same protocol as other `async` methods.</span></span> <span data-ttu-id="cf8dc-186">Vous pouvez modifier la signature de la méthode d’itérateur Async comme suit pour prendre en charge l’annulation :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-186">You would modify the signature for the async iterator method as follows to support cancellation:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateWithCancellation" :::

<span data-ttu-id="cf8dc-187">L' <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attribut force le compilateur à générer du code pour <xref:System.Collections.Generic.IAsyncEnumerator%601> le qui rend le jeton passé `GetAsyncEnumerator` visible au corps de l’itérateur Async comme cet argument.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-187">The <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attribute causes the compiler to generate code for the <xref:System.Collections.Generic.IAsyncEnumerator%601> that makes the token passed to `GetAsyncEnumerator` visible to the body of the async iterator as that argument.</span></span> <span data-ttu-id="cf8dc-188">Dans `runQueryAsync`, vous pouvez examiner l’état du jeton et annuler un travail supplémentaire si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-188">Inside `runQueryAsync`, you could examine the state of the token and cancel further work if requested.</span></span>

<span data-ttu-id="cf8dc-189">Vous utilisez une autre méthode d' <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>extension,, pour transmettre le jeton d’annulation au flux asynchrone.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-189">You use another extension method, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, to pass the cancellation token to the async stream.</span></span> <span data-ttu-id="cf8dc-190">Vous pouvez modifier la boucle en énumérant les problèmes comme suit :</span><span class="sxs-lookup"><span data-stu-id="cf8dc-190">You would modify the loop enumerating the issues as follows:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateWithCancellation" :::

<span data-ttu-id="cf8dc-191">Vous pouvez obtenir le code du didacticiel terminé à partir du dépôt [dotnet/docs](https://github.com/dotnet/docs) dans le dossier [CSharp/tutoriels/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) .</span><span class="sxs-lookup"><span data-stu-id="cf8dc-191">You can get the code for the finished tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="cf8dc-192">Exécutez l'application terminée</span><span class="sxs-lookup"><span data-stu-id="cf8dc-192">Run the finished application</span></span>

<span data-ttu-id="cf8dc-193">Exécutez de nouveau l'application.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-193">Run the application again.</span></span> <span data-ttu-id="cf8dc-194">Comparez son comportement avec le comportement de l’application de démarrage.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-194">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="cf8dc-195">La première page de résultats est énumérée dès qu’elle est disponible.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-195">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="cf8dc-196">Une pause peut être observée lorsque chaque nouvelle page est demandée et récupérée, puis les résultats de la page suivante sont rapidement énumérés.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-196">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="cf8dc-197">Le bloc `try` / `catch` n’est pas nécessaire pour gérer l’annulation : l’appelant peut arrêter l’énumération de la collection.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-197">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="cf8dc-198">Le rapport de progression est clair, car le flux asynchrone génère des résultats à mesure que chaque page est téléchargée.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-198">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="cf8dc-199">L’état de chaque problème renvoyé est inclus en toute transparence dans `await foreach` la boucle.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-199">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="cf8dc-200">Vous n’avez pas besoin d’un objet de rappel pour suivre la progression.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-200">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="cf8dc-201">Vous pouvez voir des améliorations lors de l’utilisation de mémoire en examinant le code.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-201">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="cf8dc-202">Vous n’avez plus besoin d’allouer une collection pour stocker tous les résultats avant qu’ils ne soient énumérés.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-202">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="cf8dc-203">L’appelant peut déterminer comment utiliser les résultats et si une collection de stockage est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-203">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="cf8dc-204">Exécutez les applications de démarrage et les applications terminées. Ceci vous permettra d’observer les différences entre les implémentations pour vous.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-204">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="cf8dc-205">À la fin de ce tutoriel, vous pouvez supprimer le jeton d’accès GitHub que vous avez créé au début.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-205">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="cf8dc-206">Si un attaquant arrive à accéder à ce jeton, il pourrait accéder aux API GitHub à l’aide de vos informations d’identification.</span><span class="sxs-lookup"><span data-stu-id="cf8dc-206">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
