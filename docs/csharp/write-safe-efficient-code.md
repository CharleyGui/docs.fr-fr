---
title: Écrire du code C# sécurisé et efficace
description: Les améliorations récentes apportées au langage C# vous permettent d’écrire du code sécurisé vérifiable que les performances associaient précédemment à du code non sécurisé.
ms.date: 10/23/2018
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: 365320fef5a2f9cd123086c1baed9a786ede9f05
ms.sourcegitcommit: 59e36e65ac81cdd094a5a84617625b2a0ff3506e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/27/2020
ms.locfileid: "80345084"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="890f6-103">Écrire du code C# sécurisé et efficace</span><span class="sxs-lookup"><span data-stu-id="890f6-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="890f6-104">Les nouvelles fonctionnalités de C# vous permettent d’écrire du code sécurisé vérifiable avec de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="890f6-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="890f6-105">Si vous appliquez soigneusement ces techniques, les scénarios nécessitant du code non sécurisé sont moins nombreux.</span><span class="sxs-lookup"><span data-stu-id="890f6-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="890f6-106">Ces fonctionnalités facilitent l’utilisation des références à des types valeur comme arguments de méthode et retours de méthode.</span><span class="sxs-lookup"><span data-stu-id="890f6-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="890f6-107">Quand elles sont utilisées de façon sécurisée, ces techniques réduisent la copie des types valeur.</span><span class="sxs-lookup"><span data-stu-id="890f6-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="890f6-108">En utilisant des types valeur, vous pouvez réduire le nombre d’allocations et de passes du garbage collection.</span><span class="sxs-lookup"><span data-stu-id="890f6-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="890f6-109">Une grande partie de l’exemple de code de cet article utilise des fonctionnalités ajoutées dans C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="890f6-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="890f6-110">Pour utiliser ces fonctionnalités, vous devez configurer votre projet pour qu’il utilise C# 7.2 ou ultérieur.</span><span class="sxs-lookup"><span data-stu-id="890f6-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="890f6-111">Pour plus d’informations sur la définition de la version linguistique, voir [configurer la version linguistique](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="890f6-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="890f6-112">Cet article met l’accent sur les techniques de gestion efficace des ressources.</span><span class="sxs-lookup"><span data-stu-id="890f6-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="890f6-113">Un avantage de l’utilisation de types valeur est qu’ils permettent souvent d’éviter les allocations de tas.</span><span class="sxs-lookup"><span data-stu-id="890f6-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="890f6-114">Mais l’inconvénient, c’est qu’ils sont copiés par valeur.</span><span class="sxs-lookup"><span data-stu-id="890f6-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="890f6-115">Ce compromis rend plus difficile l’optimisation des algorithmes fonctionnaires sur de grandes quantités de données.</span><span class="sxs-lookup"><span data-stu-id="890f6-115">This trade-off makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="890f6-116">Les nouvelles fonctionnalités du langage dans C# 7.2 fournissent des mécanismes qui permettent d’obtenir un code efficace sécurisé en utilisant des références à des types valeur.</span><span class="sxs-lookup"><span data-stu-id="890f6-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="890f6-117">Utilisez ces fonctionnalités judicieusement pour minimiser à la fois les allocations et les opérations de copie.</span><span class="sxs-lookup"><span data-stu-id="890f6-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="890f6-118">Cet article explore ces nouvelles fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="890f6-118">This article explores those new features.</span></span>

<span data-ttu-id="890f6-119">Cet article met l’accent sur les techniques de gestion des ressources suivantes :</span><span class="sxs-lookup"><span data-stu-id="890f6-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="890f6-120">Déclarez [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) un pour exprimer qu’un type est **immuable**.</span><span class="sxs-lookup"><span data-stu-id="890f6-120">Declare a [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) to express that a type is **immutable**.</span></span> <span data-ttu-id="890f6-121">Cela permet au compilateur d’enregistrer des copies défensives lors de l’utilisation de [`in`](language-reference/keywords/in-parameter-modifier.md) paramètres.</span><span class="sxs-lookup"><span data-stu-id="890f6-121">That enables the compiler to save defensive copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="890f6-122">Si un type ne peut pas `struct` être `readonly` immuable, déclarez aux membres qu’ils indiquent que le membre ne modifie pas l’état.</span><span class="sxs-lookup"><span data-stu-id="890f6-122">If a type can't be immutable, declare `struct` members `readonly` to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="890f6-123">Utilisez [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) un rendement lorsque la `struct` valeur <xref:System.IntPtr.Size?displayProperty=nameWithType> de retour est plus grande que la durée de vie de stockage est supérieure à la méthode de retour de la valeur.</span><span class="sxs-lookup"><span data-stu-id="890f6-123">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="890f6-124">Quand la taille d’une `readonly struct` plus grande que <xref:System.IntPtr.Size?displayProperty=nameWithType>, vous devez la passer comme paramètre `in` pour des raisons de performances.</span><span class="sxs-lookup"><span data-stu-id="890f6-124">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="890f6-125">Ne passez `struct` jamais `in` un paramètre à moins `readonly` qu’il ne `readonly` soit déclaré avec le modificateur ou la méthode n’appelle que les membres de la struct.</span><span class="sxs-lookup"><span data-stu-id="890f6-125">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="890f6-126">La violation de ces directives peut avoir une incidence négative sur les performances et pourrait conduire à un comportement obscur.</span><span class="sxs-lookup"><span data-stu-id="890f6-126">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="890f6-127">Utilisez [`ref struct`](language-reference/keywords/ref.md#ref-struct-types)un, `readonly ref struct` ou <xref:System.Span%601> un <xref:System.ReadOnlySpan%601> tel ou de travailler avec la mémoire comme une séquence d’octets.</span><span class="sxs-lookup"><span data-stu-id="890f6-127">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="890f6-128">Ces techniques vous forcent à trouver un équilibre entre deux objectifs concurrents concernant les **références** et les **valeurs**.</span><span class="sxs-lookup"><span data-stu-id="890f6-128">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="890f6-129">Les variables qui sont des [types référence](programming-guide/types/index.md#reference-types) contiennent une référence à l’emplacement en mémoire.</span><span class="sxs-lookup"><span data-stu-id="890f6-129">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="890f6-130">Les variables qui sont des [types valeur](programming-guide/types/index.md#value-types) contiennent directement leur valeur.</span><span class="sxs-lookup"><span data-stu-id="890f6-130">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="890f6-131">Ces différences mettent en évidence les différences importantes pour la gestion des ressources mémoire.</span><span class="sxs-lookup"><span data-stu-id="890f6-131">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="890f6-132">Les **types valeur** sont généralement copiés quand ils sont passés à une méthode ou retournés depuis une méthode.</span><span class="sxs-lookup"><span data-stu-id="890f6-132">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="890f6-133">Ce comportement comprend la copie de la valeur de `this` lors de l’appel de membres d’un type valeur.</span><span class="sxs-lookup"><span data-stu-id="890f6-133">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="890f6-134">Le coût de la copie est lié à la taille du type.</span><span class="sxs-lookup"><span data-stu-id="890f6-134">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="890f6-135">Les **types référence** sont alloués sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="890f6-135">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="890f6-136">Chaque nouvel objet nécessite une nouvelle allocation et doit par conséquent être récupéré par la suite.</span><span class="sxs-lookup"><span data-stu-id="890f6-136">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="890f6-137">Ces deux opérations prennent du temps.</span><span class="sxs-lookup"><span data-stu-id="890f6-137">Both these operations take time.</span></span> <span data-ttu-id="890f6-138">La référence est copiée quand un type référence est passé comme argument à une méthode ou retourné depuis une méthode.</span><span class="sxs-lookup"><span data-stu-id="890f6-138">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="890f6-139">Cet article utilise l’exemple de concept suivant d’une structure de points 3D pour expliquer ces recommandations :</span><span class="sxs-lookup"><span data-stu-id="890f6-139">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="890f6-140">Les différents exemples utilisent des implémentations différentes de ce concept.</span><span class="sxs-lookup"><span data-stu-id="890f6-140">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="890f6-141">Déclarer des structs en lecture seule pour les types valeur immuables</span><span class="sxs-lookup"><span data-stu-id="890f6-141">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="890f6-142">La déclaration d’une `struct` avec le modificateur `readonly` indique au compilateur que votre intention est de créer un type immuable.</span><span class="sxs-lookup"><span data-stu-id="890f6-142">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="890f6-143">Le compilateur applique cette décision de conception avec les règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="890f6-143">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="890f6-144">Tous les champs membres doivent être `readonly`</span><span class="sxs-lookup"><span data-stu-id="890f6-144">All field members must be `readonly`</span></span>
- <span data-ttu-id="890f6-145">Toutes les propriétés doivent être en lecture seule, y compris les propriétés implémentées automatiquement.</span><span class="sxs-lookup"><span data-stu-id="890f6-145">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="890f6-146">Ces deux règles sont suffisantes pour garantir qu’aucun membre d’une `readonly struct` ne modifie l’état de ce struct.</span><span class="sxs-lookup"><span data-stu-id="890f6-146">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="890f6-147">Le `struct` est immuable.</span><span class="sxs-lookup"><span data-stu-id="890f6-147">The `struct` is immutable.</span></span> <span data-ttu-id="890f6-148">La structure `Point3D` peut être définie comme struct immuable, comme le montre l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="890f6-148">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="890f6-149">Suivez cette recommandation quand l’intention de votre conception est de créer un type immuable.</span><span class="sxs-lookup"><span data-stu-id="890f6-149">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="890f6-150">Toute amélioration des performances est un avantage supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="890f6-150">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="890f6-151">Le `readonly struct` exprime clairement l’intention de votre conception.</span><span class="sxs-lookup"><span data-stu-id="890f6-151">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="890f6-152">Déclarer les membres readonly quand une struct ne peut pas être immuable</span><span class="sxs-lookup"><span data-stu-id="890f6-152">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="890f6-153">Dans C 8.0 et plus tard, quand un type de struct est mutable, vous devez déclarer les membres qui ne causent pas la mutation d’être `readonly`.</span><span class="sxs-lookup"><span data-stu-id="890f6-153">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="890f6-154">Considérez une application différente qui a besoin d’une structure de points 3D, mais doit soutenir la mutabilité.</span><span class="sxs-lookup"><span data-stu-id="890f6-154">Consider a different application that needs a 3D point structure, but must support mutability.</span></span> <span data-ttu-id="890f6-155">La version suivante de la structure `readonly` de points 3D ajoute le modificateur uniquement aux membres qui ne modifient pas la structure.</span><span class="sxs-lookup"><span data-stu-id="890f6-155">The following version of the 3D point structure adds the `readonly` modifier only to those members that don't modify the structure.</span></span> <span data-ttu-id="890f6-156">Suivez cet exemple lorsque votre conception doit prendre en charge les modifications apportées à la structure par certains membres, mais vous voulez toujours les avantages de l’application de la lecture sur certains membres:</span><span class="sxs-lookup"><span data-stu-id="890f6-156">Follow this example when your design must support modifications to the struct by some members, but you still want the benefits of enforcing readonly on some members:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

<span data-ttu-id="890f6-157">L’échantillon précédent montre de nombreux endroits `readonly` où vous pouvez appliquer le modificateur : méthodes, propriétés et accesseurs de propriété.</span><span class="sxs-lookup"><span data-stu-id="890f6-157">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="890f6-158">Si vous utilisez des propriétés auto-mises `readonly` en `get` œuvre, le compilateur ajoute le modificateur à l’accesseur pour les propriétés de lecture-écriture.</span><span class="sxs-lookup"><span data-stu-id="890f6-158">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="890f6-159">Le compilateur `readonly` ajoute le modificateur aux déclarations de `get` propriété auto-mises en œuvre pour les propriétés avec seulement un accesseur.</span><span class="sxs-lookup"><span data-stu-id="890f6-159">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="890f6-160">L’ajout du `readonly` modificateur aux membres qui ne mutent pas l’état fournit deux avantages connexes.</span><span class="sxs-lookup"><span data-stu-id="890f6-160">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="890f6-161">Tout d’abord, le compilateur applique votre intention.</span><span class="sxs-lookup"><span data-stu-id="890f6-161">First, the compiler enforces your intent.</span></span> <span data-ttu-id="890f6-162">Ce membre ne peut pas muter l’état de la structure, ni `readonly`accéder à un membre qui n’est pas également marqué .</span><span class="sxs-lookup"><span data-stu-id="890f6-162">That member can't mutate the struct's state, nor can it access a member that isn't also marked `readonly`.</span></span> <span data-ttu-id="890f6-163">Deuxièmement, le compilateur ne créera pas de copies défensives des paramètres lors de `in` l’accès à un `readonly` membre.</span><span class="sxs-lookup"><span data-stu-id="890f6-163">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="890f6-164">Le compilateur peut faire cette optimisation en `struct` toute sécurité car `readonly` il garantit que le n’est pas modifié par un membre.</span><span class="sxs-lookup"><span data-stu-id="890f6-164">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="890f6-165">Quand c’est possible, utilisez des instructions `ref readonly return` pour les grandes structures.</span><span class="sxs-lookup"><span data-stu-id="890f6-165">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="890f6-166">Vous pouvez retourner des valeurs par référence quand la valeur retournée n’est pas locale à la méthode effectuant le retour.</span><span class="sxs-lookup"><span data-stu-id="890f6-166">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="890f6-167">Un retour par référence signifie que seule la référence est copiée, et non pas la structure.</span><span class="sxs-lookup"><span data-stu-id="890f6-167">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="890f6-168">Dans l’exemple suivant, la propriété `Origin` ne peut pas utiliser un retour `ref`, car la valeur retournée est une variable locale :</span><span class="sxs-lookup"><span data-stu-id="890f6-168">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="890f6-169">Cependant, la définition de propriété suivante peut être retournée par référence, car la valeur retournée est un membre statique :</span><span class="sxs-lookup"><span data-stu-id="890f6-169">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="890f6-170">Vous ne voulez pas que les appelants modifient la valeur l’origine : vous devez donc retourner la valeur par `ref readonly` :</span><span class="sxs-lookup"><span data-stu-id="890f6-170">You don't want callers modifying the origin, so you should return the value by `ref readonly`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="890f6-171">Retourner `ref readonly` vous permet d’éviter de copier des structures plus grandes et de préserver l’immuabilité de vos membres de données internes.</span><span class="sxs-lookup"><span data-stu-id="890f6-171">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="890f6-172">À l’endroit de l’appel, les appelants font le choix d’utiliser la propriété `Origin` comme `ref readonly` ou comme valeur :</span><span class="sxs-lookup"><span data-stu-id="890f6-172">At the call site, callers make the choice to use the `Origin` property as a `ref readonly` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="890f6-173">La première assignation dans le code précédent effectue une copie de la constante `Origin` et assigne cette copie.</span><span class="sxs-lookup"><span data-stu-id="890f6-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="890f6-174">La seconde assigne une référence.</span><span class="sxs-lookup"><span data-stu-id="890f6-174">The second assigns a reference.</span></span> <span data-ttu-id="890f6-175">Notez que le modificateur `readonly` doit faire partie de la déclaration de la variable.</span><span class="sxs-lookup"><span data-stu-id="890f6-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="890f6-176">La référence à laquelle il fait référence ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="890f6-176">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="890f6-177">Toute tentative de modification provoque une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="890f6-177">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="890f6-178">Le modificateur `readonly` est nécessaire sur la déclaration de `originReference`.</span><span class="sxs-lookup"><span data-stu-id="890f6-178">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="890f6-179">Le compilateur fait en sorte que l’appelant ne puisse pas modifier la référence.</span><span class="sxs-lookup"><span data-stu-id="890f6-179">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="890f6-180">Toute tentative d’assignation directe de la valeur génère une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="890f6-180">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="890f6-181">Cependant, le compilateur ne peut pas savoir si une méthode membre modifie l’état du struct.</span><span class="sxs-lookup"><span data-stu-id="890f6-181">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="890f6-182">Pour garantir que l’objet n’est pas modifié, le compilateur crée une copie et appelle les références de membre en utilisant cette copie.</span><span class="sxs-lookup"><span data-stu-id="890f6-182">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="890f6-183">Les modifications sont apportées à cette copie défensive.</span><span class="sxs-lookup"><span data-stu-id="890f6-183">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="890f6-184">Appliquer le modificateur `in` à des paramètres `readonly struct` plus grands que `System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="890f6-184">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="890f6-185">Le mot clé `in` vient en complément des mots clés `ref` et `out` existants pour passer des arguments par référence.</span><span class="sxs-lookup"><span data-stu-id="890f6-185">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="890f6-186">Le mot clé `in` spécifie que l’argument doit être passé par référence, mais la méthode appelée ne modifie pas la valeur.</span><span class="sxs-lookup"><span data-stu-id="890f6-186">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="890f6-187">Vous disposez ainsi d’un vocabulaire complet pour exprimer votre intention de conception.</span><span class="sxs-lookup"><span data-stu-id="890f6-187">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="890f6-188">Les types valeur sont copiés s’ils sont passés à une méthode appelée et que vous ne spécifiez pas l’un des modificateurs suivants dans la signature de la méthode.</span><span class="sxs-lookup"><span data-stu-id="890f6-188">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="890f6-189">Chacun de ces modificateurs spécifie qu’une variable est passée par référence, ce qui évite la copie.</span><span class="sxs-lookup"><span data-stu-id="890f6-189">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="890f6-190">Chaque modificateur exprime une intention différente :</span><span class="sxs-lookup"><span data-stu-id="890f6-190">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="890f6-191">`out` : Cette méthode définit la valeur de l’argument utilisé comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="890f6-191">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="890f6-192">`ref` : Cette méthode peut définir la valeur de l’argument utilisé comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="890f6-192">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="890f6-193">`in`: Cette méthode ne modifie pas la valeur de l’argument utilisé comme ce paramètre.</span><span class="sxs-lookup"><span data-stu-id="890f6-193">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="890f6-194">Ajoutez le modificateur `in` pour passer un argument par référence et déclarez que votre intention de conception est de passer des arguments par référence afin d’éviter toute copie inutile.</span><span class="sxs-lookup"><span data-stu-id="890f6-194">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="890f6-195">Vous n’avez pas l’intention de modifier l’objet utilisé comme argument.</span><span class="sxs-lookup"><span data-stu-id="890f6-195">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="890f6-196">Cette pratique améliore souvent les performances pour les types valeur en lecture seule qui sont plus grands que <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="890f6-196">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="890f6-197">Pour les types simples (les types `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal`, `bool` et `enum`), les gains de performances potentiels sont minimes.</span><span class="sxs-lookup"><span data-stu-id="890f6-197">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="890f6-198">En fait, les performances peuvent se dégrader quand le passage par référence est utilisé pour les types plus petits que <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="890f6-198">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="890f6-199">Le code suivant montre un exemple de méthode qui calcule la distance entre deux points dans l’espace 3D.</span><span class="sxs-lookup"><span data-stu-id="890f6-199">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="890f6-200">Les arguments sont deux structures qui contiennent chacune trois valeurs de type double.</span><span class="sxs-lookup"><span data-stu-id="890f6-200">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="890f6-201">Un double représentant 8 octets, chaque argument représente 24 octets.</span><span class="sxs-lookup"><span data-stu-id="890f6-201">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="890f6-202">En spécifiant le modificateur `in`, vous passez une référence de 4 ou 8 octets à ces arguments, selon l’architecture de la machine.</span><span class="sxs-lookup"><span data-stu-id="890f6-202">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="890f6-203">La différence de taille est minime, mais elle peut s’accentuer si votre application appelle cette méthode dans une boucle dense avec de nombreuses valeurs différentes.</span><span class="sxs-lookup"><span data-stu-id="890f6-203">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="890f6-204">Le modificateur `in` complète aussi `out` et `ref` d’autres façons.</span><span class="sxs-lookup"><span data-stu-id="890f6-204">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="890f6-205">Vous ne pouvez pas créer des surcharges de méthode qui diffèrent seulement par la présence de `in`, `out` ou `ref`.</span><span class="sxs-lookup"><span data-stu-id="890f6-205">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="890f6-206">Ces nouvelles règles étendent le même comportement qui a toujours été défini pour les paramètres `out` et `ref`.</span><span class="sxs-lookup"><span data-stu-id="890f6-206">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="890f6-207">Comme les modificateurs `out` et `ref`, les types valeur ne sont pas convertis (boxed), car le modificateur `in` est appliqué.</span><span class="sxs-lookup"><span data-stu-id="890f6-207">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="890f6-208">Le modificateur `in` peut être appliqué à tout membre acceptant des paramètres : méthodes, délégués, expressions lambda, fonctions locales, indexeurs, opérateurs.</span><span class="sxs-lookup"><span data-stu-id="890f6-208">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="890f6-209">Une autre caractéristique des paramètres `in` est que vous pouvez utiliser des valeurs littérales ou des constantes pour l’argument d’un paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="890f6-209">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="890f6-210">Par ailleurs, contrairement à un paramètre `ref` ou `out`, il est inutile d’appliquer le modificateur `in` au niveau du site d’appel.</span><span class="sxs-lookup"><span data-stu-id="890f6-210">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="890f6-211">Le code suivant donne deux exemples d’appel de la méthode `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="890f6-211">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="890f6-212">Le premier utilise deux variables locales passées par référence.</span><span class="sxs-lookup"><span data-stu-id="890f6-212">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="890f6-213">La deuxième inclut une variable temporaire créée dans le cadre de l’appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="890f6-213">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="890f6-214">Le compilateur garantit la nature « en lecture seule » d’un argument `in` de plusieurs façons.</span><span class="sxs-lookup"><span data-stu-id="890f6-214">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="890f6-215">Premièrement, la méthode appelée ne peut rien assigner directement à un paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="890f6-215">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="890f6-216">Elle ne peut rien assigner directement à un champ d’un paramètre `in` quand cette valeur est un type `struct`.</span><span class="sxs-lookup"><span data-stu-id="890f6-216">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="890f6-217">De plus, vous ne pouvez pas passer un paramètre `in` à une méthode en utilisant le modificateur `ref` ou `out`.</span><span class="sxs-lookup"><span data-stu-id="890f6-217">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="890f6-218">Ces règles s’appliquent à tout champ d’un paramètre `in`, dans la mesure où le champ est un type `struct` et le paramètre également un type `struct`.</span><span class="sxs-lookup"><span data-stu-id="890f6-218">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="890f6-219">En fait, ces règles s’appliquent à plusieurs couches d’accès au membre, dans la mesure où les types situés à tous les niveaux d’accès au membre sont des `structs`.</span><span class="sxs-lookup"><span data-stu-id="890f6-219">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="890f6-220">Le compilateur considère que les types `struct` passés en tant qu’arguments `in` et leurs membres `struct` sont des variables en lecture seule quand ils sont utilisés en tant qu’arguments pour d’autres méthodes.</span><span class="sxs-lookup"><span data-stu-id="890f6-220">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="890f6-221">L’utilisation de paramètres `in` peut éviter les coûts potentiels en termes de performances qui sont liés aux copies.</span><span class="sxs-lookup"><span data-stu-id="890f6-221">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="890f6-222">Elle ne change pas la sémantique des appels de méthode.</span><span class="sxs-lookup"><span data-stu-id="890f6-222">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="890f6-223">Ainsi, vous n’avez pas besoin de spécifier le modificateur `in` à l’endroit de l’appel.</span><span class="sxs-lookup"><span data-stu-id="890f6-223">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="890f6-224">L’omission du modificateur `in` à l’endroit de l’appel indique au compilateur qu’il est autorisé à effectuer une copie de l’argument pour les raisons suivantes :</span><span class="sxs-lookup"><span data-stu-id="890f6-224">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="890f6-225">Il existe une conversion implicite, mais pas une conversion d’identité du type de l’argument en type du paramètre.</span><span class="sxs-lookup"><span data-stu-id="890f6-225">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="890f6-226">L’argument est une expression, mais ne dispose pas d’une variable de stockage connue.</span><span class="sxs-lookup"><span data-stu-id="890f6-226">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="890f6-227">Il existe une surcharge qui diffère selon la présence ou l’absence de `in`.</span><span class="sxs-lookup"><span data-stu-id="890f6-227">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="890f6-228">Dans ce cas, la surcharge par valeur convient mieux.</span><span class="sxs-lookup"><span data-stu-id="890f6-228">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="890f6-229">Ces règles s’avèrent utiles quand vous mettez à jour le code existant pour utiliser des arguments de référence en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="890f6-229">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="890f6-230">À l’intérieur de la méthode appelée, vous pouvez appeler toute méthode d’instance qui utilise des paramètres par valeur.</span><span class="sxs-lookup"><span data-stu-id="890f6-230">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="890f6-231">Dans ces instances, une copie du paramètre `in` est créée.</span><span class="sxs-lookup"><span data-stu-id="890f6-231">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="890f6-232">Étant donné que le compilateur peut créer une variable temporaire pour un paramètre `in`, vous pouvez aussi spécifier des valeurs par défaut pour n’importe quel paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="890f6-232">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="890f6-233">Le code suivant spécifie l’origine (point 0,0) comme valeur par défaut du deuxième point :</span><span class="sxs-lookup"><span data-stu-id="890f6-233">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="890f6-234">Pour forcer le compilateur à passer des arguments en lecture seule par référence, spécifiez le modificateur `in` sur les arguments à l’endroit de l’appel, comme indiqué dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="890f6-234">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="890f6-235">Ce comportement facilite l’adoption de paramètres `in` au fil du temps dans les codes bases volumineux où des gains de performance sont possibles.</span><span class="sxs-lookup"><span data-stu-id="890f6-235">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="890f6-236">Vous commencez par ajouter le modificateur `in` aux signatures de méthode.</span><span class="sxs-lookup"><span data-stu-id="890f6-236">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="890f6-237">Ensuite, vous pouvez ajouter le modificateur `in` aux endroits des appels et créer des types `readonly struct` pour permettre au compilateur d’éviter de créer des copies défensives des paramètres `in` à d’autres emplacements.</span><span class="sxs-lookup"><span data-stu-id="890f6-237">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="890f6-238">La désignation du paramètre `in` peut également être utilisée avec des types référence ou des valeurs numériques.</span><span class="sxs-lookup"><span data-stu-id="890f6-238">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="890f6-239">Toutefois, les avantages dans les deux cas sont minimes, voire inexistants.</span><span class="sxs-lookup"><span data-stu-id="890f6-239">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="avoid-mutable-structs-as-an-in-argument"></a><span data-ttu-id="890f6-240">Éviter les structs `in` mutables comme argument</span><span class="sxs-lookup"><span data-stu-id="890f6-240">Avoid mutable structs as an `in` argument</span></span>

<span data-ttu-id="890f6-241">Les techniques décrites ci-dessus expliquent comment éviter les copies en retournant des références et en passant les valeurs par référence.</span><span class="sxs-lookup"><span data-stu-id="890f6-241">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="890f6-242">Ces techniques conviennent le mieux quand les types d’arguments sont déclarés comme types `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="890f6-242">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="890f6-243">Sinon, le compilateur doit créer des **copies défensives** dans de nombreuses situations pour garantir la nature « en lecture seule » des arguments.</span><span class="sxs-lookup"><span data-stu-id="890f6-243">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="890f6-244">Considérons l’exemple suivant, qui calcule la distance d’un point 3D depuis l’origine :</span><span class="sxs-lookup"><span data-stu-id="890f6-244">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="890f6-245">La structure `Point3D` n’est *pas* un struct en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="890f6-245">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="890f6-246">Il y a six appels différents d’accès aux propriétés dans le corps de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="890f6-246">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="890f6-247">En première approche, vous pouvez penser que ces accès sont sécurisés.</span><span class="sxs-lookup"><span data-stu-id="890f6-247">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="890f6-248">Après tout, un accesseur `get` ne devrait pas modifier l’état de l’objet.</span><span class="sxs-lookup"><span data-stu-id="890f6-248">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="890f6-249">Mais il n’existe aucune règle du langage qui le garantisse.</span><span class="sxs-lookup"><span data-stu-id="890f6-249">But there's no language rule that enforces that.</span></span> <span data-ttu-id="890f6-250">Il s’agit seulement d’une convention courante.</span><span class="sxs-lookup"><span data-stu-id="890f6-250">It's only a common convention.</span></span> <span data-ttu-id="890f6-251">N’importe quel type peut implémenter un accesseur `get` qui a modifié l’état interne.</span><span class="sxs-lookup"><span data-stu-id="890f6-251">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="890f6-252">Sans une certaine garantie linguistique, le compilateur doit créer une copie `readonly` temporaire de l’argument avant d’appeler tout membre non marqué par le modificateur.</span><span class="sxs-lookup"><span data-stu-id="890f6-252">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member not marked with the `readonly` modifier.</span></span> <span data-ttu-id="890f6-253">Le stockage temporaire est créé sur la pile, les valeurs de l’argument sont copiées dans le stockage temporaire et la valeur est copiée sur la pile pour chaque accès au membre en tant qu’argument `this`.</span><span class="sxs-lookup"><span data-stu-id="890f6-253">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="890f6-254">Dans de nombreuses situations, ces copies nuisent à des performances suffisantes pour que le passage par valeur `readonly struct` soit plus rapide que le `readonly`passage par la référence lorsque le type d’argument n’est pas un et la méthode appelle les membres qui ne sont pas marqués .</span><span class="sxs-lookup"><span data-stu-id="890f6-254">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct` and the method calls members that aren't marked `readonly`.</span></span> <span data-ttu-id="890f6-255">Si vous marquez toutes les méthodes qui ne `readonly`modifient pas l’état de struct comme , le compilateur peut déterminer en toute sécurité que l’état de struct n’est pas modifié, et une copie défensive n’est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="890f6-255">If you mark all methods that don't modify the struct state as `readonly`, the compiler can safely determine that the struct state isn't modified, and a defensive copy is not needed.</span></span>

<span data-ttu-id="890f6-256">Au lieu de cela, si le calcul `ReadonlyPoint3D`de la distance utilise la struct immuable, les objets temporaires ne sont pas nécessaires:</span><span class="sxs-lookup"><span data-stu-id="890f6-256">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="890f6-257">Le compilateur génère un code plus efficace `readonly struct`lorsque `this` vous appelez les membres d’un `in` : La référence, au lieu d’une copie du récepteur, est toujours un paramètre transmis en référence à la méthode du membre.</span><span class="sxs-lookup"><span data-stu-id="890f6-257">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="890f6-258">Cette optimisation évite la copie quand vous utilisez un `readonly struct` comme argument `in`.</span><span class="sxs-lookup"><span data-stu-id="890f6-258">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="890f6-259">Vous ne devriez pas passer un type `in` de valeur nulle comme argument.</span><span class="sxs-lookup"><span data-stu-id="890f6-259">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="890f6-260">Le <xref:System.Nullable%601> type n’est pas déclaré comme une struction de lecture seulement.</span><span class="sxs-lookup"><span data-stu-id="890f6-260">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="890f6-261">Cela signifie que le compilateur doit générer des copies défensives pour tout argument de type valeur nullable passé à une méthode à l’aide du modificateur `in` sur la déclaration de paramètre.</span><span class="sxs-lookup"><span data-stu-id="890f6-261">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="890f6-262">Vous pouvez voir un programme d’exemple qui démontre les différences de performances à l’aide [de BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) dans notre [référentiel d’échantillons](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) sur GitHub.</span><span class="sxs-lookup"><span data-stu-id="890f6-262">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="890f6-263">Il compare le passage d’un struct mutable par valeur et par référence au passage d’un struct immuable par valeur et par référence.</span><span class="sxs-lookup"><span data-stu-id="890f6-263">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="890f6-264">L’utilisation du struct immuable et le passage par référence est le plus rapide.</span><span class="sxs-lookup"><span data-stu-id="890f6-264">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="890f6-265">Utilisez des types `ref struct` pour travailler avec des blocs ou de la mémoire sur un frame de pile</span><span class="sxs-lookup"><span data-stu-id="890f6-265">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="890f6-266">Une autre fonctionnalité associée du langage est la possibilité de déclarer un type valeur qui doit être contraint à un seul frame de pile.</span><span class="sxs-lookup"><span data-stu-id="890f6-266">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="890f6-267">Cette restriction permet au compilateur d’effectuer plusieurs optimisations.</span><span class="sxs-lookup"><span data-stu-id="890f6-267">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="890f6-268">Cette fonctionnalité vise principalement <xref:System.Span%601> et ses structures associées.</span><span class="sxs-lookup"><span data-stu-id="890f6-268">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="890f6-269">Vous obtiendrez de meilleures performances de ces améliorations en utilisant les API .NET nouvelles et mises à jour, qui facilitent l’utilisation du type <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="890f6-269">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="890f6-270">Vous pouvez avoir des exigences [`stackalloc`](language-reference/operators/stackalloc.md) similaires en travaillant avec la mémoire créée en utilisant ou lors de l’utilisation de la mémoire des API interop.</span><span class="sxs-lookup"><span data-stu-id="890f6-270">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="890f6-271">Pour répondre à ces besoins, vous pouvez définir vos propres types `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="890f6-271">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="890f6-272">Type`readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="890f6-272">`readonly ref struct` type</span></span>

<span data-ttu-id="890f6-273">La déclaration d’un struct comme `readonly ref` combine les avantages et les restrictions des déclarations `ref struct` et `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="890f6-273">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="890f6-274">La mémoire utilisée par l’étendue en lecture seule est limitée à un seul frame de pile, et cette mémoire ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="890f6-274">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="890f6-275">Conclusions</span><span class="sxs-lookup"><span data-stu-id="890f6-275">Conclusions</span></span>

<span data-ttu-id="890f6-276">L’utilisation de types valeur réduit le nombre d’opérations d’allocation :</span><span class="sxs-lookup"><span data-stu-id="890f6-276">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="890f6-277">Le stockage pour les types valeur est alloué sur la pile les variables locales et les arguments de méthode.</span><span class="sxs-lookup"><span data-stu-id="890f6-277">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="890f6-278">Le stockage pour les types valeur qui sont membres d’autres objets est alloué dans le cadre de cet objet, et non pas comme allocation distincte.</span><span class="sxs-lookup"><span data-stu-id="890f6-278">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="890f6-279">Le stockage pour les valeurs de retour de type valeur est alloué sur la pile.</span><span class="sxs-lookup"><span data-stu-id="890f6-279">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="890f6-280">Comparez cela avec les types référence dans ces mêmes situations :</span><span class="sxs-lookup"><span data-stu-id="890f6-280">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="890f6-281">Le stockage pour les types référence est alloué sur le tas pour les variables locales et les arguments de méthode.</span><span class="sxs-lookup"><span data-stu-id="890f6-281">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="890f6-282">La référence est stockée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="890f6-282">The reference is stored on the stack.</span></span>
- <span data-ttu-id="890f6-283">Le stockage pour les types référence qui sont membres d’autres objets sont alloués séparément sur le tas.</span><span class="sxs-lookup"><span data-stu-id="890f6-283">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="890f6-284">L’objet conteneur stocke la référence.</span><span class="sxs-lookup"><span data-stu-id="890f6-284">The containing object stores the reference.</span></span>
- <span data-ttu-id="890f6-285">Le stockage des valeurs de retour de type référence est alloué sur le tas.</span><span class="sxs-lookup"><span data-stu-id="890f6-285">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="890f6-286">La référence à ce stockage est stockée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="890f6-286">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="890f6-287">La réduction des allocations entraîne des compromis.</span><span class="sxs-lookup"><span data-stu-id="890f6-287">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="890f6-288">Vous copiez plus de mémoire quand la taille du `struct` est supérieure à la taille d’une référence.</span><span class="sxs-lookup"><span data-stu-id="890f6-288">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="890f6-289">Une référence est généralement sur 64 ou 32 bits, et elle varie en fonction de l’UC de la machine cible.</span><span class="sxs-lookup"><span data-stu-id="890f6-289">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="890f6-290">Ces compromis ont généralement un impact minimal sur les performances.</span><span class="sxs-lookup"><span data-stu-id="890f6-290">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="890f6-291">Cependant, pour les grands structs ou des collections plus grandes, l’impact sur les performances augmente.</span><span class="sxs-lookup"><span data-stu-id="890f6-291">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="890f6-292">L’impact peut être important dans des boucles denses et des chemins d’exécution intensifs pour les programmes.</span><span class="sxs-lookup"><span data-stu-id="890f6-292">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="890f6-293">Ces améliorations apportées au langage C# sont conçues pour les algorithmes dont les performances sont critiques, dans lesquels la réduction des allocations mémoire est un facteur essentiel pour atteindre le niveau de performance nécessaire.</span><span class="sxs-lookup"><span data-stu-id="890f6-293">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="890f6-294">Vous constaterez peut-être que vous n’utilisez pas souvent ces fonctionnalités dans votre code.</span><span class="sxs-lookup"><span data-stu-id="890f6-294">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="890f6-295">Cependant, ces améliorations ont été adoptées dans .NET.</span><span class="sxs-lookup"><span data-stu-id="890f6-295">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="890f6-296">Comme de plus en plus d’API adoptent ces fonctionnalités, vous verrez les performances de vos applications s’améliorer.</span><span class="sxs-lookup"><span data-stu-id="890f6-296">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="890f6-297">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="890f6-297">See also</span></span>

- [<span data-ttu-id="890f6-298">ref, mot clé</span><span class="sxs-lookup"><span data-stu-id="890f6-298">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="890f6-299">Retours ref et variables locales ref</span><span class="sxs-lookup"><span data-stu-id="890f6-299">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
