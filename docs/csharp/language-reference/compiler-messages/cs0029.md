---
title: Erreur du compilateur CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: f4dec41945ace6c6b0821b9870a88960efbe1e52
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/14/2020
ms.locfileid: "71332300"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="0b812-102">Erreur du compilateur CS0029</span><span class="sxs-lookup"><span data-stu-id="0b812-102">Compiler Error CS0029</span></span>

<span data-ttu-id="0b812-103">Impossible de convertir implicitement le type 'type' en 'type'</span><span class="sxs-lookup"><span data-stu-id="0b812-103">Cannot implicitly convert type 'type' to 'type'</span></span>

 <span data-ttu-id="0b812-104">Le compilateur requiert une conversion explicite.</span><span class="sxs-lookup"><span data-stu-id="0b812-104">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="0b812-105">Par exemple, il se peut que vous deviez effectuer un cast sur une valeur r en type identique à celui d’une valeur l.</span><span class="sxs-lookup"><span data-stu-id="0b812-105">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="0b812-106">Vous pouvez aussi avoir à fournir des routines de conversion pour prendre en charge certaines surcharges d’opérateur.</span><span class="sxs-lookup"><span data-stu-id="0b812-106">Or, you must provide conversion routines to support certain operator overloads.</span></span>

 <span data-ttu-id="0b812-107">Les conversions doivent se produire lors de l’assignation d’une variable d’un type à une variable d’un autre type.</span><span class="sxs-lookup"><span data-stu-id="0b812-107">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="0b812-108">Lors de l’assignation entre des variables de types différents, le compilateur doit convertir le type situé à droite de l’opérateur d’assignation dans le type situé à gauche de ce même opérateur.</span><span class="sxs-lookup"><span data-stu-id="0b812-108">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="0b812-109">Prenez le code ci-dessous :</span><span class="sxs-lookup"><span data-stu-id="0b812-109">Take the following the code:</span></span>

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 <span data-ttu-id="0b812-110">`i = lng;` effectue une assignation, mais les types de données des variables situées de part et d’autre de l’opérateur d’assignation ne correspondent pas.</span><span class="sxs-lookup"><span data-stu-id="0b812-110">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="0b812-111">Avant de faire l’affectation le compilateur `lng`est implicitement convertir la variable , qui est de type long, en un int. Ceci est implicite parce qu’aucun code n’a explicitement chargé le compilateur d’effectuer cette conversion.</span><span class="sxs-lookup"><span data-stu-id="0b812-111">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="0b812-112">Il s’agit néanmoins d’une conversion restrictive et c’est là où se pose un problème ; en effet, le compilateur n’autorise pas les conversions restrictives implicites, car il existe un risque potentiel de perte de données.</span><span class="sxs-lookup"><span data-stu-id="0b812-112">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>

 <span data-ttu-id="0b812-113">Une conversion restrictive existe lors de la conversion en un type de données qui occupe moins d’espace de stockage en mémoire que le type de données à partir duquel vous effectuez la conversion.</span><span class="sxs-lookup"><span data-stu-id="0b812-113">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="0b812-114">Par exemple, la conversion d’un type long en type int est considérée comme une conversion restrictive.</span><span class="sxs-lookup"><span data-stu-id="0b812-114">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="0b812-115">Le type long occupe 8 octets de mémoire tandis que le type int en occupe 4.</span><span class="sxs-lookup"><span data-stu-id="0b812-115">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="0b812-116">Pour voir dans quelles conditions survient la perte de données, prenez l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="0b812-116">To see how data loss can occur, consider the following sample:</span></span>

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 <span data-ttu-id="0b812-117">La variable `lng` contient maintenant une valeur qui ne peut être stockée dans la variable `i` du fait de sa trop grande taille.</span><span class="sxs-lookup"><span data-stu-id="0b812-117">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="0b812-118">Si vous deviez convertir cette valeur en type int, vous perdriez certaines données et la valeur convertie ne serait pas la même que la valeur avant la conversion.</span><span class="sxs-lookup"><span data-stu-id="0b812-118">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>

 <span data-ttu-id="0b812-119">Une conversion étendue est le contraire d’une conversion restrictive.</span><span class="sxs-lookup"><span data-stu-id="0b812-119">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="0b812-120">Dans ce cas, vous effectuez une conversion en un type de données qui occupe plus d’espace de stockage en mémoire que le type de données à partir duquel vous effectuez la conversion.</span><span class="sxs-lookup"><span data-stu-id="0b812-120">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="0b812-121">En voici un exemple :</span><span class="sxs-lookup"><span data-stu-id="0b812-121">Here is an example of a widening conversion:</span></span>

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 <span data-ttu-id="0b812-122">Notez la différence entre cet exemple de code et le premier.</span><span class="sxs-lookup"><span data-stu-id="0b812-122">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="0b812-123">Cette fois, la variable `lng` se trouve à gauche de l’opérateur d’assignation, de sorte qu’elle est la cible de votre assignation.</span><span class="sxs-lookup"><span data-stu-id="0b812-123">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="0b812-124">Pour que l’assignation puisse être effectuée, le compilateur doit implicitement convertir la variable `i`, qui est de type int, en type long.</span><span class="sxs-lookup"><span data-stu-id="0b812-124">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="0b812-125">Il s’agit d’une conversion étendue puisqu’elle s’effectue à partir d’un type qui occupe 4 octets de mémoire (int) vers un type qui en occupe 8 (long).</span><span class="sxs-lookup"><span data-stu-id="0b812-125">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="0b812-126">Les conversions étendues implicites sont autorisées, car il n’existe aucun risque potentiel de perte de données.</span><span class="sxs-lookup"><span data-stu-id="0b812-126">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="0b812-127">Toute valeur pouvant être stockée en type int peut l’être aussi en long.</span><span class="sxs-lookup"><span data-stu-id="0b812-127">Any value that can be stored in an int can also be stored in a long.</span></span>

 <span data-ttu-id="0b812-128">Les conversions restrictives implicites n’étant pas autorisées, il faut donc, pour compiler ce code, convertir explicitement le type de données.</span><span class="sxs-lookup"><span data-stu-id="0b812-128">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="0b812-129">Les conversions explicites sont effectuées à l’aide du cast.</span><span class="sxs-lookup"><span data-stu-id="0b812-129">Explicit conversions are done using casting.</span></span> <span data-ttu-id="0b812-130">Le cast est le terme utilisé en C# pour décrire la conversion d’un type de données en un autre.</span><span class="sxs-lookup"><span data-stu-id="0b812-130">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="0b812-131">Pour obtenir le code à compiler, vous devez utiliser la syntaxe suivante :</span><span class="sxs-lookup"><span data-stu-id="0b812-131">To get the code to compile we would need to use the following syntax:</span></span>

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 <span data-ttu-id="0b812-132">La troisième ligne de code indique au compilateur de convertir explicitement la variable `lng`, qui est de type long, en type int avant de procéder à l’assignation.</span><span class="sxs-lookup"><span data-stu-id="0b812-132">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="0b812-133">N’oubliez pas qu’avec une conversion restrictive, il existe un risque de perte de données.</span><span class="sxs-lookup"><span data-stu-id="0b812-133">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="0b812-134">Les conversions restrictives doivent être utilisées avec précaution car, même si la compilation est effectuée, des résultats inattendus peuvent se produire au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="0b812-134">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>

 <span data-ttu-id="0b812-135">Cette présentation ne concerne que les types valeur.</span><span class="sxs-lookup"><span data-stu-id="0b812-135">This discussion has only been for value types.</span></span> <span data-ttu-id="0b812-136">En utilisant les types valeur, vous travaillez directement avec les données stockées dans la variable.</span><span class="sxs-lookup"><span data-stu-id="0b812-136">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="0b812-137">Toutefois, le .NET Framework possède également des types référence.</span><span class="sxs-lookup"><span data-stu-id="0b812-137">However, the .NET Framework also has reference types.</span></span> <span data-ttu-id="0b812-138">En utilisant les types référence, vous travaillez avec une référence à une variable et non avec les données réelles.</span><span class="sxs-lookup"><span data-stu-id="0b812-138">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="0b812-139">Les classes, les interfaces et les tableaux sont des exemples de types référence.</span><span class="sxs-lookup"><span data-stu-id="0b812-139">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="0b812-140">Vous ne pouvez implicitement ou explicitement effectuer une conversion d’un type référence en un autre que si le compilateur autorise la conversion spécifique ou si les opérateurs de conversion appropriés sont implémentés.</span><span class="sxs-lookup"><span data-stu-id="0b812-140">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>

 <span data-ttu-id="0b812-141">L’exemple suivant génère l’erreur CS0029 :</span><span class="sxs-lookup"><span data-stu-id="0b812-141">The following sample generates CS0029:</span></span>

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a><span data-ttu-id="0b812-142">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="0b812-142">See also</span></span>

- [<span data-ttu-id="0b812-143">Opérateurs de conversion définie par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="0b812-143">User-defined conversion operators</span></span>](../operators/user-defined-conversion-operators.md)
