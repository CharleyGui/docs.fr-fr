---
title: Erreur du compilateur CS0165
ms.date: 07/20/2015
f1_keywords:
- CS0165
helpviewer_keywords:
- CS0165
ms.assetid: e7eb7c90-af16-4734-b747-214030696975
ms.openlocfilehash: c2e01bc3da37996ca4970c18c62db8c18320a185
ms.sourcegitcommit: 986f836f72ef10876878bd6217174e41464c145a
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/19/2019
ms.locfileid: "69608066"
---
# <a name="compiler-error-cs0165"></a><span data-ttu-id="85279-102">Erreur du compilateur CS0165</span><span class="sxs-lookup"><span data-stu-id="85279-102">Compiler Error CS0165</span></span>
<span data-ttu-id="85279-103">Utilisation d’une variable locale non assignée 'name'</span><span class="sxs-lookup"><span data-stu-id="85279-103">Use of unassigned local variable 'name'</span></span>  
  
 <span data-ttu-id="85279-104">Le compilateur C# n’autorise pas l’utilisation de variables non initialisées.</span><span class="sxs-lookup"><span data-stu-id="85279-104">The C# compiler does not allow the use of uninitialized variables.</span></span> <span data-ttu-id="85279-105">Si le compilateur détecte l’utilisation d’une variable qui n’a peut-être pas été initialisée, il génère l’erreur du compilateur CS0165.</span><span class="sxs-lookup"><span data-stu-id="85279-105">If the compiler detects the use of a variable that might not have been initialized, it generates compiler error CS0165.</span></span> <span data-ttu-id="85279-106">Pour plus d’informations, consultez [Champs](../../programming-guide/classes-and-structs/fields.md).</span><span class="sxs-lookup"><span data-stu-id="85279-106">For more information, see [Fields](../../programming-guide/classes-and-structs/fields.md).</span></span> <span data-ttu-id="85279-107">Notez que cette erreur est générée quand le compilateur rencontre une construction qui peut provoquer l’utilisation d’une variable non assignée, même si ce n’est pas le cas de votre code en particulier.</span><span class="sxs-lookup"><span data-stu-id="85279-107">Note that this error is generated when the compiler encounters a construct that might result in the use of an unassigned variable, even if your particular code does not.</span></span> <span data-ttu-id="85279-108">Il est ainsi inutile d’utiliser des règles trop complexes pour l’assignation définie.</span><span class="sxs-lookup"><span data-stu-id="85279-108">This avoids the necessity of overly-complex rules for definite assignment.</span></span>  
  
 <span data-ttu-id="85279-109">Pour plus d’informations, voir [Pourquoi une expression lambda récursive provoque-t-elle une erreur d’affectation définie ?](https://blogs.msdn.com/ericlippert/archive/2006/08/18/706398.aspx).</span><span class="sxs-lookup"><span data-stu-id="85279-109">For more information, see [Why does a recursive lambda cause a definite assignment error?](https://blogs.msdn.com/ericlippert/archive/2006/08/18/706398.aspx).</span></span>  
  
## <a name="example"></a><span data-ttu-id="85279-110">Exemples</span><span class="sxs-lookup"><span data-stu-id="85279-110">Example</span></span>  
 <span data-ttu-id="85279-111">L’exemple suivant génère l’erreur CS0165 :</span><span class="sxs-lookup"><span data-stu-id="85279-111">The following sample generates CS0165:</span></span>  
  
```csharp  
// CS0165.cs  
using System;  
  
class MyClass  
{  
    public int i;  
}  
  
class MyClass2  
{  
    public static void Main(string[] args)  
    {  
        // i and j are not initialized.  
        int i, j;  
  
        // You can provide a value for args[0] in the 'Command line arguments'  
        // text box on the Debug tab of the project Properties window.  
        if (args[0] == "test")  
        {  
            i = 0;  
        }  
        // If the following else clause is absent, i might not be  
        // initialized.  
        //else  
        //{  
        //    i = 1;  
        //}  
  
        // Because i might not have been initialized, the following   
        // line causes CS0165.  
        j = i;  
  
        // To resolve the error, uncomment the else clause of the previous  
        // if statement, or initialize i when you declare it.  
  
        // The following example causes CS0165 because myInstance is  
        // declared but not instantiated.  
        MyClass myInstance;  
        // The following line causes the error.  
        myInstance.i = 0;   
  
        // To resolve the error, replace the previous declaration with  
        // the following line.  
        //MyClass myInstance = new MyClass();  
    }  
}  
```  
  
## <a name="example"></a><span data-ttu-id="85279-112">Exemples</span><span class="sxs-lookup"><span data-stu-id="85279-112">Example</span></span>  
 <span data-ttu-id="85279-113">L’erreur du compilateur CS0165 peut se produire dans les définitions de délégué récursif.</span><span class="sxs-lookup"><span data-stu-id="85279-113">Compiler error CS0165 can occur in recursive delegate definitions.</span></span> <span data-ttu-id="85279-114">Vous pouvez éviter cette erreur en définissant le délégué dans deux instructions afin que la variable ne soit pas utilisée avant d’être initialisée.</span><span class="sxs-lookup"><span data-stu-id="85279-114">You can avoid the error by defining the delegate in two statements so that the variable is not used before it is initialized.</span></span> <span data-ttu-id="85279-115">L’exemple suivant illustre l’erreur et la résolution.</span><span class="sxs-lookup"><span data-stu-id="85279-115">The following example demonstrates the error and the resolution.</span></span>  
  
```csharp  
class Program  
{  
    delegate void Del();  
    static void Main(string[] args)  
    {  
        // The following line causes CS0165 because variable d is used   
        // as an argument before it has been initialized.  
        Del d = delegate() { System.Console.WriteLine(d); };   
  
        //// To resolve the error, initialize d in a separate statement.  
        //Del d = null;  
        //// After d is initialized, you can use it as an argument.  
        //d = delegate() { System.Console.WriteLine(d); };  
        //d();  
    }  
}  
```
