---
description: where (contrainte de type générique) - Référence C#
title: where (contrainte de type générique) - Référence C#
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 78f784135c6bf01ea9724fcf92be234e6b86ff07
ms.sourcegitcommit: d579fb5e4b46745fd0f1f8874c94c6469ce58604
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/30/2020
ms.locfileid: "89141905"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="433ef-103">where (contrainte de type générique) (Référence C#)</span><span class="sxs-lookup"><span data-stu-id="433ef-103">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="433ef-104">La clause `where` dans une définition générique spécifie des contraintes sur les types qui sont utilisés comme arguments pour les paramètres de type d’un type générique, d’une méthode, d’un délégué ou d’une fonction locale.</span><span class="sxs-lookup"><span data-stu-id="433ef-104">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="433ef-105">Les contraintes peuvent spécifier des interfaces, des classes de base ou exiger qu’un type générique soit une référence, une valeur ou un type non managé.</span><span class="sxs-lookup"><span data-stu-id="433ef-105">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="433ef-106">Elles déclarent les fonctionnalités que l’argument de type doit avoir.</span><span class="sxs-lookup"><span data-stu-id="433ef-106">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="433ef-107">Vous pouvez, par exemple, déclarer une classe générique, `MyGenericClass`, de telle sorte que le paramètre de type `T` implémente l’interface <xref:System.IComparable%601> :</span><span class="sxs-lookup"><span data-stu-id="433ef-107">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="433ef-108">Pour plus d’informations sur la clause where dans une expression de requête, consultez [where, clause](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="433ef-108">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="433ef-109">La clause `where` peut également inclure une contrainte de classe de base.</span><span class="sxs-lookup"><span data-stu-id="433ef-109">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="433ef-110">La contrainte de classe de base indique qu’un type à utiliser comme argument de type pour ce type générique a la classe spécifiée comme classe de base, ou est cette classe de base.</span><span class="sxs-lookup"><span data-stu-id="433ef-110">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="433ef-111">Si la contrainte de classe de base est utilisée, elle doit apparaître avant toute autre contrainte sur ce paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="433ef-111">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="433ef-112">Certains types ne sont pas autorisés comme contrainte de classe de base : <xref:System.Object>, <xref:System.Array> et <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="433ef-112">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="433ef-113">Avant C# 7,3, <xref:System.Enum> , <xref:System.Delegate> et <xref:System.MulticastDelegate> étaient également interdits en tant que contraintes de classe de base.</span><span class="sxs-lookup"><span data-stu-id="433ef-113">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="433ef-114">L’exemple suivant montre les types qui peuvent maintenant être spécifiés comme classe de base :</span><span class="sxs-lookup"><span data-stu-id="433ef-114">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#2)]

<span data-ttu-id="433ef-115">Dans un contexte Nullable en C# 8,0 et versions ultérieures, la possibilité de valeur null du type de classe de base est appliquée.</span><span class="sxs-lookup"><span data-stu-id="433ef-115">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="433ef-116">Si la classe de base n’accepte pas les valeurs null (par exemple `Base` ), l’argument de type ne doit pas avoir la valeur null.</span><span class="sxs-lookup"><span data-stu-id="433ef-116">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="433ef-117">Si la classe de base accepte la valeur null (par exemple `Base?` ), l’argument de type peut être un type de référence Nullable ou non Nullable.</span><span class="sxs-lookup"><span data-stu-id="433ef-117">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="433ef-118">Le compilateur émet un avertissement si l’argument de type est un type référence Nullable lorsque la classe de base n’accepte pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="433ef-118">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="433ef-119">La clause `where` peut spécifier que le type est une `class` ou un `struct`.</span><span class="sxs-lookup"><span data-stu-id="433ef-119">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="433ef-120">La contrainte `struct` supprime la nécessité de spécifier une contrainte de classe de base de `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="433ef-120">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="433ef-121">Le type `System.ValueType` ne doit pas être utilisé comme contrainte de classe de base.</span><span class="sxs-lookup"><span data-stu-id="433ef-121">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="433ef-122">L’exemple suivant montre les contraintes `class` et `struct` :</span><span class="sxs-lookup"><span data-stu-id="433ef-122">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#3)]

<span data-ttu-id="433ef-123">Dans un contexte Nullable en C# 8,0 et versions ultérieures, la `class` contrainte requiert qu’un type soit un type référence qui n’accepte pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="433ef-123">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="433ef-124">Pour autoriser les types référence Nullable, utilisez la `class?` contrainte, qui autorise à la fois les types référence Nullable et non Nullable.</span><span class="sxs-lookup"><span data-stu-id="433ef-124">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="433ef-125">La `where` clause peut inclure la `notnull` contrainte.</span><span class="sxs-lookup"><span data-stu-id="433ef-125">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="433ef-126">La `notnull` contrainte limite le paramètre de type aux types non nullables.</span><span class="sxs-lookup"><span data-stu-id="433ef-126">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="433ef-127">Ce type peut être un type [valeur](../builtin-types/value-types.md) ou un type référence non Nullable.</span><span class="sxs-lookup"><span data-stu-id="433ef-127">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="433ef-128">La `notnull` contrainte est disponible à partir de C# 8,0 pour le code compilé dans un [ `nullable enable` contexte](../../nullable-references.md#nullable-contexts).</span><span class="sxs-lookup"><span data-stu-id="433ef-128">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="433ef-129">Contrairement à d’autres contraintes, si un argument de type viole la `notnull` contrainte, le compilateur génère un avertissement au lieu d’une erreur.</span><span class="sxs-lookup"><span data-stu-id="433ef-129">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="433ef-130">Les avertissements sont générés uniquement dans un `nullable enable` contexte.</span><span class="sxs-lookup"><span data-stu-id="433ef-130">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="433ef-131">Les déclarations génériques qui incluent la `notnull` contrainte peuvent être utilisées dans un contexte oublie Nullable, mais le compilateur n’applique pas la contrainte.</span><span class="sxs-lookup"><span data-stu-id="433ef-131">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](snippets/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="433ef-132">La clause `where` peut aussi inclure une contrainte `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="433ef-132">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="433ef-133">La contrainte `unmanaged` limite le paramètre de type aux types connus sous le nom de [types non managés](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="433ef-133">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="433ef-134">La contrainte `unmanaged` facilite l’écriture de code interop de bas niveau en C#.</span><span class="sxs-lookup"><span data-stu-id="433ef-134">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="433ef-135">Cette contrainte permet des routines réutilisables sur tous les types non managés.</span><span class="sxs-lookup"><span data-stu-id="433ef-135">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="433ef-136">La contrainte `unmanaged` ne peut pas être combinée avec la contrainte `class` ou `struct`.</span><span class="sxs-lookup"><span data-stu-id="433ef-136">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="433ef-137">La contrainte `unmanaged` exige que le type doit être un `struct` :</span><span class="sxs-lookup"><span data-stu-id="433ef-137">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#4)]

<span data-ttu-id="433ef-138">La clause `where` peut également inclure une contrainte de constructeur, `new()`.</span><span class="sxs-lookup"><span data-stu-id="433ef-138">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="433ef-139">Cette contrainte permet de créer une instance d’un paramètre de type à l’aide de l’opérateur `new`.</span><span class="sxs-lookup"><span data-stu-id="433ef-139">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="433ef-140">La [contrainte New ()](new-constraint.md) permet au compilateur de savoir que tout argument de type fourni doit avoir un constructeur sans paramètre accessible.</span><span class="sxs-lookup"><span data-stu-id="433ef-140">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="433ef-141">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="433ef-141">For example:</span></span>

[!code-csharp[using the new constraint](snippets/GenericWhereConstraints.cs#5)]

<span data-ttu-id="433ef-142">La contrainte `new()` apparaît en dernier dans la clause `where`.</span><span class="sxs-lookup"><span data-stu-id="433ef-142">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="433ef-143">La contrainte `new()` ne peut pas être combinée avec les contraintes `struct` ou `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="433ef-143">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="433ef-144">Tous les types répondant à ces contraintes doivent avoir un constructeur sans paramètre accessible, ce qui rend la contrainte `new()` redondante.</span><span class="sxs-lookup"><span data-stu-id="433ef-144">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="433ef-145">Avec plusieurs paramètres de type, utilisez une clause `where` pour chaque paramètre de type, par exemple :</span><span class="sxs-lookup"><span data-stu-id="433ef-145">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](snippets/GenericWhereConstraints.cs#6)]

<span data-ttu-id="433ef-146">Vous pouvez également joindre des contraintes aux paramètres de type des méthodes génériques, comme montré dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="433ef-146">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#7)]

<span data-ttu-id="433ef-147">Notez que la syntaxe décrivant les contraintes de paramètre de type sur les délégués est la même que celle des méthodes :</span><span class="sxs-lookup"><span data-stu-id="433ef-147">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#8)]

<span data-ttu-id="433ef-148">Pour plus d’informations sur les délégués génériques, consultez [Délégués génériques](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="433ef-148">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="433ef-149">Pour plus d’informations sur la syntaxe et l’utilisation de contraintes, consultez [Contraintes sur les paramètres de type](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="433ef-149">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="433ef-150">spécification du langage C#</span><span class="sxs-lookup"><span data-stu-id="433ef-150">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="433ef-151">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="433ef-151">See also</span></span>

- [<span data-ttu-id="433ef-152">Référence C#</span><span class="sxs-lookup"><span data-stu-id="433ef-152">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="433ef-153">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="433ef-153">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="433ef-154">Introduction aux génériques</span><span class="sxs-lookup"><span data-stu-id="433ef-154">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="433ef-155">nouvelle contrainte</span><span class="sxs-lookup"><span data-stu-id="433ef-155">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="433ef-156">Contraintes sur les paramètres de type</span><span class="sxs-lookup"><span data-stu-id="433ef-156">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
