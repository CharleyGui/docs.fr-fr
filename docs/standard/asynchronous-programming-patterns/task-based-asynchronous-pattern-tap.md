---
title: Modèle asynchrone basé sur les tâches (TAP, Task-based Asynchronous Pattern)
ms.date: 02/26/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
ms.openlocfilehash: 89c486618729c334bf74f0a1f4f9dd1b3cee8b0e
ms.sourcegitcommit: 00aa62e2f469c2272a457b04e66b4cc3c97a800b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/28/2020
ms.locfileid: "78158166"
---
# <a name="task-based-asynchronous-pattern-tap"></a><span data-ttu-id="995eb-102">Modèle asynchrone basé sur les tâches (TAP)</span><span class="sxs-lookup"><span data-stu-id="995eb-102">Task-based asynchronous pattern (TAP)</span></span>
<span data-ttu-id="995eb-103">Le modèle asynchrone basé sur des tâches (TAP) est basé sur les types <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> et <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> de l’espace de noms <xref:System.Threading.Tasks?displayProperty=nameWithType>, qui sont utilisés pour représenter les opérations asynchrones arbitraires.</span><span class="sxs-lookup"><span data-stu-id="995eb-103">The Task-based Asynchronous Pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="995eb-104">Le TAP est le modèle de conception asynchrone recommandé pour le nouveau développement.</span><span class="sxs-lookup"><span data-stu-id="995eb-104">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="995eb-105">Noms, paramètres et types de retour</span><span class="sxs-lookup"><span data-stu-id="995eb-105">Naming, parameters, and return types</span></span>

<span data-ttu-id="995eb-106">Le TAP utilise une méthode unique pour représenter le début et la fin d'une opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="995eb-106">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="995eb-107">Ce fonctionnement le différencie du modèle de programmation asynchrone (APM ou `IAsyncResult`) et du modèle asynchrone basé sur les événements (EAP).</span><span class="sxs-lookup"><span data-stu-id="995eb-107">This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP).</span></span> <span data-ttu-id="995eb-108">Les méthodes `Begin` et `End` sont nécessaires pour le modèle APM.</span><span class="sxs-lookup"><span data-stu-id="995eb-108">APM requires `Begin` and `End` methods.</span></span> <span data-ttu-id="995eb-109">Le modèle EAP a besoin d’une méthode comportant le suffixe `Async`, ainsi que d’un ou plusieurs événements, de types de délégués de gestionnaire d’événements et de types dérivés de `EventArg`.</span><span class="sxs-lookup"><span data-stu-id="995eb-109">EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="995eb-110">Les méthodes asynchrones du modèle TAP qui retournent des types compatibles await, comme `Async`, <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601> et <xref:System.Threading.Tasks.ValueTask>, comprennent le suffixe <xref:System.Threading.Tasks.ValueTask%601> après le nom de l’opération.</span><span class="sxs-lookup"><span data-stu-id="995eb-110">Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>.</span></span> <span data-ttu-id="995eb-111">Par exemple, une opération `Get` asynchrone qui retourne une valeur `Task<String>` peut porter le nom `GetAsync`.</span><span class="sxs-lookup"><span data-stu-id="995eb-111">For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`.</span></span> <span data-ttu-id="995eb-112">Si vous ajoutez une méthode TAP à une classe qui contient déjà un nom de méthode EAP avec le suffixe `Async`, utilisez plutôt le suffixe `TaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="995eb-112">If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="995eb-113">Par exemple, si la classe possède déjà une méthode `GetAsync`, utilisez le nom `GetTaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="995eb-113">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span> <span data-ttu-id="995eb-114">Les méthodes qui lancent une opération asynchrone, mais ne retournent pas de type compatible await, doivent porter un nom qui commence par `Begin`, `Start` ou un autre verbe suggérant qu’elles ne retournent ni ne lèvent le résultat de l’opération.</span><span class="sxs-lookup"><span data-stu-id="995eb-114">If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.</span></span>  
  
 <span data-ttu-id="995eb-115">Une méthode TAP retourne une <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> ou une <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, selon que la méthode synchrone correspondante retourne void ou un type `TResult`.</span><span class="sxs-lookup"><span data-stu-id="995eb-115">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="995eb-116">Les paramètres d’une méthode TAP doivent correspondre à ceux de son équivalent synchrone, dans le même ordre.</span><span class="sxs-lookup"><span data-stu-id="995eb-116">The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.</span></span>  <span data-ttu-id="995eb-117">Toutefois, les paramètres `out` et `ref` sont exempts de cette règle et doivent être évités entièrement.</span><span class="sxs-lookup"><span data-stu-id="995eb-117">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="995eb-118">Les données qui auraient dû être retournées par un paramètre `out` ou `ref` doivent être retournées comme faisant partie du `TResult` retourné par <xref:System.Threading.Tasks.Task%601>, et doivent utiliser un tuple ou une structure de données personnalisée pour s’adapter à plusieurs valeurs.</span><span class="sxs-lookup"><span data-stu-id="995eb-118">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> <span data-ttu-id="995eb-119">Il peut rester intéressant d’ajouter un paramètre <xref:System.Threading.CancellationToken> même si l’équivalent synchrone de la méthode TAP n’en offre pas.</span><span class="sxs-lookup"><span data-stu-id="995eb-119">You should also consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.</span></span>

 <span data-ttu-id="995eb-120">Les méthodes qui sont consacrées exclusivement à la création, la manipulation ou la combinaison de tâches (où l’intention asynchrone de la méthode est clairement indiquée dans le nom de la méthode ou dans le nom du type auquel la méthode appartient) n’ont pas besoin de suivre ce modèle d’affectation de noms. Ces types de méthodes sont souvent appelés *combinateurs*.</span><span class="sxs-lookup"><span data-stu-id="995eb-120">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="995eb-121">Les exemples de combinateurs incluent <xref:System.Threading.Tasks.Task.WhenAll%2A> et <xref:System.Threading.Tasks.Task.WhenAny%2A>, et sont traités dans la section [Utilisation des combinateurs intégrés basés sur des tâches](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) de l'article [Utilisation du modèle asynchrone basé sur les tâches](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="995eb-121">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="995eb-122">Pour obtenir des exemples de la façon dont la syntaxe du TAP diffère de celle utilisée dans les modèles de programmation asynchrones hérités tels que le modèle de programmation asynchrone (APM) et le modèle asynchrone basé sur des événements (EAP), consultez [Modèles de programmation asynchrone](../../../docs/standard/asynchronous-programming-patterns/index.md).</span><span class="sxs-lookup"><span data-stu-id="995eb-122">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](../../../docs/standard/asynchronous-programming-patterns/index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="995eb-123">Lancer une opération asynchrone</span><span class="sxs-lookup"><span data-stu-id="995eb-123">Initiating an asynchronous operation</span></span>  
 <span data-ttu-id="995eb-124">Une méthode asynchrone basée sur le TAP peut effectuer une petite quantité de travail de façon synchrone, comme valider les arguments et initialiser l’opération asynchrone, avant de retourner la tâche résultante.</span><span class="sxs-lookup"><span data-stu-id="995eb-124">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="995eb-125">Le travail synchrone doit être conservé au minimum afin que la méthode asynchrone puisse retourner rapidement.</span><span class="sxs-lookup"><span data-stu-id="995eb-125">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="995eb-126">Les raisons d'un retour rapide sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="995eb-126">Reasons for a quick return include the following:</span></span>  
  
- <span data-ttu-id="995eb-127">Les méthodes asynchrones peuvent être appelées par des threads d'interface utilisateur, et tout travail synchrone de longue durée peut nuire à la réactivité de l'application.</span><span class="sxs-lookup"><span data-stu-id="995eb-127">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
- <span data-ttu-id="995eb-128">Plusieurs méthodes asynchrones peuvent être lancées simultanément.</span><span class="sxs-lookup"><span data-stu-id="995eb-128">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="995eb-129">Par conséquent, tout travail de longue durée dans la partie synchrone d'une méthode asynchrone risque de retarder l'initiation d'autres opérations asynchrones, réduisant ainsi les avantages offerts par l'accès concurrentiel.</span><span class="sxs-lookup"><span data-stu-id="995eb-129">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="995eb-130">Dans certains cas, la quantité de travail nécessaire pour terminer l'opération est inférieure à la quantité de travail nécessaire pour lancer l'opération de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="995eb-130">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="995eb-131">La lecture d'un flux où l'opération de lecture peut être satisfaite par les données déjà mises en mémoire tampon est un exemple de ce type de scénario.</span><span class="sxs-lookup"><span data-stu-id="995eb-131">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="995eb-132">Dans de tels cas, l'opération peut s'exécuter de façon synchrone et peut retourner une tâche qui a déjà été effectuée.</span><span class="sxs-lookup"><span data-stu-id="995eb-132">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="995eb-133">Exceptions</span><span class="sxs-lookup"><span data-stu-id="995eb-133">Exceptions</span></span>  
 <span data-ttu-id="995eb-134">Une méthode asynchrone doit lever une exception pour être rejetée de l'appel de méthode asynchrone uniquement en réponse à une erreur d'utilisation.</span><span class="sxs-lookup"><span data-stu-id="995eb-134">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="995eb-135">Les erreurs d'utilisation ne doivent jamais se produire dans le code de production.</span><span class="sxs-lookup"><span data-stu-id="995eb-135">Usage errors should never occur in production code.</span></span> <span data-ttu-id="995eb-136">Par exemple, si le fait de passer une référence null (`Nothing` en Visual Basic) comme arguments de la méthode provoque un état d’erreur (généralement représenté par une exception <xref:System.ArgumentNullException> ), il est possible de modifier le code appelant pour vérifier qu’une référence null n’est jamais passée.</span><span class="sxs-lookup"><span data-stu-id="995eb-136">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method’s arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="995eb-137">Pour toutes les autres erreurs, les exceptions qui se produisent lorsqu'une méthode asynchrone est en cours d'exécution doivent être assignées à la tâche retournée, même si la méthode asynchrone se termine avant que la tâche ne soit retournée.</span><span class="sxs-lookup"><span data-stu-id="995eb-137">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="995eb-138">En général, une tâche contient au plus une exception.</span><span class="sxs-lookup"><span data-stu-id="995eb-138">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="995eb-139">Toutefois, si la tâche représente plusieurs opérations (par exemple, <xref:System.Threading.Tasks.Task.WhenAll%2A>), plusieurs exceptions peuvent être associées à une tâche unique.</span><span class="sxs-lookup"><span data-stu-id="995eb-139">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="995eb-140">Environnement cible</span><span class="sxs-lookup"><span data-stu-id="995eb-140">Target environment</span></span>  
 <span data-ttu-id="995eb-141">Lorsque vous implémentez une méthode TAP, il est possible de déterminer où l'exécution asynchrone se produit.</span><span class="sxs-lookup"><span data-stu-id="995eb-141">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="995eb-142">Il est possible de choisir d'exécuter la charge de travail dans le pool de threads, de l'implémenter à l'aide d'E/S asynchrones (sans être lié à un thread pour la majorité de l'exécution de l'opération), de l'exécuter sur un thread spécifique (tel que le thread d'interface utilisateur), ou d'utiliser plusieurs contextes potentiels.</span><span class="sxs-lookup"><span data-stu-id="995eb-142">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation’s execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="995eb-143">Une méthode TAP peut même ne rien avoir à exécuter et simplement retourner une <xref:System.Threading.Tasks.Task> qui représente l’occurrence d’une condition ailleurs dans le système (par exemple, une tâche qui représente des données reçues par une structure de données en file d’attente).</span><span class="sxs-lookup"><span data-stu-id="995eb-143">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>

 <span data-ttu-id="995eb-144">L’appelant de la méthode TAP peut bloquer l’attente de l’exécution de la méthode TAP par une attente synchrone sur la tâche obtenue, ou il peut exécuter du code supplémentaire (continuation) quand l’opération asynchrone est terminée.</span><span class="sxs-lookup"><span data-stu-id="995eb-144">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="995eb-145">Le créateur du code de continuation a le contrôle sur l'endroit où ce code s'exécute.</span><span class="sxs-lookup"><span data-stu-id="995eb-145">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="995eb-146">Il est possible de créer le code de continuation explicitement, via des méthodes sur la classe <xref:System.Threading.Tasks.Task> (par exemple, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) ou implicitement, à l'aide de la prise en charge des langages par les continuations (par exemple, `await` en C#, `Await` en Visual Basic, `AwaitValue` en F#).</span><span class="sxs-lookup"><span data-stu-id="995eb-146">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="995eb-147">État des tâches</span><span class="sxs-lookup"><span data-stu-id="995eb-147">Task status</span></span>  
 <span data-ttu-id="995eb-148">La classe <xref:System.Threading.Tasks.Task> fournit un cycle de vie pour les opérations asynchrones, et ce cycle est représenté par l'énumération <xref:System.Threading.Tasks.TaskStatus>.</span><span class="sxs-lookup"><span data-stu-id="995eb-148">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="995eb-149">Pour prendre en charge les cas extrêmes de types qui dérivent de <xref:System.Threading.Tasks.Task> et de <xref:System.Threading.Tasks.Task%601>, et pour prendre en charge la séparation de la construction et de la planification, la classe <xref:System.Threading.Tasks.Task> expose une méthode <xref:System.Threading.Tasks.Task.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="995eb-149">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="995eb-150">Les tâches créées par les constructeurs <xref:System.Threading.Tasks.Task> publics sont connues sous le nom de *tâches passives*, car elles démarrent leur cycle de vie dans l'état <xref:System.Threading.Tasks.TaskStatus.Created> non planifié et sont planifiées uniquement quand la méthode <xref:System.Threading.Tasks.Task.Start%2A> est appelée sur ces instances.</span><span class="sxs-lookup"><span data-stu-id="995eb-150">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span>

 <span data-ttu-id="995eb-151">Toutes les autres tâches démarrent leur cycle de vie dans un état réactif, ce qui signifie que les opérations asynchrones qu’elles représentent ont déjà été initialisées et que leur état de tâche est une valeur d’énumération autre que <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="995eb-151">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="995eb-152">Toutes les tâches qui sont retournées par les méthodes TAP doivent être activées.</span><span class="sxs-lookup"><span data-stu-id="995eb-152">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="995eb-153">**Si une méthode TAP utilise en interne le constructeur d’une tâche pour instancier la tâche à retourner, la méthode TAP doit appeler <xref:System.Threading.Tasks.Task.Start%2A> sur l’objet <xref:System.Threading.Tasks.Task> avant de la retourner.**</span><span class="sxs-lookup"><span data-stu-id="995eb-153">**If a TAP method internally uses a task’s constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="995eb-154">Les consommateurs d’une méthode TAP peuvent sans risque supposer que la tâche retournée est active et ne doivent pas essayer d’appeler la méthode <xref:System.Threading.Tasks.Task.Start%2A> sur une <xref:System.Threading.Tasks.Task> qui est retournée à partir d’une méthode TAP.</span><span class="sxs-lookup"><span data-stu-id="995eb-154">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="995eb-155">L'appel de la méthode <xref:System.Threading.Tasks.Task.Start%2A> sur une tâche active entraîne la levée d'une exception <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="995eb-155">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="995eb-156">Annulation (facultatif)</span><span class="sxs-lookup"><span data-stu-id="995eb-156">Cancellation (optional)</span></span>  
 <span data-ttu-id="995eb-157">Dans le TAP, l'annulation est facultative pour les implémenteurs de méthodes asynchrones et les consommateurs de méthodes asynchrones.</span><span class="sxs-lookup"><span data-stu-id="995eb-157">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="995eb-158">Si une opération autorise l'annulation, elle expose une surcharge de la méthode asynchrone qui accepte un jeton d'annulation (instance de <xref:System.Threading.CancellationToken>).</span><span class="sxs-lookup"><span data-stu-id="995eb-158">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="995eb-159">Par convention, le paramètre est nommé `cancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="995eb-159">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="995eb-160">L'opération asynchrone surveille ce jeton en cas de demandes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="995eb-160">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="995eb-161">Si elle reçoit une demande d'annulation, elle peut choisir d'honorer cette demande et d'annuler l'opération.</span><span class="sxs-lookup"><span data-stu-id="995eb-161">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="995eb-162">Si la demande d’annulation provoque l’arrêt prématuré du travail, la méthode TAP retourne une tâche qui se termine dans l’état <xref:System.Threading.Tasks.TaskStatus.Canceled> ; il n’existe aucun résultat disponible et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="995eb-162">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="995eb-163">L’état <xref:System.Threading.Tasks.TaskStatus.Canceled> est considéré comme un état final (terminé) pour une tâche, il en est de même pour les états <xref:System.Threading.Tasks.TaskStatus.Faulted> et <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span><span class="sxs-lookup"><span data-stu-id="995eb-163">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="995eb-164">Par conséquent, si une tâche est dans l'état <xref:System.Threading.Tasks.TaskStatus.Canceled>, sa propriété <xref:System.Threading.Tasks.Task.IsCompleted%2A> retourne la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="995eb-164">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="995eb-165">Lorsqu'une tâche se termine dans l'état <xref:System.Threading.Tasks.TaskStatus.Canceled>, toutes les continuations enregistrées avec la tâche sont planifiées ou exécutées, sauf si une option de continuation telle que <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> a été spécifiée pour quitter la continuation.</span><span class="sxs-lookup"><span data-stu-id="995eb-165">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="995eb-166">Tout code qui attend de façon asynchrone une tâche annulée via l'utilisation de fonctionnalités de langage continue de s'exécuter mais reçoit une exception <xref:System.OperationCanceledException> ou une exception qui en dérive.</span><span class="sxs-lookup"><span data-stu-id="995eb-166">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="995eb-167">Le code qui est bloqué de manière synchrone en attendant la tâche via des méthodes telles que <xref:System.Threading.Tasks.Task.Wait%2A> et <xref:System.Threading.Tasks.Task.WaitAll%2A> continue également de s’exécuter avec une exception.</span><span class="sxs-lookup"><span data-stu-id="995eb-167">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="995eb-168">Si un jeton d’annulation a demandé l’annulation avant que la méthode TAP qui accepte le jeton ne soit appelée, la méthode TAP doit retourner une tâche <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span><span class="sxs-lookup"><span data-stu-id="995eb-168">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="995eb-169">Toutefois, si l'annulation est demandée alors que l'opération asynchrone est en cours d'exécution, l'opération asynchrone n'a pas besoin d'accepter la demande d'annulation.</span><span class="sxs-lookup"><span data-stu-id="995eb-169">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="995eb-170">La tâche retournée doit se terminer dans l’état <xref:System.Threading.Tasks.TaskStatus.Canceled> uniquement si l’opération se termine à la suite de la demande d’annulation.</span><span class="sxs-lookup"><span data-stu-id="995eb-170">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="995eb-171">Si l'annulation est demandée mais qu'un résultat (ou une exception) est tout de même produit, la tâche doit se terminer dans l'état <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> ou <xref:System.Threading.Tasks.TaskStatus.Faulted>.</span><span class="sxs-lookup"><span data-stu-id="995eb-171">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span>

 <span data-ttu-id="995eb-172">Pour les méthodes asynchrones souhaitant exposer la capacité d’annulation en priorité, vous ne devez pas fournir de surcharge n'acceptant pas de jeton d'annulation.</span><span class="sxs-lookup"><span data-stu-id="995eb-172">For asynchronous methods that want to expose the ability to be cancelled first and foremost, you don't have to provide an overload that doesn’t accept a cancellation token.</span></span> <span data-ttu-id="995eb-173">Pour les méthodes qui ne peuvent pas être annulées, ne fournissez aucune surcharge acceptant un jeton d'annulation ; cela permet d'indiquer à l'appelant si la méthode cible est réellement annulable ou non.</span><span class="sxs-lookup"><span data-stu-id="995eb-173">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="995eb-174">Le code de consommateur qui ne souhaite pas l’annulation peut appeler une méthode qui accepte un <xref:System.Threading.CancellationToken> et fournit <xref:System.Threading.CancellationToken.None%2A> comme valeur d’argument.</span><span class="sxs-lookup"><span data-stu-id="995eb-174">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="995eb-175"><xref:System.Threading.CancellationToken.None%2A> est fonctionnellement équivalent au <xref:System.Threading.CancellationToken> par défaut.</span><span class="sxs-lookup"><span data-stu-id="995eb-175"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="995eb-176">Rapport de progression (facultatif)</span><span class="sxs-lookup"><span data-stu-id="995eb-176">Progress reporting (optional)</span></span>  
 <span data-ttu-id="995eb-177">Certaines opérations asynchrones tirent parti de la fourniture de notifications de progression ; elles sont généralement utilisées pour mettre à jour une interface utilisateur avec des informations sur la progression de l'opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="995eb-177">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span>

 <span data-ttu-id="995eb-178">Dans le TAP, la progression est gérée via une interface <xref:System.IProgress%601>, qui est passée à la méthode asynchrone en tant que paramètre généralement nommé `progress`.</span><span class="sxs-lookup"><span data-stu-id="995eb-178">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="995eb-179">Le fait de fournir l'interface de progression lorsque la méthode asynchrone est appelée aide à éliminer les conditions de concurrence qui résultent d'une utilisation incorrecte (autrement dit, lorsque les gestionnaires d'événements enregistrés de façon incorrecte après le démarrage de l'opération sont susceptibles de manquer des mises à jour).</span><span class="sxs-lookup"><span data-stu-id="995eb-179">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="995eb-180">Plus important encore, l'interface de progression prend en charge diverses implémentations de progression, comme indiqué par le code de consommation.</span><span class="sxs-lookup"><span data-stu-id="995eb-180">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="995eb-181">Par exemple, le code de consommation peut uniquement s’intéresser à la dernière mise à jour de la progression, ou peut vouloir mettre en mémoire tampon toutes les mises à jour, ou peut vouloir appeler une action pour chaque mise à jour, ou peut vouloir vérifier si l’appel est marshalé à un thread particulier.</span><span class="sxs-lookup"><span data-stu-id="995eb-181">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="995eb-182">Toutes ces options peuvent être réalisées en utilisant une implémentation différente de l'interface, personnalisée en fonction des besoins particuliers du consommateur.</span><span class="sxs-lookup"><span data-stu-id="995eb-182">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer’s needs.</span></span>  <span data-ttu-id="995eb-183">Comme pour l'annulation, les implémentations du TAP doivent fournir un paramètre <xref:System.IProgress%601> uniquement si l'API prend en charge les notifications de progression.</span><span class="sxs-lookup"><span data-stu-id="995eb-183">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span>

 <span data-ttu-id="995eb-184">Par exemple, si la méthode `ReadAsync` décrite précédemment dans cet article peut indiquer la progression intermédiaire sous la forme du nombre d'octets lus jusqu'ici, le rappel de progression peut être une interface <xref:System.IProgress%601> :</span><span class="sxs-lookup"><span data-stu-id="995eb-184">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="995eb-185">Si une méthode `FindFilesAsync` retourne une liste de tous les fichiers qui rencontrent un modèle de recherche spécifique, le rappel de progression peut fournir une estimation du pourcentage de travail effectué ainsi que de l’ensemble actuel des résultats partiels.</span><span class="sxs-lookup"><span data-stu-id="995eb-185">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed as well as the current set of partial results.</span></span>  <span data-ttu-id="995eb-186">Elle peut effectuer ceci avec un tuple :</span><span class="sxs-lookup"><span data-stu-id="995eb-186">It could do this either with a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="995eb-187">ou avec un type de données spécifique à l'API :</span><span class="sxs-lookup"><span data-stu-id="995eb-187">or with a data type that is specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="995eb-188">Dans le second cas, le type de données particulier possède généralement le suffixe `ProgressInfo`.</span><span class="sxs-lookup"><span data-stu-id="995eb-188">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="995eb-189">Si les implémentations du TAP fournissent des surcharges qui acceptent un paramètre `progress`, elles doivent permettre à l’argument d’être `null`, dans ce cas aucune progression ne sera signalée.</span><span class="sxs-lookup"><span data-stu-id="995eb-189">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress will be reported.</span></span> <span data-ttu-id="995eb-190">Les implémentations du TAP doivent signaler la progression vers l’objet <xref:System.Progress%601> de façon synchrone, ce qui permet à la méthode asynchrone de fournir rapidement la progression, et permettre au consommateur de la progression de déterminer où et comment gérer les informations.</span><span class="sxs-lookup"><span data-stu-id="995eb-190">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress, and allow the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="995eb-191">Par exemple, l'instance de progression peut choisir de marshaler les rappels et de déclencher des événements dans un contexte de synchronisation capturé.</span><span class="sxs-lookup"><span data-stu-id="995eb-191">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="995eb-192">Implémentations IProgress\<T></span><span class="sxs-lookup"><span data-stu-id="995eb-192">IProgress\<T> implementations</span></span>  
 <span data-ttu-id="995eb-193">.NET Framework 4.5 fournit une implémentation unique de <xref:System.IProgress%601> : <xref:System.Progress%601>.</span><span class="sxs-lookup"><span data-stu-id="995eb-193">The .NET Framework 4.5 provides a single <xref:System.IProgress%601> implementation: <xref:System.Progress%601>.</span></span> <span data-ttu-id="995eb-194">La classe <xref:System.Progress%601> est déclarée comme suit :</span><span class="sxs-lookup"><span data-stu-id="995eb-194">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T> ProgressChanged;  
}  
```  
  
```vb  
Public Class Progress(Of T) : Inherits IProgress(Of T)  
    Public Sub New()  
    Public Sub New(handler As Action(Of T))  
    Protected Overridable Sub OnReport(value As T)  
    Public Event ProgressChanged As EventHandler(Of T>  
End Class  
```  
  
 <span data-ttu-id="995eb-195">Une instance de <xref:System.Progress%601> expose un événement <xref:System.Progress%601.ProgressChanged>, qui est déclenché chaque fois que l'opération asynchrone signale une mise à jour de la progression.</span><span class="sxs-lookup"><span data-stu-id="995eb-195">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="995eb-196">L'événement <xref:System.Progress%601.ProgressChanged> est déclenché sur l'objet <xref:System.Threading.SynchronizationContext> qui a été capturé lorsque l'instance de <xref:System.Progress%601> a été instanciée.</span><span class="sxs-lookup"><span data-stu-id="995eb-196">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="995eb-197">Si aucun contexte de synchronisation n’est disponible, un contexte par défaut qui cible le pool de threads est utilisé.</span><span class="sxs-lookup"><span data-stu-id="995eb-197">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="995eb-198">Les gestionnaires peuvent être enregistrés avec cet événement.</span><span class="sxs-lookup"><span data-stu-id="995eb-198">Handlers may be registered with this event.</span></span> <span data-ttu-id="995eb-199">Un gestionnaire unique peut également être fourni au constructeur <xref:System.Progress%601> pour des raisons pratiques, et se comporter comme un gestionnaire d'événements pour l'événement <xref:System.Progress%601.ProgressChanged>.</span><span class="sxs-lookup"><span data-stu-id="995eb-199">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="995eb-200">Les mises à jour de progression sont déclenchées de façon asynchrone afin d'éviter de différer l'opération asynchrone alors que les gestionnaires d'événements s'exécutent.</span><span class="sxs-lookup"><span data-stu-id="995eb-200">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="995eb-201">Une autre implémentation de <xref:System.IProgress%601> peut choisir d'appliquer une sémantique différente.</span><span class="sxs-lookup"><span data-stu-id="995eb-201">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="995eb-202">Choisir les surcharges à fournir</span><span class="sxs-lookup"><span data-stu-id="995eb-202">Choosing the overloads to provide</span></span>  
 <span data-ttu-id="995eb-203">Si une implémentation du TAP utilise des paramètres facultatifs <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> et <xref:System.IProgress%601>, elle est susceptible de nécessiter jusqu'à quatre surcharges :</span><span class="sxs-lookup"><span data-stu-id="995eb-203">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="995eb-204">Toutefois, plusieurs implémentations du TAP ne fournissent ni capacité d'annulation ni capacité de progression, elles requièrent donc une méthode unique :</span><span class="sxs-lookup"><span data-stu-id="995eb-204">However, many TAP implementations provide neither cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="995eb-205">Si une implémentation du TAP prend en charge l'annulation ou la progression, mais pas les deux, elle peut fournir deux surcharges :</span><span class="sxs-lookup"><span data-stu-id="995eb-205">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="995eb-206">Si une implémentation du TAP prend en charge l'annulation et la progression, elle peut exposer les quatre surcharges.</span><span class="sxs-lookup"><span data-stu-id="995eb-206">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="995eb-207">Toutefois, elle peut fournir uniquement les deux suivantes :</span><span class="sxs-lookup"><span data-stu-id="995eb-207">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="995eb-208">Pour compenser les deux combinaisons intermédiaires manquantes, les développeurs peuvent passer <xref:System.Threading.CancellationToken.None%2A> ou un <xref:System.Threading.CancellationToken> par défaut pour le paramètre `cancellationToken` et la valeur `null` pour le paramètre `progress`.</span><span class="sxs-lookup"><span data-stu-id="995eb-208">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="995eb-209">Si vous vous attendez à ce que chaque utilisation de la méthode TAP prenne en charge l'annulation ou la progression, vous pouvez omettre les surcharges qui n'acceptent pas le paramètre approprié.</span><span class="sxs-lookup"><span data-stu-id="995eb-209">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don’t accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="995eb-210">Si vous décidez d'exposer plusieurs surcharges pour rendre l'annulation ou la progression facultative, les surcharges qui ne prennent pas en charge l'annulation ou la progression doivent se comporter comme si elles passaient <xref:System.Threading.CancellationToken.None%2A> pour l'annulation ou `null` pour la progression à la surcharge qui ne prend pas en charge ces dernières.</span><span class="sxs-lookup"><span data-stu-id="995eb-210">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don’t support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="995eb-211">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="995eb-211">Related topics</span></span>  
  
|<span data-ttu-id="995eb-212">Titre</span><span class="sxs-lookup"><span data-stu-id="995eb-212">Title</span></span>|<span data-ttu-id="995eb-213">Description</span><span class="sxs-lookup"><span data-stu-id="995eb-213">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="995eb-214">Modèles de programmation asynchrone</span><span class="sxs-lookup"><span data-stu-id="995eb-214">Asynchronous Programming Patterns</span></span>](../../../docs/standard/asynchronous-programming-patterns/index.md)|<span data-ttu-id="995eb-215">Présente les trois modèles permettant d'effectuer des opérations asynchrones : le modèle asynchrone basé sur des tâches (TAP), le modèle de programmation asynchrone (APM) et le modèle asynchrone basé sur des événements (EAP).</span><span class="sxs-lookup"><span data-stu-id="995eb-215">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="995eb-216">Implémentation du modèle asynchrone basé sur des tâches</span><span class="sxs-lookup"><span data-stu-id="995eb-216">Implementing the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="995eb-217">Décrit comment implémenter le modèle asynchrone basé sur des tâches (TAP) de trois façons : à l'aide des compilateurs C# et Visual Basic dans Visual Studio, manuellement, ou par une combinaison des méthodes du compilateur et des méthodes manuelles.</span><span class="sxs-lookup"><span data-stu-id="995eb-217">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="995eb-218">Utilisation du modèle asynchrone basé sur les tâches</span><span class="sxs-lookup"><span data-stu-id="995eb-218">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="995eb-219">Décrit comment utiliser des tâches et des rappels afin de terminer l’attente sans blocage.</span><span class="sxs-lookup"><span data-stu-id="995eb-219">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="995eb-220">Interopérabilité avec d’autres types et modèles asynchrones</span><span class="sxs-lookup"><span data-stu-id="995eb-220">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="995eb-221">Décrit comment utiliser le modèle asynchrone basé sur des tâches (TAP) pour implémenter le modèle de programmation asynchrone (APM) et le modèle asynchrone basé sur des événements (EAP).</span><span class="sxs-lookup"><span data-stu-id="995eb-221">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
