---
title: Implémentation du modèle asynchrone basé sur des tâches
description: Cet article explique comment implémenter le modèle asynchrone basé sur des tâches. Vous pouvez l’utiliser pour implémenter des opérations asynchrones liées aux calculs et aux e/s.
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- asynchronous design patterns, .NET
- TAP, .NET support for
- Task-based Asynchronous Pattern, .NET support for
- .NET, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: 8bac9d265211d2f266db634d4bcebb87c2debd9a
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/28/2020
ms.locfileid: "92888774"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="6f9b6-104">Implémentation du modèle asynchrone basé sur des tâches</span><span class="sxs-lookup"><span data-stu-id="6f9b6-104">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="6f9b6-105">Vous pouvez implémenter le modèle asynchrone basé sur des tâches (TAP) de trois façons : à l’aide des compilateurs C# et Visual Basic dans Visual Studio, manuellement, ou par une combinaison des méthodes du compilateur et des méthodes manuelles.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-105">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="6f9b6-106">Les sections suivantes abordent chacune de ces méthodes en détail.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-106">The following sections discuss each method in detail.</span></span> <span data-ttu-id="6f9b6-107">Vous pouvez utiliser le modèle TAP pour implémenter à la fois des opérations asynchrones liées aux calculs et liées aux E/S.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-107">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="6f9b6-108">La section [Charges de travail](#workloads) aborde chacun des types d'opérations.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-108">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="6f9b6-109">Génération de méthodes TAP</span><span class="sxs-lookup"><span data-stu-id="6f9b6-109">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="6f9b6-110">Utilisation des compilateurs</span><span class="sxs-lookup"><span data-stu-id="6f9b6-110">Using the compilers</span></span>
<span data-ttu-id="6f9b6-111">À partir de .NET Framework 4.5, toute méthode attribuée avec le mot clé `async` (`Async` en Visual Basic) est considérée comme une méthode asynchrone. Les compilateurs C# et Visual Basic effectuent alors les transformations nécessaires pour implémenter la méthode de façon asynchrone à l’aide du modèle TAP.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-111">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="6f9b6-112">Une méthode asynchrone doit retourner un objet <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-112">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="6f9b6-113">Dans le dernier cas, le corps de la fonction doit retourner un `TResult`. Le compilateur garantit ensuite que ce résultat est rendu disponible via l’objet de tâche qui en résulte.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-113">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="6f9b6-114">De même, toutes les exceptions non gérées dans le corps de la méthode sont marshalées vers la tâche de sortie et provoquent la fin de la tâche résultante avec l’état <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-114">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="6f9b6-115">L’exception à cette règle se produit lorsqu’un <xref:System.OperationCanceledException> (ou un type dérivé) n’est pas géré, auquel cas la tâche obtenue se termine dans l' <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> État.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-115">The exception to this rule is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="6f9b6-116">Génération manuelle des méthodes TAP</span><span class="sxs-lookup"><span data-stu-id="6f9b6-116">Generating TAP methods manually</span></span>
<span data-ttu-id="6f9b6-117">Vous pouvez implémenter le modèle TAP manuellement pour mieux contrôler l'implémentation.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-117">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="6f9b6-118">Le compilateur s'appuie sur la surface publique exposée depuis l'espace de noms <xref:System.Threading.Tasks?displayProperty=nameWithType> et sur les types de prise en charge de l'espace de noms <xref:System.Runtime.CompilerServices?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-118">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="6f9b6-119">Pour implémenter le modèle TAP vous-même, créez un objet <xref:System.Threading.Tasks.TaskCompletionSource%601>, effectuez l'opération asynchrone, et lorsqu'elle est terminée, appelez la méthode <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> ou <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, ou bien la version `Try` de l'une de ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-119">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="6f9b6-120">Quand vous implémentez une méthode TAP manuellement, vous devez achever la tâche qui en résulte quand l’opération asynchrone représentée se termine.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-120">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="6f9b6-121">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="6f9b6-121">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="6f9b6-122">Approche hybride</span><span class="sxs-lookup"><span data-stu-id="6f9b6-122">Hybrid approach</span></span>
 <span data-ttu-id="6f9b6-123">Il peut s’avérer utile d’implémenter le modèle TAP manuellement pour déléguer la logique de base de l’implémentation du compilateur.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-123">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="6f9b6-124">Par exemple, vous souhaiterez peut-être utiliser l’approche hybride lorsque vous souhaitez vérifier des arguments en dehors d’une méthode asynchrone générée par le compilateur afin que les exceptions puissent échapper à l’appelant direct de la méthode au lieu d’être exposées via l' <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> objet :</span><span class="sxs-lookup"><span data-stu-id="6f9b6-124">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method's direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="6f9b6-125">La délégation est également utile quand vous implémentez une optimisation de chemin d'accès rapide et souhaitez retourner une tâche mise en cache.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-125">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="6f9b6-126">Charges de travail</span><span class="sxs-lookup"><span data-stu-id="6f9b6-126">Workloads</span></span>
<span data-ttu-id="6f9b6-127">Vous pouvez implémenter des opérations asynchrones liées aux calculs et liées aux E/S en tant que méthodes TAP.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-127">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="6f9b6-128">Toutefois, quand des méthodes TAP sont exposées publiquement depuis une bibliothèque, elles doivent uniquement être fournies pour les charges de travail qui impliquent des opérations d'E/S (elles peuvent également impliquer des calculs, mais ne doivent pas consister uniquement de calculs).</span><span class="sxs-lookup"><span data-stu-id="6f9b6-128">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="6f9b6-129">Si une méthode est entièrement liée aux calculs, elle doit uniquement être exposée en tant qu’implémentation synchrone.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-129">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="6f9b6-130">Le code qui la consomme peut alors décider s'il faut encapsuler un appel à cette méthode synchrone dans une tâche pour décharger le travail vers un autre thread ou pour atteindre un parallélisme.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-130">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="6f9b6-131">En revanche, si une méthode est liée aux E/S, elle doit uniquement être exposée en tant qu’implémentation asynchrone.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-131">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="6f9b6-132">Tâches liées aux calculs</span><span class="sxs-lookup"><span data-stu-id="6f9b6-132">Compute-bound tasks</span></span>
<span data-ttu-id="6f9b6-133">La classe <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> convient parfaitement aux opérations de calcul intensives.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-133">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="6f9b6-134">Par défaut, elle tire parti de la prise en charge spéciale de la classe <xref:System.Threading.ThreadPool> pour assurer une exécution efficace. Elle permet également de contrôler de manière précise le moment, l'endroit et la manière dont sont exécutés les calculs asynchrones.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-134">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="6f9b6-135">Vous pouvez générer des tâches liées au calcul de la manière suivante :</span><span class="sxs-lookup"><span data-stu-id="6f9b6-135">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="6f9b6-136">Dans .NET Framework 4,5 et versions ultérieures (y compris .NET Core et .NET 5 +), utilisez la <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> méthode statique en tant que raccourci vers <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="6f9b6-136">In .NET Framework 4.5 and later versions (including .NET Core and .NET 5+), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6f9b6-137">Vous pouvez utiliser <xref:System.Threading.Tasks.Task.Run%2A> pour lancer facilement une tâche liée aux calculs qui cible le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-137">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="6f9b6-138">Il s’agit du mécanisme préféré pour lancer une tâche liée au calcul.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-138">This is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="6f9b6-139">`StartNew` ne doit s'utiliser directement que quand vous souhaitez contrôler la tâche de manière plus précise.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-139">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="6f9b6-140">Dans .NET Framework 4, utilisez la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> méthode, qui accepte un délégué (en général un <xref:System.Action%601> ou un <xref:System.Func%601> ) à exécuter de manière asynchrone.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-140">In .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="6f9b6-141">Si vous fournissez un délégué <xref:System.Action%601>, la méthode retourne un objet <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> qui représente l'exécution asynchrone de ce délégué.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-141">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="6f9b6-142">Si vous fournissez un délégué <xref:System.Func%601>, la méthode retourne un objet <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-142">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="6f9b6-143">Les surcharges de la méthode <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> acceptent un jeton d’annulation, (<xref:System.Threading.CancellationToken>), des options de création de tâche (<xref:System.Threading.Tasks.TaskCreationOptions>) et un planificateur de tâches (<xref:System.Threading.Tasks.TaskScheduler>) qui permettent un contrôle précis de la planification et de l’exécution de la tâche.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-143">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="6f9b6-144">Une instance de fabrique qui cible le planificateur de tâches actuel est disponible sous la forme d’une propriété statique (<xref:System.Threading.Tasks.Task.Factory%2A>) de la classe<xref:System.Threading.Tasks.Task>, par exemple `Task.Factory.StartNew(…)`.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-144">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="6f9b6-145">Utilisez les constructeurs du type `Task` ou de la méthode `Start` pour générer et planifier la tâche séparément.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-145">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="6f9b6-146">Les méthodes publiques doivent retourner uniquement les tâches qui ont déjà été lancées.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-146">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="6f9b6-147">Utilisez les surcharges de la méthode <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-147">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6f9b6-148">Cette méthode crée une nouvelle tâche qui est planifiée quand l’exécution d’une autre tâche se termine.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-148">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="6f9b6-149">Certaines surcharges <xref:System.Threading.Tasks.Task.ContinueWith%2A> acceptent un jeton d’annulation, des options de continuation et un planificateur de tâches pour un meilleur contrôle de la planification et de l’exécution de la tâche de continuation.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-149">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="6f9b6-150">Utilisez les méthodes <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> et <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-150">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="6f9b6-151">Ces méthodes créent une nouvelle tâche qui est planifiée quand une partie ou l’intégralité d’un ensemble de tâches fourni se termine.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-151">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="6f9b6-152">Ces méthodes fournissent également des surcharges permettant de contrôler la planification et l’exécution de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-152">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="6f9b6-153">Dans les tâches liées aux calculs, le système peut empêcher l'exécution d'une tâche planifiée s'il reçoit une demande d'annulation avant l'exécution de la tâche.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-153">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="6f9b6-154">Par conséquent, si vous fournissez un jeton d'annulation (un objet <xref:System.Threading.CancellationToken>), vous pouvez passer ce jeton au code asynchrone qui surveille le jeton.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-154">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="6f9b6-155">Vous pouvez également fournir le jeton pour l'une des méthodes mentionnées précédemment telles que `StartNew` ou `Run`, pour que le runtime `Task` puisse également surveiller le jeton.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-155">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="6f9b6-156">Prenons, par exemple, une méthode asynchrone qui génère le rendu d'une image.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-156">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="6f9b6-157">Le corps de la tâche peut interroger le jeton d’annulation pour que l’exécution du code puisse s’arrêter plus tôt si une demande d’annulation arrive pendant le rendu.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-157">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="6f9b6-158">De plus, si la demande d'annulation arrive avant le début du rendu, vous pourrez empêcher l'opération de rendu :</span><span class="sxs-lookup"><span data-stu-id="6f9b6-158">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="6f9b6-159">Les tâches liées aux calculs se terminent avec l’état <xref:System.Threading.Tasks.TaskStatus.Canceled> si au moins l’une des conditions suivantes est remplie :</span><span class="sxs-lookup"><span data-stu-id="6f9b6-159">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="6f9b6-160">Une demande d’annulation arrive via l’objet <xref:System.Threading.CancellationToken>, qui est fourni en tant qu’argument à la méthode de création (par exemple, `StartNew` ou `Run`) avant que la tâche ne passe à l’état <xref:System.Threading.Tasks.TaskStatus.Running>.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-160">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="6f9b6-161">Une exception <xref:System.OperationCanceledException> n’est pas gérée dans le corps d’une telle tâche. Cette exception contient le même <xref:System.Threading.CancellationToken> qui est passé à la tâche et ce jeton indique qu’une annulation a été demandée.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-161">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="6f9b6-162">Si une autre exception n’est pas gérée dans le corps de la tâche, la tâche se termine avec l’état <xref:System.Threading.Tasks.TaskStatus.Faulted>, et toute tentative d’attendre la tâche ou d’accéder à son résultat provoque la levée d’une exception.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-162">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="6f9b6-163">Tâches d’E/S</span><span class="sxs-lookup"><span data-stu-id="6f9b6-163">I/O-bound tasks</span></span>
<span data-ttu-id="6f9b6-164">Pour créer une tâche qui ne doit pas être sauvegardée directement par un thread pour l’intégralité de son exécution, utilisez le type <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-164">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="6f9b6-165">Ce type expose une propriété <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> qui retourne une instance <xref:System.Threading.Tasks.Task%601> associée.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-165">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="6f9b6-166">Le cycle de vie de cette tâche est contrôlé par les méthodes <xref:System.Threading.Tasks.TaskCompletionSource%601> telles que <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> et <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, et leurs variantes `TrySet`.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-166">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="6f9b6-167">Supposons que vous vouliez créer une tâche devant se terminer après une période spécifiée.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-167">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="6f9b6-168">Par exemple, vous pouvez vouloir différer une activité dans l'interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-168">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="6f9b6-169">La classe <xref:System.Threading.Timer?displayProperty=nameWithType> fournit déjà la possibilité d'appeler un délégué de façon asynchrone après une période donnée, et grâce à <xref:System.Threading.Tasks.TaskCompletionSource%601>, vous pouvez ajouter un <xref:System.Threading.Tasks.Task%601> au minuteur, par exemple :</span><span class="sxs-lookup"><span data-stu-id="6f9b6-169">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="6f9b6-170">La <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> méthode est fournie à cet effet, et vous pouvez l’utiliser dans une autre méthode asynchrone, par exemple pour implémenter une boucle d’interrogation asynchrone :</span><span class="sxs-lookup"><span data-stu-id="6f9b6-170">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="6f9b6-171">La classe <xref:System.Threading.Tasks.TaskCompletionSource%601> ne possède pas d'équivalent non générique.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-171">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="6f9b6-172">Toutefois, <xref:System.Threading.Tasks.Task%601> dérive de <xref:System.Threading.Tasks.Task>. Vous pouvez donc utiliser l’objet <xref:System.Threading.Tasks.TaskCompletionSource%601> générique pour les méthodes d’E/S qui ne font que retourner une tâche.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-172">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="6f9b6-173">Pour ce faire, vous pouvez utiliser une source avec un `TResult` factice (<xref:System.Boolean> est un bon choix par défaut, mais si vous avez peur que l'utilisateur de la <xref:System.Threading.Tasks.Task> en fasse une classe de base <xref:System.Threading.Tasks.Task%601>, vous pouvez utiliser un type `TResult` privé à la place).</span><span class="sxs-lookup"><span data-stu-id="6f9b6-173">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="6f9b6-174">Par exemple, la méthode `Delay` de l'exemple précédent retourne l'heure actuelle, ainsi que le décalage résultant (`Task<DateTimeOffset>`).</span><span class="sxs-lookup"><span data-stu-id="6f9b6-174">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="6f9b6-175">Si une telle valeur n'est pas nécessaire, la méthode peut être codée comme suit (notez le changement du type de retour et le remplacement de l'argument par <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>) :</span><span class="sxs-lookup"><span data-stu-id="6f9b6-175">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="6f9b6-176">Tâches à la fois liées aux calculs et aux E/S</span><span class="sxs-lookup"><span data-stu-id="6f9b6-176">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="6f9b6-177">Les méthodes asynchrones peuvent comprendre à la fois des opérations de calcul et d'E/S.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-177">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="6f9b6-178">En réalité, les opérations asynchrones sont souvent combinées au sein de plus grandes opérations mixtes.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-178">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="6f9b6-179">Par exemple, la méthode `RenderAsync` de l'exemple précédent permettait d'exécuter une opération de calcul intensive pour restituer une image basée sur des `imageData` d'entrée.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-179">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="6f9b6-180">Ces `imageData` peuvent provenir d'un service web auquel vous pouvez accéder de manière asynchrone :</span><span class="sxs-lookup"><span data-stu-id="6f9b6-180">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="6f9b6-181">Cet exemple montre également comment un jeton d'annulation peut être associé à un thread par l'intermédiaire de plusieurs opérations asynchrones.</span><span class="sxs-lookup"><span data-stu-id="6f9b6-181">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="6f9b6-182">Pour plus d’informations, consultez la section relative à l’annulation dans [Utilisation du modèle asynchrone basé sur les tâches](consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="6f9b6-182">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="6f9b6-183">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="6f9b6-183">See also</span></span>

- [<span data-ttu-id="6f9b6-184">Modèle asynchrone basé sur les tâches (TAP, Task-based Asynchronous Pattern)</span><span class="sxs-lookup"><span data-stu-id="6f9b6-184">Task-based Asynchronous Pattern (TAP)</span></span>](task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="6f9b6-185">Utilisation du modèle asynchrone basé sur les tâches</span><span class="sxs-lookup"><span data-stu-id="6f9b6-185">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="6f9b6-186">Interopérabilité avec d’autres types et modèles asynchrones</span><span class="sxs-lookup"><span data-stu-id="6f9b6-186">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)
