---
title: Implémentation du modèle asynchrone basé sur des tâches
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: e09ed853598dcbb13cc8dc3fe963276e4b5e974d
ms.sourcegitcommit: 465547886a1224a5435c3ac349c805e39ce77706
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/21/2020
ms.locfileid: "81739649"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="486e6-102">Implémentation du modèle asynchrone basé sur des tâches</span><span class="sxs-lookup"><span data-stu-id="486e6-102">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="486e6-103">Vous pouvez implémenter le modèle asynchrone basé sur des tâches (TAP) de trois façons : à l’aide des compilateurs C# et Visual Basic dans Visual Studio, manuellement, ou par une combinaison des méthodes du compilateur et des méthodes manuelles.</span><span class="sxs-lookup"><span data-stu-id="486e6-103">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="486e6-104">Les sections suivantes abordent chacune de ces méthodes en détail.</span><span class="sxs-lookup"><span data-stu-id="486e6-104">The following sections discuss each method in detail.</span></span> <span data-ttu-id="486e6-105">Vous pouvez utiliser le modèle TAP pour implémenter à la fois des opérations asynchrones liées aux calculs et liées aux E/S.</span><span class="sxs-lookup"><span data-stu-id="486e6-105">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="486e6-106">La section [Charges de travail](#workloads) aborde chacun des types d'opérations.</span><span class="sxs-lookup"><span data-stu-id="486e6-106">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="486e6-107">Génération de méthodes TAP</span><span class="sxs-lookup"><span data-stu-id="486e6-107">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="486e6-108">Utilisation des compilateurs</span><span class="sxs-lookup"><span data-stu-id="486e6-108">Using the compilers</span></span>
<span data-ttu-id="486e6-109">À partir de .NET Framework 4.5, toute méthode attribuée avec le mot clé `async` (`Async` en Visual Basic) est considérée comme une méthode asynchrone. Les compilateurs C# et Visual Basic effectuent alors les transformations nécessaires pour implémenter la méthode de façon asynchrone à l’aide du modèle TAP.</span><span class="sxs-lookup"><span data-stu-id="486e6-109">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="486e6-110">Une méthode asynchrone doit retourner un objet <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="486e6-110">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="486e6-111">Dans le dernier cas, le corps de la fonction doit retourner un `TResult`. Le compilateur garantit ensuite que ce résultat est rendu disponible via l’objet de tâche qui en résulte.</span><span class="sxs-lookup"><span data-stu-id="486e6-111">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="486e6-112">De même, toutes les exceptions non gérées dans le corps de la méthode sont marshalées vers la tâche de sortie et provoquent la fin de la tâche résultante avec l’état <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="486e6-112">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="486e6-113">L’exception à cette <xref:System.OperationCanceledException> règle est lorsqu’un (ou type dérivé) n’est <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> pas géré, auquel cas la tâche qui en résulte se termine dans l’état.</span><span class="sxs-lookup"><span data-stu-id="486e6-113">The exception to this rule is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="486e6-114">Génération manuelle des méthodes TAP</span><span class="sxs-lookup"><span data-stu-id="486e6-114">Generating TAP methods manually</span></span>
<span data-ttu-id="486e6-115">Vous pouvez implémenter le modèle TAP manuellement pour mieux contrôler l'implémentation.</span><span class="sxs-lookup"><span data-stu-id="486e6-115">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="486e6-116">Le compilateur s'appuie sur la surface publique exposée depuis l'espace de noms <xref:System.Threading.Tasks?displayProperty=nameWithType> et sur les types de prise en charge de l'espace de noms <xref:System.Runtime.CompilerServices?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="486e6-116">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="486e6-117">Pour implémenter le modèle TAP vous-même, créez un objet <xref:System.Threading.Tasks.TaskCompletionSource%601>, effectuez l'opération asynchrone, et lorsqu'elle est terminée, appelez la méthode <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> ou <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, ou bien la version `Try` de l'une de ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="486e6-117">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="486e6-118">Quand vous implémentez une méthode TAP manuellement, vous devez achever la tâche qui en résulte quand l’opération asynchrone représentée se termine.</span><span class="sxs-lookup"><span data-stu-id="486e6-118">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="486e6-119">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="486e6-119">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="486e6-120">Approche hybride</span><span class="sxs-lookup"><span data-stu-id="486e6-120">Hybrid approach</span></span>
 <span data-ttu-id="486e6-121">Il peut s’avérer utile d’implémenter le modèle TAP manuellement pour déléguer la logique de base de l’implémentation du compilateur.</span><span class="sxs-lookup"><span data-stu-id="486e6-121">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="486e6-122">Par exemple, vous pouvez utiliser l’approche hybride pour vérifier des arguments en dehors d’une méthode asynchrone générée par le compilateur, pour que les exceptions puissent être échappées vers l’appelant direct de la méthode, plutôt que d’être exposées par un objet <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="486e6-122">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method’s direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="486e6-123">La délégation est également utile quand vous implémentez une optimisation de chemin d'accès rapide et souhaitez retourner une tâche mise en cache.</span><span class="sxs-lookup"><span data-stu-id="486e6-123">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="486e6-124">Charges de travail</span><span class="sxs-lookup"><span data-stu-id="486e6-124">Workloads</span></span>
<span data-ttu-id="486e6-125">Vous pouvez implémenter des opérations asynchrones liées aux calculs et liées aux E/S en tant que méthodes TAP.</span><span class="sxs-lookup"><span data-stu-id="486e6-125">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="486e6-126">Toutefois, quand des méthodes TAP sont exposées publiquement depuis une bibliothèque, elles doivent uniquement être fournies pour les charges de travail qui impliquent des opérations d'E/S (elles peuvent également impliquer des calculs, mais ne doivent pas consister uniquement de calculs).</span><span class="sxs-lookup"><span data-stu-id="486e6-126">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="486e6-127">Si une méthode est entièrement liée aux calculs, elle doit uniquement être exposée en tant qu’implémentation synchrone.</span><span class="sxs-lookup"><span data-stu-id="486e6-127">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="486e6-128">Le code qui la consomme peut alors décider s'il faut encapsuler un appel à cette méthode synchrone dans une tâche pour décharger le travail vers un autre thread ou pour atteindre un parallélisme.</span><span class="sxs-lookup"><span data-stu-id="486e6-128">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="486e6-129">En revanche, si une méthode est liée aux E/S, elle doit uniquement être exposée en tant qu’implémentation asynchrone.</span><span class="sxs-lookup"><span data-stu-id="486e6-129">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="486e6-130">Tâches liées aux calculs</span><span class="sxs-lookup"><span data-stu-id="486e6-130">Compute-bound tasks</span></span>
<span data-ttu-id="486e6-131">La classe <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> convient parfaitement aux opérations de calcul intensives.</span><span class="sxs-lookup"><span data-stu-id="486e6-131">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="486e6-132">Par défaut, elle tire parti de la prise en charge spéciale de la classe <xref:System.Threading.ThreadPool> pour assurer une exécution efficace. Elle permet également de contrôler de manière précise le moment, l'endroit et la manière dont sont exécutés les calculs asynchrones.</span><span class="sxs-lookup"><span data-stu-id="486e6-132">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="486e6-133">Vous pouvez générer des tâches liées au calcul de la manière suivante :</span><span class="sxs-lookup"><span data-stu-id="486e6-133">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="486e6-134">Dans le .NET Framework 4, utilisez la méthode <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> qui accepte un délégué (en général un <xref:System.Action%601> ou un <xref:System.Func%601>) devant être exécuté de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="486e6-134">In the .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="486e6-135">Si vous fournissez un délégué <xref:System.Action%601>, la méthode retourne un objet <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> qui représente l'exécution asynchrone de ce délégué.</span><span class="sxs-lookup"><span data-stu-id="486e6-135">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="486e6-136">Si vous fournissez un délégué <xref:System.Func%601>, la méthode retourne un objet <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="486e6-136">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="486e6-137">Les surcharges de la méthode <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> acceptent un jeton d’annulation, (<xref:System.Threading.CancellationToken>), des options de création de tâche (<xref:System.Threading.Tasks.TaskCreationOptions>) et un planificateur de tâches (<xref:System.Threading.Tasks.TaskScheduler>) qui permettent un contrôle précis de la planification et de l’exécution de la tâche.</span><span class="sxs-lookup"><span data-stu-id="486e6-137">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="486e6-138">Une instance de fabrique qui cible le planificateur de tâches actuel est disponible sous la forme d’une propriété statique (<xref:System.Threading.Tasks.Task.Factory%2A>) de la classe<xref:System.Threading.Tasks.Task>, par exemple `Task.Factory.StartNew(…)`.</span><span class="sxs-lookup"><span data-stu-id="486e6-138">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="486e6-139">Dans .NET Framework 4.5 et versions ultérieures (notamment .NET Core et .NET Standard), utilisez la méthode statique <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> en tant que raccourci vers <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="486e6-139">In the .NET Framework 4.5 and later versions (including .NET Core and .NET Standard), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="486e6-140">Vous pouvez utiliser <xref:System.Threading.Tasks.Task.Run%2A> pour lancer facilement une tâche liée aux calculs qui cible le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="486e6-140">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="486e6-141">Dans .NET Framework 4.5 et versions ultérieures, il s’agit du moyen privilégié de lancer une tâche liée aux calculs.</span><span class="sxs-lookup"><span data-stu-id="486e6-141">In the .NET Framework 4.5 and later versions, this is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="486e6-142">`StartNew` ne doit s'utiliser directement que quand vous souhaitez contrôler la tâche de manière plus précise.</span><span class="sxs-lookup"><span data-stu-id="486e6-142">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="486e6-143">Utilisez les constructeurs du type `Task` ou de la méthode `Start` pour générer et planifier la tâche séparément.</span><span class="sxs-lookup"><span data-stu-id="486e6-143">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="486e6-144">Les méthodes publiques doivent retourner uniquement les tâches qui ont déjà été lancées.</span><span class="sxs-lookup"><span data-stu-id="486e6-144">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="486e6-145">Utilisez les surcharges de la méthode <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="486e6-145">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="486e6-146">Cette méthode crée une nouvelle tâche qui est planifiée quand l’exécution d’une autre tâche se termine.</span><span class="sxs-lookup"><span data-stu-id="486e6-146">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="486e6-147">Certaines surcharges <xref:System.Threading.Tasks.Task.ContinueWith%2A> acceptent un jeton d’annulation, des options de continuation et un planificateur de tâches pour un meilleur contrôle de la planification et de l’exécution de la tâche de continuation.</span><span class="sxs-lookup"><span data-stu-id="486e6-147">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="486e6-148">Utilisez les méthodes <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> et <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="486e6-148">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="486e6-149">Ces méthodes créent une nouvelle tâche qui est planifiée quand une partie ou l’intégralité d’un ensemble de tâches fourni se termine.</span><span class="sxs-lookup"><span data-stu-id="486e6-149">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="486e6-150">Ces méthodes fournissent également des surcharges permettant de contrôler la planification et l’exécution de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="486e6-150">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="486e6-151">Dans les tâches liées aux calculs, le système peut empêcher l'exécution d'une tâche planifiée s'il reçoit une demande d'annulation avant l'exécution de la tâche.</span><span class="sxs-lookup"><span data-stu-id="486e6-151">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="486e6-152">Par conséquent, si vous fournissez un jeton d'annulation (un objet <xref:System.Threading.CancellationToken>), vous pouvez passer ce jeton au code asynchrone qui surveille le jeton.</span><span class="sxs-lookup"><span data-stu-id="486e6-152">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="486e6-153">Vous pouvez également fournir le jeton pour l'une des méthodes mentionnées précédemment telles que `StartNew` ou `Run`, pour que le runtime `Task` puisse également surveiller le jeton.</span><span class="sxs-lookup"><span data-stu-id="486e6-153">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="486e6-154">Prenons, par exemple, une méthode asynchrone qui génère le rendu d'une image.</span><span class="sxs-lookup"><span data-stu-id="486e6-154">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="486e6-155">Le corps de la tâche peut interroger le jeton d’annulation pour que l’exécution du code puisse s’arrêter plus tôt si une demande d’annulation arrive pendant le rendu.</span><span class="sxs-lookup"><span data-stu-id="486e6-155">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="486e6-156">De plus, si la demande d'annulation arrive avant le début du rendu, vous pourrez empêcher l'opération de rendu :</span><span class="sxs-lookup"><span data-stu-id="486e6-156">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="486e6-157">Les tâches liées aux calculs se terminent avec l’état <xref:System.Threading.Tasks.TaskStatus.Canceled> si au moins l’une des conditions suivantes est remplie :</span><span class="sxs-lookup"><span data-stu-id="486e6-157">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="486e6-158">Une demande d’annulation arrive via l’objet <xref:System.Threading.CancellationToken>, qui est fourni en tant qu’argument à la méthode de création (par exemple, `StartNew` ou `Run`) avant que la tâche ne passe à l’état <xref:System.Threading.Tasks.TaskStatus.Running>.</span><span class="sxs-lookup"><span data-stu-id="486e6-158">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="486e6-159">Une exception <xref:System.OperationCanceledException> n’est pas gérée dans le corps d’une telle tâche. Cette exception contient le même <xref:System.Threading.CancellationToken> qui est passé à la tâche et ce jeton indique qu’une annulation a été demandée.</span><span class="sxs-lookup"><span data-stu-id="486e6-159">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="486e6-160">Si une autre exception n’est pas gérée dans le corps de la tâche, la tâche se termine avec l’état <xref:System.Threading.Tasks.TaskStatus.Faulted>, et toute tentative d’attendre la tâche ou d’accéder à son résultat provoque la levée d’une exception.</span><span class="sxs-lookup"><span data-stu-id="486e6-160">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="486e6-161">Tâches d’E/S</span><span class="sxs-lookup"><span data-stu-id="486e6-161">I/O-bound tasks</span></span>
<span data-ttu-id="486e6-162">Pour créer une tâche qui ne doit pas être sauvegardée directement par un thread pour l’intégralité de son exécution, utilisez le type <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="486e6-162">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="486e6-163">Ce type expose une propriété <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> qui retourne une instance <xref:System.Threading.Tasks.Task%601> associée.</span><span class="sxs-lookup"><span data-stu-id="486e6-163">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="486e6-164">Le cycle de vie de cette tâche est contrôlé par les méthodes <xref:System.Threading.Tasks.TaskCompletionSource%601> telles que <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> et <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, et leurs variantes `TrySet`.</span><span class="sxs-lookup"><span data-stu-id="486e6-164">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="486e6-165">Supposons que vous vouliez créer une tâche devant se terminer après une période spécifiée.</span><span class="sxs-lookup"><span data-stu-id="486e6-165">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="486e6-166">Par exemple, vous pouvez vouloir différer une activité dans l'interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="486e6-166">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="486e6-167">La classe <xref:System.Threading.Timer?displayProperty=nameWithType> fournit déjà la possibilité d'appeler un délégué de façon asynchrone après une période donnée, et grâce à <xref:System.Threading.Tasks.TaskCompletionSource%601>, vous pouvez ajouter un <xref:System.Threading.Tasks.Task%601> au minuteur, par exemple :</span><span class="sxs-lookup"><span data-stu-id="486e6-167">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="486e6-168">Depuis .NET Framework 4.5, la méthode <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> est fournie à cet effet et peut être utilisée dans une autre méthode asynchrone, par exemple pour implémenter une boucle d’interrogation asynchrone :</span><span class="sxs-lookup"><span data-stu-id="486e6-168">Starting with the .NET Framework 4.5, the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="486e6-169">La classe <xref:System.Threading.Tasks.TaskCompletionSource%601> ne possède pas d'équivalent non générique.</span><span class="sxs-lookup"><span data-stu-id="486e6-169">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="486e6-170">Toutefois, <xref:System.Threading.Tasks.Task%601> dérive de <xref:System.Threading.Tasks.Task>. Vous pouvez donc utiliser l’objet <xref:System.Threading.Tasks.TaskCompletionSource%601> générique pour les méthodes d’E/S qui ne font que retourner une tâche.</span><span class="sxs-lookup"><span data-stu-id="486e6-170">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="486e6-171">Pour ce faire, vous pouvez utiliser une source avec un `TResult` factice (<xref:System.Boolean> est un bon choix par défaut, mais si vous avez peur que l'utilisateur de la <xref:System.Threading.Tasks.Task> en fasse une classe de base <xref:System.Threading.Tasks.Task%601>, vous pouvez utiliser un type `TResult` privé à la place).</span><span class="sxs-lookup"><span data-stu-id="486e6-171">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="486e6-172">Par exemple, la méthode `Delay` de l'exemple précédent retourne l'heure actuelle, ainsi que le décalage résultant (`Task<DateTimeOffset>`).</span><span class="sxs-lookup"><span data-stu-id="486e6-172">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="486e6-173">Si une telle valeur n'est pas nécessaire, la méthode peut être codée comme suit (notez le changement du type de retour et le remplacement de l'argument par <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>) :</span><span class="sxs-lookup"><span data-stu-id="486e6-173">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="486e6-174">Tâches à la fois liées aux calculs et aux E/S</span><span class="sxs-lookup"><span data-stu-id="486e6-174">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="486e6-175">Les méthodes asynchrones peuvent comprendre à la fois des opérations de calcul et d'E/S.</span><span class="sxs-lookup"><span data-stu-id="486e6-175">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="486e6-176">En réalité, les opérations asynchrones sont souvent combinées au sein de plus grandes opérations mixtes.</span><span class="sxs-lookup"><span data-stu-id="486e6-176">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="486e6-177">Par exemple, la méthode `RenderAsync` de l'exemple précédent permettait d'exécuter une opération de calcul intensive pour restituer une image basée sur des `imageData` d'entrée.</span><span class="sxs-lookup"><span data-stu-id="486e6-177">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="486e6-178">Ces `imageData` peuvent provenir d'un service web auquel vous pouvez accéder de manière asynchrone :</span><span class="sxs-lookup"><span data-stu-id="486e6-178">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="486e6-179">Cet exemple montre également comment un jeton d'annulation peut être associé à un thread par l'intermédiaire de plusieurs opérations asynchrones.</span><span class="sxs-lookup"><span data-stu-id="486e6-179">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="486e6-180">Pour plus d’informations, consultez la section relative à l’annulation dans [Utilisation du modèle asynchrone basé sur les tâches](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="486e6-180">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="486e6-181">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="486e6-181">See also</span></span>

- [<span data-ttu-id="486e6-182">Modèle asynchrone basé sur les tâches (TAP, Task-based Asynchronous Pattern)</span><span class="sxs-lookup"><span data-stu-id="486e6-182">Task-based Asynchronous Pattern (TAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="486e6-183">Consuming the Task-based Asynchronous Pattern</span><span class="sxs-lookup"><span data-stu-id="486e6-183">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="486e6-184">Interopérabilité avec d’autres types et modèles asynchrones</span><span class="sxs-lookup"><span data-stu-id="486e6-184">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)
