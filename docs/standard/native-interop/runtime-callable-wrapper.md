---
title: Wrapper pouvant être appelé par le runtime
description: Le CLR expose des objets COM via un wrapper pouvant être appelé par le runtime, qui gère les appels entre un client .NET et un objet COM.
ms.date: 03/30/2017
helpviewer_keywords:
- COM interop, COM wrappers
- RCW
- COM wrappers
- runtime callable wrappers
- interoperation with unmanaged code, COM wrappers
ms.assetid: 7e542583-1e31-4e10-b523-8cf2f29cb4a4
ms.openlocfilehash: 6868c79791d960dd1ae55ab09d4ac3b40ce52655
ms.sourcegitcommit: 9a4488a3625866335e83a20da5e9c5286b1f034c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/15/2020
ms.locfileid: "83420485"
---
# <a name="runtime-callable-wrapper"></a><span data-ttu-id="02be9-103">Wrapper pouvant être appelé par le runtime</span><span class="sxs-lookup"><span data-stu-id="02be9-103">Runtime Callable Wrapper</span></span>
<span data-ttu-id="02be9-104">Le common language runtime expose les objets COM via un proxy appelé wrapper RCW.</span><span class="sxs-lookup"><span data-stu-id="02be9-104">The common language runtime exposes COM objects through a proxy called the runtime callable wrapper (RCW).</span></span> <span data-ttu-id="02be9-105">Même si le wrapper RCW est un objet ordinaire pour les clients .NET, sa fonction principale est de marshaler les appels entre un client .NET et un objet COM.</span><span class="sxs-lookup"><span data-stu-id="02be9-105">Although the RCW appears to be an ordinary object to .NET clients, its primary function is to marshal calls between a .NET client and a COM object.</span></span>  
  
 <span data-ttu-id="02be9-106">Le runtime crée un wrapper RCW pour chaque objet COM, quel que soit le nombre de références qui existent sur cet objet.</span><span class="sxs-lookup"><span data-stu-id="02be9-106">The runtime creates exactly one RCW for each COM object, regardless of the number of references that exist on that object.</span></span> <span data-ttu-id="02be9-107">Le runtime gère un seul wrapper RCW par processus pour chaque objet.</span><span class="sxs-lookup"><span data-stu-id="02be9-107">The runtime maintains a single RCW per process for each object.</span></span>  <span data-ttu-id="02be9-108">Si vous créez un wrapper RCW dans un domaine d'application ou cloisonnement, puis passez une référence à un autre domaine d'application ou cloisonnement, un proxy du premier objet sera utilisé.</span><span class="sxs-lookup"><span data-stu-id="02be9-108">If you create an RCW in one application domain or apartment, and then pass a reference to another application domain or apartment, a proxy to the first object will be used.</span></span>  <span data-ttu-id="02be9-109">Comme le montre l'illustration suivante, il n'existe pas de limite au nombre de clients managés pouvant contenir une référence aux objets COM qui exposent les interfaces INew et INewer.</span><span class="sxs-lookup"><span data-stu-id="02be9-109">As the following illustration shows, any number of managed clients can hold a reference to the COM objects that expose INew and INewer interfaces.</span></span>  

<span data-ttu-id="02be9-110">L’image suivante montre le processus d’accès aux objets COM par le biais du wrapper RCW :</span><span class="sxs-lookup"><span data-stu-id="02be9-110">The following image shows the process for accessing COM objects through the runtime callable wrapper:</span></span>

 ![Processus d’accès aux objets COM par le biais du wrapper RCW.](./media/runtime-callable-wrapper/runtime-callable-wrapper.gif)  

 <span data-ttu-id="02be9-112">À l'aide de métadonnées dérivées d'une bibliothèque de types, le runtime crée l'objet COM appelé, ainsi qu'un wrapper pour celui-ci.</span><span class="sxs-lookup"><span data-stu-id="02be9-112">Using metadata derived from a type library, the runtime creates both the COM object being called and a wrapper for that object.</span></span> <span data-ttu-id="02be9-113">Chaque wrapper RCW gère un cache de pointeurs d'interface sur l'objet COM qu'il encapsule et libère sa référence à l'objet COM quand le wrapper RCW n'est plus utile.</span><span class="sxs-lookup"><span data-stu-id="02be9-113">Each RCW maintains a cache of interface pointers on the COM object it wraps and releases its reference on the COM object when the RCW is no longer needed.</span></span> <span data-ttu-id="02be9-114">Le runtime exécute le garbage collection du wrapper RCW.</span><span class="sxs-lookup"><span data-stu-id="02be9-114">The runtime performs garbage collection on the RCW.</span></span>  
  
 <span data-ttu-id="02be9-115">Entre autres activités, le wrapper RCW marshale les données entre code managé et non managé, pour le compte de l’objet encapsulé.</span><span class="sxs-lookup"><span data-stu-id="02be9-115">Among other activities, the RCW marshals data between managed and unmanaged code, on behalf of the wrapped object.</span></span> <span data-ttu-id="02be9-116">Plus précisément, le wrapper RCW fournit le marshaling pour les arguments de méthode et les valeurs de retour de méthode chaque fois que le client et le serveur ont des représentations différentes des données circulant entre eux.</span><span class="sxs-lookup"><span data-stu-id="02be9-116">Specifically, the RCW provides marshaling for method arguments and method return values whenever the client and server have different representations of the data passed between them.</span></span>  
  
 <span data-ttu-id="02be9-117">Le wrapper standard applique les règles de marshaling intégrées.</span><span class="sxs-lookup"><span data-stu-id="02be9-117">The standard wrapper enforces built-in marshaling rules.</span></span> <span data-ttu-id="02be9-118">Par exemple, quand un client .NET passe un type String dans le cadre d’un argument à un objet non managé, le wrapper convertit la chaîne en un type BSTR.</span><span class="sxs-lookup"><span data-stu-id="02be9-118">For example, when a .NET client passes a String type as part of an argument to an unmanaged object, the wrapper converts the string to a BSTR type.</span></span> <span data-ttu-id="02be9-119">Si l'objet COM retourne un BSTR à son appelant managé, l'appelant reçoit une chaîne (String).</span><span class="sxs-lookup"><span data-stu-id="02be9-119">Should the COM object return a BSTR to its managed caller, the caller receives a String.</span></span> <span data-ttu-id="02be9-120">Le client et le serveur envoient et reçoivent des données qui leur sont familières.</span><span class="sxs-lookup"><span data-stu-id="02be9-120">Both the client and the server send and receive data that is familiar to them.</span></span> <span data-ttu-id="02be9-121">Les autres types ne nécessitent pas de conversion.</span><span class="sxs-lookup"><span data-stu-id="02be9-121">Other types require no conversion.</span></span> <span data-ttu-id="02be9-122">Par exemple, un wrapper standard passera toujours un entier de 4 octets d'un code managé à un code non managé sans convertir le type.</span><span class="sxs-lookup"><span data-stu-id="02be9-122">For instance, a standard wrapper will always pass a 4-byte integer between managed and unmanaged code without converting the type.</span></span>  
  
## <a name="marshaling-selected-interfaces"></a><span data-ttu-id="02be9-123">Marshaling d’interfaces sélectionnées</span><span class="sxs-lookup"><span data-stu-id="02be9-123">Marshaling selected interfaces</span></span>  
 <span data-ttu-id="02be9-124">L’objectif principal du [wrapper RCW](runtime-callable-wrapper.md) est de masquer les différences entre les modèles de programmation managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="02be9-124">The primary goal of the [runtime callable wrapper](runtime-callable-wrapper.md) (RCW) is to hide the differences between the managed and unmanaged programming models.</span></span> <span data-ttu-id="02be9-125">Pour créer une transition transparente, le wrapper RCW consomme les interfaces COM sélectionnées sans les exposer au client .NET, comme indiqué dans l'illustration suivante.</span><span class="sxs-lookup"><span data-stu-id="02be9-125">To create a seamless transition, the RCW consumes selected COM interfaces without exposing them to the .NET client, as shown in the following illustration.</span></span>

 <span data-ttu-id="02be9-126">L’image suivante montre les interfaces COM et le wrapper RCW :</span><span class="sxs-lookup"><span data-stu-id="02be9-126">The following image shows COM interfaces and the runtime callable wrapper:</span></span>
  
 ![Capture d’écran du wrapper RCW avec des interfaces.](./media/runtime-callable-wrapper/runtime-callable-wrapper-interfaces.gif)  
  
 <span data-ttu-id="02be9-128">Quand il est créé comme un objet à liaison anticipée, le wrapper RCW est un type spécifique.</span><span class="sxs-lookup"><span data-stu-id="02be9-128">When created as an early-bound object, the RCW is a specific type.</span></span> <span data-ttu-id="02be9-129">Il implémente les interfaces que l'objet COM implémente et expose les méthodes, les propriétés et les événements des interfaces de l'objet.</span><span class="sxs-lookup"><span data-stu-id="02be9-129">It implements the interfaces that the COM object implements and exposes the methods, properties, and events from the object's interfaces.</span></span> <span data-ttu-id="02be9-130">Dans l’illustration, le wrapper RCW expose l’interface INew, mais consomme les interfaces **IUnknown** et **IDispatch**.</span><span class="sxs-lookup"><span data-stu-id="02be9-130">In the illustration, the RCW exposes the INew interface but consumes the **IUnknown** and **IDispatch** interfaces.</span></span> <span data-ttu-id="02be9-131">De plus, le wrapper RCW expose tous les membres de l'interface INew au client .NET.</span><span class="sxs-lookup"><span data-stu-id="02be9-131">Further, the RCW exposes all members of the INew interface to the .NET client.</span></span>  
  
 <span data-ttu-id="02be9-132">Le wrapper RCW consomme les interfaces répertoriées dans le tableau suivant, qui sont exposées par l'objet qu'il encapsule.</span><span class="sxs-lookup"><span data-stu-id="02be9-132">The RCW consumes the interfaces listed in the following table, which are exposed by the object it wraps.</span></span>  
  
|<span data-ttu-id="02be9-133">Interface</span><span class="sxs-lookup"><span data-stu-id="02be9-133">Interface</span></span>|<span data-ttu-id="02be9-134">Description</span><span class="sxs-lookup"><span data-stu-id="02be9-134">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="02be9-135">**IDispatch**</span><span class="sxs-lookup"><span data-stu-id="02be9-135">**IDispatch**</span></span>|<span data-ttu-id="02be9-136">Pour la liaison tardive aux objets COM via la réflexion.</span><span class="sxs-lookup"><span data-stu-id="02be9-136">For late binding to COM objects through reflection.</span></span>|  
|<span data-ttu-id="02be9-137">**IErrorInfo**</span><span class="sxs-lookup"><span data-stu-id="02be9-137">**IErrorInfo**</span></span>|<span data-ttu-id="02be9-138">Fournit une description textuelle de l’erreur, sa source, un fichier d’aide, un contexte d’aide et le GUID de l’interface ayant défini l’erreur (toujours **GUID_NULL** pour les classes .NET).</span><span class="sxs-lookup"><span data-stu-id="02be9-138">Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always **GUID_NULL** for .NET classes).</span></span>|  
|<span data-ttu-id="02be9-139">**IProvideClassInfo**</span><span class="sxs-lookup"><span data-stu-id="02be9-139">**IProvideClassInfo**</span></span>|<span data-ttu-id="02be9-140">Si l’objet COM qui est encapsulé implémente **IProvideClassInfo**, le wrapper RCW extrait les informations de type à partir de cette interface pour fournir une meilleure identité de type.</span><span class="sxs-lookup"><span data-stu-id="02be9-140">If the COM object being wrapped implements **IProvideClassInfo**, the RCW extracts the type information from this interface to provide better type identity.</span></span>|  
|<span data-ttu-id="02be9-141">**IUnknown**</span><span class="sxs-lookup"><span data-stu-id="02be9-141">**IUnknown**</span></span>|<span data-ttu-id="02be9-142">Pour l'identité de l'objet, le forçage de type et la gestion de la durée de vie :</span><span class="sxs-lookup"><span data-stu-id="02be9-142">For object identity, type coercion, and lifetime management:</span></span><br /><br /> <span data-ttu-id="02be9-143">- Identité d’un objet</span><span class="sxs-lookup"><span data-stu-id="02be9-143">-   Object identity</span></span><br />     <span data-ttu-id="02be9-144">Le runtime fait la distinction entre les objets COM en comparant la valeur d’interface **IUnknown** pour chaque objet.</span><span class="sxs-lookup"><span data-stu-id="02be9-144">The runtime distinguishes between COM objects by comparing the value of the **IUnknown** interface for each object.</span></span><br /><span data-ttu-id="02be9-145">- Forçage de type</span><span class="sxs-lookup"><span data-stu-id="02be9-145">-   Type coercion</span></span><br />     <span data-ttu-id="02be9-146">Le wrapper RCW reconnaît la découverte de type dynamique exécutée par la méthode **QueryInterface**.</span><span class="sxs-lookup"><span data-stu-id="02be9-146">The RCW recognizes the dynamic type discovery performed by the **QueryInterface** method.</span></span><br /><span data-ttu-id="02be9-147">- Gestion de la durée de vie</span><span class="sxs-lookup"><span data-stu-id="02be9-147">-   Lifetime management</span></span><br />     <span data-ttu-id="02be9-148">À l’aide de la méthode **QueryInterface**, le wrapper RCW obtient et conserve une référence à un objet non managé jusqu’à ce que le runtime exécute le garbage collection sur le wrapper, qui libère l’objet non managé.</span><span class="sxs-lookup"><span data-stu-id="02be9-148">Using the **QueryInterface** method, the RCW gets and holds a reference to an unmanaged object until the runtime performs garbage collection on the wrapper, which releases the unmanaged object.</span></span>|  
  
 <span data-ttu-id="02be9-149">Le wrapper RCW peut éventuellement consommer les interfaces répertoriées dans le tableau suivant, qui sont exposées par l'objet qu'il encapsule.</span><span class="sxs-lookup"><span data-stu-id="02be9-149">The RCW optionally consumes the interfaces listed in the following table, which are exposed by the object it wraps.</span></span>  
  
|<span data-ttu-id="02be9-150">Interface</span><span class="sxs-lookup"><span data-stu-id="02be9-150">Interface</span></span>|<span data-ttu-id="02be9-151">Description</span><span class="sxs-lookup"><span data-stu-id="02be9-151">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="02be9-152">**IConnectionPoint** et **IConnectionPointContainer**</span><span class="sxs-lookup"><span data-stu-id="02be9-152">**IConnectionPoint** and **IConnectionPointContainer**</span></span>|<span data-ttu-id="02be9-153">Le wrapper RCW convertit les objets qui exposent le style d'événement point de connexion en événements basés sur le délégué.</span><span class="sxs-lookup"><span data-stu-id="02be9-153">The RCW converts objects that expose the connection-point event style to delegate-based events.</span></span>|  
|<span data-ttu-id="02be9-154">**IDispatchEx** (.NET Framework uniquement)</span><span class="sxs-lookup"><span data-stu-id="02be9-154">**IDispatchEx** (.NET Framework Only)</span></span> |<span data-ttu-id="02be9-155">Si la classe implémente **IDispatchEx**, le wrapper RCW implémente **IExpando**.</span><span class="sxs-lookup"><span data-stu-id="02be9-155">If the class implements **IDispatchEx**, the RCW implements **IExpando**.</span></span> <span data-ttu-id="02be9-156">L’interface **IDispatchEx** est une extension de l’interface **IDispatch** qui, contrairement à l’interface **IDispatch**, permet l’énumération, l’ajout, la suppression et l’appel de la casse des membres.</span><span class="sxs-lookup"><span data-stu-id="02be9-156">The **IDispatchEx** interface is an extension of the **IDispatch** interface that, unlike **IDispatch**, enables enumeration, addition, deletion, and case-sensitive calling of members.</span></span>|  
|<span data-ttu-id="02be9-157">**IEnumVARIANT**</span><span class="sxs-lookup"><span data-stu-id="02be9-157">**IEnumVARIANT**</span></span>|<span data-ttu-id="02be9-158">Permet aux types COM qui prennent en charge les énumérations d'être traités comme des collections.</span><span class="sxs-lookup"><span data-stu-id="02be9-158">Enables COM types that support enumerations to be treated as collections.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="02be9-159">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="02be9-159">See also</span></span>

- [<span data-ttu-id="02be9-160">Wrappers COM</span><span class="sxs-lookup"><span data-stu-id="02be9-160">COM Wrappers</span></span>](com-wrappers.md)
- [<span data-ttu-id="02be9-161">Wrapper CCW (COM Callable Wrapper)</span><span class="sxs-lookup"><span data-stu-id="02be9-161">COM Callable Wrapper</span></span>](com-callable-wrapper.md)
- <span data-ttu-id="02be9-162">[Récapitulatif de la conversion d’une bibliothèque de types en assembly](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/k83zzh38(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="02be9-162">[Type Library to Assembly Conversion Summary](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/k83zzh38(v=vs.100))</span></span>
- [<span data-ttu-id="02be9-163">Importation d'une bibliothèque de types sous la forme d'un assembly</span><span class="sxs-lookup"><span data-stu-id="02be9-163">Importing a Type Library as an Assembly</span></span>](../../framework/interop/importing-a-type-library-as-an-assembly.md)
