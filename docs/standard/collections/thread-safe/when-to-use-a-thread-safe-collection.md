---
title: Quand utiliser une collection thread-safe
description: Savoir quand utiliser une collection thread-safe dans .NET. Cinq types de collection sont spécialement conçus pour prendre en charge les opérations d’ajout & de suppression multithread.
ms.date: 03/30/2017
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: ab1d4d436ce833af94e7eaba35943e499a047a05
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95725064"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="602d8-104">Quand utiliser une collection thread-safe</span><span class="sxs-lookup"><span data-stu-id="602d8-104">When to use a thread-safe collection</span></span>

<span data-ttu-id="602d8-105">.NET Framework 4 a introduit cinq types de collection spécialement conçus pour prendre en charge les opérations d’ajout et de suppression multithread.</span><span class="sxs-lookup"><span data-stu-id="602d8-105">.NET Framework 4 introduced five collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="602d8-106">Pour assurer la sécurité des threads, ces types utilisent différents types de mécanismes de verrouillage et de synchronisation sans verrou efficaces.</span><span class="sxs-lookup"><span data-stu-id="602d8-106">To achieve thread-safety, these types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="602d8-107">La synchronisation ajoute une surcharge à une opération.</span><span class="sxs-lookup"><span data-stu-id="602d8-107">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="602d8-108">La quantité de la surcharge dépend du genre de synchronisation utilisé, du genre d’opérations exécutées et d’autres facteurs tels que le nombre de threads qui tentent d’accéder simultanément à la collection.</span><span class="sxs-lookup"><span data-stu-id="602d8-108">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="602d8-109">Dans certains scénarios, la surcharge de synchronisation est négligeable et permet au type multithread de s’exécuter beaucoup plus rapidement et d’évoluer beaucoup mieux que son équivalent qui n’est pas thread-safe quand il est protégé par un verrou externe.</span><span class="sxs-lookup"><span data-stu-id="602d8-109">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="602d8-110">Dans d’autres scénarios, la surcharge peut entraîner une exécution et une scalabilité du type thread-safe à peu près identiques, ou même plus lentes, que celles de la version du type qui n’est pas thread-safe et qui est verrouillée de manière externe.</span><span class="sxs-lookup"><span data-stu-id="602d8-110">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="602d8-111">Les sections suivantes fournissent des recommandations générales concernant le moment où utiliser une collection thread-safe ou son équivalent non thread-safe qui a un verrou fourni par l’utilisateur autour de ses opérations de lecture et d’écriture.</span><span class="sxs-lookup"><span data-stu-id="602d8-111">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="602d8-112">Étant donné que les performances peuvent varier en fonction de nombreux facteurs, ces recommandations ne sont pas spécifiques et ne sont pas nécessairement valables dans toutes les circonstances.</span><span class="sxs-lookup"><span data-stu-id="602d8-112">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="602d8-113">Si les performances sont très importantes, la meilleure façon de déterminer le type de collection à utiliser consiste à mesurer les performances en fonction de configurations et de charges d’ordinateur représentatives.</span><span class="sxs-lookup"><span data-stu-id="602d8-113">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="602d8-114">Ce document utilise les termes suivants :</span><span class="sxs-lookup"><span data-stu-id="602d8-114">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="602d8-115">*Scénario producteur-consommateur pur*</span><span class="sxs-lookup"><span data-stu-id="602d8-115">*Pure producer-consumer scenario*</span></span>\
 <span data-ttu-id="602d8-116">Tout thread donné ajoute ou supprime des éléments, mais pas les deux.</span><span class="sxs-lookup"><span data-stu-id="602d8-116">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="602d8-117">*Scénario producteur-consommateur mixte*</span><span class="sxs-lookup"><span data-stu-id="602d8-117">*Mixed producer-consumer scenario*</span></span>\
 <span data-ttu-id="602d8-118">Tout thread donné ajoute et supprime des éléments.</span><span class="sxs-lookup"><span data-stu-id="602d8-118">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="602d8-119">*Accélération*</span><span class="sxs-lookup"><span data-stu-id="602d8-119">*Speedup*</span></span>\
 <span data-ttu-id="602d8-120">Performances algorithmiques plus rapides par rapport à un autre type dans le même scénario.</span><span class="sxs-lookup"><span data-stu-id="602d8-120">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="602d8-121">*Extensibilité*</span><span class="sxs-lookup"><span data-stu-id="602d8-121">*Scalability*</span></span>\
 <span data-ttu-id="602d8-122">Augmentation des performances proportionnelle au nombre de cœurs de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="602d8-122">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="602d8-123">Un algorithme évolutif s’exécute plus vite sur huit cœurs que sur deux cœurs.</span><span class="sxs-lookup"><span data-stu-id="602d8-123">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="602d8-124">ConcurrentQueue (T) vs. queue (T)</span><span class="sxs-lookup"><span data-stu-id="602d8-124">ConcurrentQueue(T) vs. Queue(T)</span></span>  

 <span data-ttu-id="602d8-125">Dans les scénarios producteur-consommateur purs, où le temps de traitement de chaque élément est très court (quelques instructions), <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> peut offrir des avantages modestes en matière de performances par rapport à un <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> qui a un verrou externe.</span><span class="sxs-lookup"><span data-stu-id="602d8-125">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="602d8-126">Dans ce scénario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> fonctionne mieux quand un thread dédié effectue la mise en file d’attente et qu’un autre thread dédié annule la mise en file d’attente.</span><span class="sxs-lookup"><span data-stu-id="602d8-126">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="602d8-127">Si vous n’appliquez pas cette règle, <xref:System.Collections.Generic.Queue%601> peut même s’exécuter légèrement plus rapidement que <xref:System.Collections.Concurrent.ConcurrentQueue%601> sur les ordinateurs à plusieurs cœurs.</span><span class="sxs-lookup"><span data-stu-id="602d8-127">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="602d8-128">Quand le temps de traitement est autour de 500 opérations en virgule flottante (FLOPS), ou plus, la règle de deux threads ne s’applique pas à <xref:System.Collections.Concurrent.ConcurrentQueue%601>, qui possède alors une très bonne scalabilité.</span><span class="sxs-lookup"><span data-stu-id="602d8-128">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="602d8-129"><xref:System.Collections.Generic.Queue%601> n’évolue pas bien dans ce scénario.</span><span class="sxs-lookup"><span data-stu-id="602d8-129"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="602d8-130">Dans les scénarios producteur-consommateur mixtes, quand le temps de traitement est très court, un <xref:System.Collections.Generic.Queue%601> qui a un externe verrou évolue mieux que <xref:System.Collections.Concurrent.ConcurrentQueue%601>.</span><span class="sxs-lookup"><span data-stu-id="602d8-130">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="602d8-131">Toutefois, quand le temps de traitement est autour de 500 opérations en virgule flottante (FLOPS), ou plus, <xref:System.Collections.Concurrent.ConcurrentQueue%601> évolue mieux.</span><span class="sxs-lookup"><span data-stu-id="602d8-131">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="602d8-132">ConcurrentStack et pile</span><span class="sxs-lookup"><span data-stu-id="602d8-132">ConcurrentStack vs. Stack</span></span>  

 <span data-ttu-id="602d8-133">Dans les scénarios producteur-consommateur purs, quand le temps de traitement est très court, <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> et <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> qui a un verrou externe s’exécuteront probablement de la même manière avec un thread d’exécution de type push dédié et un thread d’exécution de type pop dédié.</span><span class="sxs-lookup"><span data-stu-id="602d8-133">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="602d8-134">Toutefois, à mesure que le nombre de threads augmente, les deux types ralentissent à cause de l’augmentation des conflits, et <xref:System.Collections.Generic.Stack%601> peut fonctionner mieux que <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span><span class="sxs-lookup"><span data-stu-id="602d8-134">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="602d8-135">Quand le temps de traitement est autour de 500 opérations en virgule flottante (FLOPS), ou plus, les deux types évoluent à peu près au même rythme.</span><span class="sxs-lookup"><span data-stu-id="602d8-135">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="602d8-136">Dans les scénarios producteur-consommateur mixtes, <xref:System.Collections.Concurrent.ConcurrentStack%601> est plus rapide à la fois pour les petites et les grandes charges de travail.</span><span class="sxs-lookup"><span data-stu-id="602d8-136">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="602d8-137">L’utilisation de <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> et de <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> peut accélérer considérablement les temps d’accès.</span><span class="sxs-lookup"><span data-stu-id="602d8-137">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="602d8-138">ConcurrentDictionary et dictionary</span><span class="sxs-lookup"><span data-stu-id="602d8-138">ConcurrentDictionary vs. Dictionary</span></span>  

 <span data-ttu-id="602d8-139">En général, vous devez utiliser un <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> dans tout scénario où vous ajoutez et mettez à jour des clés ou des valeurs simultanément à partir de plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="602d8-139">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="602d8-140">Dans les scénarios qui impliquent des mises à jour fréquentes et des lectures relativement peu nombreuses, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> offre généralement des avantages modestes.</span><span class="sxs-lookup"><span data-stu-id="602d8-140">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="602d8-141">Dans les scénarios qui impliquent de nombreuses lectures et de nombreuses mises à jour, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> est généralement beaucoup plus rapide, quel que soit le nombre de cœurs des ordinateurs.</span><span class="sxs-lookup"><span data-stu-id="602d8-141">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="602d8-142">Dans les scénarios qui impliquent des mises à jour fréquentes, vous pouvez augmenter le degré d’accès concurrentiel dans <xref:System.Collections.Concurrent.ConcurrentDictionary%602>, puis mesurer pour voir si les performances augmentent sur les ordinateurs qui ont plus de cœurs.</span><span class="sxs-lookup"><span data-stu-id="602d8-142">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="602d8-143">Si vous modifiez le niveau d’accès concurrentiel, évitez, autant que possible, les opérations globales.</span><span class="sxs-lookup"><span data-stu-id="602d8-143">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="602d8-144">Si vous lisez uniquement une clé ou des valeurs, <xref:System.Collections.Generic.Dictionary%602> est plus rapide car aucune synchronisation n’est nécessaire si le dictionnaire n’est pas modifié par des threads.</span><span class="sxs-lookup"><span data-stu-id="602d8-144">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="602d8-145">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="602d8-145">ConcurrentBag</span></span>  

 <span data-ttu-id="602d8-146">Dans les scénarios producteur-consommateur purs, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> s’exécutera probablement plus lentement que les autres types de collections simultanées.</span><span class="sxs-lookup"><span data-stu-id="602d8-146">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="602d8-147">Dans les scénarios producteur-consommateur mixtes, <xref:System.Collections.Concurrent.ConcurrentBag%601> est généralement beaucoup plus rapide et plus évolutif que les autres types de collections simultanées à la fois pour les petites et pour les grandes charges de travail.</span><span class="sxs-lookup"><span data-stu-id="602d8-147">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="602d8-148">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="602d8-148">BlockingCollection</span></span>  

 <span data-ttu-id="602d8-149">Quand une sémantique de délimitation et de blocage est nécessaire, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> s’exécutera probablement plus rapidement que toute implémentation personnalisée.</span><span class="sxs-lookup"><span data-stu-id="602d8-149">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="602d8-150">Il prend également en charge une gestion enrichie des annulations, énumérations et exceptions.</span><span class="sxs-lookup"><span data-stu-id="602d8-150">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="602d8-151">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="602d8-151">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="602d8-152">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="602d8-152">Thread-Safe Collections</span></span>](index.md)
- [<span data-ttu-id="602d8-153">Programmation parallèle</span><span class="sxs-lookup"><span data-stu-id="602d8-153">Parallel Programming</span></span>](../../parallel-programming/index.md)
