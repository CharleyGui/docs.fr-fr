---
title: Vue d'ensemble de BlockingCollection
description: En savoir plus sur BlockingCollection <T> , une classe de collection thread-safe dans .net. Cette classe offre des fonctionnalités telles que l’ajout simultané & la réalisation d’éléments à partir de plusieurs threads.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- BlockingCollection, overview
ms.assetid: 987ea3d7-0ad5-4238-8b64-331ce4eb3f0b
ms.openlocfilehash: 550649ae8d5527b96e3a44edf44731c9c0586150
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95733501"
---
# <a name="blockingcollection-overview"></a><span data-ttu-id="ee60e-104">Vue d'ensemble de BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="ee60e-104">BlockingCollection Overview</span></span>

<span data-ttu-id="ee60e-105"><xref:System.Collections.Concurrent.BlockingCollection%601> est une classe de collection thread-safe qui fournit les fonctionnalités suivantes :</span><span class="sxs-lookup"><span data-stu-id="ee60e-105"><xref:System.Collections.Concurrent.BlockingCollection%601> is a thread-safe collection class that provides the following features:</span></span>  
  
- <span data-ttu-id="ee60e-106">Implémentation du modèle producteur-consommateur.</span><span class="sxs-lookup"><span data-stu-id="ee60e-106">An implementation of the Producer-Consumer pattern.</span></span>  
  
- <span data-ttu-id="ee60e-107">Ajout et reprise simultanés d’éléments à partir de plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="ee60e-107">Concurrent adding and taking of items from multiple threads.</span></span>  
  
- <span data-ttu-id="ee60e-108">Capacité maximale facultative.</span><span class="sxs-lookup"><span data-stu-id="ee60e-108">Optional maximum capacity.</span></span>  
  
- <span data-ttu-id="ee60e-109">Opérations d’insertion et de suppression qui se bloquent quand la collection est vide ou complète.</span><span class="sxs-lookup"><span data-stu-id="ee60e-109">Insertion and removal operations that block when collection is empty or full.</span></span>  
  
- <span data-ttu-id="ee60e-110">Opérations « d’essai » d’insertion et de suppression qui ne se bloquent pas ou qui se bloquent pendant une période spécifiée.</span><span class="sxs-lookup"><span data-stu-id="ee60e-110">Insertion and removal "try" operations that do not block or that block up to a specified period of time.</span></span>  
  
- <span data-ttu-id="ee60e-111">Encapsule tout type de collection qui implémente <xref:System.Collections.Concurrent.IProducerConsumerCollection%601></span><span class="sxs-lookup"><span data-stu-id="ee60e-111">Encapsulates any collection type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601></span></span>  
  
- <span data-ttu-id="ee60e-112">Annulation avec jetons d’annulation.</span><span class="sxs-lookup"><span data-stu-id="ee60e-112">Cancellation with cancellation tokens.</span></span>  
  
- <span data-ttu-id="ee60e-113">Deux types d’énumération avec `foreach` (`For Each` en Visual Basic) :</span><span class="sxs-lookup"><span data-stu-id="ee60e-113">Two kinds of enumeration with `foreach` (`For Each` in Visual Basic):</span></span>  
  
    1. <span data-ttu-id="ee60e-114">Énumération en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="ee60e-114">Read-only enumeration.</span></span>  
  
    2. <span data-ttu-id="ee60e-115">Énumération qui supprime des éléments à mesure qu’ils sont énumérés.</span><span class="sxs-lookup"><span data-stu-id="ee60e-115">Enumeration that removes items as they are enumerated.</span></span>  
  
## <a name="bounding-and-blocking-support"></a><span data-ttu-id="ee60e-116">Prise en charge de la délimitation et du blocage</span><span class="sxs-lookup"><span data-stu-id="ee60e-116">Bounding and Blocking Support</span></span>  

 <span data-ttu-id="ee60e-117"><xref:System.Collections.Concurrent.BlockingCollection%601> prend en charge la délimitation et le blocage.</span><span class="sxs-lookup"><span data-stu-id="ee60e-117"><xref:System.Collections.Concurrent.BlockingCollection%601> supports bounding and blocking.</span></span> <span data-ttu-id="ee60e-118">La délimitation signifie que vous pouvez définir la capacité maximale de la collection.</span><span class="sxs-lookup"><span data-stu-id="ee60e-118">Bounding means you can set the maximum capacity of the collection.</span></span> <span data-ttu-id="ee60e-119">La délimitation est importante dans certains scénarios, car elle vous permet de contrôler la taille maximale de la collection en mémoire, et elle empêche les threads producteur de se déplacer trop loin avant les threads consommateur.</span><span class="sxs-lookup"><span data-stu-id="ee60e-119">Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.</span></span>  
  
 <span data-ttu-id="ee60e-120">Plusieurs threads ou tâches peuvent ajouter simultanément des éléments à la collection, et si la collection atteint sa capacité maximale spécifiée, les threads producteur se bloquent jusqu’à ce qu’un élément soit supprimé.</span><span class="sxs-lookup"><span data-stu-id="ee60e-120">Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</span></span> <span data-ttu-id="ee60e-121">Plusieurs consommateurs peuvent supprimer des éléments simultanément, et si la collection devient vide, les threads consommateur se bloquent jusqu’à ce qu’un producteur ajoute un élément.</span><span class="sxs-lookup"><span data-stu-id="ee60e-121">Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</span></span> <span data-ttu-id="ee60e-122">Un thread producteur peut appeler <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> pour indiquer qu’aucun élément supplémentaire ne sera ajouté.</span><span class="sxs-lookup"><span data-stu-id="ee60e-122">A producing thread can call <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> to indicate that no more items will be added.</span></span> <span data-ttu-id="ee60e-123">Les consommateurs surveillent la propriété <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> pour savoir quand la collection est vide et quand aucun autre élément ne sera ajouté.</span><span class="sxs-lookup"><span data-stu-id="ee60e-123">Consumers monitor the <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> property to know when the collection is empty and no more items will be added.</span></span> <span data-ttu-id="ee60e-124">L’exemple suivant montre un BlockingCollection simple avec une capacité limitée de 100.</span><span class="sxs-lookup"><span data-stu-id="ee60e-124">The following example shows a simple BlockingCollection with a bounded capacity of 100.</span></span> <span data-ttu-id="ee60e-125">Une tâche de producteur ajoute des éléments à la collection tant qu’une certaine condition externe est remplie, puis appelle <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A>.</span><span class="sxs-lookup"><span data-stu-id="ee60e-125">A producer task adds items to the collection as long as some external condition is true, and then calls <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A>.</span></span> <span data-ttu-id="ee60e-126">La tâche du consommateur prend des éléments jusqu’à ce que la propriété <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> ait la valeur true.</span><span class="sxs-lookup"><span data-stu-id="ee60e-126">The consumer task takes items until the <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> property is true.</span></span>  
  
 [!code-csharp[CDS_BlockingCollection#04](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds_blockingcollection/cs/blockingcollection.cs#04)]
 [!code-vb[CDS_BlockingCollection#04](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_blockingcollection/vb/introsnippetsbc.vb#04)]  
  
 <span data-ttu-id="ee60e-127">Pour obtenir un exemple complet, consultez [Guide pratique : ajouter et prendre des éléments individuellement dans un BlockingCollection](how-to-add-and-take-items.md).</span><span class="sxs-lookup"><span data-stu-id="ee60e-127">For a complete example, see [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).</span></span>  
  
## <a name="timed-blocking-operations"></a><span data-ttu-id="ee60e-128">Opérations de blocage temporisé</span><span class="sxs-lookup"><span data-stu-id="ee60e-128">Timed Blocking Operations</span></span>  

 <span data-ttu-id="ee60e-129">Dans les opérations <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> et <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> de blocage temporisé sur les collections limitées, la méthode tente d’ajouter ou de prendre un élément.</span><span class="sxs-lookup"><span data-stu-id="ee60e-129">In timed blocking <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> and <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> operations on bounded collections, the method tries to add or take an item.</span></span> <span data-ttu-id="ee60e-130">Si un élément est disponible, il est placé dans la variable qui a été passée par référence, et la méthode retourne la valeur true.</span><span class="sxs-lookup"><span data-stu-id="ee60e-130">If an item is available it is placed into the variable that was passed in by reference, and the method returns true.</span></span> <span data-ttu-id="ee60e-131">Si aucun élément n’est récupéré après un délai d’attente spécifié, la méthode retourne la valeur false.</span><span class="sxs-lookup"><span data-stu-id="ee60e-131">If no item is retrieved after a specified time-out period the method returns false.</span></span> <span data-ttu-id="ee60e-132">Le thread est ensuite libre d’effectuer un autre travail utile avant de réessayer d’accéder à la collection.</span><span class="sxs-lookup"><span data-stu-id="ee60e-132">The thread is then free to do some other useful work before trying again to access the collection.</span></span> <span data-ttu-id="ee60e-133">Pour obtenir un exemple d’accès à blocage temporisé, consultez le deuxième exemple de la rubrique [Guide pratique : ajouter et prendre des éléments individuellement dans un BlockingCollection](how-to-add-and-take-items.md).</span><span class="sxs-lookup"><span data-stu-id="ee60e-133">For an example of timed blocking access, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).</span></span>  
  
## <a name="cancelling-add-and-take-operations"></a><span data-ttu-id="ee60e-134">Annulation d’opérations Add et Take</span><span class="sxs-lookup"><span data-stu-id="ee60e-134">Cancelling Add and Take Operations</span></span>  

 <span data-ttu-id="ee60e-135">Les opérations Add et Take sont généralement effectuées dans une boucle.</span><span class="sxs-lookup"><span data-stu-id="ee60e-135">Add and Take operations are typically performed in a loop.</span></span> <span data-ttu-id="ee60e-136">Vous pouvez annuler une boucle en passant un <xref:System.Threading.CancellationToken> à la méthode <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> ou <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A>, puis en vérifiant la valeur de la propriété <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> du jeton à chaque itération.</span><span class="sxs-lookup"><span data-stu-id="ee60e-136">You can cancel a loop by passing in a <xref:System.Threading.CancellationToken> to the <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> or <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> method, and then checking the value of the token's <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on each iteration.</span></span> <span data-ttu-id="ee60e-137">Si la valeur est true, vous pouvez, si vous le souhaitez, répondre à la demande d’annulation en nettoyant toutes les ressources et en quittant la boucle.</span><span class="sxs-lookup"><span data-stu-id="ee60e-137">If the value is true, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</span></span> <span data-ttu-id="ee60e-138">L’exemple suivant montre une surcharge de <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> qui prend un jeton d’annulation, ainsi que le code qui l’utilise :</span><span class="sxs-lookup"><span data-stu-id="ee60e-138">The following example shows an overload of <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> that takes a cancellation token, and the code that uses it:</span></span>  
  
 [!code-csharp[CDS_BlockingCollection#05](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds_blockingcollection/cs/blockingcollection.cs#05)]
 [!code-vb[CDS_BlockingCollection#05](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_blockingcollection/vb/introsnippetsbc.vb#05)]  
  
 <span data-ttu-id="ee60e-139">Pour obtenir un exemple d’ajout de prise en charge de l’annulation, consultez le deuxième exemple de la rubrique [Guide pratique : ajouter et prendre des éléments individuellement dans un BlockingCollection](how-to-add-and-take-items.md).</span><span class="sxs-lookup"><span data-stu-id="ee60e-139">For an example of how to add cancellation support, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).</span></span>  
  
## <a name="specifying-the-collection-type"></a><span data-ttu-id="ee60e-140">Spécification du type de collection</span><span class="sxs-lookup"><span data-stu-id="ee60e-140">Specifying the Collection Type</span></span>  

 <span data-ttu-id="ee60e-141">Quand vous créez un <xref:System.Collections.Concurrent.BlockingCollection%601>, vous pouvez spécifier non seulement la capacité limitée, mais aussi le type de collection à utiliser.</span><span class="sxs-lookup"><span data-stu-id="ee60e-141">When you create a <xref:System.Collections.Concurrent.BlockingCollection%601>, you can specify not only the bounded capacity but also the type of collection to use.</span></span> <span data-ttu-id="ee60e-142">Par exemple, vous pouvez spécifier un <xref:System.Collections.Concurrent.ConcurrentQueue%601> pour un comportement premier entré, premier sorti (FIFO, First In-First Out), ou un <xref:System.Collections.Concurrent.ConcurrentStack%601> pour un comportement dernier entré, premier sorti (LIFO, Last In-First Out).</span><span class="sxs-lookup"><span data-stu-id="ee60e-142">For example, you could specify a <xref:System.Collections.Concurrent.ConcurrentQueue%601> for first in-first out (FIFO) behavior, or a <xref:System.Collections.Concurrent.ConcurrentStack%601> for last in-first out (LIFO) behavior.</span></span> <span data-ttu-id="ee60e-143">Vous pouvez utiliser n’importe quelle classe de collection qui implémente l’interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="ee60e-143">You can use any collection class that implements the <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interface.</span></span> <span data-ttu-id="ee60e-144">Le type de collection par défaut pour <xref:System.Collections.Concurrent.BlockingCollection%601> est <xref:System.Collections.Concurrent.ConcurrentQueue%601>.</span><span class="sxs-lookup"><span data-stu-id="ee60e-144">The default collection type for <xref:System.Collections.Concurrent.BlockingCollection%601> is <xref:System.Collections.Concurrent.ConcurrentQueue%601>.</span></span> <span data-ttu-id="ee60e-145">L’exemple de code suivant montre comment créer un <xref:System.Collections.Concurrent.BlockingCollection%601> de chaînes qui possède une capacité de 1000 et qui utilise un <xref:System.Collections.Concurrent.ConcurrentBag%601> :</span><span class="sxs-lookup"><span data-stu-id="ee60e-145">The following code example shows how to create a <xref:System.Collections.Concurrent.BlockingCollection%601> of strings that has a capacity of 1000 and uses a <xref:System.Collections.Concurrent.ConcurrentBag%601>:</span></span>  
  
```vb  
Dim bc = New BlockingCollection(Of String)(New ConcurrentBag(Of String()), 1000)  
```  
  
```csharp  
BlockingCollection<string> bc = new BlockingCollection<string>(new ConcurrentBag<string>(), 1000 );  
```  
  
 <span data-ttu-id="ee60e-146">Pour plus d’informations, consultez [Comment : ajouter des fonctionnalités de liaison et de blocage à une collection](how-to-add-bounding-and-blocking.md).</span><span class="sxs-lookup"><span data-stu-id="ee60e-146">For more information, see [How to: Add Bounding and Blocking Functionality to a Collection](how-to-add-bounding-and-blocking.md).</span></span>  
  
## <a name="ienumerable-support"></a><span data-ttu-id="ee60e-147">Prise en charge d’IEnumerable</span><span class="sxs-lookup"><span data-stu-id="ee60e-147">IEnumerable Support</span></span>  

 <span data-ttu-id="ee60e-148"><xref:System.Collections.Concurrent.BlockingCollection%601> fournit une méthode <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> qui permet aux consommateurs d’utiliser une instruction `foreach` (`For Each` en Visual Basic) pour supprimer des éléments jusqu’à ce que la collection soit terminée, ce qui signifie qu’elle est vide et qu’aucun autre élément ne sera plus ajouté.</span><span class="sxs-lookup"><span data-stu-id="ee60e-148"><xref:System.Collections.Concurrent.BlockingCollection%601> provides a <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> method that enables consumers to use `foreach` (`For Each` in Visual Basic) to remove items until the collection is completed, which means it is empty and no more items will be added.</span></span> <span data-ttu-id="ee60e-149">Pour plus d’informations, consultez [Guide pratique : utiliser la boucle ForEach pour supprimer les éléments d’un BlockingCollection](how-to-use-foreach-to-remove.md).</span><span class="sxs-lookup"><span data-stu-id="ee60e-149">For more information, see [How to: Use ForEach to Remove Items in a BlockingCollection](how-to-use-foreach-to-remove.md).</span></span>  
  
## <a name="using-many-blockingcollections-as-one"></a><span data-ttu-id="ee60e-150">Utilisation de nombreux BlockingCollections comme un seul</span><span class="sxs-lookup"><span data-stu-id="ee60e-150">Using Many BlockingCollections As One</span></span>  

 <span data-ttu-id="ee60e-151">Pour les scénarios dans lesquels un consommateur doit prendre simultanément des éléments à partir de plusieurs collections, vous pouvez créer des tableaux de <xref:System.Collections.Concurrent.BlockingCollection%601> et utiliser les méthodes statiques telles que <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A> et <xref:System.Collections.Concurrent.BlockingCollection%601.AddToAny%2A> qui effectuent un ajout ou une prise dans n’importe laquelle des collections du tableau.</span><span class="sxs-lookup"><span data-stu-id="ee60e-151">For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <xref:System.Collections.Concurrent.BlockingCollection%601> and use the static methods such as <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A> and <xref:System.Collections.Concurrent.BlockingCollection%601.AddToAny%2A> that will add to or take from any of the collections in the array.</span></span> <span data-ttu-id="ee60e-152">Si une collection bloque, la méthode en essaie immédiatement une autre jusqu’à ce qu’elle en trouve une qui peut effectuer l’opération.</span><span class="sxs-lookup"><span data-stu-id="ee60e-152">If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.</span></span> <span data-ttu-id="ee60e-153">Pour plus d’informations, consultez [Guide pratique : utiliser des tableaux de collections de blocage dans un pipeline](how-to-use-arrays-of-blockingcollections.md).</span><span class="sxs-lookup"><span data-stu-id="ee60e-153">For more information, see [How to: Use Arrays of Blocking Collections in a Pipeline](how-to-use-arrays-of-blockingcollections.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ee60e-154">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="ee60e-154">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="ee60e-155">Collections et structures de données</span><span class="sxs-lookup"><span data-stu-id="ee60e-155">Collections and Data Structures</span></span>](../index.md)
- [<span data-ttu-id="ee60e-156">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="ee60e-156">Thread-Safe Collections</span></span>](index.md)
