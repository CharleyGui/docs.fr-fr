---
title: Collections thread-safe
description: Prise en main des collections thread-safe à l’aide de l’espace de noms System. Collections. concurrent dans .NET, qui comprend des classes de collection à thread sécurisée et évolutives.
ms.date: 03/30/2017
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 5f64d7b6a9b3564248a2b6113724e948066bf45c
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94827748"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="1df12-103">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="1df12-103">Thread-Safe Collections</span></span>
<span data-ttu-id="1df12-104">.NET Framework 4 introduit l’espace de noms <xref:System.Collections.Concurrent?displayProperty=nameWithType>, qui contient plusieurs classes de collection qui sont à la fois thread-safe et scalables.</span><span class="sxs-lookup"><span data-stu-id="1df12-104">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="1df12-105">Plusieurs threads peuvent, sans risque et de façon efficace, ajouter ou supprimer des éléments dans ces collections, sans nécessiter une synchronisation supplémentaire dans le code utilisateur.</span><span class="sxs-lookup"><span data-stu-id="1df12-105">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="1df12-106">Quand vous écrivez du code, utilisez des classes de collections simultanées si plusieurs threads écrivent en même temps dans la collection.</span><span class="sxs-lookup"><span data-stu-id="1df12-106">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="1df12-107">Si vous lisez seulement dans une collection partagée, vous pouvez utiliser les classes de l’espace de noms <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1df12-107">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="1df12-108">Nous vous recommandons de ne pas utiliser les classes de collections 1.0, à moins que vous ne deviez cibler le runtime .NET Framework 1.1 ou une version antérieure.</span><span class="sxs-lookup"><span data-stu-id="1df12-108">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="1df12-109">Synchronisation de threads dans les collections .NET Framework 1.0 et 2.0</span><span class="sxs-lookup"><span data-stu-id="1df12-109">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="1df12-110">Les collections introduites dans le .NET Framework 1.0 se trouvent dans l’espace de noms <xref:System.Collections?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1df12-110">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="1df12-111">Ces collections, qui incluent les <xref:System.Collections.ArrayList> et <xref:System.Collections.Hashtable> fréquemment utilisés, garantissent une certaine cohérence des threads par le biais de la propriété `Synchronized`, qui retourne un wrapper thread-safe autour de la collection.</span><span class="sxs-lookup"><span data-stu-id="1df12-111">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="1df12-112">Le wrapper fonctionne en verrouillant l’ensemble de la collection à chaque opération d’ajout ou de suppression.</span><span class="sxs-lookup"><span data-stu-id="1df12-112">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="1df12-113">Par conséquent, chaque thread qui tente d’accéder à la collection doit attendre son tour pour prendre le verrou.</span><span class="sxs-lookup"><span data-stu-id="1df12-113">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="1df12-114">Ce fonctionnement n’est pas évolutif et peut provoquer une importante dégradation des performances pour les grandes collections.</span><span class="sxs-lookup"><span data-stu-id="1df12-114">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="1df12-115">De même, la conception n’est pas complètement protégée contre la concurrence critique.</span><span class="sxs-lookup"><span data-stu-id="1df12-115">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="1df12-116">Pour plus d’informations, consultez [Synchronisation dans les collections génériques](/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span><span class="sxs-lookup"><span data-stu-id="1df12-116">For more information, see [Synchronization in Generic Collections](/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="1df12-117">Les classes de collection introduites dans le .NET Framework 2.0 se trouvent dans l’espace de noms <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1df12-117">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="1df12-118">Elles comprennent notamment <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, etc.</span><span class="sxs-lookup"><span data-stu-id="1df12-118">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="1df12-119">Ces classes garantissent une cohérence des types et des performances améliorées par rapport aux classes du .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="1df12-119">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="1df12-120">Toutefois, les classes de collections .NET Framework 2.0 ne fournissent pas de synchronisation des threads. Le code utilisateur doit fournir toute la synchronisation quand des éléments sont ajoutés ou supprimés simultanément sur plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="1df12-120">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="1df12-121">Nous vous recommandons les classes de collections simultanées de .NET Framework 4, car elles offrent non seulement la cohérence des types des classes de collections .NET Framework 2.0, mais également une cohérence de thread plus efficace et plus complète que les collections .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="1df12-121">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="1df12-122">Verrouillage de granularité fine et mécanismes sans verrou</span><span class="sxs-lookup"><span data-stu-id="1df12-122">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="1df12-123">Certains types de collections simultanées utilisent des mécanismes de synchronisation légers, comme <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim> et <xref:System.Threading.CountdownEvent>, qui sont nouveaux dans .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="1df12-123">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="1df12-124">Ces types de synchronisation utilisent généralement la *rotation intensive* pendant de courtes périodes avant de mettre le thread dans un véritable état d’attente.</span><span class="sxs-lookup"><span data-stu-id="1df12-124">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="1df12-125">Lorsque les temps d’attente sont supposés être très courts, la rotation est beaucoup moins gourmande en ressources informatiques que l’attente, qui implique une transition de noyau coûteuse.</span><span class="sxs-lookup"><span data-stu-id="1df12-125">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="1df12-126">Pour les classes de collections qui utilisent la rotation, cette efficacité signifie que plusieurs threads peuvent ajouter et supprimer des éléments à un taux très élevé.</span><span class="sxs-lookup"><span data-stu-id="1df12-126">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="1df12-127">Pour plus d'informations sur la rotation et le blocage, consultez [SpinLock](../../threading/spinlock.md) et [SpinWait](../../threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="1df12-127">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="1df12-128">Les classes <xref:System.Collections.Concurrent.ConcurrentQueue%601> et <xref:System.Collections.Concurrent.ConcurrentStack%601> n’utilisent pas de verrous du tout.</span><span class="sxs-lookup"><span data-stu-id="1df12-128">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="1df12-129">Au lieu de cela, elles s’appuient sur des opérations <xref:System.Threading.Interlocked> pour assurer la cohérence des threads.</span><span class="sxs-lookup"><span data-stu-id="1df12-129">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1df12-130">Étant donné que les classes de collections simultanées prennent en charge <xref:System.Collections.ICollection>, elles fournissent des implémentations pour les propriétés <xref:System.Collections.ICollection.IsSynchronized%2A> et <xref:System.Collections.ICollection.SyncRoot%2A>, bien que ces propriétés ne soient pas pertinentes.</span><span class="sxs-lookup"><span data-stu-id="1df12-130">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="1df12-131">`IsSynchronized` retourne toujours `false` et `SyncRoot` a toujours la valeur `null` (`Nothing` dans Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="1df12-131">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="1df12-132">Le tableau suivant répertorie les types de collections dans l’espace de noms <xref:System.Collections.Concurrent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1df12-132">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="1df12-133">Type</span><span class="sxs-lookup"><span data-stu-id="1df12-133">Type</span></span>|<span data-ttu-id="1df12-134">Description</span><span class="sxs-lookup"><span data-stu-id="1df12-134">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="1df12-135">Fournit des fonctionnalités de délimitation et de blocage pour tous les types qui implémentent <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="1df12-135">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="1df12-136">Pour plus d’informations, consultez [Vue d’ensemble de BlockingCollection](blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="1df12-136">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="1df12-137">Implémentation thread-safe d’un dictionnaire de paires clé-valeur.</span><span class="sxs-lookup"><span data-stu-id="1df12-137">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="1df12-138">Implémentation thread-safe d’une file d’attente FIFO (premier entré, premier sorti).</span><span class="sxs-lookup"><span data-stu-id="1df12-138">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="1df12-139">Implémentation thread-safe d’une pile LIFO (dernier entré, premier sorti).</span><span class="sxs-lookup"><span data-stu-id="1df12-139">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="1df12-140">Implémentation thread-safe d’une collection non ordonnée d’éléments.</span><span class="sxs-lookup"><span data-stu-id="1df12-140">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="1df12-141">Interface qu’un type doit implémenter pour être utilisé dans un `BlockingCollection`.</span><span class="sxs-lookup"><span data-stu-id="1df12-141">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="1df12-142">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="1df12-142">Related Topics</span></span>  
  
|<span data-ttu-id="1df12-143">Intitulé</span><span class="sxs-lookup"><span data-stu-id="1df12-143">Title</span></span>|<span data-ttu-id="1df12-144">Description</span><span class="sxs-lookup"><span data-stu-id="1df12-144">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="1df12-145">Vue d'ensemble de BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="1df12-145">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="1df12-146">Décrit la fonctionnalité fournie par le type <xref:System.Collections.Concurrent.BlockingCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="1df12-146">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="1df12-147">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="1df12-147">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="1df12-148">Décrit comment ajouter et supprimer des éléments dans un <xref:System.Collections.Concurrent.ConcurrentDictionary%602>.</span><span class="sxs-lookup"><span data-stu-id="1df12-148">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="1df12-149">Procédure : ajouter et prendre des éléments individuellement dans un BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="1df12-149">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="1df12-150">Décrit comment ajouter et récupérer des éléments dans une collection de blocage sans utiliser l’énumérateur en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="1df12-150">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="1df12-151">Procédure : ajouter des fonctionnalités de délimitation et de blocage à une collection</span><span class="sxs-lookup"><span data-stu-id="1df12-151">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="1df12-152">Décrit comment utiliser une classe de collection comme mécanisme de stockage sous-jacent pour une collection <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="1df12-152">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="1df12-153">Procédure : utiliser la boucle ForEach pour supprimer les éléments d’un BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="1df12-153">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="1df12-154">Décrit comment utiliser `foreach`, (`For Each` dans Visual Basic) pour supprimer tous les éléments d’une collection de blocage.</span><span class="sxs-lookup"><span data-stu-id="1df12-154">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="1df12-155">Procédure : utiliser des tableaux de collections de blocage dans un pipeline</span><span class="sxs-lookup"><span data-stu-id="1df12-155">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="1df12-156">Décrit comment utiliser simultanément plusieurs collections de blocage pour implémenter un pipeline.</span><span class="sxs-lookup"><span data-stu-id="1df12-156">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="1df12-157">Procédure : créer un pool d’objets à l’aide d’un ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="1df12-157">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="1df12-158">Montre comment utiliser un conteneur simultané pour améliorer les performances dans les scénarios où vous pouvez réutiliser des objets au lieu d’en créer continuellement de nouveaux.</span><span class="sxs-lookup"><span data-stu-id="1df12-158">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="1df12-159">Référence</span><span class="sxs-lookup"><span data-stu-id="1df12-159">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
