---
title: Assemblys de référence
description: En savoir plus sur les assemblys de référence, un type spécial d’assemblys dans .NET qui contiennent uniquement la surface de l’API publique de la bibliothèque
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: 3b85e51a015cca1e53ee2503c7bfa58c504fc718
ms.sourcegitcommit: 00aa62e2f469c2272a457b04e66b4cc3c97a800b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/28/2020
ms.locfileid: "78156463"
---
# <a name="reference-assemblies"></a><span data-ttu-id="b0ec0-103">Assemblys de référence</span><span class="sxs-lookup"><span data-stu-id="b0ec0-103">Reference assemblies</span></span>

<span data-ttu-id="b0ec0-104">Les *assemblys de référence* sont un type spécial d’assembly qui ne contient que la quantité minimale de métadonnées requises pour représenter la surface de l’API publique de la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="b0ec0-105">Elles incluent des déclarations pour tous les membres qui sont significatifs lors du référencement d’un assembly dans les outils de génération, mais excluent toutes les implémentations de membres et les déclarations de membres privés qui n’ont aucun impact observable sur leur contrat d’API.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="b0ec0-106">En revanche, les assemblys standard sont appelés *assemblys d’implémentation*.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="b0ec0-107">Les assemblys de référence ne peuvent pas être chargés pour l’exécution, mais ils peuvent être passés en tant qu’entrée de compilateur de la même façon que les assemblys d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="b0ec0-108">Les assemblys de référence sont généralement distribués avec le kit de développement logiciel (SDK) d’une plateforme ou d’une bibliothèque particulière.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="b0ec0-109">L’utilisation d’un assembly de référence permet aux développeurs de générer des programmes qui ciblent une version de bibliothèque spécifique sans disposer de l’assembly d’implémentation complète pour cette version.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="b0ec0-110">Supposons que vous disposez uniquement de la dernière version d’une bibliothèque sur votre ordinateur, mais que vous souhaitez créer un programme qui cible une version antérieure de cette bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="b0ec0-111">Si vous compilez directement par rapport à l’assembly d’implémentation, vous pouvez utiliser par inadvertance des membres de l’API qui ne sont pas disponibles dans la version antérieure.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="b0ec0-112">Vous ne trouverez cette erreur que si vous testez le programme sur l’ordinateur cible.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="b0ec0-113">Si vous compilez par rapport à l’assembly de référence pour la version antérieure, vous obtenez immédiatement une erreur au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="b0ec0-114">Un assembly de référence peut également représenter un contrat, c’est-à-dire un ensemble d’API qui ne correspondent pas à l’assembly d’implémentation concret.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="b0ec0-115">De tels assemblys de référence, appelés *assembly de contrat*, peuvent être utilisés pour cibler plusieurs plateformes qui prennent en charge le même ensemble d’API.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="b0ec0-116">Par exemple, .NET Standard fournit l’assembly de contrat, *netstandard. dll*, qui représente l’ensemble des API communes partagées entre différentes plateformes .net.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="b0ec0-117">Les implémentations de ces API sont contenues dans des assemblys différents sur différentes plateformes, comme *mscorlib. dll* sur .NET Framework ou *System. private. CoreLib. dll* sur .net core.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="b0ec0-118">Une bibliothèque qui cible .NET Standard peut s’exécuter sur toutes les plateformes qui prennent en charge .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="b0ec0-119">Utilisation d’assemblys de référence</span><span class="sxs-lookup"><span data-stu-id="b0ec0-119">Using reference assemblies</span></span>

<span data-ttu-id="b0ec0-120">Pour utiliser certaines API à partir de votre projet, vous devez ajouter des références à leurs assemblys.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="b0ec0-121">Vous pouvez ajouter des références à des assemblys d’implémentation ou à des assemblys de référence.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="b0ec0-122">Il est recommandé d’utiliser des assemblys de référence chaque fois qu’ils sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="b0ec0-123">Cela vous permet de vous assurer que vous utilisez uniquement les membres de l’API pris en charge dans la version cible, destinés à être utilisés par les concepteurs d’API.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="b0ec0-124">L’utilisation de l’assembly de référence vous permet de vous assurer que vous n’êtes pas dépendant des détails d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="b0ec0-125">Les assemblys de référence pour les bibliothèques .NET Framework sont distribués avec des packs de ciblage.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="b0ec0-126">Vous pouvez les obtenir en téléchargeant un programme d’installation autonome ou en sélectionnant un composant dans Visual Studio installer.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="b0ec0-127">Pour plus d’informations, consultez [installer le .NET Framework pour les développeurs](../../framework/install/guide-for-developers.md).</span><span class="sxs-lookup"><span data-stu-id="b0ec0-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="b0ec0-128">Pour .NET Core et .NET Standard, les assemblys de référence sont automatiquement téléchargés si nécessaire (via NuGet) et référencés.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="b0ec0-129">Pour .NET Core 3,0 et versions ultérieures, les assemblys de référence pour l’infrastructure de base se trouvent dans le package [Microsoft. Netcore. app. Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) (le package [Microsoft. Netcore. app](https://www.nuget.org/packages/Microsoft.NETCore.App) est utilisé à la place pour les versions antérieures à 3,0).</span><span class="sxs-lookup"><span data-stu-id="b0ec0-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="b0ec0-130">Pour plus d’informations, consultez [packages, offres et infrastructures](../../core/packages.md) dans le guide .net core.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-130">For more information, see [Packages, metapackages, and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="b0ec0-131">Quand vous ajoutez des références à des assemblys .NET Framework dans Visual Studio à l’aide de la boîte de dialogue **Ajouter une référence** , vous sélectionnez un assembly dans la liste, et Visual Studio recherche automatiquement les assemblys de référence qui correspondent à la version cible de .NET Framework sélectionnée dans votre projet.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-131">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="b0ec0-132">Il en va de même pour l’ajout de références directement dans le projet MSBuild à l’aide de l’élément de projet de [référence](/visualstudio/msbuild/common-msbuild-project-items#reference) : vous devez uniquement spécifier le nom de l’assembly, et non le chemin d’accès complet au fichier.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-132">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="b0ec0-133">Quand vous ajoutez des références à ces assemblys dans la ligne de commande à l’aide de l’option de compilateur `-reference` ([dans C# ](../../csharp/language-reference/compiler-options/reference-compiler-option.md) et dans [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) ou à l’aide de la méthode <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> dans l’API Roslyn, vous devez spécifier manuellement des fichiers d’assembly de référence pour la version de plateforme cible correcte.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-133">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="b0ec0-134">.NET Framework fichiers d’assembly de référence se trouvent dans les *assemblys de référence% ProgramFiles (x86)%\\\\Microsoft\\Framework\\. Répertoire NETFramework* .</span><span class="sxs-lookup"><span data-stu-id="b0ec0-134">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="b0ec0-135">Pour .NET Core, vous pouvez forcer l’opération de publication à copier des assemblys de référence pour votre plateforme cible dans le sous-répertoire *Publish/REFS* de votre répertoire de sortie en affectant à la propriété `PreserveCompilationContext` Project la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-135">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="b0ec0-136">Vous pouvez ensuite passer ces fichiers d’assembly de référence au compilateur.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-136">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="b0ec0-137">L’utilisation de `DependencyContext` du package [Microsoft. extensions. DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) peut faciliter la localisation de leurs chemins d’accès.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-137">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="b0ec0-138">Étant donné qu’elles ne contiennent aucune implémentation, les assemblys de référence ne peuvent pas être chargés pour l’exécution ; Si vous tentez de le faire, une <xref:System.BadImageFormatException?displayProperty=nameWithType>est générée.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-138">Because they contain no implementation, reference assemblies can't be loaded for execution; trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b0ec0-139">Toutefois, elles peuvent toujours être chargées dans le contexte de réflexion uniquement (à l’aide de la méthode <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>), si vous devez examiner leur contenu.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-139">However, they still can be loaded into the reflection-only context (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method), if you need to examine their contents.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="b0ec0-140">Génération d’assemblys de référence</span><span class="sxs-lookup"><span data-stu-id="b0ec0-140">Generating reference assemblies</span></span>

<span data-ttu-id="b0ec0-141">La génération d’assemblys de référence pour vos bibliothèques peut être utile lorsque les consommateurs de votre bibliothèque doivent créer leurs programmes sur de nombreuses versions différentes de la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-141">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="b0ec0-142">La distribution d’assemblys d’implémentation pour toutes ces versions peut être irréalisable en raison de leur taille importante.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-142">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="b0ec0-143">La taille des assemblys de référence est plus petite et leur distribution dans le cadre du kit de développement logiciel (SDK) de votre bibliothèque réduit la taille du téléchargement et économise de l’espace disque.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-143">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="b0ec0-144">Les IDE et les outils de génération peuvent également tirer parti des assemblys de référence pour réduire les délais de génération en cas de solutions volumineuses composées de plusieurs bibliothèques de classes.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-144">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="b0ec0-145">En général, dans les scénarios de génération incrémentielle, un projet est régénéré quand l’un de ses fichiers d’entrée est modifié, y compris les assemblys dont il dépend.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-145">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="b0ec0-146">L’assembly d’implémentation change chaque fois que le programmeur modifie l’implémentation d’un membre.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-146">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="b0ec0-147">L’assembly de référence change uniquement lorsque son API publique est affectée.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-147">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="b0ec0-148">Ainsi, l’utilisation de l’assembly de référence comme fichier d’entrée au lieu de l’assembly d’implémentation permet d’ignorer la génération du projet dépendant dans certains cas.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-148">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="b0ec0-149">Vous pouvez générer des assemblys de référence :</span><span class="sxs-lookup"><span data-stu-id="b0ec0-149">You can generate reference assemblies:</span></span>

- <span data-ttu-id="b0ec0-150">Dans un projet MSBuild, à l’aide de la [propriété de projet`ProduceReferenceAssembly`](/visualstudio/msbuild/common-msbuild-project-properties).</span><span class="sxs-lookup"><span data-stu-id="b0ec0-150">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="b0ec0-151">Lors de la compilation d’un programme à partir de la[C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) ligne de commande, en fonction[C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) des options du compilateur `-refonly` ( / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) ou `-refout` ( / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)).</span><span class="sxs-lookup"><span data-stu-id="b0ec0-151">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="b0ec0-152">Lorsque vous utilisez l’API Roslyn, en définissant <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> sur `true` et <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> pour `false` dans un objet passé à la méthode <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-152">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="b0ec0-153">Si vous souhaitez distribuer des assemblys de référence avec des packages NuGet, vous devez les inclure dans le sous-répertoire *ref\\* sous le répertoire du package plutôt que dans le sous-répertoire *lib\\* utilisé pour les assemblys d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-153">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="b0ec0-154">Structure des assemblys de référence</span><span class="sxs-lookup"><span data-stu-id="b0ec0-154">Reference assemblies structure</span></span>

<span data-ttu-id="b0ec0-155">Les assemblys de référence sont une expansion du concept connexe, des *assemblys de métadonnées uniquement*.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-155">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="b0ec0-156">Les assemblys de métadonnées uniquement ont leurs corps de méthode remplacés par un corps `throw null` unique, mais incluent tous les membres à l’exception des types anonymes.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-156">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="b0ec0-157">La raison de l’utilisation de `throw null` corps (par opposition à aucun corps) est que **PEVerify** peut s’exécuter et réussir (validant ainsi l’exhaustivité des métadonnées).</span><span class="sxs-lookup"><span data-stu-id="b0ec0-157">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="b0ec0-158">En outre, les assemblys de référence suppriment les métadonnées (membres privés) des assemblys de métadonnées uniquement :</span><span class="sxs-lookup"><span data-stu-id="b0ec0-158">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="b0ec0-159">Un assembly de référence a uniquement des références pour ce dont il a besoin dans la surface de l’API.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-159">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="b0ec0-160">L’assembly réel peut avoir des références supplémentaires relatives à des implémentations spécifiques.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-160">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="b0ec0-161">Par exemple, l’assembly de référence pour `class C { private void M() { dynamic d = 1; ... } }` ne fait référence à aucun type requis pour la `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-161">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="b0ec0-162">Les membres de fonction privés (méthodes, propriétés et événements) sont supprimés si leur suppression n’affecte pas la compilation sensiblement.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-162">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="b0ec0-163">S’il n’y a pas d’attributs [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) , les membres de fonction internes sont également supprimés.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-163">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="b0ec0-164">Les métadonnées dans les assemblys de référence continuent à conserver les informations suivantes :</span><span class="sxs-lookup"><span data-stu-id="b0ec0-164">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="b0ec0-165">Tous les types, y compris les types privés et imbriqués.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-165">All types, including private and nested types.</span></span>
- <span data-ttu-id="b0ec0-166">Tous les attributs, y compris internes.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-166">All attributes, even internal ones.</span></span>
- <span data-ttu-id="b0ec0-167">Toutes les méthodes virtuelles.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-167">All virtual methods.</span></span>
- <span data-ttu-id="b0ec0-168">Implémentations d’interface explicites.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-168">Explicit interface implementations.</span></span>
- <span data-ttu-id="b0ec0-169">Les propriétés et les événements implémentés explicitement, car leurs accesseurs sont virtuels.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-169">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="b0ec0-170">Tous les champs de structures.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-170">All fields of structures.</span></span>

<span data-ttu-id="b0ec0-171">Les assemblys de référence incluent un attribut [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) au niveau de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-171">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="b0ec0-172">Cet attribut peut être spécifié dans la source ; le compilateur n’a pas besoin de le synthétiser.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-172">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="b0ec0-173">En raison de cet attribut, les runtimes refusent de charger des assemblys de référence pour l’exécution (mais ils peuvent être chargés en mode de réflexion uniquement).</span><span class="sxs-lookup"><span data-stu-id="b0ec0-173">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="b0ec0-174">Les détails de la structure de l’assembly de référence exact dépendent de la version du compilateur.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-174">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="b0ec0-175">Les versions plus récentes peuvent choisir d’exclure davantage de métadonnées si elles sont déterminées comme n’affectant pas la surface de l’API publique.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-175">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="b0ec0-176">Les informations contenues dans cette section s’appliquent uniquement aux assemblys de référence générés par C# les compilateurs Roslyn à partir de la version 7,1 ou Visual Basic version 15,3.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-176">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="b0ec0-177">La structure des assemblys de référence pour les .NET Framework et les bibliothèques .NET Core peut différer dans certains détails, car ils utilisent leur propre mécanisme de génération d’assemblys de référence.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-177">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="b0ec0-178">Par exemple, ils peuvent avoir des corps de méthode entièrement vides au lieu du corps du `throw null`.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-178">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="b0ec0-179">Toutefois, le principe général s’applique toujours : ils n’ont pas d’implémentations de méthode utilisables et contiennent uniquement des métadonnées pour les membres qui ont un impact observable à partir d’une perspective d’API publique.</span><span class="sxs-lookup"><span data-stu-id="b0ec0-179">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="b0ec0-180">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="b0ec0-180">See also</span></span>

- [<span data-ttu-id="b0ec0-181">Assemblys dans .NET</span><span class="sxs-lookup"><span data-stu-id="b0ec0-181">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="b0ec0-182">Vue d’ensemble du ciblage des frameworks</span><span class="sxs-lookup"><span data-stu-id="b0ec0-182">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="b0ec0-183">Procédure : ajouter ou supprimer des références à l’aide du gestionnaire de références</span><span class="sxs-lookup"><span data-stu-id="b0ec0-183">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
