---
title: Assemblys de référence
description: En savoir plus sur les assemblages de référence, un type spécial d’assemblages en .NET qui ne contiennent que la surface publique de l’API de la bibliothèque
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: 938942caf81c54a8aa9207dbe87559438ffb252e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/15/2020
ms.locfileid: "79141066"
---
# <a name="reference-assemblies"></a><span data-ttu-id="98d77-103">Assemblys de référence</span><span class="sxs-lookup"><span data-stu-id="98d77-103">Reference assemblies</span></span>

<span data-ttu-id="98d77-104">*Les assemblages* de référence sont un type spécial d’assemblage qui ne contient que la quantité minimale de métadonnées requises pour représenter la surface publique de l’API de la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="98d77-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="98d77-105">Elles comprennent des déclarations pour tous les membres qui sont importantes lorsqu’ils font référence à une assemblée dans des outils de construction, mais excluent toutes les mises en œuvre et déclarations des membres du groupe privé qui n’ont aucune incidence observable sur leur contrat d’API.</span><span class="sxs-lookup"><span data-stu-id="98d77-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="98d77-106">En revanche, les assemblées régulières sont appelées *assemblées de mise en œuvre*.</span><span class="sxs-lookup"><span data-stu-id="98d77-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="98d77-107">Les assemblages de référence ne peuvent pas être chargés pour exécution, mais ils peuvent être adoptés comme entrée de compilateur de la même manière que les assemblages de mise en œuvre.</span><span class="sxs-lookup"><span data-stu-id="98d77-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="98d77-108">Les assemblages de référence sont généralement distribués avec le kit de développement logiciel (SDK) d’une plate-forme ou d’une bibliothèque particulière.</span><span class="sxs-lookup"><span data-stu-id="98d77-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="98d77-109">L’utilisation d’un assemblage de référence permet aux développeurs de construire des programmes qui ciblent une version de bibliothèque spécifique sans avoir l’assemblage complet de mise en œuvre pour cette version.</span><span class="sxs-lookup"><span data-stu-id="98d77-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="98d77-110">Supposons que vous n’ayez que la dernière version d’une bibliothèque sur votre machine, mais vous voulez construire un programme qui cible une version antérieure de cette bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="98d77-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="98d77-111">Si vous compilez directement contre l’assemblée de mise en œuvre, vous pouvez utiliser par inadvertance des membres de l’API qui ne sont pas disponibles dans la version antérieure.</span><span class="sxs-lookup"><span data-stu-id="98d77-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="98d77-112">Vous ne trouverez cette erreur que lorsque vous testez le programme sur la machine cible.</span><span class="sxs-lookup"><span data-stu-id="98d77-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="98d77-113">Si vous compilez contre l’assemblage de référence pour la version antérieure, vous obtiendrez immédiatement une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="98d77-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="98d77-114">Une assemblée de référence peut également représenter un contrat, c’est-à-dire un ensemble d’API qui ne correspondent pas à l’assemblage concret de la mise en œuvre.</span><span class="sxs-lookup"><span data-stu-id="98d77-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="98d77-115">Ces assemblages de référence, appelés *l’assemblage des contrats,* peuvent être utilisés pour cibler plusieurs plates-formes qui prennent en charge le même ensemble d’API.</span><span class="sxs-lookup"><span data-stu-id="98d77-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="98d77-116">Par exemple, .NET Standard fournit l’assemblage du contrat, *netstandard.dll*, qui représente l’ensemble des API communes partagées entre les différentes plates-formes .NET.</span><span class="sxs-lookup"><span data-stu-id="98d77-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="98d77-117">Les implémentations de ces API sont contenues dans différents assemblages sur différentes plates-formes, telles que *mscorlib.dll* sur .NET Framework ou *System.Private.CoreLib.dll* sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="98d77-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="98d77-118">Une bibliothèque qui cible .NET Standard peut fonctionner sur toutes les plates-formes qui prennent en charge .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="98d77-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="98d77-119">Utilisation d’assemblages de référence</span><span class="sxs-lookup"><span data-stu-id="98d77-119">Using reference assemblies</span></span>

<span data-ttu-id="98d77-120">Pour utiliser certaines API de votre projet, vous devez ajouter des références à leurs assemblages.</span><span class="sxs-lookup"><span data-stu-id="98d77-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="98d77-121">Vous pouvez ajouter des références aux assemblages de mise en œuvre ou aux assemblages de référence.</span><span class="sxs-lookup"><span data-stu-id="98d77-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="98d77-122">Il est recommandé d’utiliser des assemblages de référence chaque fois qu’ils sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="98d77-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="98d77-123">Cela garantit que vous utilisez uniquement les membres API pris en charge dans la version cible, destinée à être utilisée par les concepteurs d’API.</span><span class="sxs-lookup"><span data-stu-id="98d77-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="98d77-124">L’utilisation de l’assemblage de référence garantit que vous ne prenez pas une dépendance aux détails de mise en œuvre.</span><span class="sxs-lookup"><span data-stu-id="98d77-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="98d77-125">Les assemblages de référence pour les bibliothèques cadre .NET sont distribués avec des packs de ciblage.</span><span class="sxs-lookup"><span data-stu-id="98d77-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="98d77-126">Vous pouvez les obtenir en téléchargeant un installateur autonome ou en sélectionnant un composant dans l’installateur Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="98d77-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="98d77-127">Pour plus d’informations, voir [Installer le cadre .NET pour les développeurs](../../framework/install/guide-for-developers.md).</span><span class="sxs-lookup"><span data-stu-id="98d77-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="98d77-128">Pour .NET Core et .NET Standard, les assemblages de référence sont automatiquement téléchargés au besoin (via NuGet) et référencés.</span><span class="sxs-lookup"><span data-stu-id="98d77-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="98d77-129">Pour .NET Core 3.0 et plus, les assemblages de référence pour le cadre de base sont dans le paquet [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) (le paquet [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) est utilisé à la place pour les versions avant 3.0).</span><span class="sxs-lookup"><span data-stu-id="98d77-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="98d77-130">Pour plus d’informations, voir [Paquets, métapackages et cadres](../../core/packages.md) dans le guide de base .NET.</span><span class="sxs-lookup"><span data-stu-id="98d77-130">For more information, see [Packages, metapackages, and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="98d77-131">Lorsque vous ajoutez des références à des assemblages cadres .NET dans Visual Studio à l’aide du dialogue **de référence Add,** vous sélectionnez un assemblage de la liste, et Visual Studio trouve automatiquement des assemblages de référence qui correspondent à la version cadre cible sélectionnée dans votre projet.</span><span class="sxs-lookup"><span data-stu-id="98d77-131">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="98d77-132">Il en va de même pour l’ajout de références directement dans le projet MSBuild à l’aide de [l’élément](/visualstudio/msbuild/common-msbuild-project-items#reference) du projet De référence : vous n’avez qu’à spécifier le nom de l’assemblage, et non la trajectoire complète du fichier.</span><span class="sxs-lookup"><span data-stu-id="98d77-132">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="98d77-133">Lorsque vous ajoutez des références à ces `-reference` assemblages dans la ligne de commande en utilisant l’option compilateur[(en C](../../csharp/language-reference/compiler-options/reference-compiler-option.md) et dans Visual [Basic](../../visual-basic/reference/command-line-compiler/reference.md)) ou en utilisant la <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> méthode dans l’API Roslyn, vous devez spécifier manuellement les fichiers d’assemblage de référence pour la bonne version de la plate-forme cible.</span><span class="sxs-lookup"><span data-stu-id="98d77-133">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="98d77-134">.NET Les fichiers d’assemblage de référence du Cadre sont situés dans le *cadre\\\\\\Microsoft Assembly des % ProgramFiles(x86)% .\\ Annuaire NETFramework.*</span><span class="sxs-lookup"><span data-stu-id="98d77-134">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="98d77-135">Pour .NET Core, vous pouvez forcer l’opération de publication à copier des assemblages de référence pour `PreserveCompilationContext` votre `true`plate-forme cible dans la sous-direction de votre répertoire de sortie *de publication/réfsation* en fixant la propriété du projet à .</span><span class="sxs-lookup"><span data-stu-id="98d77-135">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="98d77-136">Ensuite, vous pouvez passer ces fichiers d’assemblage de référence au compilateur.</span><span class="sxs-lookup"><span data-stu-id="98d77-136">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="98d77-137">L’utilisation `DependencyContext` du package [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) peut aider à localiser leurs chemins.</span><span class="sxs-lookup"><span data-stu-id="98d77-137">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="98d77-138">Parce qu’ils ne contiennent aucune implémentation, les assemblages de référence ne peuvent pas être chargés pour l’exécution.</span><span class="sxs-lookup"><span data-stu-id="98d77-138">Because they contain no implementation, reference assemblies can't be loaded for execution.</span></span> <span data-ttu-id="98d77-139">Essayer de le faire <xref:System.BadImageFormatException?displayProperty=nameWithType>se traduit par un .</span><span class="sxs-lookup"><span data-stu-id="98d77-139">Trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="98d77-140">Si vous souhaitez examiner le contenu d’un assemblage de référence, vous pouvez le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> charger dans le <xref:System.Reflection.MetadataLoadContext> contexte de réflexion uniquement dans .NET Framework (en utilisant la méthode) ou dans le noyau en .NET.</span><span class="sxs-lookup"><span data-stu-id="98d77-140">If you want to examine the contents of a reference assembly, you can load it into the reflection-only context in .NET Framework (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method) or into the <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="98d77-141">Génération d’assemblages de référence</span><span class="sxs-lookup"><span data-stu-id="98d77-141">Generating reference assemblies</span></span>

<span data-ttu-id="98d77-142">Générer des assemblages de référence pour vos bibliothèques peut être utile lorsque les consommateurs de votre bibliothèque ont besoin de construire leurs programmes contre de nombreuses versions différentes de la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="98d77-142">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="98d77-143">La distribution d’assemblages d’implémentation pour toutes ces versions peut être peu pratique en raison de leur grande taille.</span><span class="sxs-lookup"><span data-stu-id="98d77-143">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="98d77-144">Les assemblages de référence sont de plus petite taille, et leur distribution dans le cadre du SDK de votre bibliothèque réduit la taille du téléchargement et permet d’économiser de l’espace disque.</span><span class="sxs-lookup"><span data-stu-id="98d77-144">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="98d77-145">Les IDE et les outils de construction peuvent également tirer parti des assemblages de référence pour réduire les temps de construction en cas de grandes solutions composées de bibliothèques de plusieurs classes.</span><span class="sxs-lookup"><span data-stu-id="98d77-145">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="98d77-146">Habituellement, dans les scénarios de construction incrémentielle, un projet est reconstruit lorsque l’un de ses fichiers d’entrée est modifié, y compris les assemblages dont il dépend.</span><span class="sxs-lookup"><span data-stu-id="98d77-146">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="98d77-147">L’assemblage de mise en œuvre change chaque fois que le programmeur modifie la mise en œuvre d’un membre.</span><span class="sxs-lookup"><span data-stu-id="98d77-147">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="98d77-148">L’assemblage de référence ne change que lorsque son API public est affecté.</span><span class="sxs-lookup"><span data-stu-id="98d77-148">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="98d77-149">Ainsi, l’utilisation de l’assemblage de référence comme fichier d’entrée au lieu de l’assemblage de mise en œuvre permet de sauter la construction du projet dépendant dans certains cas.</span><span class="sxs-lookup"><span data-stu-id="98d77-149">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="98d77-150">Vous pouvez générer des assemblages de référence :</span><span class="sxs-lookup"><span data-stu-id="98d77-150">You can generate reference assemblies:</span></span>

- <span data-ttu-id="98d77-151">Dans un projet MSBuild, en utilisant la [ `ProduceReferenceAssembly` propriété](/visualstudio/msbuild/common-msbuild-project-properties)du projet .</span><span class="sxs-lookup"><span data-stu-id="98d77-151">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="98d77-152">Lors de la compilation du programme à `-refonly` partir de la ligne `-refout` de commande, en spécifiant[(C -](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / Visual[Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) ou ( C[-](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) options compiler.</span><span class="sxs-lookup"><span data-stu-id="98d77-152">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="98d77-153">Lors de l’utilisation de <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> l’API Roslyn, en définissant `true` et <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> à `false` dans un objet passé à la <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> méthode.</span><span class="sxs-lookup"><span data-stu-id="98d77-153">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="98d77-154">Si vous souhaitez distribuer des assemblages de référence avec des paquets NuGet, vous devez les inclure dans la sous-direction \*de l’application\\ \* du paquet au lieu de dans la sous-direction \*lib\\ \* utilisée pour les assemblages de mise en œuvre.</span><span class="sxs-lookup"><span data-stu-id="98d77-154">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="98d77-155">Structure d’assemblages de référence</span><span class="sxs-lookup"><span data-stu-id="98d77-155">Reference assemblies structure</span></span>

<span data-ttu-id="98d77-156">Les assemblages de référence sont une expansion du concept connexe, *des assemblages de métadonnées seulement*.</span><span class="sxs-lookup"><span data-stu-id="98d77-156">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="98d77-157">Les assemblys de métadonnées uniquement ont leurs corps de méthode remplacés par un corps `throw null` unique, mais incluent tous les membres à l’exception des types anonymes.</span><span class="sxs-lookup"><span data-stu-id="98d77-157">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="98d77-158">La raison `throw null` de l’utilisation des corps (par opposition à aucun corps) est de sorte que **PEVerify** peut courir et passer (validant ainsi l’exhaustivité des métadonnées).</span><span class="sxs-lookup"><span data-stu-id="98d77-158">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="98d77-159">En outre, les assemblys de référence suppriment les métadonnées (membres privés) des assemblys de métadonnées uniquement :</span><span class="sxs-lookup"><span data-stu-id="98d77-159">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="98d77-160">Un assembly de référence a uniquement des références pour ce dont il a besoin dans la surface de l’API.</span><span class="sxs-lookup"><span data-stu-id="98d77-160">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="98d77-161">L’assembly réel peut avoir des références supplémentaires relatives à des implémentations spécifiques.</span><span class="sxs-lookup"><span data-stu-id="98d77-161">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="98d77-162">Par exemple, l’assemblage de référence pour `class C { private void M() { dynamic d = 1; ... } }` `dynamic`ne fait pas référence à tous les types requis pour .</span><span class="sxs-lookup"><span data-stu-id="98d77-162">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="98d77-163">Les membres de fonction privés (méthodes, propriétés et événements) sont supprimés si leur suppression n’affecte pas la compilation sensiblement.</span><span class="sxs-lookup"><span data-stu-id="98d77-163">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="98d77-164">S’il n’y a pas [d’attributs InternalsVisibleTo,](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) les membres de la fonction interne sont également supprimés.</span><span class="sxs-lookup"><span data-stu-id="98d77-164">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="98d77-165">Les métadonnées dans les assemblages de référence continuent de conserver les informations suivantes :</span><span class="sxs-lookup"><span data-stu-id="98d77-165">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="98d77-166">Tous types, y compris les types privés et imbriqués.</span><span class="sxs-lookup"><span data-stu-id="98d77-166">All types, including private and nested types.</span></span>
- <span data-ttu-id="98d77-167">Tous les attributs, même internes.</span><span class="sxs-lookup"><span data-stu-id="98d77-167">All attributes, even internal ones.</span></span>
- <span data-ttu-id="98d77-168">Toutes les méthodes virtuelles.</span><span class="sxs-lookup"><span data-stu-id="98d77-168">All virtual methods.</span></span>
- <span data-ttu-id="98d77-169">Implémentations d’interface explicites.</span><span class="sxs-lookup"><span data-stu-id="98d77-169">Explicit interface implementations.</span></span>
- <span data-ttu-id="98d77-170">Propriétés et événements explicitement mis en œuvre, parce que leurs accesseurs sont virtuels.</span><span class="sxs-lookup"><span data-stu-id="98d77-170">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="98d77-171">Tous les champs de structures.</span><span class="sxs-lookup"><span data-stu-id="98d77-171">All fields of structures.</span></span>

<span data-ttu-id="98d77-172">Les assemblages de référence comprennent un attribut [Dementassembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) au niveau de l’assemblage.</span><span class="sxs-lookup"><span data-stu-id="98d77-172">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="98d77-173">Cet attribut peut être spécifié dans la source; alors le compilateur n’aura pas besoin de le synthétiser.</span><span class="sxs-lookup"><span data-stu-id="98d77-173">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="98d77-174">En raison de cet attribut, les temps d’exécution refuseront de charger des assemblages de référence pour l’exécution (mais ils peuvent être chargés en mode réflexion seulement).</span><span class="sxs-lookup"><span data-stu-id="98d77-174">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="98d77-175">Les détails exacts de la structure d’assemblage de référence dépendent de la version compilateur.</span><span class="sxs-lookup"><span data-stu-id="98d77-175">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="98d77-176">Les versions plus nouvelles peuvent choisir d’exclure plus de métadonnées si elles sont déterminées comme n’affectant pas la surface publique de l’API.</span><span class="sxs-lookup"><span data-stu-id="98d77-176">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="98d77-177">Les informations contenues dans cette section ne s’appliquent qu’aux assemblages de référence générés par les compilateurs Roslyn à partir de la version 7.1 ou de la version 15.3 visual.</span><span class="sxs-lookup"><span data-stu-id="98d77-177">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="98d77-178">La structure des assemblages de référence pour les bibliothèques de base .NET et .NET peuvent différer dans certains détails, car elles utilisent leur propre mécanisme de génération d’assemblages de référence.</span><span class="sxs-lookup"><span data-stu-id="98d77-178">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="98d77-179">Par exemple, ils peuvent avoir des `throw null` corps de méthode totalement vides au lieu du corps.</span><span class="sxs-lookup"><span data-stu-id="98d77-179">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="98d77-180">Mais le principe général s’applique toujours : ils n’ont pas de mise en œuvre de méthode utilisable et ne contiennent des métadonnées que pour les membres qui ont un impact observable du point de vue de l’API public.</span><span class="sxs-lookup"><span data-stu-id="98d77-180">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="98d77-181">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="98d77-181">See also</span></span>

- [<span data-ttu-id="98d77-182">Assemblys dans .NET</span><span class="sxs-lookup"><span data-stu-id="98d77-182">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="98d77-183">Vue d’ensemble du ciblage des frameworks</span><span class="sxs-lookup"><span data-stu-id="98d77-183">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="98d77-184">Comment : Ajouter ou supprimer des références en utilisant le gestionnaire de référence</span><span class="sxs-lookup"><span data-stu-id="98d77-184">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
