---
title: Règles relatives à l'inférence de types simples
ms.date: 03/30/2017
ms.technology: dotnet-standard
ms.assetid: 394624d6-4da0-430a-8a88-46efe40f14de
ms.openlocfilehash: 571019d13433312a5d31f581c3527aae901bbba7
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/02/2020
ms.locfileid: "84289068"
---
# <a name="rules-for-inferring-simple-types"></a><span data-ttu-id="8601b-102">Règles relatives à l'inférence de types simples</span><span class="sxs-lookup"><span data-stu-id="8601b-102">Rules for Inferring Simple Types</span></span>
<span data-ttu-id="8601b-103">Décrit comment la classe <xref:System.Xml.Schema.XmlSchemaInference> déduit le type de données pour les attributs et les éléments.</span><span class="sxs-lookup"><span data-stu-id="8601b-103">Describes how the <xref:System.Xml.Schema.XmlSchemaInference> class infers the data type for attributes and elements.</span></span>  
  
 <span data-ttu-id="8601b-104">La classe <xref:System.Xml.Schema.XmlSchemaInference> déduit les types de données pour les attributs et les éléments comme types simples.</span><span class="sxs-lookup"><span data-stu-id="8601b-104">The <xref:System.Xml.Schema.XmlSchemaInference> class infers the data type for attributes and elements as simple types.</span></span> <span data-ttu-id="8601b-105">Cette section décrit les types déduits possibles, la manière dont plusieurs valeurs différentes sont rapprochées en un type simple et la manière dont les attributs de définition de schéma `xsi` sont gérés.</span><span class="sxs-lookup"><span data-stu-id="8601b-105">This section describes the potential inferred types, how multiple differing values are reconciled to a single type, and how schema-defining `xsi` attributes are handled.</span></span>  
  
## <a name="inferred-types"></a><span data-ttu-id="8601b-106">Types déduits</span><span class="sxs-lookup"><span data-stu-id="8601b-106">Inferred Types</span></span>  
 <span data-ttu-id="8601b-107">La classe <xref:System.Xml.Schema.XmlSchemaInference> déduit des valeurs d'éléments et d'attributs comme des types simples et inclut un type d'attribut dans le schéma qui en résulte.</span><span class="sxs-lookup"><span data-stu-id="8601b-107">The <xref:System.Xml.Schema.XmlSchemaInference> class infers element and attribute values as simple types and includes a type attribute in the resulting schema.</span></span> <span data-ttu-id="8601b-108">Tous les types déduits sont des types simples.</span><span class="sxs-lookup"><span data-stu-id="8601b-108">All inferred types are simple types.</span></span> <span data-ttu-id="8601b-109">Aucun type de base ni aucune facette n'est inclus dans le schéma résultant.</span><span class="sxs-lookup"><span data-stu-id="8601b-109">No base types or facets are included as part of the resulting schema.</span></span>  
  
 <span data-ttu-id="8601b-110">Les valeurs sont examinées individuellement, au fur et à mesure qu'elles sont rencontrées dans le document XML.</span><span class="sxs-lookup"><span data-stu-id="8601b-110">Values are examined individually as they are encountered in the XML document.</span></span> <span data-ttu-id="8601b-111">Le type est déduit pour une valeur au moment de son examen.</span><span class="sxs-lookup"><span data-stu-id="8601b-111">The type is inferred for a value at the time it is examined.</span></span> <span data-ttu-id="8601b-112">Si un type a été déduit pour un attribut ou un élément et si une valeur pour l'attribut ou l'élément est rencontrée, qui ne correspond pas au type actuellement déduit, la classe <xref:System.Xml.Schema.XmlSchemaInference> promeut le type pour chaque ensemble de règles.</span><span class="sxs-lookup"><span data-stu-id="8601b-112">If a type has been inferred for an attribute or element, and a value for the attribute or element is encountered that does not match the currently inferred type, the <xref:System.Xml.Schema.XmlSchemaInference> class promotes the type for each of a set of rules.</span></span> <span data-ttu-id="8601b-113">Ces règles sont présentées dans la section Promotion de type, plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="8601b-113">These rules are discussed in the Type Promotion section, later in this topic.</span></span>  
  
 <span data-ttu-id="8601b-114">Le tableau suivant répertorie les types déduits possibles pour le schéma résultant.</span><span class="sxs-lookup"><span data-stu-id="8601b-114">The following table lists the possible inferred types for the resulting schema.</span></span>  
  
|<span data-ttu-id="8601b-115">Type simple</span><span class="sxs-lookup"><span data-stu-id="8601b-115">Simple Type</span></span>|<span data-ttu-id="8601b-116">Description</span><span class="sxs-lookup"><span data-stu-id="8601b-116">Description</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="8601b-117">boolean</span><span class="sxs-lookup"><span data-stu-id="8601b-117">boolean</span></span>|<span data-ttu-id="8601b-118">True, false, 0, 1.</span><span class="sxs-lookup"><span data-stu-id="8601b-118">True, false, 0, 1.</span></span>|  
|<span data-ttu-id="8601b-119">byte</span><span class="sxs-lookup"><span data-stu-id="8601b-119">byte</span></span>|<span data-ttu-id="8601b-120">Nombres entiers dans la plage comprise entre -128 et 127.</span><span class="sxs-lookup"><span data-stu-id="8601b-120">Integers in the range of –128 to 127.</span></span>|  
|<span data-ttu-id="8601b-121">unsignedByte</span><span class="sxs-lookup"><span data-stu-id="8601b-121">unsignedByte</span></span>|<span data-ttu-id="8601b-122">Nombres entiers dans la plage comprise entre 0 et 255.</span><span class="sxs-lookup"><span data-stu-id="8601b-122">Integers in the range of 0 to 255.</span></span>|  
|<span data-ttu-id="8601b-123">short</span><span class="sxs-lookup"><span data-stu-id="8601b-123">short</span></span>|<span data-ttu-id="8601b-124">Nombres entiers dans la plage comprise entre -32768 et 32767.</span><span class="sxs-lookup"><span data-stu-id="8601b-124">Integers in the range of –32768 to 32767.</span></span>|  
|<span data-ttu-id="8601b-125">unsignedShort</span><span class="sxs-lookup"><span data-stu-id="8601b-125">unsignedShort</span></span>|<span data-ttu-id="8601b-126">Nombres entiers dans la plage comprise entre 0 et 65535.</span><span class="sxs-lookup"><span data-stu-id="8601b-126">Integers in the range of 0 to 65535.</span></span>|  
|<span data-ttu-id="8601b-127">int</span><span class="sxs-lookup"><span data-stu-id="8601b-127">int</span></span>|<span data-ttu-id="8601b-128">Nombres entiers dans la plage comprise entre -2147483648 et 2147483647.</span><span class="sxs-lookup"><span data-stu-id="8601b-128">Integers in the range of –2147483648 to 2147483647.</span></span>|  
|<span data-ttu-id="8601b-129">unsignedInt</span><span class="sxs-lookup"><span data-stu-id="8601b-129">unsignedInt</span></span>|<span data-ttu-id="8601b-130">Nombres entiers dans la plage comprise entre 0 et 4294967295.</span><span class="sxs-lookup"><span data-stu-id="8601b-130">Integers in the range of 0 to 4294967295.</span></span>|  
|<span data-ttu-id="8601b-131">long</span><span class="sxs-lookup"><span data-stu-id="8601b-131">long</span></span>|<span data-ttu-id="8601b-132">Nombres entiers dans la plage comprise entre -9223372036854775808 et 9223372036854775807.</span><span class="sxs-lookup"><span data-stu-id="8601b-132">Integers in the range of –9223372036854775808 to 9223372036854775807.</span></span>|  
|<span data-ttu-id="8601b-133">unsignedLong</span><span class="sxs-lookup"><span data-stu-id="8601b-133">unsignedLong</span></span>|<span data-ttu-id="8601b-134">Nombres entiers dans la plage comprise entre 0 et 18446744073709551615.</span><span class="sxs-lookup"><span data-stu-id="8601b-134">Integers in the range of 0 to 18446744073709551615.</span></span>|  
|<span data-ttu-id="8601b-135">entier</span><span class="sxs-lookup"><span data-stu-id="8601b-135">integer</span></span>|<span data-ttu-id="8601b-136">Nombre de chiffres fini éventuellement précédé du préfixe « - ».</span><span class="sxs-lookup"><span data-stu-id="8601b-136">A finite number of digits possibly prefixed with "-".</span></span>|  
|<span data-ttu-id="8601b-137">Décimal</span><span class="sxs-lookup"><span data-stu-id="8601b-137">decimal</span></span>|<span data-ttu-id="8601b-138">Valeurs numériques avec une précision de 0 à 28 chiffres.</span><span class="sxs-lookup"><span data-stu-id="8601b-138">Numerical values that contain from 0 to 28 digits of precision.</span></span>|  
|<span data-ttu-id="8601b-139">float</span><span class="sxs-lookup"><span data-stu-id="8601b-139">float</span></span>|<span data-ttu-id="8601b-140">Décimales éventuellement suivies de « E » ou « e » et d'une valeur entière représentant l'exposant.</span><span class="sxs-lookup"><span data-stu-id="8601b-140">Decimals optionally followed by "E" or "e" followed by an integer value representing the exponent.</span></span> <span data-ttu-id="8601b-141">Les valeurs décimales peuvent s'inscrire dans la plage comprise entre -16777216 et 16777216.</span><span class="sxs-lookup"><span data-stu-id="8601b-141">Decimal values can be in the range of -16777216 to 16777216.</span></span> <span data-ttu-id="8601b-142">Les valeurs d'exposant peuvent s'inscrire dans la plage comprise entre –149 et 104.</span><span class="sxs-lookup"><span data-stu-id="8601b-142">Exponent values can be in the range of –149 to 104.</span></span><br /><br /> <span data-ttu-id="8601b-143">Float permet d'utiliser des valeurs spéciales pour représenter des valeurs d'infinité et non numériques.</span><span class="sxs-lookup"><span data-stu-id="8601b-143">Float allows for special values to represent infinity and non-numeric values.</span></span> <span data-ttu-id="8601b-144">Les valeurs spéciales pour float sont : 0, -0, INF, -INF, NaN.</span><span class="sxs-lookup"><span data-stu-id="8601b-144">Special values for float are: 0, -0, INF, -INF, NaN.</span></span>|  
|<span data-ttu-id="8601b-145">double</span><span class="sxs-lookup"><span data-stu-id="8601b-145">double</span></span>|<span data-ttu-id="8601b-146">Comme pour float, sinon que les valeurs décimales peuvent s'inscrire dans la plage comprise entre -9007199254740992 et 9007199254740992. Les valeurs d'exposant peuvent s'inscrire dans la plage comprise entre –1075 et 970.</span><span class="sxs-lookup"><span data-stu-id="8601b-146">The same as float except decimal values can be in the range of -9007199254740992 to 9007199254740992, and exponent values can be in the range of –1075 to 970.</span></span><br /><br /> <span data-ttu-id="8601b-147">Double permet d'utiliser des valeurs spéciales pour représenter des valeurs d'infinité et non numériques.</span><span class="sxs-lookup"><span data-stu-id="8601b-147">Double allows for special values to represent infinity and non-numeric values.</span></span> <span data-ttu-id="8601b-148">Les valeurs spéciales pour float sont : 0, -0, INF, -INF, NaN.</span><span class="sxs-lookup"><span data-stu-id="8601b-148">Special values for float are: 0, -0, INF, -INF, NaN.</span></span>|  
|<span data-ttu-id="8601b-149">duration</span><span class="sxs-lookup"><span data-stu-id="8601b-149">duration</span></span>|<span data-ttu-id="8601b-150">Format de durée de W3C.</span><span class="sxs-lookup"><span data-stu-id="8601b-150">The W3C duration format.</span></span>|  
|<span data-ttu-id="8601b-151">dateTime</span><span class="sxs-lookup"><span data-stu-id="8601b-151">dateTime</span></span>|<span data-ttu-id="8601b-152">Le format de date et d'heure de W3C.</span><span class="sxs-lookup"><span data-stu-id="8601b-152">The W3C dateTime format.</span></span>|  
|<span data-ttu-id="8601b-153">time</span><span class="sxs-lookup"><span data-stu-id="8601b-153">time</span></span>|<span data-ttu-id="8601b-154">Le format d'heure de W3C.</span><span class="sxs-lookup"><span data-stu-id="8601b-154">The W3C time format.</span></span>|  
|<span data-ttu-id="8601b-155">Date</span><span class="sxs-lookup"><span data-stu-id="8601b-155">date</span></span>|<span data-ttu-id="8601b-156">Les valeurs d'année doivent être comprises entre 0001 et 9999.</span><span class="sxs-lookup"><span data-stu-id="8601b-156">Year values are restricted from 0001 to 9999.</span></span>|  
|<span data-ttu-id="8601b-157">gYearMonth</span><span class="sxs-lookup"><span data-stu-id="8601b-157">gYearMonth</span></span>|<span data-ttu-id="8601b-158">Format d'année et de mois du calendrier grégorien de W3C.</span><span class="sxs-lookup"><span data-stu-id="8601b-158">The W3C Gregorian month and year format.</span></span>|  
|<span data-ttu-id="8601b-159">string</span><span class="sxs-lookup"><span data-stu-id="8601b-159">string</span></span>|<span data-ttu-id="8601b-160">Un ou plusieurs caractères Unicode.</span><span class="sxs-lookup"><span data-stu-id="8601b-160">One or more Unicode characters.</span></span>|  
  
## <a name="type-promotion"></a><span data-ttu-id="8601b-161">Promotion de type</span><span class="sxs-lookup"><span data-stu-id="8601b-161">Type Promotion</span></span>  
 <span data-ttu-id="8601b-162">La classe <xref:System.Xml.Schema.XmlSchemaInference> examine les valeurs d'attributs et d'éléments l'une après l'autre.</span><span class="sxs-lookup"><span data-stu-id="8601b-162">The <xref:System.Xml.Schema.XmlSchemaInference> class examines attribute and element values one at a time.</span></span> <span data-ttu-id="8601b-163">Au fur et à mesure que des valeurs sont rencontrées, le type non signé le plus restrictif est déduit.</span><span class="sxs-lookup"><span data-stu-id="8601b-163">As values are encountered, the most restrictive, unsigned type is inferred.</span></span> <span data-ttu-id="8601b-164">Si un type a été déduit pour un attribut ou un élément et si une nouvelle valeur est rencontrée, qui ne correspond pas au type actuellement déduit, le type déduit est promu au rang de nouveau type qui s'applique au type actuellement déduit et à la nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="8601b-164">If a type has been inferred for an attribute or element, and a new value is encountered that does not match the currently inferred type, the inferred type is promoted to a new type that applies to both the currently inferred type and the new value.</span></span> <span data-ttu-id="8601b-165">La classe <xref:System.Xml.Schema.XmlSchemaInference> ne considère pas les valeurs précédentes lors de la promotion du type déduit.</span><span class="sxs-lookup"><span data-stu-id="8601b-165">The <xref:System.Xml.Schema.XmlSchemaInference> class does consider previous values when promoting the inferred type.</span></span>  
  
 <span data-ttu-id="8601b-166">Examinons, par exemple, les fragments XML suivants de deux documents XML :</span><span class="sxs-lookup"><span data-stu-id="8601b-166">For example, consider the following XML fragments from two XML documents:</span></span>  
  
 `<MyElement1 attr1="12" />`  
  
 `<MyElement1 attr1="52344" />`  
  
 <span data-ttu-id="8601b-167">Lorsque la première valeur `attr1` est rencontrée, le type de `attr1` est déduit comme `unsignedByte` sur la base de la valeur `12`.</span><span class="sxs-lookup"><span data-stu-id="8601b-167">When the first `attr1` value is encountered, the type of `attr1` is inferred as `unsignedByte` based on the value `12`.</span></span> <span data-ttu-id="8601b-168">Lorsque la seconde valeur `attr1` est rencontrée, le type est promu au rang de `unsignedShort` sur la base du type actuellement déduit de `unsignedByte` et de la valeur actuelle `52344`.</span><span class="sxs-lookup"><span data-stu-id="8601b-168">When the second `attr1` is encountered, the type is promoted to `unsignedShort` based on the currently inferred type of `unsignedByte` and the current value `52344`.</span></span>  
  
 <span data-ttu-id="8601b-169">Examinons, à présent, le code XML suivant de deux documents XML :</span><span class="sxs-lookup"><span data-stu-id="8601b-169">Now, consider the following XML from two XML documents:</span></span>  
  
 `<MyElement2 attr2="0" />`  
  
 `<MyElement2 attr2="true" />`  
  
 <span data-ttu-id="8601b-170">Lorsque la première valeur `attr2` est rencontrée, le type de `attr2` est déduit comme `unsignedByte` sur la base de la valeur `0`.</span><span class="sxs-lookup"><span data-stu-id="8601b-170">When the first `attr2` value is encountered, the type of `attr2` is inferred as `unsignedByte` based on the value `0`.</span></span> <span data-ttu-id="8601b-171">Lorsque la seconde valeur `attr2` est rencontrée, le type est promu au rang de `string` sur la base du type actuellement déduit de `unsignedByte` et de la valeur actuelle `true` parce que la classe <xref:System.Xml.Schema.XmlSchemaInference> prend en considération les valeurs précédents lors de la promotion du type déduit.</span><span class="sxs-lookup"><span data-stu-id="8601b-171">When the second `attr2` is encountered, the type is promoted to `string` based on the currently inferred type of `unsignedByte` and the current value `true` because the <xref:System.Xml.Schema.XmlSchemaInference> class does consider previous values when promoting the inferred type.</span></span> <span data-ttu-id="8601b-172">Toutefois, si les deux instances de `attr2` avaient été rencontrées dans le même document XML et pas dans deux documents XML différents, comme illustré ci-avant, `attr2` aurait été déduit comme `boolean`.</span><span class="sxs-lookup"><span data-stu-id="8601b-172">However, if both instances of `attr2` were encountered in the same XML document and not in two different XML documents as illustrated above, `attr2` would have been inferred as `boolean`.</span></span>  
  
### <a name="ignored-attributes-from-the-httpswwww3org2001xmlschema-instance-namespace"></a><span data-ttu-id="8601b-173">Attributs ignorés dans l’espace de noms <https://www.w3.org/2001/XMLSchema-instance></span><span class="sxs-lookup"><span data-stu-id="8601b-173">Ignored attributes from the <https://www.w3.org/2001/XMLSchema-instance> namespace</span></span>

<span data-ttu-id="8601b-174">Vous trouverez ci-après les attributs de définition du schéma qui sont ignorés durant l'inférence de schéma.</span><span class="sxs-lookup"><span data-stu-id="8601b-174">The following are schema-defining attributes that are ignored during schema inference.</span></span>  
  
|<span data-ttu-id="8601b-175">Attribut</span><span class="sxs-lookup"><span data-stu-id="8601b-175">Attribute</span></span>|<span data-ttu-id="8601b-176">Description</span><span class="sxs-lookup"><span data-stu-id="8601b-176">Description</span></span>|  
|---------------|-----------------|  
|`xsi:type`|<span data-ttu-id="8601b-177">Si un élément est rencontré avec un `xsi:type` spécifié, le `xsi:type` est ignoré.</span><span class="sxs-lookup"><span data-stu-id="8601b-177">If an element is encountered with `xsi:type` specified, the `xsi:type` is ignored.</span></span>|  
|`xsi:nil`|<span data-ttu-id="8601b-178">Si un élément avec un attribut `xsi:nil` est rencontré, sa déclaration d'élément dans le schéma déduit a la valeur `nillable="true"`.</span><span class="sxs-lookup"><span data-stu-id="8601b-178">If an element with an `xsi:nil` attribute is encountered, its element declaration in the inferred schema has the value of `nillable="true"`.</span></span> <span data-ttu-id="8601b-179">Un élément dont un attribut `xsi:nil` a la valeur `true` ne peut pas avoir d'éléments enfants.</span><span class="sxs-lookup"><span data-stu-id="8601b-179">An element with an `xsi:nil` attribute set to `true` cannot have child elements.</span></span>|  
|`xsi:schemaLocation`|<span data-ttu-id="8601b-180">Si `xsi:schemaLocation` est rencontré, il est ignoré.</span><span class="sxs-lookup"><span data-stu-id="8601b-180">If `xsi:schemaLocation` is encountered, it is ignored.</span></span>|  
|`xsi:noNamespaceSchemaLocation`|<span data-ttu-id="8601b-181">Si `xsi:noNamespaceSchemaLocation` est rencontré, il est ignoré.</span><span class="sxs-lookup"><span data-stu-id="8601b-181">If `xsi:noNamespaceSchemaLocation` is encountered, it is ignored.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="8601b-182">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="8601b-182">See also</span></span>

- [<span data-ttu-id="8601b-183">Modèle Objet du schéma (SOM) XML</span><span class="sxs-lookup"><span data-stu-id="8601b-183">XML Schema Object Model (SOM)</span></span>](xml-schema-object-model-som.md)
- [<span data-ttu-id="8601b-184">Inférence de schémas à partir de documents XML</span><span class="sxs-lookup"><span data-stu-id="8601b-184">Inferring Schemas from XML Documents</span></span>](inferring-schemas-from-xml-documents.md)
- [<span data-ttu-id="8601b-185">Règles pour l'inférence de types et de structure de nœud de schéma</span><span class="sxs-lookup"><span data-stu-id="8601b-185">Rules for Inferring Schema Node Types and Structure</span></span>](rules-for-inferring-schema-node-types-and-structure.md)
