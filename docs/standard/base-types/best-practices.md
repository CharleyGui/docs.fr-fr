---
title: Bonnes pratiques pour les expressions régulières dans .NET
description: Découvrez comment créer des expressions régulières effectives et efficaces dans .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
ms.openlocfilehash: 9b09f5a2505888c6154a58a3512c94c51f89295b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/15/2020
ms.locfileid: "77124420"
---
# <a name="best-practices-for-regular-expressions-in-net"></a><span data-ttu-id="ea469-103">Meilleures pratiques pour les expressions régulières en .NET</span><span class="sxs-lookup"><span data-stu-id="ea469-103">Best practices for regular expressions in .NET</span></span>

<span data-ttu-id="ea469-104">Le moteur d’expression régulière dans .NET est un outil puissant et complet. Il traite le texte en fonction de correspondances de modèle plutôt qu’en comparant et en faisant correspondre le texte littéral.</span><span class="sxs-lookup"><span data-stu-id="ea469-104">The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</span></span> <span data-ttu-id="ea469-105">Dans la plupart des cas, il exécute les critères spéciaux de façon rapide et efficace.</span><span class="sxs-lookup"><span data-stu-id="ea469-105">In most cases, it performs pattern matching rapidly and efficiently.</span></span> <span data-ttu-id="ea469-106">Toutefois, dans certains cas, le moteur des expressions régulières peut sembler très lent.</span><span class="sxs-lookup"><span data-stu-id="ea469-106">However, in some cases, the regular expression engine can appear to be very slow.</span></span> <span data-ttu-id="ea469-107">Dans des cas extrêmes, il semble même cesser de répondre. Il traite en effet peu d'entrées sur une période de plusieurs heures ou même de plusieurs jours.</span><span class="sxs-lookup"><span data-stu-id="ea469-107">In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</span></span>

<span data-ttu-id="ea469-108">Cette rubrique décrit quelques-unes des meilleures pratiques que les développeurs peuvent adopter afin de garantir que les expressions régulières atteignent des performances optimales.</span><span class="sxs-lookup"><span data-stu-id="ea469-108">This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</span></span>

## <a name="consider-the-input-source"></a><span data-ttu-id="ea469-109">Prise en compte de la source d’entrée</span><span class="sxs-lookup"><span data-stu-id="ea469-109">Consider the input source</span></span>

<span data-ttu-id="ea469-110">En général, les expressions régulières peuvent accepter deux types d'entrée : avec contrainte ou sans contrainte.</span><span class="sxs-lookup"><span data-stu-id="ea469-110">In general, regular expressions can accept two types of input: constrained or unconstrained.</span></span> <span data-ttu-id="ea469-111">L'entrée avec contrainte est un texte provenant d'une source fiable ou connue, et qui suit un format prédéfini.</span><span class="sxs-lookup"><span data-stu-id="ea469-111">Constrained input is text that originates from a known or reliable source and follows a predefined format.</span></span> <span data-ttu-id="ea469-112">L'entrée sans contrainte est un texte provenant d'une source non fiable, telle qu'un utilisateur web. Elle ne suit pas forcément un format prédéfini ou attendu.</span><span class="sxs-lookup"><span data-stu-id="ea469-112">Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</span></span>

<span data-ttu-id="ea469-113">Les modèles d'expressions régulières sont généralement écrits pour correspondre à une entrée valide.</span><span class="sxs-lookup"><span data-stu-id="ea469-113">Regular expression patterns are typically written to match valid input.</span></span> <span data-ttu-id="ea469-114">Autrement dit, les développeurs examinent le texte qu'ils souhaitent faire correspondre, puis ils écrivent un modèle d'expression régulière qui lui correspond.</span><span class="sxs-lookup"><span data-stu-id="ea469-114">That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</span></span> <span data-ttu-id="ea469-115">Les développeurs déterminent ensuite si ce modèle doit être corrigé ou approfondi en le testant à l'aide de plusieurs éléments d'entrée valides.</span><span class="sxs-lookup"><span data-stu-id="ea469-115">Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</span></span> <span data-ttu-id="ea469-116">Lorsque le modèle correspond à toutes les entrées valides supposées, il est déclaré prêt pour la production et peut être intégré à une application finale.</span><span class="sxs-lookup"><span data-stu-id="ea469-116">When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</span></span> <span data-ttu-id="ea469-117">Le modèle d'expression régulière est ainsi adapté à la mise en correspondance d'une entrée avec contrainte.</span><span class="sxs-lookup"><span data-stu-id="ea469-117">This makes a regular expression pattern suitable for matching constrained input.</span></span> <span data-ttu-id="ea469-118">Toutefois, il n'est pas adapté à la mise en correspondance d'une entrée sans contrainte.</span><span class="sxs-lookup"><span data-stu-id="ea469-118">However, it does not make it suitable for matching unconstrained input.</span></span>

<span data-ttu-id="ea469-119">Pour faire correspondre une entrée sans contrainte, une expression régulière doit pouvoir gérer efficacement trois types de texte :</span><span class="sxs-lookup"><span data-stu-id="ea469-119">To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</span></span>

- <span data-ttu-id="ea469-120">Texte correspondant au modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-120">Text that matches the regular expression pattern.</span></span>

- <span data-ttu-id="ea469-121">Texte ne correspondant pas au modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-121">Text that does not match the regular expression pattern.</span></span>

- <span data-ttu-id="ea469-122">Texte correspondant presque au modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-122">Text that nearly matches the regular expression pattern.</span></span>

<span data-ttu-id="ea469-123">Le dernier type de texte est problématique pour une expression régulière écrite pour gérer les entrées avec contrainte.</span><span class="sxs-lookup"><span data-stu-id="ea469-123">The last text type is especially problematic for a regular expression that has been written to handle constrained input.</span></span> <span data-ttu-id="ea469-124">Si cette expression régulière repose également sur une [rétroaction](../../../docs/standard/base-types/backtracking-in-regular-expressions.md) complète, le traitement d’un texte apparemment anodin par le moteur d’expression régulière risque d’être extrêmement long (dans certains cas, un grand nombre d’heures ou de jours).</span><span class="sxs-lookup"><span data-stu-id="ea469-124">If that regular expression also relies on extensive [backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</span></span>

> [!WARNING]
> <span data-ttu-id="ea469-125">L'exemple suivant utilise une expression régulière sujette à des rétroactions excessives et susceptible de rejeter des adresses e-mail valides.</span><span class="sxs-lookup"><span data-stu-id="ea469-125">The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</span></span> <span data-ttu-id="ea469-126">Vous ne devez pas l’utiliser dans une routine de validation d’e-mails.</span><span class="sxs-lookup"><span data-stu-id="ea469-126">You should not use it in an email validation routine.</span></span> <span data-ttu-id="ea469-127">Si vous souhaitez une expression régulière qui valide des adresses e-mail, consultez [Guide pratique : vérifier que des chaînes sont dans un format d’adresse e-mail valide](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="ea469-127">If you would like a regular expression that validates email addresses, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

<span data-ttu-id="ea469-128">Prenons l'exemple d'une expression régulière très fréquemment utilisée, mais extrêmement problématique, pour la validation de l'alias d'une adresse e-mail.</span><span class="sxs-lookup"><span data-stu-id="ea469-128">For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</span></span> <span data-ttu-id="ea469-129">L'expression régulière `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` est écrite pour traiter ce qui est considéré comme une adresse e-mail valide. Cette dernière se compose d'un caractère alphanumérique suivi de zéro, ou de plusieurs caractères (caractères alphanumériques, points ou traits d'union).</span><span class="sxs-lookup"><span data-stu-id="ea469-129">The regular expression `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</span></span> <span data-ttu-id="ea469-130">L'expression régulière doit se terminer par un caractère alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="ea469-130">The regular expression must end with an alphanumeric character.</span></span> <span data-ttu-id="ea469-131">Toutefois, comme illustré dans l'exemple suivant, bien que cette expression régulière gère facilement une entrée valide, elle s'avère particulièrement inefficace lorsqu'il s'agit de traiter une entrée presque valide.</span><span class="sxs-lookup"><span data-stu-id="ea469-131">However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]

<span data-ttu-id="ea469-132">Comme le montre la sortie de l'exemple, le moteur des expressions régulières traite l'alias de messagerie valide dans un intervalle de temps à peu près identique, indépendamment de sa longueur.</span><span class="sxs-lookup"><span data-stu-id="ea469-132">As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</span></span> <span data-ttu-id="ea469-133">En revanche, lorsque l'adresse e-mail presque valide comporte plus de cinq caractères, le temps de traitement est environ doublé pour chaque caractère supplémentaire de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="ea469-133">On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</span></span> <span data-ttu-id="ea469-134">Cela signifie qu'une chaîne de 28 caractères presque valide serait traitée en plus d'une heure et qu'une chaîne de 33 caractères presque valide serait traitée en un peu moins d'un jour.</span><span class="sxs-lookup"><span data-stu-id="ea469-134">This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</span></span>

<span data-ttu-id="ea469-135">Étant donné que cette expression régulière a été développée en prenant uniquement en considération le format de l'entrée à faire correspondre, elle ne tient pas compte des entrées qui ne correspondent pas au modèle.</span><span class="sxs-lookup"><span data-stu-id="ea469-135">Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</span></span> <span data-ttu-id="ea469-136">Une entrée sans contrainte correspondant presque au modèle d'expression régulière risque ainsi de nuire considérablement aux performances.</span><span class="sxs-lookup"><span data-stu-id="ea469-136">This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</span></span>

<span data-ttu-id="ea469-137">Pour résoudre ce problème, vous pouvez effectuer les opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="ea469-137">To solve this problem, you can do the following:</span></span>

- <span data-ttu-id="ea469-138">Lorsque vous développez un modèle, vous devez réfléchir à la manière dont la rétroaction peut affecter les performances du moteur des expressions régulières, en particulier si votre expression régulière est conçue pour traiter des entrées sans contrainte.</span><span class="sxs-lookup"><span data-stu-id="ea469-138">When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</span></span> <span data-ttu-id="ea469-139">Pour plus d’informations, consultez la section [Prendre en charge le retour en arrière.](#take-charge-of-backtracking)</span><span class="sxs-lookup"><span data-stu-id="ea469-139">For more information, see the [Take Charge of Backtracking](#take-charge-of-backtracking) section.</span></span>

- <span data-ttu-id="ea469-140">Testez intégralement votre expression régulière à l'aide d'entrées non valides et presque valides, ainsi que d'entrées valides.</span><span class="sxs-lookup"><span data-stu-id="ea469-140">Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</span></span> <span data-ttu-id="ea469-141">Pour générer de manière aléatoire une entrée pour une expression régulière spécifique, vous pouvez utiliser [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), l’outil d’exploration d’expressions régulières de Microsoft Research.</span><span class="sxs-lookup"><span data-stu-id="ea469-141">To generate input for a particular regular expression randomly, you can use [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), which is a regular expression exploration tool from Microsoft Research.</span></span>

## <a name="handle-object-instantiation-appropriately"></a><span data-ttu-id="ea469-142">Gestion correcte de l’instanciation d’objet</span><span class="sxs-lookup"><span data-stu-id="ea469-142">Handle object instantiation appropriately</span></span>

<span data-ttu-id="ea469-143">La classe <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> est au cœur du modèle d'objet d'expression régulière de .NET. Elle représente le moteur d’expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="ea469-143">At the heart of .NET’s regular expression object model is the <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class, which represents the regular expression engine.</span></span> <span data-ttu-id="ea469-144">Souvent, la façon dont le moteur <xref:System.Text.RegularExpressions.Regex> est utilisé est le facteur principal ayant un impact sur les performances des expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="ea469-144">Often, the single greatest factor that affects regular expression performance is the way in which the <xref:System.Text.RegularExpressions.Regex> engine is used.</span></span> <span data-ttu-id="ea469-145">La définition d’une expression régulière implique une association étroite entre le moteur des expressions régulières et un modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-145">Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</span></span> <span data-ttu-id="ea469-146">Ce processus est forcément onéreux, qu’il implique l’instanciation d’un objet <xref:System.Text.RegularExpressions.Regex> en passant à son constructeur un modèle d’expression régulière ou l’appel d’une méthode statique en lui passant le modèle d’expression régulière avec la chaîne à analyser.</span><span class="sxs-lookup"><span data-stu-id="ea469-146">That coupling process, whether it involves instantiating a <xref:System.Text.RegularExpressions.Regex> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</span></span>

> [!NOTE]
> <span data-ttu-id="ea469-147">Vous trouverez une présentation plus détaillée des répercussions sur les performances des expressions régulières interprétées et compilées sur la page [Optimiser les performances des expressions régulières, deuxième partie : prendre en charge le retour arrière](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) du blog de l'équipe BCL.</span><span class="sxs-lookup"><span data-stu-id="ea469-147">For a more detailed discussion of the performance implications of using interpreted and compiled regular expressions, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="ea469-148">Vous pouvez associer le moteur des expressions régulières à un modèle d’expression régulière spécifique, puis utiliser le moteur pour faire correspondre du texte de plusieurs façons :</span><span class="sxs-lookup"><span data-stu-id="ea469-148">You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</span></span>

- <span data-ttu-id="ea469-149">Vous pouvez appeler une méthode statique de critères spéciaux, comme <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ea469-149">You can call a static pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ea469-150">L'instanciation d'un objet d'expression régulière n'est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="ea469-150">This does not require instantiation of a regular expression object.</span></span>

- <span data-ttu-id="ea469-151">Vous pouvez instancier un objet <xref:System.Text.RegularExpressions.Regex> et appeler une méthode d'instance de critères spéciaux d'une expression régulière interprétée.</span><span class="sxs-lookup"><span data-stu-id="ea469-151">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of an interpreted regular expression.</span></span> <span data-ttu-id="ea469-152">Il s’agit de la méthode par défaut pour lier le moteur des expressions régulières à un modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-152">This is the default method for binding the regular expression engine to a regular expression pattern.</span></span> <span data-ttu-id="ea469-153">Elle se produit lorsqu'un objet <xref:System.Text.RegularExpressions.Regex> est instancié sans argument `options` incluant l'indicateur <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.</span><span class="sxs-lookup"><span data-stu-id="ea469-153">It results when a <xref:System.Text.RegularExpressions.Regex> object is instantiated without an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="ea469-154">Vous pouvez instancier un objet <xref:System.Text.RegularExpressions.Regex> et appeler une méthode d'instance de critères spéciaux d'une expression régulière compilée.</span><span class="sxs-lookup"><span data-stu-id="ea469-154">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of a compiled regular expression.</span></span> <span data-ttu-id="ea469-155">Les objets d’expression régulière représentent des modèles compilés lorsqu’un objet <xref:System.Text.RegularExpressions.Regex> est instancié avec un argument `options` incluant l’indicateur <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.</span><span class="sxs-lookup"><span data-stu-id="ea469-155">Regular expression objects represent compiled patterns when a <xref:System.Text.RegularExpressions.Regex> object is instantiated with an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="ea469-156">Vous pouvez créer un objet <xref:System.Text.RegularExpressions.Regex> qui a un usage spécial et qui est fortement couplé à un modèle d’expression régulière particulier, le compiler et l’enregistrer dans un assembly autonome.</span><span class="sxs-lookup"><span data-stu-id="ea469-156">You can create a special-purpose <xref:System.Text.RegularExpressions.Regex> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly.</span></span> <span data-ttu-id="ea469-157">Pour ce faire, appelez la méthode <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ea469-157">You do this by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="ea469-158">La façon dont vous appelez les méthodes de correspondance d'expression régulière peut avoir un impact significatif sur votre application.</span><span class="sxs-lookup"><span data-stu-id="ea469-158">The particular way in which you call regular expression matching methods can have a significant impact on your application.</span></span> <span data-ttu-id="ea469-159">Les sections suivantes expliquent quand utiliser les appels de méthode statique, les expressions régulières interprétées et les expressions régulières compilées afin d'améliorer les performances de votre application.</span><span class="sxs-lookup"><span data-stu-id="ea469-159">The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="ea469-160">La forme de l'appel de méthode (statique, interprétée, compilée) affecte les performances si une même expression régulière est utilisée à plusieurs reprises dans les appels de méthode, ou si une application entraîne l'utilisation intensive d'objets d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-160">The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</span></span>

### <a name="static-regular-expressions"></a><span data-ttu-id="ea469-161">Expressions régulières statiques</span><span class="sxs-lookup"><span data-stu-id="ea469-161">Static regular expressions</span></span>

<span data-ttu-id="ea469-162">Les méthodes d'expression régulière statiques sont recommandées pour éviter d'instancier à plusieurs reprises un objet d'expression régulière avec la même expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-162">Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</span></span> <span data-ttu-id="ea469-163">Contrairement aux modèles d’expression réguliers utilisés par les objets d’expression réguliers, soit les codes d’opération ou le langage intermédiaire Microsoft compilé (MSIL) à partir de modèles utilisés dans les appels de méthode statique est mis en cache en interne par le moteur d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-163">Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in static method calls is cached internally by the regular expression engine.</span></span>

<span data-ttu-id="ea469-164">Par exemple, un gestionnaire d'événements appelle fréquemment une autre méthode pour valider l'entrée d'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ea469-164">For example, an event handler frequently calls another method to validate user input.</span></span> <span data-ttu-id="ea469-165">Ceci se reflète dans le code suivant, dans lequel l'événement <xref:System.Windows.Forms.Button> d'un contrôle <xref:System.Windows.Forms.Control.Click> est utilisé pour appeler une méthode nommée `IsValidCurrency`, qui vérifie si l'utilisateur a entré un symbole monétaire suivi d'au moins un chiffre décimal.</span><span class="sxs-lookup"><span data-stu-id="ea469-165">This is reflected in the following code, in which a <xref:System.Windows.Forms.Button> control's <xref:System.Windows.Forms.Control.Click> event is used to call a method named `IsValidCurrency`, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]

<span data-ttu-id="ea469-166">L'exemple suivant illustre une implémentation très peu efficace de la méthode `IsValidCurrency`.</span><span class="sxs-lookup"><span data-stu-id="ea469-166">A very inefficient implementation of the `IsValidCurrency` method is shown in the following example.</span></span> <span data-ttu-id="ea469-167">Notez que chaque appel de méthode réinstancie un objet <xref:System.Text.RegularExpressions.Regex> avec le même modèle.</span><span class="sxs-lookup"><span data-stu-id="ea469-167">Note that each method call reinstantiates a <xref:System.Text.RegularExpressions.Regex> object with the same pattern.</span></span> <span data-ttu-id="ea469-168">Cela signifie ainsi que le modèle d’expression régulière doit être recompilé chaque fois que la méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="ea469-168">This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]

<span data-ttu-id="ea469-169">Vous devez remplacer ce code peu efficace par un appel à la méthode statique <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ea469-169">You should replace this inefficient code with a call to the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ea469-170">De cette manière, un objet <xref:System.Text.RegularExpressions.Regex> n'a pas besoin d'être instancié chaque fois que vous souhaitez appeler une méthode de critères spéciaux. En outre, le moteur des expressions régulières est alors en mesure de récupérer une version compilée de l'expression régulière depuis son cache.</span><span class="sxs-lookup"><span data-stu-id="ea469-170">This eliminates the need to instantiate a <xref:System.Text.RegularExpressions.Regex> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]

<span data-ttu-id="ea469-171">Par défaut, les 15 derniers modèles d’expressions régulières statiques utilisés récemment sont mis en cache.</span><span class="sxs-lookup"><span data-stu-id="ea469-171">By default, the last 15 most recently used static regular expression patterns are cached.</span></span> <span data-ttu-id="ea469-172">Pour les applications qui requièrent un plus grand nombre d'expressions régulières statiques mises en cache, la taille du cache peut être ajustée en définissant la propriété <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ea469-172">For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>

<span data-ttu-id="ea469-173">L'expression régulière `\p{Sc}+\s*\d+` utilisée dans cet exemple vérifie que la chaîne d'entrée se compose d'un symbole monétaire et d'au moins un chiffre décimal.</span><span class="sxs-lookup"><span data-stu-id="ea469-173">The regular expression `\p{Sc}+\s*\d+` that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</span></span> <span data-ttu-id="ea469-174">Le modèle est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="ea469-174">The pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="ea469-175">Modèle</span><span class="sxs-lookup"><span data-stu-id="ea469-175">Pattern</span></span>|<span data-ttu-id="ea469-176">Description</span><span class="sxs-lookup"><span data-stu-id="ea469-176">Description</span></span>|
|-------------|-----------------|
|`\p{Sc}+`|<span data-ttu-id="ea469-177">Mettre en correspondance un ou plusieurs caractères dans la catégorie Unicode symbole, devise.</span><span class="sxs-lookup"><span data-stu-id="ea469-177">Match one or more characters in the Unicode Symbol, Currency category.</span></span>|
|`\s*`|<span data-ttu-id="ea469-178">Correspond à zéro, un ou plusieurs espaces blancs.</span><span class="sxs-lookup"><span data-stu-id="ea469-178">Match zero or more white-space characters.</span></span>|
|`\d+`|<span data-ttu-id="ea469-179">Mettre en correspondance un ou plusieurs chiffres décimaux.</span><span class="sxs-lookup"><span data-stu-id="ea469-179">Match one or more decimal digits.</span></span>|

### <a name="interpreted-vs-compiled-regular-expressions"></a><span data-ttu-id="ea469-180">Expressions régulières interprétées ou compilées</span><span class="sxs-lookup"><span data-stu-id="ea469-180">Interpreted vs. compiled regular expressions</span></span>

<span data-ttu-id="ea469-181">Les modèles d’expressions régulières qui ne sont pas associés au moteur des expressions régulières par la spécification de l’option <xref:System.Text.RegularExpressions.RegexOptions.Compiled> sont interprétés.</span><span class="sxs-lookup"><span data-stu-id="ea469-181">Regular expression patterns that are not bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are interpreted.</span></span> <span data-ttu-id="ea469-182">Lorsqu'un objet d'expression régulière est instancié, le moteur des expressions régulières convertit l'expression régulière en un ensemble de codes d'opération.</span><span class="sxs-lookup"><span data-stu-id="ea469-182">When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</span></span> <span data-ttu-id="ea469-183">Lorsqu'une méthode d'instance est appelée, les codes d'opération sont convertis en langage MSIL et exécutés par le compilateur JIT.</span><span class="sxs-lookup"><span data-stu-id="ea469-183">When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</span></span> <span data-ttu-id="ea469-184">De même, lorsqu'une méthode d'expression régulière statique est appelée et que l'expression régulière ne peut pas être récupérée dans le cache, le moteur des expressions régulières convertit l'expression régulière en un ensemble de codes d'opération et les stocke dans le cache.</span><span class="sxs-lookup"><span data-stu-id="ea469-184">Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</span></span> <span data-ttu-id="ea469-185">Il convertit ensuite ces codes d'opération en langage MSIL afin que le compilateur JIT puisse les exécuter.</span><span class="sxs-lookup"><span data-stu-id="ea469-185">It then converts these operation codes to MSIL so that the JIT compiler can execute them.</span></span> <span data-ttu-id="ea469-186">Les expressions régulières interprétées réduisent le temps de démarrage, mais ralentissent le temps d'exécution.</span><span class="sxs-lookup"><span data-stu-id="ea469-186">Interpreted regular expressions reduce startup time at the cost of slower execution time.</span></span> <span data-ttu-id="ea469-187">Pour cette raison, il est préférable de les utiliser lorsque l'expression régulière est utilisée dans un nombre d'appels de méthode restreint, ou lorsque le nombre exact d'appels de méthodes d'expression régulière est inconnu, mais qu'il est supposé être petit.</span><span class="sxs-lookup"><span data-stu-id="ea469-187">Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</span></span> <span data-ttu-id="ea469-188">À mesure que le nombre d'appels de méthode augmente, le ralentissement de la vitesse d'exécution l'emporte sur l'amélioration des performances liée à la réduction du temps de démarrage.</span><span class="sxs-lookup"><span data-stu-id="ea469-188">As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</span></span>

<span data-ttu-id="ea469-189">Les modèles d’expressions régulières qui sont associés au moteur des expressions régulières par la spécification de l’option <xref:System.Text.RegularExpressions.RegexOptions.Compiled> sont compilés.</span><span class="sxs-lookup"><span data-stu-id="ea469-189">Regular expression patterns that are bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are compiled.</span></span> <span data-ttu-id="ea469-190">Cela signifie que, lorsqu'un objet d'expression régulière est instancié ou lorsqu'une méthode d'expression régulière statique est appelée et que l'expression régulière ne peut pas être récupérée dans le cache, le moteur des expressions régulières convertit l'expression régulière en un ensemble de codes d'opération intermédiaire, qu'il convertit ensuite en langage MSIL.</span><span class="sxs-lookup"><span data-stu-id="ea469-190">This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</span></span> <span data-ttu-id="ea469-191">Lorsqu'une méthode est appelée, le compilateur JIT exécute le MSIL.</span><span class="sxs-lookup"><span data-stu-id="ea469-191">When a method is called, the JIT compiler executes the MSIL.</span></span> <span data-ttu-id="ea469-192">Contrairement aux expressions régulières interprétées, les expressions régulières compilées augmentent le temps de démarrage, mais elles exécutent plus rapidement les méthodes de critères spéciaux individuelles.</span><span class="sxs-lookup"><span data-stu-id="ea469-192">In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</span></span> <span data-ttu-id="ea469-193">En conséquence, l'amélioration des performances due à la compilation de l'expression régulière augmente en fonction du nombre de méthodes d'expression régulières appelées.</span><span class="sxs-lookup"><span data-stu-id="ea469-193">As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</span></span>

<span data-ttu-id="ea469-194">Pour résumer, nous vous conseillons d'utiliser des expressions régulières interprétées lorsque vous appelez relativement peu souvent des méthodes d'expression régulières avec une expression régulière spécifique.</span><span class="sxs-lookup"><span data-stu-id="ea469-194">To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</span></span> <span data-ttu-id="ea469-195">Nous vous conseillons d'utiliser des expressions régulières compilées lorsque vous appelez relativement souvent des méthodes d'expression régulière avec une expression régulière spécifique.</span><span class="sxs-lookup"><span data-stu-id="ea469-195">You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</span></span> <span data-ttu-id="ea469-196">Il est difficile de déterminer le seuil exact auquel le ralentissement de la vitesse d'exécution des expressions normales interprétées l'emporte sur la réduction du temps de démarrage. Il est également difficile de déterminer le seuil auquel le ralentissement du temps de démarrage des expressions régulières compilées l'emporte sur l'amélioration des vitesses d'exécution.</span><span class="sxs-lookup"><span data-stu-id="ea469-196">The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</span></span> <span data-ttu-id="ea469-197">Différents facteurs doivent être pris en compte, notamment la complexité des expressions régulières et les données spécifiques qui sont traitées.</span><span class="sxs-lookup"><span data-stu-id="ea469-197">It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</span></span> <span data-ttu-id="ea469-198">Pour déterminer si ce sont les expressions régulières interprétées ou compilées qui offrent les meilleures performances pour votre scénario d'application spécifique, vous pouvez utiliser la classe <xref:System.Diagnostics.Stopwatch> pour comparer les durées d'exécution.</span><span class="sxs-lookup"><span data-stu-id="ea469-198">To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <xref:System.Diagnostics.Stopwatch> class to compare their execution times.</span></span>

<span data-ttu-id="ea469-199">L’exemple suivant compare les performances des expressions régulières compilées et interprétées sur la lecture des dix premières phrases et de toutes les phrases du texte de Theodore Dreiser, *The Financier*.</span><span class="sxs-lookup"><span data-stu-id="ea469-199">The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's *The Financier*.</span></span> <span data-ttu-id="ea469-200">Comme l'indique la sortie de l'exemple, lorsque les méthodes de correspondance d'expression régulière sont appelées seulement dix fois, une expression régulière interprétée offre de meilleures performances qu'une expression régulière compilée.</span><span class="sxs-lookup"><span data-stu-id="ea469-200">As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</span></span> <span data-ttu-id="ea469-201">Par contre, une expression régulière compilée offre de meilleures performances dans le cas d'un grand nombre d'appels (dans le cas présent, plus de 13 000).</span><span class="sxs-lookup"><span data-stu-id="ea469-201">However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]

<span data-ttu-id="ea469-202">Le modèle d'expression régulière utilisé dans l'exemple, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="ea469-202">The regular expression pattern used in the example, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, is defined as shown in the following table.</span></span>

|<span data-ttu-id="ea469-203">Modèle</span><span class="sxs-lookup"><span data-stu-id="ea469-203">Pattern</span></span>|<span data-ttu-id="ea469-204">Description</span><span class="sxs-lookup"><span data-stu-id="ea469-204">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="ea469-205">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="ea469-205">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="ea469-206">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="ea469-206">Match one or more word characters.</span></span>|
|<code>(\r?\n)&#124;,?\s)</code>|<span data-ttu-id="ea469-207">Mettre en correspondance un ou aucun retour chariot suivi d'un caractère de saut de ligne, ou une ou aucune virgule, suivie d'un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="ea469-207">Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</span></span>|
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|<span data-ttu-id="ea469-208">Mettre en correspondance zéro, une ou plusieurs occurrences d'un ou plusieurs caractères alphabétiques qui sont suivis par un ou aucun retour chariot et un caractère de saut de ligne, ou par une ou aucune virgule, suivie d'un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="ea469-208">Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</span></span>|
|`\w+`|<span data-ttu-id="ea469-209">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="ea469-209">Match one or more word characters.</span></span>|
|`[.?:;!]`|<span data-ttu-id="ea469-210">Mettre en correspondance un point, un point d'interrogation, deux-points, un point-virgule ou un point d'exclamation.</span><span class="sxs-lookup"><span data-stu-id="ea469-210">Match a period, question mark, colon, semicolon, or exclamation point.</span></span>|

### <a name="regular-expressions-compiled-to-an-assembly"></a><span data-ttu-id="ea469-211">Expressions régulières : Compilées à une assemblée</span><span class="sxs-lookup"><span data-stu-id="ea469-211">Regular expressions: Compiled to an assembly</span></span>

<span data-ttu-id="ea469-212">.NET permet également de créer un assembly contenant des expressions régulières compilées.</span><span class="sxs-lookup"><span data-stu-id="ea469-212">.NET also enables you to create an assembly that contains compiled regular expressions.</span></span> <span data-ttu-id="ea469-213">La baisse de performances des expressions régulières est alors ressentie au moment du design et non au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="ea469-213">This moves the performance hit of regular expression compilation from run time to design time.</span></span> <span data-ttu-id="ea469-214">Toutefois, cela engendre également un travail supplémentaire : vous devez définir les expressions régulières à l'avance et les compiler dans un assembly.</span><span class="sxs-lookup"><span data-stu-id="ea469-214">However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly.</span></span> <span data-ttu-id="ea469-215">Le compilateur peut ensuite référencer cet assembly lors de la compilation du code source qui utilise les expressions régulières de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="ea469-215">The compiler can then reference this assembly when compiling source code that uses the assembly’s regular expressions.</span></span> <span data-ttu-id="ea469-216">Chaque expression régulière compilée dans l'assembly est représentée par une classe qui dérive de <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="ea469-216">Each compiled regular expression in the assembly is represented by a class that derives from <xref:System.Text.RegularExpressions.Regex>.</span></span>

<span data-ttu-id="ea469-217">Pour compiler des expressions régulières dans un assembly, vous appelez la méthode <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> et vous lui passez un tableau d'objets <xref:System.Text.RegularExpressions.RegexCompilationInfo> représentant les expressions régulières à compiler, ainsi qu'un objet <xref:System.Reflection.AssemblyName> contenant des informations sur l'assembly à créer.</span><span class="sxs-lookup"><span data-stu-id="ea469-217">To compile regular expressions to an assembly, you call the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> method and pass it an array of <xref:System.Text.RegularExpressions.RegexCompilationInfo> objects that represent the regular expressions to be compiled, and an <xref:System.Reflection.AssemblyName> object that contains information about the assembly to be created.</span></span>

<span data-ttu-id="ea469-218">Nous vous conseillons de compiler les expressions régulières dans un assembly dans les situations suivantes :</span><span class="sxs-lookup"><span data-stu-id="ea469-218">We recommend that you compile regular expressions to an assembly in the following situations:</span></span>

- <span data-ttu-id="ea469-219">Vous êtes un développeur de composants et vous souhaitez créer une bibliothèque d'expressions régulières réutilisables.</span><span class="sxs-lookup"><span data-stu-id="ea469-219">If you are a component developer who wants to create a library of reusable regular expressions.</span></span>

- <span data-ttu-id="ea469-220">Vous savez que les méthodes de critères spéciaux de vos expression régulières seront appelées un nombre de fois indéterminé (entre une fois et des dizaines de milliers de fois).</span><span class="sxs-lookup"><span data-stu-id="ea469-220">If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times.</span></span> <span data-ttu-id="ea469-221">Contrairement aux expressions régulières compilées ou interprétées, les expressions régulières qui sont compilées dans des assemblys distincts offrent des performances homogènes, indépendamment du nombre d'appels de méthode.</span><span class="sxs-lookup"><span data-stu-id="ea469-221">Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</span></span>

<span data-ttu-id="ea469-222">Si vous utilisez des expressions régulières compilées pour optimiser les performances, vous ne devez pas utiliser la réflexion pour créer l’assembly, charger le moteur des expressions régulières et exécuter ses méthodes de critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="ea469-222">If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods.</span></span> <span data-ttu-id="ea469-223">Vous devez donc éviter de générer dynamiquement des modèles d’expressions régulières et spécifier les options de critères spéciaux (tels que des critères spéciaux de non respect de la casse) au moment de la création de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="ea469-223">This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created.</span></span> <span data-ttu-id="ea469-224">Vous devez également séparer le code qui crée l'assembly du code qui utilise l'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-224">It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</span></span>

<span data-ttu-id="ea469-225">L'exemple suivant montre comment créer un assembly qui contient une expression régulière compilée.</span><span class="sxs-lookup"><span data-stu-id="ea469-225">The following example shows how to create an assembly that contains a compiled regular expression.</span></span> <span data-ttu-id="ea469-226">Il crée une `RegexLib.dll` assemblée nommée avec `SentencePattern`une seule classe d’expression régulière, qui contient le modèle d’expression régulière correspondant à la phrase utilisé dans la section [Des expressions régulières interprétées par rapport à compilée.](#interpreted-vs-compiled-regular-expressions)</span><span class="sxs-lookup"><span data-stu-id="ea469-226">It creates an assembly named `RegexLib.dll` with a single regular expression class, `SentencePattern`, that contains the sentence-matching regular expression pattern used in the [Interpreted vs. Compiled Regular Expressions](#interpreted-vs-compiled-regular-expressions) section.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]

<span data-ttu-id="ea469-227">Lorsque l'exemple est compilé dans un exécutable et qu'il est exécuté, il crée un assembly nommé `RegexLib.dll`.</span><span class="sxs-lookup"><span data-stu-id="ea469-227">When the example is compiled to an executable and run, it creates an assembly named `RegexLib.dll`.</span></span> <span data-ttu-id="ea469-228">L'expression régulière est représentée par une classe nommée `Utilities.RegularExpressions.SentencePattern`, dérivée de <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="ea469-228">The regular expression is represented by a class named `Utilities.RegularExpressions.SentencePattern` that is derived from <xref:System.Text.RegularExpressions.Regex>.</span></span> <span data-ttu-id="ea469-229">L'exemple suivant utilise ensuite l'expression régulière compilée pour extraire les phrases du texte de Theodore Dreiser, *The Financier*.</span><span class="sxs-lookup"><span data-stu-id="ea469-229">The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's *The Financier*.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]

## <a name="take-charge-of-backtracking"></a><span data-ttu-id="ea469-230">Prise en charge de la rétroaction</span><span class="sxs-lookup"><span data-stu-id="ea469-230">Take charge of backtracking</span></span>

<span data-ttu-id="ea469-231">Normalement, le moteur des expressions régulières utilise une progression linéaire pour se déplacer dans une chaîne d’entrée et pour la comparer à un modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-231">Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</span></span> <span data-ttu-id="ea469-232">Toutefois, lorsque les quantificateurs indéterminés, `*`, `+` et `?`, par exemple, sont utilisés dans un modèle d’expression régulière, le moteur des expressions régulières peut abandonner une partie des correspondances partielles trouvées et revenir à un état précédemment enregistré pour trouver une correspondance pour le modèle entier.</span><span class="sxs-lookup"><span data-stu-id="ea469-232">However, when indeterminate quantifiers such as `*`, `+`, and `?` are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</span></span> <span data-ttu-id="ea469-233">Ce processus est appelé « rétroaction ».</span><span class="sxs-lookup"><span data-stu-id="ea469-233">This process is known as backtracking.</span></span>

> [!NOTE]
> <span data-ttu-id="ea469-234">Pour plus d'informations sur le retour arrière, consultez les pages [Informations sur le comportement des expressions régulières](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) et [Retour arrière](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="ea469-234">For more information on backtracking, see [Details of Regular Expression Behavior](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) and [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="ea469-235">Vous trouverez une présentation détaillée du retour arrière sur la page [Optimiser les performances des expressions régulières, deuxième partie : prendre en charge le retour arrière](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) du blog de l'équipe BCL.</span><span class="sxs-lookup"><span data-stu-id="ea469-235">For a detailed discussion of backtracking, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="ea469-236">La prise en charge de la rétroaction confère aux expressions régulières leur puissance et leur flexibilité.</span><span class="sxs-lookup"><span data-stu-id="ea469-236">Support for backtracking gives regular expressions power and flexibility.</span></span> <span data-ttu-id="ea469-237">La responsabilité de contrôle du fonctionnement du moteur des expressions régulières est alors confiée aux développeurs d'expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="ea469-237">It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</span></span> <span data-ttu-id="ea469-238">Souvent, les développeurs ne sont pas conscients de cette responsabilité. Leur utilisation incorrecte de la rétroaction ou leur dépendance vis-à-vis d'une rétroaction excessive a souvent un impact négatif très important sur les performances des expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="ea469-238">Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</span></span> <span data-ttu-id="ea469-239">Dans le pire des scénarios, la durée d'exécution peut doubler pour chaque caractère supplémentaire de la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="ea469-239">In a worst-case scenario, execution time can double for each additional character in the input string.</span></span> <span data-ttu-id="ea469-240">En réalité, lorsque la rétroaction est utilisée de manière excessive, il est facile de créer l'équivalent de programmation d'une boucle sans fin si l'entrée correspond presque au modèle d'expression régulière. Le moteur des expressions régulières peut alors traiter une chaîne d'entrée relativement courte en plusieurs heures, voire en plusieurs jours.</span><span class="sxs-lookup"><span data-stu-id="ea469-240">In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</span></span>

<span data-ttu-id="ea469-241">Les performances des applications sont souvent altérées par l'utilisation de la rétroaction, même si ce processus n'est pas essentiel pour une correspondance.</span><span class="sxs-lookup"><span data-stu-id="ea469-241">Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</span></span> <span data-ttu-id="ea469-242">Par exemple, l'expression régulière `\b\p{Lu}\w*\b` établit une correspondance entre tous les mots qui commencent par une majuscule, comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="ea469-242">For example, the regular expression `\b\p{Lu}\w*\b` matches all words that begin with an uppercase character, as the following table shows.</span></span>

|<span data-ttu-id="ea469-243">Modèle</span><span class="sxs-lookup"><span data-stu-id="ea469-243">Pattern</span></span>|<span data-ttu-id="ea469-244">Description</span><span class="sxs-lookup"><span data-stu-id="ea469-244">Description</span></span>|
|-|-|
|`\b`|<span data-ttu-id="ea469-245">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="ea469-245">Begin the match at a word boundary.</span></span>|
|`\p{Lu}`|<span data-ttu-id="ea469-246">Mettre en correspondance une majuscule.</span><span class="sxs-lookup"><span data-stu-id="ea469-246">Match an uppercase character.</span></span>|
|`\w*`|<span data-ttu-id="ea469-247">Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="ea469-247">Match zero or more word characters.</span></span>|
|`\b`|<span data-ttu-id="ea469-248">Terminer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="ea469-248">End the match at a word boundary.</span></span>|

<span data-ttu-id="ea469-249">Étant donné qu'une limite de mot est différente d'un caractère alphabétique et qu'elle n'est pas un sous-ensemble de ce dernier, il est impossible que le moteur des expressions régulières franchisse une limite de mot lors de la mise en correspondance de caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="ea469-249">Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</span></span> <span data-ttu-id="ea469-250">Cela signifie que, pour cette expression régulière, une rétroaction ne peut jamais contribuer à la réussite globale d'une correspondance. Elle risque en revanche de diminuer les performances, étant donné que le moteur des expressions régulières doit impérativement enregistrer sont état pour chaque correspondance préliminaire d'un caractère alphabétique trouvée.</span><span class="sxs-lookup"><span data-stu-id="ea469-250">This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</span></span>

<span data-ttu-id="ea469-251">Si vous déterminez qu’un retour en arrière n’est pas nécessaire, vous pouvez le désactiver en utilisant l’élément de langue, connu sous le `(?>subexpression)` nom de groupe atomique.</span><span class="sxs-lookup"><span data-stu-id="ea469-251">If you determine that backtracking is not necessary, you can disable it by using the `(?>subexpression)` language element, known as an atomic group.</span></span> <span data-ttu-id="ea469-252">L'exemple suivant analyse une chaîne d'entrée à l'aide de deux expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="ea469-252">The following example parses an input string by using two regular expressions.</span></span> <span data-ttu-id="ea469-253">La première, `\b\p{Lu}\w*\b`, utilise la rétroaction.</span><span class="sxs-lookup"><span data-stu-id="ea469-253">The first, `\b\p{Lu}\w*\b`, relies on backtracking.</span></span> <span data-ttu-id="ea469-254">La seconde, `\b\p{Lu}(?>\w*)\b`, désactive la rétroaction.</span><span class="sxs-lookup"><span data-stu-id="ea469-254">The second, `\b\p{Lu}(?>\w*)\b`, disables backtracking.</span></span> <span data-ttu-id="ea469-255">Comme l'indique la sortie de l'exemple, les résultats obtenus sont identiques.</span><span class="sxs-lookup"><span data-stu-id="ea469-255">As the output from the example shows, they both produce the same result.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]

<span data-ttu-id="ea469-256">Dans de nombreux cas, la rétroaction est essentielle pour faire correspondre un modèle d’expression régulière à un texte d’entrée.</span><span class="sxs-lookup"><span data-stu-id="ea469-256">In many cases, backtracking is essential for matching a regular expression pattern to input text.</span></span> <span data-ttu-id="ea469-257">Toutefois, une rétroaction excessive risque d'altérer considérablement les performances et de donner l'impression qu'une application a cessé de répondre.</span><span class="sxs-lookup"><span data-stu-id="ea469-257">However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</span></span> <span data-ttu-id="ea469-258">Cela se produit notamment lorsque les quantificateurs sont imbriqués et que le texte correspondant à la sous-expression externe est un sous-ensemble du texte correspondant à la sous-expression interne.</span><span class="sxs-lookup"><span data-stu-id="ea469-258">In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</span></span>

> [!WARNING]
> <span data-ttu-id="ea469-259">En plus d’éviter une rétroaction excessive, vous devez utiliser la fonctionnalité de délai d’attente pour garantir qu’une rétroaction excessive n’altère pas considérablement les performances des expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="ea469-259">In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</span></span> <span data-ttu-id="ea469-260">Pour plus d’informations, consultez la section [Valeurs d’utilisation.](#use-time-out-values)</span><span class="sxs-lookup"><span data-stu-id="ea469-260">For more information, see the [Use Time-out Values](#use-time-out-values) section.</span></span>

<span data-ttu-id="ea469-261">Par exemple, le modèle d'expression régulière `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` est conçu pour mettre en correspondance un numéro de référence composé d'au moins un caractère alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="ea469-261">For example, the regular expression pattern `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` is intended to match a part number that consists of at least one alphanumeric character.</span></span> <span data-ttu-id="ea469-262">Tous les caractères supplémentaires peuvent être composés d'un caractère alphanumérique, d'un trait d'union, d'un trait de soulignement ou d'un point. Toutefois, le dernier caractère doit impérativement être alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="ea469-262">Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</span></span> <span data-ttu-id="ea469-263">Un signe dollar termine le numéro de référence.</span><span class="sxs-lookup"><span data-stu-id="ea469-263">A dollar sign terminates the part number.</span></span> <span data-ttu-id="ea469-264">Dans certains cas, ce modèle d'expression régulière peut présenter des performances médiocres, si les quantificateurs sont imbriqués et que la sous-expression `[0-9A-Z]` est un sous-ensemble de la sous-expression `[-.\w]*`.</span><span class="sxs-lookup"><span data-stu-id="ea469-264">In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression `[0-9A-Z]` is a subset of the subexpression `[-.\w]*`.</span></span>

<span data-ttu-id="ea469-265">Dans ces cas, vous pouvez optimiser les performances des expressions régulières en supprimant les quantificateurs imbriqués et en remplaçant la sous-expression externe par une assertion de préanalyse ou de postanalyse de largeur nulle.</span><span class="sxs-lookup"><span data-stu-id="ea469-265">In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</span></span> <span data-ttu-id="ea469-266">Les assertions de préanalyse et de postanalyse sont des points d'ancrage. Elles ne déplacent pas le pointeur dans la chaîne d'entrée, mais elles vérifient en amont et en aval si une condition spécifiée est remplie.</span><span class="sxs-lookup"><span data-stu-id="ea469-266">Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</span></span> <span data-ttu-id="ea469-267">Par exemple, l'expression régulière de numéro de référence peut être réécrite sous la forme `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span><span class="sxs-lookup"><span data-stu-id="ea469-267">For example, the part number regular expression can be rewritten as `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span></span> <span data-ttu-id="ea469-268">Ce modèle d'expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="ea469-268">This regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="ea469-269">Modèle</span><span class="sxs-lookup"><span data-stu-id="ea469-269">Pattern</span></span>|<span data-ttu-id="ea469-270">Description</span><span class="sxs-lookup"><span data-stu-id="ea469-270">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="ea469-271">Commencer la correspondance au début de la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="ea469-271">Begin the match at the beginning of the input string.</span></span>|
|`[0-9A-Z]`|<span data-ttu-id="ea469-272">Mettre en correspondance un caractère alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="ea469-272">Match an alphanumeric character.</span></span> <span data-ttu-id="ea469-273">Le numéro de référence doit au minimum comporter ce caractère.</span><span class="sxs-lookup"><span data-stu-id="ea469-273">The part number must consist of at least this character.</span></span>|
|`[-.\w]*`|<span data-ttu-id="ea469-274">Mettre en correspondance zéro, une ou plusieurs occurrences de tout caractère alphabétique, trait d'union ou point.</span><span class="sxs-lookup"><span data-stu-id="ea469-274">Match zero or more occurrences of any word character, hyphen, or period.</span></span>|
|`\$`|<span data-ttu-id="ea469-275">Mettre en correspondance un signe dollar.</span><span class="sxs-lookup"><span data-stu-id="ea469-275">Match a dollar sign.</span></span>|
|`(?<=[0-9A-Z])`|<span data-ttu-id="ea469-276">Effectuer une préanalyse avancée du signe dollar de fin de s'assurer que le caractère précédent est un caractère alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="ea469-276">Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</span></span>|
|`$`|<span data-ttu-id="ea469-277">Terminer la correspondance à la fin de la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="ea469-277">End the match at the end of the input string.</span></span>|

<span data-ttu-id="ea469-278">L'exemple suivant illustre l'utilisation de cette expression régulière pour faire correspondre un tableau pouvant contenir des numéros de référence potentiels.</span><span class="sxs-lookup"><span data-stu-id="ea469-278">The following example illustrates the use of this regular expression to match an array containing possible part numbers.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]

<span data-ttu-id="ea469-279">Le langage d’expression régulière dans .NET comprend les éléments de langage suivants, que vous pouvez utiliser pour éliminer les quantificateurs imbriqués.</span><span class="sxs-lookup"><span data-stu-id="ea469-279">The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</span></span> <span data-ttu-id="ea469-280">Pour plus d’informations, consultez [Constructions de regroupement](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="ea469-280">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

|<span data-ttu-id="ea469-281">Élément du langage</span><span class="sxs-lookup"><span data-stu-id="ea469-281">Language element</span></span>|<span data-ttu-id="ea469-282">Description</span><span class="sxs-lookup"><span data-stu-id="ea469-282">Description</span></span>|
|----------------------|-----------------|
|<span data-ttu-id="ea469-283">`(?=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="ea469-283">`(?=` `subexpression` `)`</span></span>|<span data-ttu-id="ea469-284">Préanalyse positive de largeur nulle.</span><span class="sxs-lookup"><span data-stu-id="ea469-284">Zero-width positive lookahead.</span></span> <span data-ttu-id="ea469-285">Effectuer une préanalyse de la position actuelle pour déterminer si `subexpression` correspond à la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="ea469-285">Look ahead of the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="ea469-286">`(?!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="ea469-286">`(?!` `subexpression` `)`</span></span>|<span data-ttu-id="ea469-287">Préanalyse négative de largeur nulle.</span><span class="sxs-lookup"><span data-stu-id="ea469-287">Zero-width negative lookahead.</span></span> <span data-ttu-id="ea469-288">Effectuer une préanalyse de la position actuelle pour déterminer si `subexpression` ne correspond pas à la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="ea469-288">Look ahead of the current position to determine whether `subexpression` does not match the input string.</span></span>|
|<span data-ttu-id="ea469-289">`(?<=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="ea469-289">`(?<=` `subexpression` `)`</span></span>|<span data-ttu-id="ea469-290">Postanalyse positive de largeur nulle.</span><span class="sxs-lookup"><span data-stu-id="ea469-290">Zero-width positive lookbehind.</span></span> <span data-ttu-id="ea469-291">Effectuer une postanalyse de la position actuelle pour déterminer si `subexpression` correspond à la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="ea469-291">Look behind the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="ea469-292">`(?<!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="ea469-292">`(?<!` `subexpression` `)`</span></span>|<span data-ttu-id="ea469-293">Postanalyse négative de largeur nulle.</span><span class="sxs-lookup"><span data-stu-id="ea469-293">Zero-width negative lookbehind.</span></span> <span data-ttu-id="ea469-294">Effectuer une postanalyse de la position actuelle pour déterminer si `subexpression` ne correspond pas à la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="ea469-294">Look behind the current position to determine whether `subexpression` does not match the input string.</span></span>|

## <a name="use-time-out-values"></a><span data-ttu-id="ea469-295">Utilisation de valeurs de délai d’attente</span><span class="sxs-lookup"><span data-stu-id="ea469-295">Use time-out values</span></span>

<span data-ttu-id="ea469-296">Si une expression régulière traite une entrée qui correspond presque au modèle d'expression régulière, elle peut souvent se baser sur une rétroaction excessive, laquelle affecte considérablement ses performances.</span><span class="sxs-lookup"><span data-stu-id="ea469-296">If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</span></span> <span data-ttu-id="ea469-297">En plus d'envisager soigneusement l'utilisation de la rétroaction et de tester l'expression régulière sur une entrée presque correspondante, vous devez toujours définir une valeur de délai d'attente pour garantir la minimalisation de l'impact d'une rétroaction excessive, le cas échéant.</span><span class="sxs-lookup"><span data-stu-id="ea469-297">In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</span></span>

<span data-ttu-id="ea469-298">L’intervalle de temps d’arrêt d’expression régulier définit la période de temps que le moteur d’expression régulière cherchera une seule correspondance avant qu’il ne s’avère. L’intervalle de temps <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>d’exécution par défaut est, ce qui signifie que l’expression régulière ne s’évanouira pas. Vous pouvez remplacer cette valeur et définir un intervalle de temps d’exécution comme suit :</span><span class="sxs-lookup"><span data-stu-id="ea469-298">The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</span></span>

- <span data-ttu-id="ea469-299">En fournissant une valeur de délai d'attente quand vous instanciez un objet <xref:System.Text.RegularExpressions.Regex> en appelant le constructeur <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ea469-299">By providing a time-out value when you instantiate a <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span>

- <span data-ttu-id="ea469-300">En appelant une méthode de mise en correspondance de modèles statique, telle que <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> ou <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, qui inclut un paramètre `matchTimeout`.</span><span class="sxs-lookup"><span data-stu-id="ea469-300">By calling a static pattern matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, that includes a `matchTimeout` parameter.</span></span>

- <span data-ttu-id="ea469-301">Pour les expressions régulières compilées qui sont créées en appelant la méthode <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>, en appelant le constructeur ayant un paramètre de type <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="ea469-301">For compiled regular expressions that are created by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, by calling the constructor that has a parameter of type <xref:System.TimeSpan>.</span></span>

<span data-ttu-id="ea469-302">Si vous avez défini un délai d'attente et qu'aucune correspondance n'est trouvée à la fin de cet intervalle, la méthode d'expression régulière lève une exception <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="ea469-302">If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="ea469-303">Dans votre gestionnaire d'exceptions, vous pouvez choisir de réessayer la mise en correspondance avec un délai d'attente plus long, d'annuler la recherche de correspondance et de supposer l'absence de correspondance, ou encore d'annuler la recherche de correspondance et de consigner les informations sur les exceptions à des fins d'analyse ultérieure.</span><span class="sxs-lookup"><span data-stu-id="ea469-303">In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</span></span>

<span data-ttu-id="ea469-304">L'exemple ci-dessous définit une méthode `GetWordData` qui instancie une expression régulière avec un délai d'attente de 350 millisecondes pour calculer le nombre de mots dans un document texte et le nombre moyen de caractères par mot.</span><span class="sxs-lookup"><span data-stu-id="ea469-304">The following example defines a `GetWordData` method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</span></span> <span data-ttu-id="ea469-305">Si le délai d'attente de l'opération de recherche de correspondance expire, le délai d'attente augmente de 350 millisecondes et l'objet <xref:System.Text.RegularExpressions.Regex> est réinstancié.</span><span class="sxs-lookup"><span data-stu-id="ea469-305">If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <xref:System.Text.RegularExpressions.Regex> object is re-instantiated.</span></span> <span data-ttu-id="ea469-306">Si le nouveau délai d'attente dépasse 1 seconde, la méthode lève de nouveau l'exception pour l'appelant.</span><span class="sxs-lookup"><span data-stu-id="ea469-306">If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]

## <a name="capture-only-when-necessary"></a><span data-ttu-id="ea469-307">Capture uniquement quand cela s’avère nécessaire</span><span class="sxs-lookup"><span data-stu-id="ea469-307">Capture only when necessary</span></span>

<span data-ttu-id="ea469-308">Les expressions régulières dans .NET prennent en charge plusieurs constructions de regroupement, ce qui vous permet de regrouper un modèle d’expression régulière dans une ou plusieurs sous-expressions.</span><span class="sxs-lookup"><span data-stu-id="ea469-308">Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</span></span> <span data-ttu-id="ea469-309">Les constructions de groupement les plus couramment `(`utilisées dans le langage d’expression régulière .NET sont *la sous-expression*`)`, qui définit un groupe de capture numéroté, et `(?<`*la sous-expression*`)` *de nom*`>`, qui définit un groupe de capture nommé.</span><span class="sxs-lookup"><span data-stu-id="ea469-309">The most commonly used grouping constructs in .NET regular expression language are `(`*subexpression*`)`, which defines a numbered capturing group, and `(?<`*name*`>`*subexpression*`)`, which defines a named capturing group.</span></span> <span data-ttu-id="ea469-310">Les constructions de regroupement sont essentielles pour créer des références arrières et pour définir une sous-expression à laquelle un quantificateur est appliqué.</span><span class="sxs-lookup"><span data-stu-id="ea469-310">Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</span></span>

<span data-ttu-id="ea469-311">Toutefois, l'utilisation de ces éléments de langage n'est pas sans effet.</span><span class="sxs-lookup"><span data-stu-id="ea469-311">However, the use of these language elements has a cost.</span></span> <span data-ttu-id="ea469-312">Ils entraînent le remplissage de l'objet <xref:System.Text.RegularExpressions.GroupCollection> renvoyé par la propriété <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> avec les captures nommées ou sans nom les plus récentes. Si une seule construction de regroupement a capturé plusieurs sous-chaînes dans la chaîne d'entrée, elles remplissent également l'objet <xref:System.Text.RegularExpressions.CaptureCollection> renvoyé par la propriété <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> d'un groupe de capture particulier à l'aide de plusieurs objets <xref:System.Text.RegularExpressions.Capture>.</span><span class="sxs-lookup"><span data-stu-id="ea469-312">They cause the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property of a particular capturing group with multiple <xref:System.Text.RegularExpressions.Capture> objects.</span></span>

<span data-ttu-id="ea469-313">Souvent, les constructions de regroupement sont utilisées dans une expression régulière uniquement pour que les quantificateurs puissent leur être appliqués. Les groupes capturés par ces sous-expressions ne sont alors pas utilisés par la suite.</span><span class="sxs-lookup"><span data-stu-id="ea469-313">Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</span></span> <span data-ttu-id="ea469-314">Par exemple, l'expression régulière `\b(\w+[;,]?\s?)+[.?!]` est conçue pour capturer une phrase entière.</span><span class="sxs-lookup"><span data-stu-id="ea469-314">For example, the regular expression `\b(\w+[;,]?\s?)+[.?!]` is designed to capture an entire sentence.</span></span> <span data-ttu-id="ea469-315">Le tableau suivant décrit les éléments de langage dans ce modèle d'expression régulière et leur effet sur les <xref:System.Text.RegularExpressions.Match> des objets <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> et les collections <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ea469-315">The following table describes the language elements in this regular expression pattern and their effect on the <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collections.</span></span>

|<span data-ttu-id="ea469-316">Modèle</span><span class="sxs-lookup"><span data-stu-id="ea469-316">Pattern</span></span>|<span data-ttu-id="ea469-317">Description</span><span class="sxs-lookup"><span data-stu-id="ea469-317">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="ea469-318">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="ea469-318">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="ea469-319">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="ea469-319">Match one or more word characters.</span></span>|
|`[;,]?`|<span data-ttu-id="ea469-320">Mettre en correspondance zéro ou une virgule, ou zéro ou un point-virgule.</span><span class="sxs-lookup"><span data-stu-id="ea469-320">Match zero or one comma or semicolon.</span></span>|
|`\s?`|<span data-ttu-id="ea469-321">Mettre en correspondance zéro ou un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="ea469-321">Match zero or one white-space character.</span></span>|
|`(\w+[;,]?\s?)+`|<span data-ttu-id="ea469-322">Mettre en correspondance une ou plusieurs occurrences d'un ou plusieurs caractères alphabétiques suivis d'une virgule ou d'un point-virgule facultatif suivi d'un espace blanc facultatif.</span><span class="sxs-lookup"><span data-stu-id="ea469-322">Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</span></span> <span data-ttu-id="ea469-323">Cela définit le premier groupe de capture. Il est nécessaire pour que la combinaison de plusieurs caractères alphabétiques (autrement dit, un mot) suivis d'un signe de ponctuation facultatif soit répétée jusqu'à ce que le moteur des expressions régulières ait atteint la fin d'une phrase.</span><span class="sxs-lookup"><span data-stu-id="ea469-323">This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</span></span>|
|`[.?!]`|<span data-ttu-id="ea469-324">Mettre en correspondance un point, un point d'interrogation ou un point d'exclamation.</span><span class="sxs-lookup"><span data-stu-id="ea469-324">Match a period, question mark, or exclamation point.</span></span>|

<span data-ttu-id="ea469-325">Comme l'indique l'exemple suivant, lorsqu'une correspondance est trouvée, l'objet <xref:System.Text.RegularExpressions.GroupCollection> et l'objet <xref:System.Text.RegularExpressions.CaptureCollection> sont remplis avec des captures de la correspondance.</span><span class="sxs-lookup"><span data-stu-id="ea469-325">As the following example shows, when a match is found, both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> objects are populated with captures from the match.</span></span> <span data-ttu-id="ea469-326">Dans ce cas, le groupe de capture `(\w+[;,]?\s?)` existe afin que le quantificateur `+` puisse lui être appliqué, ce qui permet au modèle d'expression régulière de correspondre à chaque mot d'une phrase.</span><span class="sxs-lookup"><span data-stu-id="ea469-326">In this case, the capturing group `(\w+[;,]?\s?)` exists so that the `+` quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</span></span> <span data-ttu-id="ea469-327">Sinon, elle correspondrait au dernier mot d'une phrase.</span><span class="sxs-lookup"><span data-stu-id="ea469-327">Otherwise, it would match the last word in a sentence.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]

<span data-ttu-id="ea469-328">Lorsque vous utilisez des sous-expressions uniquement pour y appliquer des quantificateurs et que le texte capturé ne vous intéresse pas, vous devez désactiver les captures de groupe.</span><span class="sxs-lookup"><span data-stu-id="ea469-328">When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</span></span> <span data-ttu-id="ea469-329">Par exemple, l'élément de langage `(?:subexpression)` empêche le groupe auquel il s'applique de capturer les sous-chaînes correspondantes.</span><span class="sxs-lookup"><span data-stu-id="ea469-329">For example, the `(?:subexpression)` language element prevents the group to which it applies from capturing matched substrings.</span></span> <span data-ttu-id="ea469-330">Dans l'exemple suivant, le modèle d'expression régulière de l'exemple précédent est remplacé par `\b(?:\w+[;,]?\s?)+[.?!]`.</span><span class="sxs-lookup"><span data-stu-id="ea469-330">In the following example, the regular expression pattern from the previous example is changed to `\b(?:\w+[;,]?\s?)+[.?!]`.</span></span> <span data-ttu-id="ea469-331">Comme l'indique la sortie, le moteur des expressions régulières ne peut pas remplir les collections <xref:System.Text.RegularExpressions.GroupCollection> et <xref:System.Text.RegularExpressions.CaptureCollection>.</span><span class="sxs-lookup"><span data-stu-id="ea469-331">As the output shows, it prevents the regular expression engine from populating the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collections.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]

<span data-ttu-id="ea469-332">Vous pouvez désactiver les captures de l'une des façons suivantes :</span><span class="sxs-lookup"><span data-stu-id="ea469-332">You can disable captures in one of the following ways:</span></span>

- <span data-ttu-id="ea469-333">Utilisez l'élément de langage `(?:subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="ea469-333">Use the `(?:subexpression)` language element.</span></span> <span data-ttu-id="ea469-334">Cet élément empêche la capture des sous-chaînes correspondantes dans le groupe auquel il s'applique.</span><span class="sxs-lookup"><span data-stu-id="ea469-334">This element prevents the capture of matched substrings in the group to which it applies.</span></span> <span data-ttu-id="ea469-335">Il ne désactive pas les captures de la sous-chaîne dans les groupes imbriqués.</span><span class="sxs-lookup"><span data-stu-id="ea469-335">It does not disable substring captures in any nested groups.</span></span>

- <span data-ttu-id="ea469-336">Utilisez l'option <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>.</span><span class="sxs-lookup"><span data-stu-id="ea469-336">Use the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> option.</span></span> <span data-ttu-id="ea469-337">Elle désactive toutes les captures implicites ou sans nom dans le modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-337">It disables all unnamed or implicit captures in the regular expression pattern.</span></span> <span data-ttu-id="ea469-338">Avec cette option, seules les sous-chaînes qui correspondent à des groupes nommés définis avec l'élément de langage `(?<name>subexpression)` peuvent être capturées.</span><span class="sxs-lookup"><span data-stu-id="ea469-338">When you use this option, only substrings that match named groups defined with the `(?<name>subexpression)` language element can be captured.</span></span> <span data-ttu-id="ea469-339">L'indicateur <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> peut être passé au paramètre `options` d'un constructeur de classe <xref:System.Text.RegularExpressions.Regex> ou au paramètre `options` d'une méthode correspondante statique <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="ea469-339">The <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> flag can be passed to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> static matching method.</span></span>

- <span data-ttu-id="ea469-340">Utilisez l'option `n` dans l'élément de langage `(?imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="ea469-340">Use the `n` option in the `(?imnsx)` language element.</span></span> <span data-ttu-id="ea469-341">Cette option désactive toutes les captures implicites ou sans nom à partir du point où l’élément apparaît dans le modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="ea469-341">This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</span></span> <span data-ttu-id="ea469-342">Les captures sont désactivées jusqu’à la fin du modèle ou jusqu’à ce que l’option `(-n)` active les captures implicites ou sans nom.</span><span class="sxs-lookup"><span data-stu-id="ea469-342">Captures are disabled either until the end of the pattern or until the `(-n)` option enables unnamed or implicit captures.</span></span> <span data-ttu-id="ea469-343">Pour plus d'informations, consultez [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="ea469-343">For more information, see [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="ea469-344">Utilisez l'option `n` dans l'élément de langage `(?imnsx:subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="ea469-344">Use the `n` option in the `(?imnsx:subexpression)` language element.</span></span> <span data-ttu-id="ea469-345">Cette option désactive toutes les captures implicites ou sans nom dans `subexpression`.</span><span class="sxs-lookup"><span data-stu-id="ea469-345">This option disables all unnamed or implicit captures in `subexpression`.</span></span> <span data-ttu-id="ea469-346">Les captures effectuées par les groupes de capture imbriqués implicites ou sans nom sont également désactivées.</span><span class="sxs-lookup"><span data-stu-id="ea469-346">Captures by any unnamed or implicit nested capturing groups are disabled as well.</span></span>

## <a name="related-topics"></a><span data-ttu-id="ea469-347">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="ea469-347">Related topics</span></span>

|<span data-ttu-id="ea469-348">Intitulé</span><span class="sxs-lookup"><span data-stu-id="ea469-348">Title</span></span>|<span data-ttu-id="ea469-349">Description</span><span class="sxs-lookup"><span data-stu-id="ea469-349">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="ea469-350">Détails du comportement d’expression régulière</span><span class="sxs-lookup"><span data-stu-id="ea469-350">Details of Regular Expression Behavior</span></span>](../../../docs/standard/base-types/details-of-regular-expression-behavior.md)|<span data-ttu-id="ea469-351">Aborde l’implémentation du moteur d’expression régulière dans .NET.</span><span class="sxs-lookup"><span data-stu-id="ea469-351">Examines the implementation of the regular expression engine in .NET.</span></span> <span data-ttu-id="ea469-352">Cette rubrique traite de la flexibilité des expressions régulières. Elle explique la responsabilité du développeur pour que le fonctionnement efficace et fiable du moteur des expressions régulières soit garanti.</span><span class="sxs-lookup"><span data-stu-id="ea469-352">The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</span></span>|
|[<span data-ttu-id="ea469-353">Rétroaction</span><span class="sxs-lookup"><span data-stu-id="ea469-353">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="ea469-354">Aborde la rétroaction et la façon dont elle affecte les performances des expressions régulières, ainsi que les éléments de langage, qui offrent des alternatives à la rétroaction.</span><span class="sxs-lookup"><span data-stu-id="ea469-354">Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</span></span>|
|[<span data-ttu-id="ea469-355">Langage d’expression régulière - Référence rapide</span><span class="sxs-lookup"><span data-stu-id="ea469-355">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="ea469-356">Décrit les éléments du langage d’expression régulière dans .NET et propose des liens vers la documentation détaillée pour chaque élément de langage.</span><span class="sxs-lookup"><span data-stu-id="ea469-356">Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</span></span>|
