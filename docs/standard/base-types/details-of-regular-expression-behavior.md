---
title: Comportement d’expression régulière
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 0273d16028315452e35f83086dbc134d6fcb66c6
ms.sourcegitcommit: 1c1a1f9ec0bd1efb3040d86a79f7ee94e207cca5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/03/2020
ms.locfileid: "80635986"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="b088b-102">Comportement détaillé des expressions régulières</span><span class="sxs-lookup"><span data-stu-id="b088b-102">Details of regular expression behavior</span></span>

<span data-ttu-id="b088b-103">Le moteur d’expression régulière du .NET Framework est un analyseur d’expression régulière rétroactive qui incorpore un moteur NFA (Nondeterministic Finite Automaton) tel que celui utilisé par Perl, Python, Emacs et Tcl.</span><span class="sxs-lookup"><span data-stu-id="b088b-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="b088b-104">Cette particularité le distingue des moteurs d’expression régulière pure DFA (Deterministic Finite Automaton) plus rapides, mais plus limités, comme ceux d’awk, egrep ou lex.</span><span class="sxs-lookup"><span data-stu-id="b088b-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="b088b-105">Elle le distingue également des moteurs NFA POSIX standardisés, mais plus lents.</span><span class="sxs-lookup"><span data-stu-id="b088b-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="b088b-106">La section suivante décrit les trois types de moteurs d’expression régulière et explique pourquoi les expressions régulières dans le .NET Framework sont implémentées à l’aide d’un moteur NFA classique.</span><span class="sxs-lookup"><span data-stu-id="b088b-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="b088b-107">Avantages du moteur NFA</span><span class="sxs-lookup"><span data-stu-id="b088b-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="b088b-108">Quand les moteurs DFA exécutent des critères spéciaux, leur ordre de traitement est piloté par la chaîne d’entrée.</span><span class="sxs-lookup"><span data-stu-id="b088b-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="b088b-109">Les moteurs commencent au début de la chaîne d’entrée et continuent de manière séquentielle pour déterminer si le caractère suivant correspond au modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="b088b-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="b088b-110">Ils peuvent garantir une correspondance avec la chaîne la plus longue possible.</span><span class="sxs-lookup"><span data-stu-id="b088b-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="b088b-111">Étant donné qu’ils ne testent jamais le même caractère deux fois, les moteurs DFA ne prennent pas en charge la rétroaction.</span><span class="sxs-lookup"><span data-stu-id="b088b-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="b088b-112">Toutefois, étant donné qu’un moteur DFA contient uniquement un état fini, il ne peut pas rechercher un modèle avec des références arrière, et comme il ne construit pas d’expansion explicite, il ne peut pas capturer de sous-expressions.</span><span class="sxs-lookup"><span data-stu-id="b088b-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="b088b-113">Contrairement aux moteurs DFA, quand les moteurs NFA classiques exécutent des critères spéciaux, leur ordre de traitement est piloté par le modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="b088b-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="b088b-114">Lorsqu’il traite un élément de langage particulier, le moteur utilise une correspondance gourmande ; autrement dit, il cherche la chaîne d’entrée la plus longue possible.</span><span class="sxs-lookup"><span data-stu-id="b088b-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="b088b-115">Mais il enregistre également son état après avoir trouvé la correspondance correcte d’une sous-expression.</span><span class="sxs-lookup"><span data-stu-id="b088b-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="b088b-116">Si une correspondance finit par échouer, le moteur peut revenir à un état enregistré pour tenter d’autres correspondances.</span><span class="sxs-lookup"><span data-stu-id="b088b-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="b088b-117">Ce processus consistant à abandonner une correspondance réussie de sous-expression pour que les éléments de langage ultérieurs dans l’expression régulière puissent également correspondre est appelé *rétroaction*.</span><span class="sxs-lookup"><span data-stu-id="b088b-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="b088b-118">Les moteurs NFA utilisent la rétroaction pour tester toutes les expansions possibles d’une expression régulière dans un ordre spécifique et accepter la première correspondance.</span><span class="sxs-lookup"><span data-stu-id="b088b-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="b088b-119">Comme un moteur NFA classique construit une expansion spécifique de l’expression régulière pour obtenir une correspondance correcte, il peut capturer des correspondances de sous-expressions et des références arrière correspondantes.</span><span class="sxs-lookup"><span data-stu-id="b088b-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="b088b-120">Toutefois, comme un moteur NFA classique utilise la rétroaction, il peut visiter le même état plusieurs fois s’il y parvient par différents chemins.</span><span class="sxs-lookup"><span data-stu-id="b088b-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="b088b-121">Par conséquent, il peut s’exécuter lentement de façon exponentielle dans le pire des cas.</span><span class="sxs-lookup"><span data-stu-id="b088b-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="b088b-122">Comme un moteur NFA classique accepte la première correspondance trouvée, il peut également en négliger d’autres (éventuellement plus longues).</span><span class="sxs-lookup"><span data-stu-id="b088b-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="b088b-123">Les moteurs NFA POSIX sont comme les moteurs NFA classiques, sauf qu’ils poursuivent la rétroaction jusqu’à garantir qu’ils ont trouvé la correspondance la plus longue possible.</span><span class="sxs-lookup"><span data-stu-id="b088b-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="b088b-124">Ainsi, un moteur NFA POSIX est plus lent qu’un moteur NFA classique. Quand vous utilisez un moteur NFA POSIX, vous ne pouvez pas favoriser une correspondance plus courte au détriment d’une plus longue en modifiant l’ordre de la recherche rétroactive.</span><span class="sxs-lookup"><span data-stu-id="b088b-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="b088b-125">Les moteurs NFA classiques ont la préférence des programmeurs, car ils offrent un meilleur contrôle sur la mise en correspondance de chaînes que les moteurs DFA ou NFA POSIX.</span><span class="sxs-lookup"><span data-stu-id="b088b-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="b088b-126">Même si, dans le pire des cas, ils peuvent s’exécuter lentement, vous pouvez les amener à trouver des correspondances sur des durées linéaires ou polynomiales à l’aide de modèles qui réduisent les ambiguïtés et limitent la rétroaction.</span><span class="sxs-lookup"><span data-stu-id="b088b-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="b088b-127">En d’autres termes, bien que les moteurs NFA échangent des performances pour la puissance et la flexibilité, dans la plupart des cas, ils offrent de bonnes performances acceptables si une expression régulière est bien écrite et évite les cas dans lesquels le retour en arrière dégrade les performances de façon exponentielle.</span><span class="sxs-lookup"><span data-stu-id="b088b-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="b088b-128">Pour plus d’informations sur la baisse des performances due à la rétroaction excessive et sur les moyens de créer une expression régulière pour y remédier, consultez [Rétroaction](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b088b-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="b088b-129">.NET Capacités de moteur-cadre</span><span class="sxs-lookup"><span data-stu-id="b088b-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="b088b-130">Pour tirer parti des avantages d’un moteur NFA classique, le moteur d’expression régulière du .NET Framework inclut un ensemble complet de constructions pour permettre aux programmeurs de diriger le moteur de rétroaction.</span><span class="sxs-lookup"><span data-stu-id="b088b-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="b088b-131">Ces constructions peuvent être utilisées pour rechercher des correspondances plus rapidement ou pour favoriser des expansions spécifiques par rapport à d’autres.</span><span class="sxs-lookup"><span data-stu-id="b088b-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="b088b-132">Les autres fonctionnalités du moteur d’expression régulière du .NET Framework sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="b088b-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="b088b-133">Quantificateurs paresseux: `??`, `*?` `+?`, , `{` *n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="b088b-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="b088b-134">Ces constructions indiquent au moteur de rétroaction de rechercher d’abord le nombre minimal de répétitions.</span><span class="sxs-lookup"><span data-stu-id="b088b-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="b088b-135">Par opposition, les quantificateurs gourmands ordinaires essaient de trouver d’abord le nombre maximal de répétitions.</span><span class="sxs-lookup"><span data-stu-id="b088b-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="b088b-136">L’exemple suivant illustre la différence entre les deux.</span><span class="sxs-lookup"><span data-stu-id="b088b-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="b088b-137">Une expression régulière correspond à une phrase se terminant par un nombre qu’un groupe de capture est destiné à extraire.</span><span class="sxs-lookup"><span data-stu-id="b088b-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="b088b-138">L’expression régulière `.+(\d+)\.` inclut le quantificateur gourmand `.+`, qui amène le moteur d’expression régulière à capturer uniquement le dernier chiffre du nombre.</span><span class="sxs-lookup"><span data-stu-id="b088b-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="b088b-139">Par opposition, l’expression régulière `.+?(\d+)\.` inclut le quantificateur paresseux `.+?`, qui amène le moteur d’expression régulière à capturer le nombre entier.</span><span class="sxs-lookup"><span data-stu-id="b088b-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="b088b-140">Les versions gourmande et paresseuse de cette expression régulière sont définies comme indiqué dans le tableau suivant :</span><span class="sxs-lookup"><span data-stu-id="b088b-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="b088b-141">Modèle</span><span class="sxs-lookup"><span data-stu-id="b088b-141">Pattern</span></span>|<span data-ttu-id="b088b-142">Description</span><span class="sxs-lookup"><span data-stu-id="b088b-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="b088b-143">`.+` (quantificateur gourmand)</span><span class="sxs-lookup"><span data-stu-id="b088b-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="b088b-144">Mettre en correspondance au moins une occurrence de n’importe quel caractère.</span><span class="sxs-lookup"><span data-stu-id="b088b-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="b088b-145">Le moteur d’expression régulière recherche alors la chaîne entière, puis effectue une rétroaction si nécessaire pour trouver le reste du modèle.</span><span class="sxs-lookup"><span data-stu-id="b088b-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="b088b-146">`.+?` (quantificateur paresseux)</span><span class="sxs-lookup"><span data-stu-id="b088b-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="b088b-147">Mettre en correspondance au moins une occurrence de n’importe quel caractère, mais une quantité la plus petite possible.</span><span class="sxs-lookup"><span data-stu-id="b088b-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="b088b-148">Mettre en correspondance au moins un caractère numérique et l’assigner au premier groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="b088b-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="b088b-149">Mettre en correspondance un point.</span><span class="sxs-lookup"><span data-stu-id="b088b-149">Match a period.</span></span>|

     <span data-ttu-id="b088b-150">Pour plus d'informations sur les quantificateurs paresseux, voir [Quantificateurs](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b088b-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="b088b-151">Lookahead positif: `(?=` *sous-expression*`)`.</span><span class="sxs-lookup"><span data-stu-id="b088b-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="b088b-152">Cette fonctionnalité permet au moteur de rétroaction de revenir au même endroit dans le texte après avoir mis en correspondance une sous-expression.</span><span class="sxs-lookup"><span data-stu-id="b088b-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="b088b-153">Elle s’avère utile pour effectuer une recherche dans le texte en vérifiant plusieurs modèles qui démarrent à la même position.</span><span class="sxs-lookup"><span data-stu-id="b088b-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="b088b-154">Elle permet également au moteur de vérifier qu’une sous-chaîne existe à la fin de la correspondance sans inclure cette sous-chaîne dans le texte correspondant.</span><span class="sxs-lookup"><span data-stu-id="b088b-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="b088b-155">L’exemple suivant utilise la préanalyse positive pour extraire les mots d’une phrase qui ne sont pas suivis de symboles de ponctuation.</span><span class="sxs-lookup"><span data-stu-id="b088b-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="b088b-156">L'expression régulière `\b[A-Z]+\b(?=\P{P})` est définie comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="b088b-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="b088b-157">Modèle</span><span class="sxs-lookup"><span data-stu-id="b088b-157">Pattern</span></span>|<span data-ttu-id="b088b-158">Description</span><span class="sxs-lookup"><span data-stu-id="b088b-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="b088b-159">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="b088b-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="b088b-160">Mettre en correspondance un caractère alphabétique une ou plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="b088b-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="b088b-161">Cette comparaison ne respecte pas la casse car la méthode <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> est appelée avec l'option <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b088b-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="b088b-162">Terminer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="b088b-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="b088b-163">Préanalyser pour déterminer si le caractère suivant est un symbole de ponctuation.</span><span class="sxs-lookup"><span data-stu-id="b088b-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="b088b-164">Dans la négative, la correspondance réussit.</span><span class="sxs-lookup"><span data-stu-id="b088b-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="b088b-165">Pour plus d’informations sur les assertions de préanalyse positive, consultez [Constructions de regroupement](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b088b-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="b088b-166">Lookahead négatif: `(?!` *sous-expression*`)`.</span><span class="sxs-lookup"><span data-stu-id="b088b-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="b088b-167">Cette fonctionnalité ajoute la possibilité de mettre en correspondance une expression uniquement si une sous-expression ne correspond pas.</span><span class="sxs-lookup"><span data-stu-id="b088b-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="b088b-168">Ceci est puissant pour l’élagage d’une recherche, car il est souvent plus simple de fournir une expression pour un cas qui devrait être éliminé qu’une expression pour les cas qui doivent être inclus.</span><span class="sxs-lookup"><span data-stu-id="b088b-168">This is powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="b088b-169">Par exemple, il est difficile d’écrire une expression pour les mots qui ne commencent pas par « non ».</span><span class="sxs-lookup"><span data-stu-id="b088b-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="b088b-170">L’exemple suivant utilise la préanalyse négative pour les exclure.</span><span class="sxs-lookup"><span data-stu-id="b088b-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="b088b-171">Le modèle d'expression régulière `\b(?!non)\w+\b` est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="b088b-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="b088b-172">Modèle</span><span class="sxs-lookup"><span data-stu-id="b088b-172">Pattern</span></span>|<span data-ttu-id="b088b-173">Description</span><span class="sxs-lookup"><span data-stu-id="b088b-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="b088b-174">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="b088b-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="b088b-175">Préanalyser pour garantir que la chaîne actuelle ne commence pas par « non ».</span><span class="sxs-lookup"><span data-stu-id="b088b-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="b088b-176">Si c’est le cas, la correspondance échoue.</span><span class="sxs-lookup"><span data-stu-id="b088b-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="b088b-177">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="b088b-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="b088b-178">Terminer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="b088b-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="b088b-179">Pour plus d’informations sur les assertions de préanalyse négative, consultez [Constructions de regroupement](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b088b-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="b088b-180">Évaluation conditionnelle: `(?(` *expression*`)` `(?(`*oui*`|`*non* `)` et *nom*`)`*oui*`|`*non*`)`, lorsque *l’expression* est une sous-expression pour correspondre, le *nom* est le nom d’un groupe de capture, *oui* est la chaîne à assortir si *l’expression* est assortie ou le *nom* est un valide, non vide groupe capturé, et *non* est la sous-expression pour correspondre si *l’expression* n’est pas appariée ou le *nom* n’est pas un valide, non vide groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="b088b-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="b088b-181">Grâce à cette fonctionnalité, le moteur peut rechercher à l’aide de plusieurs autres modèles, selon le résultat d’une correspondance de sous-expression précédente ou le résultat d’une assertion de largeur nulle.</span><span class="sxs-lookup"><span data-stu-id="b088b-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="b088b-182">Cette fonctionnalité permet une forme plus puissante de référence arrière qui permet, par exemple, de rechercher une sous-expression en fonction d’une sous-expression précédente trouvée.</span><span class="sxs-lookup"><span data-stu-id="b088b-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="b088b-183">L’expression régulière utilisée dans l’exemple suivant trouve les paragraphes destinés à une utilisation à la fois interne et publique.</span><span class="sxs-lookup"><span data-stu-id="b088b-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="b088b-184">Les paragraphes destinés à un usage interne uniquement commencent par une balise `<PRIVATE>`.</span><span class="sxs-lookup"><span data-stu-id="b088b-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="b088b-185">Le modèle d’expression régulière `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` utilise une évaluation conditionnelle pour assigner le contenu des paragraphes destinés à une utilisation publique et interne à des groupes de capture distincts.</span><span class="sxs-lookup"><span data-stu-id="b088b-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="b088b-186">Ces paragraphes peuvent ensuite être gérés différemment.</span><span class="sxs-lookup"><span data-stu-id="b088b-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="b088b-187">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="b088b-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="b088b-188">Modèle</span><span class="sxs-lookup"><span data-stu-id="b088b-188">Pattern</span></span>|<span data-ttu-id="b088b-189">Description</span><span class="sxs-lookup"><span data-stu-id="b088b-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="b088b-190">Commencer la correspondance au début d’une ligne.</span><span class="sxs-lookup"><span data-stu-id="b088b-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="b088b-191">Mettre en correspondance zéro ou une occurrence de la chaîne `<PRIVATE>` suivie d’un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="b088b-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="b088b-192">Assigner la correspondance à un groupe de capture nommé `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="b088b-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="b088b-193">Si le groupe de capture `Pvt` existe, mettre en correspondance une ou plusieurs occurrences d’un ou plusieurs caractères de mot suivis de zéro ou un séparateur de ponctuation suivi d’un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="b088b-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="b088b-194">Assigner la sous-chaîne au premier groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="b088b-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="b088b-195">Si le groupe de capture `Pvt` n’existe pas, mettre en correspondance une ou plusieurs occurrences d’un ou plusieurs caractères de mot suivis de zéro ou un séparateur de ponctuation suivi d’un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="b088b-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="b088b-196">Assigner la sous-chaîne au troisième groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="b088b-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="b088b-197">Mettre en correspondance la fin d’une ligne ou la fin de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="b088b-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="b088b-198">Pour plus d’informations sur l’évaluation conditionnelle, consultez [Constructions d’alternative](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b088b-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="b088b-199">Équilibrer les définitions de groupe `(?<`: *nom1*`-`*2* `>` *sous-expression*`)`.</span><span class="sxs-lookup"><span data-stu-id="b088b-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="b088b-200">Cette fonctionnalité permet au moteur d’expression régulière d’effectuer un suivi des constructions imbriquées telles que les parenthèses ou les crochets ouvrants et fermants.</span><span class="sxs-lookup"><span data-stu-id="b088b-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="b088b-201">Pour obtenir un exemple, consultez [Constructions de regroupement](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b088b-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="b088b-202">Groupes atomiques : `(?>` *sousexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="b088b-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="b088b-203">Cette fonctionnalité permet au moteur de rétroaction de garantir qu’une sous-expression correspond uniquement à la première correspondance trouvée pour cette sous-expression, comme si l’expression s’exécutait indépendamment de l’expression qui la contient.</span><span class="sxs-lookup"><span data-stu-id="b088b-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="b088b-204">Si vous n’utilisez pas cette construction, les recherches rétroactives à partir de la plus grande expression peuvent modifier le comportement d’une sous-expression.</span><span class="sxs-lookup"><span data-stu-id="b088b-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="b088b-205">Par exemple, l’expression `(a+)\w` régulière correspond à un ou plusieurs caractères « a », ainsi qu’un personnage de mot qui suit la séquence de « a » caractères, et attribue la séquence de « a » caractères au premier groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="b088b-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="b088b-206">Toutefois, si le caractère final de la chaîne d’entrée `\w` est également un « a », il est égalé par l’élément linguistique et n’est pas inclus dans le groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="b088b-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="b088b-207">L’expression régulière `((?>a+))\w` empêche ce comportement.</span><span class="sxs-lookup"><span data-stu-id="b088b-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="b088b-208">Étant donné que tous les caractères « a » consécutifs sont trouvés sans rétroaction, le premier groupe de capture inclut tous les caractères « a » consécutifs.</span><span class="sxs-lookup"><span data-stu-id="b088b-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="b088b-209">Si les caractères « a » ne sont pas suivis d’au moins un caractère autre que « a », la correspondance échoue.</span><span class="sxs-lookup"><span data-stu-id="b088b-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="b088b-210">Pour plus d’informations sur les groupes [atomiques, voir Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b088b-210">For more information about atomic groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="b088b-211">La mise en correspondance de droite à gauche est spécifiée en fournissant l’option <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> à une méthode de mise en correspondance de constructeur de classe ou d’instance statique <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="b088b-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="b088b-212">Cette fonctionnalité s’avère utile lors de la recherche de droite à gauche au lieu de gauche à droite, ou dans les cas où il est plus efficace de commencer une correspondance dans la partie droite du modèle plutôt que la partie gauche.</span><span class="sxs-lookup"><span data-stu-id="b088b-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="b088b-213">Comme l’illustre l’exemple suivant, l’utilisation de la mise en correspondance de droite à gauche peut modifier le comportement des quantificateurs gourmands.</span><span class="sxs-lookup"><span data-stu-id="b088b-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="b088b-214">L’exemple effectue deux recherches d’une phrase qui se termine par un nombre.</span><span class="sxs-lookup"><span data-stu-id="b088b-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="b088b-215">La recherche de gauche à droite qui utilise le quantificateur gourmand `+` trouve l’un des six chiffres dans la phrase, tandis que la recherche de droite à gauche trouve les six chiffres.</span><span class="sxs-lookup"><span data-stu-id="b088b-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="b088b-216">Pour une description du modèle d’expression régulière, voir l’exemple qui illustre les quantificateurs paresseux plus tôt dans cette section.</span><span class="sxs-lookup"><span data-stu-id="b088b-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="b088b-217">Pour plus d’informations sur la mise en correspondance de droite à gauche, consultez [Options des expressions régulières](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="b088b-217">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>

- <span data-ttu-id="b088b-218">Lookbehind positif et `(?<=`négatif : *sousexpression* `)` pour `(?<!`lookbehind positif, et *sousexpression* `)` pour lookbehind négatif.</span><span class="sxs-lookup"><span data-stu-id="b088b-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="b088b-219">Cette fonctionnalité est semblable à la préanalyse décrite précédemment dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="b088b-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="b088b-220">Comme le moteur d’expression régulière autorise une mise en correspondance complète de droite à gauche, les expressions régulières autorisent les postanalyses illimitées.</span><span class="sxs-lookup"><span data-stu-id="b088b-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="b088b-221">La postanalyse positive et négative peut également servir à éviter d’imbriquer des quantificateurs lorsque la sous-expression imbriquée est un sur-ensemble d’une expression externe.</span><span class="sxs-lookup"><span data-stu-id="b088b-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="b088b-222">Les expressions régulières comportant ces quantificateurs imbriqués offrent souvent des performances médiocres.</span><span class="sxs-lookup"><span data-stu-id="b088b-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="b088b-223">L’exemple suivant vérifie qu’une chaîne commence et se termine par un caractère alphanumérique et que tout autre caractère contenu dans la chaîne fait partie d’un sur-ensemble plus grand.</span><span class="sxs-lookup"><span data-stu-id="b088b-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="b088b-224">Il forme une partie de l’expression régulière utilisée pour valider des adresses e-mail. Pour plus d’informations, consultez [Guide pratique : vérifier que des chaînes sont dans un format d’adresse e-mail valide](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="b088b-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="b088b-225">L'expression régulière ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` est définie comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="b088b-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="b088b-226">Modèle</span><span class="sxs-lookup"><span data-stu-id="b088b-226">Pattern</span></span>|<span data-ttu-id="b088b-227">Description</span><span class="sxs-lookup"><span data-stu-id="b088b-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="b088b-228">Commencer la correspondance au début de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="b088b-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="b088b-229">Mettre en correspondance n’importe quel caractère numérique ou alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="b088b-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="b088b-230">(La comparaison respecte la casse.)</span><span class="sxs-lookup"><span data-stu-id="b088b-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="b088b-231">Assortissez zéro ou plus d’occurrences de n’importe quel personnage de mot, ou de l’un des caractères suivants : -, !,, $, &, ', ., \*,, /, ', ', ', &#96;, ', &#124;, ou '.</span><span class="sxs-lookup"><span data-stu-id="b088b-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="b088b-232">Postanalyser jusqu’au caractère précédent, qui doit être numérique ou alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="b088b-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="b088b-233">(La comparaison respecte la casse.)</span><span class="sxs-lookup"><span data-stu-id="b088b-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="b088b-234">Termine la correspondance à la fin de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="b088b-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="b088b-235">Pour plus d’informations sur la postanalyse positive et négative, consultez [Constructions de regroupement](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b088b-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="b088b-236">Articles connexes</span><span class="sxs-lookup"><span data-stu-id="b088b-236">Related articles</span></span>

|<span data-ttu-id="b088b-237">Intitulé</span><span class="sxs-lookup"><span data-stu-id="b088b-237">Title</span></span>|<span data-ttu-id="b088b-238">Description</span><span class="sxs-lookup"><span data-stu-id="b088b-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="b088b-239">Rétroaction</span><span class="sxs-lookup"><span data-stu-id="b088b-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="b088b-240">Fournit des informations sur la manière dont la rétroaction d’expression régulière se ramifie pour trouver d’autres correspondances.</span><span class="sxs-lookup"><span data-stu-id="b088b-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="b088b-241">Compilation et réutilisation</span><span class="sxs-lookup"><span data-stu-id="b088b-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="b088b-242">Fournit des informations sur la compilation et la réutilisation des expressions régulières pour augmenter les performances.</span><span class="sxs-lookup"><span data-stu-id="b088b-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="b088b-243">Sécurité des fils</span><span class="sxs-lookup"><span data-stu-id="b088b-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="b088b-244">Fournit des informations sur la sécurité des threads d’expression régulière et explique quand vous devez synchroniser l’accès aux objets d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="b088b-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="b088b-245">Expressions régulières du .NET Framework</span><span class="sxs-lookup"><span data-stu-id="b088b-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="b088b-246">Fournit une vue d’ensemble de l’aspect du langage de programmation des expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="b088b-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="b088b-247">Modèle objet d'expression régulière</span><span class="sxs-lookup"><span data-stu-id="b088b-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="b088b-248">Fournit des informations et des exemples de code illustrant l’utilisation des classes d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="b088b-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="b088b-249">Langage des expressions régulières - Aide-mémoire</span><span class="sxs-lookup"><span data-stu-id="b088b-249">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="b088b-250">Fournit des informations sur le jeu de caractères, d’opérateurs et de constructions permettant de définir des expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="b088b-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="b088b-251">Informations de référence</span><span class="sxs-lookup"><span data-stu-id="b088b-251">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
