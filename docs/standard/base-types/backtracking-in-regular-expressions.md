---
title: Rétroaction dans les expressions régulières .NET
description: Apprenez à contrôler la rétroaction dans la mise en correspondance de modèle d’expression régulière.
ms.date: 11/12/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
ms.openlocfilehash: d9fb976c73891646df60b5329beb09493acbae8a
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/02/2020
ms.locfileid: "84277802"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="5693e-103">Rétroaction dans les expressions régulières</span><span class="sxs-lookup"><span data-stu-id="5693e-103">Backtracking in Regular Expressions</span></span>
<span data-ttu-id="5693e-104">La rétroaction se produit quand un modèle d’expression régulière contient des [quantificateurs](quantifiers-in-regular-expressions.md) ou des [constructions d’alternative](alternation-constructs-in-regular-expressions.md) facultatifs, et que le moteur d’expression régulière retourne à un état enregistré précédent pour poursuivre la recherche d’une correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-104">Backtracking occurs when a regular expression pattern contains optional [quantifiers](quantifiers-in-regular-expressions.md) or [alternation constructs](alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="5693e-105">La rétroaction est essentielle à la puissance des expressions régulières ; elle permet aux expressions d'être puissantes et flexibles et de correspondre à des modèles très complexes.</span><span class="sxs-lookup"><span data-stu-id="5693e-105">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="5693e-106">Cependant, cette puissance a un coût.</span><span class="sxs-lookup"><span data-stu-id="5693e-106">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="5693e-107">La rétroaction est souvent le facteur le plus important qui affecte les performances du moteur des expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="5693e-107">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="5693e-108">Heureusement, le développeur contrôle le comportement du moteur des expressions régulières et comment il utilise la rétroaction.</span><span class="sxs-lookup"><span data-stu-id="5693e-108">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="5693e-109">Cette rubrique explique comment la rétroaction fonctionne et comment elle peut être activée.</span><span class="sxs-lookup"><span data-stu-id="5693e-109">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5693e-110">En général, un automate fini non déterministe comme le moteur d’expression régulière de .NET fait peser la responsabilité de la conception d’expressions régulières efficaces et rapides sur le développeur.</span><span class="sxs-lookup"><span data-stu-id="5693e-110">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  

## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="5693e-111">Comparaison linéaire sans rétroaction</span><span class="sxs-lookup"><span data-stu-id="5693e-111">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="5693e-112">Si un modèle d'expression régulière ne possède pas de quantificateur facultatif ou de construction d'alternative, le moteur des expressions régulières s'exécute en temps linéaire.</span><span class="sxs-lookup"><span data-stu-id="5693e-112">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="5693e-113">Autrement dit, une fois que le moteur des expressions régulières correspond au premier élément de langage dans le modèle avec du texte dans la chaîne d'entrée, il tente de correspondre à l'élément de langage suivant dans le modèle avec le caractère ou le groupe suivant de caractères dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-113">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="5693e-114">Cela se poursuit jusqu'à ce que la correspondance réussisse ou échoue.</span><span class="sxs-lookup"><span data-stu-id="5693e-114">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="5693e-115">Dans les deux cas, le moteur des expressions régulières avance d'un caractère à la fois dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-115">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="5693e-116">L'exemple suivant en est l'illustration.</span><span class="sxs-lookup"><span data-stu-id="5693e-116">The following example provides an illustration.</span></span> <span data-ttu-id="5693e-117">L'expression régulière `e{2}\w\b` recherche deux occurrences de la lettre « e » suivie de n'importe quel caractère de mot suivi d'une limite de mot.</span><span class="sxs-lookup"><span data-stu-id="5693e-117">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="5693e-118">Bien que cette expression régulière inclue le quantificateur `{2}`, elle est évaluée de façon linéaire.</span><span class="sxs-lookup"><span data-stu-id="5693e-118">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="5693e-119">Le moteur des expressions régulières ne revient pas en arrière, car `{2}` n'est pas un quantificateur facultatif ; il spécifie un nombre exact et pas un nombre variable de fois que la sous-expression précédente doit correspondre.</span><span class="sxs-lookup"><span data-stu-id="5693e-119">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="5693e-120">Par conséquent, le moteur des expressions régulières tente de correspondre au modèle d'expression régulière avec la chaîne d'entrée comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="5693e-120">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="5693e-121">Opération</span><span class="sxs-lookup"><span data-stu-id="5693e-121">Operation</span></span>|<span data-ttu-id="5693e-122">Position dans le modèle</span><span class="sxs-lookup"><span data-stu-id="5693e-122">Position in pattern</span></span>|<span data-ttu-id="5693e-123">Position dans la chaîne</span><span class="sxs-lookup"><span data-stu-id="5693e-123">Position in string</span></span>|<span data-ttu-id="5693e-124">Résultats</span><span class="sxs-lookup"><span data-stu-id="5693e-124">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="5693e-125">1</span><span class="sxs-lookup"><span data-stu-id="5693e-125">1</span></span>|<span data-ttu-id="5693e-126">e</span><span class="sxs-lookup"><span data-stu-id="5693e-126">e</span></span>|<span data-ttu-id="5693e-127">"besoin d'un roseau" (index 0)</span><span class="sxs-lookup"><span data-stu-id="5693e-127">"needing a reed" (index 0)</span></span>|<span data-ttu-id="5693e-128">Pas de correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-128">No match.</span></span>|  
|<span data-ttu-id="5693e-129">2</span><span class="sxs-lookup"><span data-stu-id="5693e-129">2</span></span>|<span data-ttu-id="5693e-130">e</span><span class="sxs-lookup"><span data-stu-id="5693e-130">e</span></span>|<span data-ttu-id="5693e-131">"esoin d'un roseau" (index 1)</span><span class="sxs-lookup"><span data-stu-id="5693e-131">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="5693e-132">Correspondance possible.</span><span class="sxs-lookup"><span data-stu-id="5693e-132">Possible match.</span></span>|  
|<span data-ttu-id="5693e-133">3</span><span class="sxs-lookup"><span data-stu-id="5693e-133">3</span></span>|<span data-ttu-id="5693e-134">e{2}</span><span class="sxs-lookup"><span data-stu-id="5693e-134">e{2}</span></span>|<span data-ttu-id="5693e-135">"soin d'un roseau" (index 2)</span><span class="sxs-lookup"><span data-stu-id="5693e-135">"eding a reed" (index 2)</span></span>|<span data-ttu-id="5693e-136">Correspondance possible.</span><span class="sxs-lookup"><span data-stu-id="5693e-136">Possible match.</span></span>|  
|<span data-ttu-id="5693e-137">4</span><span class="sxs-lookup"><span data-stu-id="5693e-137">4</span></span>|<span data-ttu-id="5693e-138">\w</span><span class="sxs-lookup"><span data-stu-id="5693e-138">\w</span></span>|<span data-ttu-id="5693e-139">"oin d'un roseau" (index 3)</span><span class="sxs-lookup"><span data-stu-id="5693e-139">"ding a reed" (index 3)</span></span>|<span data-ttu-id="5693e-140">Correspondance possible.</span><span class="sxs-lookup"><span data-stu-id="5693e-140">Possible match.</span></span>|  
|<span data-ttu-id="5693e-141">5</span><span class="sxs-lookup"><span data-stu-id="5693e-141">5</span></span>|<span data-ttu-id="5693e-142">\b</span><span class="sxs-lookup"><span data-stu-id="5693e-142">\b</span></span>|<span data-ttu-id="5693e-143">"in d'un roseau" (index 4)</span><span class="sxs-lookup"><span data-stu-id="5693e-143">"ing a reed" (index 4)</span></span>|<span data-ttu-id="5693e-144">Échecs de correspondance possibles.</span><span class="sxs-lookup"><span data-stu-id="5693e-144">Possible match fails.</span></span>|  
|<span data-ttu-id="5693e-145">6</span><span class="sxs-lookup"><span data-stu-id="5693e-145">6</span></span>|<span data-ttu-id="5693e-146">e</span><span class="sxs-lookup"><span data-stu-id="5693e-146">e</span></span>|<span data-ttu-id="5693e-147">"soin d'un roseau" (index 2)</span><span class="sxs-lookup"><span data-stu-id="5693e-147">"eding a reed" (index 2)</span></span>|<span data-ttu-id="5693e-148">Correspondance possible.</span><span class="sxs-lookup"><span data-stu-id="5693e-148">Possible match.</span></span>|  
|<span data-ttu-id="5693e-149">7</span><span class="sxs-lookup"><span data-stu-id="5693e-149">7</span></span>|<span data-ttu-id="5693e-150">e{2}</span><span class="sxs-lookup"><span data-stu-id="5693e-150">e{2}</span></span>|<span data-ttu-id="5693e-151">"oin d'un roseau" (index 3)</span><span class="sxs-lookup"><span data-stu-id="5693e-151">"ding a reed" (index 3)</span></span>|<span data-ttu-id="5693e-152">Échecs de correspondance possibles.</span><span class="sxs-lookup"><span data-stu-id="5693e-152">Possible match fails.</span></span>|  
|<span data-ttu-id="5693e-153">8</span><span class="sxs-lookup"><span data-stu-id="5693e-153">8</span></span>|<span data-ttu-id="5693e-154">e</span><span class="sxs-lookup"><span data-stu-id="5693e-154">e</span></span>|<span data-ttu-id="5693e-155">"oin d'un roseau" (index 3)</span><span class="sxs-lookup"><span data-stu-id="5693e-155">"ding a reed" (index 3)</span></span>|<span data-ttu-id="5693e-156">Échec de la correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-156">Match fails.</span></span>|  
|<span data-ttu-id="5693e-157">9</span><span class="sxs-lookup"><span data-stu-id="5693e-157">9</span></span>|<span data-ttu-id="5693e-158">e</span><span class="sxs-lookup"><span data-stu-id="5693e-158">e</span></span>|<span data-ttu-id="5693e-159">"in d'un roseau" (index 4)</span><span class="sxs-lookup"><span data-stu-id="5693e-159">"ing a reed" (index 4)</span></span>|<span data-ttu-id="5693e-160">Pas de correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-160">No match.</span></span>|  
|<span data-ttu-id="5693e-161">10</span><span class="sxs-lookup"><span data-stu-id="5693e-161">10</span></span>|<span data-ttu-id="5693e-162">e</span><span class="sxs-lookup"><span data-stu-id="5693e-162">e</span></span>|<span data-ttu-id="5693e-163">"n d'un roseau" (index 5)</span><span class="sxs-lookup"><span data-stu-id="5693e-163">"ng a reed" (index 5)</span></span>|<span data-ttu-id="5693e-164">Pas de correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-164">No match.</span></span>|  
|<span data-ttu-id="5693e-165">11</span><span class="sxs-lookup"><span data-stu-id="5693e-165">11</span></span>|<span data-ttu-id="5693e-166">e</span><span class="sxs-lookup"><span data-stu-id="5693e-166">e</span></span>|<span data-ttu-id="5693e-167">"d'un roseau" (index 6)</span><span class="sxs-lookup"><span data-stu-id="5693e-167">"g a reed" (index 6)</span></span>|<span data-ttu-id="5693e-168">Pas de correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-168">No match.</span></span>|  
|<span data-ttu-id="5693e-169">12</span><span class="sxs-lookup"><span data-stu-id="5693e-169">12</span></span>|<span data-ttu-id="5693e-170">e</span><span class="sxs-lookup"><span data-stu-id="5693e-170">e</span></span>|<span data-ttu-id="5693e-171">" un roseau" (index 7)</span><span class="sxs-lookup"><span data-stu-id="5693e-171">" a reed" (index 7)</span></span>|<span data-ttu-id="5693e-172">Pas de correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-172">No match.</span></span>|  
|<span data-ttu-id="5693e-173">13</span><span class="sxs-lookup"><span data-stu-id="5693e-173">13</span></span>|<span data-ttu-id="5693e-174">e</span><span class="sxs-lookup"><span data-stu-id="5693e-174">e</span></span>|<span data-ttu-id="5693e-175">"un roseau" (index 8)</span><span class="sxs-lookup"><span data-stu-id="5693e-175">"a reed" (index 8)</span></span>|<span data-ttu-id="5693e-176">Pas de correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-176">No match.</span></span>|  
|<span data-ttu-id="5693e-177">14</span><span class="sxs-lookup"><span data-stu-id="5693e-177">14</span></span>|<span data-ttu-id="5693e-178">e</span><span class="sxs-lookup"><span data-stu-id="5693e-178">e</span></span>|<span data-ttu-id="5693e-179">" roseau" (index 9)</span><span class="sxs-lookup"><span data-stu-id="5693e-179">" reed" (index 9)</span></span>|<span data-ttu-id="5693e-180">Pas de correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-180">No match.</span></span>|  
|<span data-ttu-id="5693e-181">15</span><span class="sxs-lookup"><span data-stu-id="5693e-181">15</span></span>|<span data-ttu-id="5693e-182">e</span><span class="sxs-lookup"><span data-stu-id="5693e-182">e</span></span>|<span data-ttu-id="5693e-183">"roseau" (index 10)</span><span class="sxs-lookup"><span data-stu-id="5693e-183">"reed" (index 10)</span></span>|<span data-ttu-id="5693e-184">Pas de correspondance</span><span class="sxs-lookup"><span data-stu-id="5693e-184">No match</span></span>|  
|<span data-ttu-id="5693e-185">16</span><span class="sxs-lookup"><span data-stu-id="5693e-185">16</span></span>|<span data-ttu-id="5693e-186">e</span><span class="sxs-lookup"><span data-stu-id="5693e-186">e</span></span>|<span data-ttu-id="5693e-187">"seau" (index 11)</span><span class="sxs-lookup"><span data-stu-id="5693e-187">"eed" (index 11)</span></span>|<span data-ttu-id="5693e-188">Correspondance possible.</span><span class="sxs-lookup"><span data-stu-id="5693e-188">Possible match.</span></span>|  
|<span data-ttu-id="5693e-189">17</span><span class="sxs-lookup"><span data-stu-id="5693e-189">17</span></span>|<span data-ttu-id="5693e-190">e{2}</span><span class="sxs-lookup"><span data-stu-id="5693e-190">e{2}</span></span>|<span data-ttu-id="5693e-191">"au" (index 12)</span><span class="sxs-lookup"><span data-stu-id="5693e-191">"ed" (index 12)</span></span>|<span data-ttu-id="5693e-192">Correspondance possible.</span><span class="sxs-lookup"><span data-stu-id="5693e-192">Possible match.</span></span>|  
|<span data-ttu-id="5693e-193">18</span><span class="sxs-lookup"><span data-stu-id="5693e-193">18</span></span>|<span data-ttu-id="5693e-194">\w</span><span class="sxs-lookup"><span data-stu-id="5693e-194">\w</span></span>|<span data-ttu-id="5693e-195">"u" (index 13)</span><span class="sxs-lookup"><span data-stu-id="5693e-195">"d" (index 13)</span></span>|<span data-ttu-id="5693e-196">Correspondance possible.</span><span class="sxs-lookup"><span data-stu-id="5693e-196">Possible match.</span></span>|  
|<span data-ttu-id="5693e-197">19</span><span class="sxs-lookup"><span data-stu-id="5693e-197">19</span></span>|<span data-ttu-id="5693e-198">\b</span><span class="sxs-lookup"><span data-stu-id="5693e-198">\b</span></span>|<span data-ttu-id="5693e-199">"" (index 14)</span><span class="sxs-lookup"><span data-stu-id="5693e-199">"" (index 14)</span></span>|<span data-ttu-id="5693e-200">Correspondance</span><span class="sxs-lookup"><span data-stu-id="5693e-200">Match.</span></span>|  
  
 <span data-ttu-id="5693e-201">Si un modèle d'expression régulière n'inclut aucun quantificateur facultatif ou construction d'alternative, le nombre maximal de comparaisons requises pour correspondre au modèle d'expression régulière avec la chaîne d'entrée équivaut à peu près au nombre de caractères dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-201">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="5693e-202">Dans ce cas, le moteur des expressions régulières utilise 19 comparaisons pour identifier les correspondances possibles dans cette chaîne de 13 caractères.</span><span class="sxs-lookup"><span data-stu-id="5693e-202">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="5693e-203">En d'autres termes, le moteur des expressions régulières s'exécute en temps quasi linéaire s'il ne contient pas de quantificateur facultatif ou de construction d'alternative.</span><span class="sxs-lookup"><span data-stu-id="5693e-203">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>

## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="5693e-204">Rétroaction avec des quantificateurs facultatifs ou des constructions d'alternative</span><span class="sxs-lookup"><span data-stu-id="5693e-204">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="5693e-205">Lorsqu'une expression régulière inclut des quantificateurs facultatifs ou des constructions d'alternative, l'évaluation de la chaîne d'entrée n'est plus linéaire.</span><span class="sxs-lookup"><span data-stu-id="5693e-205">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="5693e-206">Les critères spéciaux avec un moteur NFA sont pilotés par les éléments de langage dans l'expression régulière et non par des caractères de correspondance dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-206">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="5693e-207">Par conséquent, le moteur des expressions régulières tente de correspondre complètement aux sous-expressions facultatives ou alternatives.</span><span class="sxs-lookup"><span data-stu-id="5693e-207">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="5693e-208">Lorsqu'il avance à l'élément de langage suivant dans la sous-expression et que la correspondance échoue, le moteur des expressions régulières peut abandonner une partie de sa correspondance trouvée et retourner à un état enregistré précédent afin de mettre en correspondance l'expression régulière dans son ensemble avec la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-208">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="5693e-209">Ce processus de retour à un état enregistré précédent pour rechercher une correspondance est appelé rétroaction.</span><span class="sxs-lookup"><span data-stu-id="5693e-209">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="5693e-210">Considérons, par exemple, le modèle d'expression régulière `.*(es)`, qui correspond aux caractères « es » et tous caractères qui précèdent.</span><span class="sxs-lookup"><span data-stu-id="5693e-210">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="5693e-211">Comme l'exemple suivant l'indique, si la chaîne d'entrée est « Des services essentiels sont fournis par les expressions régulières. », le modèle correspond à la chaîne entière jusqu'à « es » dans « expressions ».</span><span class="sxs-lookup"><span data-stu-id="5693e-211">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="5693e-212">Pour cela, le moteur des expressions régulières utilise la rétroaction comme suit :</span><span class="sxs-lookup"><span data-stu-id="5693e-212">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
- <span data-ttu-id="5693e-213">Il établit une correspondance entre `.*` (qui correspond à zéro, une ou plusieurs occurrences d'un caractère) et la chaîne d'entrée entière.</span><span class="sxs-lookup"><span data-stu-id="5693e-213">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
- <span data-ttu-id="5693e-214">Il tente de faire correspondre « e » dans le modèle d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="5693e-214">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="5693e-215">Toutefois, il ne reste aucun caractère disponible pour la correspondance dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-215">However, the input string has no remaining characters available to match.</span></span>  
  
- <span data-ttu-id="5693e-216">Il revient en arrière à la dernière correspondance trouvée, « Des services essentiels sont fournis par les expressions régulières » et tente de faire correspondre « e » avec le point à la fin de la phrase.</span><span class="sxs-lookup"><span data-stu-id="5693e-216">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="5693e-217">La correspondance échoue.</span><span class="sxs-lookup"><span data-stu-id="5693e-217">The match fails.</span></span>  
  
- <span data-ttu-id="5693e-218">Il continue à revenir en arrière à la correspondance précédente caractère après caractère jusqu'à ce qu'à ce que la sous-chaîne en correspondance provisoire soit « Des services essentiels sont fournis par le les expr ».</span><span class="sxs-lookup"><span data-stu-id="5693e-218">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="5693e-219">Il compare ensuite le « e » dans le modèle avec le second « e » dans « expressions » et trouve une correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-219">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
- <span data-ttu-id="5693e-220">Il compare le « s » dans le modèle avec le « s » qui suit le « e » mis en correspondance (le premier « s » dans « expressions »).</span><span class="sxs-lookup"><span data-stu-id="5693e-220">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="5693e-221">La correspondance réussit.</span><span class="sxs-lookup"><span data-stu-id="5693e-221">The match is successful.</span></span>  
  
 <span data-ttu-id="5693e-222">Lorsque vous utilisez la rétroaction, la mise en correspondance du modèle d'expression régulière avec la chaîne d'entrée, qui comporte 55 caractères, requiert 67 opérations de comparaison.</span><span class="sxs-lookup"><span data-stu-id="5693e-222">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="5693e-223">En général, si un modèle d'expression régulière a une seule construction d'alternative ou un seul quantificateur facultatif, le nombre d'opérations de comparaison requises pour correspondre au modèle est supérieur au double du nombre de caractères dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-223">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>

## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="5693e-224">Rétroaction avec des quantificateurs facultatifs imbriqués</span><span class="sxs-lookup"><span data-stu-id="5693e-224">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="5693e-225">Le nombre d'opérations de comparaison requises pour correspondre à un modèle d'expression régulière peut augmenter de façon exponentielle si le modèle se compose d'un grand nombre de constructions d'alternative, s'il est constitué de constructions d'alternative imbriquées ou, le plus souvent, s'il inclut des quantificateurs facultatifs imbriqués.</span><span class="sxs-lookup"><span data-stu-id="5693e-225">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="5693e-226">Par exemple, le modèle d'expression régulière `^(a+)+$` est conçu pour une correspondance avec une chaîne complète qui contient un ou plusieurs caractères « a ».</span><span class="sxs-lookup"><span data-stu-id="5693e-226">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="5693e-227">L'exemple fournit deux chaînes d'entrée de longueurs identiques, mais seule la première chaîne correspond au modèle.</span><span class="sxs-lookup"><span data-stu-id="5693e-227">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="5693e-228">La classe <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> est utilisée pour déterminer la durée de l'opération de correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-228">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="5693e-229">Comme la sortie de l'exemple indique, il a fallu presque deux fois plus de temps au moteur des expressions régulières pour constater qu'une chaîne d'entrée ne correspondait pas au modèle que pour identifier une chaîne correspondante.</span><span class="sxs-lookup"><span data-stu-id="5693e-229">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="5693e-230">Cela est dû au fait qu'une correspondance infructueuse représente toujours le pire des scénarios.</span><span class="sxs-lookup"><span data-stu-id="5693e-230">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="5693e-231">Le moteur des expressions régulières doit utiliser l'expression régulière pour suivre tous les chemins d'accès possibles dans les données avant qu'il puisse conclure que la correspondance est infructueuse, et les parenthèses imbriquées créent plusieurs chemins d'accès supplémentaires dans les données.</span><span class="sxs-lookup"><span data-stu-id="5693e-231">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="5693e-232">Le moteur des expressions régulières conclut que la deuxième chaîne ne correspondait pas au modèle en procédant comme suit :</span><span class="sxs-lookup"><span data-stu-id="5693e-232">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
- <span data-ttu-id="5693e-233">Il vérifie qu'il était au début de la chaîne, puis fait correspondre les cinq premiers caractères dans la chaîne avec le modèle `a+`.</span><span class="sxs-lookup"><span data-stu-id="5693e-233">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="5693e-234">Il détermine ensuite qu'il n'y a aucun groupe supplémentaire de caractères « a » dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="5693e-234">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="5693e-235">Enfin, il effectue en test pour déterminer la fin de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="5693e-235">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="5693e-236">Étant donné qu'il reste un caractère supplémentaire dans la chaîne, la correspondance échoue.</span><span class="sxs-lookup"><span data-stu-id="5693e-236">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="5693e-237">Cette correspondance infructueuse requiert 9 comparaisons.</span><span class="sxs-lookup"><span data-stu-id="5693e-237">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="5693e-238">Le moteur des expressions régulières enregistre également des informations d'état de ses correspondances de « a » (que nous appellerons correspondance 1), « aa » (correspondance 2), « aaa » (correspondance 3) et « aaaa » (correspondance 4).</span><span class="sxs-lookup"><span data-stu-id="5693e-238">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
- <span data-ttu-id="5693e-239">Il revient à la correspondance 4 enregistrée précédemment.</span><span class="sxs-lookup"><span data-stu-id="5693e-239">It returns to the previously saved match 4.</span></span> <span data-ttu-id="5693e-240">Il détermine qu'il y a un caractère « a » supplémentaire à assigner à un groupe capturé supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="5693e-240">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="5693e-241">Enfin, il effectue en test pour déterminer la fin de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="5693e-241">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="5693e-242">Étant donné qu'il reste un caractère supplémentaire dans la chaîne, la correspondance échoue.</span><span class="sxs-lookup"><span data-stu-id="5693e-242">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="5693e-243">Cette correspondance infructueuse requiert 4 comparaisons.</span><span class="sxs-lookup"><span data-stu-id="5693e-243">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="5693e-244">Jusqu'à présent, un total de 13 comparaisons ont été effectuées.</span><span class="sxs-lookup"><span data-stu-id="5693e-244">So far, a total of 13 comparisons have been performed.</span></span>  
  
- <span data-ttu-id="5693e-245">Il revient à la correspondance 3 enregistrée précédemment.</span><span class="sxs-lookup"><span data-stu-id="5693e-245">It returns to the previously saved match 3.</span></span> <span data-ttu-id="5693e-246">Il détermine qu'il y a deux caractères « a » supplémentaires à assigner à un groupe capturé supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="5693e-246">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="5693e-247">Toutefois, le test de fin de chaîne échoue.</span><span class="sxs-lookup"><span data-stu-id="5693e-247">However, the end-of-string test fails.</span></span> <span data-ttu-id="5693e-248">Il revient ensuite à la correspondance 3 et tente de faire correspondre les deux caractères « a » supplémentaire dans deux groupes capturés supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="5693e-248">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="5693e-249">Le test de fin de chaîne échoue encore.</span><span class="sxs-lookup"><span data-stu-id="5693e-249">The end-of-string test still fails.</span></span> <span data-ttu-id="5693e-250">Ces correspondances infructueuses requièrent 12 comparaisons.</span><span class="sxs-lookup"><span data-stu-id="5693e-250">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="5693e-251">Jusqu'à présent, un total de 25 comparaisons ont été effectuées.</span><span class="sxs-lookup"><span data-stu-id="5693e-251">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="5693e-252">La comparaison de la chaîne d'entrée avec l'expression régulière continue de cette façon jusqu'à ce que le moteur des expressions régulières ait tenté toutes les combinaisons possibles des correspondances et conclue qu'il n'existe aucune correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-252">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="5693e-253">En raison des quantificateurs imbriqués, cette comparaison est une opération O (2<sup>n</sup>) ou exponentielle, où *n* est le nombre de caractères dans la chaîne d’entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-253">Because of the nested quantifiers, this comparison is an O(2<sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="5693e-254">Cela signifie que dans le pire des cas, une chaîne d'entrée de 30 caractères requiert environ 1 073 741 824 comparaisons et une chaîne d'entrée de 40 caractères requiert environ 1 099 511 627 776 comparaisons.</span><span class="sxs-lookup"><span data-stu-id="5693e-254">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="5693e-255">Si vous utilisez des chaînes de longueurs identiques ou supérieures, l'exécution des méthodes d'expression régulières peut prendre très longtemps lorsqu'elles traitent une entrée qui ne correspond pas au modèle d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="5693e-255">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>

## <a name="controlling-backtracking"></a><span data-ttu-id="5693e-256">Contrôle de la rétroaction</span><span class="sxs-lookup"><span data-stu-id="5693e-256">Controlling Backtracking</span></span>  
 <span data-ttu-id="5693e-257">La rétroaction vous permet de créer des expressions régulières puissantes et flexibles.</span><span class="sxs-lookup"><span data-stu-id="5693e-257">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="5693e-258">Toutefois, comme la section précédente l'indiquait, ces avantages peuvent s'accompagner de performances médiocres.</span><span class="sxs-lookup"><span data-stu-id="5693e-258">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="5693e-259">Pour empêcher la rétroaction excessive, vous devez définir un intervalle de délai d'attente lorsque vous instanciez un objet <xref:System.Text.RegularExpressions.Regex> ou appelez une méthode de mise en correspondance statique d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="5693e-259">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="5693e-260">Cette situation est présentée dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="5693e-260">This is discussed in the next section.</span></span> <span data-ttu-id="5693e-261">En outre, .NET prend en charge trois éléments de langage d’expression régulière qui limitent ou suppriment la rétroaction et qui prennent en charge des expressions régulières complexes avec peu ou pas de dégradation des performances : les [groupes atomiques](#atomic-groups), les [assertions de postanalyse](#lookbehind-assertions)et les [assertions de préanalyse](#lookahead-assertions).</span><span class="sxs-lookup"><span data-stu-id="5693e-261">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [atomic groups](#atomic-groups), [lookbehind assertions](#lookbehind-assertions), and [lookahead assertions](#lookahead-assertions).</span></span> <span data-ttu-id="5693e-262">Pour plus d’informations sur chaque élément de langage, consultez [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="5693e-262">For more information about each language element, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>  

### <a name="defining-a-time-out-interval"></a><span data-ttu-id="5693e-263">Définir un intervalle de délai d'attente</span><span class="sxs-lookup"><span data-stu-id="5693e-263">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="5693e-264">À partir de .NET Framework 4.5, vous pouvez définir un intervalle de délai d’attente qui représente la durée maximale pendant laquelle le moteur d’expression régulière recherche une correspondance avant d’abandonner la tentative et de lever une exception <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="5693e-264">Starting with the .NET Framework 4.5, you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="5693e-265">Vous spécifiez l'intervalle de délai d'attente en donnant une valeur <xref:System.TimeSpan> au constructeur <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> pour les expressions régulières d'instances.</span><span class="sxs-lookup"><span data-stu-id="5693e-265">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor for instance regular expressions.</span></span> <span data-ttu-id="5693e-266">De plus, chaque méthode de mise en correspondance statique possède une surcharge avec un paramètre <xref:System.TimeSpan> qui vous permet de spécifier une valeur de délai d'attente.</span><span class="sxs-lookup"><span data-stu-id="5693e-266">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="5693e-267">Par défaut, l'intervalle de délai d'attente est défini sur <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> et le moteur des expressions régulières n'expire pas.</span><span class="sxs-lookup"><span data-stu-id="5693e-267">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="5693e-268">Il est recommandé de toujours définir un intervalle de délai d'attente si votre expression régulière repose sur la restauration.</span><span class="sxs-lookup"><span data-stu-id="5693e-268">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="5693e-269">Une exception <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> indique que le moteur des expressions régulières n’a pas pu trouver de correspondance dans l’intervalle de délai d’attente spécifié, mais n’indique pas pourquoi l’exception a été levée.</span><span class="sxs-lookup"><span data-stu-id="5693e-269">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="5693e-270">Cela peut provenir de la rétroaction excessive, mais il est possible que l'intervalle de délai d'attente était trop faible étant donné la charge système au moment où l'exception a été levée.</span><span class="sxs-lookup"><span data-stu-id="5693e-270">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="5693e-271">Lorsque vous gérez l'exception, vous pouvez choisir d'abandonner d'autres correspondances avec la chaîne d'entrée ou augmenter l'intervalle de délai d'attente et de retenter l'opération de mise en correspondance.</span><span class="sxs-lookup"><span data-stu-id="5693e-271">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="5693e-272">Par exemple, le code suivant appelle le constructeur <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> pour instancier un objet <xref:System.Text.RegularExpressions.Regex> avec un délai d'attente d'une seconde.</span><span class="sxs-lookup"><span data-stu-id="5693e-272">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="5693e-273">Le modèle d'expression régulière `(a+)+$`, qui correspond à une ou plusieurs séquences d'un ou plusieurs caractères « a » à la fin d'une ligne, est soumis à une rétroaction excessive.</span><span class="sxs-lookup"><span data-stu-id="5693e-273">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="5693e-274">Si une <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> est levée, l'exemple augmente la valeur du délai d'attente jusqu'à un intervalle maximal de trois secondes.</span><span class="sxs-lookup"><span data-stu-id="5693e-274">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="5693e-275">Après cela, il abandonne la tentative pour mettre en correspondance le modèle.</span><span class="sxs-lookup"><span data-stu-id="5693e-275">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  

### <a name="atomic-groups"></a><span data-ttu-id="5693e-276">Groupes atomiques</span><span class="sxs-lookup"><span data-stu-id="5693e-276">Atomic groups</span></span>
 <span data-ttu-id="5693e-277">L’élément de langage sous- `(?>` *expression* `)` supprime la rétroaction dans la sous-expression.</span><span class="sxs-lookup"><span data-stu-id="5693e-277">The `(?>` *subexpression*`)` language element suppresses backtracking into the subexpression.</span></span> <span data-ttu-id="5693e-278">Une fois qu’il a été mis en correspondance, il n’accorde aucune partie de sa correspondance à la rétroaction suivante.</span><span class="sxs-lookup"><span data-stu-id="5693e-278">Once it has successfully matched, it will not give up any part of its match to subsequent backtracking.</span></span> <span data-ttu-id="5693e-279">Par exemple, dans le modèle `(?>\w*\d*)1` , si le `1` ne peut pas être mis en correspondance, le n' `\d*` abandonnera aucune de ses correspondances, même si cela signifie qu’il autorisera la `1` correspondance avec.</span><span class="sxs-lookup"><span data-stu-id="5693e-279">For example, in the pattern `(?>\w*\d*)1`, if the `1` cannot be matched, the `\d*` will not give up any of its match even if that means it would allow the `1` to successfully match.</span></span> <span data-ttu-id="5693e-280">Les groupes atomiques peuvent aider à éviter les problèmes de performances associés aux correspondances ayant échoué.</span><span class="sxs-lookup"><span data-stu-id="5693e-280">Atomic groups can help prevent the performance problems associated with failed matches.</span></span>
  
 <span data-ttu-id="5693e-281">L'exemple suivant montre comment la suppression de la rétroaction améliore les performances lors de l'utilisation de quantificateurs imbriqués.</span><span class="sxs-lookup"><span data-stu-id="5693e-281">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="5693e-282">Il mesure le temps nécessaire pour que le moteur des expressions régulières détermine qu'une chaîne d'entrée ne correspond pas à deux expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="5693e-282">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="5693e-283">La première expression régulière utilise la rétroaction pour tenter de mettre en correspondance une chaîne qui contient une ou plusieurs occurrences d'un ou plusieurs chiffres hexadécimaux, suivi d'un signe deux-points, suivi d'un ou plusieurs chiffres hexadécimaux, suivi de deux signes deux-points.</span><span class="sxs-lookup"><span data-stu-id="5693e-283">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="5693e-284">La seconde expression régulière est identique à la première, à ceci près qu'elle désactive la rétroaction.</span><span class="sxs-lookup"><span data-stu-id="5693e-284">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="5693e-285">Comme la sortie de l'exemple l'indique, l'amélioration des performances due à la désactivation de la rétroaction est considérable.</span><span class="sxs-lookup"><span data-stu-id="5693e-285">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  

### <a name="lookbehind-assertions"></a><span data-ttu-id="5693e-286">assertions de postanalyse</span><span class="sxs-lookup"><span data-stu-id="5693e-286">Lookbehind Assertions</span></span>  
 <span data-ttu-id="5693e-287">.NET comprend deux éléments de langage, sous- `(?<=` *expression* `)` et sous- `(?<!` *expression* `)` , qui correspondent au ou aux caractères précédents de la chaîne d’entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-287">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="5693e-288">Les deux éléments de langage sont des assertions de largeur nulle ; c’est-à-dire qu’ils déterminent si le ou les caractères qui précèdent immédiatement le caractère actuel peuvent être mis en correspondance par la *sous-expression*, sans avancer ou utiliser la rétroaction.</span><span class="sxs-lookup"><span data-stu-id="5693e-288">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="5693e-289">`(?<=`sous- *expression* `)` est une assertion de postanalyse positive ; autrement dit, le ou les caractères situés avant la position actuelle doivent correspondre à la sous- *expression*.</span><span class="sxs-lookup"><span data-stu-id="5693e-289">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="5693e-290">`(?<!`sous- *expression* `)` est une assertion de postanalyse négative ; autrement dit, le ou les caractères situés avant la position actuelle ne doivent pas correspondre à la sous- *expression*.</span><span class="sxs-lookup"><span data-stu-id="5693e-290">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="5693e-291">Les assertions de postanalyse positive et négative sont très utiles quand la sous- *expression* est un sous-ensemble de la sous-expression précédente.</span><span class="sxs-lookup"><span data-stu-id="5693e-291">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="5693e-292">L'exemple suivant utilise deux modèles d'expressions régulières équivalents qui valident le nom d'utilisateur dans une adresse e-mail.</span><span class="sxs-lookup"><span data-stu-id="5693e-292">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="5693e-293">Le premier modèle est sujet à des performances médiocres dues à une rétroaction excessive.</span><span class="sxs-lookup"><span data-stu-id="5693e-293">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="5693e-294">Le second modèle modifie la première expression régulière en remplaçant un quantificateur imbriqué par une assertion de postanalyse positive.</span><span class="sxs-lookup"><span data-stu-id="5693e-294">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="5693e-295">La sortie de l'exemple indique la durée d'exécution de la méthode <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5693e-295">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="5693e-296">Le premier modèle d'expression régulière, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="5693e-296">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5693e-297">Modèle</span><span class="sxs-lookup"><span data-stu-id="5693e-297">Pattern</span></span>|<span data-ttu-id="5693e-298">Description</span><span class="sxs-lookup"><span data-stu-id="5693e-298">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="5693e-299">Démarrer la correspondance au début de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="5693e-299">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="5693e-300">Mettre en correspondance un caractère alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="5693e-300">Match an alphanumeric character.</span></span> <span data-ttu-id="5693e-301">Cette comparaison ne respecte pas la casse, parce que la méthode <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> est appelée avec l'option <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5693e-301">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="5693e-302">Mettre en correspondance zéro, une ou plusieurs occurrences d'un trait d'union, d'un point ou d'un caractère alphabétique.</span><span class="sxs-lookup"><span data-stu-id="5693e-302">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="5693e-303">Mettre en correspondance un caractère alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="5693e-303">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="5693e-304">Mettre en correspondance zéro, une ou plusieurs occurrences de la combinaison de zéro ou plus traits d'union, points ou caractères alphabétiques, suivis d'un caractère alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="5693e-304">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="5693e-305">Il s'agit du premier groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="5693e-305">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="5693e-306">Mettre en correspondance une arobase (« \@ »).</span><span class="sxs-lookup"><span data-stu-id="5693e-306">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="5693e-307">Le second modèle d'expression régulière, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, utilise une assertion de postanalyse positive.</span><span class="sxs-lookup"><span data-stu-id="5693e-307">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="5693e-308">Il est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="5693e-308">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5693e-309">Modèle</span><span class="sxs-lookup"><span data-stu-id="5693e-309">Pattern</span></span>|<span data-ttu-id="5693e-310">Description</span><span class="sxs-lookup"><span data-stu-id="5693e-310">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="5693e-311">Démarrer la correspondance au début de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="5693e-311">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="5693e-312">Mettre en correspondance un caractère alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="5693e-312">Match an alphanumeric character.</span></span> <span data-ttu-id="5693e-313">Cette comparaison ne respecte pas la casse, parce que la méthode <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> est appelée avec l'option <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5693e-313">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="5693e-314">Mettre en correspondance zéro, une ou plusieurs occurrences d'un trait d'union, d'un point ou d'un caractère alphabétique.</span><span class="sxs-lookup"><span data-stu-id="5693e-314">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="5693e-315">Remonter au dernier caractère mis en correspondance et continuer la mise en correspondances si elle est alphanumérique.</span><span class="sxs-lookup"><span data-stu-id="5693e-315">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="5693e-316">Notez que les caractères alphanumériques sont un sous-ensemble du jeu qui se compose de points, de traits d'union et de tous les caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="5693e-316">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="5693e-317">Mettre en correspondance une arobase (« \@ »).</span><span class="sxs-lookup"><span data-stu-id="5693e-317">Match an at sign ("\@").</span></span>|  

### <a name="lookahead-assertions"></a><span data-ttu-id="5693e-318">assertions de préanalyse</span><span class="sxs-lookup"><span data-stu-id="5693e-318">Lookahead Assertions</span></span>  
 <span data-ttu-id="5693e-319">.NET comprend deux éléments de langage, sous- `(?=` *expression* `)` et sous- `(?!` *expression* `)` , qui correspondent au ou aux caractères suivants dans la chaîne d’entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-319">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="5693e-320">Les deux éléments de langage sont des assertions de largeur nulle ; c’est-à-dire qu’ils déterminent si le ou les caractères qui suivent immédiatement le caractère actuel peuvent être mis en correspondance par la *sous-expression*, sans avancer ou utiliser la rétroaction.</span><span class="sxs-lookup"><span data-stu-id="5693e-320">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="5693e-321">`(?=`sous- *expression* `)` est une assertion de préanalyse positive ; autrement dit, le ou les caractères situés après la position actuelle doivent correspondre à la sous- *expression*.</span><span class="sxs-lookup"><span data-stu-id="5693e-321">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="5693e-322">`(?!`sous- *expression* `)` est une assertion de préanalyse négative ; autrement dit, le ou les caractères situés après la position actuelle ne doivent pas correspondre à la sous- *expression*.</span><span class="sxs-lookup"><span data-stu-id="5693e-322">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="5693e-323">Les assertions de préanalyse positive et négative sont très utiles quand la sous- *expression* est un sous-ensemble de la sous-expression suivante.</span><span class="sxs-lookup"><span data-stu-id="5693e-323">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="5693e-324">L'exemple suivant utilise deux modèles d'expressions régulières équivalentes qui valident un nom de type qualifié complet.</span><span class="sxs-lookup"><span data-stu-id="5693e-324">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="5693e-325">Le premier modèle est sujet à des performances médiocres dues à une rétroaction excessive.</span><span class="sxs-lookup"><span data-stu-id="5693e-325">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="5693e-326">Le second modifie la première expression régulière en remplaçant un quantificateur imbriqué par une assertion de préanalyse positive.</span><span class="sxs-lookup"><span data-stu-id="5693e-326">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="5693e-327">La sortie de l'exemple indique la durée d'exécution de la méthode <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5693e-327">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="5693e-328">Le premier modèle d'expression régulière, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="5693e-328">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5693e-329">Modèle</span><span class="sxs-lookup"><span data-stu-id="5693e-329">Pattern</span></span>|<span data-ttu-id="5693e-330">Description</span><span class="sxs-lookup"><span data-stu-id="5693e-330">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="5693e-331">Démarrer la correspondance au début de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="5693e-331">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="5693e-332">Mettre en correspondance un caractère alphabétique (A-Z) suivi de zéro, un ou plusieurs caractères alphabétiques une ou plusieurs fois, suivi d'un point.</span><span class="sxs-lookup"><span data-stu-id="5693e-332">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="5693e-333">Cette comparaison ne respecte pas la casse, parce que la méthode <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> est appelée avec l'option <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5693e-333">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="5693e-334">Mettre en correspondance le modèle précédent, zéro, une ou plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="5693e-334">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="5693e-335">Mettre en correspondance un caractère alphabétique suivi de zéro, un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="5693e-335">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="5693e-336">Terminer la correspondance à la fin de la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-336">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="5693e-337">Le second modèle d'expression régulière, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, utilise une assertion de préanalyse positive.</span><span class="sxs-lookup"><span data-stu-id="5693e-337">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="5693e-338">Il est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="5693e-338">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5693e-339">Modèle</span><span class="sxs-lookup"><span data-stu-id="5693e-339">Pattern</span></span>|<span data-ttu-id="5693e-340">Description</span><span class="sxs-lookup"><span data-stu-id="5693e-340">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="5693e-341">Démarrer la correspondance au début de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="5693e-341">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="5693e-342">Effectuer une préanalyse du premier caractère et continuer la mise en correspondance s'il est alphabétique (A-Z).</span><span class="sxs-lookup"><span data-stu-id="5693e-342">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="5693e-343">Cette comparaison ne respecte pas la casse, parce que la méthode <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> est appelée avec l'option <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5693e-343">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="5693e-344">Mettre en correspondance un ou plusieurs caractères alphabétiques suivis d'un point.</span><span class="sxs-lookup"><span data-stu-id="5693e-344">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="5693e-345">Mettre en correspondance un ou plusieurs caractères alphabétiques suivis d'un point zéro, une ou plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="5693e-345">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="5693e-346">Le caractère alphabétique initial doit être alphabétique.</span><span class="sxs-lookup"><span data-stu-id="5693e-346">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="5693e-347">Mettre en correspondance un caractère alphabétique suivi de zéro, un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="5693e-347">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="5693e-348">Terminer la correspondance à la fin de la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="5693e-348">End the match at the end of the input string.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="5693e-349">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="5693e-349">See also</span></span>

- [<span data-ttu-id="5693e-350">Expressions régulières .NET</span><span class="sxs-lookup"><span data-stu-id="5693e-350">.NET Regular Expressions</span></span>](regular-expressions.md)
- [<span data-ttu-id="5693e-351">Langage des expressions régulières - Aide-mémoire</span><span class="sxs-lookup"><span data-stu-id="5693e-351">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="5693e-352">Quantificateurs</span><span class="sxs-lookup"><span data-stu-id="5693e-352">Quantifiers</span></span>](quantifiers-in-regular-expressions.md)
- [<span data-ttu-id="5693e-353">Constructions d’alternative</span><span class="sxs-lookup"><span data-stu-id="5693e-353">Alternation Constructs</span></span>](alternation-constructs-in-regular-expressions.md)
- [<span data-ttu-id="5693e-354">Constructions de regroupement</span><span class="sxs-lookup"><span data-stu-id="5693e-354">Grouping Constructs</span></span>](grouping-constructs-in-regular-expressions.md)
