---
title: quantificateurs dans les expressions régulières
description: En savoir plus sur les quantificateurs d’expressions régulières, qui spécifient le nombre d’instances d’un caractère, d’un groupe ou d’une classe de caractères devant être présentes dans l’entrée à mettre en correspondance.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
ms.openlocfilehash: 361286b992180e1d7fdf18d88022780cc3aa53fc
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/28/2020
ms.locfileid: "92889424"
---
# <a name="quantifiers-in-regular-expressions"></a><span data-ttu-id="fc386-103">quantificateurs dans les expressions régulières</span><span class="sxs-lookup"><span data-stu-id="fc386-103">Quantifiers in Regular Expressions</span></span>
<span data-ttu-id="fc386-104">Les quantificateurs spécifient le nombre d’instances d’un caractère, groupe ou classe de caractères devant être présentes dans l’entrée pour qu’une correspondance soit trouvée.</span><span class="sxs-lookup"><span data-stu-id="fc386-104">Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</span></span>  <span data-ttu-id="fc386-105">Le tableau suivant répertorie les quantificateurs pris en charge par .NET.</span><span class="sxs-lookup"><span data-stu-id="fc386-105">The following table lists the quantifiers supported by .NET.</span></span>  
  
|<span data-ttu-id="fc386-106">Quantificateur gourmand</span><span class="sxs-lookup"><span data-stu-id="fc386-106">Greedy quantifier</span></span>|<span data-ttu-id="fc386-107">Quantificateur paresseux</span><span class="sxs-lookup"><span data-stu-id="fc386-107">Lazy quantifier</span></span>|<span data-ttu-id="fc386-108">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-108">Description</span></span>|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|<span data-ttu-id="fc386-109">Mettre en correspondance zéro occurrence ou plus.</span><span class="sxs-lookup"><span data-stu-id="fc386-109">Match zero or more times.</span></span>|  
|`+`|`+?`|<span data-ttu-id="fc386-110">Mettre en correspondance une ou plusieurs occurrences.</span><span class="sxs-lookup"><span data-stu-id="fc386-110">Match one or more times.</span></span>|  
|`?`|`??`|<span data-ttu-id="fc386-111">Mettre en correspondance zéro ou une occurrence.</span><span class="sxs-lookup"><span data-stu-id="fc386-111">Match zero or one time.</span></span>|  
|<span data-ttu-id="fc386-112">`{`*n*`}`</span><span class="sxs-lookup"><span data-stu-id="fc386-112">`{` *n* `}`</span></span>|<span data-ttu-id="fc386-113">`{`*n*`}?`</span><span class="sxs-lookup"><span data-stu-id="fc386-113">`{` *n* `}?`</span></span>|<span data-ttu-id="fc386-114">Mettre en correspondance exactement *n* occurrences.</span><span class="sxs-lookup"><span data-stu-id="fc386-114">Match exactly *n* times.</span></span>|  
|<span data-ttu-id="fc386-115">`{`*n*`,}`</span><span class="sxs-lookup"><span data-stu-id="fc386-115">`{` *n* `,}`</span></span>|<span data-ttu-id="fc386-116">`{`*n*`,}?`</span><span class="sxs-lookup"><span data-stu-id="fc386-116">`{` *n* `,}?`</span></span>|<span data-ttu-id="fc386-117">Mettre en correspondance au moins *n* occurrences.</span><span class="sxs-lookup"><span data-stu-id="fc386-117">Match at least *n* times.</span></span>|  
|<span data-ttu-id="fc386-118">`{`*n* `,` *m*`}`</span><span class="sxs-lookup"><span data-stu-id="fc386-118">`{` *n* `,` *m* `}`</span></span>|<span data-ttu-id="fc386-119">`{`*n* `,` *m*`}?`</span><span class="sxs-lookup"><span data-stu-id="fc386-119">`{` *n* `,` *m* `}?`</span></span>|<span data-ttu-id="fc386-120">Mettre en correspondance entre *n* et *m* occurrences.</span><span class="sxs-lookup"><span data-stu-id="fc386-120">Match from *n* to *m* times.</span></span>|  
  
 <span data-ttu-id="fc386-121">Les quantités `n` et `m` sont des constantes entières.</span><span class="sxs-lookup"><span data-stu-id="fc386-121">The quantities `n` and `m` are integer constants.</span></span> <span data-ttu-id="fc386-122">Habituellement, les quantificateurs sont gourmands ; ils obligent le moteur d’expression régulière à faire correspondre autant d’occurrences de modèles particuliers que possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-122">Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</span></span> <span data-ttu-id="fc386-123">L’ajout du caractère `?` à un quantificateur le rend paresseux ; le moteur d’expression régulière fait alors correspondre aussi peu d’occurrences que possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-123">Appending the `?` character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</span></span> <span data-ttu-id="fc386-124">Pour une description complète de la différence entre quantificateurs gourmands et paresseux, consultez la section [Quantificateurs gourmands et paresseux](#Greedy) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="fc386-124">For a complete description of the difference between greedy and lazy quantifiers, see the section [Greedy and Lazy Quantifiers](#Greedy) later in this topic.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="fc386-125">L’imbrication des quantificateurs (par exemple, comme le fait le modèle d’expression régulière `(a*)*`) peut augmenter le nombre de comparaisons que le moteur d’expression régulière doit exécuter, comme une fonction exponentielle du nombre de caractères dans la chaîne d’entrée.</span><span class="sxs-lookup"><span data-stu-id="fc386-125">Nesting quantifiers (for example, as the regular expression pattern `(a*)*` does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</span></span> <span data-ttu-id="fc386-126">Pour plus d’informations sur ce comportement et ses solutions de contournement, consultez [Rétroaction](backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="fc386-126">For more information about this behavior and its workarounds, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="regular-expression-quantifiers"></a><span data-ttu-id="fc386-127">Quantificateurs d’expression régulière</span><span class="sxs-lookup"><span data-stu-id="fc386-127">Regular Expression Quantifiers</span></span>  
 <span data-ttu-id="fc386-128">Les sections suivantes présentent les quantificateurs pris en charge par les expressions régulières .NET.</span><span class="sxs-lookup"><span data-stu-id="fc386-128">The following sections list the quantifiers supported by .NET regular expressions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fc386-129">Si les caractères \*, +, ?, { et } sont rencontrés dans un modèle d’expressions régulières, le moteur d’expression régulière les interprète comme des quantificateurs ou partie de constructions de quantificateur à moins qu’ils ne soient inclus dans une [classe de caractères](character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="fc386-129">If the \*, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a [character class](character-classes-in-regular-expressions.md).</span></span> <span data-ttu-id="fc386-130">Pour les interpréter comme des caractères littéraux en dehors d’une classe de caractères, vous devez les placer dans une séquence d’échappement en les faisant précéder d’une barre oblique inverse.</span><span class="sxs-lookup"><span data-stu-id="fc386-130">To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</span></span> <span data-ttu-id="fc386-131">Par exemple, la chaîne `\*` dans un modèle d’expression régulière est interprétée comme un caractère astérisque (« \* ») littéral.</span><span class="sxs-lookup"><span data-stu-id="fc386-131">For example, the string `\*` in a regular expression pattern is interpreted as a literal asterisk ("\*") character.</span></span>  
  
### <a name="match-zero-or-more-times-"></a><span data-ttu-id="fc386-132">Mettre en correspondance zéro occurrence ou plus : \*</span><span class="sxs-lookup"><span data-stu-id="fc386-132">Match Zero or More Times: \*</span></span>  
 <span data-ttu-id="fc386-133">Le quantificateur `*` correspond zéro fois, ou plus, à l’élément qui précède.</span><span class="sxs-lookup"><span data-stu-id="fc386-133">The `*` quantifier matches the preceding element zero or more times.</span></span> <span data-ttu-id="fc386-134">Il équivaut au quantificateur `{0,}`.</span><span class="sxs-lookup"><span data-stu-id="fc386-134">It is equivalent to the `{0,}` quantifier.</span></span> <span data-ttu-id="fc386-135">`*` est un quantificateur gourmand dont l’équivalent paresseux est `*?`.</span><span class="sxs-lookup"><span data-stu-id="fc386-135">`*` is a greedy quantifier whose lazy equivalent is `*?`.</span></span>  
  
 <span data-ttu-id="fc386-136">L’exemple suivant illustre cette expression régulière.</span><span class="sxs-lookup"><span data-stu-id="fc386-136">The following example illustrates this regular expression.</span></span> <span data-ttu-id="fc386-137">Parmi les neuf groupes de chiffres de la chaîne d’entrée, cinq correspondent au modèle et quatre ( `95` , `929` , `9219` et `9919` ) ne le font pas.</span><span class="sxs-lookup"><span data-stu-id="fc386-137">Of the nine digit groups in the input string, five match the pattern and four (`95`, `929`, `9219`, and `9919`) do not.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 <span data-ttu-id="fc386-138">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-138">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="fc386-139">Modèle</span><span class="sxs-lookup"><span data-stu-id="fc386-139">Pattern</span></span>|<span data-ttu-id="fc386-140">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-140">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="fc386-141">Commencer à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-141">Start at a word boundary.</span></span>|  
|`91*`|<span data-ttu-id="fc386-142">Mettre en correspondance un « 9 » suivi de zéro, ou plus, caractère « 1 ».</span><span class="sxs-lookup"><span data-stu-id="fc386-142">Match a "9" followed by zero or more "1" characters.</span></span>|  
|`9*`|<span data-ttu-id="fc386-143">Mettre en correspondance zéro, ou plus, caractère « 9 ».</span><span class="sxs-lookup"><span data-stu-id="fc386-143">Match zero or more "9" characters.</span></span>|  
|`\b`|<span data-ttu-id="fc386-144">Terminer à une limite de mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-144">End at a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-"></a><span data-ttu-id="fc386-145">Mettre en correspondance un ou plusieurs chiffres : +</span><span class="sxs-lookup"><span data-stu-id="fc386-145">Match One or More Times: +</span></span>  
 <span data-ttu-id="fc386-146">Le quantificateur `+` correspond une ou plusieurs fois à l’élément qui précède.</span><span class="sxs-lookup"><span data-stu-id="fc386-146">The `+` quantifier matches the preceding element one or more times.</span></span> <span data-ttu-id="fc386-147">Il équivaut à `{1,}`.</span><span class="sxs-lookup"><span data-stu-id="fc386-147">It is equivalent to `{1,}`.</span></span> <span data-ttu-id="fc386-148">`+` est un quantificateur gourmand dont l’équivalent paresseux est `+?`.</span><span class="sxs-lookup"><span data-stu-id="fc386-148">`+` is a greedy quantifier whose lazy equivalent is `+?`.</span></span>  
  
 <span data-ttu-id="fc386-149">Par exemple, l’expression régulière `\ban+\w*?\b` tente d’établir une correspondance avec les mots entiers qui commencent par la lettre `a` suivie d’une ou de plusieurs instances de la lettre `n`.</span><span class="sxs-lookup"><span data-stu-id="fc386-149">For example, the regular expression `\ban+\w*?\b` tries to match entire words that begin with the letter `a` followed by one or more instances of the letter `n`.</span></span> <span data-ttu-id="fc386-150">L’exemple suivant illustre cette expression régulière.</span><span class="sxs-lookup"><span data-stu-id="fc386-150">The following example illustrates this regular expression.</span></span> <span data-ttu-id="fc386-151">L’expression régulière établit une correspondance avec les mots `an`, `annual`, `announcement` et `antique`, et pas avec les mots `autumn` et `all`.</span><span class="sxs-lookup"><span data-stu-id="fc386-151">The regular expression matches the words `an`, `annual`, `announcement`, and `antique`, and correctly fails to match `autumn` and `all`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 <span data-ttu-id="fc386-152">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-152">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="fc386-153">Modèle</span><span class="sxs-lookup"><span data-stu-id="fc386-153">Pattern</span></span>|<span data-ttu-id="fc386-154">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-154">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="fc386-155">Commencer à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-155">Start at a word boundary.</span></span>|  
|`an+`|<span data-ttu-id="fc386-156">Mettre en correspondance un « a » suivi d’un ou plusieurs caractères « n ».</span><span class="sxs-lookup"><span data-stu-id="fc386-156">Match an "a" followed by one or more "n" characters.</span></span>|  
|`\w*?`|<span data-ttu-id="fc386-157">Mettre en correspondance un caractère alphabétique zéro, une ou plusieurs fois, mais le moins de fois possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-157">Match a word character zero or more times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="fc386-158">Terminer à une limite de mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-158">End at a word boundary.</span></span>|  
  
### <a name="match-zero-or-one-time-"></a><span data-ttu-id="fc386-159">Mettre en correspondance zéro ou une occurrence : ?</span><span class="sxs-lookup"><span data-stu-id="fc386-159">Match Zero or One Time: ?</span></span>  
 <span data-ttu-id="fc386-160">Le quantificateur `?` correspond zéro ou une fois à l’élément qui précède.</span><span class="sxs-lookup"><span data-stu-id="fc386-160">The `?` quantifier matches the preceding element zero or one time.</span></span> <span data-ttu-id="fc386-161">Il équivaut à `{0,1}`.</span><span class="sxs-lookup"><span data-stu-id="fc386-161">It is equivalent to `{0,1}`.</span></span> <span data-ttu-id="fc386-162">`?` est un quantificateur gourmand dont l’équivalent paresseux est `??`.</span><span class="sxs-lookup"><span data-stu-id="fc386-162">`?` is a greedy quantifier whose lazy equivalent is `??`.</span></span>  
  
 <span data-ttu-id="fc386-163">Par exemple, l’expression régulière `\ban?\b` tente d’établir une correspondance avec les mots entiers qui commencent par la lettre `a` suivie de zéro ou une instance de la lettre `n`.</span><span class="sxs-lookup"><span data-stu-id="fc386-163">For example, the regular expression `\ban?\b` tries to match entire words that begin with the letter `a` followed by zero or one instances of the letter `n`.</span></span> <span data-ttu-id="fc386-164">En d’autres termes, elle tente d’établir une correspondance avec les mots `a` et `an`.</span><span class="sxs-lookup"><span data-stu-id="fc386-164">In other words, it tries to match the words `a` and `an`.</span></span> <span data-ttu-id="fc386-165">L’exemple suivant illustre cette expression régulière.</span><span class="sxs-lookup"><span data-stu-id="fc386-165">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 <span data-ttu-id="fc386-166">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-166">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="fc386-167">Modèle</span><span class="sxs-lookup"><span data-stu-id="fc386-167">Pattern</span></span>|<span data-ttu-id="fc386-168">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-168">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="fc386-169">Commencer à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-169">Start at a word boundary.</span></span>|  
|`an?`|<span data-ttu-id="fc386-170">Mettre en correspondance un « a » suivi de zéro ou un caractère « n ».</span><span class="sxs-lookup"><span data-stu-id="fc386-170">Match an "a" followed by zero or one "n" character.</span></span>|  
|`\b`|<span data-ttu-id="fc386-171">Terminer à une limite de mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-171">End at a word boundary.</span></span>|  
  
### <a name="match-exactly-n-times-n"></a><span data-ttu-id="fc386-172">Mettre en correspondance exactement n occurrences : {n}</span><span class="sxs-lookup"><span data-stu-id="fc386-172">Match Exactly n Times: {n}</span></span>  
 <span data-ttu-id="fc386-173">Le `{` *n* `}` quantificateur n correspond à l’élément qui précède exactement *n* fois, où *n* est un entier.</span><span class="sxs-lookup"><span data-stu-id="fc386-173">The `{`*n*`}` quantifier matches the preceding element exactly *n* times, where *n* is any integer.</span></span> <span data-ttu-id="fc386-174">`{`*n* `}` est un quantificateur gourmand dont l’équivalent paresseux est `{` *n* `}?` .</span><span class="sxs-lookup"><span data-stu-id="fc386-174">`{`*n*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`}?`.</span></span>  
  
 <span data-ttu-id="fc386-175">Par exemple, l’expression régulière `\b\d+\,\d{3}\b` tente d’établir une correspondance avec une limite de mot suivie d’un ou de plusieurs chiffres décimaux suivis de trois chiffres décimaux suivis d’une limite de mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-175">For example, the regular expression `\b\d+\,\d{3}\b` tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</span></span> <span data-ttu-id="fc386-176">L’exemple suivant illustre cette expression régulière.</span><span class="sxs-lookup"><span data-stu-id="fc386-176">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 <span data-ttu-id="fc386-177">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-177">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="fc386-178">Modèle</span><span class="sxs-lookup"><span data-stu-id="fc386-178">Pattern</span></span>|<span data-ttu-id="fc386-179">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-179">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="fc386-180">Commencer à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-180">Start at a word boundary.</span></span>|  
|`\d+`|<span data-ttu-id="fc386-181">Mettre en correspondance un ou plusieurs chiffres décimaux.</span><span class="sxs-lookup"><span data-stu-id="fc386-181">Match one or more decimal digits.</span></span>|  
|`\,`|<span data-ttu-id="fc386-182">Mettre en correspondance une virgule.</span><span class="sxs-lookup"><span data-stu-id="fc386-182">Match a comma character.</span></span>|  
|`\d{3}`|<span data-ttu-id="fc386-183">Mettre en correspondance trois chiffres décimaux.</span><span class="sxs-lookup"><span data-stu-id="fc386-183">Match three decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="fc386-184">Terminer à une limite de mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-184">End at a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-n"></a><span data-ttu-id="fc386-185">Mettre en correspondance au moins n occurrences : {n,}</span><span class="sxs-lookup"><span data-stu-id="fc386-185">Match at Least n Times: {n,}</span></span>  
 <span data-ttu-id="fc386-186">Le `{` *n* `,}` quantificateur n correspond à l’élément qui précède au moins *n* fois, où *n* est un entier.</span><span class="sxs-lookup"><span data-stu-id="fc386-186">The `{`*n*`,}` quantifier matches the preceding element at least *n* times, where *n* is any integer.</span></span> <span data-ttu-id="fc386-187">`{`*n* `,}` est un quantificateur gourmand dont l’équivalent paresseux est `{` *n* `,}?` .</span><span class="sxs-lookup"><span data-stu-id="fc386-187">`{`*n*`,}` is a greedy quantifier whose lazy equivalent is `{`*n*`,}?`.</span></span>  
  
 <span data-ttu-id="fc386-188">Par exemple, l’expression régulière `\b\d{2,}\b\D+` tente d’établir une correspondance avec une limite de mot suivie d’au moins deux chiffres suivis d’une limite de mot et d’un caractère non numérique.</span><span class="sxs-lookup"><span data-stu-id="fc386-188">For example, the regular expression `\b\d{2,}\b\D+` tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</span></span> <span data-ttu-id="fc386-189">L’exemple suivant illustre cette expression régulière.</span><span class="sxs-lookup"><span data-stu-id="fc386-189">The following example illustrates this regular expression.</span></span> <span data-ttu-id="fc386-190">L’expression régulière ne peut pas établir de correspondance avec l’expression `"7 days"`, car elle ne contient qu’un chiffre. En revanche, une correspondance est établie les expressions `"10 weeks and 300 years"`.</span><span class="sxs-lookup"><span data-stu-id="fc386-190">The regular expression fails to match the phrase `"7 days"` because it contains just one decimal digit, but it successfully matches the phrases `"10 weeks and 300 years"`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 <span data-ttu-id="fc386-191">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-191">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="fc386-192">Modèle</span><span class="sxs-lookup"><span data-stu-id="fc386-192">Pattern</span></span>|<span data-ttu-id="fc386-193">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-193">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="fc386-194">Commencer à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-194">Start at a word boundary.</span></span>|  
|`\d{2,}`|<span data-ttu-id="fc386-195">Mettre en correspondance au moins deux chiffres décimaux.</span><span class="sxs-lookup"><span data-stu-id="fc386-195">Match at least two decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="fc386-196">Mettre en correspondance la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-196">Match a word boundary.</span></span>|  
|`\D+`|<span data-ttu-id="fc386-197">Mettre en correspondance au moins un chiffre non décimal.</span><span class="sxs-lookup"><span data-stu-id="fc386-197">Match at least one non-decimal digit.</span></span>|  
  
### <a name="match-between-n-and-m-times-nm"></a><span data-ttu-id="fc386-198">Mettre en correspondance entre n et m fois : {n, m}</span><span class="sxs-lookup"><span data-stu-id="fc386-198">Match Between n and m Times: {n,m}</span></span>  
 <span data-ttu-id="fc386-199">Le `{` quantificateur *n* `,` *m* `}` correspond à l’élément qui précède au moins *n* fois, mais pas plus de *m* fois, où *n* et *m* sont des entiers.</span><span class="sxs-lookup"><span data-stu-id="fc386-199">The `{`*n*`,`*m*`}` quantifier matches the preceding element at least *n* times, but no more than *m* times, where *n* and *m* are integers.</span></span> <span data-ttu-id="fc386-200">`{`*n* `,` *m* `}` est un quantificateur gourmand dont l’équivalent paresseux est `{` *n* `,` *m* `}?` .</span><span class="sxs-lookup"><span data-stu-id="fc386-200">`{`*n*`,`*m*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`,`*m*`}?`.</span></span>  
  
 <span data-ttu-id="fc386-201">Dans l’exemple suivant, l’expression régulière `(00\s){2,4}` tente d’établir une correspondance entre deux et quatre occurrences de deux zéros suivis d’un espace.</span><span class="sxs-lookup"><span data-stu-id="fc386-201">In the following example, the regular expression `(00\s){2,4}` tries to match between two and four occurrences of two zero digits followed by a space.</span></span> <span data-ttu-id="fc386-202">Notez que la partie finale de la chaîne d’entrée inclut ce modèle cinq fois au lieu du maximum de quatre.</span><span class="sxs-lookup"><span data-stu-id="fc386-202">Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</span></span> <span data-ttu-id="fc386-203">Toutefois, seule la partie initiale de cette sous-chaîne (jusqu’à l’espace et la cinquième paire de zéros) correspond au modèle d’expression régulière.</span><span class="sxs-lookup"><span data-stu-id="fc386-203">However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a><span data-ttu-id="fc386-204">Mettre en correspondance zéro occurrence ou plus (correspondance paresseuse) : \*?</span><span class="sxs-lookup"><span data-stu-id="fc386-204">Match Zero or More Times (Lazy Match): \*?</span></span>  
 <span data-ttu-id="fc386-205">Le quantificateur `*?` établit zéro, une ou plusieurs correspondances avec l’élément qui précède, mais le moins de fois possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-205">The `*?` quantifier matches the preceding element zero or more times, but as few times as possible.</span></span> <span data-ttu-id="fc386-206">Il s’agit de l’équivalent paresseux du quantificateur gourmand `*`.</span><span class="sxs-lookup"><span data-stu-id="fc386-206">It is the lazy counterpart of the greedy quantifier `*`.</span></span>  
  
 <span data-ttu-id="fc386-207">Dans l’exemple suivant, l’expression régulière `\b\w*?oo\w*?\b` correspond à tous les mots qui contiennent la chaîne `oo`.</span><span class="sxs-lookup"><span data-stu-id="fc386-207">In the following example, the regular expression `\b\w*?oo\w*?\b` matches all words that contain the string `oo`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 <span data-ttu-id="fc386-208">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-208">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="fc386-209">Modèle</span><span class="sxs-lookup"><span data-stu-id="fc386-209">Pattern</span></span>|<span data-ttu-id="fc386-210">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-210">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="fc386-211">Commencer à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-211">Start at a word boundary.</span></span>|  
|`\w*?`|<span data-ttu-id="fc386-212">Correspond à zéro, un ou plusieurs caractères alphabétiques, mais le moins de caractères possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-212">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`oo`|<span data-ttu-id="fc386-213">Mettre en correspondance la chaîne « oo ».</span><span class="sxs-lookup"><span data-stu-id="fc386-213">Match the string "oo".</span></span>|  
|`\w*?`|<span data-ttu-id="fc386-214">Correspond à zéro, un ou plusieurs caractères alphabétiques, mais le moins de caractères possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-214">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`\b`|<span data-ttu-id="fc386-215">Terminer sur une limite de mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-215">End on a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-lazy-match-"></a><span data-ttu-id="fc386-216">Mettre en correspondance une ou plusieurs occurrences (correspondance paresseuse) : +?</span><span class="sxs-lookup"><span data-stu-id="fc386-216">Match One or More Times (Lazy Match): +?</span></span>  
 <span data-ttu-id="fc386-217">Le quantificateur `+?` établit une ou plusieurs correspondances avec l’élément qui précède, mais le moins de fois possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-217">The `+?` quantifier matches the preceding element one or more times, but as few times as possible.</span></span> <span data-ttu-id="fc386-218">Il s’agit de l’équivalent paresseux du quantificateur gourmand `+`.</span><span class="sxs-lookup"><span data-stu-id="fc386-218">It is the lazy counterpart of the greedy quantifier `+`.</span></span>  
  
 <span data-ttu-id="fc386-219">Par exemple, l’expression régulière `\b\w+?\b` établit une correspondance avec un ou plusieurs caractères séparés par des limites de mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-219">For example, the regular expression `\b\w+?\b` matches one or more characters separated by word boundaries.</span></span> <span data-ttu-id="fc386-220">L’exemple suivant illustre cette expression régulière.</span><span class="sxs-lookup"><span data-stu-id="fc386-220">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a><span data-ttu-id="fc386-221">Mettre en correspondance zéro ou une occurrence (correspondance paresseuse) : ??</span><span class="sxs-lookup"><span data-stu-id="fc386-221">Match Zero or One Time (Lazy Match): ??</span></span>  
 <span data-ttu-id="fc386-222">Le quantificateur `??` établit zéro ou une correspondance avec l’élément qui précède, mais le moins de fois possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-222">The `??` quantifier matches the preceding element zero or one time, but as few times as possible.</span></span> <span data-ttu-id="fc386-223">Il s’agit de l’équivalent paresseux du quantificateur gourmand `?`.</span><span class="sxs-lookup"><span data-stu-id="fc386-223">It is the lazy counterpart of the greedy quantifier `?`.</span></span>  
  
 <span data-ttu-id="fc386-224">Par exemple, l’expression régulière `^\s*(System.)??Console.Write(Line)??\(??` tente d’établir une correspondance avec les chaînes « Console.Write » ou « Console.WriteLine ».</span><span class="sxs-lookup"><span data-stu-id="fc386-224">For example, the regular expression `^\s*(System.)??Console.Write(Line)??\(??` attempts to match the strings "Console.Write" or "Console.WriteLine".</span></span> <span data-ttu-id="fc386-225">La chaîne peut également comprendre « System. »</span><span class="sxs-lookup"><span data-stu-id="fc386-225">The string can also include "System."</span></span> <span data-ttu-id="fc386-226">avant « Console », et elle peut être suivie par une parenthèse ouvrante.</span><span class="sxs-lookup"><span data-stu-id="fc386-226">before "Console", and it can be followed by an opening parenthesis.</span></span> <span data-ttu-id="fc386-227">Elle doit se trouver au début d’une ligne, mais peut être précédée d’un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="fc386-227">The string must be at the beginning of a line, although it can be preceded by white space.</span></span> <span data-ttu-id="fc386-228">L’exemple suivant illustre cette expression régulière.</span><span class="sxs-lookup"><span data-stu-id="fc386-228">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 <span data-ttu-id="fc386-229">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-229">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="fc386-230">Modèle</span><span class="sxs-lookup"><span data-stu-id="fc386-230">Pattern</span></span>|<span data-ttu-id="fc386-231">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-231">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="fc386-232">Mettre en correspondance le début du flux d’entrée.</span><span class="sxs-lookup"><span data-stu-id="fc386-232">Match the start of the input stream.</span></span>|  
|`\s*`|<span data-ttu-id="fc386-233">Correspond à zéro, un ou plusieurs espaces blancs.</span><span class="sxs-lookup"><span data-stu-id="fc386-233">Match zero or more white-space characters.</span></span>|  
|`(System.)??`|<span data-ttu-id="fc386-234">Mettre en correspondance zéro ou une occurrence de la chaîne « System. ».</span><span class="sxs-lookup"><span data-stu-id="fc386-234">Match zero or one occurrence of the string "System.".</span></span>|  
|`Console.Write`|<span data-ttu-id="fc386-235">Mettre en correspondance la chaîne « Console.Write ».</span><span class="sxs-lookup"><span data-stu-id="fc386-235">Match the string "Console.Write".</span></span>|  
|`(Line)??`|<span data-ttu-id="fc386-236">Mettre en correspondance zéro ou une occurrence de la chaîne « Line ».</span><span class="sxs-lookup"><span data-stu-id="fc386-236">Match zero or one occurrence of the string "Line".</span></span>|  
|`\(??`|<span data-ttu-id="fc386-237">Mettre en correspondance zéro occurrence, ou plus, de la parenthèse ouvrante.</span><span class="sxs-lookup"><span data-stu-id="fc386-237">Match zero or one occurrence of the opening parenthesis.</span></span>|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a><span data-ttu-id="fc386-238">Mettre en correspondance exactement n occurrences (correspondance paresseuse) : {n}?</span><span class="sxs-lookup"><span data-stu-id="fc386-238">Match Exactly n Times (Lazy Match): {n}?</span></span>  
 <span data-ttu-id="fc386-239">Le `{` *n* `}?` quantificateur n correspond exactement à l’élément qui précède `n` , où *n* est un entier.</span><span class="sxs-lookup"><span data-stu-id="fc386-239">The `{`*n*`}?` quantifier matches the preceding element exactly `n` times, where *n* is any integer.</span></span> <span data-ttu-id="fc386-240">Il s’agit de l’équivalent paresseux du quantificateur gourmand `{` *n* `}` .</span><span class="sxs-lookup"><span data-stu-id="fc386-240">It is the lazy counterpart of the greedy quantifier `{`*n*`}`.</span></span>  
  
 <span data-ttu-id="fc386-241">Dans l’exemple suivant, l’expression régulière `\b(\w{3,}?\.){2}?\w{3,}?\b` est utilisée pour identifier une adresse de site web.</span><span class="sxs-lookup"><span data-stu-id="fc386-241">In the following example, the regular expression `\b(\w{3,}?\.){2}?\w{3,}?\b` is used to identify a Web site address.</span></span> <span data-ttu-id="fc386-242">Notez qu’elle établit une correspondance avec « www.microsoft.com » et « msdn.microsoft.com », mais pas avec « mywebsite » ou « mycompany.com ».</span><span class="sxs-lookup"><span data-stu-id="fc386-242">Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 <span data-ttu-id="fc386-243">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-243">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="fc386-244">Modèle</span><span class="sxs-lookup"><span data-stu-id="fc386-244">Pattern</span></span>|<span data-ttu-id="fc386-245">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-245">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="fc386-246">Commencer à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-246">Start at a word boundary.</span></span>|  
|`(\w{3,}?\.)`|<span data-ttu-id="fc386-247">Mettre en correspondance au moins 3 caractères alphabétiques, mais le moins de caractères possible, suivis d’un point ou d’un point final.</span><span class="sxs-lookup"><span data-stu-id="fc386-247">Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</span></span> <span data-ttu-id="fc386-248">Il s'agit du premier groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="fc386-248">This is the first capturing group.</span></span>|  
|`(\w{3,}?\.){2}?`|<span data-ttu-id="fc386-249">Mettre en correspondance le modèle dans le premier groupe deux fois, mais le moins de fois possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-249">Match the pattern in the first group two times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="fc386-250">Terminer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-250">End the match on a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a><span data-ttu-id="fc386-251">Mettre en correspondance au moins n occurrences (correspondance paresseuse) : {n,}?</span><span class="sxs-lookup"><span data-stu-id="fc386-251">Match at Least n Times (Lazy Match): {n,}?</span></span>  
 <span data-ttu-id="fc386-252">Le `{` *n* `,}?` quantificateur n correspond à l’élément qui précède au moins `n` fois, où *n* est un entier, mais le moins de fois possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-252">The `{`*n*`,}?` quantifier matches the preceding element at least `n` times, where *n* is any integer, but as few times as possible.</span></span> <span data-ttu-id="fc386-253">Il s’agit de l’équivalent paresseux du quantificateur gourmand `{` *n* `,}` .</span><span class="sxs-lookup"><span data-stu-id="fc386-253">It is the lazy counterpart of the greedy quantifier `{`*n*`,}`.</span></span>  
  
 <span data-ttu-id="fc386-254">Pour obtenir une illustration, consultez l’exemple du `{` quantificateur *n* `}?` dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="fc386-254">See the example for the `{`*n*`}?` quantifier in the previous section for an illustration.</span></span> <span data-ttu-id="fc386-255">L’expression régulière de cet exemple utilise le `{` *n* `,}` quantificateur n pour faire correspondre une chaîne comportant au moins trois caractères suivis d’un point.</span><span class="sxs-lookup"><span data-stu-id="fc386-255">The regular expression in that example uses the `{`*n*`,}` quantifier to match a string that has at least three characters followed by a period.</span></span>  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a><span data-ttu-id="fc386-256">Mettre en correspondance entre n et m fois (correspondance paresseuse) : {n,m}?</span><span class="sxs-lookup"><span data-stu-id="fc386-256">Match Between n and m Times (Lazy Match): {n,m}?</span></span>  
 <span data-ttu-id="fc386-257">Le `{` quantificateur *n* `,` *m* `}?` correspond à l’élément qui précède entre `n` et `m` heures, où *n* et *m* sont des entiers, mais le moins de fois possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-257">The `{`*n*`,`*m*`}?` quantifier matches the preceding element between `n` and `m` times, where *n* and *m* are integers, but as few times as possible.</span></span> <span data-ttu-id="fc386-258">Il s’agit de l’équivalent paresseux du quantificateur gourmand `{` *n* `,` *m* `}` .</span><span class="sxs-lookup"><span data-stu-id="fc386-258">It is the lazy counterpart of the greedy quantifier `{`*n*`,`*m*`}`.</span></span>  
  
 <span data-ttu-id="fc386-259">Dans l’exemple suivant, l’expression régulière `\b[A-Z](\w*?\s*?){1,10}[.!?]` correspond aux phrases qui contiennent entre un et dix mots.</span><span class="sxs-lookup"><span data-stu-id="fc386-259">In the following example, the regular expression `\b[A-Z](\w*?\s*?){1,10}[.!?]` matches sentences that contain between one and ten words.</span></span> <span data-ttu-id="fc386-260">Elle établit une correspondance avec toutes les phrases de la chaîne d’entrée à l’exception d’une phrase qui contient 18 mots.</span><span class="sxs-lookup"><span data-stu-id="fc386-260">It matches all the sentences in the input string except for one sentence that contains 18 words.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 <span data-ttu-id="fc386-261">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-261">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="fc386-262">Modèle</span><span class="sxs-lookup"><span data-stu-id="fc386-262">Pattern</span></span>|<span data-ttu-id="fc386-263">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-263">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="fc386-264">Commencer à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="fc386-264">Start at a word boundary.</span></span>|  
|`[A-Z]`|<span data-ttu-id="fc386-265">Mettre en correspondance une majuscule de A à Z.</span><span class="sxs-lookup"><span data-stu-id="fc386-265">Match an uppercase character from A to Z.</span></span>|  
|`(\w*?\s*?)`|<span data-ttu-id="fc386-266">Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques, suivis d’un ou plusieurs espaces, mais le moins de fois possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-266">Match zero or more word characters, followed by one or more white-space characters, but as few times as possible.</span></span> <span data-ttu-id="fc386-267">Il s’agit du premier groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="fc386-267">This is the first capture group.</span></span>|  
|`{1,10}`|<span data-ttu-id="fc386-268">Mettre en correspondance le modèle précédent entre 1 et 10 fois.</span><span class="sxs-lookup"><span data-stu-id="fc386-268">Match the previous pattern between 1 and 10 times.</span></span>|  
|`[.!?]`|<span data-ttu-id="fc386-269">Mettre en correspondance un signe de ponctuation « . », « ! » ou « ? ».</span><span class="sxs-lookup"><span data-stu-id="fc386-269">Match any one of the punctuation characters ".", "!", or "?".</span></span>|  
  
<a name="Greedy"></a>
## <a name="greedy-and-lazy-quantifiers"></a><span data-ttu-id="fc386-270">Quantificateurs gourmands et paresseux</span><span class="sxs-lookup"><span data-stu-id="fc386-270">Greedy and Lazy Quantifiers</span></span>  
 <span data-ttu-id="fc386-271">De nombreux quantificateurs existent en deux versions :</span><span class="sxs-lookup"><span data-stu-id="fc386-271">A number of the quantifiers have two versions:</span></span>  
  
- <span data-ttu-id="fc386-272">Une version gourmande.</span><span class="sxs-lookup"><span data-stu-id="fc386-272">A greedy version.</span></span>  
  
     <span data-ttu-id="fc386-273">Un quantificateur gourmand essaie de correspondre à un élément autant de fois que possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-273">A greedy quantifier tries to match an element as many times as possible.</span></span>  
  
- <span data-ttu-id="fc386-274">Une version non gourmande (ou paresseuse).</span><span class="sxs-lookup"><span data-stu-id="fc386-274">A non-greedy (or lazy) version.</span></span>  
  
     <span data-ttu-id="fc386-275">Un quantificateur non gourmand essaie de correspondre à un élément aussi peu de fois que possible.</span><span class="sxs-lookup"><span data-stu-id="fc386-275">A non-greedy quantifier tries to match an element as few times as possible.</span></span> <span data-ttu-id="fc386-276">Vous pouvez changer un quantificateur gourmand en quantificateur paresseux en ajoutant simplement un `?`.</span><span class="sxs-lookup"><span data-stu-id="fc386-276">You can turn a greedy quantifier into a lazy quantifier by simply adding a `?`.</span></span>  
  
 <span data-ttu-id="fc386-277">Considérez une expression régulière simple censée extraire les quatre derniers chiffres d’une chaîne de nombres telle qu’un numéro de carte de crédit.</span><span class="sxs-lookup"><span data-stu-id="fc386-277">Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</span></span> <span data-ttu-id="fc386-278">La version de l’expression régulière qui utilise le quantificateur gourmand `*` est `\b.*([0-9]{4})\b`.</span><span class="sxs-lookup"><span data-stu-id="fc386-278">The version of the regular expression that uses the `*` greedy quantifier is `\b.*([0-9]{4})\b`.</span></span> <span data-ttu-id="fc386-279">Toutefois, si une chaîne contient deux nombres, cette expression régulière correspond uniquement aux quatre derniers chiffres du deuxième nombre, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-279">However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 <span data-ttu-id="fc386-280">L’expression régulière ne parvient pas à établir de correspondance avec le premier nombre ; en effet, comme le quantificateur `*` tente d’établir une correspondance autant de fois que possible avec l’élément qui précède dans la totalité de la chaîne, il trouve une correspondance à la fin de celle-ci.</span><span class="sxs-lookup"><span data-stu-id="fc386-280">The regular expression fails to match the first number because the `*` quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</span></span>  
  
 <span data-ttu-id="fc386-281">Il ne s’agit pas du comportement souhaité.</span><span class="sxs-lookup"><span data-stu-id="fc386-281">This is not the desired behavior.</span></span> <span data-ttu-id="fc386-282">Vous pouvez plutôt utiliser le quantificateur paresseux `*?` pour extraire les chiffres des deux nombres, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-282">Instead, you can use the `*?`lazy quantifier to extract digits from both numbers, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 <span data-ttu-id="fc386-283">Dans la plupart des cas, les expressions régulières avec des quantificateurs gourmands et paresseux retournent les mêmes correspondances.</span><span class="sxs-lookup"><span data-stu-id="fc386-283">In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</span></span> <span data-ttu-id="fc386-284">Elles retournent le plus souvent des résultats différents quand elles sont utilisées avec le métacaractère (`.`) générique, qui correspond à n’importe quel caractère.</span><span class="sxs-lookup"><span data-stu-id="fc386-284">They most commonly return different results when they are used with the wildcard (`.`) metacharacter, which matches any character.</span></span>  
  
## <a name="quantifiers-and-empty-matches"></a><span data-ttu-id="fc386-285">Quantificateurs et correspondances vides</span><span class="sxs-lookup"><span data-stu-id="fc386-285">Quantifiers and Empty Matches</span></span>  
 <span data-ttu-id="fc386-286">Les quantificateurs `*` , `+` et `{` *n* `,` *m* `}` et leurs équivalents paresseux ne se répètent jamais après une correspondance vide quand le nombre minimal de captures a été trouvé.</span><span class="sxs-lookup"><span data-stu-id="fc386-286">The quantifiers `*`, `+`, and `{`*n*`,`*m*`}` and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</span></span> <span data-ttu-id="fc386-287">Cette règle empêche les quantificateurs d’entrer dans des boucles infinies sur des correspondances de sous-expressions vides quand le nombre maximal de captures de groupe possibles est infini ou proche de l’infini.</span><span class="sxs-lookup"><span data-stu-id="fc386-287">This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</span></span>  
  
 <span data-ttu-id="fc386-288">Par exemple, le code suivant montre le résultat d’un appel de la méthode <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> avec le modèle d’expression régulière `(a?)*` qui correspond à zéro ou un caractère « a », zéro, une ou plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="fc386-288">For example, the following code shows the result of a call to the <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> method with the regular expression pattern `(a?)*`, which matches zero or one "a" character zero or more times.</span></span> <span data-ttu-id="fc386-289">Notez que le seul groupe de capture capture chaque « a », ainsi que <xref:System.String.Empty?displayProperty=nameWithType>, mais qu’il n’existe aucune deuxième correspondance vide, car la première correspondance vide entraîne l’arrêt de la répétition du quantificateur.</span><span class="sxs-lookup"><span data-stu-id="fc386-289">Note that the single capturing group captures each "a" as well as <xref:System.String.Empty?displayProperty=nameWithType>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 <span data-ttu-id="fc386-290">Pour voir la différence pratique entre un groupe de capture qui définit un nombre minimal et un nombre maximal de captures et un groupe de capture qui définit un nombre fixe de captures, examinez les modèles d’expressions régulières `(a\1|(?(1)\1)){0,2}` et `(a\1|(?(1)\1)){2}`.</span><span class="sxs-lookup"><span data-stu-id="fc386-290">To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns `(a\1|(?(1)\1)){0,2}` and `(a\1|(?(1)\1)){2}`.</span></span> <span data-ttu-id="fc386-291">Les deux expressions régulières se composent d’un seul groupe de capture, qui est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="fc386-291">Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="fc386-292">Modèle</span><span class="sxs-lookup"><span data-stu-id="fc386-292">Pattern</span></span>|<span data-ttu-id="fc386-293">Description</span><span class="sxs-lookup"><span data-stu-id="fc386-293">Description</span></span>|  
|-------------|-----------------|  
|`(a\1`|<span data-ttu-id="fc386-294">Mettre en correspondance « a » avec la valeur du premier groupe capturé …</span><span class="sxs-lookup"><span data-stu-id="fc386-294">Either match "a" along with the value of the first captured group …</span></span>|  
|<code>&#124;(?(1)</code>|<span data-ttu-id="fc386-295">…</span><span class="sxs-lookup"><span data-stu-id="fc386-295">…</span></span> <span data-ttu-id="fc386-296">ou tester si le premier groupe capturé a été défini.</span><span class="sxs-lookup"><span data-stu-id="fc386-296">or test whether the first captured group has been defined.</span></span> <span data-ttu-id="fc386-297">(Notez que la construction `(?(1)` ne définit pas un groupe de capture.)</span><span class="sxs-lookup"><span data-stu-id="fc386-297">(Note that the `(?(1)` construct does not define a capturing group.)</span></span>|  
|`\1))`|<span data-ttu-id="fc386-298">Si le premier groupe capturé existe, établir une correspondance avec sa valeur.</span><span class="sxs-lookup"><span data-stu-id="fc386-298">If the first captured group exists, match its value.</span></span> <span data-ttu-id="fc386-299">Si le groupe n’existe pas, le groupe correspond à <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="fc386-299">If the group does not exist, the group will match <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="fc386-300">La première expression régulière essaie de correspondre à ce modèle entre zéro et deux fois ; la deuxième, exactement deux fois.</span><span class="sxs-lookup"><span data-stu-id="fc386-300">The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</span></span> <span data-ttu-id="fc386-301">Étant donné que le premier modèle atteint son nombre minimal de captures avec sa première capture de <xref:System.String.Empty?displayProperty=nameWithType>, il ne se répète jamais pour essayer d’établir une correspondance avec `a\1` ; le quantificateur `{0,2}` autorise uniquement les correspondances vides dans la dernière itération.</span><span class="sxs-lookup"><span data-stu-id="fc386-301">Because the first pattern reaches its minimum number of captures with its first capture of <xref:System.String.Empty?displayProperty=nameWithType>, it never repeats to try to match `a\1`; the `{0,2}` quantifier allows only empty matches in the last iteration.</span></span> <span data-ttu-id="fc386-302">En revanche, la seconde expression régulière établit une correspondance avec « a », car elle évalue `a\1` une deuxième fois ; le nombre minimal d’itérations, 2, entraîne la répétition du moteur après une correspondance vide.</span><span class="sxs-lookup"><span data-stu-id="fc386-302">In contrast, the second regular expression does match "a" because it evaluates `a\1` a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="fc386-303">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="fc386-303">See also</span></span>

- [<span data-ttu-id="fc386-304">Langage des expressions régulières - Aide-mémoire</span><span class="sxs-lookup"><span data-stu-id="fc386-304">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="fc386-305">Rétroaction</span><span class="sxs-lookup"><span data-stu-id="fc386-305">Backtracking</span></span>](backtracking-in-regular-expressions.md)
