---
title: Automatic Memory Management
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, automatic memory management
- memory, allocating
- memory, automatic memory management
- memory, releasing
- common language runtime, automatic memory management
- automatic memory management
- managed heap
- runtime, automatic memory management
ms.assetid: d4850de5-fa63-4936-a250-5678d118acba
ms.openlocfilehash: d112bf6d145893bd7b0f99e2b233fc83e72fe227
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73140565"
---
# <a name="automatic-memory-management"></a><span data-ttu-id="a3409-102">Automatic Memory Management</span><span class="sxs-lookup"><span data-stu-id="a3409-102">Automatic Memory Management</span></span>
<span data-ttu-id="a3409-103">La gestion automatique de la mémoire est un des services que le Common Language Runtime fournit au cours de [l'exécution managée](../../docs/standard/managed-execution-process.md).</span><span class="sxs-lookup"><span data-stu-id="a3409-103">Automatic memory management is one of the services that the Common Language Runtime provides during [Managed Execution](../../docs/standard/managed-execution-process.md).</span></span> <span data-ttu-id="a3409-104">Le Garbage collector du Common Language Runtime gère l’allocation et la libération de mémoire pour une application.</span><span class="sxs-lookup"><span data-stu-id="a3409-104">The Common Language Runtime's garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="a3409-105">Les développeurs n’ont donc plus à écrire du code pour exécuter leurs tâches de gestion de mémoire lors du développement d’applications managées.</span><span class="sxs-lookup"><span data-stu-id="a3409-105">For developers, this means that you do not have to write code to perform memory management tasks when you develop managed applications.</span></span> <span data-ttu-id="a3409-106">La gestion automatique de la mémoire permet d'éliminer des problèmes fréquents tels que l'oubli de libération d'un objet ou les fuites de mémoire ou encore les tentatives d'accès à la mémoire à la recherche d'un objet qui a déjà été libéré.</span><span class="sxs-lookup"><span data-stu-id="a3409-106">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak, or attempting to access memory for an object that has already been freed.</span></span> <span data-ttu-id="a3409-107">Cette section décrit la façon dont le « garbage collector » alloue et libère la mémoire.</span><span class="sxs-lookup"><span data-stu-id="a3409-107">This section describes how the garbage collector allocates and releases memory.</span></span>  
  
## <a name="allocating-memory"></a><span data-ttu-id="a3409-108">Allocation de mémoire</span><span class="sxs-lookup"><span data-stu-id="a3409-108">Allocating Memory</span></span>  
 <span data-ttu-id="a3409-109">Lorsque vous initialisez un nouveau processus, le runtime réserve une région d'espace d'adressage contigu pour le processus.</span><span class="sxs-lookup"><span data-stu-id="a3409-109">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="a3409-110">Cet espace d'adressage est appelé le tas managé.</span><span class="sxs-lookup"><span data-stu-id="a3409-110">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="a3409-111">Le tas managé garde un pointeur vers l'adresse qui sera allouée au nouvel objet du tas.</span><span class="sxs-lookup"><span data-stu-id="a3409-111">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="a3409-112">À l’origine, ce pointeur indique l’adresse de base du tas managé.</span><span class="sxs-lookup"><span data-stu-id="a3409-112">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="a3409-113">Tous les [types référence](../../docs/standard/base-types/common-type-system.md) sont alloués sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="a3409-113">All [reference types](../../docs/standard/base-types/common-type-system.md) are allocated on the managed heap.</span></span> <span data-ttu-id="a3409-114">Lorsqu’une application crée le premier type référence, la mémoire est allouée pour le type à l’adresse de base du tas managé.</span><span class="sxs-lookup"><span data-stu-id="a3409-114">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="a3409-115">Lorsque l'application crée l'objet suivant, le « garbage collector » lui alloue de la mémoire dans l'espace d'adressage qui suit immédiatement le premier objet.</span><span class="sxs-lookup"><span data-stu-id="a3409-115">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="a3409-116">Aussi longtemps que de l'espace d'adressage est disponible, le « garbage collector » continue à allouer de l'espace pour de nouveaux objets selon la même procédure.</span><span class="sxs-lookup"><span data-stu-id="a3409-116">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>  
  
 <span data-ttu-id="a3409-117">L'allocation de mémoire à partir du tas managé est plus rapide que l'allocation de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="a3409-117">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="a3409-118">Étant donné que le runtime alloue de la mémoire pour un objet en ajoutant une valeur à un pointeur, elle est pratiquement aussi rapide que l'allocation de mémoire à partir de la pile.</span><span class="sxs-lookup"><span data-stu-id="a3409-118">Because the runtime allocates memory for an object by adding a value to a pointer, it is almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="a3409-119">En outre, puisque les nouveaux objets auxquels un espace mémoire est alloué sont stockés à la suite dans le tas managé, une application peut accéder très rapidement aux objets.</span><span class="sxs-lookup"><span data-stu-id="a3409-119">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects very quickly.</span></span>  
  
<a name="cpconautomaticmemorymanagementreleasingmemoryanchor1"></a>   
## <a name="releasing-memory"></a><span data-ttu-id="a3409-120">Libération de la mémoire</span><span class="sxs-lookup"><span data-stu-id="a3409-120">Releasing Memory</span></span>  
 <span data-ttu-id="a3409-121">Le moteur d'optimisation du « garbage collector » détermine le meilleur moment pour lancer une opération garbage collection sur base des allocations de mémoire effectuées.</span><span class="sxs-lookup"><span data-stu-id="a3409-121">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="a3409-122">Lorsque le « garbage collector » effectue une opération garbage collection, il libère la mémoire pour les objets qui ne sont plus utilisées par l'application.</span><span class="sxs-lookup"><span data-stu-id="a3409-122">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="a3409-123">Il détermine les objets qui ne sont plus utilisés en examinant les racines de l'application.</span><span class="sxs-lookup"><span data-stu-id="a3409-123">It determines which objects are no longer being used by examining the application's roots.</span></span> <span data-ttu-id="a3409-124">Chaque application possède un jeu de racines.</span><span class="sxs-lookup"><span data-stu-id="a3409-124">Every application has a set of roots.</span></span> <span data-ttu-id="a3409-125">Chaque racine fait référence à un objet du tas managé ou, à défaut, a la valeur Null.</span><span class="sxs-lookup"><span data-stu-id="a3409-125">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="a3409-126">Les racines de l’application comprennent des champs statiques, des variables et des paramètres locaux sur la pile d’un thread et des Registres du processeur.</span><span class="sxs-lookup"><span data-stu-id="a3409-126">An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</span></span> <span data-ttu-id="a3409-127">Le Garbage collector a accès à la liste des racines actives entretenues par le [compilateur juste-à-temps (JIT)](../../docs/standard/managed-execution-process.md) et le runtime.</span><span class="sxs-lookup"><span data-stu-id="a3409-127">The garbage collector has access to the list of active roots that the [just-in-time (JIT) compiler](../../docs/standard/managed-execution-process.md) and the runtime maintain.</span></span> <span data-ttu-id="a3409-128">En utilisant cette liste, il examine des racines d'application et crée, au cours du processus, un graphique qui contient tous les objets accessibles à partir des racines.</span><span class="sxs-lookup"><span data-stu-id="a3409-128">Using this list, it examines an application's roots, and in the process creates a graph that contains all the objects that are reachable from the roots.</span></span>  
  
 <span data-ttu-id="a3409-129">Les objets non compris dans le graphique ne sont pas accessibles à partir des racines de l'application.</span><span class="sxs-lookup"><span data-stu-id="a3409-129">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="a3409-130">Le « garbage collector » examine les objets inaccessibles et libère la mémoire qui leur a été allouée.</span><span class="sxs-lookup"><span data-stu-id="a3409-130">The garbage collector considers unreachable objects garbage and will release the memory allocated for them.</span></span> <span data-ttu-id="a3409-131">Au cours d'une opération garbage collection, le « garbage collector » examine le tas managé pour y détecter les blocs de mémoire occupés par des objets inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="a3409-131">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="a3409-132">Chaque fois qu'il détecte un objet inaccessible, il utilise une fonction de copie de mémoire pour compacter les objets accessibles en mémoire et libérer les blocs d'espaces d'adressage alloués aux objets inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="a3409-132">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="a3409-133">Lorsque la mémoire allouée aux objets accessibles a été réduite, le « garbage collector » procède aux corrections de pointeurs nécessaires pour que les racines des applications pointent vers les nouveaux emplacements des objets.</span><span class="sxs-lookup"><span data-stu-id="a3409-133">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="a3409-134">Il positionne aussi le pointeur du tas managé après le dernier objet accessible.</span><span class="sxs-lookup"><span data-stu-id="a3409-134">It also positions the managed heap's pointer after the last reachable object.</span></span> <span data-ttu-id="a3409-135">Vous remarquerez que la mémoire est compactée uniquement si une collection détecte un nombre significatif d'objets inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="a3409-135">Note that memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="a3409-136">Si tous les objets du tas managé survivent à une collection, il n'est pas nécessaire de procéder à un compactage de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="a3409-136">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>  
  
 <span data-ttu-id="a3409-137">Pour améliorer les performances, le runtime alloue de la mémoire pour les objets de grandes dimensions dans un tas séparé.</span><span class="sxs-lookup"><span data-stu-id="a3409-137">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="a3409-138">Le « garbage collector » libère automatiquement la mémoire des objets de grande dimension.</span><span class="sxs-lookup"><span data-stu-id="a3409-138">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="a3409-139">Cependant, pour éviter de déplacer de grands objets en mémoire, la mémoire n'est pas compactée.</span><span class="sxs-lookup"><span data-stu-id="a3409-139">However, to avoid moving large objects in memory, this memory is not compacted.</span></span>  
  
## <a name="generations-and-performance"></a><span data-ttu-id="a3409-140">Générations et performances</span><span class="sxs-lookup"><span data-stu-id="a3409-140">Generations and Performance</span></span>  
 <span data-ttu-id="a3409-141">Pour optimiser les performances du garbage collector, le tas managé est divisé en trois générations : 0, 1 et 2.</span><span class="sxs-lookup"><span data-stu-id="a3409-141">To optimize the performance of the garbage collector, the managed heap is divided into three generations: 0, 1, and 2.</span></span> <span data-ttu-id="a3409-142">L'algorithme de garbage collection du runtime est basé sur plusieurs généralisations que l'industrie informatique a observées en expérimentant des modèles de garbage collection.</span><span class="sxs-lookup"><span data-stu-id="a3409-142">The runtime's garbage collection algorithm is based on several generalizations that the computer software industry has discovered to be true by experimenting with garbage collection schemes.</span></span> <span data-ttu-id="a3409-143">En premier lieu, il est plus rapide de compacter la mémoire pour une partie du tas managé que pour le tas tout entier.</span><span class="sxs-lookup"><span data-stu-id="a3409-143">First, it is faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span> <span data-ttu-id="a3409-144">Deuxièmement, les nouveaux objets ont des durées de vie plus courtes que les objets plus anciens.</span><span class="sxs-lookup"><span data-stu-id="a3409-144">Secondly, newer objects will have shorter lifetimes and older objects will have longer lifetimes.</span></span> <span data-ttu-id="a3409-145">Enfin, les nouveaux objets sont fréquemment liés entre eux et l'application y accède à peu près au même moment.</span><span class="sxs-lookup"><span data-stu-id="a3409-145">Lastly, newer objects tend to be related to each other and accessed by the application around the same time.</span></span>  
  
 <span data-ttu-id="a3409-146">Le garbage collector du runtime stocke les nouveaux objets dans la génération 0.</span><span class="sxs-lookup"><span data-stu-id="a3409-146">The runtime's garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="a3409-147">Les objets qui sont créés à un stade précoce de la durée de vie de l'application et qui survivent aux collectes sont promus et stockés dans les générations 1 et 2.</span><span class="sxs-lookup"><span data-stu-id="a3409-147">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="a3409-148">Le processus de promotion d'objet est décrit ultérieurement dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="a3409-148">The process of object promotion is described later in this topic.</span></span> <span data-ttu-id="a3409-149">Parce qu'il est plus rapide de compacter une partie du tas managé que le tas tout entier, ce schéma permet au « garbage collector » de libérer la mémoire dans une génération spécifique plutôt que de libérer la mémoire de l'intégralité du tas managé chaque fois qu'une opération garbage collection est effectuée.</span><span class="sxs-lookup"><span data-stu-id="a3409-149">Because it is faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>  
  
 <span data-ttu-id="a3409-150">En fait, le « garbage collector » procède à une opération collection lorsque la génération 0 est complète.</span><span class="sxs-lookup"><span data-stu-id="a3409-150">In reality, the garbage collector performs a collection when generation 0 is full.</span></span> <span data-ttu-id="a3409-151">Si une application tente de créer un nouvel objet lorsque la génération 0 est complète, le « garbage collector » observe qu'il n'y a plus d'espace d'adressage disponible dans la génération 0 à allouer à l'objet.</span><span class="sxs-lookup"><span data-stu-id="a3409-151">If an application attempts to create a new object when generation 0 is full, the garbage collector discovers that there is no address space remaining in generation 0 to allocate for the object.</span></span> <span data-ttu-id="a3409-152">Le « garbage collector » effectue une opération garbage collection en essayant de libérer de l'espace d'adressage pour l'objet dans la génération 0.</span><span class="sxs-lookup"><span data-stu-id="a3409-152">The garbage collector performs a collection in an attempt to free address space in generation 0 for the object.</span></span> <span data-ttu-id="a3409-153">Le « garbage collector » commence par examiner les objets de la génération 0 plutôt que tous les objets du tas managé.</span><span class="sxs-lookup"><span data-stu-id="a3409-153">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="a3409-154">Cette approche est la plus efficace parce que les nouveaux objets ont en règle générale une durée de vie courte et qu'une grande part des objets de la génération 0 ne seront plus utilisés par l'application lorsqu'une opération garbage collection sera effectuée.</span><span class="sxs-lookup"><span data-stu-id="a3409-154">This is the most efficient approach, because new objects tend to have short lifetimes, and it is expected that many of the objects in generation 0 will no longer be in use by the application when a collection is performed.</span></span> <span data-ttu-id="a3409-155">En outre, une opération garbage collection de la génération 0 récupère souvent à elle seule suffisamment de mémoire pour permettre à l’application de continuer à créer de nouveaux objets.</span><span class="sxs-lookup"><span data-stu-id="a3409-155">In addition, a collection of generation 0 alone often reclaims enough memory to allow the application to continue creating new objects.</span></span>  
  
 <span data-ttu-id="a3409-156">Après avoir effectué une collection de génération 0, le Garbage collector compacte la mémoire pour les objets accessibles comme expliqué dans la section [Libération de la mémoire](#cpconautomaticmemorymanagementreleasingmemoryanchor1), plus haut dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="a3409-156">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects as explained in [Releasing Memory](#cpconautomaticmemorymanagementreleasingmemoryanchor1) earlier in this topic.</span></span> <span data-ttu-id="a3409-157">Le garbage collector promeut ensuite ces objets et considère que cette partie du tas managé appartient à la génération 1.</span><span class="sxs-lookup"><span data-stu-id="a3409-157">The garbage collector then promotes these objects and considers this portion of the managed heap generation 1.</span></span> <span data-ttu-id="a3409-158">Étant donné que les objets qui survivent aux collectes ont tendance à avoir de plus longues durées de vie, il est logique de les promouvoir à une génération supérieure.</span><span class="sxs-lookup"><span data-stu-id="a3409-158">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="a3409-159">En conséquence, le « garbage collector »n'a pas à réexaminer les objets des générations 1 et 2 chaque fois qu'il effectue une opération garbage collection de la génération 0.</span><span class="sxs-lookup"><span data-stu-id="a3409-159">As a result, the garbage collector does not have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>  
  
 <span data-ttu-id="a3409-160">Après avoir exécuté sa première opération garbage collection de la génération 0 et promu les objets accessibles à la génération 1, le garbage collector considère que le reste du tas managé appartient à la génération 0.</span><span class="sxs-lookup"><span data-stu-id="a3409-160">After the garbage collector performs its first collection of generation 0 and promotes the reachable objects to generation 1, it considers the remainder of the managed heap generation 0.</span></span> <span data-ttu-id="a3409-161">Il continue à allouer de la mémoire pour les nouveaux objets de la génération 0 jusqu'à ce qu'elle soit complète et qu'il soit nécessaire d'effectuer une autre collecte.</span><span class="sxs-lookup"><span data-stu-id="a3409-161">It continues to allocate memory for new objects in generation 0 until generation 0 is full and it is necessary to perform another collection.</span></span> <span data-ttu-id="a3409-162">À ce stade, le moteur d'optimisation du « garbage collector » détermine s'il est nécessaire d'examiner les objets des générations plus anciennes.</span><span class="sxs-lookup"><span data-stu-id="a3409-162">At this point, the garbage collector's optimizing engine determines whether it is necessary to examine the objects in older generations.</span></span> <span data-ttu-id="a3409-163">Par exemple, si une collecte de génération 0 ne libère pas assez de mémoire pour que l'application puisse terminer sa création d'objet, le garbage collector peut exécuter une collecte de génération 1, puis de génération 2.</span><span class="sxs-lookup"><span data-stu-id="a3409-163">For example, if a collection of generation 0 does not reclaim enough memory for the application to successfully complete its attempt to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="a3409-164">Si cela ne libère pas assez de mémoire, le garbage collector peut exécuter une collecte de génération 2, 1 et 0.</span><span class="sxs-lookup"><span data-stu-id="a3409-164">If this does not reclaim enough memory, the garbage collector can perform a collection of generations 2, 1, and 0.</span></span> <span data-ttu-id="a3409-165">Après chaque collecte, le garbage collector condense les objets accessibles dans la génération 0 et les promeut à la génération 1.</span><span class="sxs-lookup"><span data-stu-id="a3409-165">After each collection, the garbage collector compacts the reachable objects in generation 0 and promotes them to generation 1.</span></span> <span data-ttu-id="a3409-166">Les objets qui survivent aux collectes sont promus et stockés dans les générations 1 et 2.</span><span class="sxs-lookup"><span data-stu-id="a3409-166">Objects in generation 1 that survive collections are promoted to generation 2.</span></span> <span data-ttu-id="a3409-167">Comme le garbage collector ne prend en charge que trois générations, les objets de génération 2 qui survivent à une collecte restent dans la génération 2 jusqu'à ce qu'ils soient considérés comme impossibles à atteindre lors d'une prochaine collecte.</span><span class="sxs-lookup"><span data-stu-id="a3409-167">Because the garbage collector supports only three generations, objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>  
  
## <a name="releasing-memory-for-unmanaged-resources"></a><span data-ttu-id="a3409-168">Libération de mémoire pour des ressources non managées</span><span class="sxs-lookup"><span data-stu-id="a3409-168">Releasing Memory for Unmanaged Resources</span></span>  
 <span data-ttu-id="a3409-169">Pour la majorité des objets créés par votre application, vous pouvez laisser au « garbage collector » le soin de réaliser automatiquement les tâches de gestion de mémoire requises.</span><span class="sxs-lookup"><span data-stu-id="a3409-169">For the majority of the objects that your application creates, you can rely on the garbage collector to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="a3409-170">Cependant, les ressources non managées requièrent un nettoyage explicite.</span><span class="sxs-lookup"><span data-stu-id="a3409-170">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="a3409-171">Le type le plus répandu de ressource non managée est un objet qui enveloppe une ressource de système d'exploitation telle qu'un handle de fichier ou de fenêtre ou une connexion réseau.</span><span class="sxs-lookup"><span data-stu-id="a3409-171">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="a3409-172">Bien que le « garbage collector » soit en mesure de suivre la durée de vie d'un objet managé qui encapsule une ressource non managée, il ne possède pas de connaissances spécifiques sur la façon de nettoyer une ressource.</span><span class="sxs-lookup"><span data-stu-id="a3409-172">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it does not have specific knowledge about how to clean up the resource.</span></span> <span data-ttu-id="a3409-173">Lors de la création d'un objet qui encapsule une ressource non managée, il est recommandé de fournir le code nécessaire pour nettoyer la ressource non managée dans une méthode **Dispose** publique.</span><span class="sxs-lookup"><span data-stu-id="a3409-173">When you create an object that encapsulates an unmanaged resource, it is recommended that you provide the necessary code to clean up the unmanaged resource in a public **Dispose** method.</span></span> <span data-ttu-id="a3409-174">En fournissant une méthode **Dispose**, vous donnez la possibilité aux utilisateurs de votre objet d'en libérer explicitement la mémoire lorsqu'ils ont fini de s'en servir.</span><span class="sxs-lookup"><span data-stu-id="a3409-174">By providing a **Dispose** method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="a3409-175">Lorsque vous utilisez un objet qui encapsule une ressource non managée, vous devez garder à l'esprit la méthode **Dispose** et l'appeler si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="a3409-175">When you use an object that encapsulates an unmanaged resource, you should be aware of **Dispose** and call it as necessary.</span></span> <span data-ttu-id="a3409-176">Pour obtenir plus d’informations sur le nettoyage de ressources non managées et un exemple de modèle de conception pour l’implémentation de la méthode **Dispose**, consultez [Garbage collection](../../docs/standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="a3409-176">For more information about cleaning up unmanaged resources and an example of a design pattern for implementing **Dispose**, see [Garbage Collection](../../docs/standard/garbage-collection/index.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a3409-177">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="a3409-177">See also</span></span>

- <xref:System.GC>
- [<span data-ttu-id="a3409-178">Nettoyage de la mémoire</span><span class="sxs-lookup"><span data-stu-id="a3409-178">Garbage Collection</span></span>](../../docs/standard/garbage-collection/index.md)
- [<span data-ttu-id="a3409-179">Processus d'exécution managée</span><span class="sxs-lookup"><span data-stu-id="a3409-179">Managed Execution Process</span></span>](../../docs/standard/managed-execution-process.md)
