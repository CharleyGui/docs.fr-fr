---
title: Migrer de Newtonsoft. JSON vers System. Text. JSON-.NET
author: tdykstra
ms.author: tdykstra
ms.date: 01/10/2020
helpviewer_keywords:
- JSON serialization
- serializing objects
- serialization
- objects, serializing
ms.openlocfilehash: 8b3ffc885691264548a19f694d159ce07aba7550
ms.sourcegitcommit: dfad244ba549702b649bfef3bb057e33f24a8fb2
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/12/2020
ms.locfileid: "75904683"
---
# <a name="how-to-migrate-from-newtonsoftjson-to-systemtextjson"></a><span data-ttu-id="3b233-102">Comment migrer de Newtonsoft. JSON vers System. Text. JSON</span><span class="sxs-lookup"><span data-stu-id="3b233-102">How to migrate from Newtonsoft.Json to System.Text.Json</span></span>

<span data-ttu-id="3b233-103">Cet article explique comment effectuer une migration de [Newtonsoft. JSON](https://www.newtonsoft.com/json) vers <xref:System.Text.Json>.</span><span class="sxs-lookup"><span data-stu-id="3b233-103">This article shows how to migrate from [Newtonsoft.Json](https://www.newtonsoft.com/json) to <xref:System.Text.Json>.</span></span>

 <span data-ttu-id="3b233-104">`System.Text.Json` se concentre principalement sur les performances, la sécurité et la conformité aux normes.</span><span class="sxs-lookup"><span data-stu-id="3b233-104">`System.Text.Json` focuses primarily on performance, security, and standards compliance.</span></span> <span data-ttu-id="3b233-105">Il présente certaines différences clés dans le comportement par défaut et n’a pas pour but d’avoir une parité des fonctionnalités avec `Newtonsoft.Json`.</span><span class="sxs-lookup"><span data-stu-id="3b233-105">It has some key differences in default behavior and doesn't aim to have feature parity with `Newtonsoft.Json`.</span></span> <span data-ttu-id="3b233-106">Dans certains scénarios, `System.Text.Json` n’a pas de fonctionnalité intégrée, mais il existe des solutions de contournement recommandées.</span><span class="sxs-lookup"><span data-stu-id="3b233-106">For some scenarios, `System.Text.Json` has no built-in functionality, but there are recommended workarounds.</span></span> <span data-ttu-id="3b233-107">Pour les autres scénarios, les solutions de contournement ne sont pas pratiques.</span><span class="sxs-lookup"><span data-stu-id="3b233-107">For other scenarios, workarounds are impractical.</span></span> <span data-ttu-id="3b233-108">Si votre application dépend d’une fonctionnalité manquante, envisagez de signaler [un problème](https://github.com/dotnet/runtime/issues/new) pour déterminer si la prise en charge de votre scénario peut être ajoutée.</span><span class="sxs-lookup"><span data-stu-id="3b233-108">If your application depends on a missing feature, consider [filing an issue](https://github.com/dotnet/runtime/issues/new) to find out if support for your scenario can be added.</span></span>

<!-- For information about which features might be added in future releases, see the [Roadmap](https://github.com/dotnet/runtime/tree/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/roadmap/README.md). [Restore this when the roadmap is updated.]-->

<span data-ttu-id="3b233-109">La majeure partie de cet article concerne l’utilisation de l’API <xref:System.Text.Json.JsonSerializer>, mais elle fournit également des conseils sur l’utilisation de l' <xref:System.Text.Json.JsonDocument> (qui représente les types Document Object Model ou DOM), <xref:System.Text.Json.Utf8JsonReader>et <xref:System.Text.Json.Utf8JsonWriter>.</span><span class="sxs-lookup"><span data-stu-id="3b233-109">Most of this article is about how to use the <xref:System.Text.Json.JsonSerializer> API, but it also includes guidance on how to use the <xref:System.Text.Json.JsonDocument> (which represents the Document Object Model or DOM), <xref:System.Text.Json.Utf8JsonReader>, and <xref:System.Text.Json.Utf8JsonWriter> types.</span></span> <span data-ttu-id="3b233-110">L’article est organisé en sections dans l’ordre suivant :</span><span class="sxs-lookup"><span data-stu-id="3b233-110">The article is organized into sections in the following order:</span></span>

* [<span data-ttu-id="3b233-111">Différences dans le comportement de jsonSerializer **par défaut** par rapport à Newtonsoft. JSON</span><span class="sxs-lookup"><span data-stu-id="3b233-111">Differences in **default** JsonSerializer behavior compared to Newtonsoft.Json</span></span>](#differences-in-default-jsonserializer-behavior-compared-to-newtonsoftjson)
* [<span data-ttu-id="3b233-112">Scénarios utilisant des JsonSerializer qui requièrent des solutions de contournement</span><span class="sxs-lookup"><span data-stu-id="3b233-112">Scenarios using JsonSerializer that require workarounds</span></span>](#scenarios-using-jsonserializer-that-require-workarounds)
* [<span data-ttu-id="3b233-113">Les scénarios que JsonSerializer ne prend pas en charge actuellement</span><span class="sxs-lookup"><span data-stu-id="3b233-113">Scenarios that JsonSerializer currently doesn't support</span></span>](#scenarios-that-jsonserializer-currently-doesnt-support)
* [<span data-ttu-id="3b233-114">JsonDocument et JsonElement comparés à JToken (comme JObject, JArray)</span><span class="sxs-lookup"><span data-stu-id="3b233-114">JsonDocument and JsonElement compared to JToken (like JObject, JArray)</span></span>](#jsondocument-and-jsonelement-compared-to-jtoken-like-jobject-jarray)
* [<span data-ttu-id="3b233-115">Utf8JsonReader comparé à JsonTextReader</span><span class="sxs-lookup"><span data-stu-id="3b233-115">Utf8JsonReader compared to JsonTextReader</span></span>](#utf8jsonreader-compared-to-jsontextreader)
* [<span data-ttu-id="3b233-116">Utf8JsonWriter comparé à JsonTextWriter</span><span class="sxs-lookup"><span data-stu-id="3b233-116">Utf8JsonWriter compared to JsonTextWriter</span></span>](#utf8jsonwriter-compared-to-jsontextwriter)

## <a name="differences-in-default-jsonserializer-behavior-compared-to-newtonsoftjson"></a><span data-ttu-id="3b233-117">Différences dans le comportement de JsonSerializer par défaut par rapport à Newtonsoft. JSON</span><span class="sxs-lookup"><span data-stu-id="3b233-117">Differences in default JsonSerializer behavior compared to Newtonsoft.Json</span></span>

<span data-ttu-id="3b233-118"><xref:System.Text.Json> est strict par défaut et évite toute estimation ou interprétation au nom de l’appelant, en soulignant le comportement déterministe.</span><span class="sxs-lookup"><span data-stu-id="3b233-118"><xref:System.Text.Json> is strict by default and avoids any guessing or interpretation on the caller's behalf, emphasizing deterministic behavior.</span></span> <span data-ttu-id="3b233-119">La bibliothèque est intentionnellement conçue de cette façon pour les performances et la sécurité.</span><span class="sxs-lookup"><span data-stu-id="3b233-119">The library is intentionally designed this way for performance and security.</span></span> <span data-ttu-id="3b233-120">`Newtonsoft.Json` est flexible par défaut.</span><span class="sxs-lookup"><span data-stu-id="3b233-120">`Newtonsoft.Json` is flexible by default.</span></span> <span data-ttu-id="3b233-121">Cette différence fondamentale en matière de conception repose sur la plupart des différences spécifiques suivantes dans le comportement par défaut.</span><span class="sxs-lookup"><span data-stu-id="3b233-121">This fundamental difference in design is behind many of the following specific differences in default behavior.</span></span>

### <a name="case-insensitive-deserialization"></a><span data-ttu-id="3b233-122">Désérialisation non sensible à la casse</span><span class="sxs-lookup"><span data-stu-id="3b233-122">Case-insensitive deserialization</span></span> 

<span data-ttu-id="3b233-123">Pendant la désérialisation, `Newtonsoft.Json` ne respecte pas la casse par défaut des noms de propriété qui ne respectent pas la casse.</span><span class="sxs-lookup"><span data-stu-id="3b233-123">During deserialization, `Newtonsoft.Json` does case-insensitive property name matching by default.</span></span> <span data-ttu-id="3b233-124">La valeur par défaut de la <xref:System.Text.Json> est sensible à la casse, ce qui offre de meilleures performances, car elle fait une correspondance exacte.</span><span class="sxs-lookup"><span data-stu-id="3b233-124">The <xref:System.Text.Json> default is case-sensitive, which gives better performance since it's doing an exact match.</span></span> <span data-ttu-id="3b233-125">Pour plus d’informations sur la façon d’effectuer une correspondance qui ne respecte pas la casse, consultez [correspondance de propriété](system-text-json-how-to.md#case-insensitive-property-matching)ne respectant pas la casse.</span><span class="sxs-lookup"><span data-stu-id="3b233-125">For information about how to do case-insensitive matching, see [Case-insensitive property matching](system-text-json-how-to.md#case-insensitive-property-matching).</span></span>

<span data-ttu-id="3b233-126">Si vous utilisez `System.Text.Json` indirectement à l’aide d’ASP.NET Core, vous n’avez rien à faire pour vous procurer un comportement comme `Newtonsoft.Json`.</span><span class="sxs-lookup"><span data-stu-id="3b233-126">If you're using `System.Text.Json` indirectly by using ASP.NET Core, you don't need to do anything to get behavior like `Newtonsoft.Json`.</span></span> <span data-ttu-id="3b233-127">ASP.NET Core spécifie les paramètres pour les [noms de propriété en casse mixte](system-text-json-how-to.md#use-camel-case-for-all-json-property-names) et la correspondance ne respectant pas la casse lorsqu’il utilise `System.Text.Json`.</span><span class="sxs-lookup"><span data-stu-id="3b233-127">ASP.NET Core specifies the settings for [camel-casing property names](system-text-json-how-to.md#use-camel-case-for-all-json-property-names) and case-insensitive matching when it uses `System.Text.Json`.</span></span>

### <a name="comments"></a><span data-ttu-id="3b233-128">Comments</span><span class="sxs-lookup"><span data-stu-id="3b233-128">Comments</span></span>

<span data-ttu-id="3b233-129">Pendant la désérialisation, `Newtonsoft.Json` ignore par défaut les commentaires dans le JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-129">During deserialization, `Newtonsoft.Json` ignores comments in the JSON by default.</span></span> <span data-ttu-id="3b233-130">La <xref:System.Text.Json> par défaut consiste à lever des exceptions pour les commentaires, car la spécification [RFC 8259](https://tools.ietf.org/html/rfc8259) ne les inclut pas.</span><span class="sxs-lookup"><span data-stu-id="3b233-130">The <xref:System.Text.Json> default is to throw exceptions for comments because the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification doesn't include them.</span></span> <span data-ttu-id="3b233-131">Pour plus d’informations sur l’autorisation des commentaires, consultez [autoriser les commentaires et les virgules de fin](system-text-json-how-to.md#allow-comments-and-trailing-commas).</span><span class="sxs-lookup"><span data-stu-id="3b233-131">For information about how to allow comments, see [Allow comments and trailing commas](system-text-json-how-to.md#allow-comments-and-trailing-commas).</span></span>

### <a name="trailing-commas"></a><span data-ttu-id="3b233-132">Virgules de fin</span><span class="sxs-lookup"><span data-stu-id="3b233-132">Trailing commas</span></span>

<span data-ttu-id="3b233-133">Au cours de la désérialisation, `Newtonsoft.Json` ignore les virgules de fin par défaut.</span><span class="sxs-lookup"><span data-stu-id="3b233-133">During deserialization, `Newtonsoft.Json` ignores trailing commas by default.</span></span> <span data-ttu-id="3b233-134">Elle ignore également plusieurs virgules de fin (par exemple, `[{"Color":"Red"},{"Color":"Green"},,]`).</span><span class="sxs-lookup"><span data-stu-id="3b233-134">It also ignores multiple trailing commas (for example, `[{"Color":"Red"},{"Color":"Green"},,]`).</span></span> <span data-ttu-id="3b233-135">La <xref:System.Text.Json> par défaut consiste à lever des exceptions pour les virgules de fin, car la spécification [RFC 8259](https://tools.ietf.org/html/rfc8259) ne les autorise pas.</span><span class="sxs-lookup"><span data-stu-id="3b233-135">The <xref:System.Text.Json> default is to throw exceptions for trailing commas because the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification doesn't allow them.</span></span> <span data-ttu-id="3b233-136">Pour plus d’informations sur la façon de faire `System.Text.Json` les accepter, consultez [autoriser les commentaires et les virgules de fin](system-text-json-how-to.md#allow-comments-and-trailing-commas).</span><span class="sxs-lookup"><span data-stu-id="3b233-136">For information about how to make `System.Text.Json` accept them, see [Allow comments and trailing commas](system-text-json-how-to.md#allow-comments-and-trailing-commas).</span></span> <span data-ttu-id="3b233-137">Il n’existe aucun moyen d’autoriser plusieurs virgules de fin.</span><span class="sxs-lookup"><span data-stu-id="3b233-137">There's no way to allow multiple trailing commas.</span></span>

### <a name="json-strings-property-names-and-string-values"></a><span data-ttu-id="3b233-138">Chaînes JSON (noms de propriété et valeurs de chaîne)</span><span class="sxs-lookup"><span data-stu-id="3b233-138">JSON strings (property names and string values)</span></span>

<span data-ttu-id="3b233-139">Pendant la désérialisation, `Newtonsoft.Json` accepte les noms de propriété placés entre guillemets doubles, apostrophes ou sans guillemets.</span><span class="sxs-lookup"><span data-stu-id="3b233-139">During deserialization, `Newtonsoft.Json` accepts property names surrounded by double quotes, single quotes, or without quotes.</span></span> <span data-ttu-id="3b233-140">Il accepte les valeurs de chaîne entourées de guillemets doubles ou de guillemets simples.</span><span class="sxs-lookup"><span data-stu-id="3b233-140">It accepts string values surrounded by double quotes or single quotes.</span></span> <span data-ttu-id="3b233-141">Par exemple, `Newtonsoft.Json` accepte le code JSON suivant :</span><span class="sxs-lookup"><span data-stu-id="3b233-141">For example, `Newtonsoft.Json` accepts the following JSON:</span></span>

```json
{
  "name1": "value",
  'name2': "value",
  name3: 'value'
}
```

<span data-ttu-id="3b233-142">`System.Text.Json` accepte uniquement les noms de propriété et les valeurs de chaîne entre guillemets doubles, car ce format est requis par la spécification [RFC 8259](https://tools.ietf.org/html/rfc8259) et est le seul format considéré comme un JSON valide.</span><span class="sxs-lookup"><span data-stu-id="3b233-142">`System.Text.Json` only accepts property names and string values in double quotes because that format is required by the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification and is the only format considered valid JSON.</span></span>

<span data-ttu-id="3b233-143">Une valeur placée entre guillemets simples donne un [JsonException](xref:System.Text.Json.JsonException) avec le message suivant :</span><span class="sxs-lookup"><span data-stu-id="3b233-143">A value enclosed in single quotes results in a [JsonException](xref:System.Text.Json.JsonException) with the following message:</span></span>

```
''' is an invalid start of a value.
```

### <a name="non-string-values-for-string-properties"></a><span data-ttu-id="3b233-144">Valeurs qui ne sont pas des chaînes pour les propriétés de chaîne</span><span class="sxs-lookup"><span data-stu-id="3b233-144">Non-string values for string properties</span></span>

<span data-ttu-id="3b233-145">`Newtonsoft.Json` accepte les valeurs qui ne sont pas des chaînes, telles qu’un nombre ou les littéraux `true` et `false`, pour la désérialisation des propriétés de type String.</span><span class="sxs-lookup"><span data-stu-id="3b233-145">`Newtonsoft.Json` accepts non-string values, such as a number or the literals `true` and `false`, for deserialization to properties of type string.</span></span> <span data-ttu-id="3b233-146">Voici un exemple de code JSON qui `Newtonsoft.Json` désérialise avec succès vers la classe suivante :</span><span class="sxs-lookup"><span data-stu-id="3b233-146">Here's an example of JSON that `Newtonsoft.Json` successfully deserializes to the following class:</span></span>

```json
{
  "String1": 1,
  "String2": true,
  "String3": false
}
```

```csharp
public class ExampleClass
{
    public string String1 { get; set; }
    public string String2 { get; set; }
    public string String3 { get; set; }
}
```

<span data-ttu-id="3b233-147">`System.Text.Json` ne désérialise pas les valeurs qui ne sont pas des chaînes dans les propriétés de chaîne.</span><span class="sxs-lookup"><span data-stu-id="3b233-147">`System.Text.Json` doesn't deserialize non-string values into string properties.</span></span> <span data-ttu-id="3b233-148">Une valeur qui n’est pas une chaîne reçue pour un champ de chaîne génère un [JsonException](xref:System.Text.Json.JsonException) avec le message suivant :</span><span class="sxs-lookup"><span data-stu-id="3b233-148">A non-string value received for a string field results in a [JsonException](xref:System.Text.Json.JsonException) with the following message:</span></span>

```
The JSON value could not be converted to System.String.
```

### <a name="converter-registration-precedence"></a><span data-ttu-id="3b233-149">Priorité d’inscription du convertisseur</span><span class="sxs-lookup"><span data-stu-id="3b233-149">Converter registration precedence</span></span>

<span data-ttu-id="3b233-150">La priorité d’inscription `Newtonsoft.Json` pour les convertisseurs personnalisés est la suivante :</span><span class="sxs-lookup"><span data-stu-id="3b233-150">The `Newtonsoft.Json` registration precedence for custom converters is as follows:</span></span>

* <span data-ttu-id="3b233-151">Attribut sur la propriété</span><span class="sxs-lookup"><span data-stu-id="3b233-151">Attribute on property</span></span>
* <span data-ttu-id="3b233-152">Attribut sur le type</span><span class="sxs-lookup"><span data-stu-id="3b233-152">Attribute on type</span></span>
* <span data-ttu-id="3b233-153">[Converters](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_Converters.htm) , collection</span><span class="sxs-lookup"><span data-stu-id="3b233-153">[Converters](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_Converters.htm) collection</span></span>

<span data-ttu-id="3b233-154">Dans cet ordre, un convertisseur personnalisé dans la collection `Converters` est substitué par un convertisseur qui est inscrit en appliquant un attribut au niveau du type.</span><span class="sxs-lookup"><span data-stu-id="3b233-154">This order means that a custom converter in the `Converters` collection is overridden by a converter that is registered by applying an attribute at the type level.</span></span> <span data-ttu-id="3b233-155">Ces deux inscriptions sont remplacées par un attribut au niveau de la propriété.</span><span class="sxs-lookup"><span data-stu-id="3b233-155">Both of those registrations are overridden by an attribute at the property level.</span></span>

<span data-ttu-id="3b233-156">La priorité d’inscription <xref:System.Text.Json> pour les convertisseurs personnalisés est différente :</span><span class="sxs-lookup"><span data-stu-id="3b233-156">The <xref:System.Text.Json> registration precedence for custom converters is different:</span></span>

* <span data-ttu-id="3b233-157">Attribut sur la propriété</span><span class="sxs-lookup"><span data-stu-id="3b233-157">Attribute on property</span></span>
* <span data-ttu-id="3b233-158">collection <xref:System.Text.Json.JsonSerializerOptions.Converters></span><span class="sxs-lookup"><span data-stu-id="3b233-158"><xref:System.Text.Json.JsonSerializerOptions.Converters> collection</span></span>
* <span data-ttu-id="3b233-159">Attribut sur le type</span><span class="sxs-lookup"><span data-stu-id="3b233-159">Attribute on type</span></span>

<span data-ttu-id="3b233-160">La différence réside dans le fait qu’un convertisseur personnalisé dans la collection `Converters` remplace un attribut au niveau du type.</span><span class="sxs-lookup"><span data-stu-id="3b233-160">The difference here is that a custom converter in the `Converters` collection overrides an attribute at the type level.</span></span> <span data-ttu-id="3b233-161">L’objectif derrière cet ordre de priorité est de faire en sorte que les modifications au moment de l’exécution remplacent les choix au moment de la conception.</span><span class="sxs-lookup"><span data-stu-id="3b233-161">The intention behind this order of precedence is to make run-time changes override design-time choices.</span></span> <span data-ttu-id="3b233-162">Il n’existe aucun moyen de modifier la précédence.</span><span class="sxs-lookup"><span data-stu-id="3b233-162">There's no way to change the precedence.</span></span>

<span data-ttu-id="3b233-163">Pour plus d’informations sur l’inscription d’un convertisseur personnalisé, consultez [inscrire un convertisseur personnalisé](system-text-json-converters-how-to.md#register-a-custom-converter).</span><span class="sxs-lookup"><span data-stu-id="3b233-163">For more information about custom converter registration, see [Register a custom converter](system-text-json-converters-how-to.md#register-a-custom-converter).</span></span>

### <a name="character-escaping"></a><span data-ttu-id="3b233-164">Échappement de caractères</span><span class="sxs-lookup"><span data-stu-id="3b233-164">Character escaping</span></span>

<span data-ttu-id="3b233-165">Au cours de la sérialisation, `Newtonsoft.Json` est relativement permissif quant à la possibilité de laisser des caractères sans les placer dans une séquence d’échappement.</span><span class="sxs-lookup"><span data-stu-id="3b233-165">During serialization, `Newtonsoft.Json` is relatively permissive about letting characters through without escaping them.</span></span> <span data-ttu-id="3b233-166">Autrement dit, il ne les remplace pas par `\uxxxx` où `xxxx` est le point de code du caractère.</span><span class="sxs-lookup"><span data-stu-id="3b233-166">That is, it doesn't replace them with `\uxxxx` where `xxxx` is the character's code point.</span></span> <span data-ttu-id="3b233-167">Lorsqu’il les échappe, il émet une `\` avant le caractère (par exemple, `"` devient `\"`).</span><span class="sxs-lookup"><span data-stu-id="3b233-167">Where it does escape them, it does so by emitting a `\` before the character (for example, `"` becomes `\"`).</span></span> <span data-ttu-id="3b233-168"><xref:System.Text.Json> échappe plus de caractères par défaut pour fournir des protections en profondeur contre les attaques de script entre sites (XSS) ou de divulgation d’informations et le fait à l’aide de la séquence de six caractères.</span><span class="sxs-lookup"><span data-stu-id="3b233-168"><xref:System.Text.Json> escapes more characters by default to provide defense-in-depth protections against cross-site scripting (XSS) or information-disclosure attacks and does so by using the six-character sequence.</span></span> <span data-ttu-id="3b233-169">`System.Text.Json` échappe par défaut tous les caractères non-ASCII. vous n’avez donc pas besoin de faire quoi que ce soit si vous utilisez `StringEscapeHandling.EscapeNonAscii` dans `Newtonsoft.Json`.</span><span class="sxs-lookup"><span data-stu-id="3b233-169">`System.Text.Json` escapes all non-ASCII characters by default, so you don't need to do anything if you're using `StringEscapeHandling.EscapeNonAscii` in `Newtonsoft.Json`.</span></span> <span data-ttu-id="3b233-170">par défaut, `System.Text.Json` échappe également aux caractères HTML.</span><span class="sxs-lookup"><span data-stu-id="3b233-170">`System.Text.Json` also escapes HTML-sensitive characters, by default.</span></span> <span data-ttu-id="3b233-171">Pour plus d’informations sur la façon de substituer le comportement de `System.Text.Json` par défaut, consultez [personnaliser l’encodage de caractères](system-text-json-how-to.md#customize-character-encoding).</span><span class="sxs-lookup"><span data-stu-id="3b233-171">For information about how to override the default `System.Text.Json` behavior, see [Customize character encoding](system-text-json-how-to.md#customize-character-encoding).</span></span>

### <a name="deserialization-of-object-properties"></a><span data-ttu-id="3b233-172">Désérialisation des propriétés de l’objet</span><span class="sxs-lookup"><span data-stu-id="3b233-172">Deserialization of object properties</span></span>

<span data-ttu-id="3b233-173">Lorsque `Newtonsoft.Json` désérialise sur `object` propriétés dans POCO ou dans des dictionnaires de type `Dictionary<string, object>`, il :</span><span class="sxs-lookup"><span data-stu-id="3b233-173">When `Newtonsoft.Json` deserializes to `object` properties in POCOs or in dictionaries of type `Dictionary<string, object>`, it:</span></span>

* <span data-ttu-id="3b233-174">Déduit le type de valeurs primitives dans la charge utile JSON (autre que `null`) et retourne le `string`stocké, `long`, `double`, `boolean`ou `DateTime` en tant qu’objet boxed.</span><span class="sxs-lookup"><span data-stu-id="3b233-174">Infers the type of primitive values in the JSON payload (other than `null`) and returns the stored `string`, `long`, `double`, `boolean`, or `DateTime` as a boxed object.</span></span> <span data-ttu-id="3b233-175">Les *valeurs primitives* sont des valeurs JSON uniques, telles qu’un nombre JSON, une chaîne, `true`, `false`ou `null`.</span><span class="sxs-lookup"><span data-stu-id="3b233-175">*Primitive values* are single JSON values such as a JSON number, string, `true`, `false`, or `null`.</span></span>
* <span data-ttu-id="3b233-176">Retourne un `JObject` ou `JArray` pour les valeurs complexes dans la charge utile JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-176">Returns a `JObject` or `JArray` for complex values in the JSON payload.</span></span> <span data-ttu-id="3b233-177">Les *valeurs complexes* sont des collections de paires clé-valeur JSON entre accolades (`{}`) ou des listes de valeurs entre crochets (`[]`).</span><span class="sxs-lookup"><span data-stu-id="3b233-177">*Complex values* are collections of JSON key-value pairs within braces (`{}`) or lists of values within brackets (`[]`).</span></span> <span data-ttu-id="3b233-178">Les propriétés et les valeurs entre accolades ou crochets peuvent avoir des propriétés ou des valeurs supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="3b233-178">The properties and values within the braces or brackets can have additional properties or values.</span></span>
* <span data-ttu-id="3b233-179">Retourne une référence Null lorsque la charge utile a le littéral JSON `null`.</span><span class="sxs-lookup"><span data-stu-id="3b233-179">Returns a null reference when the payload has the `null` JSON literal.</span></span>

<span data-ttu-id="3b233-180"><xref:System.Text.Json> stocke un `JsonElement` boxed pour les valeurs primitives et complexes dans la `System.Object` la valeur de la propriété ou du dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="3b233-180"><xref:System.Text.Json> stores a boxed `JsonElement` for both primitive and complex values within the `System.Object` property or dictionary value.</span></span> <span data-ttu-id="3b233-181">Toutefois, il traite `null` identique à `Newtonsoft.Json` et retourne une référence Null lorsque la charge utile contient le littéral JSON `null`.</span><span class="sxs-lookup"><span data-stu-id="3b233-181">However, it treats `null` the same as `Newtonsoft.Json` and returns a null reference when the payload has the `null` JSON literal in it.</span></span>

<span data-ttu-id="3b233-182">Pour implémenter l’inférence de type pour les propriétés de `object`, créez un convertisseur comme dans l’exemple d' [écriture de convertisseurs personnalisés](system-text-json-converters-how-to.md#deserialize-inferred-types-to-object-properties).</span><span class="sxs-lookup"><span data-stu-id="3b233-182">To implement type inference for `object` properties, create a converter like the example in [How to write custom converters](system-text-json-converters-how-to.md#deserialize-inferred-types-to-object-properties).</span></span>

### <a name="maximum-depth"></a><span data-ttu-id="3b233-183">Profondeur maximale</span><span class="sxs-lookup"><span data-stu-id="3b233-183">Maximum depth</span></span>

<span data-ttu-id="3b233-184">`Newtonsoft.Json` n’a pas de limite de profondeur maximale par défaut.</span><span class="sxs-lookup"><span data-stu-id="3b233-184">`Newtonsoft.Json` doesn't have a maximum depth limit by default.</span></span> <span data-ttu-id="3b233-185">Par <xref:System.Text.Json> il existe une limite par défaut de 64, qui peut être configurée en définissant <xref:System.Text.Json.JsonSerializerOptions.MaxDepth?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3b233-185">For <xref:System.Text.Json> there's a default limit  of 64, and it's configurable by setting <xref:System.Text.Json.JsonSerializerOptions.MaxDepth?displayProperty=nameWithType>.</span></span>

### <a name="stack-type-handling"></a><span data-ttu-id="3b233-186">Gestion des types de pile</span><span class="sxs-lookup"><span data-stu-id="3b233-186">Stack type handling</span></span>

<span data-ttu-id="3b233-187">Dans <xref:System.Text.Json>, l’ordre du contenu d’une pile est inversé lorsqu’il est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="3b233-187">In <xref:System.Text.Json>, the order of a stack's contents is reversed when it's serialized.</span></span> <span data-ttu-id="3b233-188">Ce comportement s’applique aux types et à l’interface et aux types définis par l’utilisateur suivants qui dérivent de ceux-ci :</span><span class="sxs-lookup"><span data-stu-id="3b233-188">This behavior applies to the following types and interface and user-defined types that derive from them:</span></span>

* <xref:System.Collections.Stack>
* <xref:System.Collections.Generic.Stack%601>
* <xref:System.Collections.Immutable.ImmutableStack%601>
* <xref:System.Collections.Immutable.IImmutableStack%601>

<span data-ttu-id="3b233-189">Un convertisseur personnalisé peut être implémenté pour conserver le contenu de la pile dans le même ordre.</span><span class="sxs-lookup"><span data-stu-id="3b233-189">A custom converter could be implemented to keep stack contents in the same order.</span></span>

### <a name="omit-null-value-properties"></a><span data-ttu-id="3b233-190">Omettre les propriétés de valeur null</span><span class="sxs-lookup"><span data-stu-id="3b233-190">Omit null-value properties</span></span>

<span data-ttu-id="3b233-191">`Newtonsoft.Json` a un paramètre global qui fait que les propriétés de valeur NULL sont exclues de la sérialisation : [NullValueHandling. ignore](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_NullValueHandling.htm).</span><span class="sxs-lookup"><span data-stu-id="3b233-191">`Newtonsoft.Json` has a global setting that causes null-value properties to be excluded from serialization: [NullValueHandling.Ignore](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_NullValueHandling.htm).</span></span> <span data-ttu-id="3b233-192">L’option correspondante dans <xref:System.Text.Json> est <xref:System.Text.Json.JsonSerializerOptions.IgnoreNullValues%2A>.</span><span class="sxs-lookup"><span data-stu-id="3b233-192">The corresponding option in <xref:System.Text.Json> is <xref:System.Text.Json.JsonSerializerOptions.IgnoreNullValues%2A>.</span></span>

## <a name="scenarios-using-jsonserializer-that-require-workarounds"></a><span data-ttu-id="3b233-193">Scénarios utilisant des JsonSerializer qui requièrent des solutions de contournement</span><span class="sxs-lookup"><span data-stu-id="3b233-193">Scenarios using JsonSerializer that require workarounds</span></span>

<span data-ttu-id="3b233-194">Les scénarios suivants ne sont pas pris en charge par les fonctionnalités intégrées, mais un exemple de code est fourni pour les solutions de contournement.</span><span class="sxs-lookup"><span data-stu-id="3b233-194">The following scenarios aren't supported by built-in functionality, but sample code is provided for workarounds.</span></span> <span data-ttu-id="3b233-195">La plupart des solutions de contournement requièrent l’implémentation de [convertisseurs personnalisés](system-text-json-converters-how-to.md).</span><span class="sxs-lookup"><span data-stu-id="3b233-195">Most of the workarounds require that you implement [custom converters](system-text-json-converters-how-to.md).</span></span>

### <a name="specify-date-format"></a><span data-ttu-id="3b233-196">Spécifier le format de la date</span><span class="sxs-lookup"><span data-stu-id="3b233-196">Specify date format</span></span>

<span data-ttu-id="3b233-197">`Newtonsoft.Json` offre plusieurs moyens de contrôler la sérialisation et la désérialisation des propriétés des types `DateTime` et `DateTimeOffset` :</span><span class="sxs-lookup"><span data-stu-id="3b233-197">`Newtonsoft.Json` provides several ways to control how properties of `DateTime` and `DateTimeOffset` types are serialized and deserialized:</span></span>

* <span data-ttu-id="3b233-198">Le paramètre `DateTimeZoneHandling` peut être utilisé pour sérialiser toutes les valeurs de `DateTime` en tant que dates UTC.</span><span class="sxs-lookup"><span data-stu-id="3b233-198">The `DateTimeZoneHandling` setting can be used to serialize all `DateTime` values as UTC dates.</span></span>
* <span data-ttu-id="3b233-199">Le paramètre `DateFormatString` et les convertisseurs de `DateTime` peuvent être utilisés pour personnaliser le format des chaînes de date.</span><span class="sxs-lookup"><span data-stu-id="3b233-199">The `DateFormatString` setting and `DateTime` converters can be used to customize the format of date strings.</span></span>

<span data-ttu-id="3b233-200">Dans <xref:System.Text.Json>, le seul format qui offre une prise en charge intégrée est ISO 8601-1:2019, car il est largement adopté, sans ambiguïté, et effectue des allers-retours avec précision.</span><span class="sxs-lookup"><span data-stu-id="3b233-200">In <xref:System.Text.Json>, the only format that has built-in support is ISO 8601-1:2019 since it's widely adopted, unambiguous, and makes round trips precisely.</span></span> <span data-ttu-id="3b233-201">Pour utiliser n’importe quel autre format, créez un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="3b233-201">To use any other format, create a custom converter.</span></span> <span data-ttu-id="3b233-202">Pour plus d’informations, consultez [prise en charge des valeurs DateTime et DateTimeOffset dans System. Text. JSON](../datetime/system-text-json-support.md).</span><span class="sxs-lookup"><span data-stu-id="3b233-202">For more information, see [DateTime and DateTimeOffset support in System.Text.Json](../datetime/system-text-json-support.md).</span></span>

### <a name="quoted-numbers"></a><span data-ttu-id="3b233-203">Nombres entre guillemets</span><span class="sxs-lookup"><span data-stu-id="3b233-203">Quoted numbers</span></span>

<span data-ttu-id="3b233-204">`Newtonsoft.Json` pouvez sérialiser ou désérialiser des nombres représentés par des chaînes JSON (entourées de guillemets).</span><span class="sxs-lookup"><span data-stu-id="3b233-204">`Newtonsoft.Json` can serialize or deserialize numbers represented by JSON strings (surrounded by quotes).</span></span> <span data-ttu-id="3b233-205">Par exemple, il peut accepter : `{"DegreesCelsius":"23"}` au lieu de `{"DegreesCelsius":23}`.</span><span class="sxs-lookup"><span data-stu-id="3b233-205">For example, it can accept: `{"DegreesCelsius":"23"}` instead of `{"DegreesCelsius":23}`.</span></span> <span data-ttu-id="3b233-206">Pour activer ce comportement dans <xref:System.Text.Json>, implémentez un convertisseur personnalisé comme dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="3b233-206">To enable that behavior in <xref:System.Text.Json>, implement a custom converter like the following example.</span></span> <span data-ttu-id="3b233-207">Le convertisseur gère les propriétés définies en tant que `long`:</span><span class="sxs-lookup"><span data-stu-id="3b233-207">The converter handles properties defined as `long`:</span></span>

* <span data-ttu-id="3b233-208">Il les sérialise en tant que chaînes JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-208">It serializes them as JSON strings.</span></span> 
* <span data-ttu-id="3b233-209">Il accepte les nombres et nombres JSON dans les guillemets lors de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="3b233-209">It accepts JSON numbers and numbers within quotes while deserializing.</span></span>

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/LongToStringConverter.cs)]

<span data-ttu-id="3b233-210">Inscrivez ce convertisseur personnalisé à [l’aide d’un attribut](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property) sur des propriétés de `long` individuelles ou en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la collection de <xref:System.Text.Json.JsonSerializerOptions.Converters>.</span><span class="sxs-lookup"><span data-stu-id="3b233-210">Register this custom converter by [using an attribute](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property) on individual `long` properties or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

### <a name="dictionary-with-non-string-key"></a><span data-ttu-id="3b233-211">Dictionnaire avec clé non-chaîne</span><span class="sxs-lookup"><span data-stu-id="3b233-211">Dictionary with non-string key</span></span>

<span data-ttu-id="3b233-212">`Newtonsoft.Json` prend en charge les collections de type `Dictionary<TKey, TValue>`.</span><span class="sxs-lookup"><span data-stu-id="3b233-212">`Newtonsoft.Json` supports collections of type `Dictionary<TKey, TValue>`.</span></span> <span data-ttu-id="3b233-213">La prise en charge intégrée pour les collections de dictionnaires dans <xref:System.Text.Json> est limitée à `Dictionary<string, TValue>`.</span><span class="sxs-lookup"><span data-stu-id="3b233-213">The built-in support for dictionary collections in <xref:System.Text.Json> is limited to `Dictionary<string, TValue>`.</span></span> <span data-ttu-id="3b233-214">Autrement dit, la clé doit être une chaîne.</span><span class="sxs-lookup"><span data-stu-id="3b233-214">That is, the key must be a string.</span></span>

<span data-ttu-id="3b233-215">Pour prendre en charge un dictionnaire avec un entier ou un autre type en tant que clé, créez un convertisseur comme l’exemple dans [Comment écrire des convertisseurs personnalisés](system-text-json-converters-how-to.md#support-dictionary-with-non-string-key).</span><span class="sxs-lookup"><span data-stu-id="3b233-215">To support a dictionary with an integer or some other type as the key, create a converter like the example in [How to write custom converters](system-text-json-converters-how-to.md#support-dictionary-with-non-string-key).</span></span>

### <a name="polymorphic-serialization"></a><span data-ttu-id="3b233-216">Sérialisation polymorphe</span><span class="sxs-lookup"><span data-stu-id="3b233-216">Polymorphic serialization</span></span>

<span data-ttu-id="3b233-217">`Newtonsoft.Json` effectue automatiquement la sérialisation polymorphe.</span><span class="sxs-lookup"><span data-stu-id="3b233-217">`Newtonsoft.Json` automatically does polymorphic serialization.</span></span> <span data-ttu-id="3b233-218">Pour plus d’informations sur les fonctionnalités de sérialisation polymorphes limitées de <xref:System.Text.Json>, consultez [sérialisation des propriétés de classes dérivées](system-text-json-how-to.md#serialize-properties-of-derived-classes).</span><span class="sxs-lookup"><span data-stu-id="3b233-218">For information about the limited polymorphic serialization capabilities of <xref:System.Text.Json>, see [Serialize properties of derived classes](system-text-json-how-to.md#serialize-properties-of-derived-classes).</span></span>

<span data-ttu-id="3b233-219">La solution de contournement décrite consiste à définir des propriétés qui peuvent contenir des classes dérivées comme `object`de type.</span><span class="sxs-lookup"><span data-stu-id="3b233-219">The workaround described there is to define properties that may contain derived classes as type `object`.</span></span> <span data-ttu-id="3b233-220">Si cela n’est pas possible, une autre option consiste à créer un convertisseur avec une méthode de `Write` pour l’ensemble de la hiérarchie des types d’héritage, comme dans l’exemple de la rubrique [Comment écrire des convertisseurs personnalisés](system-text-json-converters-how-to.md#support-polymorphic-deserialization).</span><span class="sxs-lookup"><span data-stu-id="3b233-220">If that isn't possible, another option is to create a converter with a `Write` method for the whole inheritance type hierarchy like the example in [How to write custom converters](system-text-json-converters-how-to.md#support-polymorphic-deserialization).</span></span>

### <a name="polymorphic-deserialization"></a><span data-ttu-id="3b233-221">Désérialisation polymorphe</span><span class="sxs-lookup"><span data-stu-id="3b233-221">Polymorphic deserialization</span></span>

<span data-ttu-id="3b233-222">`Newtonsoft.Json` a un paramètre `TypeNameHandling` qui ajoute des métadonnées de nom de type au JSON lors de la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="3b233-222">`Newtonsoft.Json` has a `TypeNameHandling` setting that adds type name metadata to the JSON while serializing.</span></span> <span data-ttu-id="3b233-223">Elle utilise les métadonnées lors de la désérialisation pour effectuer une désérialisation polymorphe.</span><span class="sxs-lookup"><span data-stu-id="3b233-223">It uses the metadata while deserializing to do polymorphic deserialization.</span></span> <span data-ttu-id="3b233-224"><xref:System.Text.Json> pouvez effectuer une plage limitée de [sérialisation polymorphe](system-text-json-how-to.md#serialize-properties-of-derived-classes) , mais pas de désérialisation polymorphe.</span><span class="sxs-lookup"><span data-stu-id="3b233-224"><xref:System.Text.Json> can do a limited range of [polymorphic serialization](system-text-json-how-to.md#serialize-properties-of-derived-classes) but not polymorphic deserialization.</span></span>

<span data-ttu-id="3b233-225">Pour prendre en charge la désérialisation polymorphe, créez un convertisseur comme l’exemple dans [Comment écrire des convertisseurs personnalisés](system-text-json-converters-how-to.md#support-polymorphic-deserialization).</span><span class="sxs-lookup"><span data-stu-id="3b233-225">To support polymorphic deserialization, create a converter like the example in [How to write custom converters](system-text-json-converters-how-to.md#support-polymorphic-deserialization).</span></span>

### <a name="required-properties"></a><span data-ttu-id="3b233-226">Propriétés requises</span><span class="sxs-lookup"><span data-stu-id="3b233-226">Required properties</span></span>

<span data-ttu-id="3b233-227">Pendant la désérialisation, <xref:System.Text.Json> ne lève pas d’exception si aucune valeur n’est reçue dans le JSON pour l’une des propriétés du type cible.</span><span class="sxs-lookup"><span data-stu-id="3b233-227">During deserialization, <xref:System.Text.Json> doesn't throw an exception if no value is received in the JSON for one of the properties of the target type.</span></span> <span data-ttu-id="3b233-228">Par exemple, si vous avez une classe `WeatherForecast` :</span><span class="sxs-lookup"><span data-stu-id="3b233-228">For example, if you have a `WeatherForecast` class:</span></span>

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/WeatherForecast.cs?name=SnippetWF)]

<span data-ttu-id="3b233-229">Le code JSON suivant est désérialisé sans erreur :</span><span class="sxs-lookup"><span data-stu-id="3b233-229">The following JSON is deserialized without error:</span></span>

```json
{
    "TemperatureCelsius": 25,
    "Summary": "Hot"
}
```

<span data-ttu-id="3b233-230">Pour faire échouer la désérialisation si aucune propriété `Date` n’est dans le JSON, implémentez un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="3b233-230">To make deserialization fail if no `Date` property is in the JSON, implement a custom converter.</span></span> <span data-ttu-id="3b233-231">L’exemple de code de convertisseur suivant lève une exception si la propriété `Date` n’est pas définie une fois que la désérialisation est terminée :</span><span class="sxs-lookup"><span data-stu-id="3b233-231">The following sample converter code throws an exception if the `Date` property isn't set after deserialization is complete:</span></span>

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/WeatherForecastRequiredPropertyConverter.cs)]

<span data-ttu-id="3b233-232">Inscrivez ce convertisseur personnalisé à l' [aide d’un attribut sur la classe POCO](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-type) ou en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la collection <xref:System.Text.Json.JsonSerializerOptions.Converters>.</span><span class="sxs-lookup"><span data-stu-id="3b233-232">Register this custom converter by [using an attribute on the POCO class](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-type) or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="3b233-233">Si vous suivez ce modèle, ne transmettez pas l’objet options lorsque vous appelez de manière récursive <xref:System.Text.Json.JsonSerializer.Serialize%2A> ou <xref:System.Text.Json.JsonSerializer.Deserialize%2A>.</span><span class="sxs-lookup"><span data-stu-id="3b233-233">If you follow this pattern, don't pass in the options object when recursively calling <xref:System.Text.Json.JsonSerializer.Serialize%2A> or <xref:System.Text.Json.JsonSerializer.Deserialize%2A>.</span></span> <span data-ttu-id="3b233-234">L’objet d’options contient la collection <xref:System.Text.Json.JsonSerializerOptions.Converters%2A>.</span><span class="sxs-lookup"><span data-stu-id="3b233-234">The options object contains the <xref:System.Text.Json.JsonSerializerOptions.Converters%2A> collection.</span></span> <span data-ttu-id="3b233-235">Si vous le transmettez à `Serialize` ou `Deserialize`, le convertisseur personnalisé s’appelle lui-même, en effectuant une boucle infinie qui entraîne une exception de dépassement de capacité de la pile.</span><span class="sxs-lookup"><span data-stu-id="3b233-235">If you pass it in to `Serialize` or `Deserialize`, the custom converter calls into itself, making an infinite loop that results in a stack overflow exception.</span></span> <span data-ttu-id="3b233-236">Si les options par défaut ne sont pas réalisables, créez une nouvelle instance des options avec les paramètres dont vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="3b233-236">If the default options are not feasible, create a new instance of the options with the settings that you need.</span></span> <span data-ttu-id="3b233-237">Cette approche est lente puisque chaque nouvelle instance est mise en cache de façon indépendante.</span><span class="sxs-lookup"><span data-stu-id="3b233-237">This approach will be slow since each new instance caches independently.</span></span>

<span data-ttu-id="3b233-238">Le code de convertisseur précédent est un exemple simplifié.</span><span class="sxs-lookup"><span data-stu-id="3b233-238">The preceding converter code is a simplified example.</span></span> <span data-ttu-id="3b233-239">Une logique supplémentaire est nécessaire si vous avez besoin de gérer des attributs (tels que [[JsonIgnore]](xref:System.Text.Json.Serialization.JsonIgnoreAttribute) ou des options différentes (telles que des encodeurs personnalisés).</span><span class="sxs-lookup"><span data-stu-id="3b233-239">Additional logic would be required if you need to handle attributes (such as [[JsonIgnore]](xref:System.Text.Json.Serialization.JsonIgnoreAttribute) or different options (such as custom encoders).</span></span> <span data-ttu-id="3b233-240">En outre, l’exemple de code ne gère pas les propriétés pour lesquelles une valeur par défaut est définie dans le constructeur.</span><span class="sxs-lookup"><span data-stu-id="3b233-240">Also, the example code doesn't handle properties for which a default value is set in the constructor.</span></span> <span data-ttu-id="3b233-241">Cette approche ne fait pas la différence entre les scénarios suivants :</span><span class="sxs-lookup"><span data-stu-id="3b233-241">And this approach doesn't differentiate between the following scenarios:</span></span>

* <span data-ttu-id="3b233-242">Une propriété est absente du JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-242">A property is missing from the JSON.</span></span>
* <span data-ttu-id="3b233-243">Une propriété pour un type non Nullable est présente dans le JSON, mais la valeur est la valeur par défaut pour le type, par exemple zéro pour un `int`.</span><span class="sxs-lookup"><span data-stu-id="3b233-243">A property for a non-nullable type is present in the JSON, but the value is the default for the type, such as zero for an `int`.</span></span>
* <span data-ttu-id="3b233-244">Une propriété pour un type Nullable est présente dans le JSON, mais la valeur est null.</span><span class="sxs-lookup"><span data-stu-id="3b233-244">A property for a nullable type is present in the JSON, but the value is null.</span></span>

### <a name="deserialize-null-to-non-nullable-type"></a><span data-ttu-id="3b233-245">Désérialiser la valeur null en type non Nullable</span><span class="sxs-lookup"><span data-stu-id="3b233-245">Deserialize null to non-nullable type</span></span> 

<span data-ttu-id="3b233-246">`Newtonsoft.Json` ne lève pas d’exception dans le scénario suivant :</span><span class="sxs-lookup"><span data-stu-id="3b233-246">`Newtonsoft.Json` doesn't throw an exception in the following scenario:</span></span>

* <span data-ttu-id="3b233-247">`NullValueHandling` est défini sur `Ignore`et</span><span class="sxs-lookup"><span data-stu-id="3b233-247">`NullValueHandling` is set to `Ignore`, and</span></span>
* <span data-ttu-id="3b233-248">Pendant la désérialisation, le JSON contient une valeur null pour un type non Nullable.</span><span class="sxs-lookup"><span data-stu-id="3b233-248">During deserialization, the JSON contains a null value for a non-nullable type.</span></span>

<span data-ttu-id="3b233-249">Dans le même scénario, <xref:System.Text.Json> lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3b233-249">In the same scenario, <xref:System.Text.Json> does throw an exception.</span></span> <span data-ttu-id="3b233-250">(Le paramètre de gestion null correspondant est <xref:System.Text.Json.JsonSerializerOptions.IgnoreNullValues?displayProperty=nameWithType>.)</span><span class="sxs-lookup"><span data-stu-id="3b233-250">(The corresponding null handling setting is <xref:System.Text.Json.JsonSerializerOptions.IgnoreNullValues?displayProperty=nameWithType>.)</span></span>

<span data-ttu-id="3b233-251">Si vous êtes propriétaire du type de cible, la meilleure solution consiste à rendre la propriété en question Nullable (par exemple, modifier `int` en `int?`).</span><span class="sxs-lookup"><span data-stu-id="3b233-251">If you own the target type, the best workaround is to make the property in question nullable (for example, change `int` to `int?`).</span></span>

<span data-ttu-id="3b233-252">Une autre solution consiste à créer un convertisseur pour le type, comme dans l’exemple suivant qui gère les valeurs NULL pour les types de `DateTimeOffset` :</span><span class="sxs-lookup"><span data-stu-id="3b233-252">Another workaround is to make a converter for the type, such as the following example that handles null values for `DateTimeOffset` types:</span></span>

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/DateTimeOffsetNullHandlingConverter.cs)]

<span data-ttu-id="3b233-253">Inscrivez ce convertisseur personnalisé à l' [aide d’un attribut sur la propriété](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property) ou en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la collection <xref:System.Text.Json.JsonSerializerOptions.Converters>.</span><span class="sxs-lookup"><span data-stu-id="3b233-253">Register this custom converter by [using an attribute on the property](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property) or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="3b233-254">**Remarque :** Le convertisseur précédent **gère les valeurs NULL différemment** de `Newtonsoft.Json` pour les poco qui spécifient des valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="3b233-254">**Note:** The preceding converter **handles null values differently** than `Newtonsoft.Json` does for POCOs that specify default values.</span></span> <span data-ttu-id="3b233-255">Par exemple, supposons que le code suivant représente votre objet cible :</span><span class="sxs-lookup"><span data-stu-id="3b233-255">For example, suppose the following code represents your target object:</span></span>

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/WeatherForecast.cs?name=SnippetWFWithDefault)]

<span data-ttu-id="3b233-256">Et supposons que le code JSON suivant est désérialisé à l’aide du convertisseur précédent :</span><span class="sxs-lookup"><span data-stu-id="3b233-256">And suppose the following JSON is deserialized by using the preceding converter:</span></span>

```json
{
  "Date": null,
  "TemperatureCelsius": 25,
  "Summary": null
}
```

<span data-ttu-id="3b233-257">Après la désérialisation, la propriété `Date` a 1/1/0001 (`default(DateTimeOffset)`), autrement dit, la valeur définie dans le constructeur est remplacée.</span><span class="sxs-lookup"><span data-stu-id="3b233-257">After deserialization, the `Date` property has 1/1/0001 (`default(DateTimeOffset)`), that is, the value set in the constructor is overwritten.</span></span> <span data-ttu-id="3b233-258">Étant donné les mêmes POCO et JSON, `Newtonsoft.Json` la désérialisation laisse 1/1/2001 dans la propriété `Date`.</span><span class="sxs-lookup"><span data-stu-id="3b233-258">Given the same POCO and JSON, `Newtonsoft.Json` deserialization would leave 1/1/2001 in the `Date` property.</span></span>

### <a name="deserialize-to-immutable-classes-and-structs"></a><span data-ttu-id="3b233-259">Désérialiser en classes et structs immuables</span><span class="sxs-lookup"><span data-stu-id="3b233-259">Deserialize to immutable classes and structs</span></span>

<span data-ttu-id="3b233-260">`Newtonsoft.Json` pouvez désérialiser des classes et des structs immuables, car ils peuvent utiliser des constructeurs qui ont des paramètres.</span><span class="sxs-lookup"><span data-stu-id="3b233-260">`Newtonsoft.Json` can deserialize to immutable classes and structs because it can use constructors that have parameters.</span></span> <span data-ttu-id="3b233-261"><xref:System.Text.Json> prend en charge uniquement les constructeurs sans paramètre public.</span><span class="sxs-lookup"><span data-stu-id="3b233-261"><xref:System.Text.Json> supports only public parameterless constructors.</span></span> <span data-ttu-id="3b233-262">En guise de solution de contournement, vous pouvez appeler un constructeur avec des paramètres dans un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="3b233-262">As a workaround, you can call a constructor with parameters in a custom converter.</span></span>

<span data-ttu-id="3b233-263">Voici un struct immuable avec plusieurs paramètres de constructeur :</span><span class="sxs-lookup"><span data-stu-id="3b233-263">Here's an immutable struct with multiple constructor parameters:</span></span>

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/ImmutablePoint.cs#ImmutablePoint)]

<span data-ttu-id="3b233-264">Et voici un convertisseur qui sérialise et désérialise ce struct :</span><span class="sxs-lookup"><span data-stu-id="3b233-264">And here's a converter that serializes and deserializes this struct:</span></span>

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/ImmutablePointConverter.cs)]

<span data-ttu-id="3b233-265">Inscrivez ce convertisseur personnalisé en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la collection <xref:System.Text.Json.JsonSerializerOptions.Converters>.</span><span class="sxs-lookup"><span data-stu-id="3b233-265">Register this custom converter by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="3b233-266">Pour obtenir un exemple de convertisseur similaire qui gère les propriétés génériques ouvertes, consultez le [convertisseur intégré pour les paires clé-valeur](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/JsonValueConverterKeyValuePair.cs).</span><span class="sxs-lookup"><span data-stu-id="3b233-266">For an example of a similar converter that handles open generic properties, see the [built-in converter for key-value pairs](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/JsonValueConverterKeyValuePair.cs).</span></span>

### <a name="specify-constructor-to-use"></a><span data-ttu-id="3b233-267">Spécifier le constructeur à utiliser</span><span class="sxs-lookup"><span data-stu-id="3b233-267">Specify constructor to use</span></span>

<span data-ttu-id="3b233-268">L’attribut `Newtonsoft.Json` `[JsonConstructor]` vous permet de spécifier le constructeur à appeler lors de la désérialisation vers un POCO.</span><span class="sxs-lookup"><span data-stu-id="3b233-268">The `Newtonsoft.Json` `[JsonConstructor]` attribute lets you specify which constructor to call when deserializing to a POCO.</span></span> <span data-ttu-id="3b233-269"><xref:System.Text.Json> prend en charge uniquement les constructeurs sans paramètre.</span><span class="sxs-lookup"><span data-stu-id="3b233-269"><xref:System.Text.Json> supports only parameterless constructors.</span></span> <span data-ttu-id="3b233-270">En guise de solution de contournement, vous pouvez appeler le constructeur dont vous avez besoin dans un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="3b233-270">As a workaround, you can call whichever constructor you need in a custom converter.</span></span> <span data-ttu-id="3b233-271">Consultez l’exemple pour [désérialiser des classes et des structs immuables](#deserialize-to-immutable-classes-and-structs).</span><span class="sxs-lookup"><span data-stu-id="3b233-271">See the example for [Deserialize to immutable classes and structs](#deserialize-to-immutable-classes-and-structs).</span></span>

### <a name="conditionally-ignore-a-property"></a><span data-ttu-id="3b233-272">Ignorer une propriété de façon conditionnelle</span><span class="sxs-lookup"><span data-stu-id="3b233-272">Conditionally ignore a property</span></span>

<span data-ttu-id="3b233-273">`Newtonsoft.Json` dispose de plusieurs méthodes pour ignorer de manière conditionnelle une propriété lors de la sérialisation ou de la désérialisation :</span><span class="sxs-lookup"><span data-stu-id="3b233-273">`Newtonsoft.Json` has several ways to conditionally ignore a property on serialization or deserialization:</span></span>

* <span data-ttu-id="3b233-274">`DefaultContractResolver` vous permet de sélectionner les propriétés à inclure ou exclure, en fonction de critères arbitraires.</span><span class="sxs-lookup"><span data-stu-id="3b233-274">`DefaultContractResolver` lets you select properties to include or exclude, based on arbitrary criteria.</span></span> 
* <span data-ttu-id="3b233-275">Les paramètres `NullValueHandling` et `DefaultValueHandling` sur `JsonSerializerSettings` vous permettent de spécifier que toutes les propriétés de valeur null ou de valeur par défaut doivent être ignorées.</span><span class="sxs-lookup"><span data-stu-id="3b233-275">The `NullValueHandling` and `DefaultValueHandling` settings on `JsonSerializerSettings` let you specify that all null-value or default-value properties should be ignored.</span></span>
* <span data-ttu-id="3b233-276">Les paramètres `NullValueHandling` et `DefaultValueHandling` de l’attribut `[JsonProperty]` vous permettent de spécifier des propriétés individuelles qui doivent être ignorées lorsque la valeur est null ou la valeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="3b233-276">The `NullValueHandling` and `DefaultValueHandling` settings on the `[JsonProperty]` attribute let you specify individual properties that should be ignored when set to null or the default value.</span></span>

<span data-ttu-id="3b233-277"><xref:System.Text.Json> fournit les méthodes suivantes pour omettre des propriétés lors de la sérialisation :</span><span class="sxs-lookup"><span data-stu-id="3b233-277"><xref:System.Text.Json> provides the following ways to omit properties while serializing:</span></span>

* <span data-ttu-id="3b233-278">L’attribut [[JsonIgnore]](system-text-json-how-to.md#exclude-individual-properties) sur une propriété provoque l’omission de la propriété du JSON pendant la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="3b233-278">The [[JsonIgnore]](system-text-json-how-to.md#exclude-individual-properties) attribute on a property causes the property to be omitted from the JSON during serialization.</span></span>
* <span data-ttu-id="3b233-279">L’option [IgnoreNullValues](system-text-json-how-to.md#exclude-all-null-value-properties) global vous permet d’exclure toutes les propriétés de valeur null.</span><span class="sxs-lookup"><span data-stu-id="3b233-279">The [IgnoreNullValues](system-text-json-how-to.md#exclude-all-null-value-properties) global option lets you exclude all null-value properties.</span></span>
* <span data-ttu-id="3b233-280">L’option [IgnoreReadOnlyProperties](system-text-json-how-to.md#exclude-all-read-only-properties) global vous permet d’exclure toutes les propriétés en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="3b233-280">The [IgnoreReadOnlyProperties](system-text-json-how-to.md#exclude-all-read-only-properties) global option lets you exclude all read-only properties.</span></span>

<span data-ttu-id="3b233-281">Ces options **ne** vous permettent pas de :</span><span class="sxs-lookup"><span data-stu-id="3b233-281">These options **don't** let you:</span></span>

* <span data-ttu-id="3b233-282">Ignore toutes les propriétés qui ont la valeur par défaut pour le type.</span><span class="sxs-lookup"><span data-stu-id="3b233-282">Ignore all properties that have the default value for the type.</span></span>
* <span data-ttu-id="3b233-283">Ignorer les propriétés sélectionnées qui ont la valeur par défaut pour le type.</span><span class="sxs-lookup"><span data-stu-id="3b233-283">Ignore selected properties that have the default value for the type.</span></span>
* <span data-ttu-id="3b233-284">Ignorer les propriétés sélectionnées si leur valeur est null.</span><span class="sxs-lookup"><span data-stu-id="3b233-284">Ignore selected properties if their value is null.</span></span>
* <span data-ttu-id="3b233-285">Ignorer les propriétés sélectionnées en fonction de critères arbitraires évalués au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3b233-285">Ignore selected properties based on arbitrary criteria evaluated at run time.</span></span> 

<span data-ttu-id="3b233-286">Pour cette fonctionnalité, vous pouvez écrire un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="3b233-286">For that functionality, you can write a custom converter.</span></span> <span data-ttu-id="3b233-287">Voici un exemple de modèle POCO et un convertisseur personnalisé qui illustre cette approche :</span><span class="sxs-lookup"><span data-stu-id="3b233-287">Here's a sample POCO and a custom converter for it that illustrates this approach:</span></span>

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/WeatherForecast.cs?name=SnippetWF)]

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/WeatherForecastRuntimeIgnoreConverter.cs)]

<span data-ttu-id="3b233-288">Le convertisseur fait en sorte que la propriété `Summary` soit omise de la sérialisation si sa valeur est null, une chaîne vide ou « N/A ».</span><span class="sxs-lookup"><span data-stu-id="3b233-288">The converter causes the `Summary` property to be omitted from serialization if its value is null, an empty string, or "N/A".</span></span> 

<span data-ttu-id="3b233-289">Inscrivez ce convertisseur personnalisé à l' [aide d’un attribut sur la classe](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-type) ou en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la collection <xref:System.Text.Json.JsonSerializerOptions.Converters>.</span><span class="sxs-lookup"><span data-stu-id="3b233-289">Register this custom converter by [using an attribute on the class](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-type) or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="3b233-290">Cette approche nécessite une logique supplémentaire dans les cas suivants :</span><span class="sxs-lookup"><span data-stu-id="3b233-290">This approach requires additional logic if:</span></span>

* <span data-ttu-id="3b233-291">Le POCO comprend des propriétés complexes.</span><span class="sxs-lookup"><span data-stu-id="3b233-291">The POCO includes complex properties.</span></span>
* <span data-ttu-id="3b233-292">Vous devez gérer des attributs tels que des `[JsonIgnore]` ou des options telles que des encodeurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="3b233-292">You need to handle attributes such as `[JsonIgnore]` or options such as custom encoders.</span></span>

### <a name="callbacks"></a><span data-ttu-id="3b233-293">Rappels</span><span class="sxs-lookup"><span data-stu-id="3b233-293">Callbacks</span></span>

<span data-ttu-id="3b233-294">`Newtonsoft.Json` vous permet d’exécuter du code personnalisé à plusieurs points dans le processus de sérialisation ou de désérialisation :</span><span class="sxs-lookup"><span data-stu-id="3b233-294">`Newtonsoft.Json` lets you execute custom code at several points in the serialization or deserialization process:</span></span>

* <span data-ttu-id="3b233-295">OnDeserializing (au début de la désérialisation d’un objet)</span><span class="sxs-lookup"><span data-stu-id="3b233-295">OnDeserializing (when beginning to deserialize an object)</span></span>
* <span data-ttu-id="3b233-296">OnDeserialized (à la fin de la désérialisation d’un objet)</span><span class="sxs-lookup"><span data-stu-id="3b233-296">OnDeserialized (when finished deserializing an object)</span></span>
* <span data-ttu-id="3b233-297">OnSerializing (au début de la sérialisation d’un objet)</span><span class="sxs-lookup"><span data-stu-id="3b233-297">OnSerializing (when beginning to serialize an object)</span></span>
* <span data-ttu-id="3b233-298">OnSerialized (à la fin de la sérialisation d’un objet)</span><span class="sxs-lookup"><span data-stu-id="3b233-298">OnSerialized (when finished serializing an object)</span></span>

<span data-ttu-id="3b233-299">Dans <xref:System.Text.Json>, vous pouvez simuler des rappels en écrivant un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="3b233-299">In <xref:System.Text.Json>, you can simulate callbacks by writing a custom converter.</span></span> <span data-ttu-id="3b233-300">L’exemple suivant montre un convertisseur personnalisé pour un POCO.</span><span class="sxs-lookup"><span data-stu-id="3b233-300">The following example shows a custom converter for a POCO.</span></span> <span data-ttu-id="3b233-301">Le convertisseur comprend du code qui affiche un message à chaque point qui correspond à un rappel `Newtonsoft.Json`.</span><span class="sxs-lookup"><span data-stu-id="3b233-301">The converter includes code that displays a message at each point that corresponds to a `Newtonsoft.Json` callback.</span></span>

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/WeatherForecastCallbacksConverter.cs)]

<span data-ttu-id="3b233-302">Inscrivez ce convertisseur personnalisé à l' [aide d’un attribut sur la classe](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-type) ou en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la collection <xref:System.Text.Json.JsonSerializerOptions.Converters>.</span><span class="sxs-lookup"><span data-stu-id="3b233-302">Register this custom converter by [using an attribute on the class](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-type) or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="3b233-303">Si vous utilisez un convertisseur personnalisé qui suit l’exemple précédent :</span><span class="sxs-lookup"><span data-stu-id="3b233-303">If you use a custom converter that follows the preceding sample:</span></span>

* <span data-ttu-id="3b233-304">Le code `OnDeserializing` n’a pas accès à la nouvelle instance POCO.</span><span class="sxs-lookup"><span data-stu-id="3b233-304">The `OnDeserializing` code doesn't have access to the new POCO instance.</span></span> <span data-ttu-id="3b233-305">Pour manipuler la nouvelle instance POCO au début de la désérialisation, placez ce code dans le constructeur POCO.</span><span class="sxs-lookup"><span data-stu-id="3b233-305">To manipulate the new POCO instance at the start of deserialization, put that code in the POCO constructor.</span></span>
* <span data-ttu-id="3b233-306">Ne transmettez pas l’objet d’options lorsque vous appelez `Serialize` ou `Deserialize`de manière récursive.</span><span class="sxs-lookup"><span data-stu-id="3b233-306">Don't pass in the options object when recursively calling `Serialize` or `Deserialize`.</span></span> <span data-ttu-id="3b233-307">L’objet d’options contient la collection `Converters`.</span><span class="sxs-lookup"><span data-stu-id="3b233-307">The options object contains the `Converters` collection.</span></span> <span data-ttu-id="3b233-308">Si vous le transmettez à `Serialize` ou `Deserialize`, le convertisseur sera utilisé, en effectuant une boucle infinie qui entraîne une exception de dépassement de capacité de la pile.</span><span class="sxs-lookup"><span data-stu-id="3b233-308">If you pass it in to `Serialize` or `Deserialize`, the converter will be used, making an infinite loop that results in a stack overflow exception.</span></span>

## <a name="scenarios-that-jsonserializer-currently-doesnt-support"></a><span data-ttu-id="3b233-309">Les scénarios que JsonSerializer ne prend pas en charge actuellement</span><span class="sxs-lookup"><span data-stu-id="3b233-309">Scenarios that JsonSerializer currently doesn't support</span></span>

<span data-ttu-id="3b233-310">Les solutions de contournement sont possibles pour les scénarios suivants, mais certaines d’entre elles sont relativement difficiles à implémenter.</span><span class="sxs-lookup"><span data-stu-id="3b233-310">Workarounds are possible for the following scenarios, but some of them would be relatively difficult to implement.</span></span> <span data-ttu-id="3b233-311">Cet article ne fournit pas d’exemples de code pour les solutions de contournement pour ces scénarios.</span><span class="sxs-lookup"><span data-stu-id="3b233-311">This article doesn't provide code samples for workarounds for these scenarios.</span></span>

<span data-ttu-id="3b233-312">Il ne s’agit pas d’une liste exhaustive des fonctionnalités de `Newtonsoft.Json` qui n’ont pas d’équivalents dans `System.Text.Json`.</span><span class="sxs-lookup"><span data-stu-id="3b233-312">This is not an exhaustive list of `Newtonsoft.Json` features that have no equivalents in `System.Text.Json`.</span></span> <span data-ttu-id="3b233-313">La liste comprend un grand nombre des scénarios qui ont été demandés dans les [problèmes GitHub](https://github.com/dotnet/runtime/issues?q=is%3Aopen+is%3Aissue+label%3Aarea-System.Text.Json) ou les publications [StackOverflow](https://stackoverflow.com/questions/tagged/system.text.json) .</span><span class="sxs-lookup"><span data-stu-id="3b233-313">The list includes many of the scenarios that have been requested in [GitHub issues](https://github.com/dotnet/runtime/issues?q=is%3Aopen+is%3Aissue+label%3Aarea-System.Text.Json) or [StackOverflow](https://stackoverflow.com/questions/tagged/system.text.json) posts.</span></span>

<span data-ttu-id="3b233-314">Si vous implémentez une solution de contournement pour l’un de ces scénarios et que vous pouvez partager le code, sélectionnez le bouton «**cette page**» en bas de la page.</span><span class="sxs-lookup"><span data-stu-id="3b233-314">If you implement a workaround for one of these scenarios and can share the code, select the "**This page**" button at the bottom of the page.</span></span> <span data-ttu-id="3b233-315">Cela crée un problème GitHub et l’ajoute aux problèmes répertoriés au bas de la page.</span><span class="sxs-lookup"><span data-stu-id="3b233-315">That creates a GitHub issue and adds it to the issues that are listed at the bottom of the page.</span></span>

### <a name="types-without-built-in-support"></a><span data-ttu-id="3b233-316">Types sans prise en charge intégrée</span><span class="sxs-lookup"><span data-stu-id="3b233-316">Types without built-in support</span></span>

<span data-ttu-id="3b233-317"><xref:System.Text.Json> ne fournit pas de prise en charge intégrée pour les types suivants :</span><span class="sxs-lookup"><span data-stu-id="3b233-317"><xref:System.Text.Json> doesn't provide built-in support for the following types:</span></span>

* <span data-ttu-id="3b233-318"><xref:System.Data.DataTable> et types associés</span><span class="sxs-lookup"><span data-stu-id="3b233-318"><xref:System.Data.DataTable> and related types</span></span>
* <span data-ttu-id="3b233-319">F#types, tels que les [unions discriminées](../../fsharp/language-reference/discriminated-unions.md), les [types d’enregistrements](../../fsharp/language-reference/records.md)et les types d' [enregistrements anonymes](../../fsharp/language-reference/anonymous-records.md).</span><span class="sxs-lookup"><span data-stu-id="3b233-319">F# types, such as [discriminated unions](../../fsharp/language-reference/discriminated-unions.md), [record types](../../fsharp/language-reference/records.md), and [anonymous record types](../../fsharp/language-reference/anonymous-records.md).</span></span>
* <span data-ttu-id="3b233-320">Types de collections dans l’espace de noms <xref:System.Collections.Specialized></span><span class="sxs-lookup"><span data-stu-id="3b233-320">Collection types in the <xref:System.Collections.Specialized> namespace</span></span>
* <xref:System.Dynamic.ExpandoObject>
* <xref:System.TimeZoneInfo>
* <xref:System.Numerics.BigInteger>
* <xref:System.TimeSpan>
* <xref:System.DBNull>
* <xref:System.Type>
* <span data-ttu-id="3b233-321"><xref:System.ValueTuple> et ses types génériques associés</span><span class="sxs-lookup"><span data-stu-id="3b233-321"><xref:System.ValueTuple> and its associated generic types</span></span>

<span data-ttu-id="3b233-322">Les convertisseurs personnalisés peuvent être implémentés pour les types qui n’ont pas de prise en charge intégrée.</span><span class="sxs-lookup"><span data-stu-id="3b233-322">Custom converters can be implemented for types that don't have built-in support.</span></span>

### <a name="public-and-non-public-fields"></a><span data-ttu-id="3b233-323">Champs publics et non publics</span><span class="sxs-lookup"><span data-stu-id="3b233-323">Public and non-public fields</span></span>

<span data-ttu-id="3b233-324">`Newtonsoft.Json` pouvez sérialiser et désérialiser des champs ainsi que des propriétés.</span><span class="sxs-lookup"><span data-stu-id="3b233-324">`Newtonsoft.Json` can serialize and deserialize fields as well as properties.</span></span> <span data-ttu-id="3b233-325"><xref:System.Text.Json> fonctionne uniquement avec les propriétés publiques.</span><span class="sxs-lookup"><span data-stu-id="3b233-325"><xref:System.Text.Json> only works with public properties.</span></span> <span data-ttu-id="3b233-326">Les convertisseurs personnalisés peuvent fournir cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="3b233-326">Custom converters can provide this functionality.</span></span>

### <a name="internal-and-private-property-setters-and-getters"></a><span data-ttu-id="3b233-327">Accesseurs set et getters de propriétés internes et privées</span><span class="sxs-lookup"><span data-stu-id="3b233-327">Internal and private property setters and getters</span></span>

<span data-ttu-id="3b233-328">`Newtonsoft.Json` pouvez utiliser des accesseurs set et des accesseurs set de propriété privés et internes via l’attribut `JsonProperty`.</span><span class="sxs-lookup"><span data-stu-id="3b233-328">`Newtonsoft.Json` can use private and internal property setters and getters via the `JsonProperty` attribute.</span></span> <span data-ttu-id="3b233-329"><xref:System.Text.Json> prend en charge uniquement les accesseurs set publics.</span><span class="sxs-lookup"><span data-stu-id="3b233-329"><xref:System.Text.Json> supports only public setters.</span></span> <span data-ttu-id="3b233-330">Les convertisseurs personnalisés peuvent fournir cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="3b233-330">Custom converters can provide this functionality.</span></span>

### <a name="preserve-object-references-and-handle-loops"></a><span data-ttu-id="3b233-331">Conserver les références d’objet et gérer les boucles</span><span class="sxs-lookup"><span data-stu-id="3b233-331">Preserve object references and handle loops</span></span>

<span data-ttu-id="3b233-332">Par défaut, `Newtonsoft.Json` sérialise par valeur.</span><span class="sxs-lookup"><span data-stu-id="3b233-332">By default, `Newtonsoft.Json` serializes by value.</span></span> <span data-ttu-id="3b233-333">Par exemple, si un objet contient deux propriétés qui contiennent une référence au même objet `Person`, les valeurs des propriétés de cet objet `Person` sont dupliquées dans le JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-333">For example, if an object contains two properties that contain a reference to the same `Person` object, the values of that `Person` object's properties are duplicated in the JSON.</span></span>

<span data-ttu-id="3b233-334">`Newtonsoft.Json` a un paramètre `PreserveReferencesHandling` sur `JsonSerializerSettings` qui vous permet de sérialiser par référence :</span><span class="sxs-lookup"><span data-stu-id="3b233-334">`Newtonsoft.Json` has a `PreserveReferencesHandling` setting on `JsonSerializerSettings` that lets you serialize by reference:</span></span>

* <span data-ttu-id="3b233-335">Les métadonnées d’identificateur sont ajoutées au JSON créé pour le premier objet `Person`.</span><span class="sxs-lookup"><span data-stu-id="3b233-335">An identifier metadata is added to the JSON created for the first `Person` object.</span></span>
* <span data-ttu-id="3b233-336">Le JSON créé pour le deuxième `Person` objet contient une référence à cet identificateur à la place des valeurs de propriété.</span><span class="sxs-lookup"><span data-stu-id="3b233-336">The JSON that is created for the second `Person` object contains a reference to that identifier instead of property values.</span></span>

<span data-ttu-id="3b233-337">`Newtonsoft.Json` a également un paramètre `ReferenceLoopHandling` qui vous permet d’ignorer les références circulaires au lieu de lever une exception.</span><span class="sxs-lookup"><span data-stu-id="3b233-337">`Newtonsoft.Json` also has a `ReferenceLoopHandling` setting that lets you ignore circular references rather than throw an exception.</span></span>

<span data-ttu-id="3b233-338"><xref:System.Text.Json> prend en charge uniquement la sérialisation par valeur et lève une exception pour les références circulaires.</span><span class="sxs-lookup"><span data-stu-id="3b233-338"><xref:System.Text.Json> only supports serialization by value and throws an exception for circular references.</span></span>

### <a name="systemruntimeserialization-attributes"></a><span data-ttu-id="3b233-339">Attributs System. Runtime. Serialization</span><span class="sxs-lookup"><span data-stu-id="3b233-339">System.Runtime.Serialization attributes</span></span>

<span data-ttu-id="3b233-340"><xref:System.Text.Json> ne prend pas en charge les attributs de l’espace de noms `System.Runtime.Serialization`, tels que `DataMemberAttribute` et `IgnoreDataMemberAttribute`.</span><span class="sxs-lookup"><span data-stu-id="3b233-340"><xref:System.Text.Json> doesn't support attributes from the `System.Runtime.Serialization` namespace, such as `DataMemberAttribute` and `IgnoreDataMemberAttribute`.</span></span>

### <a name="octal-numbers"></a><span data-ttu-id="3b233-341">Nombres octaux</span><span class="sxs-lookup"><span data-stu-id="3b233-341">Octal numbers</span></span>

<span data-ttu-id="3b233-342">`Newtonsoft.Json` traite les nombres avec un zéro non significatif comme des nombres octaux.</span><span class="sxs-lookup"><span data-stu-id="3b233-342">`Newtonsoft.Json` treats numbers with a leading zero as octal numbers.</span></span> <span data-ttu-id="3b233-343"><xref:System.Text.Json> n’autorise pas les zéros non significatifs, car la spécification [RFC 8259](https://tools.ietf.org/html/rfc8259) ne les autorise pas.</span><span class="sxs-lookup"><span data-stu-id="3b233-343"><xref:System.Text.Json> doesn't allow leading zeroes because the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification doesn't allow them.</span></span>

### <a name="populate-existing-objects"></a><span data-ttu-id="3b233-344">Remplir les objets existants</span><span class="sxs-lookup"><span data-stu-id="3b233-344">Populate existing objects</span></span>

<span data-ttu-id="3b233-345">La méthode `JsonConvert.PopulateObject` dans `Newtonsoft.Json` désérialise un document JSON en une instance existante d’une classe, au lieu de créer une nouvelle instance.</span><span class="sxs-lookup"><span data-stu-id="3b233-345">The `JsonConvert.PopulateObject` method in `Newtonsoft.Json` deserializes a JSON document to an existing instance of a class, instead of creating a new instance.</span></span> <span data-ttu-id="3b233-346"><xref:System.Text.Json> crée toujours une nouvelle instance du type cible à l’aide du constructeur sans paramètre public par défaut.</span><span class="sxs-lookup"><span data-stu-id="3b233-346"><xref:System.Text.Json> always creates a new instance of the target type by using the default public parameterless constructor.</span></span> <span data-ttu-id="3b233-347">Les convertisseurs personnalisés peuvent être désérialisés en une instance existante.</span><span class="sxs-lookup"><span data-stu-id="3b233-347">Custom converters can deserialize to an existing instance.</span></span>

### <a name="reuse-rather-than-replace-properties"></a><span data-ttu-id="3b233-348">Réutiliser plutôt que remplacer les propriétés</span><span class="sxs-lookup"><span data-stu-id="3b233-348">Reuse rather than replace properties</span></span>

<span data-ttu-id="3b233-349">Le paramètre `Newtonsoft.Json` `ObjectCreationHandling` vous permet de spécifier que les objets dans les propriétés doivent être réutilisés au lieu d’être remplacés lors de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="3b233-349">The `Newtonsoft.Json` `ObjectCreationHandling` setting lets you specify that objects in properties should be reused rather than replaced during deserialization.</span></span> <span data-ttu-id="3b233-350"><xref:System.Text.Json> remplace toujours les objets dans les propriétés.</span><span class="sxs-lookup"><span data-stu-id="3b233-350"><xref:System.Text.Json> always replaces objects in properties.</span></span>  <span data-ttu-id="3b233-351">Les convertisseurs personnalisés peuvent fournir cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="3b233-351">Custom converters can provide this functionality.</span></span>

### <a name="add-to-collections-without-setters"></a><span data-ttu-id="3b233-352">Ajouter aux collections sans Setters</span><span class="sxs-lookup"><span data-stu-id="3b233-352">Add to collections without setters</span></span>

<span data-ttu-id="3b233-353">Pendant la désérialisation, `Newtonsoft.Json` ajoute des objets à une collection même si la propriété n’a pas d’accesseur Set.</span><span class="sxs-lookup"><span data-stu-id="3b233-353">During deserialization, `Newtonsoft.Json` adds objects to a collection even if the property has no setter.</span></span> <span data-ttu-id="3b233-354"><xref:System.Text.Json> ignore les propriétés qui n’ont pas de méthode setter.</span><span class="sxs-lookup"><span data-stu-id="3b233-354"><xref:System.Text.Json> ignores properties that don't have setters.</span></span> <span data-ttu-id="3b233-355">Les convertisseurs personnalisés peuvent fournir cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="3b233-355">Custom converters can provide this functionality.</span></span>

### <a name="missingmemberhandling"></a><span data-ttu-id="3b233-356">MissingMemberHandling</span><span class="sxs-lookup"><span data-stu-id="3b233-356">MissingMemberHandling</span></span>

<span data-ttu-id="3b233-357">`Newtonsoft.Json` peut être configuré pour lever des exceptions pendant la désérialisation si le JSON comprend des propriétés qui sont manquantes dans le type cible.</span><span class="sxs-lookup"><span data-stu-id="3b233-357">`Newtonsoft.Json` can be configured to throw exceptions during deserialization if the JSON includes properties that are missing in the target type.</span></span> <span data-ttu-id="3b233-358"><xref:System.Text.Json> ignore les propriétés supplémentaires dans JSON, sauf lorsque vous utilisez l' [attribut [JsonExtensionData]](system-text-json-how-to.md#handle-overflow-json).</span><span class="sxs-lookup"><span data-stu-id="3b233-358"><xref:System.Text.Json> ignores extra properties in the JSON, except when you use the [[JsonExtensionData] attribute](system-text-json-how-to.md#handle-overflow-json).</span></span> <span data-ttu-id="3b233-359">Il n’existe aucune solution de contournement pour la fonctionnalité de membre manquant.</span><span class="sxs-lookup"><span data-stu-id="3b233-359">There's no workaround for the missing member feature.</span></span>

### <a name="tracewriter"></a><span data-ttu-id="3b233-360">TraceWriter</span><span class="sxs-lookup"><span data-stu-id="3b233-360">TraceWriter</span></span>

<span data-ttu-id="3b233-361">`Newtonsoft.Json` vous permet de déboguer à l’aide d’un `TraceWriter` pour afficher les journaux qui sont générés par la sérialisation ou la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="3b233-361">`Newtonsoft.Json` lets you debug by using a `TraceWriter` to view logs that are generated by serialization or deserialization.</span></span> <span data-ttu-id="3b233-362"><xref:System.Text.Json> n’effectue pas de journalisation.</span><span class="sxs-lookup"><span data-stu-id="3b233-362"><xref:System.Text.Json> doesn't do logging.</span></span>

## <a name="jsondocument-and-jsonelement-compared-to-jtoken-like-jobject-jarray"></a><span data-ttu-id="3b233-363">JsonDocument et JsonElement comparés à JToken (comme JObject, JArray)</span><span class="sxs-lookup"><span data-stu-id="3b233-363">JsonDocument and JsonElement compared to JToken (like JObject, JArray)</span></span>

<span data-ttu-id="3b233-364"><xref:System.Text.Json.JsonDocument?displayProperty=fullName> offre la possibilité d’analyser et de générer un Document Object Model **en lecture seule** à partir de charges utiles JSON existantes.</span><span class="sxs-lookup"><span data-stu-id="3b233-364"><xref:System.Text.Json.JsonDocument?displayProperty=fullName> provides the ability to parse and build a **read-only** Document Object Model (DOM) from existing JSON payloads.</span></span> <span data-ttu-id="3b233-365">Le DOM fournit un accès aléatoire aux données dans une charge utile JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-365">The DOM provides random access to data in a JSON payload.</span></span> <span data-ttu-id="3b233-366">Les éléments JSON qui composent la charge utile sont accessibles via le type de <xref:System.Text.Json.JsonElement>.</span><span class="sxs-lookup"><span data-stu-id="3b233-366">The JSON elements that compose the payload can be accessed via the <xref:System.Text.Json.JsonElement> type.</span></span> <span data-ttu-id="3b233-367">Le type de `JsonElement` fournit des API pour convertir du texte JSON en types .NET courants.</span><span class="sxs-lookup"><span data-stu-id="3b233-367">The `JsonElement` type provides APIs to convert JSON text to common .NET types.</span></span> <span data-ttu-id="3b233-368">`JsonDocument` expose une propriété <xref:System.Text.Json.JsonDocument.RootElement>.</span><span class="sxs-lookup"><span data-stu-id="3b233-368">`JsonDocument` exposes a <xref:System.Text.Json.JsonDocument.RootElement> property.</span></span>

### <a name="jsondocument-is-idisposable"></a><span data-ttu-id="3b233-369">JsonDocument est IDisposable</span><span class="sxs-lookup"><span data-stu-id="3b233-369">JsonDocument is IDisposable</span></span>

<span data-ttu-id="3b233-370">`JsonDocument` crée une vue en mémoire des données dans une mémoire tampon regroupée.</span><span class="sxs-lookup"><span data-stu-id="3b233-370">`JsonDocument` builds an in-memory view of the data into a pooled buffer.</span></span> <span data-ttu-id="3b233-371">Par conséquent, contrairement à `JObject` ou `JArray` à partir de `Newtonsoft.Json`, le type de `JsonDocument` implémente `IDisposable` et doit être utilisé à l’intérieur d’un bloc using.</span><span class="sxs-lookup"><span data-stu-id="3b233-371">Therefore, unlike `JObject` or `JArray` from `Newtonsoft.Json`, the `JsonDocument` type implements `IDisposable` and needs to be used inside a using block.</span></span> 

<span data-ttu-id="3b233-372">Retournez uniquement une `JsonDocument` à partir de votre API si vous souhaitez transférer la propriété de la durée de vie et supprimer la responsabilité de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="3b233-372">Only return a `JsonDocument` from your API if you want to transfer lifetime ownership and dispose responsibility to the caller.</span></span> <span data-ttu-id="3b233-373">Dans la plupart des scénarios, ce n’est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="3b233-373">In most scenarios, that isn't necessary.</span></span> <span data-ttu-id="3b233-374">Si l’appelant doit travailler avec l’ensemble du document JSON, retournez le <xref:System.Text.Json.JsonElement.Clone%2A> du <xref:System.Text.Json.JsonDocument.RootElement%2A>, qui est un <xref:System.Text.Json.JsonElement>.</span><span class="sxs-lookup"><span data-stu-id="3b233-374">If the caller needs to work with the entire JSON document, return the <xref:System.Text.Json.JsonElement.Clone%2A> of the <xref:System.Text.Json.JsonDocument.RootElement%2A>, which is a <xref:System.Text.Json.JsonElement>.</span></span> <span data-ttu-id="3b233-375">Si l’appelant doit travailler avec un élément particulier dans le document JSON, retournez le <xref:System.Text.Json.JsonElement.Clone%2A> de ce <xref:System.Text.Json.JsonElement>.</span><span class="sxs-lookup"><span data-stu-id="3b233-375">If the caller needs to work with a particular element within the JSON document, return the <xref:System.Text.Json.JsonElement.Clone%2A> of that <xref:System.Text.Json.JsonElement>.</span></span> <span data-ttu-id="3b233-376">Si vous retournez l' `RootElement` ou un sous-élément directement sans créer de `Clone`, l’appelant ne pourra pas accéder au `JsonElement` retourné une fois que le `JsonDocument` qui le possède est supprimé.</span><span class="sxs-lookup"><span data-stu-id="3b233-376">If you return the `RootElement` or a sub-element directly without making a `Clone`, the caller won't be able to access the returned `JsonElement` after the `JsonDocument` that owns it is disposed.</span></span>

<span data-ttu-id="3b233-377">Voici un exemple qui vous oblige à créer une `Clone`:</span><span class="sxs-lookup"><span data-stu-id="3b233-377">Here's an example that requires you to make a `Clone`:</span></span>

```csharp
public JsonElement LookAndLoad(JsonElement source)
{
    string json = File.ReadAllText(source.GetProperty("fileName").GetString());
   
    using (JsonDocument doc = JsonDocument.Parse(json))
    {
        return doc.RootElement.Clone();
    }
}
```

<span data-ttu-id="3b233-378">Le code précédent attend un `JsonElement` qui contient une propriété `fileName`.</span><span class="sxs-lookup"><span data-stu-id="3b233-378">The preceding code expects a `JsonElement` that contains a `fileName` property.</span></span> <span data-ttu-id="3b233-379">Il ouvre le fichier JSON et crée un `JsonDocument`.</span><span class="sxs-lookup"><span data-stu-id="3b233-379">It opens the JSON file and creates a `JsonDocument`.</span></span> <span data-ttu-id="3b233-380">La méthode suppose que l’appelant souhaite travailler avec l’ensemble du document, de sorte qu’il retourne le `Clone` du `RootElement`.</span><span class="sxs-lookup"><span data-stu-id="3b233-380">The method assumes that the caller wants to work with the entire document, so it returns the `Clone` of the `RootElement`.</span></span> 

<span data-ttu-id="3b233-381">Si vous recevez une `JsonElement` et retournent un sous-élément, il n’est pas nécessaire de retourner une `Clone` du sous-élément.</span><span class="sxs-lookup"><span data-stu-id="3b233-381">If you receive a `JsonElement` and are returning a sub-element, it's not necessary to return a `Clone` of the sub-element.</span></span> <span data-ttu-id="3b233-382">L’appelant est chargé de conserver le `JsonDocument` auquel appartient le `JsonElement` passé.</span><span class="sxs-lookup"><span data-stu-id="3b233-382">The caller is responsible for keeping alive the `JsonDocument` that the passed-in `JsonElement` belongs to.</span></span> <span data-ttu-id="3b233-383">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="3b233-383">For example:</span></span>

```csharp
public JsonElement ReturnFileName(JsonElement source)
{
   return source.GetProperty("fileName");
}
```

### <a name="jsondocument-is-read-only"></a><span data-ttu-id="3b233-384">JsonDocument est en lecture seule</span><span class="sxs-lookup"><span data-stu-id="3b233-384">JsonDocument is read-only</span></span>

<span data-ttu-id="3b233-385">Le DOM <xref:System.Text.Json> ne peut pas ajouter, supprimer ou modifier des éléments JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-385">The <xref:System.Text.Json> DOM can't add, remove, or modify JSON elements.</span></span> <span data-ttu-id="3b233-386">Cette méthode est conçue pour les performances et pour réduire les allocations pour l’analyse des tailles de charge utile JSON courantes (c’est-à-dire < 1 Mo).</span><span class="sxs-lookup"><span data-stu-id="3b233-386">It's designed this way for performance and to reduce allocations for parsing common JSON payload sizes (that is, < 1 MB).</span></span> <span data-ttu-id="3b233-387">Si votre scénario utilise actuellement un modèle DOM modifiable, l’une des solutions de contournement suivantes peut être possible :</span><span class="sxs-lookup"><span data-stu-id="3b233-387">If your scenario currently uses a modifiable DOM, one of the following workarounds might be feasible:</span></span>

* <span data-ttu-id="3b233-388">Pour créer une `JsonDocument` à partir de zéro (autrement dit, sans passer une charge utile JSON existante à la méthode `Parse`), écrivez le texte JSON à l’aide de la `Utf8JsonWriter` et analysez la sortie de celle-ci pour créer un `JsonDocument`.</span><span class="sxs-lookup"><span data-stu-id="3b233-388">To build a `JsonDocument` from scratch (that is, without passing in an existing JSON payload to the `Parse` method), write the JSON text by using the `Utf8JsonWriter` and parse the output from that to make a new `JsonDocument`.</span></span>
* <span data-ttu-id="3b233-389">Pour modifier une `JsonDocument`existante, utilisez-la pour écrire du texte JSON, apporter des modifications pendant l’écriture et analyser la sortie de celle-ci pour créer une nouvelle `JsonDocument`.</span><span class="sxs-lookup"><span data-stu-id="3b233-389">To modify an existing `JsonDocument`, use it to write JSON text, making changes while you write, and parse the output from that to make a new `JsonDocument`.</span></span>
* <span data-ttu-id="3b233-390">Pour fusionner les documents JSON existants, équivalents aux API `JObject.Merge` ou `JContainer.Merge` à partir `Newtonsoft.Json`, consultez [ce problème GitHub](https://github.com/dotnet/corefx/issues/42466#issuecomment-570475853).</span><span class="sxs-lookup"><span data-stu-id="3b233-390">To merge existing JSON documents, equivalent to the `JObject.Merge` or `JContainer.Merge` APIs from `Newtonsoft.Json`, see [this GitHub issue](https://github.com/dotnet/corefx/issues/42466#issuecomment-570475853).</span></span>

### <a name="jsonelement-is-a-union-struct"></a><span data-ttu-id="3b233-391">JsonElement est un struct d’Union</span><span class="sxs-lookup"><span data-stu-id="3b233-391">JsonElement is a union struct</span></span>

<span data-ttu-id="3b233-392">`JsonDocument` expose le `RootElement` en tant que propriété de type <xref:System.Text.Json.JsonElement>, qui est une Union, type struct qui englobe tout élément JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-392">`JsonDocument` exposes the `RootElement` as a property of type <xref:System.Text.Json.JsonElement>, which is a union, struct type that encompasses any JSON element.</span></span> <span data-ttu-id="3b233-393">`Newtonsoft.Json` utilise des types hiérarchiques dédiés comme `JObject`,`JArray`, `JToken`, etc.</span><span class="sxs-lookup"><span data-stu-id="3b233-393">`Newtonsoft.Json` uses dedicated hierarchical types like `JObject`,`JArray`, `JToken`, and so forth.</span></span> <span data-ttu-id="3b233-394">`JsonElement` est ce que vous pouvez rechercher et énumérer, et vous pouvez utiliser `JsonElement` pour matérialiser des éléments JSON dans des types .NET.</span><span class="sxs-lookup"><span data-stu-id="3b233-394">`JsonElement` is what you can search and enumerate over, and you can use `JsonElement` to materialize JSON elements into .NET types.</span></span>

### <a name="how-to-search-a-jsondocument-and-jsonelement-for-sub-elements"></a><span data-ttu-id="3b233-395">Comment rechercher des sous-éléments dans un JsonDocument et JsonElement</span><span class="sxs-lookup"><span data-stu-id="3b233-395">How to search a JsonDocument and JsonElement for sub-elements</span></span>

<span data-ttu-id="3b233-396">Recherche des jetons JSON à l’aide d' `JObject` ou d' `JArray` à partir de `Newtonsoft.Json` tendance à être relativement rapide car il s’agit de recherches dans un dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="3b233-396">Searches for JSON tokens using `JObject` or `JArray` from `Newtonsoft.Json` tend to be relatively fast because they're lookups in some dictionary.</span></span> <span data-ttu-id="3b233-397">Par comparaison, les recherches sur `JsonElement` requièrent une recherche séquentielle des propriétés et sont donc relativement lentes (par exemple, lors de l’utilisation de `TryGetProperty`).</span><span class="sxs-lookup"><span data-stu-id="3b233-397">By comparison, searches on `JsonElement` require a sequential search of the properties and hence is relatively slow (for example when using `TryGetProperty`).</span></span> <span data-ttu-id="3b233-398"><xref:System.Text.Json> est conçu pour réduire le temps d’analyse initial plutôt que le temps de recherche.</span><span class="sxs-lookup"><span data-stu-id="3b233-398"><xref:System.Text.Json> is designed to minimize initial parse time rather than lookup time.</span></span> <span data-ttu-id="3b233-399">Par conséquent, utilisez les approches suivantes pour optimiser les performances lors de la recherche dans un objet `JsonDocument` :</span><span class="sxs-lookup"><span data-stu-id="3b233-399">Therefore, use the following approaches to optimize performance when searching through a `JsonDocument` object:</span></span>

* <span data-ttu-id="3b233-400">Utilisez les énumérateurs intégrés (<xref:System.Text.Json.JsonElement.EnumerateArray%2A> et <xref:System.Text.Json.JsonElement.EnumerateObject%2A>) au lieu d’effectuer votre propre indexation ou boucles.</span><span class="sxs-lookup"><span data-stu-id="3b233-400">Use the built-in enumerators (<xref:System.Text.Json.JsonElement.EnumerateArray%2A> and <xref:System.Text.Json.JsonElement.EnumerateObject%2A>) rather than doing your own indexing or loops.</span></span>
* <span data-ttu-id="3b233-401">N’effectuez pas de recherche séquentielle sur l’ensemble du `JsonDocument` par le biais de chaque propriété à l’aide de `RootElement`.</span><span class="sxs-lookup"><span data-stu-id="3b233-401">Don't do a sequential search on the whole `JsonDocument` through every property by using `RootElement`.</span></span> <span data-ttu-id="3b233-402">Au lieu de cela, recherchez des objets JSON imbriqués en fonction de la structure connue des données JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-402">Instead, search on nested JSON objects based on the known structure of the JSON data.</span></span> <span data-ttu-id="3b233-403">Par exemple, si vous recherchez une propriété `Grade` dans `Student` objets, effectuez une boucle sur les objets `Student` et récupérez la valeur de `Grade` pour chaque objet, plutôt que de rechercher dans tous les objets `JsonElement` recherchant des propriétés `Grade`.</span><span class="sxs-lookup"><span data-stu-id="3b233-403">For example, if you're looking for a `Grade` property in `Student` objects, loop through the `Student` objects and get the value of `Grade` for each, rather than searching through all `JsonElement` objects looking for `Grade` properties.</span></span> <span data-ttu-id="3b233-404">Si vous procédez ainsi, vous obtiendrez des passes inutiles sur les mêmes données.</span><span class="sxs-lookup"><span data-stu-id="3b233-404">Doing the latter will result in unnecessary passes over the same data.</span></span>

<span data-ttu-id="3b233-405">Pour obtenir un exemple de code, consultez [utiliser JsonDocument pour accéder aux données](system-text-json-how-to.md#use-jsondocument-for-access-to-data).</span><span class="sxs-lookup"><span data-stu-id="3b233-405">For a code example, see [Use JsonDocument for access to data](system-text-json-how-to.md#use-jsondocument-for-access-to-data).</span></span>

## <a name="utf8jsonreader-compared-to-jsontextreader"></a><span data-ttu-id="3b233-406">Utf8JsonReader comparé à JsonTextReader</span><span class="sxs-lookup"><span data-stu-id="3b233-406">Utf8JsonReader compared to JsonTextReader</span></span>

<span data-ttu-id="3b233-407"><xref:System.Text.Json.Utf8JsonReader?displayProperty=fullName> est un lecteur haute performance, à faible allocation et en avant uniquement pour le texte JSON encodé en UTF-8, lit à partir d’un [ReadOnlySpan\<byte >](xref:System.ReadOnlySpan%601) ou [ReadOnlySequence\<Byte >](xref:System.Buffers.ReadOnlySequence%601).</span><span class="sxs-lookup"><span data-stu-id="3b233-407"><xref:System.Text.Json.Utf8JsonReader?displayProperty=fullName> is a high-performance, low allocation, forward-only reader for UTF-8 encoded JSON text, read from a [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601) or [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601).</span></span> <span data-ttu-id="3b233-408">Le `Utf8JsonReader` est un type de bas niveau qui peut être utilisé pour créer des analyseurs et des désérialiseurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="3b233-408">The `Utf8JsonReader` is a low-level type that can be used to build custom parsers and deserializers.</span></span>

<span data-ttu-id="3b233-409">Les sections suivantes expliquent les modèles de programmation recommandés pour l’utilisation de `Utf8JsonReader`.</span><span class="sxs-lookup"><span data-stu-id="3b233-409">The following sections explain recommended programming patterns for using `Utf8JsonReader`.</span></span>

### <a name="utf8jsonreader-is-a-ref-struct"></a><span data-ttu-id="3b233-410">Utf8JsonReader est un struct Ref</span><span class="sxs-lookup"><span data-stu-id="3b233-410">Utf8JsonReader is a ref struct</span></span>

<span data-ttu-id="3b233-411">Étant donné que le type de `Utf8JsonReader` est un *struct de référence*, il présente [certaines limitations](../../csharp/language-reference/keywords/ref.md#ref-struct-types).</span><span class="sxs-lookup"><span data-stu-id="3b233-411">Because the `Utf8JsonReader` type is a *ref struct*, it has [certain limitations](../../csharp/language-reference/keywords/ref.md#ref-struct-types).</span></span> <span data-ttu-id="3b233-412">Par exemple, il ne peut pas être stocké en tant que champ sur une classe ou un struct autre qu’un struct Ref.</span><span class="sxs-lookup"><span data-stu-id="3b233-412">For example, it can't be stored as a field on a class or struct other than a ref struct.</span></span> <span data-ttu-id="3b233-413">Pour obtenir des performances élevées, ce type doit être un `ref struct` dans la mesure où il doit mettre en cache l’entrée [ReadOnlySpan\<byte >](xref:System.ReadOnlySpan%601), qui est lui-même un struct Ref.</span><span class="sxs-lookup"><span data-stu-id="3b233-413">To achieve high performance, this type must be a `ref struct` since it needs to cache the input [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601), which itself is a ref struct.</span></span> <span data-ttu-id="3b233-414">En outre, ce type est mutable puisqu’il contient l’État.</span><span class="sxs-lookup"><span data-stu-id="3b233-414">In addition, this type is mutable since it holds state.</span></span> <span data-ttu-id="3b233-415">Par conséquent, **transmettez-le par référence** plutôt que par valeur.</span><span class="sxs-lookup"><span data-stu-id="3b233-415">Therefore, **pass it by ref** rather than by value.</span></span> <span data-ttu-id="3b233-416">Le fait de le passer par valeur génère une copie de struct et les modifications d’État ne sont pas visibles par l’appelant.</span><span class="sxs-lookup"><span data-stu-id="3b233-416">Passing it by value would result in a struct copy and the state changes would not be visible to the caller.</span></span> <span data-ttu-id="3b233-417">Cela diffère de `Newtonsoft.Json` dans la mesure où le `Newtonsoft.Json` `JsonTextReader` est une classe.</span><span class="sxs-lookup"><span data-stu-id="3b233-417">This differs from `Newtonsoft.Json` since the `Newtonsoft.Json` `JsonTextReader` is a class.</span></span> <span data-ttu-id="3b233-418">Pour plus d’informations sur l’utilisation des structs de référence, consultez [écriture de C# code sécurisé et efficace](../../csharp/write-safe-efficient-code.md).</span><span class="sxs-lookup"><span data-stu-id="3b233-418">For more information about how to use ref structs, see [Write safe and efficient C# code](../../csharp/write-safe-efficient-code.md).</span></span>

### <a name="read-utf-8-text"></a><span data-ttu-id="3b233-419">Lire du texte UTF-8</span><span class="sxs-lookup"><span data-stu-id="3b233-419">Read UTF-8 text</span></span>

<span data-ttu-id="3b233-420">Pour obtenir les meilleures performances possibles lors de l’utilisation de la `Utf8JsonReader`, lisez les charges utiles JSON déjà encodées en tant que texte UTF-8 plutôt qu’en tant que chaînes UTF-16.</span><span class="sxs-lookup"><span data-stu-id="3b233-420">To achieve the best possible performance while using the `Utf8JsonReader`, read JSON payloads already encoded as UTF-8 text rather than as UTF-16 strings.</span></span> <span data-ttu-id="3b233-421">Pour obtenir un exemple de code, consultez [Filtrer les données à l’aide de Utf8JsonReader](system-text-json-how-to.md#filter-data-using-utf8jsonreader).</span><span class="sxs-lookup"><span data-stu-id="3b233-421">For a code example, see [Filter data using Utf8JsonReader](system-text-json-how-to.md#filter-data-using-utf8jsonreader).</span></span>

### <a name="read-with-a-stream-or-pipereader"></a><span data-ttu-id="3b233-422">Lire avec un flux ou un PipeReader</span><span class="sxs-lookup"><span data-stu-id="3b233-422">Read with a Stream or PipeReader</span></span>

<span data-ttu-id="3b233-423">Le `Utf8JsonReader` prend en charge la lecture à partir d’un > codé en UTF-8 [ReadOnlySpan\<byte >](xref:System.ReadOnlySpan%601) ou [ReadOnlySequence\<Byte <xref:System.IO.Pipelines.PipeReader>](xref:System.Buffers.ReadOnlySequence%601) (qui est le résultat de la lecture à partir d’un).</span><span class="sxs-lookup"><span data-stu-id="3b233-423">The `Utf8JsonReader` supports reading from a UTF-8 encoded [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601) or [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601) (which is the result of reading from a <xref:System.IO.Pipelines.PipeReader>).</span></span>

<span data-ttu-id="3b233-424">Pour la lecture synchrone, vous pouvez lire la charge utile JSON jusqu’à la fin du flux dans un tableau d’octets et la passer dans le lecteur.</span><span class="sxs-lookup"><span data-stu-id="3b233-424">For synchronous reading, you could read the JSON payload until the end of the stream into a byte array and pass that into the reader.</span></span> <span data-ttu-id="3b233-425">Pour lire à partir d’une chaîne (qui est encodée au format UTF-16), appelez <xref:System.Text.Encoding.UTF8>.<xref:System.Text.Encoding.GetBytes%2A></span><span class="sxs-lookup"><span data-stu-id="3b233-425">For reading from a string (which is encoded as UTF-16), call <xref:System.Text.Encoding.UTF8>.<xref:System.Text.Encoding.GetBytes%2A></span></span> <span data-ttu-id="3b233-426">pour tout d’abord transcoder la chaîne en un tableau d’octets encodé en UTF-8.</span><span class="sxs-lookup"><span data-stu-id="3b233-426">to first transcode the string to a UTF-8 encoded byte array.</span></span> <span data-ttu-id="3b233-427">Ensuite, transmettez-le à la `Utf8JsonReader`.</span><span class="sxs-lookup"><span data-stu-id="3b233-427">Then pass that to the `Utf8JsonReader`.</span></span> 

<span data-ttu-id="3b233-428">Étant donné que le `Utf8JsonReader` considère que l’entrée est du texte JSON, une marque d’ordre d’octet (BOM) UTF-8 est considérée comme un JSON non valide.</span><span class="sxs-lookup"><span data-stu-id="3b233-428">Since the `Utf8JsonReader` considers the input to be JSON text, a UTF-8 byte order mark (BOM) is considered invalid JSON.</span></span> <span data-ttu-id="3b233-429">L’appelant doit filtrer ce dernier avant de passer les données au lecteur.</span><span class="sxs-lookup"><span data-stu-id="3b233-429">The caller needs to filter that out before passing the data to the reader.</span></span>

<span data-ttu-id="3b233-430">Pour obtenir des exemples de code, consultez [use Utf8JsonReader](system-text-json-how-to.md#use-utf8jsonreader).</span><span class="sxs-lookup"><span data-stu-id="3b233-430">For code examples, see [Use Utf8JsonReader](system-text-json-how-to.md#use-utf8jsonreader).</span></span>

### <a name="read-with-multi-segment-readonlysequence"></a><span data-ttu-id="3b233-431">Lecture avec ReadOnlySequence à plusieurs segments</span><span class="sxs-lookup"><span data-stu-id="3b233-431">Read with multi-segment ReadOnlySequence</span></span>

<span data-ttu-id="3b233-432">Si votre entrée JSON est un [ReadOnlySpan\<octet >](xref:System.ReadOnlySpan%601), chaque élément JSON est accessible à partir de la propriété `ValueSpan` sur le lecteur à mesure que vous parcourez la boucle de lecture.</span><span class="sxs-lookup"><span data-stu-id="3b233-432">If your JSON input is a [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601), each JSON element can be accessed from the `ValueSpan` property on the reader as you go through the read loop.</span></span> <span data-ttu-id="3b233-433">Toutefois, si votre entrée est un [ReadOnlySequence\<byte >](xref:System.Buffers.ReadOnlySequence%601) (qui est le résultat de la lecture à partir d’un <xref:System.IO.Pipelines.PipeReader>), certains éléments JSON peuvent chevaucher plusieurs segments de l’objet `ReadOnlySequence<byte>`.</span><span class="sxs-lookup"><span data-stu-id="3b233-433">However, if your input is a [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601) (which is the result of reading from a <xref:System.IO.Pipelines.PipeReader>), some JSON elements might straddle multiple segments of the `ReadOnlySequence<byte>` object.</span></span> <span data-ttu-id="3b233-434">Ces éléments ne sont pas accessibles à partir de <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> dans un bloc de mémoire contigu.</span><span class="sxs-lookup"><span data-stu-id="3b233-434">These elements would not be accessible from <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> in a contiguous memory block.</span></span> <span data-ttu-id="3b233-435">Au lieu de cela, chaque fois que vous avez un `ReadOnlySequence<byte>` à plusieurs segments comme entrée, interrogez la propriété <xref:System.Text.Json.Utf8JsonReader.HasValueSequence%2A> sur le lecteur pour déterminer comment accéder à l’élément JSON actuel.</span><span class="sxs-lookup"><span data-stu-id="3b233-435">Instead, whenever you have a multi-segment `ReadOnlySequence<byte>` as input, poll the <xref:System.Text.Json.Utf8JsonReader.HasValueSequence%2A> property on the reader to figure out how to access the current JSON element.</span></span> <span data-ttu-id="3b233-436">Voici un modèle recommandé :</span><span class="sxs-lookup"><span data-stu-id="3b233-436">Here's a recommended pattern:</span></span>

```csharp
while (reader.Read())
{
    switch (reader.TokenType)
    {
        // ...
        ReadOnlySpan<byte> jsonElement = reader.HasValueSequence ?
            reader.ValueSequence.ToArray() :
            reader.ValueSpan;
        // ...
    }
}
```

### <a name="use-valuetextequals-for-property-name-lookups"></a><span data-ttu-id="3b233-437">Utiliser ValueTextEquals pour les recherches de nom de propriété</span><span class="sxs-lookup"><span data-stu-id="3b233-437">Use ValueTextEquals for property name lookups</span></span>

<span data-ttu-id="3b233-438">N’utilisez pas <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> pour effectuer des comparaisons octet par octet en appelant <xref:System.MemoryExtensions.SequenceEqual%2A> pour les recherches de nom de propriété.</span><span class="sxs-lookup"><span data-stu-id="3b233-438">Don't use <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> to do byte-by-byte comparisons by calling <xref:System.MemoryExtensions.SequenceEqual%2A> for property name lookups.</span></span> <span data-ttu-id="3b233-439">Appelez à la place <xref:System.Text.Json.Utf8JsonReader.ValueTextEquals%2A>, car cette méthode annule l’échappement des caractères échappés dans le JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-439">Call <xref:System.Text.Json.Utf8JsonReader.ValueTextEquals%2A> instead, because that method unescapes any characters that are escaped in the JSON.</span></span> <span data-ttu-id="3b233-440">Voici un exemple qui montre comment rechercher une propriété nommée « Name » :</span><span class="sxs-lookup"><span data-stu-id="3b233-440">Here's an example that shows how to search for a property that is named "name":</span></span>

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/ValueTextEqualsExample.cs?name=SnippetDefineUtf8Var)]

[!code-csharp[](~/samples/snippets/core/system-text-json/csharp/ValueTextEqualsExample.cs?name=SnippetUseUtf8Var&highlight=11)]

### <a name="read-null-values-into-nullable-value-types"></a><span data-ttu-id="3b233-441">Lire les valeurs NULL dans les types valeur Nullable</span><span class="sxs-lookup"><span data-stu-id="3b233-441">Read null values into nullable value types</span></span>

<span data-ttu-id="3b233-442">`Newtonsoft.Json` fournit des API qui retournent des <xref:System.Nullable%601>, telles que `ReadAsBoolean`, qui gère une `TokenType` `Null` pour vous en retournant un `bool?`.</span><span class="sxs-lookup"><span data-stu-id="3b233-442">`Newtonsoft.Json` provides APIs that return <xref:System.Nullable%601>, such as `ReadAsBoolean`, which handles a `Null` `TokenType` for you by returning a `bool?`.</span></span> <span data-ttu-id="3b233-443">Les API de `System.Text.Json` intégrées retournent uniquement des types valeur n’acceptant pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="3b233-443">The built-in `System.Text.Json` APIs return only non-nullable value types.</span></span> <span data-ttu-id="3b233-444">Par exemple, <xref:System.Text.Json.Utf8JsonReader.GetBoolean%2A?displayProperty=nameWithType> retourne une `bool`.</span><span class="sxs-lookup"><span data-stu-id="3b233-444">For example, <xref:System.Text.Json.Utf8JsonReader.GetBoolean%2A?displayProperty=nameWithType> returns a `bool`.</span></span> <span data-ttu-id="3b233-445">Elle lève une exception si elle trouve `Null` dans le JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-445">It throws an exception if it finds `Null` in the JSON.</span></span> <span data-ttu-id="3b233-446">Les exemples suivants illustrent deux façons de gérer les valeurs NULL, l’une en retournant un type valeur Nullable et l’autre en retournant la valeur par défaut :</span><span class="sxs-lookup"><span data-stu-id="3b233-446">The following examples show two ways to handle nulls, one by returning a nullable value type and one by returning the default value:</span></span>

```csharp
public bool? ReadAsNullableBoolean()
{
    _reader.Read();
    if (_reader.TokenType == JsonTokenType.Null)
    {
        return null;
    }
    if (_reader.TokenType != JsonTokenType.True && _reader.TokenType != JsonTokenType.False)
    {
        throw new JsonException();
    }
    return _reader.GetBoolean();
}
```

```csharp
public bool ReadAsBoolean(bool defaultValue)
{
    _reader.Read();
    if (_reader.TokenType == JsonTokenType.Null)
    {
        return defaultValue;
    }
    if (_reader.TokenType != JsonTokenType.True && _reader.TokenType != JsonTokenType.False)
    {
        throw new JsonException();
    }
    return _reader.GetBoolean();
}
```

### <a name="multi-targeting"></a><span data-ttu-id="3b233-447">Multi-ciblage</span><span class="sxs-lookup"><span data-stu-id="3b233-447">Multi-targeting</span></span>

<span data-ttu-id="3b233-448">Si vous devez continuer à utiliser `Newtonsoft.Json` pour certains frameworks cibles, vous pouvez effectuer plusieurs cibles et avoir deux implémentations.</span><span class="sxs-lookup"><span data-stu-id="3b233-448">If you need to continue to use `Newtonsoft.Json` for certain target frameworks, you can multi-target and have two implementations.</span></span> <span data-ttu-id="3b233-449">Toutefois, cette opération n’est pas évidente et nécessiterait des `#ifdefs` et une duplication source.</span><span class="sxs-lookup"><span data-stu-id="3b233-449">However, this is not trivial and would require some `#ifdefs` and source duplication.</span></span> <span data-ttu-id="3b233-450">Une façon de partager autant de code que possible consiste à créer un wrapper `ref struct` autour de `Utf8JsonReader` et `Newtonsoft.Json` `JsonTextReader`.</span><span class="sxs-lookup"><span data-stu-id="3b233-450">One way to share as much code as possible is to create a `ref struct` wrapper around `Utf8JsonReader` and `Newtonsoft.Json` `JsonTextReader`.</span></span> <span data-ttu-id="3b233-451">Ce wrapper unifie la surface d’exposition publique tout en isolant les différences de comportement.</span><span class="sxs-lookup"><span data-stu-id="3b233-451">This wrapper would unify the public surface area while isolating the behavioral differences.</span></span> <span data-ttu-id="3b233-452">Cela vous permet d’isoler les modifications principalement à la construction du type, ainsi que de passer le nouveau type par référence.</span><span class="sxs-lookup"><span data-stu-id="3b233-452">This lets you isolate the changes mainly to the construction of the type, along with passing the new type around by reference.</span></span> <span data-ttu-id="3b233-453">Il s’agit du modèle que la bibliothèque [Microsoft. extensions. DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) suit :</span><span class="sxs-lookup"><span data-stu-id="3b233-453">This is the pattern that the [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) library follows:</span></span>

* [<span data-ttu-id="3b233-454">UnifiedJsonReader.JsonTextReader.cs</span><span class="sxs-lookup"><span data-stu-id="3b233-454">UnifiedJsonReader.JsonTextReader.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonReader.JsonTextReader.cs)
* [<span data-ttu-id="3b233-455">UnifiedJsonReader.Utf8JsonReader.cs</span><span class="sxs-lookup"><span data-stu-id="3b233-455">UnifiedJsonReader.Utf8JsonReader.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonReader.Utf8JsonReader.cs)

## <a name="utf8jsonwriter-compared-to-jsontextwriter"></a><span data-ttu-id="3b233-456">Utf8JsonWriter comparé à JsonTextWriter</span><span class="sxs-lookup"><span data-stu-id="3b233-456">Utf8JsonWriter compared to JsonTextWriter</span></span>

<span data-ttu-id="3b233-457"><xref:System.Text.Json.Utf8JsonWriter?displayProperty=fullName> est une méthode très performante pour écrire du texte JSON encodé en UTF-8 à partir de types .NET courants comme `String`, `Int32`et `DateTime`.</span><span class="sxs-lookup"><span data-stu-id="3b233-457"><xref:System.Text.Json.Utf8JsonWriter?displayProperty=fullName> is a high-performance way to write UTF-8 encoded JSON text from common .NET types like `String`, `Int32`, and `DateTime`.</span></span> <span data-ttu-id="3b233-458">Le writer est un type de bas niveau qui peut être utilisé pour créer des sérialiseurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="3b233-458">The writer is a low-level type that can be used to build custom serializers.</span></span>

<span data-ttu-id="3b233-459">Les sections suivantes expliquent les modèles de programmation recommandés pour l’utilisation de `Utf8JsonWriter`.</span><span class="sxs-lookup"><span data-stu-id="3b233-459">The following sections explain recommended programming patterns for using `Utf8JsonWriter`.</span></span>

### <a name="write-with-utf-8-text"></a><span data-ttu-id="3b233-460">Écrire avec du texte UTF-8</span><span class="sxs-lookup"><span data-stu-id="3b233-460">Write with UTF-8 text</span></span>

<span data-ttu-id="3b233-461">Pour obtenir les meilleures performances possibles lors de l’utilisation de la `Utf8JsonWriter`, écrivez les charges utiles JSON déjà encodées en tant que texte UTF-8 plutôt qu’en tant que chaînes UTF-16.</span><span class="sxs-lookup"><span data-stu-id="3b233-461">To achieve the best possible performance while using the `Utf8JsonWriter`, write JSON payloads already encoded as UTF-8 text rather than as UTF-16 strings.</span></span> <span data-ttu-id="3b233-462">Utilisez <xref:System.Text.Json.JsonEncodedText> pour mettre en cache et précoder des noms et des valeurs de propriété de chaîne connus comme statiques, et les transmettre au writer, plutôt que d’utiliser des littéraux de chaîne UTF-16.</span><span class="sxs-lookup"><span data-stu-id="3b233-462">Use <xref:System.Text.Json.JsonEncodedText> to cache and pre-encode known string property names and values as statics, and pass those to the writer, rather than using UTF-16 string literals.</span></span> <span data-ttu-id="3b233-463">Cela est plus rapide que la mise en cache et l’utilisation des tableaux d’octets UTF-8.</span><span class="sxs-lookup"><span data-stu-id="3b233-463">This is faster than caching and using UTF-8 byte arrays.</span></span>

<span data-ttu-id="3b233-464">Cette approche fonctionne également si vous devez effectuer des séquences d’échappement personnalisées.</span><span class="sxs-lookup"><span data-stu-id="3b233-464">This approach also works if you need to do custom escaping.</span></span> <span data-ttu-id="3b233-465">`System.Text.Json` ne vous permet pas de désactiver l’échappement lors de l’écriture d’une chaîne.</span><span class="sxs-lookup"><span data-stu-id="3b233-465">`System.Text.Json` doesn't let you disable escaping while writing a string.</span></span> <span data-ttu-id="3b233-466">Toutefois, vous pouvez transmettre votre propre <xref:System.Text.Encodings.Web.JavaScriptEncoder> personnalisé en tant qu’option au writer, ou créer votre propre `JsonEncodedText` qui utilise votre `JavascriptEncoder` pour effectuer l’échappement, puis écrire le `JsonEncodedText` à la place de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="3b233-466">However, you could pass in your own custom <xref:System.Text.Encodings.Web.JavaScriptEncoder> as an option to the writer, or create your own `JsonEncodedText` that uses your `JavascriptEncoder` to do the escaping, and then write the `JsonEncodedText` instead of the string.</span></span> <span data-ttu-id="3b233-467">Pour plus d’informations, consultez [personnaliser l’encodage des caractères](system-text-json-how-to.md#customize-character-encoding).</span><span class="sxs-lookup"><span data-stu-id="3b233-467">For more information, see [Customize character encoding](system-text-json-how-to.md#customize-character-encoding).</span></span>

### <a name="write-raw-values"></a><span data-ttu-id="3b233-468">Écrire des valeurs brutes</span><span class="sxs-lookup"><span data-stu-id="3b233-468">Write raw values</span></span>

<span data-ttu-id="3b233-469">La méthode `Newtonsoft.Json` `WriteRawValue` écrit un JSON brut dans lequel une valeur est attendue.</span><span class="sxs-lookup"><span data-stu-id="3b233-469">The `Newtonsoft.Json` `WriteRawValue` method writes raw JSON where a value is expected.</span></span> <span data-ttu-id="3b233-470"><xref:System.Text.Json> n’a pas d’équivalent direct, mais voici une solution de contournement qui garantit que seul le JSON valide est écrit :</span><span class="sxs-lookup"><span data-stu-id="3b233-470"><xref:System.Text.Json> has no direct equivalent, but here's a workaround that ensures only valid JSON is written:</span></span>

```csharp
using JsonDocument doc = JsonDocument.Parse(string);
doc.WriteTo(writer);
```

### <a name="customize-character-escaping"></a><span data-ttu-id="3b233-471">Personnaliser l’échappement des caractères</span><span class="sxs-lookup"><span data-stu-id="3b233-471">Customize character escaping</span></span>

<span data-ttu-id="3b233-472">Le paramètre [StringEscapeHandling](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_StringEscapeHandling.htm) de `JsonTextWriter` offre des options permettant d’échapper tous les caractères non-ASCII **ou** les caractères HTML.</span><span class="sxs-lookup"><span data-stu-id="3b233-472">The [StringEscapeHandling](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_StringEscapeHandling.htm) setting of `JsonTextWriter` offers options to escape all non-ASCII characters **or** HTML characters.</span></span> <span data-ttu-id="3b233-473">Par défaut, `Utf8JsonWriter` place dans une séquence d’échappement tous les caractères non-ASCII **et** html.</span><span class="sxs-lookup"><span data-stu-id="3b233-473">By default, `Utf8JsonWriter` escapes all non-ASCII **and** HTML characters.</span></span> <span data-ttu-id="3b233-474">Cette séquence d’échappement est effectuée pour des raisons de sécurité de défense en profondeur.</span><span class="sxs-lookup"><span data-stu-id="3b233-474">This escaping is done for defense-in-depth security reasons.</span></span> <span data-ttu-id="3b233-475">Pour spécifier une autre stratégie d’échappement, créez un <xref:System.Text.Encodings.Web.JavaScriptEncoder> et définissez <xref:System.Text.Json.JsonWriterOptions.Encoder?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3b233-475">To specify a different escaping policy, create a <xref:System.Text.Encodings.Web.JavaScriptEncoder> and set <xref:System.Text.Json.JsonWriterOptions.Encoder?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3b233-476">Pour plus d’informations, consultez [personnaliser l’encodage des caractères](system-text-json-how-to.md#customize-character-encoding).</span><span class="sxs-lookup"><span data-stu-id="3b233-476">For more information, see [Customize character encoding](system-text-json-how-to.md#customize-character-encoding).</span></span>

### <a name="customize-json-format"></a><span data-ttu-id="3b233-477">Personnaliser le format JSON</span><span class="sxs-lookup"><span data-stu-id="3b233-477">Customize JSON format</span></span>

<span data-ttu-id="3b233-478">`JsonTextWriter` inclut les paramètres suivants, pour lesquels `Utf8JsonWriter` n’a pas d’équivalent :</span><span class="sxs-lookup"><span data-stu-id="3b233-478">`JsonTextWriter` includes the following settings, for which `Utf8JsonWriter` has no equivalent:</span></span>

* <span data-ttu-id="3b233-479">[Mise en retrait](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_Indentation.htm) : spécifie le nombre de caractères à mettre en retrait.</span><span class="sxs-lookup"><span data-stu-id="3b233-479">[Indentation](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_Indentation.htm) - Specifies how many characters to indent.</span></span> <span data-ttu-id="3b233-480">`Utf8JsonWriter` effectue toujours une mise en retrait de 2 caractères.</span><span class="sxs-lookup"><span data-stu-id="3b233-480">`Utf8JsonWriter` always does 2-character indentation.</span></span>
* <span data-ttu-id="3b233-481">[IndentChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_IndentChar.htm) : spécifie le caractère à utiliser pour la mise en retrait.</span><span class="sxs-lookup"><span data-stu-id="3b233-481">[IndentChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_IndentChar.htm) - Specifies the character to use for indentation.</span></span>  <span data-ttu-id="3b233-482">`Utf8JsonWriter` utilise toujours l’espace blanc.</span><span class="sxs-lookup"><span data-stu-id="3b233-482">`Utf8JsonWriter` always uses whitespace.</span></span>
* <span data-ttu-id="3b233-483">[QuoteChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteChar.htm) : spécifie le caractère à utiliser pour entourer les valeurs de chaîne.</span><span class="sxs-lookup"><span data-stu-id="3b233-483">[QuoteChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteChar.htm) - Specifies the character to use to surround string values.</span></span>  <span data-ttu-id="3b233-484">`Utf8JsonWriter` utilise toujours des guillemets doubles.</span><span class="sxs-lookup"><span data-stu-id="3b233-484">`Utf8JsonWriter` always uses double quotes.</span></span>
* <span data-ttu-id="3b233-485">[QUOTENAME](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteName.htm) : spécifie si les noms de propriété doivent être placés entre guillemets.</span><span class="sxs-lookup"><span data-stu-id="3b233-485">[QuoteName](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteName.htm) - Specifies whether or not to surround property names with quotes.</span></span>  <span data-ttu-id="3b233-486">`Utf8JsonWriter` les entoure toujours de guillemets.</span><span class="sxs-lookup"><span data-stu-id="3b233-486">`Utf8JsonWriter` always surrounds them with quotes.</span></span>

<span data-ttu-id="3b233-487">Il n’existe aucune solution de contournement qui vous permettrait de personnaliser le JSON généré par `Utf8JsonWriter` de la façon suivante.</span><span class="sxs-lookup"><span data-stu-id="3b233-487">There are no workarounds that would let you customize the JSON produced by `Utf8JsonWriter` in these ways.</span></span>

### <a name="write-null-values"></a><span data-ttu-id="3b233-488">Écrire des valeurs null</span><span class="sxs-lookup"><span data-stu-id="3b233-488">Write null values</span></span>

<span data-ttu-id="3b233-489">Pour écrire des valeurs NULL à l’aide de `Utf8JsonWriter`, appelez :</span><span class="sxs-lookup"><span data-stu-id="3b233-489">To write null values by using `Utf8JsonWriter`, call:</span></span>

* <span data-ttu-id="3b233-490"><xref:System.Text.Json.Utf8JsonWriter.WriteNull%2A> d’écrire une paire clé-valeur avec une valeur NULL comme valeur.</span><span class="sxs-lookup"><span data-stu-id="3b233-490"><xref:System.Text.Json.Utf8JsonWriter.WriteNull%2A> to write a key-value pair with null as the value.</span></span>
* <span data-ttu-id="3b233-491"><xref:System.Text.Json.Utf8JsonWriter.WriteNullValue%2A> d’écrire la valeur null en tant qu’élément d’un tableau JSON.</span><span class="sxs-lookup"><span data-stu-id="3b233-491"><xref:System.Text.Json.Utf8JsonWriter.WriteNullValue%2A> to write null as an element of a JSON array.</span></span>

<span data-ttu-id="3b233-492">Pour une propriété de type chaîne, si la chaîne est null, <xref:System.Text.Json.Utf8JsonWriter.WriteString%2A> et <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A> sont équivalents à `WriteNull` et `WriteNullValue`.</span><span class="sxs-lookup"><span data-stu-id="3b233-492">For a string property, if the string is null, <xref:System.Text.Json.Utf8JsonWriter.WriteString%2A> and <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A> are equivalent to `WriteNull` and `WriteNullValue`.</span></span>

### <a name="write-timespan-uri-or-char-values"></a><span data-ttu-id="3b233-493">Écrire les valeurs TimeSpan, Uri ou char</span><span class="sxs-lookup"><span data-stu-id="3b233-493">Write Timespan, Uri, or char values</span></span>

<span data-ttu-id="3b233-494">`JsonTextWriter` fournit `WriteValue` méthodes pour les valeurs [TimeSpan](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_18.htm), [URI](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_22.htm)et [char](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_3.htm) .</span><span class="sxs-lookup"><span data-stu-id="3b233-494">`JsonTextWriter` provides `WriteValue` methods for [TimeSpan](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_18.htm), [Uri](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_22.htm), and [char](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_3.htm) values.</span></span> <span data-ttu-id="3b233-495">`Utf8JsonWriter` n’a pas de méthode équivalente.</span><span class="sxs-lookup"><span data-stu-id="3b233-495">`Utf8JsonWriter` doesn't have equivalent methods.</span></span> <span data-ttu-id="3b233-496">Au lieu de cela, mettez en forme ces valeurs en tant que chaînes (en appelant `ToString()`, par exemple) et appelez <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A>.</span><span class="sxs-lookup"><span data-stu-id="3b233-496">Instead, format these values as strings (by calling `ToString()`, for example) and call <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A>.</span></span>

### <a name="multi-targeting"></a><span data-ttu-id="3b233-497">Multi-ciblage</span><span class="sxs-lookup"><span data-stu-id="3b233-497">Multi-targeting</span></span>

<span data-ttu-id="3b233-498">Si vous devez continuer à utiliser `Newtonsoft.Json` pour certains frameworks cibles, vous pouvez effectuer plusieurs cibles et avoir deux implémentations.</span><span class="sxs-lookup"><span data-stu-id="3b233-498">If you need to continue to use `Newtonsoft.Json` for certain target frameworks, you can multi-target and have two implementations.</span></span> <span data-ttu-id="3b233-499">Toutefois, cette opération n’est pas évidente et nécessiterait des `#ifdefs` et une duplication source.</span><span class="sxs-lookup"><span data-stu-id="3b233-499">However, this is not trivial and would require some `#ifdefs` and source duplication.</span></span> <span data-ttu-id="3b233-500">Une façon de partager autant de code que possible consiste à créer un wrapper autour de `Utf8JsonWriter` et `Newtonsoft` `JsonTextWriter`.</span><span class="sxs-lookup"><span data-stu-id="3b233-500">One way to share as much code as possible is to create a wrapper around `Utf8JsonWriter` and `Newtonsoft` `JsonTextWriter`.</span></span> <span data-ttu-id="3b233-501">Ce wrapper unifie la surface d’exposition publique tout en isolant les différences de comportement.</span><span class="sxs-lookup"><span data-stu-id="3b233-501">This wrapper would unify the public surface area while isolating the behavioral differences.</span></span> <span data-ttu-id="3b233-502">Cela vous permet d’isoler les modifications principalement de la construction du type.</span><span class="sxs-lookup"><span data-stu-id="3b233-502">This lets you isolate the changes mainly to the construction of the type.</span></span> <span data-ttu-id="3b233-503">La bibliothèque [Microsoft. extensions. DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) est la suivante :</span><span class="sxs-lookup"><span data-stu-id="3b233-503">[Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) library follows:</span></span>

* [<span data-ttu-id="3b233-504">UnifiedJsonWriter.JsonTextWriter.cs</span><span class="sxs-lookup"><span data-stu-id="3b233-504">UnifiedJsonWriter.JsonTextWriter.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonWriter.JsonTextWriter.cs)
* [<span data-ttu-id="3b233-505">UnifiedJsonWriter.Utf8JsonWriter.cs</span><span class="sxs-lookup"><span data-stu-id="3b233-505">UnifiedJsonWriter.Utf8JsonWriter.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonWriter.Utf8JsonWriter.cs)

## <a name="additional-resources"></a><span data-ttu-id="3b233-506">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="3b233-506">Additional resources</span></span>

<!-- * [System.Text.Json roadmap](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/roadmap/README.md)[Restore this when the roadmap is updated.]-->
* [<span data-ttu-id="3b233-507">Vue d’ensemble de System. Text. JSON</span><span class="sxs-lookup"><span data-stu-id="3b233-507">System.Text.Json overview</span></span>](system-text-json-overview.md)
* [<span data-ttu-id="3b233-508">Utilisation de System. Text. JSON</span><span class="sxs-lookup"><span data-stu-id="3b233-508">How to use System.Text.Json</span></span>](system-text-json-how-to.md)
* [<span data-ttu-id="3b233-509">Comment écrire des convertisseurs personnalisés</span><span class="sxs-lookup"><span data-stu-id="3b233-509">How to write custom converters</span></span>](system-text-json-converters-how-to.md)
* [<span data-ttu-id="3b233-510">Prise en charge des valeurs DateTime et DateTimeOffset dans System. Text. JSON</span><span class="sxs-lookup"><span data-stu-id="3b233-510">DateTime and DateTimeOffset support in System.Text.Json</span></span>](../datetime/system-text-json-support.md)
* [<span data-ttu-id="3b233-511">Informations de référence sur l’API System. Text. JSON</span><span class="sxs-lookup"><span data-stu-id="3b233-511">System.Text.Json API reference</span></span>](xref:System.Text.Json)
* [<span data-ttu-id="3b233-512">Informations de référence sur l’API System. Text. JSON. Serialization</span><span class="sxs-lookup"><span data-stu-id="3b233-512">System.Text.Json.Serialization API reference</span></span>](xref:System.Text.Json.Serialization)
