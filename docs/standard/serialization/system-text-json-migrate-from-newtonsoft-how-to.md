---
title: Migrer de Newtonsoft.Json vers System.Text.Json -.net
author: tdykstra
ms.author: tdykstra
no-loc:
- System.Text.Json
- Newtonsoft.Json
ms.date: 01/10/2020
helpviewer_keywords:
- JSON serialization
- serializing objects
- serialization
- objects, serializing
ms.openlocfilehash: 11de13a6674411bbad52678b59879ed26366e0f1
ms.sourcegitcommit: 9c45035b781caebc63ec8ecf912dc83fb6723b1f
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/25/2020
ms.locfileid: "88811052"
---
# <a name="how-to-migrate-from-no-locnewtonsoftjson-to-no-locsystemtextjson"></a><span data-ttu-id="d5796-102">Comment migrer de Newtonsoft.Json vers System.Text.Json</span><span class="sxs-lookup"><span data-stu-id="d5796-102">How to migrate from Newtonsoft.Json to System.Text.Json</span></span>

<span data-ttu-id="d5796-103">Cet article explique comment migrer de [Newtonsoft.Json](https://www.newtonsoft.com/json) vers <xref:System.Text.Json> .</span><span class="sxs-lookup"><span data-stu-id="d5796-103">This article shows how to migrate from [Newtonsoft.Json](https://www.newtonsoft.com/json) to <xref:System.Text.Json>.</span></span>

<span data-ttu-id="d5796-104">L' `System.Text.Json` espace de noms fournit des fonctionnalités pour sérialiser vers et désérialiser à partir de JavaScript Object Notation (JSON).</span><span class="sxs-lookup"><span data-stu-id="d5796-104">The `System.Text.Json` namespace provides functionality for serializing to and deserializing from JavaScript Object Notation (JSON).</span></span> <span data-ttu-id="d5796-105">La `System.Text.Json` bibliothèque est incluse dans l’infrastructure partagée [.net Core 3,0](https://aka.ms/netcore3download) .</span><span class="sxs-lookup"><span data-stu-id="d5796-105">The `System.Text.Json` library is included in the [.NET Core 3.0](https://aka.ms/netcore3download) shared framework.</span></span> <span data-ttu-id="d5796-106">Pour les autres frameworks cibles, installez le [System.Text.Json](https://www.nuget.org/packages/System.Text.Json) package NuGet.</span><span class="sxs-lookup"><span data-stu-id="d5796-106">For other target frameworks, install the [System.Text.Json](https://www.nuget.org/packages/System.Text.Json) NuGet package.</span></span> <span data-ttu-id="d5796-107">Le package prend en charge :</span><span class="sxs-lookup"><span data-stu-id="d5796-107">The package supports:</span></span>

* <span data-ttu-id="d5796-108">.NET Standard 2,0 et versions ultérieures</span><span class="sxs-lookup"><span data-stu-id="d5796-108">.NET Standard 2.0 and later versions</span></span>
* <span data-ttu-id="d5796-109">.NET Framework 4.7.2 et versions ultérieures</span><span class="sxs-lookup"><span data-stu-id="d5796-109">.NET Framework 4.7.2 and later versions</span></span>
* <span data-ttu-id="d5796-110">.NET Core 2,0, 2,1 et 2,2</span><span class="sxs-lookup"><span data-stu-id="d5796-110">.NET Core 2.0, 2.1, and 2.2</span></span>

<span data-ttu-id="d5796-111">`System.Text.Json` se concentre principalement sur les performances, la sécurité et la conformité aux normes.</span><span class="sxs-lookup"><span data-stu-id="d5796-111">`System.Text.Json` focuses primarily on performance, security, and standards compliance.</span></span> <span data-ttu-id="d5796-112">Il présente certaines différences clés dans le comportement par défaut et n’a pas pour but d’avoir une parité des fonctionnalités avec `Newtonsoft.Json` .</span><span class="sxs-lookup"><span data-stu-id="d5796-112">It has some key differences in default behavior and doesn't aim to have feature parity with `Newtonsoft.Json`.</span></span> <span data-ttu-id="d5796-113">Pour certains scénarios, `System.Text.Json` ne dispose pas de fonctionnalités intégrées, mais il existe des solutions de contournement recommandées.</span><span class="sxs-lookup"><span data-stu-id="d5796-113">For some scenarios, `System.Text.Json` has no built-in functionality, but there are recommended workarounds.</span></span> <span data-ttu-id="d5796-114">Pour les autres scénarios, les solutions de contournement ne sont pas pratiques.</span><span class="sxs-lookup"><span data-stu-id="d5796-114">For other scenarios, workarounds are impractical.</span></span> <span data-ttu-id="d5796-115">Si votre application dépend d’une fonctionnalité manquante, envisagez de signaler [un problème](https://github.com/dotnet/runtime/issues/new) pour déterminer si la prise en charge de votre scénario peut être ajoutée.</span><span class="sxs-lookup"><span data-stu-id="d5796-115">If your application depends on a missing feature, consider [filing an issue](https://github.com/dotnet/runtime/issues/new) to find out if support for your scenario can be added.</span></span>

<!-- For information about which features might be added in future releases, see the [Roadmap](https://github.com/dotnet/runtime/tree/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/roadmap/README.md). [Restore this when the roadmap is updated.]-->

<span data-ttu-id="d5796-116">La majeure partie de cet article concerne l’utilisation de l' <xref:System.Text.Json.JsonSerializer> API, mais elle fournit également des conseils sur l’utilisation de <xref:System.Text.Json.JsonDocument> (qui représente les types Document Object Model ou DOM), <xref:System.Text.Json.Utf8JsonReader> et <xref:System.Text.Json.Utf8JsonWriter> .</span><span class="sxs-lookup"><span data-stu-id="d5796-116">Most of this article is about how to use the <xref:System.Text.Json.JsonSerializer> API, but it also includes guidance on how to use the <xref:System.Text.Json.JsonDocument> (which represents the Document Object Model or DOM), <xref:System.Text.Json.Utf8JsonReader>, and <xref:System.Text.Json.Utf8JsonWriter> types.</span></span>

## <a name="table-of-differences-between-no-locnewtonsoftjson-and-no-locsystemtextjson"></a><span data-ttu-id="d5796-117">Tableau des différences entre Newtonsoft.Json et System.Text.Json</span><span class="sxs-lookup"><span data-stu-id="d5796-117">Table of differences between Newtonsoft.Json and System.Text.Json</span></span>

<span data-ttu-id="d5796-118">Le tableau suivant répertorie les `Newtonsoft.Json` fonctionnalités et les `System.Text.Json` équivalents.</span><span class="sxs-lookup"><span data-stu-id="d5796-118">The following table lists `Newtonsoft.Json` features and `System.Text.Json` equivalents.</span></span> <span data-ttu-id="d5796-119">Les équivalents sont classés dans les catégories suivantes :</span><span class="sxs-lookup"><span data-stu-id="d5796-119">The equivalents fall into the following categories:</span></span>

* <span data-ttu-id="d5796-120">Pris en charge par les fonctionnalités intégrées.</span><span class="sxs-lookup"><span data-stu-id="d5796-120">Supported by built-in functionality.</span></span> <span data-ttu-id="d5796-121">L’obtention d’un comportement similaire de `System.Text.Json` peut nécessiter l’utilisation d’un attribut ou d’une option globale.</span><span class="sxs-lookup"><span data-stu-id="d5796-121">Getting similar behavior from `System.Text.Json` may require the use of an attribute or global option.</span></span>
* <span data-ttu-id="d5796-122">Non pris en charge, une solution de contournement est possible.</span><span class="sxs-lookup"><span data-stu-id="d5796-122">Not supported, workaround is possible.</span></span> <span data-ttu-id="d5796-123">Les solutions de contournement sont des [convertisseurs personnalisés](system-text-json-converters-how-to.md), qui peuvent ne pas fournir une parité complète avec les `Newtonsoft.Json` fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="d5796-123">The workarounds are [custom converters](system-text-json-converters-how-to.md), which may not provide complete parity with `Newtonsoft.Json` functionality.</span></span> <span data-ttu-id="d5796-124">Pour certains d’entre eux, un exemple de code est fourni comme exemples.</span><span class="sxs-lookup"><span data-stu-id="d5796-124">For some of these, sample code is provided as examples.</span></span> <span data-ttu-id="d5796-125">Si vous utilisez ces `Newtonsoft.Json` fonctionnalités, la migration nécessitera des modifications de vos modèles d’objet .net ou d’autres modifications de code.</span><span class="sxs-lookup"><span data-stu-id="d5796-125">If you rely on these `Newtonsoft.Json` features, migration will require modifications to your .NET object models or other code changes.</span></span>
* <span data-ttu-id="d5796-126">Non pris en charge, la solution de contournement n’est pas pratique ou possible.</span><span class="sxs-lookup"><span data-stu-id="d5796-126">Not supported, workaround is not practical or possible.</span></span> <span data-ttu-id="d5796-127">Si vous utilisez ces `Newtonsoft.Json` fonctionnalités, la migration n’est pas possible sans modification significative.</span><span class="sxs-lookup"><span data-stu-id="d5796-127">If you rely on these `Newtonsoft.Json` features, migration will not be possible without significant changes.</span></span>

| <span data-ttu-id="d5796-128">Fonctionnalité Newtonsoft.Json</span><span class="sxs-lookup"><span data-stu-id="d5796-128">Newtonsoft.Json feature</span></span>                               | <span data-ttu-id="d5796-129">System.Text.Json identique</span><span class="sxs-lookup"><span data-stu-id="d5796-129">System.Text.Json equivalent</span></span> |
|-------------------------------------------------------|-----------------------------|
| <span data-ttu-id="d5796-130">Désérialisation non sensible à la casse par défaut</span><span class="sxs-lookup"><span data-stu-id="d5796-130">Case-insensitive deserialization by default</span></span>           | <span data-ttu-id="d5796-131">✔️ [paramètre global PropertyNameCaseInsensitive](#case-insensitive-deserialization)</span><span class="sxs-lookup"><span data-stu-id="d5796-131">✔️ [PropertyNameCaseInsensitive global setting](#case-insensitive-deserialization)</span></span> |
| <span data-ttu-id="d5796-132">Noms des propriétés de casse mixte</span><span class="sxs-lookup"><span data-stu-id="d5796-132">Camel-case property names</span></span>                             | <span data-ttu-id="d5796-133">✔️ [paramètre global PropertyNamingPolicy](system-text-json-how-to.md#use-camel-case-for-all-json-property-names)</span><span class="sxs-lookup"><span data-stu-id="d5796-133">✔️ [PropertyNamingPolicy global setting](system-text-json-how-to.md#use-camel-case-for-all-json-property-names)</span></span> |
| <span data-ttu-id="d5796-134">Échappement de caractères minimal</span><span class="sxs-lookup"><span data-stu-id="d5796-134">Minimal character escaping</span></span>                            | <span data-ttu-id="d5796-135">✔️ [caractère strict de la séquence d’échappement, configurable](#minimal-character-escaping)</span><span class="sxs-lookup"><span data-stu-id="d5796-135">✔️ [Strict character escaping, configurable](#minimal-character-escaping)</span></span> |
| <span data-ttu-id="d5796-136">`NullValueHandling.Ignore` paramètre global</span><span class="sxs-lookup"><span data-stu-id="d5796-136">`NullValueHandling.Ignore` global setting</span></span>             | <span data-ttu-id="d5796-137">[option globale ✔️ IgnoreNullValues](system-text-json-how-to.md#exclude-all-null-value-properties)</span><span class="sxs-lookup"><span data-stu-id="d5796-137">✔️ [IgnoreNullValues global option](system-text-json-how-to.md#exclude-all-null-value-properties)</span></span> |
| <span data-ttu-id="d5796-138">Autoriser les commentaires</span><span class="sxs-lookup"><span data-stu-id="d5796-138">Allow comments</span></span>                                        | <span data-ttu-id="d5796-139">✔️ [paramètre global ReadCommentHandling](#comments)</span><span class="sxs-lookup"><span data-stu-id="d5796-139">✔️ [ReadCommentHandling global setting](#comments)</span></span> |
| <span data-ttu-id="d5796-140">Autoriser les virgules de fin</span><span class="sxs-lookup"><span data-stu-id="d5796-140">Allow trailing commas</span></span>                                 | <span data-ttu-id="d5796-141">✔️ [paramètre global AllowTrailingCommas](#trailing-commas)</span><span class="sxs-lookup"><span data-stu-id="d5796-141">✔️ [AllowTrailingCommas global setting](#trailing-commas)</span></span> |
| <span data-ttu-id="d5796-142">Inscription de convertisseur personnalisé</span><span class="sxs-lookup"><span data-stu-id="d5796-142">Custom converter registration</span></span>                         | <span data-ttu-id="d5796-143">✔️ [ordre de priorité différent](#converter-registration-precedence)</span><span class="sxs-lookup"><span data-stu-id="d5796-143">✔️ [Order of precedence differs](#converter-registration-precedence)</span></span> |
| <span data-ttu-id="d5796-144">Aucune profondeur maximale par défaut</span><span class="sxs-lookup"><span data-stu-id="d5796-144">No maximum depth by default</span></span>                           | <span data-ttu-id="d5796-145">✔️ [profondeur maximale par défaut 64, configurable](#maximum-depth)</span><span class="sxs-lookup"><span data-stu-id="d5796-145">✔️ [Default maximum depth 64, configurable](#maximum-depth)</span></span> |
| <span data-ttu-id="d5796-146">Prise en charge d’un large éventail de types</span><span class="sxs-lookup"><span data-stu-id="d5796-146">Support for a broad range of types</span></span>                    | <span data-ttu-id="d5796-147">⚠️[Certains types nécessitent des convertisseurs personnalisés](#types-without-built-in-support)</span><span class="sxs-lookup"><span data-stu-id="d5796-147">⚠️ [Some types require custom converters](#types-without-built-in-support)</span></span> |
| <span data-ttu-id="d5796-148">Désérialiser des chaînes sous forme de nombres</span><span class="sxs-lookup"><span data-stu-id="d5796-148">Deserialize strings as numbers</span></span>                        | <span data-ttu-id="d5796-149">⚠️[Non pris en charge, solution de contournement, exemple](#quoted-numbers)</span><span class="sxs-lookup"><span data-stu-id="d5796-149">⚠️ [Not supported, workaround, sample](#quoted-numbers)</span></span> |
| <span data-ttu-id="d5796-150">Désérialiser `Dictionary` avec une clé qui n’est pas une chaîne</span><span class="sxs-lookup"><span data-stu-id="d5796-150">Deserialize `Dictionary` with non-string key</span></span>          | <span data-ttu-id="d5796-151">⚠️[Non pris en charge, solution de contournement, exemple](#dictionary-with-non-string-key)</span><span class="sxs-lookup"><span data-stu-id="d5796-151">⚠️ [Not supported, workaround, sample](#dictionary-with-non-string-key)</span></span> |
| <span data-ttu-id="d5796-152">Sérialisation polymorphe</span><span class="sxs-lookup"><span data-stu-id="d5796-152">Polymorphic serialization</span></span>                             | <span data-ttu-id="d5796-153">⚠️[Non pris en charge, solution de contournement, exemple](#polymorphic-serialization)</span><span class="sxs-lookup"><span data-stu-id="d5796-153">⚠️ [Not supported, workaround, sample](#polymorphic-serialization)</span></span> |
| <span data-ttu-id="d5796-154">Désérialisation polymorphe</span><span class="sxs-lookup"><span data-stu-id="d5796-154">Polymorphic deserialization</span></span>                           | <span data-ttu-id="d5796-155">⚠️[Non pris en charge, solution de contournement, exemple](#polymorphic-deserialization)</span><span class="sxs-lookup"><span data-stu-id="d5796-155">⚠️ [Not supported, workaround, sample](#polymorphic-deserialization)</span></span> |
| <span data-ttu-id="d5796-156">Désérialiser le type inféré en `object` Propriétés</span><span class="sxs-lookup"><span data-stu-id="d5796-156">Deserialize inferred type to `object` properties</span></span>      | <span data-ttu-id="d5796-157">⚠️[Non pris en charge, solution de contournement, exemple](#deserialization-of-object-properties)</span><span class="sxs-lookup"><span data-stu-id="d5796-157">⚠️ [Not supported, workaround, sample](#deserialization-of-object-properties)</span></span> |
| <span data-ttu-id="d5796-158">Désérialiser le `null` LITTÉRAL JSON en types valeur non Nullable</span><span class="sxs-lookup"><span data-stu-id="d5796-158">Deserialize JSON `null` literal to non-nullable value types</span></span> | <span data-ttu-id="d5796-159">⚠️[Non pris en charge, solution de contournement, exemple](#deserialize-null-to-non-nullable-type)</span><span class="sxs-lookup"><span data-stu-id="d5796-159">⚠️ [Not supported, workaround, sample](#deserialize-null-to-non-nullable-type)</span></span> |
| <span data-ttu-id="d5796-160">Désérialiser en classes et structs immuables</span><span class="sxs-lookup"><span data-stu-id="d5796-160">Deserialize to immutable classes and structs</span></span>          | <span data-ttu-id="d5796-161">⚠️[Non pris en charge, solution de contournement, exemple](#deserialize-to-immutable-classes-and-structs)</span><span class="sxs-lookup"><span data-stu-id="d5796-161">⚠️ [Not supported, workaround, sample](#deserialize-to-immutable-classes-and-structs)</span></span> |
| <span data-ttu-id="d5796-162">Attribut `[JsonConstructor]`</span><span class="sxs-lookup"><span data-stu-id="d5796-162">`[JsonConstructor]` attribute</span></span>                         | <span data-ttu-id="d5796-163">⚠️[Non pris en charge, solution de contournement, exemple](#specify-constructor-to-use)</span><span class="sxs-lookup"><span data-stu-id="d5796-163">⚠️ [Not supported, workaround, sample](#specify-constructor-to-use)</span></span> |
| <span data-ttu-id="d5796-164">`Required` définir sur l' `[JsonProperty]` attribut</span><span class="sxs-lookup"><span data-stu-id="d5796-164">`Required` setting on `[JsonProperty]` attribute</span></span>        | <span data-ttu-id="d5796-165">⚠️[Non pris en charge, solution de contournement, exemple](#required-properties)</span><span class="sxs-lookup"><span data-stu-id="d5796-165">⚠️ [Not supported, workaround, sample](#required-properties)</span></span> |
| <span data-ttu-id="d5796-166">`NullValueHandling` définir sur l' `[JsonProperty]` attribut</span><span class="sxs-lookup"><span data-stu-id="d5796-166">`NullValueHandling` setting on `[JsonProperty]` attribute</span></span> | <span data-ttu-id="d5796-167">⚠️[Non pris en charge, solution de contournement, exemple](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="d5796-167">⚠️ [Not supported, workaround, sample](#conditionally-ignore-a-property)</span></span>  |
| <span data-ttu-id="d5796-168">`DefaultValueHandling` définir sur l' `[JsonProperty]` attribut</span><span class="sxs-lookup"><span data-stu-id="d5796-168">`DefaultValueHandling` setting on `[JsonProperty]` attribute</span></span> | <span data-ttu-id="d5796-169">⚠️[Non pris en charge, solution de contournement, exemple](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="d5796-169">⚠️ [Not supported, workaround, sample](#conditionally-ignore-a-property)</span></span>  |
| <span data-ttu-id="d5796-170">`DefaultValueHandling` paramètre global</span><span class="sxs-lookup"><span data-stu-id="d5796-170">`DefaultValueHandling` global setting</span></span>                 | <span data-ttu-id="d5796-171">⚠️[Non pris en charge, solution de contournement, exemple](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="d5796-171">⚠️ [Not supported, workaround, sample](#conditionally-ignore-a-property)</span></span> |
| <span data-ttu-id="d5796-172">`DefaultContractResolver` pour exclure des propriétés</span><span class="sxs-lookup"><span data-stu-id="d5796-172">`DefaultContractResolver` to exclude properties</span></span>       | <span data-ttu-id="d5796-173">⚠️[Non pris en charge, solution de contournement, exemple](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="d5796-173">⚠️ [Not supported, workaround, sample](#conditionally-ignore-a-property)</span></span> |
| <span data-ttu-id="d5796-174">`DateTimeZoneHandling`, `DateFormatString` paramètres</span><span class="sxs-lookup"><span data-stu-id="d5796-174">`DateTimeZoneHandling`, `DateFormatString` settings</span></span>   | <span data-ttu-id="d5796-175">⚠️[Non pris en charge, solution de contournement, exemple](#specify-date-format)</span><span class="sxs-lookup"><span data-stu-id="d5796-175">⚠️ [Not supported, workaround, sample](#specify-date-format)</span></span> |
| <span data-ttu-id="d5796-176">Rappels</span><span class="sxs-lookup"><span data-stu-id="d5796-176">Callbacks</span></span>                                             | <span data-ttu-id="d5796-177">⚠️[Non pris en charge, solution de contournement, exemple](#callbacks)</span><span class="sxs-lookup"><span data-stu-id="d5796-177">⚠️ [Not supported, workaround, sample](#callbacks)</span></span> |
| <span data-ttu-id="d5796-178">Prise en charge des champs publics et non publics</span><span class="sxs-lookup"><span data-stu-id="d5796-178">Support for public and non-public fields</span></span>              | <span data-ttu-id="d5796-179">⚠️[Non pris en charge, solution de contournement](#public-and-non-public-fields)</span><span class="sxs-lookup"><span data-stu-id="d5796-179">⚠️ [Not supported, workaround](#public-and-non-public-fields)</span></span> |
| <span data-ttu-id="d5796-180">Prise en charge des accesseurs set et des accesseurs get de propriété internes et privées</span><span class="sxs-lookup"><span data-stu-id="d5796-180">Support for internal and private property setters and getters</span></span> | <span data-ttu-id="d5796-181">⚠️[Non pris en charge, solution de contournement](#internal-and-private-property-setters-and-getters)</span><span class="sxs-lookup"><span data-stu-id="d5796-181">⚠️ [Not supported, workaround](#internal-and-private-property-setters-and-getters)</span></span> |
| <span data-ttu-id="d5796-182">Méthode `JsonConvert.PopulateObject`</span><span class="sxs-lookup"><span data-stu-id="d5796-182">`JsonConvert.PopulateObject` method</span></span>                   | <span data-ttu-id="d5796-183">⚠️[Non pris en charge, solution de contournement](#populate-existing-objects)</span><span class="sxs-lookup"><span data-stu-id="d5796-183">⚠️ [Not supported, workaround](#populate-existing-objects)</span></span> |
| <span data-ttu-id="d5796-184">`ObjectCreationHandling` paramètre global</span><span class="sxs-lookup"><span data-stu-id="d5796-184">`ObjectCreationHandling` global setting</span></span>               | <span data-ttu-id="d5796-185">⚠️[Non pris en charge, solution de contournement](#reuse-rather-than-replace-properties)</span><span class="sxs-lookup"><span data-stu-id="d5796-185">⚠️ [Not supported, workaround](#reuse-rather-than-replace-properties)</span></span> |
| <span data-ttu-id="d5796-186">Ajouter aux collections sans Setters</span><span class="sxs-lookup"><span data-stu-id="d5796-186">Add to collections without setters</span></span>                    | <span data-ttu-id="d5796-187">⚠️[Non pris en charge, solution de contournement](#add-to-collections-without-setters)</span><span class="sxs-lookup"><span data-stu-id="d5796-187">⚠️ [Not supported, workaround](#add-to-collections-without-setters)</span></span> |
| <span data-ttu-id="d5796-188">`PreserveReferencesHandling` paramètre global</span><span class="sxs-lookup"><span data-stu-id="d5796-188">`PreserveReferencesHandling` global setting</span></span>           | <span data-ttu-id="d5796-189">❌[Non pris en charge](#preserve-object-references-and-handle-loops)</span><span class="sxs-lookup"><span data-stu-id="d5796-189">❌ [Not supported](#preserve-object-references-and-handle-loops)</span></span> |
| <span data-ttu-id="d5796-190">`ReferenceLoopHandling` paramètre global</span><span class="sxs-lookup"><span data-stu-id="d5796-190">`ReferenceLoopHandling` global setting</span></span>                | <span data-ttu-id="d5796-191">❌[Non pris en charge](#preserve-object-references-and-handle-loops)</span><span class="sxs-lookup"><span data-stu-id="d5796-191">❌ [Not supported](#preserve-object-references-and-handle-loops)</span></span> |
| <span data-ttu-id="d5796-192">Prise en charge des `System.Runtime.Serialization` attributs</span><span class="sxs-lookup"><span data-stu-id="d5796-192">Support for `System.Runtime.Serialization` attributes</span></span> | <span data-ttu-id="d5796-193">❌[Non pris en charge](#systemruntimeserialization-attributes)</span><span class="sxs-lookup"><span data-stu-id="d5796-193">❌ [Not supported](#systemruntimeserialization-attributes)</span></span> |
| <span data-ttu-id="d5796-194">`MissingMemberHandling` paramètre global</span><span class="sxs-lookup"><span data-stu-id="d5796-194">`MissingMemberHandling` global setting</span></span>                | <span data-ttu-id="d5796-195">❌[Non pris en charge](#missingmemberhandling)</span><span class="sxs-lookup"><span data-stu-id="d5796-195">❌ [Not supported](#missingmemberhandling)</span></span> |
| <span data-ttu-id="d5796-196">Autoriser les noms de propriété sans guillemets</span><span class="sxs-lookup"><span data-stu-id="d5796-196">Allow property names without quotes</span></span>                   | <span data-ttu-id="d5796-197">❌[Non pris en charge](#json-strings-property-names-and-string-values)</span><span class="sxs-lookup"><span data-stu-id="d5796-197">❌ [Not supported](#json-strings-property-names-and-string-values)</span></span> |
| <span data-ttu-id="d5796-198">Autoriser les guillemets simples autour des valeurs de chaîne</span><span class="sxs-lookup"><span data-stu-id="d5796-198">Allow single quotes around string values</span></span>              | <span data-ttu-id="d5796-199">❌[Non pris en charge](#json-strings-property-names-and-string-values)</span><span class="sxs-lookup"><span data-stu-id="d5796-199">❌ [Not supported](#json-strings-property-names-and-string-values)</span></span> |
| <span data-ttu-id="d5796-200">Autoriser les valeurs non-chaîne JSON pour les propriétés de chaîne</span><span class="sxs-lookup"><span data-stu-id="d5796-200">Allow non-string JSON values for string properties</span></span>    | <span data-ttu-id="d5796-201">❌[Non pris en charge](#non-string-values-for-string-properties)</span><span class="sxs-lookup"><span data-stu-id="d5796-201">❌ [Not supported](#non-string-values-for-string-properties)</span></span> |

<span data-ttu-id="d5796-202">Il ne s’agit pas d’une liste exhaustive des `Newtonsoft.Json` fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="d5796-202">This is not an exhaustive list of `Newtonsoft.Json` features.</span></span> <span data-ttu-id="d5796-203">La liste comprend un grand nombre des scénarios qui ont été demandés dans les [problèmes GitHub](https://github.com/dotnet/runtime/issues?q=is%3Aopen+is%3Aissue+label%3Aarea-System.Text.Json) ou les publications [StackOverflow](https://stackoverflow.com/questions/tagged/system.text.json) .</span><span class="sxs-lookup"><span data-stu-id="d5796-203">The list includes many of the scenarios that have been requested in [GitHub issues](https://github.com/dotnet/runtime/issues?q=is%3Aopen+is%3Aissue+label%3Aarea-System.Text.Json) or [StackOverflow](https://stackoverflow.com/questions/tagged/system.text.json) posts.</span></span> <span data-ttu-id="d5796-204">Si vous implémentez une solution de contournement pour l’un des scénarios répertoriés ici qui n’a pas d’exemple de code, et si vous souhaitez partager votre solution, sélectionnez **cette page** dans la section **Commentaires** en bas de cette page.</span><span class="sxs-lookup"><span data-stu-id="d5796-204">If you implement a workaround for one of the scenarios listed here that doesn't currently have sample code, and if you want to share your solution, select **This page** in the **Feedback** section at the bottom of this page.</span></span> <span data-ttu-id="d5796-205">Cela crée un problème dans le référentiel GitHub de cette documentation et le répertorie également dans la section **Commentaires** sur cette page.</span><span class="sxs-lookup"><span data-stu-id="d5796-205">That creates an issue in this documentation's GitHub repo and lists it in the **Feedback** section on this page too.</span></span>

## <a name="differences-in-default-jsonserializer-behavior-compared-to-no-locnewtonsoftjson"></a><span data-ttu-id="d5796-206">Différences dans le comportement de JsonSerializer par défaut par rapport à Newtonsoft.Json</span><span class="sxs-lookup"><span data-stu-id="d5796-206">Differences in default JsonSerializer behavior compared to Newtonsoft.Json</span></span>

<span data-ttu-id="d5796-207"><xref:System.Text.Json> est strict par défaut et évite toute estimation ou interprétation au nom de l’appelant, en mettant l’accent sur le comportement déterministe.</span><span class="sxs-lookup"><span data-stu-id="d5796-207"><xref:System.Text.Json> is strict by default and avoids any guessing or interpretation on the caller's behalf, emphasizing deterministic behavior.</span></span> <span data-ttu-id="d5796-208">La bibliothèque est intentionnellement conçue de cette façon pour les performances et la sécurité.</span><span class="sxs-lookup"><span data-stu-id="d5796-208">The library is intentionally designed this way for performance and security.</span></span> <span data-ttu-id="d5796-209">`Newtonsoft.Json` est flexible par défaut.</span><span class="sxs-lookup"><span data-stu-id="d5796-209">`Newtonsoft.Json` is flexible by default.</span></span> <span data-ttu-id="d5796-210">Cette différence fondamentale en matière de conception repose sur la plupart des différences spécifiques suivantes dans le comportement par défaut.</span><span class="sxs-lookup"><span data-stu-id="d5796-210">This fundamental difference in design is behind many of the following specific differences in default behavior.</span></span>

### <a name="case-insensitive-deserialization"></a><span data-ttu-id="d5796-211">Désérialisation non sensible à la casse</span><span class="sxs-lookup"><span data-stu-id="d5796-211">Case-insensitive deserialization</span></span>

<span data-ttu-id="d5796-212">Pendant la désérialisation, `Newtonsoft.Json` ne respecte pas la casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="d5796-212">During deserialization, `Newtonsoft.Json` does case-insensitive property name matching by default.</span></span> <span data-ttu-id="d5796-213">La <xref:System.Text.Json> valeur par défaut est sensible à la casse, ce qui offre de meilleures performances, car elle fait une correspondance exacte.</span><span class="sxs-lookup"><span data-stu-id="d5796-213">The <xref:System.Text.Json> default is case-sensitive, which gives better performance since it's doing an exact match.</span></span> <span data-ttu-id="d5796-214">Pour plus d’informations sur la façon d’effectuer une correspondance qui ne respecte pas la casse, consultez [correspondance de propriété](system-text-json-how-to.md#case-insensitive-property-matching)ne respectant pas la casse.</span><span class="sxs-lookup"><span data-stu-id="d5796-214">For information about how to do case-insensitive matching, see [Case-insensitive property matching](system-text-json-how-to.md#case-insensitive-property-matching).</span></span>

<span data-ttu-id="d5796-215">Si vous utilisez `System.Text.Json` indirectement à l’aide de ASP.net Core, vous n’avez rien à faire pour avoir un comportement similaire `Newtonsoft.Json` .</span><span class="sxs-lookup"><span data-stu-id="d5796-215">If you're using `System.Text.Json` indirectly by using ASP.NET Core, you don't need to do anything to get behavior like `Newtonsoft.Json`.</span></span> <span data-ttu-id="d5796-216">ASP.NET Core spécifie les paramètres pour les [noms de propriété en casse mixte](system-text-json-how-to.md#use-camel-case-for-all-json-property-names) et la correspondance ne respectant pas la casse lorsqu’il utilise `System.Text.Json` .</span><span class="sxs-lookup"><span data-stu-id="d5796-216">ASP.NET Core specifies the settings for [camel-casing property names](system-text-json-how-to.md#use-camel-case-for-all-json-property-names) and case-insensitive matching when it uses `System.Text.Json`.</span></span> <span data-ttu-id="d5796-217">Les valeurs par défaut sont définies dans la [classe JsonOptions](https://github.com/dotnet/aspnetcore/blob/1f56888ea03f6a113587a6c4ac4d8b2ded326ffa/src/Mvc/Mvc.Core/src/JsonOptions.cs#L22-L28).</span><span class="sxs-lookup"><span data-stu-id="d5796-217">The default values are set in the [JsonOptions class](https://github.com/dotnet/aspnetcore/blob/1f56888ea03f6a113587a6c4ac4d8b2ded326ffa/src/Mvc/Mvc.Core/src/JsonOptions.cs#L22-L28).</span></span>

### <a name="minimal-character-escaping"></a><span data-ttu-id="d5796-218">Échappement de caractères minimal</span><span class="sxs-lookup"><span data-stu-id="d5796-218">Minimal character escaping</span></span>

<span data-ttu-id="d5796-219">Pendant la sérialisation, `Newtonsoft.Json` est relativement permissif en ce qui concerne les caractères sans les placer dans une séquence d’échappement.</span><span class="sxs-lookup"><span data-stu-id="d5796-219">During serialization, `Newtonsoft.Json` is relatively permissive about letting characters through without escaping them.</span></span> <span data-ttu-id="d5796-220">Autrement dit, il ne les remplace pas par `\uxxxx` où `xxxx` est le point de code du caractère.</span><span class="sxs-lookup"><span data-stu-id="d5796-220">That is, it doesn't replace them with `\uxxxx` where `xxxx` is the character's code point.</span></span> <span data-ttu-id="d5796-221">Lorsqu’il les échappe, il émet un `\` avant le caractère (par exemple, `"` devient `\"` ).</span><span class="sxs-lookup"><span data-stu-id="d5796-221">Where it does escape them, it does so by emitting a `\` before the character (for example, `"` becomes `\"`).</span></span> <span data-ttu-id="d5796-222"><xref:System.Text.Json> échappe les caractères par défaut pour fournir des protections en profondeur contre les attaques de script entre sites (XSS) ou de divulgation d’informations, et utilise la séquence de six caractères.</span><span class="sxs-lookup"><span data-stu-id="d5796-222"><xref:System.Text.Json> escapes more characters by default to provide defense-in-depth protections against cross-site scripting (XSS) or information-disclosure attacks and does so by using the six-character sequence.</span></span> <span data-ttu-id="d5796-223">`System.Text.Json` échappe par défaut tous les caractères non-ASCII. vous n’avez donc pas besoin de faire quoi que ce soit si vous utilisez `StringEscapeHandling.EscapeNonAscii` dans `Newtonsoft.Json` .</span><span class="sxs-lookup"><span data-stu-id="d5796-223">`System.Text.Json` escapes all non-ASCII characters by default, so you don't need to do anything if you're using `StringEscapeHandling.EscapeNonAscii` in `Newtonsoft.Json`.</span></span> <span data-ttu-id="d5796-224">`System.Text.Json` échappe également les caractères HTML, par défaut.</span><span class="sxs-lookup"><span data-stu-id="d5796-224">`System.Text.Json` also escapes HTML-sensitive characters, by default.</span></span> <span data-ttu-id="d5796-225">Pour plus d’informations sur la façon de remplacer le comportement par défaut `System.Text.Json` , consultez [personnaliser l’encodage des caractères](system-text-json-how-to.md#customize-character-encoding).</span><span class="sxs-lookup"><span data-stu-id="d5796-225">For information about how to override the default `System.Text.Json` behavior, see [Customize character encoding](system-text-json-how-to.md#customize-character-encoding).</span></span>

### <a name="comments"></a><span data-ttu-id="d5796-226">Commentaires</span><span class="sxs-lookup"><span data-stu-id="d5796-226">Comments</span></span>

<span data-ttu-id="d5796-227">Pendant la désérialisation, `Newtonsoft.Json` ignore par défaut les commentaires dans le JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-227">During deserialization, `Newtonsoft.Json` ignores comments in the JSON by default.</span></span> <span data-ttu-id="d5796-228">La <xref:System.Text.Json> valeur par défaut consiste à lever des exceptions pour les commentaires, car la spécification [RFC 8259](https://tools.ietf.org/html/rfc8259) ne les inclut pas.</span><span class="sxs-lookup"><span data-stu-id="d5796-228">The <xref:System.Text.Json> default is to throw exceptions for comments because the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification doesn't include them.</span></span> <span data-ttu-id="d5796-229">Pour plus d’informations sur l’autorisation des commentaires, consultez [autoriser les commentaires et les virgules de fin](system-text-json-how-to.md#allow-comments-and-trailing-commas).</span><span class="sxs-lookup"><span data-stu-id="d5796-229">For information about how to allow comments, see [Allow comments and trailing commas](system-text-json-how-to.md#allow-comments-and-trailing-commas).</span></span>

### <a name="trailing-commas"></a><span data-ttu-id="d5796-230">Virgules de fin</span><span class="sxs-lookup"><span data-stu-id="d5796-230">Trailing commas</span></span>

<span data-ttu-id="d5796-231">Pendant la désérialisation, `Newtonsoft.Json` ignore les virgules de fin par défaut.</span><span class="sxs-lookup"><span data-stu-id="d5796-231">During deserialization, `Newtonsoft.Json` ignores trailing commas by default.</span></span> <span data-ttu-id="d5796-232">Elle ignore également plusieurs virgules de fin (par exemple, `[{"Color":"Red"},{"Color":"Green"},,]` ).</span><span class="sxs-lookup"><span data-stu-id="d5796-232">It also ignores multiple trailing commas (for example, `[{"Color":"Red"},{"Color":"Green"},,]`).</span></span> <span data-ttu-id="d5796-233">La <xref:System.Text.Json> valeur par défaut consiste à lever des exceptions pour les virgules de fin, car la spécification [RFC 8259](https://tools.ietf.org/html/rfc8259) ne les autorise pas.</span><span class="sxs-lookup"><span data-stu-id="d5796-233">The <xref:System.Text.Json> default is to throw exceptions for trailing commas because the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification doesn't allow them.</span></span> <span data-ttu-id="d5796-234">Pour plus d’informations sur la façon de `System.Text.Json` les accepter, consultez [autoriser les commentaires et les virgules de fin](system-text-json-how-to.md#allow-comments-and-trailing-commas).</span><span class="sxs-lookup"><span data-stu-id="d5796-234">For information about how to make `System.Text.Json` accept them, see [Allow comments and trailing commas](system-text-json-how-to.md#allow-comments-and-trailing-commas).</span></span> <span data-ttu-id="d5796-235">Il n’existe aucun moyen d’autoriser plusieurs virgules de fin.</span><span class="sxs-lookup"><span data-stu-id="d5796-235">There's no way to allow multiple trailing commas.</span></span>

### <a name="converter-registration-precedence"></a><span data-ttu-id="d5796-236">Priorité d’inscription du convertisseur</span><span class="sxs-lookup"><span data-stu-id="d5796-236">Converter registration precedence</span></span>

<span data-ttu-id="d5796-237">La `Newtonsoft.Json` priorité d’inscription pour les convertisseurs personnalisés est la suivante :</span><span class="sxs-lookup"><span data-stu-id="d5796-237">The `Newtonsoft.Json` registration precedence for custom converters is as follows:</span></span>

* <span data-ttu-id="d5796-238">Attribut sur la propriété</span><span class="sxs-lookup"><span data-stu-id="d5796-238">Attribute on property</span></span>
* <span data-ttu-id="d5796-239">Attribut sur le type</span><span class="sxs-lookup"><span data-stu-id="d5796-239">Attribute on type</span></span>
* <span data-ttu-id="d5796-240">[Converters](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_Converters.htm) , collection</span><span class="sxs-lookup"><span data-stu-id="d5796-240">[Converters](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_Converters.htm) collection</span></span>

<span data-ttu-id="d5796-241">Dans cet ordre, un convertisseur personnalisé dans la `Converters` collection est substitué par un convertisseur qui est inscrit en appliquant un attribut au niveau du type.</span><span class="sxs-lookup"><span data-stu-id="d5796-241">This order means that a custom converter in the `Converters` collection is overridden by a converter that is registered by applying an attribute at the type level.</span></span> <span data-ttu-id="d5796-242">Ces deux inscriptions sont remplacées par un attribut au niveau de la propriété.</span><span class="sxs-lookup"><span data-stu-id="d5796-242">Both of those registrations are overridden by an attribute at the property level.</span></span>

<span data-ttu-id="d5796-243">La <xref:System.Text.Json> priorité d’inscription pour les convertisseurs personnalisés est différente :</span><span class="sxs-lookup"><span data-stu-id="d5796-243">The <xref:System.Text.Json> registration precedence for custom converters is different:</span></span>

* <span data-ttu-id="d5796-244">Attribut sur la propriété</span><span class="sxs-lookup"><span data-stu-id="d5796-244">Attribute on property</span></span>
* <span data-ttu-id="d5796-245"><xref:System.Text.Json.JsonSerializerOptions.Converters> collecte</span><span class="sxs-lookup"><span data-stu-id="d5796-245"><xref:System.Text.Json.JsonSerializerOptions.Converters> collection</span></span>
* <span data-ttu-id="d5796-246">Attribut sur le type</span><span class="sxs-lookup"><span data-stu-id="d5796-246">Attribute on type</span></span>

<span data-ttu-id="d5796-247">La différence réside dans le fait qu’un convertisseur personnalisé dans la `Converters` collection remplace un attribut au niveau du type.</span><span class="sxs-lookup"><span data-stu-id="d5796-247">The difference here is that a custom converter in the `Converters` collection overrides an attribute at the type level.</span></span> <span data-ttu-id="d5796-248">L’objectif derrière cet ordre de priorité est de faire en sorte que les modifications au moment de l’exécution remplacent les choix au moment de la conception.</span><span class="sxs-lookup"><span data-stu-id="d5796-248">The intention behind this order of precedence is to make run-time changes override design-time choices.</span></span> <span data-ttu-id="d5796-249">Il n’existe aucun moyen de modifier la précédence.</span><span class="sxs-lookup"><span data-stu-id="d5796-249">There's no way to change the precedence.</span></span>

<span data-ttu-id="d5796-250">Pour plus d’informations sur l’inscription d’un convertisseur personnalisé, consultez [inscrire un convertisseur personnalisé](system-text-json-converters-how-to.md#register-a-custom-converter).</span><span class="sxs-lookup"><span data-stu-id="d5796-250">For more information about custom converter registration, see [Register a custom converter](system-text-json-converters-how-to.md#register-a-custom-converter).</span></span>

### <a name="maximum-depth"></a><span data-ttu-id="d5796-251">Profondeur maximale</span><span class="sxs-lookup"><span data-stu-id="d5796-251">Maximum depth</span></span>

<span data-ttu-id="d5796-252">`Newtonsoft.Json` n’a pas de limite de profondeur maximale par défaut.</span><span class="sxs-lookup"><span data-stu-id="d5796-252">`Newtonsoft.Json` doesn't have a maximum depth limit by default.</span></span> <span data-ttu-id="d5796-253">Pour <xref:System.Text.Json> une limite par défaut de 64, elle peut être configurée en définissant <xref:System.Text.Json.JsonSerializerOptions.MaxDepth?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d5796-253">For <xref:System.Text.Json> there's a default limit  of 64, and it's configurable by setting <xref:System.Text.Json.JsonSerializerOptions.MaxDepth?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="d5796-254">Si vous utilisez `System.Text.Json` indirectement à l’aide de ASP.net Core, la limite de profondeur maximale par défaut est 32.</span><span class="sxs-lookup"><span data-stu-id="d5796-254">If you're using `System.Text.Json` indirectly by using ASP.NET Core, the default maximum depth limit is 32.</span></span> <span data-ttu-id="d5796-255">La valeur par défaut est la même que pour la liaison de modèle et est définie dans la [classe JsonOptions](https://github.com/dotnet/aspnetcore/blob/1f56888ea03f6a113587a6c4ac4d8b2ded326ffa/src/Mvc/Mvc.Core/src/JsonOptions.cs#L17-L20).</span><span class="sxs-lookup"><span data-stu-id="d5796-255">The default value is the same as for model binding and is set in the [JsonOptions class](https://github.com/dotnet/aspnetcore/blob/1f56888ea03f6a113587a6c4ac4d8b2ded326ffa/src/Mvc/Mvc.Core/src/JsonOptions.cs#L17-L20).</span></span>

### <a name="json-strings-property-names-and-string-values"></a><span data-ttu-id="d5796-256">Chaînes JSON (noms de propriété et valeurs de chaîne)</span><span class="sxs-lookup"><span data-stu-id="d5796-256">JSON strings (property names and string values)</span></span>

<span data-ttu-id="d5796-257">Pendant la désérialisation, `Newtonsoft.Json` accepte les noms de propriété placés entre guillemets doubles, apostrophes ou sans guillemets.</span><span class="sxs-lookup"><span data-stu-id="d5796-257">During deserialization, `Newtonsoft.Json` accepts property names surrounded by double quotes, single quotes, or without quotes.</span></span> <span data-ttu-id="d5796-258">Il accepte les valeurs de chaîne entourées de guillemets doubles ou de guillemets simples.</span><span class="sxs-lookup"><span data-stu-id="d5796-258">It accepts string values surrounded by double quotes or single quotes.</span></span> <span data-ttu-id="d5796-259">Par exemple, `Newtonsoft.Json` accepte le code JSON suivant :</span><span class="sxs-lookup"><span data-stu-id="d5796-259">For example, `Newtonsoft.Json` accepts the following JSON:</span></span>

```json
{
  "name1": "value",
  'name2': "value",
  name3: 'value'
}
```

<span data-ttu-id="d5796-260">`System.Text.Json` accepte uniquement les noms de propriété et les valeurs de chaîne dans des guillemets doubles, car ce format est requis par la spécification [RFC 8259](https://tools.ietf.org/html/rfc8259) et est le seul format considéré comme un JSON valide.</span><span class="sxs-lookup"><span data-stu-id="d5796-260">`System.Text.Json` only accepts property names and string values in double quotes because that format is required by the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification and is the only format considered valid JSON.</span></span>

<span data-ttu-id="d5796-261">Une valeur placée entre guillemets simples donne un [JsonException](xref:System.Text.Json.JsonException) avec le message suivant :</span><span class="sxs-lookup"><span data-stu-id="d5796-261">A value enclosed in single quotes results in a [JsonException](xref:System.Text.Json.JsonException) with the following message:</span></span>

```output
''' is an invalid start of a value.
```

### <a name="non-string-values-for-string-properties"></a><span data-ttu-id="d5796-262">Valeurs qui ne sont pas des chaînes pour les propriétés de chaîne</span><span class="sxs-lookup"><span data-stu-id="d5796-262">Non-string values for string properties</span></span>

<span data-ttu-id="d5796-263">`Newtonsoft.Json` accepte les valeurs qui ne sont pas des chaînes, telles qu’un nombre ou les littéraux `true` et `false` , pour la désérialisation des propriétés de type chaîne.</span><span class="sxs-lookup"><span data-stu-id="d5796-263">`Newtonsoft.Json` accepts non-string values, such as a number or the literals `true` and `false`, for deserialization to properties of type string.</span></span> <span data-ttu-id="d5796-264">Voici un exemple de JSON qui `Newtonsoft.Json` désérialise avec succès la classe suivante :</span><span class="sxs-lookup"><span data-stu-id="d5796-264">Here's an example of JSON that `Newtonsoft.Json` successfully deserializes to the following class:</span></span>

```json
{
  "String1": 1,
  "String2": true,
  "String3": false
}
```

```csharp
public class ExampleClass
{
    public string String1 { get; set; }
    public string String2 { get; set; }
    public string String3 { get; set; }
}
```

<span data-ttu-id="d5796-265">`System.Text.Json` ne désérialise pas les valeurs qui ne sont pas des chaînes dans les propriétés de chaîne.</span><span class="sxs-lookup"><span data-stu-id="d5796-265">`System.Text.Json` doesn't deserialize non-string values into string properties.</span></span> <span data-ttu-id="d5796-266">Une valeur qui n’est pas une chaîne reçue pour un champ de chaîne génère un [JsonException](xref:System.Text.Json.JsonException) avec le message suivant :</span><span class="sxs-lookup"><span data-stu-id="d5796-266">A non-string value received for a string field results in a [JsonException](xref:System.Text.Json.JsonException) with the following message:</span></span>

```output
The JSON value could not be converted to System.String.
```

## <a name="scenarios-using-jsonserializer-that-require-workarounds"></a><span data-ttu-id="d5796-267">Scénarios utilisant des JsonSerializer qui requièrent des solutions de contournement</span><span class="sxs-lookup"><span data-stu-id="d5796-267">Scenarios using JsonSerializer that require workarounds</span></span>

<span data-ttu-id="d5796-268">Les scénarios suivants ne sont pas pris en charge par les fonctionnalités intégrées, mais les solutions de contournement sont possibles.</span><span class="sxs-lookup"><span data-stu-id="d5796-268">The following scenarios aren't supported by built-in functionality, but workarounds are possible.</span></span> <span data-ttu-id="d5796-269">Les solutions de contournement sont des [convertisseurs personnalisés](system-text-json-converters-how-to.md), qui peuvent ne pas fournir une parité complète avec les `Newtonsoft.Json` fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="d5796-269">The workarounds are [custom converters](system-text-json-converters-how-to.md), which may not provide complete parity with `Newtonsoft.Json` functionality.</span></span> <span data-ttu-id="d5796-270">Pour certains d’entre eux, un exemple de code est fourni comme exemples.</span><span class="sxs-lookup"><span data-stu-id="d5796-270">For some of these, sample code is provided as examples.</span></span> <span data-ttu-id="d5796-271">Si vous utilisez ces `Newtonsoft.Json` fonctionnalités, la migration nécessitera des modifications de vos modèles d’objet .net ou d’autres modifications de code.</span><span class="sxs-lookup"><span data-stu-id="d5796-271">If you rely on these `Newtonsoft.Json` features, migration will require modifications to your .NET object models or other code changes.</span></span>

### <a name="types-without-built-in-support"></a><span data-ttu-id="d5796-272">Types sans prise en charge intégrée</span><span class="sxs-lookup"><span data-stu-id="d5796-272">Types without built-in support</span></span>

<span data-ttu-id="d5796-273"><xref:System.Text.Json> ne fournit pas de prise en charge intégrée pour les types suivants :</span><span class="sxs-lookup"><span data-stu-id="d5796-273"><xref:System.Text.Json> doesn't provide built-in support for the following types:</span></span>

* <span data-ttu-id="d5796-274"><xref:System.Data.DataTable> et types associés</span><span class="sxs-lookup"><span data-stu-id="d5796-274"><xref:System.Data.DataTable> and related types</span></span>
* <span data-ttu-id="d5796-275">Types F #, tels que les [unions discriminées](../../fsharp/language-reference/discriminated-unions.md), les [types d’enregistrements](../../fsharp/language-reference/records.md)et les types d' [enregistrements anonymes](../../fsharp/language-reference/anonymous-records.md).</span><span class="sxs-lookup"><span data-stu-id="d5796-275">F# types, such as [discriminated unions](../../fsharp/language-reference/discriminated-unions.md), [record types](../../fsharp/language-reference/records.md), and [anonymous record types](../../fsharp/language-reference/anonymous-records.md).</span></span>
* <xref:System.Dynamic.ExpandoObject>
* <xref:System.TimeZoneInfo>
* <xref:System.Numerics.BigInteger>
* <xref:System.TimeSpan>
* <xref:System.DBNull>
* <xref:System.Type>
* <span data-ttu-id="d5796-276"><xref:System.ValueTuple> et ses types génériques associés</span><span class="sxs-lookup"><span data-stu-id="d5796-276"><xref:System.ValueTuple> and its associated generic types</span></span>

<span data-ttu-id="d5796-277">Les convertisseurs personnalisés peuvent être implémentés pour les types qui n’ont pas de prise en charge intégrée.</span><span class="sxs-lookup"><span data-stu-id="d5796-277">Custom converters can be implemented for types that don't have built-in support.</span></span>

### <a name="quoted-numbers"></a><span data-ttu-id="d5796-278">Nombres entre guillemets</span><span class="sxs-lookup"><span data-stu-id="d5796-278">Quoted numbers</span></span>

<span data-ttu-id="d5796-279">`Newtonsoft.Json` peut sérialiser ou désérialiser des nombres représentés par des chaînes JSON (entourées de guillemets).</span><span class="sxs-lookup"><span data-stu-id="d5796-279">`Newtonsoft.Json` can serialize or deserialize numbers represented by JSON strings (surrounded by quotes).</span></span> <span data-ttu-id="d5796-280">Par exemple, il peut accepter : `{"DegreesCelsius":"23"}` au lieu de `{"DegreesCelsius":23}` .</span><span class="sxs-lookup"><span data-stu-id="d5796-280">For example, it can accept: `{"DegreesCelsius":"23"}` instead of `{"DegreesCelsius":23}`.</span></span> <span data-ttu-id="d5796-281">Pour activer ce comportement dans <xref:System.Text.Json> , implémentez un convertisseur personnalisé comme dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="d5796-281">To enable that behavior in <xref:System.Text.Json>, implement a custom converter like the following example.</span></span> <span data-ttu-id="d5796-282">Le convertisseur gère les propriétés définies comme `long` suit :</span><span class="sxs-lookup"><span data-stu-id="d5796-282">The converter handles properties defined as `long`:</span></span>

* <span data-ttu-id="d5796-283">Il les sérialise en tant que chaînes JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-283">It serializes them as JSON strings.</span></span>
* <span data-ttu-id="d5796-284">Il accepte les nombres et nombres JSON dans les guillemets lors de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="d5796-284">It accepts JSON numbers and numbers within quotes while deserializing.</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/LongToStringConverter.cs)]

<span data-ttu-id="d5796-285">Inscrivez ce convertisseur personnalisé à [l’aide d’un attribut](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property) sur des `long` propriétés individuelles ou en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span><span class="sxs-lookup"><span data-stu-id="d5796-285">Register this custom converter by [using an attribute](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property) on individual `long` properties or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

### <a name="dictionary-with-non-string-key"></a><span data-ttu-id="d5796-286">Dictionnaire avec clé non-chaîne</span><span class="sxs-lookup"><span data-stu-id="d5796-286">Dictionary with non-string key</span></span>

<span data-ttu-id="d5796-287">`Newtonsoft.Json` prend en charge les collections de type `Dictionary<TKey, TValue>` .</span><span class="sxs-lookup"><span data-stu-id="d5796-287">`Newtonsoft.Json` supports collections of type `Dictionary<TKey, TValue>`.</span></span> <span data-ttu-id="d5796-288">La prise en charge intégrée pour les collections de dictionnaires dans <xref:System.Text.Json> est limitée à `Dictionary<string, TValue>` .</span><span class="sxs-lookup"><span data-stu-id="d5796-288">The built-in support for dictionary collections in <xref:System.Text.Json> is limited to `Dictionary<string, TValue>`.</span></span> <span data-ttu-id="d5796-289">Autrement dit, la clé doit être une chaîne.</span><span class="sxs-lookup"><span data-stu-id="d5796-289">That is, the key must be a string.</span></span>

<span data-ttu-id="d5796-290">Pour prendre en charge un dictionnaire avec un entier ou un autre type en tant que clé, créez un convertisseur comme l’exemple dans [Comment écrire des convertisseurs personnalisés](system-text-json-converters-how-to.md#support-dictionary-with-non-string-key).</span><span class="sxs-lookup"><span data-stu-id="d5796-290">To support a dictionary with an integer or some other type as the key, create a converter like the example in [How to write custom converters](system-text-json-converters-how-to.md#support-dictionary-with-non-string-key).</span></span>

### <a name="polymorphic-serialization"></a><span data-ttu-id="d5796-291">Sérialisation polymorphe</span><span class="sxs-lookup"><span data-stu-id="d5796-291">Polymorphic serialization</span></span>

<span data-ttu-id="d5796-292">`Newtonsoft.Json` effectue automatiquement la sérialisation polymorphe.</span><span class="sxs-lookup"><span data-stu-id="d5796-292">`Newtonsoft.Json` automatically does polymorphic serialization.</span></span> <span data-ttu-id="d5796-293">Pour plus d’informations sur les fonctionnalités de sérialisation polymorphes limitées de <xref:System.Text.Json> , consultez [sérialisation des propriétés de classes dérivées](system-text-json-how-to.md#serialize-properties-of-derived-classes).</span><span class="sxs-lookup"><span data-stu-id="d5796-293">For information about the limited polymorphic serialization capabilities of <xref:System.Text.Json>, see [Serialize properties of derived classes](system-text-json-how-to.md#serialize-properties-of-derived-classes).</span></span>

<span data-ttu-id="d5796-294">La solution de contournement décrite ici permet de définir des propriétés qui peuvent contenir des classes dérivées comme type `object` .</span><span class="sxs-lookup"><span data-stu-id="d5796-294">The workaround described there is to define properties that may contain derived classes as type `object`.</span></span> <span data-ttu-id="d5796-295">Si cela n’est pas possible, une autre option consiste à créer un convertisseur avec une `Write` méthode pour l’ensemble de la hiérarchie des types d’héritage, comme dans l’exemple de la rubrique [Comment écrire des convertisseurs personnalisés](system-text-json-converters-how-to.md#support-polymorphic-deserialization).</span><span class="sxs-lookup"><span data-stu-id="d5796-295">If that isn't possible, another option is to create a converter with a `Write` method for the whole inheritance type hierarchy like the example in [How to write custom converters](system-text-json-converters-how-to.md#support-polymorphic-deserialization).</span></span>

### <a name="polymorphic-deserialization"></a><span data-ttu-id="d5796-296">Désérialisation polymorphe</span><span class="sxs-lookup"><span data-stu-id="d5796-296">Polymorphic deserialization</span></span>

<span data-ttu-id="d5796-297">`Newtonsoft.Json` a un `TypeNameHandling` paramètre qui ajoute des métadonnées de nom de type au JSON lors de la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="d5796-297">`Newtonsoft.Json` has a `TypeNameHandling` setting that adds type name metadata to the JSON while serializing.</span></span> <span data-ttu-id="d5796-298">Elle utilise les métadonnées lors de la désérialisation pour effectuer une désérialisation polymorphe.</span><span class="sxs-lookup"><span data-stu-id="d5796-298">It uses the metadata while deserializing to do polymorphic deserialization.</span></span> <span data-ttu-id="d5796-299"><xref:System.Text.Json> peut effectuer une plage limitée de [sérialisation polymorphe](system-text-json-how-to.md#serialize-properties-of-derived-classes) , mais pas de désérialisation polymorphe.</span><span class="sxs-lookup"><span data-stu-id="d5796-299"><xref:System.Text.Json> can do a limited range of [polymorphic serialization](system-text-json-how-to.md#serialize-properties-of-derived-classes) but not polymorphic deserialization.</span></span>

<span data-ttu-id="d5796-300">Pour prendre en charge la désérialisation polymorphe, créez un convertisseur comme l’exemple dans [Comment écrire des convertisseurs personnalisés](system-text-json-converters-how-to.md#support-polymorphic-deserialization).</span><span class="sxs-lookup"><span data-stu-id="d5796-300">To support polymorphic deserialization, create a converter like the example in [How to write custom converters](system-text-json-converters-how-to.md#support-polymorphic-deserialization).</span></span>

### <a name="deserialization-of-object-properties"></a><span data-ttu-id="d5796-301">Désérialisation des propriétés de l’objet</span><span class="sxs-lookup"><span data-stu-id="d5796-301">Deserialization of object properties</span></span>

<span data-ttu-id="d5796-302">Lors `Newtonsoft.Json` de la désérialisation vers <xref:System.Object> , il :</span><span class="sxs-lookup"><span data-stu-id="d5796-302">When `Newtonsoft.Json` deserializes to <xref:System.Object>, it:</span></span>

* <span data-ttu-id="d5796-303">Déduit le type de valeurs primitives dans la charge utile JSON (autre que `null` ) et retourne le stocké `string` , `long` ,, `double` `boolean` ou `DateTime` en tant qu’objet boxed.</span><span class="sxs-lookup"><span data-stu-id="d5796-303">Infers the type of primitive values in the JSON payload (other than `null`) and returns the stored `string`, `long`, `double`, `boolean`, or `DateTime` as a boxed object.</span></span> <span data-ttu-id="d5796-304">Les *valeurs primitives* sont des valeurs JSON uniques, telles qu’un nombre JSON, une chaîne,, `true` `false` ou `null` .</span><span class="sxs-lookup"><span data-stu-id="d5796-304">*Primitive values* are single JSON values such as a JSON number, string, `true`, `false`, or `null`.</span></span>
* <span data-ttu-id="d5796-305">Retourne `JObject` ou `JArray` pour les valeurs complexes dans la charge utile JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-305">Returns a `JObject` or `JArray` for complex values in the JSON payload.</span></span> <span data-ttu-id="d5796-306">Les *valeurs complexes* sont des collections de paires clé-valeur JSON entre accolades ( `{}` ) ou des listes de valeurs entre crochets ( `[]` ).</span><span class="sxs-lookup"><span data-stu-id="d5796-306">*Complex values* are collections of JSON key-value pairs within braces (`{}`) or lists of values within brackets (`[]`).</span></span> <span data-ttu-id="d5796-307">Les propriétés et les valeurs entre accolades ou crochets peuvent avoir des propriétés ou des valeurs supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="d5796-307">The properties and values within the braces or brackets can have additional properties or values.</span></span>
* <span data-ttu-id="d5796-308">Retourne une référence Null lorsque la charge utile a le `null` littéral JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-308">Returns a null reference when the payload has the `null` JSON literal.</span></span>

<span data-ttu-id="d5796-309"><xref:System.Text.Json> stocke un boxed `JsonElement` pour les valeurs primitives et complexes lors de la désérialisation de en <xref:System.Object> , par exemple :</span><span class="sxs-lookup"><span data-stu-id="d5796-309"><xref:System.Text.Json> stores a boxed `JsonElement` for both primitive and complex values whenever deserializing to <xref:System.Object>, for example:</span></span>

* <span data-ttu-id="d5796-310">Propriété `object`.</span><span class="sxs-lookup"><span data-stu-id="d5796-310">An `object` property.</span></span>
* <span data-ttu-id="d5796-311">`object`Valeur de dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="d5796-311">An `object` dictionary value.</span></span>
* <span data-ttu-id="d5796-312">`object`Valeur de tableau.</span><span class="sxs-lookup"><span data-stu-id="d5796-312">An `object` array value.</span></span>
* <span data-ttu-id="d5796-313">Racine `object` .</span><span class="sxs-lookup"><span data-stu-id="d5796-313">A root `object`.</span></span>

<span data-ttu-id="d5796-314">Toutefois, `System.Text.Json` traite de `null` la même façon que `Newtonsoft.Json` et retourne une référence Null lorsque la charge utile contient le `null` littéral JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-314">However, `System.Text.Json` treats `null` the same as `Newtonsoft.Json` and returns a null reference when the payload has the `null` JSON literal in it.</span></span>

<span data-ttu-id="d5796-315">Pour implémenter l’inférence de type pour les `object` Propriétés, créez un convertisseur comme l’exemple dans [Comment écrire des convertisseurs personnalisés](system-text-json-converters-how-to.md#deserialize-inferred-types-to-object-properties).</span><span class="sxs-lookup"><span data-stu-id="d5796-315">To implement type inference for `object` properties, create a converter like the example in [How to write custom converters](system-text-json-converters-how-to.md#deserialize-inferred-types-to-object-properties).</span></span>

### <a name="deserialize-null-to-non-nullable-type"></a><span data-ttu-id="d5796-316">Désérialiser la valeur null en type non Nullable</span><span class="sxs-lookup"><span data-stu-id="d5796-316">Deserialize null to non-nullable type</span></span>

<span data-ttu-id="d5796-317">`Newtonsoft.Json` ne lève pas d’exception dans le scénario suivant :</span><span class="sxs-lookup"><span data-stu-id="d5796-317">`Newtonsoft.Json` doesn't throw an exception in the following scenario:</span></span>

* <span data-ttu-id="d5796-318">`NullValueHandling` a la valeur `Ignore` , et</span><span class="sxs-lookup"><span data-stu-id="d5796-318">`NullValueHandling` is set to `Ignore`, and</span></span>
* <span data-ttu-id="d5796-319">Pendant la désérialisation, le JSON contient une valeur null pour un type valeur qui n’autorise pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="d5796-319">During deserialization, the JSON contains a null value for a non-nullable value type.</span></span>

<span data-ttu-id="d5796-320">Dans le même scénario, <xref:System.Text.Json> lève une exception.</span><span class="sxs-lookup"><span data-stu-id="d5796-320">In the same scenario, <xref:System.Text.Json> does throw an exception.</span></span> <span data-ttu-id="d5796-321">(Le paramètre de gestion null correspondant est <xref:System.Text.Json.JsonSerializerOptions.IgnoreNullValues?displayProperty=nameWithType> .)</span><span class="sxs-lookup"><span data-stu-id="d5796-321">(The corresponding null handling setting is <xref:System.Text.Json.JsonSerializerOptions.IgnoreNullValues?displayProperty=nameWithType>.)</span></span>

<span data-ttu-id="d5796-322">Si vous êtes propriétaire du type de cible, la meilleure solution consiste à rendre la propriété en question Nullable (par exemple, remplacer par `int` `int?` ).</span><span class="sxs-lookup"><span data-stu-id="d5796-322">If you own the target type, the best workaround is to make the property in question nullable (for example, change `int` to `int?`).</span></span>

<span data-ttu-id="d5796-323">Une autre solution consiste à créer un convertisseur pour le type, comme dans l’exemple suivant qui gère les valeurs NULL pour les `DateTimeOffset` types :</span><span class="sxs-lookup"><span data-stu-id="d5796-323">Another workaround is to make a converter for the type, such as the following example that handles null values for `DateTimeOffset` types:</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/DateTimeOffsetNullHandlingConverter.cs)]

<span data-ttu-id="d5796-324">Inscrivez ce convertisseur personnalisé à l' [aide d’un attribut sur la propriété](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property) ou en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span><span class="sxs-lookup"><span data-stu-id="d5796-324">Register this custom converter by [using an attribute on the property](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property) or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="d5796-325">**Remarque :** Le convertisseur précédent **gère les valeurs null de la même façon** que `Newtonsoft.Json` pour les poco qui spécifient des valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="d5796-325">**Note:** The preceding converter **handles null values differently** than `Newtonsoft.Json` does for POCOs that specify default values.</span></span> <span data-ttu-id="d5796-326">Par exemple, supposons que le code suivant représente votre objet cible :</span><span class="sxs-lookup"><span data-stu-id="d5796-326">For example, suppose the following code represents your target object:</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/WeatherForecast.cs?name=SnippetWFWithDefault)]

<span data-ttu-id="d5796-327">Et supposons que le code JSON suivant est désérialisé à l’aide du convertisseur précédent :</span><span class="sxs-lookup"><span data-stu-id="d5796-327">And suppose the following JSON is deserialized by using the preceding converter:</span></span>

```json
{
  "Date": null,
  "TemperatureCelsius": 25,
  "Summary": null
}
```

<span data-ttu-id="d5796-328">Après la désérialisation, la `Date` propriété a 1/1/0001 ( `default(DateTimeOffset)` ), autrement dit, la valeur définie dans le constructeur est remplacée.</span><span class="sxs-lookup"><span data-stu-id="d5796-328">After deserialization, the `Date` property has 1/1/0001 (`default(DateTimeOffset)`), that is, the value set in the constructor is overwritten.</span></span> <span data-ttu-id="d5796-329">Étant donné les mêmes POCO et JSON, la `Newtonsoft.Json` désérialisation laisse 1/1/2001 dans la `Date` propriété.</span><span class="sxs-lookup"><span data-stu-id="d5796-329">Given the same POCO and JSON, `Newtonsoft.Json` deserialization would leave 1/1/2001 in the `Date` property.</span></span>

### <a name="deserialize-to-immutable-classes-and-structs"></a><span data-ttu-id="d5796-330">Désérialiser en classes et structs immuables</span><span class="sxs-lookup"><span data-stu-id="d5796-330">Deserialize to immutable classes and structs</span></span>

<span data-ttu-id="d5796-331">`Newtonsoft.Json` peut désérialiser des classes et des structs immuables, car il peut utiliser des constructeurs qui ont des paramètres.</span><span class="sxs-lookup"><span data-stu-id="d5796-331">`Newtonsoft.Json` can deserialize to immutable classes and structs because it can use constructors that have parameters.</span></span> <span data-ttu-id="d5796-332"><xref:System.Text.Json> prend en charge uniquement les constructeurs sans paramètre public.</span><span class="sxs-lookup"><span data-stu-id="d5796-332"><xref:System.Text.Json> supports only public parameterless constructors.</span></span> <span data-ttu-id="d5796-333">En guise de solution de contournement, vous pouvez appeler un constructeur avec des paramètres dans un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="d5796-333">As a workaround, you can call a constructor with parameters in a custom converter.</span></span>

<span data-ttu-id="d5796-334">Voici un struct immuable avec plusieurs paramètres de constructeur :</span><span class="sxs-lookup"><span data-stu-id="d5796-334">Here's an immutable struct with multiple constructor parameters:</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/ImmutablePoint.cs#ImmutablePoint)]

<span data-ttu-id="d5796-335">Et voici un convertisseur qui sérialise et désérialise ce struct :</span><span class="sxs-lookup"><span data-stu-id="d5796-335">And here's a converter that serializes and deserializes this struct:</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/ImmutablePointConverter.cs)]

<span data-ttu-id="d5796-336">Inscrivez ce convertisseur personnalisé en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span><span class="sxs-lookup"><span data-stu-id="d5796-336">Register this custom converter by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="d5796-337">Pour obtenir un exemple de convertisseur similaire qui gère les propriétés génériques ouvertes, consultez le [convertisseur intégré pour les paires clé-valeur](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/JsonValueConverterKeyValuePair.cs).</span><span class="sxs-lookup"><span data-stu-id="d5796-337">For an example of a similar converter that handles open generic properties, see the [built-in converter for key-value pairs](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/JsonValueConverterKeyValuePair.cs).</span></span>

### <a name="specify-constructor-to-use"></a><span data-ttu-id="d5796-338">Spécifier le constructeur à utiliser</span><span class="sxs-lookup"><span data-stu-id="d5796-338">Specify constructor to use</span></span>

<span data-ttu-id="d5796-339">L' `Newtonsoft.Json` `[JsonConstructor]` attribut vous permet de spécifier le constructeur à appeler lors de la désérialisation vers un poco.</span><span class="sxs-lookup"><span data-stu-id="d5796-339">The `Newtonsoft.Json` `[JsonConstructor]` attribute lets you specify which constructor to call when deserializing to a POCO.</span></span> <span data-ttu-id="d5796-340"><xref:System.Text.Json> prend en charge uniquement les constructeurs sans paramètre.</span><span class="sxs-lookup"><span data-stu-id="d5796-340"><xref:System.Text.Json> supports only parameterless constructors.</span></span> <span data-ttu-id="d5796-341">En guise de solution de contournement, vous pouvez appeler le constructeur dont vous avez besoin dans un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="d5796-341">As a workaround, you can call whichever constructor you need in a custom converter.</span></span> <span data-ttu-id="d5796-342">Consultez l’exemple pour [désérialiser des classes et des structs immuables](#deserialize-to-immutable-classes-and-structs).</span><span class="sxs-lookup"><span data-stu-id="d5796-342">See the example for [Deserialize to immutable classes and structs](#deserialize-to-immutable-classes-and-structs).</span></span>

### <a name="required-properties"></a><span data-ttu-id="d5796-343">Propriétés requises</span><span class="sxs-lookup"><span data-stu-id="d5796-343">Required properties</span></span>

<span data-ttu-id="d5796-344">Dans `Newtonsoft.Json` , vous spécifiez qu’une propriété est requise en définissant `Required` sur l' `[JsonProperty]` attribut.</span><span class="sxs-lookup"><span data-stu-id="d5796-344">In `Newtonsoft.Json`, you specify that a property is required by setting `Required` on the `[JsonProperty]` attribute.</span></span> <span data-ttu-id="d5796-345">`Newtonsoft.Json` lève une exception si aucune valeur n’est reçue dans le JSON pour une propriété marquée comme obligatoire.</span><span class="sxs-lookup"><span data-stu-id="d5796-345">`Newtonsoft.Json` throws an exception if no value is received in the JSON for a property marked as required.</span></span>

<span data-ttu-id="d5796-346"><xref:System.Text.Json> ne lève pas d’exception si aucune valeur n’est reçue pour l’une des propriétés du type cible.</span><span class="sxs-lookup"><span data-stu-id="d5796-346"><xref:System.Text.Json> doesn't throw an exception if no value is received for one of the properties of the target type.</span></span> <span data-ttu-id="d5796-347">Par exemple, si vous avez une `WeatherForecast` classe :</span><span class="sxs-lookup"><span data-stu-id="d5796-347">For example, if you have a `WeatherForecast` class:</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/WeatherForecast.cs?name=SnippetWF)]

<span data-ttu-id="d5796-348">Le code JSON suivant est désérialisé sans erreur :</span><span class="sxs-lookup"><span data-stu-id="d5796-348">The following JSON is deserialized without error:</span></span>

```json
{
    "TemperatureCelsius": 25,
    "Summary": "Hot"
}
```

<span data-ttu-id="d5796-349">Pour faire échouer la désérialisation si aucune `Date` propriété n’est dans le JSON, implémentez un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="d5796-349">To make deserialization fail if no `Date` property is in the JSON, implement a custom converter.</span></span> <span data-ttu-id="d5796-350">L’exemple de code de convertisseur suivant lève une exception si la `Date` propriété n’est pas définie une fois que la désérialisation est terminée :</span><span class="sxs-lookup"><span data-stu-id="d5796-350">The following sample converter code throws an exception if the `Date` property isn't set after deserialization is complete:</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/WeatherForecastRequiredPropertyConverter.cs)]

<span data-ttu-id="d5796-351">Inscrivez ce convertisseur personnalisé en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la <xref:System.Text.Json.JsonSerializerOptions.Converters?displayProperty=nameWithType> collection.</span><span class="sxs-lookup"><span data-stu-id="d5796-351">Register this custom converter by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters?displayProperty=nameWithType> collection.</span></span>

<span data-ttu-id="d5796-352">Ce modèle d’appel récursif du convertisseur requiert que vous inscriviez le convertisseur à l’aide de <xref:System.Text.Json.JsonSerializerOptions> , et non à l’aide d’un attribut.</span><span class="sxs-lookup"><span data-stu-id="d5796-352">This pattern of recursively calling the converter requires that you register the converter by using <xref:System.Text.Json.JsonSerializerOptions>, not by using an attribute.</span></span> <span data-ttu-id="d5796-353">Si vous inscrivez le convertisseur à l’aide d’un attribut, le convertisseur personnalisé s’appelle de manière récursive dans lui-même.</span><span class="sxs-lookup"><span data-stu-id="d5796-353">If you register the converter by using an attribute, the custom converter recursively calls into itself.</span></span> <span data-ttu-id="d5796-354">Le résultat est une boucle infinie qui se termine dans une exception de dépassement de capacité de la pile.</span><span class="sxs-lookup"><span data-stu-id="d5796-354">The result is an infinite loop that ends in a stack overflow exception.</span></span>

<span data-ttu-id="d5796-355">Quand vous inscrivez le convertisseur à l’aide de l’objet d’options, évitez une boucle infinie en ne passant pas l’objet d’options lors de l’appel de <xref:System.Text.Json.JsonSerializer.Serialize%2A> ou de <xref:System.Text.Json.JsonSerializer.Deserialize%2A> .</span><span class="sxs-lookup"><span data-stu-id="d5796-355">When you register the converter by using the options object, avoid an infinite loop by not passing in the options object when recursively calling <xref:System.Text.Json.JsonSerializer.Serialize%2A> or <xref:System.Text.Json.JsonSerializer.Deserialize%2A>.</span></span> <span data-ttu-id="d5796-356">L’objet d’options contient la <xref:System.Text.Json.JsonSerializerOptions.Converters%2A> collection.</span><span class="sxs-lookup"><span data-stu-id="d5796-356">The options object contains the <xref:System.Text.Json.JsonSerializerOptions.Converters%2A> collection.</span></span> <span data-ttu-id="d5796-357">Si vous le transmettez à `Serialize` ou `Deserialize` , le convertisseur personnalisé s’appelle lui-même, en effectuant une boucle infinie qui provoque une exception de dépassement de capacité de la pile.</span><span class="sxs-lookup"><span data-stu-id="d5796-357">If you pass it in to `Serialize` or `Deserialize`, the custom converter calls into itself, making an infinite loop that results in a stack overflow exception.</span></span> <span data-ttu-id="d5796-358">Si les options par défaut ne sont pas réalisables, créez une nouvelle instance des options avec les paramètres dont vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="d5796-358">If the default options are not feasible, create a new instance of the options with the settings that you need.</span></span> <span data-ttu-id="d5796-359">Cette approche est lente puisque chaque nouvelle instance est mise en cache de façon indépendante.</span><span class="sxs-lookup"><span data-stu-id="d5796-359">This approach will be slow since each new instance caches independently.</span></span>

<span data-ttu-id="d5796-360">Il existe un autre modèle qui peut utiliser `JsonConverterAttribute` l’inscription sur la classe à convertir.</span><span class="sxs-lookup"><span data-stu-id="d5796-360">There is an alternative pattern that can use `JsonConverterAttribute` registration on the class to be converted.</span></span> <span data-ttu-id="d5796-361">Dans cette approche, le code de convertisseur appelle `Serialize` ou `Deserialize` sur une classe qui dérive de la classe à convertir.</span><span class="sxs-lookup"><span data-stu-id="d5796-361">In this approach, the converter code calls `Serialize` or `Deserialize` on a class that derives from the class to be converted.</span></span> <span data-ttu-id="d5796-362">Aucun n’est appliqué à la classe dérivée `JsonConverterAttribute` .</span><span class="sxs-lookup"><span data-stu-id="d5796-362">The derived class doesn't have a `JsonConverterAttribute` applied to it.</span></span> <span data-ttu-id="d5796-363">Dans l’exemple suivant de cette alternative :</span><span class="sxs-lookup"><span data-stu-id="d5796-363">In the following example of this alternative:</span></span>

* <span data-ttu-id="d5796-364">`WeatherForecastWithRequiredPropertyConverterAttribute` est la classe à désérialiser et auquel est `JsonConverterAttribute` appliqué.</span><span class="sxs-lookup"><span data-stu-id="d5796-364">`WeatherForecastWithRequiredPropertyConverterAttribute` is the class to be deserialized and has the `JsonConverterAttribute` applied to it.</span></span>
* <span data-ttu-id="d5796-365">`WeatherForecastWithoutRequiredPropertyConverterAttribute` est la classe dérivée qui n’a pas l’attribut de convertisseur.</span><span class="sxs-lookup"><span data-stu-id="d5796-365">`WeatherForecastWithoutRequiredPropertyConverterAttribute` is the derived class that doesn't have the converter attribute.</span></span>
* <span data-ttu-id="d5796-366">Le code dans le convertisseur appelle `Serialize` et `Deserialize` on `WeatherForecastWithoutRequiredPropertyConverterAttribute` pour éviter une boucle infinie.</span><span class="sxs-lookup"><span data-stu-id="d5796-366">The code in the converter calls `Serialize`and `Deserialize` on `WeatherForecastWithoutRequiredPropertyConverterAttribute` to avoid an infinite loop.</span></span> <span data-ttu-id="d5796-367">Cette approche présente une incidence sur les performances de la sérialisation en raison d’une instanciation d’objet supplémentaire et de la copie des valeurs de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5796-367">There is a performance cost to this approach on serialization due to an extra object instantiation and copying of property values.</span></span>

<span data-ttu-id="d5796-368">Voici les `WeatherForecast*` types :</span><span class="sxs-lookup"><span data-stu-id="d5796-368">Here are the `WeatherForecast*` types:</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/WeatherForecast.cs?name=SnippetWFWithReqPptyConverterAttr)]

<span data-ttu-id="d5796-369">Et voici le convertisseur :</span><span class="sxs-lookup"><span data-stu-id="d5796-369">And here is the converter:</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/WeatherForecastRequiredPropertyConverterForAttributeRegistration.cs)]

<span data-ttu-id="d5796-370">Le convertisseur de propriétés requis nécessiterait une logique supplémentaire si vous devez gérer des attributs tels que [[JsonIgnore]](xref:System.Text.Json.Serialization.JsonIgnoreAttribute) ou des options différentes, telles que des encodeurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="d5796-370">The required properties converter would require additional logic if you need to handle attributes such as [[JsonIgnore]](xref:System.Text.Json.Serialization.JsonIgnoreAttribute) or different options, such as custom encoders.</span></span> <span data-ttu-id="d5796-371">En outre, l’exemple de code ne gère pas les propriétés pour lesquelles une valeur par défaut est définie dans le constructeur.</span><span class="sxs-lookup"><span data-stu-id="d5796-371">Also, the example code doesn't handle properties for which a default value is set in the constructor.</span></span> <span data-ttu-id="d5796-372">Cette approche ne fait pas la différence entre les scénarios suivants :</span><span class="sxs-lookup"><span data-stu-id="d5796-372">And this approach doesn't differentiate between the following scenarios:</span></span>

* <span data-ttu-id="d5796-373">Une propriété est absente du JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-373">A property is missing from the JSON.</span></span>
* <span data-ttu-id="d5796-374">Une propriété pour un type non Nullable est présente dans le JSON, mais la valeur est la valeur par défaut pour le type, par exemple zéro pour un `int` .</span><span class="sxs-lookup"><span data-stu-id="d5796-374">A property for a non-nullable type is present in the JSON, but the value is the default for the type, such as zero for an `int`.</span></span>
* <span data-ttu-id="d5796-375">Une propriété pour un type valeur Nullable est présente dans le JSON, mais la valeur est null.</span><span class="sxs-lookup"><span data-stu-id="d5796-375">A property for a nullable value type is present in the JSON, but the value is null.</span></span>

### <a name="conditionally-ignore-a-property"></a><span data-ttu-id="d5796-376">Ignorer une propriété de façon conditionnelle</span><span class="sxs-lookup"><span data-stu-id="d5796-376">Conditionally ignore a property</span></span>

<span data-ttu-id="d5796-377">`Newtonsoft.Json` offre plusieurs méthodes pour ignorer de manière conditionnelle une propriété lors de la sérialisation ou de la désérialisation :</span><span class="sxs-lookup"><span data-stu-id="d5796-377">`Newtonsoft.Json` has several ways to conditionally ignore a property on serialization or deserialization:</span></span>

* <span data-ttu-id="d5796-378">`DefaultContractResolver` vous permet de sélectionner les propriétés à inclure ou exclure, en fonction de critères arbitraires.</span><span class="sxs-lookup"><span data-stu-id="d5796-378">`DefaultContractResolver` lets you select properties to include or exclude, based on arbitrary criteria.</span></span>
* <span data-ttu-id="d5796-379">Les `NullValueHandling` `DefaultValueHandling` paramètres et sur `JsonSerializerSettings` vous permettent de spécifier que toutes les propriétés de valeur null ou de valeur par défaut doivent être ignorées.</span><span class="sxs-lookup"><span data-stu-id="d5796-379">The `NullValueHandling` and `DefaultValueHandling` settings on `JsonSerializerSettings` let you specify that all null-value or default-value properties should be ignored.</span></span>
* <span data-ttu-id="d5796-380">Les `NullValueHandling` `DefaultValueHandling` paramètres et de l' `[JsonProperty]` attribut vous permettent de spécifier des propriétés individuelles qui doivent être ignorées lorsqu’elles sont définies sur null ou sur la valeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="d5796-380">The `NullValueHandling` and `DefaultValueHandling` settings on the `[JsonProperty]` attribute let you specify individual properties that should be ignored when set to null or the default value.</span></span>

<span data-ttu-id="d5796-381"><xref:System.Text.Json> fournit les méthodes suivantes pour omettre des propriétés lors de la sérialisation :</span><span class="sxs-lookup"><span data-stu-id="d5796-381"><xref:System.Text.Json> provides the following ways to omit properties while serializing:</span></span>

* <span data-ttu-id="d5796-382">L’attribut [[JsonIgnore]](system-text-json-how-to.md#exclude-individual-properties) sur une propriété provoque l’omission de la propriété du JSON pendant la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="d5796-382">The [[JsonIgnore]](system-text-json-how-to.md#exclude-individual-properties) attribute on a property causes the property to be omitted from the JSON during serialization.</span></span>
* <span data-ttu-id="d5796-383">L’option [IgnoreNullValues](system-text-json-how-to.md#exclude-all-null-value-properties) global vous permet d’exclure toutes les propriétés de valeur null.</span><span class="sxs-lookup"><span data-stu-id="d5796-383">The [IgnoreNullValues](system-text-json-how-to.md#exclude-all-null-value-properties) global option lets you exclude all null-value properties.</span></span>
* <span data-ttu-id="d5796-384">L’option [IgnoreReadOnlyProperties](system-text-json-how-to.md#exclude-all-read-only-properties) global vous permet d’exclure toutes les propriétés en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="d5796-384">The [IgnoreReadOnlyProperties](system-text-json-how-to.md#exclude-all-read-only-properties) global option lets you exclude all read-only properties.</span></span>

<span data-ttu-id="d5796-385">Ces options **ne** vous permettent pas de :</span><span class="sxs-lookup"><span data-stu-id="d5796-385">These options **don't** let you:</span></span>

* <span data-ttu-id="d5796-386">Ignore toutes les propriétés qui ont la valeur par défaut pour le type.</span><span class="sxs-lookup"><span data-stu-id="d5796-386">Ignore all properties that have the default value for the type.</span></span>
* <span data-ttu-id="d5796-387">Ignorer les propriétés sélectionnées qui ont la valeur par défaut pour le type.</span><span class="sxs-lookup"><span data-stu-id="d5796-387">Ignore selected properties that have the default value for the type.</span></span>
* <span data-ttu-id="d5796-388">Ignorer les propriétés sélectionnées si leur valeur est null.</span><span class="sxs-lookup"><span data-stu-id="d5796-388">Ignore selected properties if their value is null.</span></span>
* <span data-ttu-id="d5796-389">Ignorer les propriétés sélectionnées en fonction de critères arbitraires évalués au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="d5796-389">Ignore selected properties based on arbitrary criteria evaluated at run time.</span></span>

<span data-ttu-id="d5796-390">Pour cette fonctionnalité, vous pouvez écrire un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="d5796-390">For that functionality, you can write a custom converter.</span></span> <span data-ttu-id="d5796-391">Voici un exemple de modèle POCO et un convertisseur personnalisé qui illustre cette approche :</span><span class="sxs-lookup"><span data-stu-id="d5796-391">Here's a sample POCO and a custom converter for it that illustrates this approach:</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/WeatherForecast.cs?name=SnippetWF)]

[!code-csharp[](snippets/system-text-json-how-to/csharp/WeatherForecastRuntimeIgnoreConverter.cs)]

<span data-ttu-id="d5796-392">Le convertisseur fait en sorte que la `Summary` propriété soit omise de la sérialisation si sa valeur est null, une chaîne vide ou « N/A ».</span><span class="sxs-lookup"><span data-stu-id="d5796-392">The converter causes the `Summary` property to be omitted from serialization if its value is null, an empty string, or "N/A".</span></span>

<span data-ttu-id="d5796-393">Inscrivez ce convertisseur personnalisé à l' [aide d’un attribut sur la classe](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-type) ou en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span><span class="sxs-lookup"><span data-stu-id="d5796-393">Register this custom converter by [using an attribute on the class](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-type) or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="d5796-394">Cette approche nécessite une logique supplémentaire dans les cas suivants :</span><span class="sxs-lookup"><span data-stu-id="d5796-394">This approach requires additional logic if:</span></span>

* <span data-ttu-id="d5796-395">Le POCO comprend des propriétés complexes.</span><span class="sxs-lookup"><span data-stu-id="d5796-395">The POCO includes complex properties.</span></span>
* <span data-ttu-id="d5796-396">Vous devez gérer des attributs tels que `[JsonIgnore]` ou des options telles que des encodeurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="d5796-396">You need to handle attributes such as `[JsonIgnore]` or options such as custom encoders.</span></span>

### <a name="specify-date-format"></a><span data-ttu-id="d5796-397">Spécifier le format de la date</span><span class="sxs-lookup"><span data-stu-id="d5796-397">Specify date format</span></span>

<span data-ttu-id="d5796-398">`Newtonsoft.Json` offre plusieurs moyens de contrôler la façon dont les propriétés des `DateTime` `DateTimeOffset` types et sont sérialisées et désérialisées :</span><span class="sxs-lookup"><span data-stu-id="d5796-398">`Newtonsoft.Json` provides several ways to control how properties of `DateTime` and `DateTimeOffset` types are serialized and deserialized:</span></span>

* <span data-ttu-id="d5796-399">Le `DateTimeZoneHandling` paramètre peut être utilisé pour sérialiser toutes les `DateTime` valeurs en tant que dates UTC.</span><span class="sxs-lookup"><span data-stu-id="d5796-399">The `DateTimeZoneHandling` setting can be used to serialize all `DateTime` values as UTC dates.</span></span>
* <span data-ttu-id="d5796-400">Le `DateFormatString` paramètre et les `DateTime` convertisseurs peuvent être utilisés pour personnaliser le format des chaînes de date.</span><span class="sxs-lookup"><span data-stu-id="d5796-400">The `DateFormatString` setting and `DateTime` converters can be used to customize the format of date strings.</span></span>

<span data-ttu-id="d5796-401">Dans <xref:System.Text.Json> , le seul format qui offre une prise en charge intégrée est ISO 8601-1:2019, car il est largement adopté, sans ambiguïté, et effectue des allers-retours avec précision.</span><span class="sxs-lookup"><span data-stu-id="d5796-401">In <xref:System.Text.Json>, the only format that has built-in support is ISO 8601-1:2019 since it's widely adopted, unambiguous, and makes round trips precisely.</span></span> <span data-ttu-id="d5796-402">Pour utiliser n’importe quel autre format, créez un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="d5796-402">To use any other format, create a custom converter.</span></span> <span data-ttu-id="d5796-403">Pour plus d’informations, consultez [prise en charge des System.Text.Json valeurs DateTime et DateTimeOffset dans ](../datetime/system-text-json-support.md).</span><span class="sxs-lookup"><span data-stu-id="d5796-403">For more information, see [DateTime and DateTimeOffset support in System.Text.Json](../datetime/system-text-json-support.md).</span></span>

### <a name="callbacks"></a><span data-ttu-id="d5796-404">Rappels</span><span class="sxs-lookup"><span data-stu-id="d5796-404">Callbacks</span></span>

<span data-ttu-id="d5796-405">`Newtonsoft.Json` vous permet d’exécuter du code personnalisé à plusieurs points dans le processus de sérialisation ou de désérialisation :</span><span class="sxs-lookup"><span data-stu-id="d5796-405">`Newtonsoft.Json` lets you execute custom code at several points in the serialization or deserialization process:</span></span>

* <span data-ttu-id="d5796-406">OnDeserializing (au début de la désérialisation d’un objet)</span><span class="sxs-lookup"><span data-stu-id="d5796-406">OnDeserializing (when beginning to deserialize an object)</span></span>
* <span data-ttu-id="d5796-407">OnDeserialized (à la fin de la désérialisation d’un objet)</span><span class="sxs-lookup"><span data-stu-id="d5796-407">OnDeserialized (when finished deserializing an object)</span></span>
* <span data-ttu-id="d5796-408">OnSerializing (au début de la sérialisation d’un objet)</span><span class="sxs-lookup"><span data-stu-id="d5796-408">OnSerializing (when beginning to serialize an object)</span></span>
* <span data-ttu-id="d5796-409">OnSerialized (à la fin de la sérialisation d’un objet)</span><span class="sxs-lookup"><span data-stu-id="d5796-409">OnSerialized (when finished serializing an object)</span></span>

<span data-ttu-id="d5796-410">Dans <xref:System.Text.Json> , vous pouvez simuler des rappels en écrivant un convertisseur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="d5796-410">In <xref:System.Text.Json>, you can simulate callbacks by writing a custom converter.</span></span> <span data-ttu-id="d5796-411">L’exemple suivant montre un convertisseur personnalisé pour un POCO.</span><span class="sxs-lookup"><span data-stu-id="d5796-411">The following example shows a custom converter for a POCO.</span></span> <span data-ttu-id="d5796-412">Le convertisseur comprend du code qui affiche un message à chaque point qui correspond à un `Newtonsoft.Json` rappel.</span><span class="sxs-lookup"><span data-stu-id="d5796-412">The converter includes code that displays a message at each point that corresponds to a `Newtonsoft.Json` callback.</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/WeatherForecastCallbacksConverter.cs)]

<span data-ttu-id="d5796-413">Inscrivez ce convertisseur personnalisé en [ajoutant le convertisseur](system-text-json-converters-how-to.md#registration-sample---converters-collection) à la <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span><span class="sxs-lookup"><span data-stu-id="d5796-413">Register this custom converter by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="d5796-414">Si vous utilisez un convertisseur personnalisé qui suit l’exemple précédent :</span><span class="sxs-lookup"><span data-stu-id="d5796-414">If you use a custom converter that follows the preceding sample:</span></span>

* <span data-ttu-id="d5796-415">Le `OnDeserializing` code n’a pas accès à la nouvelle instance poco.</span><span class="sxs-lookup"><span data-stu-id="d5796-415">The `OnDeserializing` code doesn't have access to the new POCO instance.</span></span> <span data-ttu-id="d5796-416">Pour manipuler la nouvelle instance POCO au début de la désérialisation, placez ce code dans le constructeur POCO.</span><span class="sxs-lookup"><span data-stu-id="d5796-416">To manipulate the new POCO instance at the start of deserialization, put that code in the POCO constructor.</span></span>
* <span data-ttu-id="d5796-417">Évitez une boucle infinie en inscrivant le convertisseur dans l’objet d’options et en ne passant pas l’objet d’options lors de l’appel de `Serialize` ou de `Deserialize` .</span><span class="sxs-lookup"><span data-stu-id="d5796-417">Avoid an infinite loop by registering the converter in the options object and not passing in the options object when recursively calling `Serialize` or `Deserialize`.</span></span>

<span data-ttu-id="d5796-418">Pour plus d’informations sur les convertisseurs personnalisés qui appellent `Serialize` ou `Deserialize` , reportez-vous à la section [propriétés requises](#required-properties) , plus haut dans cet article.</span><span class="sxs-lookup"><span data-stu-id="d5796-418">For more information about custom converters that recursively call `Serialize` or `Deserialize`, see the [Required properties](#required-properties) section earlier in this article.</span></span>

### <a name="public-and-non-public-fields"></a><span data-ttu-id="d5796-419">Champs publics et non publics</span><span class="sxs-lookup"><span data-stu-id="d5796-419">Public and non-public fields</span></span>

<span data-ttu-id="d5796-420">`Newtonsoft.Json` peut sérialiser et désérialiser des champs ainsi que des propriétés.</span><span class="sxs-lookup"><span data-stu-id="d5796-420">`Newtonsoft.Json` can serialize and deserialize fields as well as properties.</span></span> <span data-ttu-id="d5796-421"><xref:System.Text.Json> fonctionne uniquement avec les propriétés publiques.</span><span class="sxs-lookup"><span data-stu-id="d5796-421"><xref:System.Text.Json> only works with public properties.</span></span> <span data-ttu-id="d5796-422">Les convertisseurs personnalisés peuvent fournir cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="d5796-422">Custom converters can provide this functionality.</span></span>

### <a name="internal-and-private-property-setters-and-getters"></a><span data-ttu-id="d5796-423">Accesseurs set et getters de propriétés internes et privées</span><span class="sxs-lookup"><span data-stu-id="d5796-423">Internal and private property setters and getters</span></span>

<span data-ttu-id="d5796-424">`Newtonsoft.Json` peut utiliser des accesseurs set et des accesseurs set de propriété privés et internes via l' `JsonProperty` attribut.</span><span class="sxs-lookup"><span data-stu-id="d5796-424">`Newtonsoft.Json` can use private and internal property setters and getters via the `JsonProperty` attribute.</span></span> <span data-ttu-id="d5796-425"><xref:System.Text.Json> prend uniquement en charge les accesseurs set publics.</span><span class="sxs-lookup"><span data-stu-id="d5796-425"><xref:System.Text.Json> supports only public setters.</span></span> <span data-ttu-id="d5796-426">Les convertisseurs personnalisés peuvent fournir cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="d5796-426">Custom converters can provide this functionality.</span></span>

### <a name="populate-existing-objects"></a><span data-ttu-id="d5796-427">Remplir les objets existants</span><span class="sxs-lookup"><span data-stu-id="d5796-427">Populate existing objects</span></span>

<span data-ttu-id="d5796-428">La `JsonConvert.PopulateObject` méthode de `Newtonsoft.Json` désérialise un document JSON vers une instance existante d’une classe, au lieu de créer une nouvelle instance.</span><span class="sxs-lookup"><span data-stu-id="d5796-428">The `JsonConvert.PopulateObject` method in `Newtonsoft.Json` deserializes a JSON document to an existing instance of a class, instead of creating a new instance.</span></span> <span data-ttu-id="d5796-429"><xref:System.Text.Json> crée toujours une nouvelle instance du type cible à l’aide du constructeur sans paramètre public par défaut.</span><span class="sxs-lookup"><span data-stu-id="d5796-429"><xref:System.Text.Json> always creates a new instance of the target type by using the default public parameterless constructor.</span></span> <span data-ttu-id="d5796-430">Les convertisseurs personnalisés peuvent être désérialisés en une instance existante.</span><span class="sxs-lookup"><span data-stu-id="d5796-430">Custom converters can deserialize to an existing instance.</span></span>

### <a name="reuse-rather-than-replace-properties"></a><span data-ttu-id="d5796-431">Réutiliser plutôt que remplacer les propriétés</span><span class="sxs-lookup"><span data-stu-id="d5796-431">Reuse rather than replace properties</span></span>

<span data-ttu-id="d5796-432">Le `Newtonsoft.Json` `ObjectCreationHandling` paramètre vous permet de spécifier que les objets dans les propriétés doivent être réutilisés au lieu d’être remplacés lors de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="d5796-432">The `Newtonsoft.Json` `ObjectCreationHandling` setting lets you specify that objects in properties should be reused rather than replaced during deserialization.</span></span> <span data-ttu-id="d5796-433"><xref:System.Text.Json> remplace toujours les objets dans les propriétés.</span><span class="sxs-lookup"><span data-stu-id="d5796-433"><xref:System.Text.Json> always replaces objects in properties.</span></span>  <span data-ttu-id="d5796-434">Les convertisseurs personnalisés peuvent fournir cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="d5796-434">Custom converters can provide this functionality.</span></span>

### <a name="add-to-collections-without-setters"></a><span data-ttu-id="d5796-435">Ajouter aux collections sans Setters</span><span class="sxs-lookup"><span data-stu-id="d5796-435">Add to collections without setters</span></span>

<span data-ttu-id="d5796-436">Pendant la désérialisation, `Newtonsoft.Json` ajoute des objets à une collection même si la propriété n’a pas d’accesseur Set.</span><span class="sxs-lookup"><span data-stu-id="d5796-436">During deserialization, `Newtonsoft.Json` adds objects to a collection even if the property has no setter.</span></span> <span data-ttu-id="d5796-437"><xref:System.Text.Json> ignore les propriétés qui n’ont pas de méthode setter.</span><span class="sxs-lookup"><span data-stu-id="d5796-437"><xref:System.Text.Json> ignores properties that don't have setters.</span></span> <span data-ttu-id="d5796-438">Les convertisseurs personnalisés peuvent fournir cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="d5796-438">Custom converters can provide this functionality.</span></span>

## <a name="scenarios-that-jsonserializer-currently-doesnt-support"></a><span data-ttu-id="d5796-439">Les scénarios que JsonSerializer ne prend pas en charge actuellement</span><span class="sxs-lookup"><span data-stu-id="d5796-439">Scenarios that JsonSerializer currently doesn't support</span></span>

<span data-ttu-id="d5796-440">Pour les scénarios suivants, les solutions de contournement ne sont pas pratiques ou possibles.</span><span class="sxs-lookup"><span data-stu-id="d5796-440">For the following scenarios, workarounds are not practical or possible.</span></span> <span data-ttu-id="d5796-441">Si vous utilisez ces `Newtonsoft.Json` fonctionnalités, la migration n’est pas possible sans modification significative.</span><span class="sxs-lookup"><span data-stu-id="d5796-441">If you rely on these `Newtonsoft.Json` features, migration will not be possible without significant changes.</span></span>

### <a name="preserve-object-references-and-handle-loops"></a><span data-ttu-id="d5796-442">Conserver les références d’objet et gérer les boucles</span><span class="sxs-lookup"><span data-stu-id="d5796-442">Preserve object references and handle loops</span></span>

<span data-ttu-id="d5796-443">Par défaut, `Newtonsoft.Json` sérialise par valeur.</span><span class="sxs-lookup"><span data-stu-id="d5796-443">By default, `Newtonsoft.Json` serializes by value.</span></span> <span data-ttu-id="d5796-444">Par exemple, si un objet contient deux propriétés qui contiennent une référence au même `Person` objet, les valeurs des propriétés de cet `Person` objet sont dupliquées dans le JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-444">For example, if an object contains two properties that contain a reference to the same `Person` object, the values of that `Person` object's properties are duplicated in the JSON.</span></span>

<span data-ttu-id="d5796-445">`Newtonsoft.Json` a un `PreserveReferencesHandling` paramètre sur `JsonSerializerSettings` qui vous permet de sérialiser par référence :</span><span class="sxs-lookup"><span data-stu-id="d5796-445">`Newtonsoft.Json` has a `PreserveReferencesHandling` setting on `JsonSerializerSettings` that lets you serialize by reference:</span></span>

* <span data-ttu-id="d5796-446">Les métadonnées d’identificateur sont ajoutées au JSON créé pour le premier `Person` objet.</span><span class="sxs-lookup"><span data-stu-id="d5796-446">An identifier metadata is added to the JSON created for the first `Person` object.</span></span>
* <span data-ttu-id="d5796-447">Le JSON créé pour le deuxième `Person` objet contient une référence à cet identificateur à la place des valeurs de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5796-447">The JSON that is created for the second `Person` object contains a reference to that identifier instead of property values.</span></span>

<span data-ttu-id="d5796-448">`Newtonsoft.Json` a également un `ReferenceLoopHandling` paramètre qui vous permet d’ignorer les références circulaires au lieu de lever une exception.</span><span class="sxs-lookup"><span data-stu-id="d5796-448">`Newtonsoft.Json` also has a `ReferenceLoopHandling` setting that lets you ignore circular references rather than throw an exception.</span></span>

<span data-ttu-id="d5796-449"><xref:System.Text.Json> prend uniquement en charge la sérialisation par valeur et lève une exception pour les références circulaires.</span><span class="sxs-lookup"><span data-stu-id="d5796-449"><xref:System.Text.Json> only supports serialization by value and throws an exception for circular references.</span></span>

### <a name="systemruntimeserialization-attributes"></a><span data-ttu-id="d5796-450">Attributs System. Runtime. Serialization</span><span class="sxs-lookup"><span data-stu-id="d5796-450">System.Runtime.Serialization attributes</span></span>

<span data-ttu-id="d5796-451"><xref:System.Text.Json> ne prend pas en charge les attributs de l' `System.Runtime.Serialization` espace de noms, tels que `DataMemberAttribute` et `IgnoreDataMemberAttribute` .</span><span class="sxs-lookup"><span data-stu-id="d5796-451"><xref:System.Text.Json> doesn't support attributes from the `System.Runtime.Serialization` namespace, such as `DataMemberAttribute` and `IgnoreDataMemberAttribute`.</span></span>

### <a name="octal-numbers"></a><span data-ttu-id="d5796-452">Nombres octaux</span><span class="sxs-lookup"><span data-stu-id="d5796-452">Octal numbers</span></span>

<span data-ttu-id="d5796-453">`Newtonsoft.Json` traite les nombres avec un zéro non significatif comme des nombres octaux.</span><span class="sxs-lookup"><span data-stu-id="d5796-453">`Newtonsoft.Json` treats numbers with a leading zero as octal numbers.</span></span> <span data-ttu-id="d5796-454"><xref:System.Text.Json> n’autorise pas les zéros non significatifs, car la spécification [RFC 8259](https://tools.ietf.org/html/rfc8259) ne les autorise pas.</span><span class="sxs-lookup"><span data-stu-id="d5796-454"><xref:System.Text.Json> doesn't allow leading zeroes because the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification doesn't allow them.</span></span>

### <a name="missingmemberhandling"></a><span data-ttu-id="d5796-455">MissingMemberHandling</span><span class="sxs-lookup"><span data-stu-id="d5796-455">MissingMemberHandling</span></span>

<span data-ttu-id="d5796-456">`Newtonsoft.Json` peut être configuré pour lever des exceptions pendant la désérialisation si le JSON comprend des propriétés qui sont manquantes dans le type cible.</span><span class="sxs-lookup"><span data-stu-id="d5796-456">`Newtonsoft.Json` can be configured to throw exceptions during deserialization if the JSON includes properties that are missing in the target type.</span></span> <span data-ttu-id="d5796-457"><xref:System.Text.Json> ignore les propriétés supplémentaires dans le JSON, sauf lorsque vous utilisez l' [attribut [JsonExtensionData]](system-text-json-how-to.md#handle-overflow-json).</span><span class="sxs-lookup"><span data-stu-id="d5796-457"><xref:System.Text.Json> ignores extra properties in the JSON, except when you use the [[JsonExtensionData] attribute](system-text-json-how-to.md#handle-overflow-json).</span></span> <span data-ttu-id="d5796-458">Il n’existe aucune solution de contournement pour la fonctionnalité de membre manquant.</span><span class="sxs-lookup"><span data-stu-id="d5796-458">There's no workaround for the missing member feature.</span></span>

### <a name="tracewriter"></a><span data-ttu-id="d5796-459">TraceWriter</span><span class="sxs-lookup"><span data-stu-id="d5796-459">TraceWriter</span></span>

<span data-ttu-id="d5796-460">`Newtonsoft.Json` vous permet de déboguer à l’aide d’un `TraceWriter` pour afficher les journaux qui sont générés par la sérialisation ou la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="d5796-460">`Newtonsoft.Json` lets you debug by using a `TraceWriter` to view logs that are generated by serialization or deserialization.</span></span> <span data-ttu-id="d5796-461"><xref:System.Text.Json> n’effectue pas de journalisation.</span><span class="sxs-lookup"><span data-stu-id="d5796-461"><xref:System.Text.Json> doesn't do logging.</span></span>

## <a name="jsondocument-and-jsonelement-compared-to-jtoken-like-jobject-jarray"></a><span data-ttu-id="d5796-462">JsonDocument et JsonElement comparés à JToken (comme JObject, JArray)</span><span class="sxs-lookup"><span data-stu-id="d5796-462">JsonDocument and JsonElement compared to JToken (like JObject, JArray)</span></span>

<span data-ttu-id="d5796-463"><xref:System.Text.Json.JsonDocument?displayProperty=fullName> permet d’analyser et de générer un Document Object Model **en lecture seule** (DOM) à partir de charges utiles JSON existantes.</span><span class="sxs-lookup"><span data-stu-id="d5796-463"><xref:System.Text.Json.JsonDocument?displayProperty=fullName> provides the ability to parse and build a **read-only** Document Object Model (DOM) from existing JSON payloads.</span></span> <span data-ttu-id="d5796-464">Le DOM fournit un accès aléatoire aux données dans une charge utile JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-464">The DOM provides random access to data in a JSON payload.</span></span> <span data-ttu-id="d5796-465">Les éléments JSON qui composent la charge utile sont accessibles via le <xref:System.Text.Json.JsonElement> type.</span><span class="sxs-lookup"><span data-stu-id="d5796-465">The JSON elements that compose the payload can be accessed via the <xref:System.Text.Json.JsonElement> type.</span></span> <span data-ttu-id="d5796-466">Le `JsonElement` type fournit des API pour convertir du texte JSON en types .net courants.</span><span class="sxs-lookup"><span data-stu-id="d5796-466">The `JsonElement` type provides APIs to convert JSON text to common .NET types.</span></span> <span data-ttu-id="d5796-467">`JsonDocument` expose une <xref:System.Text.Json.JsonDocument.RootElement> propriété.</span><span class="sxs-lookup"><span data-stu-id="d5796-467">`JsonDocument` exposes a <xref:System.Text.Json.JsonDocument.RootElement> property.</span></span>

### <a name="jsondocument-is-idisposable"></a><span data-ttu-id="d5796-468">JsonDocument est IDisposable</span><span class="sxs-lookup"><span data-stu-id="d5796-468">JsonDocument is IDisposable</span></span>

<span data-ttu-id="d5796-469">`JsonDocument` crée une vue en mémoire des données dans une mémoire tampon regroupée.</span><span class="sxs-lookup"><span data-stu-id="d5796-469">`JsonDocument` builds an in-memory view of the data into a pooled buffer.</span></span> <span data-ttu-id="d5796-470">Par conséquent, `JObject` contrairement `JArray` à ou `Newtonsoft.Json` , le `JsonDocument` type implémente `IDisposable` et doit être utilisé à l’intérieur d’un bloc using.</span><span class="sxs-lookup"><span data-stu-id="d5796-470">Therefore, unlike `JObject` or `JArray` from `Newtonsoft.Json`, the `JsonDocument` type implements `IDisposable` and needs to be used inside a using block.</span></span>

<span data-ttu-id="d5796-471">Retournez uniquement un `JsonDocument` à partir de votre API si vous souhaitez transférer la propriété de la durée de vie et supprimer la responsabilité de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="d5796-471">Only return a `JsonDocument` from your API if you want to transfer lifetime ownership and dispose responsibility to the caller.</span></span> <span data-ttu-id="d5796-472">Dans la plupart des scénarios, ce n’est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="d5796-472">In most scenarios, that isn't necessary.</span></span> <span data-ttu-id="d5796-473">Si l’appelant doit travailler avec l’ensemble du document JSON, retournez le <xref:System.Text.Json.JsonElement.Clone%2A> du <xref:System.Text.Json.JsonDocument.RootElement%2A> , qui est un <xref:System.Text.Json.JsonElement> .</span><span class="sxs-lookup"><span data-stu-id="d5796-473">If the caller needs to work with the entire JSON document, return the <xref:System.Text.Json.JsonElement.Clone%2A> of the <xref:System.Text.Json.JsonDocument.RootElement%2A>, which is a <xref:System.Text.Json.JsonElement>.</span></span> <span data-ttu-id="d5796-474">Si l’appelant doit travailler avec un élément particulier dans le document JSON, retournez le <xref:System.Text.Json.JsonElement.Clone%2A> de ce <xref:System.Text.Json.JsonElement> .</span><span class="sxs-lookup"><span data-stu-id="d5796-474">If the caller needs to work with a particular element within the JSON document, return the <xref:System.Text.Json.JsonElement.Clone%2A> of that <xref:System.Text.Json.JsonElement>.</span></span> <span data-ttu-id="d5796-475">Si vous retournez `RootElement` directement le ou un sous-élément sans créer de `Clone` , l’appelant ne pourra pas accéder au retourné `JsonElement` après que le qui l’a détenu `JsonDocument` est supprimé.</span><span class="sxs-lookup"><span data-stu-id="d5796-475">If you return the `RootElement` or a sub-element directly without making a `Clone`, the caller won't be able to access the returned `JsonElement` after the `JsonDocument` that owns it is disposed.</span></span>

<span data-ttu-id="d5796-476">Voici un exemple qui vous oblige à créer un `Clone` :</span><span class="sxs-lookup"><span data-stu-id="d5796-476">Here's an example that requires you to make a `Clone`:</span></span>

```csharp
public JsonElement LookAndLoad(JsonElement source)
{
    string json = File.ReadAllText(source.GetProperty("fileName").GetString());

    using (JsonDocument doc = JsonDocument.Parse(json))
    {
        return doc.RootElement.Clone();
    }
}
```

<span data-ttu-id="d5796-477">Le code précédent attend un `JsonElement` qui contient une `fileName` propriété.</span><span class="sxs-lookup"><span data-stu-id="d5796-477">The preceding code expects a `JsonElement` that contains a `fileName` property.</span></span> <span data-ttu-id="d5796-478">Il ouvre le fichier JSON et crée un `JsonDocument` .</span><span class="sxs-lookup"><span data-stu-id="d5796-478">It opens the JSON file and creates a `JsonDocument`.</span></span> <span data-ttu-id="d5796-479">La méthode suppose que l’appelant souhaite travailler avec l’ensemble du document, de sorte qu’il retourne l' `Clone` du `RootElement` .</span><span class="sxs-lookup"><span data-stu-id="d5796-479">The method assumes that the caller wants to work with the entire document, so it returns the `Clone` of the `RootElement`.</span></span>

<span data-ttu-id="d5796-480">Si vous recevez un `JsonElement` et que vous retournez un sous-élément, il n’est pas nécessaire de retourner un `Clone` du sous-élément.</span><span class="sxs-lookup"><span data-stu-id="d5796-480">If you receive a `JsonElement` and are returning a sub-element, it's not necessary to return a `Clone` of the sub-element.</span></span> <span data-ttu-id="d5796-481">L’appelant est chargé de conserver les actifs `JsonDocument` auxquels appartient le passé `JsonElement` .</span><span class="sxs-lookup"><span data-stu-id="d5796-481">The caller is responsible for keeping alive the `JsonDocument` that the passed-in `JsonElement` belongs to.</span></span> <span data-ttu-id="d5796-482">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="d5796-482">For example:</span></span>

```csharp
public JsonElement ReturnFileName(JsonElement source)
{
   return source.GetProperty("fileName");
}
```

### <a name="jsondocument-is-read-only"></a><span data-ttu-id="d5796-483">JsonDocument est en lecture seule</span><span class="sxs-lookup"><span data-stu-id="d5796-483">JsonDocument is read-only</span></span>

<span data-ttu-id="d5796-484">Le <xref:System.Text.Json> DOM ne peut pas ajouter, supprimer ou modifier des éléments JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-484">The <xref:System.Text.Json> DOM can't add, remove, or modify JSON elements.</span></span> <span data-ttu-id="d5796-485">Cette méthode est conçue pour les performances et pour réduire les allocations pour l’analyse des tailles de charge utile JSON courantes (c’est-à-dire < 1 Mo).</span><span class="sxs-lookup"><span data-stu-id="d5796-485">It's designed this way for performance and to reduce allocations for parsing common JSON payload sizes (that is, < 1 MB).</span></span> <span data-ttu-id="d5796-486">Si votre scénario utilise actuellement un modèle DOM modifiable, l’une des solutions de contournement suivantes peut être possible :</span><span class="sxs-lookup"><span data-stu-id="d5796-486">If your scenario currently uses a modifiable DOM, one of the following workarounds might be feasible:</span></span>

* <span data-ttu-id="d5796-487">Pour créer un `JsonDocument` à partir de zéro (autrement dit, sans passer une charge utile JSON existante à la `Parse` méthode), écrivez le texte JSON à l’aide de `Utf8JsonWriter` et analysez la sortie de cette pour créer un nouveau `JsonDocument` .</span><span class="sxs-lookup"><span data-stu-id="d5796-487">To build a `JsonDocument` from scratch (that is, without passing in an existing JSON payload to the `Parse` method), write the JSON text by using the `Utf8JsonWriter` and parse the output from that to make a new `JsonDocument`.</span></span>
* <span data-ttu-id="d5796-488">Pour modifier un existant `JsonDocument` , utilisez-le pour écrire du texte JSON, apporter des modifications pendant que vous écrivez et analyser la sortie de celle-ci pour en créer une nouvelle `JsonDocument` .</span><span class="sxs-lookup"><span data-stu-id="d5796-488">To modify an existing `JsonDocument`, use it to write JSON text, making changes while you write, and parse the output from that to make a new `JsonDocument`.</span></span>
* <span data-ttu-id="d5796-489">Pour fusionner des documents JSON existants, équivalents aux `JObject.Merge` `JContainer.Merge` API ou de `Newtonsoft.Json` , consultez [ce problème GitHub](https://github.com/dotnet/corefx/issues/42466#issuecomment-570475853).</span><span class="sxs-lookup"><span data-stu-id="d5796-489">To merge existing JSON documents, equivalent to the `JObject.Merge` or `JContainer.Merge` APIs from `Newtonsoft.Json`, see [this GitHub issue](https://github.com/dotnet/corefx/issues/42466#issuecomment-570475853).</span></span>

### <a name="jsonelement-is-a-union-struct"></a><span data-ttu-id="d5796-490">JsonElement est un struct d’Union</span><span class="sxs-lookup"><span data-stu-id="d5796-490">JsonElement is a union struct</span></span>

<span data-ttu-id="d5796-491">`JsonDocument` expose le `RootElement` en tant que propriété de type <xref:System.Text.Json.JsonElement> , qui est une Union, type struct qui englobe tout élément JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-491">`JsonDocument` exposes the `RootElement` as a property of type <xref:System.Text.Json.JsonElement>, which is a union, struct type that encompasses any JSON element.</span></span> <span data-ttu-id="d5796-492">`Newtonsoft.Json` utilise des types hiérarchiques dédiés comme `JObject` ,, `JArray` `JToken` , et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="d5796-492">`Newtonsoft.Json` uses dedicated hierarchical types like `JObject`,`JArray`, `JToken`, and so forth.</span></span> <span data-ttu-id="d5796-493">`JsonElement` est ce que vous pouvez rechercher et énumérer, et vous pouvez utiliser `JsonElement` pour matérialiser des éléments JSON dans des types .net.</span><span class="sxs-lookup"><span data-stu-id="d5796-493">`JsonElement` is what you can search and enumerate over, and you can use `JsonElement` to materialize JSON elements into .NET types.</span></span>

### <a name="how-to-search-a-jsondocument-and-jsonelement-for-sub-elements"></a><span data-ttu-id="d5796-494">Comment rechercher des sous-éléments dans un JsonDocument et JsonElement</span><span class="sxs-lookup"><span data-stu-id="d5796-494">How to search a JsonDocument and JsonElement for sub-elements</span></span>

<span data-ttu-id="d5796-495">Les recherches de jetons JSON utilisant `JObject` ou `JArray` de `Newtonsoft.Json` ont tendance à être relativement rapides parce qu’il s’agit de recherches dans un dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="d5796-495">Searches for JSON tokens using `JObject` or `JArray` from `Newtonsoft.Json` tend to be relatively fast because they're lookups in some dictionary.</span></span> <span data-ttu-id="d5796-496">Par comparaison, les recherches sur `JsonElement` requièrent une recherche séquentielle des propriétés et sont donc relativement lentes (par exemple, lors de l’utilisation de `TryGetProperty` ).</span><span class="sxs-lookup"><span data-stu-id="d5796-496">By comparison, searches on `JsonElement` require a sequential search of the properties and hence is relatively slow (for example when using `TryGetProperty`).</span></span> <span data-ttu-id="d5796-497"><xref:System.Text.Json> est conçu pour réduire le temps d’analyse initial plutôt que le temps de recherche.</span><span class="sxs-lookup"><span data-stu-id="d5796-497"><xref:System.Text.Json> is designed to minimize initial parse time rather than lookup time.</span></span> <span data-ttu-id="d5796-498">Par conséquent, utilisez les approches suivantes pour optimiser les performances lors de la recherche à l’aide d’un `JsonDocument` objet :</span><span class="sxs-lookup"><span data-stu-id="d5796-498">Therefore, use the following approaches to optimize performance when searching through a `JsonDocument` object:</span></span>

* <span data-ttu-id="d5796-499">Utilisez les énumérateurs intégrés ( <xref:System.Text.Json.JsonElement.EnumerateArray%2A> et <xref:System.Text.Json.JsonElement.EnumerateObject%2A> ) au lieu d’effectuer votre propre indexation ou boucles.</span><span class="sxs-lookup"><span data-stu-id="d5796-499">Use the built-in enumerators (<xref:System.Text.Json.JsonElement.EnumerateArray%2A> and <xref:System.Text.Json.JsonElement.EnumerateObject%2A>) rather than doing your own indexing or loops.</span></span>
* <span data-ttu-id="d5796-500">N’effectuez pas de recherche séquentielle sur l’ensemble de `JsonDocument` chaque propriété à l’aide de `RootElement` .</span><span class="sxs-lookup"><span data-stu-id="d5796-500">Don't do a sequential search on the whole `JsonDocument` through every property by using `RootElement`.</span></span> <span data-ttu-id="d5796-501">Au lieu de cela, recherchez des objets JSON imbriqués en fonction de la structure connue des données JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-501">Instead, search on nested JSON objects based on the known structure of the JSON data.</span></span> <span data-ttu-id="d5796-502">Par exemple, si vous recherchez une `Grade` propriété dans des objets, parcourez `Student` les `Student` objets et récupérez la valeur de `Grade` pour chaque, plutôt que de rechercher dans tous les objets à la `JsonElement` recherche de `Grade` Propriétés.</span><span class="sxs-lookup"><span data-stu-id="d5796-502">For example, if you're looking for a `Grade` property in `Student` objects, loop through the `Student` objects and get the value of `Grade` for each, rather than searching through all `JsonElement` objects looking for `Grade` properties.</span></span> <span data-ttu-id="d5796-503">Si vous procédez ainsi, vous obtiendrez des passes inutiles sur les mêmes données.</span><span class="sxs-lookup"><span data-stu-id="d5796-503">Doing the latter will result in unnecessary passes over the same data.</span></span>

<span data-ttu-id="d5796-504">Pour obtenir un exemple de code, consultez [utiliser JsonDocument pour accéder aux données](system-text-json-how-to.md#use-jsondocument-for-access-to-data).</span><span class="sxs-lookup"><span data-stu-id="d5796-504">For a code example, see [Use JsonDocument for access to data](system-text-json-how-to.md#use-jsondocument-for-access-to-data).</span></span>

## <a name="utf8jsonreader-compared-to-jsontextreader"></a><span data-ttu-id="d5796-505">Utf8JsonReader comparé à JsonTextReader</span><span class="sxs-lookup"><span data-stu-id="d5796-505">Utf8JsonReader compared to JsonTextReader</span></span>

<span data-ttu-id="d5796-506"><xref:System.Text.Json.Utf8JsonReader?displayProperty=fullName>est un lecteur haute performance, à faible allocation et en avant uniquement pour le texte JSON encodé en UTF-8, lu à partir d’un [ReadOnlySpan \<byte> ](xref:System.ReadOnlySpan%601) ou d’un [ReadOnlySequence \<byte> ](xref:System.Buffers.ReadOnlySequence%601).</span><span class="sxs-lookup"><span data-stu-id="d5796-506"><xref:System.Text.Json.Utf8JsonReader?displayProperty=fullName> is a high-performance, low allocation, forward-only reader for UTF-8 encoded JSON text, read from a [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601) or [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601).</span></span> <span data-ttu-id="d5796-507">Le `Utf8JsonReader` est un type de bas niveau qui peut être utilisé pour créer des analyseurs et des désérialiseurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="d5796-507">The `Utf8JsonReader` is a low-level type that can be used to build custom parsers and deserializers.</span></span>

<span data-ttu-id="d5796-508">Les sections suivantes expliquent les modèles de programmation recommandés pour l’utilisation de `Utf8JsonReader` .</span><span class="sxs-lookup"><span data-stu-id="d5796-508">The following sections explain recommended programming patterns for using `Utf8JsonReader`.</span></span>

### <a name="utf8jsonreader-is-a-ref-struct"></a><span data-ttu-id="d5796-509">Utf8JsonReader est un struct Ref</span><span class="sxs-lookup"><span data-stu-id="d5796-509">Utf8JsonReader is a ref struct</span></span>

<span data-ttu-id="d5796-510">Étant donné que le `Utf8JsonReader` type est un *struct de référence*, il présente [certaines limitations](../../csharp/language-reference/builtin-types/struct.md#ref-struct).</span><span class="sxs-lookup"><span data-stu-id="d5796-510">Because the `Utf8JsonReader` type is a *ref struct*, it has [certain limitations](../../csharp/language-reference/builtin-types/struct.md#ref-struct).</span></span> <span data-ttu-id="d5796-511">Par exemple, il ne peut pas être stocké en tant que champ sur une classe ou un struct autre qu’un struct Ref.</span><span class="sxs-lookup"><span data-stu-id="d5796-511">For example, it can't be stored as a field on a class or struct other than a ref struct.</span></span> <span data-ttu-id="d5796-512">Pour obtenir des performances élevées, ce type doit être un, `ref struct` car il doit mettre en cache le [ReadOnlySpan \<byte> ](xref:System.ReadOnlySpan%601)d’entrée, qui est lui-même un struct de référence.</span><span class="sxs-lookup"><span data-stu-id="d5796-512">To achieve high performance, this type must be a `ref struct` since it needs to cache the input [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601), which itself is a ref struct.</span></span> <span data-ttu-id="d5796-513">En outre, ce type est mutable puisqu’il contient l’État.</span><span class="sxs-lookup"><span data-stu-id="d5796-513">In addition, this type is mutable since it holds state.</span></span> <span data-ttu-id="d5796-514">Par conséquent, **transmettez-le par référence** plutôt que par valeur.</span><span class="sxs-lookup"><span data-stu-id="d5796-514">Therefore, **pass it by ref** rather than by value.</span></span> <span data-ttu-id="d5796-515">Le fait de le passer par valeur génère une copie de struct et les modifications d’État ne sont pas visibles par l’appelant.</span><span class="sxs-lookup"><span data-stu-id="d5796-515">Passing it by value would result in a struct copy and the state changes would not be visible to the caller.</span></span> <span data-ttu-id="d5796-516">Cela diffère de `Newtonsoft.Json` puisque `Newtonsoft.Json` `JsonTextReader` est une classe.</span><span class="sxs-lookup"><span data-stu-id="d5796-516">This differs from `Newtonsoft.Json` since the `Newtonsoft.Json` `JsonTextReader` is a class.</span></span> <span data-ttu-id="d5796-517">Pour plus d’informations sur l’utilisation des structs de référence, consultez [écrire du code C# sécurisé et efficace](../../csharp/write-safe-efficient-code.md).</span><span class="sxs-lookup"><span data-stu-id="d5796-517">For more information about how to use ref structs, see [Write safe and efficient C# code](../../csharp/write-safe-efficient-code.md).</span></span>

### <a name="read-utf-8-text"></a><span data-ttu-id="d5796-518">Lire du texte UTF-8</span><span class="sxs-lookup"><span data-stu-id="d5796-518">Read UTF-8 text</span></span>

<span data-ttu-id="d5796-519">Pour obtenir les meilleures performances possibles lors de l’utilisation de `Utf8JsonReader` , lisez les charges utiles JSON déjà encodées en tant que texte UTF-8 plutôt qu’en tant que chaînes UTF-16.</span><span class="sxs-lookup"><span data-stu-id="d5796-519">To achieve the best possible performance while using the `Utf8JsonReader`, read JSON payloads already encoded as UTF-8 text rather than as UTF-16 strings.</span></span> <span data-ttu-id="d5796-520">Pour obtenir un exemple de code, consultez [Filtrer les données à l’aide de Utf8JsonReader](system-text-json-how-to.md#filter-data-using-utf8jsonreader).</span><span class="sxs-lookup"><span data-stu-id="d5796-520">For a code example, see [Filter data using Utf8JsonReader](system-text-json-how-to.md#filter-data-using-utf8jsonreader).</span></span>

### <a name="read-with-a-stream-or-pipereader"></a><span data-ttu-id="d5796-521">Lire avec un flux ou un PipeReader</span><span class="sxs-lookup"><span data-stu-id="d5796-521">Read with a Stream or PipeReader</span></span>

<span data-ttu-id="d5796-522">`Utf8JsonReader`Prend en charge la lecture à partir d’un [ReadOnlySpan \<byte> ](xref:System.ReadOnlySpan%601) ou d’un [ReadOnlySequence \<byte> ](xref:System.Buffers.ReadOnlySequence%601) encodé UTF-8 (qui est le résultat de la lecture à partir d’un <xref:System.IO.Pipelines.PipeReader> ).</span><span class="sxs-lookup"><span data-stu-id="d5796-522">The `Utf8JsonReader` supports reading from a UTF-8 encoded [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601) or [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601) (which is the result of reading from a <xref:System.IO.Pipelines.PipeReader>).</span></span>

<span data-ttu-id="d5796-523">Pour la lecture synchrone, vous pouvez lire la charge utile JSON jusqu’à la fin du flux dans un tableau d’octets et la passer dans le lecteur.</span><span class="sxs-lookup"><span data-stu-id="d5796-523">For synchronous reading, you could read the JSON payload until the end of the stream into a byte array and pass that into the reader.</span></span> <span data-ttu-id="d5796-524">Pour lire à partir d’une chaîne (qui est encodée au format UTF-16), appelez <xref:System.Text.Encoding.UTF8> .<xref:System.Text.Encoding.GetBytes%2A></span><span class="sxs-lookup"><span data-stu-id="d5796-524">For reading from a string (which is encoded as UTF-16), call <xref:System.Text.Encoding.UTF8>.<xref:System.Text.Encoding.GetBytes%2A></span></span> <span data-ttu-id="d5796-525">pour tout d’abord transcoder la chaîne en un tableau d’octets encodé en UTF-8.</span><span class="sxs-lookup"><span data-stu-id="d5796-525">to first transcode the string to a UTF-8 encoded byte array.</span></span> <span data-ttu-id="d5796-526">Ensuite, transmettez-le à `Utf8JsonReader` .</span><span class="sxs-lookup"><span data-stu-id="d5796-526">Then pass that to the `Utf8JsonReader`.</span></span>

<span data-ttu-id="d5796-527">Étant donné que le `Utf8JsonReader` considère que l’entrée est du texte JSON, une marque d’ordre d’octet (BOM) UTF-8 est considérée comme un JSON non valide.</span><span class="sxs-lookup"><span data-stu-id="d5796-527">Since the `Utf8JsonReader` considers the input to be JSON text, a UTF-8 byte order mark (BOM) is considered invalid JSON.</span></span> <span data-ttu-id="d5796-528">L’appelant doit filtrer ce dernier avant de passer les données au lecteur.</span><span class="sxs-lookup"><span data-stu-id="d5796-528">The caller needs to filter that out before passing the data to the reader.</span></span>

<span data-ttu-id="d5796-529">Pour obtenir des exemples de code, consultez [use Utf8JsonReader](system-text-json-how-to.md#use-utf8jsonreader).</span><span class="sxs-lookup"><span data-stu-id="d5796-529">For code examples, see [Use Utf8JsonReader](system-text-json-how-to.md#use-utf8jsonreader).</span></span>

### <a name="read-with-multi-segment-readonlysequence"></a><span data-ttu-id="d5796-530">Lecture avec ReadOnlySequence à plusieurs segments</span><span class="sxs-lookup"><span data-stu-id="d5796-530">Read with multi-segment ReadOnlySequence</span></span>

<span data-ttu-id="d5796-531">Si votre entrée JSON est un [ReadOnlySpan \<byte> ](xref:System.ReadOnlySpan%601), chaque élément JSON est accessible à partir de la `ValueSpan` propriété sur le lecteur au fur et à mesure que vous parcourez la boucle de lecture.</span><span class="sxs-lookup"><span data-stu-id="d5796-531">If your JSON input is a [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601), each JSON element can be accessed from the `ValueSpan` property on the reader as you go through the read loop.</span></span> <span data-ttu-id="d5796-532">Toutefois, si votre entrée est un [ReadOnlySequence \<byte> ](xref:System.Buffers.ReadOnlySequence%601) (qui est le résultat de la lecture à partir d’un <xref:System.IO.Pipelines.PipeReader> ), certains éléments JSON peuvent chevaucher plusieurs segments de l' `ReadOnlySequence<byte>` objet.</span><span class="sxs-lookup"><span data-stu-id="d5796-532">However, if your input is a [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601) (which is the result of reading from a <xref:System.IO.Pipelines.PipeReader>), some JSON elements might straddle multiple segments of the `ReadOnlySequence<byte>` object.</span></span> <span data-ttu-id="d5796-533">Ces éléments ne sont pas accessibles à partir d' <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> un bloc de mémoire contigu.</span><span class="sxs-lookup"><span data-stu-id="d5796-533">These elements would not be accessible from <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> in a contiguous memory block.</span></span> <span data-ttu-id="d5796-534">Au lieu de cela, chaque fois que vous avez un segment multiple `ReadOnlySequence<byte>` comme entrée, interrogez la <xref:System.Text.Json.Utf8JsonReader.HasValueSequence%2A> propriété sur le lecteur pour déterminer comment accéder à l’élément JSON actuel.</span><span class="sxs-lookup"><span data-stu-id="d5796-534">Instead, whenever you have a multi-segment `ReadOnlySequence<byte>` as input, poll the <xref:System.Text.Json.Utf8JsonReader.HasValueSequence%2A> property on the reader to figure out how to access the current JSON element.</span></span> <span data-ttu-id="d5796-535">Voici un modèle recommandé :</span><span class="sxs-lookup"><span data-stu-id="d5796-535">Here's a recommended pattern:</span></span>

```csharp
while (reader.Read())
{
    switch (reader.TokenType)
    {
        // ...
        ReadOnlySpan<byte> jsonElement = reader.HasValueSequence ?
            reader.ValueSequence.ToArray() :
            reader.ValueSpan;
        // ...
    }
}
```

### <a name="use-valuetextequals-for-property-name-lookups"></a><span data-ttu-id="d5796-536">Utiliser ValueTextEquals pour les recherches de nom de propriété</span><span class="sxs-lookup"><span data-stu-id="d5796-536">Use ValueTextEquals for property name lookups</span></span>

<span data-ttu-id="d5796-537">N’utilisez pas <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> pour effectuer des comparaisons octet par octet en appelant <xref:System.MemoryExtensions.SequenceEqual%2A> pour les recherches de nom de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5796-537">Don't use <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> to do byte-by-byte comparisons by calling <xref:System.MemoryExtensions.SequenceEqual%2A> for property name lookups.</span></span> <span data-ttu-id="d5796-538">Appelez <xref:System.Text.Json.Utf8JsonReader.ValueTextEquals%2A> à la place, car cette méthode annule l’échappement des caractères échappés dans le JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-538">Call <xref:System.Text.Json.Utf8JsonReader.ValueTextEquals%2A> instead, because that method unescapes any characters that are escaped in the JSON.</span></span> <span data-ttu-id="d5796-539">Voici un exemple qui montre comment rechercher une propriété nommée « Name » :</span><span class="sxs-lookup"><span data-stu-id="d5796-539">Here's an example that shows how to search for a property that is named "name":</span></span>

[!code-csharp[](snippets/system-text-json-how-to/csharp/ValueTextEqualsExample.cs?name=SnippetDefineUtf8Var)]

[!code-csharp[](snippets/system-text-json-how-to/csharp/ValueTextEqualsExample.cs?name=SnippetUseUtf8Var&highlight=11)]

### <a name="read-null-values-into-nullable-value-types"></a><span data-ttu-id="d5796-540">Lire les valeurs NULL dans les types valeur Nullable</span><span class="sxs-lookup"><span data-stu-id="d5796-540">Read null values into nullable value types</span></span>

<span data-ttu-id="d5796-541">`Newtonsoft.Json` fournit des API qui retournent <xref:System.Nullable%601> , telles que `ReadAsBoolean` , qui gère un `Null` `TokenType` pour vous en retournant un `bool?` .</span><span class="sxs-lookup"><span data-stu-id="d5796-541">`Newtonsoft.Json` provides APIs that return <xref:System.Nullable%601>, such as `ReadAsBoolean`, which handles a `Null` `TokenType` for you by returning a `bool?`.</span></span> <span data-ttu-id="d5796-542">Les `System.Text.Json` API intégrées retournent uniquement des types valeur n’acceptant pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="d5796-542">The built-in `System.Text.Json` APIs return only non-nullable value types.</span></span> <span data-ttu-id="d5796-543">Par exemple, <xref:System.Text.Json.Utf8JsonReader.GetBoolean%2A?displayProperty=nameWithType> retourne un `bool` .</span><span class="sxs-lookup"><span data-stu-id="d5796-543">For example, <xref:System.Text.Json.Utf8JsonReader.GetBoolean%2A?displayProperty=nameWithType> returns a `bool`.</span></span> <span data-ttu-id="d5796-544">Elle lève une exception si elle trouve `Null` dans le JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-544">It throws an exception if it finds `Null` in the JSON.</span></span> <span data-ttu-id="d5796-545">Les exemples suivants illustrent deux façons de gérer les valeurs NULL, l’une en retournant un type valeur Nullable et l’autre en retournant la valeur par défaut :</span><span class="sxs-lookup"><span data-stu-id="d5796-545">The following examples show two ways to handle nulls, one by returning a nullable value type and one by returning the default value:</span></span>

```csharp
public bool? ReadAsNullableBoolean()
{
    _reader.Read();
    if (_reader.TokenType == JsonTokenType.Null)
    {
        return null;
    }
    if (_reader.TokenType != JsonTokenType.True && _reader.TokenType != JsonTokenType.False)
    {
        throw new JsonException();
    }
    return _reader.GetBoolean();
}
```

```csharp
public bool ReadAsBoolean(bool defaultValue)
{
    _reader.Read();
    if (_reader.TokenType == JsonTokenType.Null)
    {
        return defaultValue;
    }
    if (_reader.TokenType != JsonTokenType.True && _reader.TokenType != JsonTokenType.False)
    {
        throw new JsonException();
    }
    return _reader.GetBoolean();
}
```

### <a name="multi-targeting"></a><span data-ttu-id="d5796-546">Multi-ciblage</span><span class="sxs-lookup"><span data-stu-id="d5796-546">Multi-targeting</span></span>

<span data-ttu-id="d5796-547">Si vous devez continuer à utiliser `Newtonsoft.Json` pour certains frameworks cibles, vous pouvez effectuer plusieurs cibles et avoir deux implémentations.</span><span class="sxs-lookup"><span data-stu-id="d5796-547">If you need to continue to use `Newtonsoft.Json` for certain target frameworks, you can multi-target and have two implementations.</span></span> <span data-ttu-id="d5796-548">Toutefois, cela n’est pas trivial et nécessiterait une `#ifdefs` duplication source.</span><span class="sxs-lookup"><span data-stu-id="d5796-548">However, this is not trivial and would require some `#ifdefs` and source duplication.</span></span> <span data-ttu-id="d5796-549">Une façon de partager autant de code que possible consiste à créer un `ref struct` wrapper autour de `Utf8JsonReader` et `Newtonsoft.Json` `JsonTextReader` .</span><span class="sxs-lookup"><span data-stu-id="d5796-549">One way to share as much code as possible is to create a `ref struct` wrapper around `Utf8JsonReader` and `Newtonsoft.Json` `JsonTextReader`.</span></span> <span data-ttu-id="d5796-550">Ce wrapper unifie la surface d’exposition publique tout en isolant les différences de comportement.</span><span class="sxs-lookup"><span data-stu-id="d5796-550">This wrapper would unify the public surface area while isolating the behavioral differences.</span></span> <span data-ttu-id="d5796-551">Cela vous permet d’isoler les modifications principalement à la construction du type, ainsi que de passer le nouveau type par référence.</span><span class="sxs-lookup"><span data-stu-id="d5796-551">This lets you isolate the changes mainly to the construction of the type, along with passing the new type around by reference.</span></span> <span data-ttu-id="d5796-552">Il s’agit du modèle que la bibliothèque [Microsoft. extensions. DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) suit :</span><span class="sxs-lookup"><span data-stu-id="d5796-552">This is the pattern that the [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) library follows:</span></span>

* [<span data-ttu-id="d5796-553">UnifiedJsonReader.JsonTextReader.cs</span><span class="sxs-lookup"><span data-stu-id="d5796-553">UnifiedJsonReader.JsonTextReader.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonReader.JsonTextReader.cs)
* [<span data-ttu-id="d5796-554">UnifiedJsonReader.Utf8JsonReader.cs</span><span class="sxs-lookup"><span data-stu-id="d5796-554">UnifiedJsonReader.Utf8JsonReader.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonReader.Utf8JsonReader.cs)

## <a name="utf8jsonwriter-compared-to-jsontextwriter"></a><span data-ttu-id="d5796-555">Utf8JsonWriter comparé à JsonTextWriter</span><span class="sxs-lookup"><span data-stu-id="d5796-555">Utf8JsonWriter compared to JsonTextWriter</span></span>

<span data-ttu-id="d5796-556"><xref:System.Text.Json.Utf8JsonWriter?displayProperty=fullName> est une méthode très performante pour écrire du texte JSON encodé en UTF-8 à partir de types .NET courants tels que `String` , `Int32` et `DateTime` .</span><span class="sxs-lookup"><span data-stu-id="d5796-556"><xref:System.Text.Json.Utf8JsonWriter?displayProperty=fullName> is a high-performance way to write UTF-8 encoded JSON text from common .NET types like `String`, `Int32`, and `DateTime`.</span></span> <span data-ttu-id="d5796-557">Le writer est un type de bas niveau qui peut être utilisé pour créer des sérialiseurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="d5796-557">The writer is a low-level type that can be used to build custom serializers.</span></span>

<span data-ttu-id="d5796-558">Les sections suivantes expliquent les modèles de programmation recommandés pour l’utilisation de `Utf8JsonWriter` .</span><span class="sxs-lookup"><span data-stu-id="d5796-558">The following sections explain recommended programming patterns for using `Utf8JsonWriter`.</span></span>

### <a name="write-with-utf-8-text"></a><span data-ttu-id="d5796-559">Écrire avec du texte UTF-8</span><span class="sxs-lookup"><span data-stu-id="d5796-559">Write with UTF-8 text</span></span>

<span data-ttu-id="d5796-560">Pour obtenir les meilleures performances possibles lors de l’utilisation de `Utf8JsonWriter` , écrivez les charges utiles JSON déjà encodées en tant que texte UTF-8 plutôt qu’en tant que chaînes UTF-16.</span><span class="sxs-lookup"><span data-stu-id="d5796-560">To achieve the best possible performance while using the `Utf8JsonWriter`, write JSON payloads already encoded as UTF-8 text rather than as UTF-16 strings.</span></span> <span data-ttu-id="d5796-561">Utilisez <xref:System.Text.Json.JsonEncodedText> pour mettre en cache et précoder des noms et des valeurs de propriété de chaîne connus comme statiques, et les transmettre au writer, plutôt que d’utiliser des littéraux de chaîne UTF-16.</span><span class="sxs-lookup"><span data-stu-id="d5796-561">Use <xref:System.Text.Json.JsonEncodedText> to cache and pre-encode known string property names and values as statics, and pass those to the writer, rather than using UTF-16 string literals.</span></span> <span data-ttu-id="d5796-562">Cela est plus rapide que la mise en cache et l’utilisation des tableaux d’octets UTF-8.</span><span class="sxs-lookup"><span data-stu-id="d5796-562">This is faster than caching and using UTF-8 byte arrays.</span></span>

<span data-ttu-id="d5796-563">Cette approche fonctionne également si vous devez effectuer des séquences d’échappement personnalisées.</span><span class="sxs-lookup"><span data-stu-id="d5796-563">This approach also works if you need to do custom escaping.</span></span> <span data-ttu-id="d5796-564">`System.Text.Json` ne vous permet pas de désactiver l’échappement lors de l’écriture d’une chaîne.</span><span class="sxs-lookup"><span data-stu-id="d5796-564">`System.Text.Json` doesn't let you disable escaping while writing a string.</span></span> <span data-ttu-id="d5796-565">Toutefois, vous pouvez transmettre votre propre option personnalisée <xref:System.Text.Encodings.Web.JavaScriptEncoder> à l’enregistreur, ou créer votre propre option `JsonEncodedText` qui utilise votre `JavascriptEncoder` pour effectuer l’échappement, puis écrire à la `JsonEncodedText` place de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="d5796-565">However, you could pass in your own custom <xref:System.Text.Encodings.Web.JavaScriptEncoder> as an option to the writer, or create your own `JsonEncodedText` that uses your `JavascriptEncoder` to do the escaping, and then write the `JsonEncodedText` instead of the string.</span></span> <span data-ttu-id="d5796-566">Pour plus d’informations, consultez [personnaliser l’encodage des caractères](system-text-json-how-to.md#customize-character-encoding).</span><span class="sxs-lookup"><span data-stu-id="d5796-566">For more information, see [Customize character encoding](system-text-json-how-to.md#customize-character-encoding).</span></span>

### <a name="write-raw-values"></a><span data-ttu-id="d5796-567">Écrire des valeurs brutes</span><span class="sxs-lookup"><span data-stu-id="d5796-567">Write raw values</span></span>

<span data-ttu-id="d5796-568">La `Newtonsoft.Json` `WriteRawValue` méthode écrit un JSON brut dans lequel une valeur est attendue.</span><span class="sxs-lookup"><span data-stu-id="d5796-568">The `Newtonsoft.Json` `WriteRawValue` method writes raw JSON where a value is expected.</span></span> <span data-ttu-id="d5796-569"><xref:System.Text.Json> n’a pas d’équivalent direct, mais voici une solution de contournement qui garantit que seul le JSON valide est écrit :</span><span class="sxs-lookup"><span data-stu-id="d5796-569"><xref:System.Text.Json> has no direct equivalent, but here's a workaround that ensures only valid JSON is written:</span></span>

```csharp
using JsonDocument doc = JsonDocument.Parse(string);
doc.WriteTo(writer);
```

### <a name="customize-character-escaping"></a><span data-ttu-id="d5796-570">Personnaliser l’échappement des caractères</span><span class="sxs-lookup"><span data-stu-id="d5796-570">Customize character escaping</span></span>

<span data-ttu-id="d5796-571">Le paramètre [StringEscapeHandling](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_StringEscapeHandling.htm) de `JsonTextWriter` propose des options permettant d’échapper tous les caractères non-ASCII **ou** les caractères HTML.</span><span class="sxs-lookup"><span data-stu-id="d5796-571">The [StringEscapeHandling](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_StringEscapeHandling.htm) setting of `JsonTextWriter` offers options to escape all non-ASCII characters **or** HTML characters.</span></span> <span data-ttu-id="d5796-572">Par défaut, place dans une `Utf8JsonWriter` séquence d’échappement tous les caractères non-ASCII **et** html.</span><span class="sxs-lookup"><span data-stu-id="d5796-572">By default, `Utf8JsonWriter` escapes all non-ASCII **and** HTML characters.</span></span> <span data-ttu-id="d5796-573">Cette séquence d’échappement est effectuée pour des raisons de sécurité de défense en profondeur.</span><span class="sxs-lookup"><span data-stu-id="d5796-573">This escaping is done for defense-in-depth security reasons.</span></span> <span data-ttu-id="d5796-574">Pour spécifier une autre stratégie d’échappement, créez un <xref:System.Text.Encodings.Web.JavaScriptEncoder> et définissez <xref:System.Text.Json.JsonWriterOptions.Encoder?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d5796-574">To specify a different escaping policy, create a <xref:System.Text.Encodings.Web.JavaScriptEncoder> and set <xref:System.Text.Json.JsonWriterOptions.Encoder?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d5796-575">Pour plus d’informations, consultez [personnaliser l’encodage des caractères](system-text-json-how-to.md#customize-character-encoding).</span><span class="sxs-lookup"><span data-stu-id="d5796-575">For more information, see [Customize character encoding](system-text-json-how-to.md#customize-character-encoding).</span></span>

### <a name="customize-json-format"></a><span data-ttu-id="d5796-576">Personnaliser le format JSON</span><span class="sxs-lookup"><span data-stu-id="d5796-576">Customize JSON format</span></span>

<span data-ttu-id="d5796-577">`JsonTextWriter` inclut les paramètres suivants, pour lesquels `Utf8JsonWriter` n’a pas d’équivalent :</span><span class="sxs-lookup"><span data-stu-id="d5796-577">`JsonTextWriter` includes the following settings, for which `Utf8JsonWriter` has no equivalent:</span></span>

* <span data-ttu-id="d5796-578">[Mise en retrait](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_Indentation.htm) : spécifie le nombre de caractères à mettre en retrait.</span><span class="sxs-lookup"><span data-stu-id="d5796-578">[Indentation](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_Indentation.htm) - Specifies how many characters to indent.</span></span> <span data-ttu-id="d5796-579">`Utf8JsonWriter` effectue toujours une mise en retrait à 2 caractères.</span><span class="sxs-lookup"><span data-stu-id="d5796-579">`Utf8JsonWriter` always does 2-character indentation.</span></span>
* <span data-ttu-id="d5796-580">[IndentChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_IndentChar.htm) : spécifie le caractère à utiliser pour la mise en retrait.</span><span class="sxs-lookup"><span data-stu-id="d5796-580">[IndentChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_IndentChar.htm) - Specifies the character to use for indentation.</span></span>  <span data-ttu-id="d5796-581">`Utf8JsonWriter` utilise toujours un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="d5796-581">`Utf8JsonWriter` always uses whitespace.</span></span>
* <span data-ttu-id="d5796-582">[QuoteChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteChar.htm) : spécifie le caractère à utiliser pour entourer les valeurs de chaîne.</span><span class="sxs-lookup"><span data-stu-id="d5796-582">[QuoteChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteChar.htm) - Specifies the character to use to surround string values.</span></span>  <span data-ttu-id="d5796-583">`Utf8JsonWriter` utilise toujours des guillemets doubles.</span><span class="sxs-lookup"><span data-stu-id="d5796-583">`Utf8JsonWriter` always uses double quotes.</span></span>
* <span data-ttu-id="d5796-584">[QUOTENAME](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteName.htm) : spécifie si les noms de propriété doivent être placés entre guillemets.</span><span class="sxs-lookup"><span data-stu-id="d5796-584">[QuoteName](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteName.htm) - Specifies whether or not to surround property names with quotes.</span></span>  <span data-ttu-id="d5796-585">`Utf8JsonWriter` les entourent toujours de guillemets.</span><span class="sxs-lookup"><span data-stu-id="d5796-585">`Utf8JsonWriter` always surrounds them with quotes.</span></span>

<span data-ttu-id="d5796-586">Il n’existe aucune solution de contournement qui vous permettrait de personnaliser le JSON généré par à l’aide `Utf8JsonWriter` de ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="d5796-586">There are no workarounds that would let you customize the JSON produced by `Utf8JsonWriter` in these ways.</span></span>

### <a name="write-null-values"></a><span data-ttu-id="d5796-587">Écrire des valeurs null</span><span class="sxs-lookup"><span data-stu-id="d5796-587">Write null values</span></span>

<span data-ttu-id="d5796-588">Pour écrire des valeurs NULL à l’aide de `Utf8JsonWriter` , appelez :</span><span class="sxs-lookup"><span data-stu-id="d5796-588">To write null values by using `Utf8JsonWriter`, call:</span></span>

* <span data-ttu-id="d5796-589"><xref:System.Text.Json.Utf8JsonWriter.WriteNull%2A> pour écrire une paire clé-valeur avec NULL comme valeur.</span><span class="sxs-lookup"><span data-stu-id="d5796-589"><xref:System.Text.Json.Utf8JsonWriter.WriteNull%2A> to write a key-value pair with null as the value.</span></span>
* <span data-ttu-id="d5796-590"><xref:System.Text.Json.Utf8JsonWriter.WriteNullValue%2A> pour écrire NULL comme élément d’un tableau JSON.</span><span class="sxs-lookup"><span data-stu-id="d5796-590"><xref:System.Text.Json.Utf8JsonWriter.WriteNullValue%2A> to write null as an element of a JSON array.</span></span>

<span data-ttu-id="d5796-591">Pour une propriété de type chaîne, si la chaîne est null, <xref:System.Text.Json.Utf8JsonWriter.WriteString%2A> et <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A> sont équivalents à `WriteNull` et `WriteNullValue` .</span><span class="sxs-lookup"><span data-stu-id="d5796-591">For a string property, if the string is null, <xref:System.Text.Json.Utf8JsonWriter.WriteString%2A> and <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A> are equivalent to `WriteNull` and `WriteNullValue`.</span></span>

### <a name="write-timespan-uri-or-char-values"></a><span data-ttu-id="d5796-592">Écrire les valeurs TimeSpan, Uri ou char</span><span class="sxs-lookup"><span data-stu-id="d5796-592">Write Timespan, Uri, or char values</span></span>

<span data-ttu-id="d5796-593">`JsonTextWriter` fournit `WriteValue` des méthodes pour les valeurs [TimeSpan](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_18.htm), [URI](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_22.htm)et [char](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_3.htm) .</span><span class="sxs-lookup"><span data-stu-id="d5796-593">`JsonTextWriter` provides `WriteValue` methods for [TimeSpan](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_18.htm), [Uri](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_22.htm), and [char](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_3.htm) values.</span></span> <span data-ttu-id="d5796-594">`Utf8JsonWriter` n’a pas de méthode équivalente.</span><span class="sxs-lookup"><span data-stu-id="d5796-594">`Utf8JsonWriter` doesn't have equivalent methods.</span></span> <span data-ttu-id="d5796-595">Au lieu de cela, mettez en forme ces valeurs en tant que chaînes (en appelant `ToString()` , par exemple) et appelez <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A> .</span><span class="sxs-lookup"><span data-stu-id="d5796-595">Instead, format these values as strings (by calling `ToString()`, for example) and call <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A>.</span></span>

### <a name="multi-targeting"></a><span data-ttu-id="d5796-596">Multi-ciblage</span><span class="sxs-lookup"><span data-stu-id="d5796-596">Multi-targeting</span></span>

<span data-ttu-id="d5796-597">Si vous devez continuer à utiliser `Newtonsoft.Json` pour certains frameworks cibles, vous pouvez effectuer plusieurs cibles et avoir deux implémentations.</span><span class="sxs-lookup"><span data-stu-id="d5796-597">If you need to continue to use `Newtonsoft.Json` for certain target frameworks, you can multi-target and have two implementations.</span></span> <span data-ttu-id="d5796-598">Toutefois, cela n’est pas trivial et nécessiterait une `#ifdefs` duplication source.</span><span class="sxs-lookup"><span data-stu-id="d5796-598">However, this is not trivial and would require some `#ifdefs` and source duplication.</span></span> <span data-ttu-id="d5796-599">Une façon de partager autant de code que possible consiste à créer un wrapper autour de `Utf8JsonWriter` et `Newtonsoft` `JsonTextWriter` .</span><span class="sxs-lookup"><span data-stu-id="d5796-599">One way to share as much code as possible is to create a wrapper around `Utf8JsonWriter` and `Newtonsoft` `JsonTextWriter`.</span></span> <span data-ttu-id="d5796-600">Ce wrapper unifie la surface d’exposition publique tout en isolant les différences de comportement.</span><span class="sxs-lookup"><span data-stu-id="d5796-600">This wrapper would unify the public surface area while isolating the behavioral differences.</span></span> <span data-ttu-id="d5796-601">Cela vous permet d’isoler les modifications principalement de la construction du type.</span><span class="sxs-lookup"><span data-stu-id="d5796-601">This lets you isolate the changes mainly to the construction of the type.</span></span> <span data-ttu-id="d5796-602">La bibliothèque [Microsoft. extensions. DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) est la suivante :</span><span class="sxs-lookup"><span data-stu-id="d5796-602">[Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) library follows:</span></span>

* [<span data-ttu-id="d5796-603">UnifiedJsonWriter.JsonTextWriter.cs</span><span class="sxs-lookup"><span data-stu-id="d5796-603">UnifiedJsonWriter.JsonTextWriter.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonWriter.JsonTextWriter.cs)
* [<span data-ttu-id="d5796-604">UnifiedJsonWriter.Utf8JsonWriter.cs</span><span class="sxs-lookup"><span data-stu-id="d5796-604">UnifiedJsonWriter.Utf8JsonWriter.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonWriter.Utf8JsonWriter.cs)

## <a name="additional-resources"></a><span data-ttu-id="d5796-605">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="d5796-605">Additional resources</span></span>

<!-- * [System.Text.Json roadmap](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/roadmap/README.md)[Restore this when the roadmap is updated.]-->
* [<span data-ttu-id="d5796-606">System.Text.Json vue</span><span class="sxs-lookup"><span data-stu-id="d5796-606">System.Text.Json overview</span></span>](system-text-json-overview.md)
* [<span data-ttu-id="d5796-607">Procédure d’utilisation System.Text.Json</span><span class="sxs-lookup"><span data-stu-id="d5796-607">How to use System.Text.Json</span></span>](system-text-json-how-to.md)
* [<span data-ttu-id="d5796-608">Guide pratique pour écrire des convertisseurs personnalisés</span><span class="sxs-lookup"><span data-stu-id="d5796-608">How to write custom converters</span></span>](system-text-json-converters-how-to.md)
* [<span data-ttu-id="d5796-609">Prise en charge des valeurs DateTime et DateTimeOffset dans System.Text.Json</span><span class="sxs-lookup"><span data-stu-id="d5796-609">DateTime and DateTimeOffset support in System.Text.Json</span></span>](../datetime/system-text-json-support.md)
* <span data-ttu-id="d5796-610">[System.Text.Json Référence d’API](xref:System.Text.Json)</span><span class="sxs-lookup"><span data-stu-id="d5796-610">[System.Text.Json API reference](xref:System.Text.Json)</span></span>
* <span data-ttu-id="d5796-611">[System.Text.Json. Référence de l’API de sérialisation](xref:System.Text.Json.Serialization)</span><span class="sxs-lookup"><span data-stu-id="d5796-611">[System.Text.Json.Serialization API reference](xref:System.Text.Json.Serialization)</span></span>
