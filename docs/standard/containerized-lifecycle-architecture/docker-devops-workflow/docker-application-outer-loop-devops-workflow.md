---
title: Étapes du workflow DevOps de la boucle externe pour une application Docker
description: Découvrez les étapes pour la boucle « externe » du flux de travail DevOps
ms.date: 02/15/2019
ms.openlocfilehash: e7a82d2e5a5d503e5efbe9ac8242b163baab1286
ms.sourcegitcommit: 96543603ae29bc05cecccb8667974d058af63b4a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/24/2019
ms.locfileid: "66195614"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="149f2-103">Étapes du workflow DevOps de la boucle externe pour une application Docker</span><span class="sxs-lookup"><span data-stu-id="149f2-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="149f2-104">Figure 5-1 présente une description de bout en bout des étapes comprenant le flux de travail DevOps boucle externe.</span><span class="sxs-lookup"><span data-stu-id="149f2-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![Ce diagramme illustre la boucle « externe » de DevOps.](./media/image1.png)

<span data-ttu-id="149f2-108">**Figure 5-1**.</span><span class="sxs-lookup"><span data-stu-id="149f2-108">**Figure 5-1**.</span></span> <span data-ttu-id="149f2-109">Flux de travail DevOps boucle externe pour les applications Docker avec les outils Microsoft</span><span class="sxs-lookup"><span data-stu-id="149f2-109">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="149f2-110">Maintenant, nous allons examiner chacune de ces étapes plus en détail.</span><span class="sxs-lookup"><span data-stu-id="149f2-110">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="149f2-111">Étape 1 : Flux de travail de développement de la boucle interne</span><span class="sxs-lookup"><span data-stu-id="149f2-111">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="149f2-112">Cette étape est expliquée en détail dans le chapitre 4, mais, pour résumer, voici où la boucle externe commence, le moment auquel un développeur transmet le code pour le système de gestion de contrôle de source (comme Git) initiation d’actions de pipeline CI.</span><span class="sxs-lookup"><span data-stu-id="149f2-112">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="149f2-113">Étape 2 : Intégration de contrôle de Code source et la gestion avec Azure DevOps Services et Git</span><span class="sxs-lookup"><span data-stu-id="149f2-113">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="149f2-114">À ce stade, vous devez disposer d’un système de contrôle de version pour collecter une version consolidée de tout le code provenant des différents développeurs de l’équipe.</span><span class="sxs-lookup"><span data-stu-id="149f2-114">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="149f2-115">Même si le contrôle de code source (SCC) et de gestion de code source peuvent sembler seconde-nature à la plupart des développeurs, lors de la création d’applications Docker dans une vie DevOps cycle, il est essentiel de souligner que vous ne devez pas envoyer les images Docker avec l’application directement dans le Registre de Docker global (comme Azure Container Registry ou Docker Hub) à partir de l’ordinateur du développeur.</span><span class="sxs-lookup"><span data-stu-id="149f2-115">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="149f2-116">En revanche, les images Docker être libéré et déployée dans les environnements de production doivent être créés uniquement sur le code source en cours d’intégration dans votre build global ou d’un pipeline CI en fonction de votre référentiel de code source (comme Git).</span><span class="sxs-lookup"><span data-stu-id="149f2-116">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="149f2-117">Les images locales générées par les développeurs, doivent uniquement être utilisées par ces derniers lors des tests au sein de leurs propres ordinateurs.</span><span class="sxs-lookup"><span data-stu-id="149f2-117">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="149f2-118">C’est pourquoi il est essentiel d’avoir votre pipeline DevOps activé à partir du code de contrôle de code source.</span><span class="sxs-lookup"><span data-stu-id="149f2-118">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="149f2-119">Azure DevOps Services et Team Foundation Server prend en charge Git et Team Foundation Version Control.</span><span class="sxs-lookup"><span data-stu-id="149f2-119">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="149f2-120">Vous pouvez choisir entre eux et l’utiliser pour une expérience de Microsoft de bout en bout.</span><span class="sxs-lookup"><span data-stu-id="149f2-120">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="149f2-121">Toutefois, vous pouvez également gérer votre code dans les dépôts externes (tels que GitHub, les référentiels Git en local ou Subversion) et toujours être en mesure de s’y connecter et obtenir le code comme point de départ pour votre pipeline DevOps CI.</span><span class="sxs-lookup"><span data-stu-id="149f2-121">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="149f2-122">Étape 3 : Générer, CI, intégrer et tester avec Azure DevOps Services et Docker</span><span class="sxs-lookup"><span data-stu-id="149f2-122">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="149f2-123">CI est devenu une norme pour le test de logiciels modernes et de remise.</span><span class="sxs-lookup"><span data-stu-id="149f2-123">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="149f2-124">La solution Docker gère une séparation claire des responsabilités entre les équipes de développement et les opérations.</span><span class="sxs-lookup"><span data-stu-id="149f2-124">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="149f2-125">L’immuabilité des images Docker garantit un déploiement reproductible entre ce qui a développé, testé via l’élément de configuration et exécuter en production.</span><span class="sxs-lookup"><span data-stu-id="149f2-125">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="149f2-126">Moteur docker déployé sur les ordinateurs portables de développeur et infrastructure de test rend les conteneurs portable entre les environnements.</span><span class="sxs-lookup"><span data-stu-id="149f2-126">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="149f2-127">À ce stade, une fois que vous avez un système de contrôle de version avec le bon code soumis, vous avez besoin une *service de build* pour récupérer le code et exécuter la build global et les tests.</span><span class="sxs-lookup"><span data-stu-id="149f2-127">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="149f2-128">Le flux de travail interne pour cette étape (CI, build, test) est sur la construction d’un pipeline CI consistant à votre référentiel de code (Git, etc.), votre serveur de builds (Services de DevOps Azure), moteur Docker et un Registre Docker.</span><span class="sxs-lookup"><span data-stu-id="149f2-128">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="149f2-129">Vous pouvez utiliser Azure DevOps Services comme base pour la création de vos applications et en définissant votre pipeline CI et pour la publication « artefacts » générés pour un « référentiel d’artefacts, » qui est expliqué dans l’étape suivante.</span><span class="sxs-lookup"><span data-stu-id="149f2-129">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="149f2-130">Lors de l’utilisation de Docker pour le déploiement, les « artefacts finales » à être déployées sont des images Docker avec votre application ou les services intégrés à ceux-ci.</span><span class="sxs-lookup"><span data-stu-id="149f2-130">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="149f2-131">Ces images sont transmises ou publiés sur un *Registre Docker* (un référentiel privé, comme ceux que vous pouvez avoir dans Azure Container Registry ou une publique comme registre Docker Hub, qui est couramment utilisé pour les images de base officiels).</span><span class="sxs-lookup"><span data-stu-id="149f2-131">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="149f2-132">Voici le concept de base : Le pipeline de CI sera déclenchée désactivé par une validation à un référentiel de contrôle de code source comme Git.</span><span class="sxs-lookup"><span data-stu-id="149f2-132">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="149f2-133">La validation entraîne Azure DevOps Services exécuter une tâche de build dans un conteneur Docker et, en cas de réussite de ce travail, transférer une image Docker au Registre Docker, comme illustré dans la Figure 5-2.</span><span class="sxs-lookup"><span data-stu-id="149f2-133">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![La première partie de la boucle externe implique les étapes 1 à 3, à partir du code, exécuter, déboguer et valider, puis le référentiel de code jusqu'à l’étape d’élément de configuration de build et de test](./media/image2.png)

<span data-ttu-id="149f2-135">**Figure 5-2**.</span><span class="sxs-lookup"><span data-stu-id="149f2-135">**Figure 5-2**.</span></span> <span data-ttu-id="149f2-136">Les étapes impliquées dans l’élément de configuration</span><span class="sxs-lookup"><span data-stu-id="149f2-136">The steps involved in CI</span></span>

<span data-ttu-id="149f2-137">Voici les étapes de flux de travail de base CI avec Docker et Azure DevOps Services :</span><span class="sxs-lookup"><span data-stu-id="149f2-137">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="149f2-138">Le développeur exécute un push d’une validation à un référentiel de contrôle de code source (Git/Azure DevOps Services, GitHub, etc.).</span><span class="sxs-lookup"><span data-stu-id="149f2-138">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="149f2-139">Si vous utilisez Azure DevOps Services ou Git, CI est intégrée, ce qui signifie qu’il est aussi simple que la sélection d’une case à cocher dans les Services Azure DevOps.</span><span class="sxs-lookup"><span data-stu-id="149f2-139">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="149f2-140">Si vous utilisez un contrôle de code source externe (comme GitHub), un `webhook` Avertissez les Services de DevOps Azure de la mise à jour ou de push à Git/GitHub.</span><span class="sxs-lookup"><span data-stu-id="149f2-140">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="149f2-141">Les Services Azure DevOps extrait le référentiel de contrôle de code source, y compris le fichier Dockerfile décrivant l’image, ainsi que le code d’application et de test.</span><span class="sxs-lookup"><span data-stu-id="149f2-141">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="149f2-142">Azure DevOps Services crée une image Docker et il les avec un numéro de build.</span><span class="sxs-lookup"><span data-stu-id="149f2-142">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="149f2-143">Les Services Azure DevOps instancie le conteneur Docker dans l’hôte Docker approvisionné et exécute les tests appropriés.</span><span class="sxs-lookup"><span data-stu-id="149f2-143">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="149f2-144">Si les tests réussissent, l’image est tout d’abord un nouveau libellé à un nom significatif afin que vous savez qu’il est « génération privilégiée » (comme « / 1.0.0 » ou n’importe quel autre étiquette) et puis envoyées à votre Registre Docker (Docker Hub, Azure Container Registry, DTR, etc.).</span><span class="sxs-lookup"><span data-stu-id="149f2-144">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="149f2-145">Mise en œuvre le pipeline CI avec Azure DevOps Services et l’extension Docker pour Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="149f2-145">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="149f2-146">Visual Studio Azure DevOps Services contient les modèles de version que vous pouvez utiliser dans votre pipeline CI/CD avec lequel vous pouvez générer des images Docker, envoyer des images de Docker à un Registre Docker authentifié, exécuter des images Docker ou exécuter d’autres opérations proposées par & Build l’interface CLI Docker.</span><span class="sxs-lookup"><span data-stu-id="149f2-146">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="149f2-147">Il ajoute également une tâche de Docker Compose que vous pouvez utiliser pour créer, transmettre et exécuter des applications à plusieurs conteneurs Docker ou exécuter d’autres opérations offertes par la CLI Docker Compose, comme illustré dans la Figure 5-3.</span><span class="sxs-lookup"><span data-stu-id="149f2-147">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Vue du navigateur du pipeline CI de Docker dans Azure DevOps](./media/image3.png)

<span data-ttu-id="149f2-149">**Figure 5-3**.</span><span class="sxs-lookup"><span data-stu-id="149f2-149">**Figure 5-3**.</span></span> <span data-ttu-id="149f2-150">Le pipeline d’intégration continue Docker dans les Services Azure DevOps, notamment le développement et les modèles de version et les tâches associées.</span><span class="sxs-lookup"><span data-stu-id="149f2-150">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="149f2-151">Vous pouvez utiliser ces modèles et les tâches pour construire vos artefacts de CI/CD pour créer / tester et déployer dans Azure Service Fabric, Azure Kubernetes Service et offres similaire.</span><span class="sxs-lookup"><span data-stu-id="149f2-151">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="149f2-152">Avec ces tâches de Visual Studio Team Services, une build/la machine virtuelle Linux Docker hôte configuré dans Azure et votre Registre Docker par défaut (Azure Container Registry, Docker Hub, DTR de Docker privé ou tout autre registre Docker), vous pouvez assembler votre pipeline CI de Docker dans un façon très cohérente.</span><span class="sxs-lookup"><span data-stu-id="149f2-152">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="149f2-153">***Configuration requise :***</span><span class="sxs-lookup"><span data-stu-id="149f2-153">***Requirements:***</span></span>

- <span data-ttu-id="149f2-154">Les Services Azure DevOps, ou pour les installations locales, Team Foundation Server 2015 Update 3 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="149f2-154">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="149f2-155">Agent Azure DevOps Services a les binaires Docker.</span><span class="sxs-lookup"><span data-stu-id="149f2-155">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="149f2-156">Un moyen facile de créer un de ces agents consiste à utiliser Docker pour exécuter un conteneur basé sur l’image Docker de l’agent Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="149f2-156">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [! INFORMATIONS]<span data-ttu-id="149f2-157"> pour en savoir plus sur l’assemblage d’un élément de configuration de Azure DevOps Services Docker de pipeline et que vous affichez les procédures pas à pas, consultez ces sites :</span><span class="sxs-lookup"><span data-stu-id="149f2-157"> To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="149f2-158">Exécution d’un agent de Visual Studio Team Services (maintenant Azure DevOps Services) en tant que conteneur Docker : \\</span><span class="sxs-lookup"><span data-stu-id="149f2-158">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: \\</span></span>
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="149f2-159">Création d’images Docker .NET Core Linux avec Azure DevOps Services : \\</span><span class="sxs-lookup"><span data-stu-id="149f2-159">Building .NET Core Linux Docker images with Azure DevOps Services: \\</span></span>
>   <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/>
>
> - <span data-ttu-id="149f2-160">Création d’un basés sur Linux Visual Studio Team Service ordinateur avec prise en charge Docker de build : \\</span><span class="sxs-lookup"><span data-stu-id="149f2-160">Building a Linux-based Visual Studio Team Service build machine with Docker support: \\</span></span>
>   <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="149f2-161">Intégrer, tester et valider des applications à plusieurs conteneurs Docker</span><span class="sxs-lookup"><span data-stu-id="149f2-161">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="149f2-162">En règle générale, la plupart des applications Docker sont composées de plusieurs conteneurs plutôt qu’un seul conteneur.</span><span class="sxs-lookup"><span data-stu-id="149f2-162">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="149f2-163">Un bon exemple est une application orientée sur les microservices pour lequel vous aurait un conteneur par microservice.</span><span class="sxs-lookup"><span data-stu-id="149f2-163">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="149f2-164">Toutefois, même sans strictement suivant les modèles d’approche de microservices, il est probable que votre application Docker est composée de plusieurs conteneurs ou services.</span><span class="sxs-lookup"><span data-stu-id="149f2-164">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="149f2-165">Par conséquent, après avoir généré les conteneurs d’application dans le pipeline CI, vous devez également déployer, intégrer et tester l’application dans son ensemble avec tous ses conteneurs au sein d’un hôte Docker d’intégration ou même dans un cluster de test auquel sont vos conteneurs distribué.</span><span class="sxs-lookup"><span data-stu-id="149f2-165">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="149f2-166">Si vous utilisez un seul hôte, vous pouvez utiliser les commandes Docker tels que docker-compose pour générer et déployer des conteneurs associés pour tester et valider l’environnement Docker dans une seule machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="149f2-166">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="149f2-167">Toutefois, si vous travaillez avec un cluster orchestrateur DC/OS, Kubernetes ou Docker Swarm, vous devez déployer vos conteneurs via un mécanisme différent ou un orchestrateur, en fonction de votre cluster/planificateur sélectionné.</span><span class="sxs-lookup"><span data-stu-id="149f2-167">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="149f2-168">Voici plusieurs types de tests que vous pouvez exécuter sur des conteneurs Docker :</span><span class="sxs-lookup"><span data-stu-id="149f2-168">Following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="149f2-169">Tests unitaires pour les conteneurs Docker</span><span class="sxs-lookup"><span data-stu-id="149f2-169">Unit tests for Docker containers</span></span>

- <span data-ttu-id="149f2-170">Test des groupes d’applications liées entre elles ou microservices</span><span class="sxs-lookup"><span data-stu-id="149f2-170">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="149f2-171">Tester dans les versions de production et « canari »</span><span class="sxs-lookup"><span data-stu-id="149f2-171">Test in production and "canary" releases</span></span>

<span data-ttu-id="149f2-172">Le point important est que lors de l’exécution de l’intégration et les tests fonctionnels, vous devez exécuter ces tests à partir d’en dehors des conteneurs.</span><span class="sxs-lookup"><span data-stu-id="149f2-172">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="149f2-173">Les tests ne sont pas contenues ou exécuter dans les conteneurs que vous déployez, car les conteneurs sont basées sur des images statiques qui doivent être exactement comme ceux que vous allez déployer en production.</span><span class="sxs-lookup"><span data-stu-id="149f2-173">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="149f2-174">Une option pratique lorsque le test de scénarios plus avancés, comme notamment plusieurs clusters (tester le cluster, cluster intermédiaire et cluster de production) consiste à publier les images dans un Registre, donc il peut être testé dans des clusters différents.</span><span class="sxs-lookup"><span data-stu-id="149f2-174">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="149f2-175">Transmettre l’image de Docker d’application personnalisée à votre Registre Docker global</span><span class="sxs-lookup"><span data-stu-id="149f2-175">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="149f2-176">Une fois que les images Docker ont été testés et validés, vous souhaitez étiqueter et de les publier dans votre Registre Docker.</span><span class="sxs-lookup"><span data-stu-id="149f2-176">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="149f2-177">Le Registre Docker est un élément essentiel dans le cycle de vie d’application Docker, car il est un emplacement central où vous stockez votre test personnalisé (également appelé « images privilégiés ») d’être déployés dans des environnements d’assurance qualité et de production.</span><span class="sxs-lookup"><span data-stu-id="149f2-177">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="149f2-178">Semblable à la façon dont le code d’application stocké dans votre référentiel de contrôle de code source (Git, etc.) est votre « source de vérité », le Registre Docker est votre « source de vérité » pour votre application binaire ou les bits à déployer sur les environnements de production ou d’assurance qualité.</span><span class="sxs-lookup"><span data-stu-id="149f2-178">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="149f2-179">En règle générale, vous souhaiterez peut-être avoir vos référentiels privés pour vos images personnalisées dans un référentiel privé dans Azure Container Registry ou, dans un Registre local comme Docker Trusted Registry ou dans un Registre de cloud public avec un accès restreint (par exemple Docker Hub), bien que dans ce dernier cas, si votre code n’est pas open source, vous devez approuver la sécurité du fournisseur.</span><span class="sxs-lookup"><span data-stu-id="149f2-179">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="149f2-180">Dans les deux cas, la méthode que vous utilisez est similaire et est basée sur le `docker push` de commande, comme indiqué dans la Figure 5-4.</span><span class="sxs-lookup"><span data-stu-id="149f2-180">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![À l’étape 3, pour la création de l’intégration et de test (CI), vous pouvez publier les images docker qui en résulte à un Registre privé ou public.](./media/image4.png)

<span data-ttu-id="149f2-182">**Figure 5-4**.</span><span class="sxs-lookup"><span data-stu-id="149f2-182">**Figure 5-4**.</span></span> <span data-ttu-id="149f2-183">Publication des images personnalisées à un Registre Docker</span><span class="sxs-lookup"><span data-stu-id="149f2-183">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="149f2-184">Il existe plusieurs offres de registres Docker à partir de fournisseurs de cloud comme Azure Container Registry, Registre de conteneurs d’Amazon Web Services, Google Container Registry, quai de Registre et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="149f2-184">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="149f2-185">L’utilisation des tâches Docker, vous pouvez transmettre un ensemble d’images de service défini par un `docker-compose.yml` de fichiers, avec plusieurs balises à un Registre Docker authentifié (comme Azure Container Registry), comme illustré dans la Figure 5-5.</span><span class="sxs-lookup"><span data-stu-id="149f2-185">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Affichage du navigateur de l’étape pour publier des images sur un Registre à partir d’Azure DevOps.](./media/image5.png)

<span data-ttu-id="149f2-187">**Figure 5-5**.</span><span class="sxs-lookup"><span data-stu-id="149f2-187">**Figure 5-5**.</span></span> <span data-ttu-id="149f2-188">À l’aide d’Azure DevOps Services pour la publication des images personnalisées dans un Registre Docker</span><span class="sxs-lookup"><span data-stu-id="149f2-188">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [! INFORMATIONS]<span data-ttu-id="149f2-189"> pour plus d’informations sur Azure Container Registry, consultez <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="149f2-189"> For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="149f2-190">Étape 4 : CD, déployer</span><span class="sxs-lookup"><span data-stu-id="149f2-190">Step 4: CD, Deploy</span></span>

<span data-ttu-id="149f2-191">L’immuabilité des images Docker garantit un déploiement reproductible avec ce qui a développé, testé via l’élément de configuration et exécuter en production.</span><span class="sxs-lookup"><span data-stu-id="149f2-191">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="149f2-192">Une fois que vous avez les images de Docker d’application publiées dans votre Registre Docker (privé ou public), vous pouvez les déployer sur les environnements de plusieurs dont vous disposez (production, assurance qualité, de mise en lots, etc.) à partir de votre pipeline de CD à l’aide des Services de DevOps Azure les tâches de pipeline ou Azure DevOps Services Release Management.</span><span class="sxs-lookup"><span data-stu-id="149f2-192">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="149f2-193">Toutefois, à ce stade il dépend de quel type d’application Docker que vous déployez.</span><span class="sxs-lookup"><span data-stu-id="149f2-193">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="149f2-194">Déployant une simple application (à partir d’un point de vue composition et de déploiement) comme un monolithique application comprenant plusieurs conteneurs ou services et déployée vers plusieurs serveurs ou machines virtuelles est différent du déploiement d’une application plus complexe, comme un application orientée sur les microservices avec les fonctionnalités de très grande échelle.</span><span class="sxs-lookup"><span data-stu-id="149f2-194">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="149f2-195">Ces deux scénarios sont expliqués dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="149f2-195">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="149f2-196">Déploiement des applications de Docker à plusieurs environnements Docker composées</span><span class="sxs-lookup"><span data-stu-id="149f2-196">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="149f2-197">Regardons premièrement le scénario moins complexes : déploiement d’hôtes Docker simples (machines virtuelles ou serveurs) dans un environnement unique ou de plusieurs environnements (assurance qualité, intermédiaire et production).</span><span class="sxs-lookup"><span data-stu-id="149f2-197">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="149f2-198">Dans ce scénario, en interne votre pipeline de CD peut utiliser docker-compose (à partir de vos tâches de déploiement Azure DevOps Services) pour déployer les applications Docker avec son ensemble de conteneurs ou services, comme illustré dans la Figure 5-6.</span><span class="sxs-lookup"><span data-stu-id="149f2-198">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![Déployer le CD étape (4) peut publier dans des environnements différents, tels que q & a, intermédiaire et production.](./media/image6.png)

<span data-ttu-id="149f2-200">**Figure 5-6**.</span><span class="sxs-lookup"><span data-stu-id="149f2-200">**Figure 5-6**.</span></span> <span data-ttu-id="149f2-201">Déploiement de conteneurs de l’application sur simple Registre d’environnements l’hôte Docker</span><span class="sxs-lookup"><span data-stu-id="149f2-201">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="149f2-202">Figure 5-7 met en évidence la façon dont vous pouvez vous connecter votre élément de configuration de build aux environnements de test/AQ via des Services Azure DevOps en cliquant sur Docker Compose dans la boîte de dialogue Ajouter une tâche.</span><span class="sxs-lookup"><span data-stu-id="149f2-202">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="149f2-203">Toutefois, lors du déploiement de l’environnement intermédiaire ou de production, généralement utilisez Gestion des environnements de plusieurs des fonctionnalités de Release Management (telles que questions et réponses, intermédiaire et production).</span><span class="sxs-lookup"><span data-stu-id="149f2-203">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="149f2-204">Si vous effectuez un déploiement à des hôtes Docker uniques, il utilise les Services de DevOps Azure tâche « Docker Compose » (ce qui revient à appeler le `docker-compose up` commande sous le capot).</span><span class="sxs-lookup"><span data-stu-id="149f2-204">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="149f2-205">Si vous effectuez un déploiement vers Azure Kubernetes Service (AKS), il utilise la tâche de déploiement de Docker, comme expliqué dans la section qui suit.</span><span class="sxs-lookup"><span data-stu-id="149f2-205">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Vue du navigateur de l’ajout d’une tâche Docker Compose.](./media/image7.png)

<span data-ttu-id="149f2-207">**Figure 5-7**.</span><span class="sxs-lookup"><span data-stu-id="149f2-207">**Figure 5-7**.</span></span> <span data-ttu-id="149f2-208">Ajout d’une tâche Docker Compose dans un pipeline Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="149f2-208">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="149f2-209">Lorsque vous créez une version dans les Services Azure DevOps, il prend un ensemble d’artefacts d’entrée.</span><span class="sxs-lookup"><span data-stu-id="149f2-209">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="149f2-210">Ces artefacts sont destinées à être immuable pour la durée de vie de la version, tous les environnements.</span><span class="sxs-lookup"><span data-stu-id="149f2-210">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="149f2-211">Lorsque vous introduisez des conteneurs, les artefacts d’entrée identifient les images dans un Registre à déployer.</span><span class="sxs-lookup"><span data-stu-id="149f2-211">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="149f2-212">En fonction de la manière dont ces images sont identifiés, ils sont assurément pas restent les mêmes pendant toute la durée de la version la plus évidente cas en cours lorsque vous faites référence `myimage:latest` à partir d’un `docker-compose` fichier.</span><span class="sxs-lookup"><span data-stu-id="149f2-212">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="149f2-213">Les Azure DevOps Services modèles vous donnent la possibilité de générer des artefacts de build qui contient l’image de Registre spécifiques des résumés qui sont garanties pour identifier de façon unique la même image binaire.</span><span class="sxs-lookup"><span data-stu-id="149f2-213">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="149f2-214">Il s’agit de ce que vous voulez vraiment utiliser comme entrée pour une mise en production.</span><span class="sxs-lookup"><span data-stu-id="149f2-214">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="149f2-215">Gestion des versions aux environnements Docker à l’aide d’Azure DevOps Services Release Management</span><span class="sxs-lookup"><span data-stu-id="149f2-215">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="149f2-216">À utiliser les modèles Azure DevOps Services, vous pouvez créer une nouvelle image, publiez-le dans un Registre Docker, exécutez-le sur les hôtes Linux ou Windows et utiliser des commandes telles que `docker-compose` pour déployer plusieurs conteneurs comme une application entière, soutenue du DevOps Azure Services des fonctionnalités de gestion de version destinées à plusieurs environnements, comme illustré dans la Figure 5-8.</span><span class="sxs-lookup"><span data-stu-id="149f2-216">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Affichage du navigateur de Azure DevOps, configuration de Docker compose mises en production.](./media/image8.png)

<span data-ttu-id="149f2-218">**Figure 5-8**.</span><span class="sxs-lookup"><span data-stu-id="149f2-218">**Figure 5-8**.</span></span> <span data-ttu-id="149f2-219">Configuration d’Azure DevOps Services Docker Compose de tâches à partir d’Azure DevOps Services Release Management</span><span class="sxs-lookup"><span data-stu-id="149f2-219">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="149f2-220">Toutefois, gardez à l’esprit que le scénario illustré dans la Figure 5-6 et implémenté dans la Figure 5-8 est une simple (il consiste à déployer dans des machines virtuelles et les hôtes Docker simples, et il y aura un seul conteneur ou une instance par image) et probablement doit être utilisé uniquement pour le développement ou test sce narios.</span><span class="sxs-lookup"><span data-stu-id="149f2-220">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="149f2-221">Dans la plupart des scénarios de production d’entreprise, vous pouvez avoir haute disponibilité (HA) et l’évolutivité de facile à gérer par l’équilibrage de charge sur plusieurs nœuds, serveurs et les machines virtuelles, ainsi que les basculements « intelligents ». donc, si un serveur ou un nœud tombe en panne, ses services et conteneurs doit être déplacé vers un autre serveur hôte ou une machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="149f2-221">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="149f2-222">Dans ce cas, vous avez besoin des technologies plus avancées telles que les clusters de conteneurs, les orchestrateurs et les planificateurs.</span><span class="sxs-lookup"><span data-stu-id="149f2-222">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="149f2-223">Par conséquent, la façon de déployer à ces clusters est en gérant les scénarios avancés expliquée dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="149f2-223">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="149f2-224">Déploiement d’applications de Docker sur des clusters Docker</span><span class="sxs-lookup"><span data-stu-id="149f2-224">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="149f2-225">La nature des applications distribuées nécessite des ressources de calcul sont également distribués.</span><span class="sxs-lookup"><span data-stu-id="149f2-225">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="149f2-226">Pour que les fonctionnalités à l’échelle de production, vous devez disposer de fonctionnalités qui fournissent une grande SCALABILITÉ et haute disponibilité en fonction des ressources regroupées de clustering.</span><span class="sxs-lookup"><span data-stu-id="149f2-226">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="149f2-227">Vous pouvez déployer des conteneurs manuellement à ces clusters à partir d’un outil CLI ou un site web de l’interface utilisateur, mais vous devez réserver ce genre de travail manuel au test de déploiement directs ou à des fins de gestion telles que l’évolution horizontale ou d’analyse.</span><span class="sxs-lookup"><span data-stu-id="149f2-227">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="149f2-228">À partir d’un point de vue de CD et les Services Azure DevOps en particulier, vous pouvez exécuter des tâches de déploiement spécialement effectuées à partir de vos environnements Azure DevOps Services Release Management que vous allez déployer vos applications en conteneur pour les clusters répartis dans le conteneur Service, comme illustré dans la Figure 5-9.</span><span class="sxs-lookup"><span data-stu-id="149f2-228">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![Déployer le CD étape (4) peut également publier sur des clusters via orchestrateurs.](./media/image9.png)

<span data-ttu-id="149f2-230">**Figure 5-9**.</span><span class="sxs-lookup"><span data-stu-id="149f2-230">**Figure 5-9**.</span></span> <span data-ttu-id="149f2-231">Déploiement d’applications distribuées au Service de conteneur</span><span class="sxs-lookup"><span data-stu-id="149f2-231">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="149f2-232">Au départ, lorsque vous déployez à certains clusters ou les orchestrateurs, vous traditionnellement utiliseriez mécanismes par chaque orchestrateur (autrement dit, Kubernetes et Service Fabric disposent de mécanismes de déploiement différents) et les scripts de déploiement spécifique au lieu de la plus simple et facile à utiliser `docker-compose` outil basé sur le `docker-compose.yml` fichier de définition.</span><span class="sxs-lookup"><span data-stu-id="149f2-232">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="149f2-233">Toutefois, grâce à la tâche de déploiement du Docker Services Azure DevOps, illustrée à la Figure 5-10, vous maintenant également pourrez déployer sur les orchestrateurs pris en charge en utilisant simplement votre familier `docker-compose.yml` fichier étant donné que l’outil effectue cette « traduction » pour vous (à partir de votre `docker-compose.yml`fichier au format requis par l’orchestrateur).</span><span class="sxs-lookup"><span data-stu-id="149f2-233">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that “translation” for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Affichage du navigateur du catalogue des tâches dans Azure DevOps, montrant le déployer sur les tâches de Kubernetes.](./media/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="149f2-235">**Figure 5-10**.</span><span class="sxs-lookup"><span data-stu-id="149f2-235">**Figure 5-10**.</span></span> <span data-ttu-id="149f2-236">Ajout de la déployer à la tâche de Kubernetes à votre environnement</span><span class="sxs-lookup"><span data-stu-id="149f2-236">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="149f2-237">Figure 5-11 montre comment vous pouvez modifier le déployer sur les tâches de Kubernetes avec les sections disponibles pour la configuration.</span><span class="sxs-lookup"><span data-stu-id="149f2-237">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="149f2-238">Il s’agit de la tâche qui récupérera vos images Docker personnalisées de prêts à l’emploi pour être déployé en tant que conteneurs dans le cluster.</span><span class="sxs-lookup"><span data-stu-id="149f2-238">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Affichage du navigateur de Azure DevOps, déployez à la définition de tâche de Kubernetes.](./media/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="149f2-240">**Figure 5-11**.</span><span class="sxs-lookup"><span data-stu-id="149f2-240">**Figure 5-11**.</span></span> <span data-ttu-id="149f2-241">Déploiement de docker déployer tâche définition vers ACS DC/OS</span><span class="sxs-lookup"><span data-stu-id="149f2-241">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> [! INFORMATIONS]<span data-ttu-id="149f2-242"> pour en savoir plus sur le pipeline de CD avec Azure DevOps Services et Docker, visitez <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="149f2-242"> To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="149f2-243">Étape 5 : Exécuter et gérer</span><span class="sxs-lookup"><span data-stu-id="149f2-243">Step 5: Run and manage</span></span>

<span data-ttu-id="149f2-244">Étant donné qu’en cours d’exécution et la gestion des applications en production de l’entreprise au niveau est un sujet majeur dans et de lui-même, en raison du type d’opérations et personnes travaillent à ce niveau (opérations informatiques), ainsi que l’étendue de grande taille de cette zone, tout le chapitre suivant est consacré à l’explication.</span><span class="sxs-lookup"><span data-stu-id="149f2-244">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="149f2-245">Étape 6 : Surveiller et diagnostiquer</span><span class="sxs-lookup"><span data-stu-id="149f2-245">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="149f2-246">Cette rubrique est également couvert dans le prochain chapitre dans le cadre des tâches qu’il effectue dans les systèmes de production ; Toutefois, il est important de souligner que les informations obtenues lors de cette étape doivent flux à l’équipe de développement afin que l’application est améliorée en permanence.</span><span class="sxs-lookup"><span data-stu-id="149f2-246">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="149f2-247">À partir de ce point de vue, il fait également partie de DevOps, bien que les tâches et les opérations sont communément exécutées en informatique.</span><span class="sxs-lookup"><span data-stu-id="149f2-247">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="149f2-248">Uniquement lors de la surveillance et diagnostic est 100 % dans le domaine du DevOps sont les processus de surveillance et les analytique effectuée par l’équipe de développement par rapport à des environnements de test ou de la version bêta.</span><span class="sxs-lookup"><span data-stu-id="149f2-248">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="149f2-249">Pour cela en effectuant des tests de charge ou en surveillant la version bêta ou les environnements d’assurance qualité, où les bêta-testeurs essayez les nouvelles versions.</span><span class="sxs-lookup"><span data-stu-id="149f2-249">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="149f2-250">[Précédent](index.md)
>[Suivant](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="149f2-250">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
