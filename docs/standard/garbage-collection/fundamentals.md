---
title: Notions de base du garbage collection
description: Découvrez comment fonctionne le récupérateur de mémoire et comment le configurer pour optimiser ses performances.
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: 98dee04593ea26bbbc3079f5da98d8106a373168
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/02/2020
ms.locfileid: "84286065"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="cb01e-103">Notions de base du garbage collection</span><span class="sxs-lookup"><span data-stu-id="cb01e-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="cb01e-104">Dans le common language runtime (CLR), le garbage collector (GC) sert de gestionnaire de mémoire automatique.</span><span class="sxs-lookup"><span data-stu-id="cb01e-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="cb01e-105">Le garbage collector gère l’allocation et la libération de mémoire pour une application.</span><span class="sxs-lookup"><span data-stu-id="cb01e-105">The garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="cb01e-106">Pour les développeurs qui utilisent du code managé, cela signifie que vous n’avez pas besoin d’écrire du code pour effectuer des tâches de gestion de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="cb01e-106">For developers working with managed code, this means that you don't have to write code to perform memory management tasks.</span></span> <span data-ttu-id="cb01e-107">La gestion automatique de la mémoire permet d’éliminer les problèmes courants, tels que l’oubli de libérer un objet et de provoquer une fuite de mémoire ou une tentative d’accès à la mémoire pour un objet qui a déjà été libéré.</span><span class="sxs-lookup"><span data-stu-id="cb01e-107">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak or attempting to access memory for an object that's already been freed.</span></span>

<span data-ttu-id="cb01e-108">Cet article décrit les concepts fondamentaux de garbage collection.</span><span class="sxs-lookup"><span data-stu-id="cb01e-108">This article describes the core concepts of garbage collection.</span></span>

## <a name="benefits"></a><span data-ttu-id="cb01e-109">Avantages</span><span class="sxs-lookup"><span data-stu-id="cb01e-109">Benefits</span></span>

<span data-ttu-id="cb01e-110">Le garbage collector offre les avantages suivants :</span><span class="sxs-lookup"><span data-stu-id="cb01e-110">The garbage collector provides the following benefits:</span></span>

- <span data-ttu-id="cb01e-111">Évite aux développeurs d’avoir à libérer manuellement de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="cb01e-111">Frees developers from having to manually release memory.</span></span>

- <span data-ttu-id="cb01e-112">Il alloue efficacement les objets sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-112">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="cb01e-113">Il libère les objets qui ne sont plus utilisés, efface leur mémoire et garde la mémoire disponible pour les futures allocations.</span><span class="sxs-lookup"><span data-stu-id="cb01e-113">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="cb01e-114">Les objets managés obtiennent automatiquement un contenu propre au démarrage, de sorte que leurs constructeurs n’ont pas à initialiser chaque champ de données.</span><span class="sxs-lookup"><span data-stu-id="cb01e-114">Managed objects automatically get clean content to start with, so their constructors don't have to initialize every data field.</span></span>

- <span data-ttu-id="cb01e-115">Il sécurise la mémoire en s'assurant qu'un objet ne peut pas utiliser le contenu d'un autre objet.</span><span class="sxs-lookup"><span data-stu-id="cb01e-115">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="cb01e-116">Notions de base de la mémoire</span><span class="sxs-lookup"><span data-stu-id="cb01e-116">Fundamentals of memory</span></span>

<span data-ttu-id="cb01e-117">La liste suivante résume les concepts importants de la mémoire CLR.</span><span class="sxs-lookup"><span data-stu-id="cb01e-117">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="cb01e-118">Chaque processus possède son propre espace d'adressage virtuel séparé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-118">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="cb01e-119">Tous les processus sur le même ordinateur partagent la même mémoire physique et le même fichier d’échange, le cas échéant.</span><span class="sxs-lookup"><span data-stu-id="cb01e-119">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="cb01e-120">Par défaut, sur les ordinateurs 32 bits, chaque processus a un espace d'adressage virtuel en mode utilisateur de 2 Go.</span><span class="sxs-lookup"><span data-stu-id="cb01e-120">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="cb01e-121">En tant que développeur d'applications, vous travaillez uniquement avec l'espace d'adressage virtuel et ne gérez jamais directement la mémoire physique.</span><span class="sxs-lookup"><span data-stu-id="cb01e-121">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="cb01e-122">Le garbage collector alloue et libère la mémoire virtuelle pour vous sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-122">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="cb01e-123">Si vous écrivez du code natif, vous utilisez des fonctions Windows pour travailler avec l’espace d’adressage virtuel.</span><span class="sxs-lookup"><span data-stu-id="cb01e-123">If you're writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="cb01e-124">Ces fonctions allouent et libèrent la mémoire virtuelle pour vous sur les tas natifs.</span><span class="sxs-lookup"><span data-stu-id="cb01e-124">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="cb01e-125">La mémoire virtuelle peut être dans trois états :</span><span class="sxs-lookup"><span data-stu-id="cb01e-125">Virtual memory can be in three states:</span></span>

  | <span data-ttu-id="cb01e-126">État</span><span class="sxs-lookup"><span data-stu-id="cb01e-126">State</span></span> | <span data-ttu-id="cb01e-127">Description</span><span class="sxs-lookup"><span data-stu-id="cb01e-127">Description</span></span> |
  |---------|---------|
  | <span data-ttu-id="cb01e-128">Gratuit</span><span class="sxs-lookup"><span data-stu-id="cb01e-128">Free</span></span> | <span data-ttu-id="cb01e-129">Il n'existe aucune référence au bloc de mémoire et celui-ci est disponible pour allocation.</span><span class="sxs-lookup"><span data-stu-id="cb01e-129">The block of memory has no references to it and is available for allocation.</span></span> |
  | <span data-ttu-id="cb01e-130">Réservé</span><span class="sxs-lookup"><span data-stu-id="cb01e-130">Reserved</span></span> | <span data-ttu-id="cb01e-131">Le bloc de mémoire est disponible pour votre utilisation et ne peut pas être utilisé pour une autre demande d'allocation.</span><span class="sxs-lookup"><span data-stu-id="cb01e-131">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="cb01e-132">Toutefois, vous ne pouvez pas stocker de données dans ce bloc de mémoire tant qu'il n'est pas validé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-132">However, you cannot store data to this memory block until it is committed.</span></span> |
  | <span data-ttu-id="cb01e-133">Committed</span><span class="sxs-lookup"><span data-stu-id="cb01e-133">Committed</span></span> | <span data-ttu-id="cb01e-134">Le bloc de mémoire est assigné au stockage physique.</span><span class="sxs-lookup"><span data-stu-id="cb01e-134">The block of memory is assigned to physical storage.</span></span> |

- <span data-ttu-id="cb01e-135">L'espace d'adressage virtuel peut être fragmenté.</span><span class="sxs-lookup"><span data-stu-id="cb01e-135">Virtual address space can get fragmented.</span></span> <span data-ttu-id="cb01e-136">Cela signifie qu'il existe des blocs libres, également appelés trous, dans l'espace d'adressage.</span><span class="sxs-lookup"><span data-stu-id="cb01e-136">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="cb01e-137">Lorsqu'une allocation de mémoire virtuelle est demandée, le gestionnaire de mémoire virtuelle doit rechercher un bloc unique libre suffisamment grand pour satisfaire la demande d'allocation.</span><span class="sxs-lookup"><span data-stu-id="cb01e-137">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="cb01e-138">Même si vous disposez de 2 Go d’espace libre, une allocation qui requiert 2 Go échoue, sauf si tout cet espace libre se trouve dans un bloc d’adresses unique.</span><span class="sxs-lookup"><span data-stu-id="cb01e-138">Even if you have 2 GB of free space, an allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="cb01e-139">Vous pouvez manquer de mémoire s’il n’y a pas suffisamment d’espace d’adressage virtuel à réserver ou d’espace physique à valider.</span><span class="sxs-lookup"><span data-stu-id="cb01e-139">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="cb01e-140">Le fichier d’échange est utilisé même si la sollicitation de la mémoire physique (c’est-à-dire, la demande de mémoire physique) est faible.</span><span class="sxs-lookup"><span data-stu-id="cb01e-140">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="cb01e-141">La première fois que la sollicitation de la mémoire physique est élevée, le système d’exploitation doit libérer de l’espace dans la mémoire physique pour stocker les données, et il sauvegarde certaines des données qui se trouvent dans la mémoire physique dans le fichier d’échange.</span><span class="sxs-lookup"><span data-stu-id="cb01e-141">The first time physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="cb01e-142">Ces données ne sont pas paginées tant qu’elles ne sont pas nécessaires, il est donc possible de rencontrer la pagination dans les situations où la sollicitation de la mémoire physique est faible.</span><span class="sxs-lookup"><span data-stu-id="cb01e-142">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>
  
### <a name="memory-allocation"></a><span data-ttu-id="cb01e-143">Allocation de mémoire</span><span class="sxs-lookup"><span data-stu-id="cb01e-143">Memory allocation</span></span>

<span data-ttu-id="cb01e-144">Lorsque vous initialisez un nouveau processus, le runtime réserve une région d'espace d'adressage contigu pour le processus.</span><span class="sxs-lookup"><span data-stu-id="cb01e-144">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="cb01e-145">Cet espace d'adressage est appelé le tas managé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-145">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="cb01e-146">Le tas managé garde un pointeur vers l'adresse qui sera allouée au nouvel objet du tas.</span><span class="sxs-lookup"><span data-stu-id="cb01e-146">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="cb01e-147">À l’origine, ce pointeur indique l’adresse de base du tas managé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-147">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="cb01e-148">Tous les types référence sont alloués sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-148">All reference types are allocated on the managed heap.</span></span> <span data-ttu-id="cb01e-149">Lorsqu’une application crée le premier type référence, la mémoire est allouée pour le type à l’adresse de base du tas managé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-149">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="cb01e-150">Lorsque l'application crée l'objet suivant, le « garbage collector » lui alloue de la mémoire dans l'espace d'adressage qui suit immédiatement le premier objet.</span><span class="sxs-lookup"><span data-stu-id="cb01e-150">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="cb01e-151">Aussi longtemps que de l'espace d'adressage est disponible, le « garbage collector » continue à allouer de l'espace pour de nouveaux objets selon la même procédure.</span><span class="sxs-lookup"><span data-stu-id="cb01e-151">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>

<span data-ttu-id="cb01e-152">L'allocation de mémoire à partir du tas managé est plus rapide que l'allocation de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="cb01e-152">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="cb01e-153">Étant donné que le runtime alloue de la mémoire pour un objet en ajoutant une valeur à un pointeur, il est presque aussi rapide que d’allouer de la mémoire à partir de la pile.</span><span class="sxs-lookup"><span data-stu-id="cb01e-153">Because the runtime allocates memory for an object by adding a value to a pointer, it's almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="cb01e-154">En outre, étant donné que les nouveaux objets qui sont alloués consécutivement sont stockés de façon contiguë dans le tas managé, une application peut accéder rapidement aux objets.</span><span class="sxs-lookup"><span data-stu-id="cb01e-154">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects quickly.</span></span>

### <a name="memory-release"></a><span data-ttu-id="cb01e-155">Mise en mémoire</span><span class="sxs-lookup"><span data-stu-id="cb01e-155">Memory release</span></span>

<span data-ttu-id="cb01e-156">Le moteur d'optimisation du « garbage collector » détermine le meilleur moment pour lancer une opération garbage collection sur base des allocations de mémoire effectuées.</span><span class="sxs-lookup"><span data-stu-id="cb01e-156">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="cb01e-157">Lorsque le « garbage collector » effectue une opération garbage collection, il libère la mémoire pour les objets qui ne sont plus utilisées par l'application.</span><span class="sxs-lookup"><span data-stu-id="cb01e-157">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="cb01e-158">Il détermine les objets qui ne sont plus utilisés en examinant les *racines*de l’application.</span><span class="sxs-lookup"><span data-stu-id="cb01e-158">It determines which objects are no longer being used by examining the application's *roots*.</span></span> <span data-ttu-id="cb01e-159">Les racines de l’application comprennent des champs statiques, des variables et des paramètres locaux sur la pile d’un thread et des Registres du processeur.</span><span class="sxs-lookup"><span data-stu-id="cb01e-159">An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</span></span> <span data-ttu-id="cb01e-160">Chaque racine fait référence à un objet du tas managé ou, à défaut, a la valeur Null.</span><span class="sxs-lookup"><span data-stu-id="cb01e-160">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="cb01e-161">Le Garbage collector a accès à la liste des racines actives entretenues par le compilateur juste-à-temps (JIT) et le runtime.</span><span class="sxs-lookup"><span data-stu-id="cb01e-161">The garbage collector has access to the list of active roots that the just-in-time (JIT) compiler and the runtime maintain.</span></span> <span data-ttu-id="cb01e-162">À l’aide de cette liste, le garbage collector crée un graphique qui contient tous les objets accessibles à partir des racines.</span><span class="sxs-lookup"><span data-stu-id="cb01e-162">Using this list, the garbage collector creates a graph that contains all the objects that are reachable from the roots.</span></span>

<span data-ttu-id="cb01e-163">Les objets non compris dans le graphique ne sont pas accessibles à partir des racines de l'application.</span><span class="sxs-lookup"><span data-stu-id="cb01e-163">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="cb01e-164">Le garbage collector considère que les objets inaccessibles sont nettoyés et libère la mémoire qui leur est allouée.</span><span class="sxs-lookup"><span data-stu-id="cb01e-164">The garbage collector considers unreachable objects garbage and releases the memory allocated for them.</span></span> <span data-ttu-id="cb01e-165">Au cours d'une opération garbage collection, le « garbage collector » examine le tas managé pour y détecter les blocs de mémoire occupés par des objets inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="cb01e-165">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="cb01e-166">Chaque fois qu'il détecte un objet inaccessible, il utilise une fonction de copie de mémoire pour compacter les objets accessibles en mémoire et libérer les blocs d'espaces d'adressage alloués aux objets inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="cb01e-166">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="cb01e-167">Lorsque la mémoire allouée aux objets accessibles a été réduite, le « garbage collector » procède aux corrections de pointeurs nécessaires pour que les racines des applications pointent vers les nouveaux emplacements des objets.</span><span class="sxs-lookup"><span data-stu-id="cb01e-167">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="cb01e-168">Il positionne aussi le pointeur du tas managé après le dernier objet accessible.</span><span class="sxs-lookup"><span data-stu-id="cb01e-168">It also positions the managed heap's pointer after the last reachable object.</span></span>

<span data-ttu-id="cb01e-169">La mémoire est compactée uniquement si une collection Découvre un nombre significatif d’objets inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="cb01e-169">Memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="cb01e-170">Si tous les objets du tas managé survivent à une collection, il n'est pas nécessaire de procéder à un compactage de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="cb01e-170">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>

<span data-ttu-id="cb01e-171">Pour améliorer les performances, le runtime alloue de la mémoire pour les objets de grandes dimensions dans un tas séparé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-171">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="cb01e-172">Le « garbage collector » libère automatiquement la mémoire des objets de grande dimension.</span><span class="sxs-lookup"><span data-stu-id="cb01e-172">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="cb01e-173">Toutefois, pour éviter de déplacer des objets volumineux en mémoire, cette mémoire n’est généralement pas compactée.</span><span class="sxs-lookup"><span data-stu-id="cb01e-173">However, to avoid moving large objects in memory, this memory is usually not compacted.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="cb01e-174">Conditions pour une opération garbage collection</span><span class="sxs-lookup"><span data-stu-id="cb01e-174">Conditions for a garbage collection</span></span>

<span data-ttu-id="cb01e-175">Le garbage collection se produit lorsque l'une des conditions suivantes est vraie :</span><span class="sxs-lookup"><span data-stu-id="cb01e-175">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="cb01e-176">Le système possède peu de mémoire physique.</span><span class="sxs-lookup"><span data-stu-id="cb01e-176">The system has low physical memory.</span></span> <span data-ttu-id="cb01e-177">Cela est détecté par la notification de mémoire insuffisante du système d’exploitation ou la mémoire insuffisante, comme indiqué par l’hôte.</span><span class="sxs-lookup"><span data-stu-id="cb01e-177">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="cb01e-178">La mémoire utilisée par les objets alloués sur le tas managé dépasse un seuil acceptable.</span><span class="sxs-lookup"><span data-stu-id="cb01e-178">The memory that's used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="cb01e-179">Ce seuil est continuellement ajusté à mesure que le processus s'exécute.</span><span class="sxs-lookup"><span data-stu-id="cb01e-179">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="cb01e-180">La méthode <xref:System.GC.Collect%2A?displayProperty=nameWithType> est appelée.</span><span class="sxs-lookup"><span data-stu-id="cb01e-180">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="cb01e-181">Dans presque tous les cas, il n’est pas nécessaire d’appeler cette méthode, car le garbage collector s’exécute en continu.</span><span class="sxs-lookup"><span data-stu-id="cb01e-181">In almost all cases, you don't have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="cb01e-182">Cette méthode est principalement utilisée pour les situations uniques et les tests.</span><span class="sxs-lookup"><span data-stu-id="cb01e-182">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="cb01e-183">Tas managé</span><span class="sxs-lookup"><span data-stu-id="cb01e-183">The managed heap</span></span>

<span data-ttu-id="cb01e-184">Une fois que le garbage collector est initialisé par le CLR, il alloue un segment de mémoire pour stocker et gérer des objets.</span><span class="sxs-lookup"><span data-stu-id="cb01e-184">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="cb01e-185">Cette mémoire est appelée tas managé, par opposition à un tas natif dans le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="cb01e-185">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="cb01e-186">Il existe un tas managé pour chaque processus managé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-186">There is a managed heap for each managed process.</span></span> <span data-ttu-id="cb01e-187">Tous les threads du processus allouent de la mémoire pour les objets sur le même tas.</span><span class="sxs-lookup"><span data-stu-id="cb01e-187">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="cb01e-188">Pour réserver de la mémoire, le garbage collector appelle la fonction [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) de Windows et réserve un segment de mémoire à la fois pour les applications managées.</span><span class="sxs-lookup"><span data-stu-id="cb01e-188">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="cb01e-189">Le garbage collector réserve également des segments, si nécessaire, et libère des segments dans le système d’exploitation (après avoir effacé leurs objets) en appelant la fonction [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) de Windows.</span><span class="sxs-lookup"><span data-stu-id="cb01e-189">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="cb01e-190">La taille des segments alloués par le garbage collector est spécifique à l'implémentation et susceptible de changer à tout moment, y compris les mises à jour périodiques.</span><span class="sxs-lookup"><span data-stu-id="cb01e-190">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="cb01e-191">Votre application ne doit jamais faire d'hypothèses concernant une taille de segment particulière, ni dépendre de celle-ci. Elle ne doit pas non plus tenter de configurer la quantité de mémoire disponible pour les allocations de segments.</span><span class="sxs-lookup"><span data-stu-id="cb01e-191">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="cb01e-192">Moins il y a d'objets alloués sur le tas, moins le garbage collector a à faire.</span><span class="sxs-lookup"><span data-stu-id="cb01e-192">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="cb01e-193">Lorsque vous allouez des objets, n’utilisez pas de valeurs arrondies qui dépassent vos besoins, par exemple l’allocation d’un tableau de 32 octets lorsque vous n’avez besoin que de 15 octets.</span><span class="sxs-lookup"><span data-stu-id="cb01e-193">When you allocate objects, don't use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="cb01e-194">Lorsqu’un garbage collection est déclenché, le garbage collector récupère la mémoire occupée par les objets morts.</span><span class="sxs-lookup"><span data-stu-id="cb01e-194">When a garbage collection is triggered, the garbage collector reclaims the memory that's occupied by dead objects.</span></span> <span data-ttu-id="cb01e-195">Le processus de libération compacte les objets vivants afin qu'ils soient déplacés ensemble, et l'espace inutilisé est supprimé, ce qui entraîne la diminution du tas.</span><span class="sxs-lookup"><span data-stu-id="cb01e-195">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="cb01e-196">Cela garantit que les objets alloués ensemble restent ensemble sur le tas managé pour conserver leur localité.</span><span class="sxs-lookup"><span data-stu-id="cb01e-196">This ensures that objects that are allocated together stay together on the managed heap to preserve their locality.</span></span>

<span data-ttu-id="cb01e-197">Le déroulement (fréquence et durée) des garbage collection est le résultat du volume des allocations et de la quantité de mémoire restante sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-197">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="cb01e-198">Le tas peut être considéré comme l’accumulation de deux tas : le [tas de grands objets](large-object-heap.md) et le tas de petits objets.</span><span class="sxs-lookup"><span data-stu-id="cb01e-198">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span> <span data-ttu-id="cb01e-199">Le tas d’objets volumineux contient des objets de 85 000 octets et plus grands, qui sont généralement des tableaux.</span><span class="sxs-lookup"><span data-stu-id="cb01e-199">The large object heap contains objects that are 85,000 bytes and larger, which are usually arrays.</span></span> <span data-ttu-id="cb01e-200">Il est rare qu’un objet d’instance soit extrêmement volumineux.</span><span class="sxs-lookup"><span data-stu-id="cb01e-200">It's rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="cb01e-201">Vous pouvez [configurer la taille de seuil](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) pour les objets à atteindre sur le tas d’objets volumineux.</span><span class="sxs-lookup"><span data-stu-id="cb01e-201">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="cb01e-202">Générations</span><span class="sxs-lookup"><span data-stu-id="cb01e-202">Generations</span></span>

<span data-ttu-id="cb01e-203">L’algorithme GC est basé sur plusieurs considérations :</span><span class="sxs-lookup"><span data-stu-id="cb01e-203">The GC algorithm is based on several considerations:</span></span>

- <span data-ttu-id="cb01e-204">Il est plus rapide de compacter la mémoire pour une partie du tas managé que pour l’intégralité du tas managé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-204">It's faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span>
- <span data-ttu-id="cb01e-205">Les objets plus récents ont des durées de vie plus courtes et les objets plus anciens ont des durées de vie plus longues.</span><span class="sxs-lookup"><span data-stu-id="cb01e-205">Newer objects have shorter lifetimes and older objects have longer lifetimes.</span></span>
- <span data-ttu-id="cb01e-206">Les objets les plus récents ont tendance à être liés les uns aux autres et à être accessibles à l’application en même temps.</span><span class="sxs-lookup"><span data-stu-id="cb01e-206">Newer objects tend to be related to each other and accessed by the application around the same time.</span></span>

<span data-ttu-id="cb01e-207">Le garbage collection se produit principalement avec la récupération d’objets éphémères.</span><span class="sxs-lookup"><span data-stu-id="cb01e-207">Garbage collection primarily occurs with the reclamation of short-lived objects.</span></span> <span data-ttu-id="cb01e-208">Pour optimiser les performances du garbage collector, le tas managé est divisé en trois générations, 0, 1 et 2. il peut donc gérer séparément les objets à durée de vie et à courte durée de vie.</span><span class="sxs-lookup"><span data-stu-id="cb01e-208">To optimize the performance of the garbage collector, the managed heap is divided into three generations, 0, 1, and 2, so it can handle long-lived and short-lived objects separately.</span></span> <span data-ttu-id="cb01e-209">Le garbage collector stocke les nouveaux objets dans la génération 0.</span><span class="sxs-lookup"><span data-stu-id="cb01e-209">The garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="cb01e-210">Les objets qui sont créés à un stade précoce de la durée de vie de l'application et qui survivent aux collectes sont promus et stockés dans les générations 1 et 2.</span><span class="sxs-lookup"><span data-stu-id="cb01e-210">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="cb01e-211">Étant donné qu’il est plus rapide de compacter une partie du tas managé que le tas entier, ce schéma permet au garbage collector de libérer la mémoire dans une génération spécifique plutôt que de libérer la mémoire pour l’intégralité du tas managé chaque fois qu’il effectue une collection.</span><span class="sxs-lookup"><span data-stu-id="cb01e-211">Because it's faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>

- <span data-ttu-id="cb01e-212">**Génération 0**.</span><span class="sxs-lookup"><span data-stu-id="cb01e-212">**Generation 0**.</span></span> <span data-ttu-id="cb01e-213">Il s'agit de la génération la plus jeune, qui contient des objets éphémères.</span><span class="sxs-lookup"><span data-stu-id="cb01e-213">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="cb01e-214">Un exemple d'objet éphémère est une variable temporaire.</span><span class="sxs-lookup"><span data-stu-id="cb01e-214">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="cb01e-215">Le garbage collection a le plus souvent lieu dans cette génération.</span><span class="sxs-lookup"><span data-stu-id="cb01e-215">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="cb01e-216">Les objets alloués récemment forment une nouvelle génération d’objets et sont implicitement des collections de génération 0.</span><span class="sxs-lookup"><span data-stu-id="cb01e-216">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="cb01e-217">Toutefois, s’il s’agit d’objets volumineux, ils sont placés sur le tas d’objets volumineux (LOH), parfois appelé *génération 3*.</span><span class="sxs-lookup"><span data-stu-id="cb01e-217">However, if they are large objects, they go on the large object heap (LOH), which is sometimes referred to as *generation 3*.</span></span> <span data-ttu-id="cb01e-218">La génération 3 est une génération physique qui est collectée logiquement dans le cadre de la génération 2.</span><span class="sxs-lookup"><span data-stu-id="cb01e-218">Generation 3 is a physical generation that's logically collected as part of generation 2.</span></span>

  <span data-ttu-id="cb01e-219">La plupart des objets sont récupérés pour garbage collection dans la génération 0 et ne survivent pas à la génération suivante.</span><span class="sxs-lookup"><span data-stu-id="cb01e-219">Most objects are reclaimed for garbage collection in generation 0 and don't survive to the next generation.</span></span>
  
  <span data-ttu-id="cb01e-220">Si une application tente de créer un nouvel objet lorsque la génération 0 est complète, le garbage collector effectue une collection pour tenter de libérer de l’espace d’adressage pour l’objet.</span><span class="sxs-lookup"><span data-stu-id="cb01e-220">If an application attempts to create a new object when generation 0 is full, the garbage collector performs a collection in an attempt to free address space for the object.</span></span> <span data-ttu-id="cb01e-221">Le « garbage collector » commence par examiner les objets de la génération 0 plutôt que tous les objets du tas managé.</span><span class="sxs-lookup"><span data-stu-id="cb01e-221">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="cb01e-222">Une collection de génération 0 récupère souvent suffisamment de mémoire pour permettre à l’application de continuer à créer des objets.</span><span class="sxs-lookup"><span data-stu-id="cb01e-222">A collection of generation 0 alone often reclaims enough memory to enable the application to continue creating new objects.</span></span>

- <span data-ttu-id="cb01e-223">**Génération 1**.</span><span class="sxs-lookup"><span data-stu-id="cb01e-223">**Generation 1**.</span></span> <span data-ttu-id="cb01e-224">Cette génération contient des objets éphémères et sert de tampon entre objets éphémères et objets durables.</span><span class="sxs-lookup"><span data-stu-id="cb01e-224">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

  <span data-ttu-id="cb01e-225">Une fois que le « garbage collector » effectue une opération garbage collection de la génération 0, il compacte la mémoire pour les objets accessibles et les promeut à la génération 1.</span><span class="sxs-lookup"><span data-stu-id="cb01e-225">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects and promotes them to generation 1.</span></span> <span data-ttu-id="cb01e-226">Étant donné que les objets qui survivent aux collectes ont tendance à avoir de plus longues durées de vie, il est logique de les promouvoir à une génération supérieure.</span><span class="sxs-lookup"><span data-stu-id="cb01e-226">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="cb01e-227">Le garbage collector n’a pas à réexaminer les objets des générations 1 et 2 chaque fois qu’il exécute une collection de génération 0.</span><span class="sxs-lookup"><span data-stu-id="cb01e-227">The garbage collector doesn't have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>
  
  <span data-ttu-id="cb01e-228">Si une collection de génération 0 ne libère pas assez de mémoire pour que l’application puisse créer un nouvel objet, le garbage collector peut exécuter une collection de génération 1, puis de génération 2.</span><span class="sxs-lookup"><span data-stu-id="cb01e-228">If a collection of generation 0 does not reclaim enough memory for the application to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="cb01e-229">Les objets qui survivent aux collectes sont promus et stockés dans les générations 1 et 2.</span><span class="sxs-lookup"><span data-stu-id="cb01e-229">Objects in generation 1 that survive collections are promoted to generation 2.</span></span>

- <span data-ttu-id="cb01e-230">**Génération 2**.</span><span class="sxs-lookup"><span data-stu-id="cb01e-230">**Generation 2**.</span></span> <span data-ttu-id="cb01e-231">Cette génération contient des objets durables.</span><span class="sxs-lookup"><span data-stu-id="cb01e-231">This generation contains long-lived objects.</span></span> <span data-ttu-id="cb01e-232">Un exemple d’objet de longue durée est un objet dans une application serveur qui contient des données statiques qui sont actives pendant la durée du processus.</span><span class="sxs-lookup"><span data-stu-id="cb01e-232">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

  <span data-ttu-id="cb01e-233">Les objets de génération 2 qui survivent à une collection restent dans la génération 2 jusqu’à ce qu’ils soient considérés comme inaccessibles dans une prochaine collection.</span><span class="sxs-lookup"><span data-stu-id="cb01e-233">Objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>
  
  <span data-ttu-id="cb01e-234">Les objets sur le tas d’objets volumineux (parfois appelé *génération 3*) sont également collectés dans la génération 2.</span><span class="sxs-lookup"><span data-stu-id="cb01e-234">Objects on the large object heap (which is sometimes referred to as *generation 3*) are also collected in generation 2.</span></span>

<span data-ttu-id="cb01e-235">Les opérations garbage collection se produisent sur des générations spécifiques, selon les conditions spécifiées.</span><span class="sxs-lookup"><span data-stu-id="cb01e-235">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="cb01e-236">La collecte d'une génération signifie la collecte des objets de cette génération et de toutes ses générations plus jeunes.</span><span class="sxs-lookup"><span data-stu-id="cb01e-236">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="cb01e-237">Une garbage collection de génération 2 est également appelée garbage collection complète, car elle libère des objets dans toutes les générations (autrement dit, tous les objets du tas managé).</span><span class="sxs-lookup"><span data-stu-id="cb01e-237">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="cb01e-238">Survie et promotions</span><span class="sxs-lookup"><span data-stu-id="cb01e-238">Survival and promotions</span></span>

<span data-ttu-id="cb01e-239">Les objets qui ne sont pas récupérés dans un garbage collection sont appelés survivants et sont promus à la génération suivante :</span><span class="sxs-lookup"><span data-stu-id="cb01e-239">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation:</span></span>

- <span data-ttu-id="cb01e-240">Les objets qui survivent à une garbage collection de génération 0 sont promus à la génération 1.</span><span class="sxs-lookup"><span data-stu-id="cb01e-240">Objects that survive a generation 0 garbage collection are promoted to generation 1.</span></span>
- <span data-ttu-id="cb01e-241">Les objets qui survivent à une garbage collection de génération 1 sont promus à la génération 2.</span><span class="sxs-lookup"><span data-stu-id="cb01e-241">Objects that survive a generation 1 garbage collection are promoted to generation 2.</span></span>
- <span data-ttu-id="cb01e-242">Les objets qui survivent à une garbage collection de génération 2 restent dans la génération 2.</span><span class="sxs-lookup"><span data-stu-id="cb01e-242">Objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="cb01e-243">Lorsque le garbage collector détecte que le taux de survie est élevé dans une génération, il augmente le seuil des allocations pour cette génération.</span><span class="sxs-lookup"><span data-stu-id="cb01e-243">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="cb01e-244">La collection suivante obtient une taille substantielle de mémoire libérée.</span><span class="sxs-lookup"><span data-stu-id="cb01e-244">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="cb01e-245">Le CLR équilibre continuellement deux priorités : ne pas permettre à la plage de travail d’une application d’être trop volumineuse en retardant garbage collection et en empêchant l’exécution trop fréquente du garbage collection.</span><span class="sxs-lookup"><span data-stu-id="cb01e-245">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="cb01e-246">Segments et générations éphémères</span><span class="sxs-lookup"><span data-stu-id="cb01e-246">Ephemeral generations and segments</span></span>

<span data-ttu-id="cb01e-247">Étant donné que les objets des générations 0 et 1 sont éphémères, ces générations sont appelées *générations éphémères*.</span><span class="sxs-lookup"><span data-stu-id="cb01e-247">Because objects in generations 0 and 1 are short-lived, these generations are known as the *ephemeral generations*.</span></span>

<span data-ttu-id="cb01e-248">Les générations éphémères sont allouées dans le segment de mémoire appelé segment éphémère.</span><span class="sxs-lookup"><span data-stu-id="cb01e-248">Ephemeral generations are allocated in the memory segment that's known as the ephemeral segment.</span></span> <span data-ttu-id="cb01e-249">Chaque nouveau segment acquis par le garbage collector devient le nouveau segment éphémère et contient les objets qui ont survécu à un garbage collection de génération 0.</span><span class="sxs-lookup"><span data-stu-id="cb01e-249">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="cb01e-250">L'ancien segment éphémère devient le nouveau segment de génération 2.</span><span class="sxs-lookup"><span data-stu-id="cb01e-250">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="cb01e-251">La taille du segment éphémère varie selon qu’il s’agit d’un système 32 bits ou 64 bits et du type de garbage collector en cours d’exécution (station de[travail ou GC de serveur](workstation-server-gc.md)).</span><span class="sxs-lookup"><span data-stu-id="cb01e-251">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit and on the type of garbage collector it is running ([workstation or server GC](workstation-server-gc.md)).</span></span> <span data-ttu-id="cb01e-252">Le tableau suivant indique les tailles par défaut du segment éphémère.</span><span class="sxs-lookup"><span data-stu-id="cb01e-252">The following table shows the default sizes of the ephemeral segment.</span></span>

|<span data-ttu-id="cb01e-253">GC station de travail/serveur</span><span class="sxs-lookup"><span data-stu-id="cb01e-253">Workstation/server GC</span></span>|<span data-ttu-id="cb01e-254">32 bits</span><span class="sxs-lookup"><span data-stu-id="cb01e-254">32-bit</span></span>|<span data-ttu-id="cb01e-255">64 bits</span><span class="sxs-lookup"><span data-stu-id="cb01e-255">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="cb01e-256">Garbage collector pour station de travail</span><span class="sxs-lookup"><span data-stu-id="cb01e-256">Workstation GC</span></span>|<span data-ttu-id="cb01e-257">16 Mo</span><span class="sxs-lookup"><span data-stu-id="cb01e-257">16 MB</span></span>|<span data-ttu-id="cb01e-258">256 octets</span><span class="sxs-lookup"><span data-stu-id="cb01e-258">256 MB</span></span>|
|<span data-ttu-id="cb01e-259">Garbage collector pour serveur</span><span class="sxs-lookup"><span data-stu-id="cb01e-259">Server GC</span></span>|<span data-ttu-id="cb01e-260">64 Mo</span><span class="sxs-lookup"><span data-stu-id="cb01e-260">64 MB</span></span>|<span data-ttu-id="cb01e-261">4 Go</span><span class="sxs-lookup"><span data-stu-id="cb01e-261">4 GB</span></span>|
|<span data-ttu-id="cb01e-262">Garbage collector pour serveur > 4 processeurs logiques</span><span class="sxs-lookup"><span data-stu-id="cb01e-262">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="cb01e-263">32 Mo</span><span class="sxs-lookup"><span data-stu-id="cb01e-263">32 MB</span></span>|<span data-ttu-id="cb01e-264">2 Go</span><span class="sxs-lookup"><span data-stu-id="cb01e-264">2 GB</span></span>|
|<span data-ttu-id="cb01e-265">Garbage collector pour serveur > 8 processeurs logiques</span><span class="sxs-lookup"><span data-stu-id="cb01e-265">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="cb01e-266">16 Mo</span><span class="sxs-lookup"><span data-stu-id="cb01e-266">16 MB</span></span>|<span data-ttu-id="cb01e-267">1 Go</span><span class="sxs-lookup"><span data-stu-id="cb01e-267">1 GB</span></span>|

<span data-ttu-id="cb01e-268">Le segment éphémère peut inclure des objets de la génération 2.</span><span class="sxs-lookup"><span data-stu-id="cb01e-268">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="cb01e-269">Les objets de génération 2 peuvent utiliser plusieurs segments (autant que votre processus en requiert et que la mémoire en autorise).</span><span class="sxs-lookup"><span data-stu-id="cb01e-269">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="cb01e-270">La quantité de mémoire libérée à partir d'un garbage collection éphémère est limitée à la taille du segment éphémère.</span><span class="sxs-lookup"><span data-stu-id="cb01e-270">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="cb01e-271">La quantité de mémoire libérée est proportionnelle à l'espace occupé par les objets morts.</span><span class="sxs-lookup"><span data-stu-id="cb01e-271">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="cb01e-272">Déroulement d’une opération garbage collection</span><span class="sxs-lookup"><span data-stu-id="cb01e-272">What happens during a garbage collection</span></span>

<span data-ttu-id="cb01e-273">Une opération garbage collection présente les phases suivantes :</span><span class="sxs-lookup"><span data-stu-id="cb01e-273">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="cb01e-274">Une phase de marquage qui recherche et crée une liste de tous les objets actifs.</span><span class="sxs-lookup"><span data-stu-id="cb01e-274">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="cb01e-275">Une phase de déplacement qui met à jour les références aux objets qui seront compactés.</span><span class="sxs-lookup"><span data-stu-id="cb01e-275">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="cb01e-276">Une phase de compactage qui libère l'espace occupé par les objets morts et compacte les objets survivants.</span><span class="sxs-lookup"><span data-stu-id="cb01e-276">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="cb01e-277">La phase de compactage déplace les objets qui ont survécu à un garbage collection vers l'extrémité la plus ancienne du segment.</span><span class="sxs-lookup"><span data-stu-id="cb01e-277">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="cb01e-278">Étant donné que les collections de génération 2 peuvent occuper plusieurs segments, les objets promus dans la génération 2 peuvent être déplacés dans un segment plus ancien.</span><span class="sxs-lookup"><span data-stu-id="cb01e-278">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="cb01e-279">Les survivants des générations 1 et 2 peuvent être déplacés vers un autre segment, car ils sont promus à la génération 2.</span><span class="sxs-lookup"><span data-stu-id="cb01e-279">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="cb01e-280">En règle générale, le tas d’objets volumineux (LOH) n’est pas compacté, car la copie d’objets volumineux impose une baisse des performances.</span><span class="sxs-lookup"><span data-stu-id="cb01e-280">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="cb01e-281">Toutefois, dans .NET Core et dans .NET Framework 4.5.1 et versions ultérieures, vous pouvez utiliser la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété pour compacter le tas d’objets volumineux à la demande.</span><span class="sxs-lookup"><span data-stu-id="cb01e-281">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="cb01e-282">En outre, le LOH est automatiquement compacté lorsqu’une limite inconditionnelle est définie en spécifiant l’un ou l’autre des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="cb01e-282">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="cb01e-283">Limite de mémoire sur un conteneur.</span><span class="sxs-lookup"><span data-stu-id="cb01e-283">A memory limit on a container.</span></span>
  - <span data-ttu-id="cb01e-284">Options de configuration [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) ou [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) Runtime.</span><span class="sxs-lookup"><span data-stu-id="cb01e-284">The [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) run-time configuration options.</span></span>

<span data-ttu-id="cb01e-285">Le garbage collector utilise les informations suivantes pour déterminer si les objets sont vivants :</span><span class="sxs-lookup"><span data-stu-id="cb01e-285">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="cb01e-286">**Racines de pile**.</span><span class="sxs-lookup"><span data-stu-id="cb01e-286">**Stack roots**.</span></span> <span data-ttu-id="cb01e-287">Variables de pile fournies par le compilateur juste-à-temps (JIT) et l'explorateur de pile.</span><span class="sxs-lookup"><span data-stu-id="cb01e-287">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="cb01e-288">Les optimisations JIT peuvent rallonger ou raccourcir les régions de code au sein desquelles les variables de pile sont signalées au garbage collector.</span><span class="sxs-lookup"><span data-stu-id="cb01e-288">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="cb01e-289">**Handles de garbage collection**.</span><span class="sxs-lookup"><span data-stu-id="cb01e-289">**Garbage collection handles**.</span></span> <span data-ttu-id="cb01e-290">Handles qui pointent vers les objets managés qui peuvent être alloués par le code utilisateur ou par le Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="cb01e-290">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="cb01e-291">**Données statiques**.</span><span class="sxs-lookup"><span data-stu-id="cb01e-291">**Static data**.</span></span> <span data-ttu-id="cb01e-292">Objets statiques des domaines d'application qui pourraient référencer d'autres objets.</span><span class="sxs-lookup"><span data-stu-id="cb01e-292">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="cb01e-293">Chaque domaine d'application effectue le suivi de ses objets statiques.</span><span class="sxs-lookup"><span data-stu-id="cb01e-293">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="cb01e-294">Avant qu'une opération garbage collection ne démarre, tous les threads managés sont suspendus à l'exception du thread qui a déclenché l'opération.</span><span class="sxs-lookup"><span data-stu-id="cb01e-294">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="cb01e-295">L'illustration suivante montre un thread qui déclenche un garbage collection et entraîne l'interruption des autres threads.</span><span class="sxs-lookup"><span data-stu-id="cb01e-295">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![Lorsqu'un thread déclenche un nettoyage de la mémoire](./media/gc-triggered.png)

## <a name="unmanaged-resources"></a><span data-ttu-id="cb01e-297">Ressources non managées</span><span class="sxs-lookup"><span data-stu-id="cb01e-297">Unmanaged resources</span></span>

<span data-ttu-id="cb01e-298">Pour la plupart des objets créés par votre application, vous pouvez vous appuyer sur garbage collection pour effectuer automatiquement les tâches de gestion de mémoire nécessaires.</span><span class="sxs-lookup"><span data-stu-id="cb01e-298">For most of the objects that your application creates, you can rely on garbage collection to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="cb01e-299">Cependant, les ressources non managées requièrent un nettoyage explicite.</span><span class="sxs-lookup"><span data-stu-id="cb01e-299">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="cb01e-300">Le type le plus répandu de ressource non managée est un objet qui enveloppe une ressource de système d'exploitation telle qu'un handle de fichier ou de fenêtre ou une connexion réseau.</span><span class="sxs-lookup"><span data-stu-id="cb01e-300">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="cb01e-301">Bien que le « garbage collector » soit en mesure de suivre la durée de vie d’un objet managé qui encapsule une ressource non managée, il n’a pas de connaissance spécifique sur le nettoyage de la ressource.</span><span class="sxs-lookup"><span data-stu-id="cb01e-301">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it doesn't have specific knowledge about how to clean up the resource.</span></span>

<span data-ttu-id="cb01e-302">Lorsque vous créez un objet qui encapsule une ressource non managée, il est recommandé de fournir le code nécessaire pour nettoyer la ressource non managée dans une `Dispose` méthode publique.</span><span class="sxs-lookup"><span data-stu-id="cb01e-302">When you create an object that encapsulates an unmanaged resource, it's recommended that you provide the necessary code to clean up the unmanaged resource in a public `Dispose` method.</span></span> <span data-ttu-id="cb01e-303">En fournissant une méthode `Dispose`, vous donnez la possibilité aux utilisateurs de votre objet d’en libérer explicitement la mémoire lorsqu’ils ont fini de s’en servir.</span><span class="sxs-lookup"><span data-stu-id="cb01e-303">By providing a `Dispose` method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="cb01e-304">Quand vous utilisez un objet qui encapsule une ressource non managée, veillez à appeler `Dispose` si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="cb01e-304">When you use an object that encapsulates an unmanaged resource, make sure to call `Dispose` as necessary.</span></span>

<span data-ttu-id="cb01e-305">Vous devez également fournir un moyen pour que vos ressources non managées soient libérées si un consommateur de votre type oublie d’appeler `Dispose` .</span><span class="sxs-lookup"><span data-stu-id="cb01e-305">You must also provide a way for your unmanaged resources to be released in case a consumer of your type forgets to call `Dispose`.</span></span> <span data-ttu-id="cb01e-306">Vous pouvez utiliser un handle sécurisé pour encapsuler la ressource non managée ou substituer la <xref:System.Object.Finalize?displayProperty=nameWithType> méthode.</span><span class="sxs-lookup"><span data-stu-id="cb01e-306">You can either use a safe handle to wrap the unmanaged resource, or override the <xref:System.Object.Finalize?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="cb01e-307">Pour plus d’informations sur le nettoyage des ressources non managées, consultez [nettoyer les ressources non managées](unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="cb01e-307">For more information about cleaning up unmanaged resources, see [Clean up unmanaged resources](unmanaged.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="cb01e-308">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="cb01e-308">See also</span></span>

- [<span data-ttu-id="cb01e-309">Garbage collection de station de travail et de serveur</span><span class="sxs-lookup"><span data-stu-id="cb01e-309">Workstation and server garbage collection</span></span>](workstation-server-gc.md)
- [<span data-ttu-id="cb01e-310">garbage collection d’arrière-plan</span><span class="sxs-lookup"><span data-stu-id="cb01e-310">Background garbage collection</span></span>](background-gc.md)
- [<span data-ttu-id="cb01e-311">Options de configuration pour GC</span><span class="sxs-lookup"><span data-stu-id="cb01e-311">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- [<span data-ttu-id="cb01e-312">Garbage collection</span><span class="sxs-lookup"><span data-stu-id="cb01e-312">Garbage collection</span></span>](index.md)
