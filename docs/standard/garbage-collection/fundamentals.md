---
title: Notions de base du garbage collection
description: Découvrez comment fonctionne le récupérateur de mémoire et comment le configurer pour optimiser ses performances.
ms.date: 03/08/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background garbage collection
- garbage collection, concurrent garbage collection
- garbage collection, server garbage collection
- garbage collection, workstation garbage collection
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 364ac31744d41d95ba20b598f8f137257ddbc608
ms.sourcegitcommit: d6e27023aeaffc4b5a3cb4b88685018d6284ada4
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/09/2019
ms.locfileid: "67663656"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="b9aa1-103">Notions de base du garbage collection</span><span class="sxs-lookup"><span data-stu-id="b9aa1-103">Fundamentals of garbage collection</span></span>

<a name="top"></a> <span data-ttu-id="b9aa1-104">Dans le Common Language Runtime (CLR), le garbage collector a un rôle de gestionnaire de mémoire automatique.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-104">In the common language runtime (CLR), the garbage collector serves as an automatic memory manager.</span></span> <span data-ttu-id="b9aa1-105">Il fournit les avantages suivants :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-105">It provides the following benefits:</span></span>

- <span data-ttu-id="b9aa1-106">Il vous permet de développer votre application sans avoir à libérer de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-106">Enables you to develop your application without having to free memory.</span></span>

- <span data-ttu-id="b9aa1-107">Il alloue efficacement les objets sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-107">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="b9aa1-108">Il libère les objets qui ne sont plus utilisés, efface leur mémoire et garde la mémoire disponible pour les futures allocations.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-108">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="b9aa1-109">Les objets managés obtiennent automatiquement un contenu propre au démarrage, ce qui fait que leurs constructeurs n'ont pas à initialiser chaque champ de données.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-109">Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</span></span>

- <span data-ttu-id="b9aa1-110">Il sécurise la mémoire en s'assurant qu'un objet ne peut pas utiliser le contenu d'un autre objet.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-110">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

 <span data-ttu-id="b9aa1-111">Cette rubrique décrit les concepts fondamentaux du garbage collection.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-111">This topic describes the core concepts of garbage collection.</span></span>

<a name="fundamentals_of_memory"></a>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="b9aa1-112">Notions de base de la mémoire</span><span class="sxs-lookup"><span data-stu-id="b9aa1-112">Fundamentals of memory</span></span>

<span data-ttu-id="b9aa1-113">La liste suivante résume les concepts importants de la mémoire CLR.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-113">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="b9aa1-114">Chaque processus possède son propre espace d'adressage virtuel séparé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-114">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="b9aa1-115">Tous les processus sur le même ordinateur partagent la même mémoire physique et le fichier d'échange s'il en existe un.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-115">All processes on the same computer share the same physical memory, and share the page file if there is one.</span></span>

- <span data-ttu-id="b9aa1-116">Par défaut, sur les ordinateurs 32 bits, chaque processus a un espace d'adressage virtuel en mode utilisateur de 2 Go.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-116">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="b9aa1-117">En tant que développeur d'applications, vous travaillez uniquement avec l'espace d'adressage virtuel et ne gérez jamais directement la mémoire physique.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-117">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="b9aa1-118">Le garbage collector alloue et libère la mémoire virtuelle pour vous sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-118">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="b9aa1-119">Si vous écrivez du code natif, vous utilisez des fonctions Win32 pour utiliser l'espace d'adressage virtuel.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-119">If you are writing native code, you use Win32 functions to work with the virtual address space.</span></span> <span data-ttu-id="b9aa1-120">Ces fonctions allouent et libèrent la mémoire virtuelle pour vous sur les tas natifs.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-120">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="b9aa1-121">La mémoire virtuelle peut être dans trois états :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-121">Virtual memory can be in three states:</span></span>

  - <span data-ttu-id="b9aa1-122">Libre.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-122">Free.</span></span> <span data-ttu-id="b9aa1-123">Il n'existe aucune référence au bloc de mémoire et celui-ci est disponible pour allocation.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-123">The block of memory has no references to it and is available for allocation.</span></span>

  - <span data-ttu-id="b9aa1-124">Réservé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-124">Reserved.</span></span> <span data-ttu-id="b9aa1-125">Le bloc de mémoire est disponible pour votre utilisation et ne peut pas être utilisé pour une autre demande d'allocation.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-125">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="b9aa1-126">Toutefois, vous ne pouvez pas stocker de données dans ce bloc de mémoire tant qu'il n'est pas validé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-126">However, you cannot store data to this memory block until it is committed.</span></span>

  - <span data-ttu-id="b9aa1-127">Validé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-127">Committed.</span></span> <span data-ttu-id="b9aa1-128">Le bloc de mémoire est assigné au stockage physique.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-128">The block of memory is assigned to physical storage.</span></span>

- <span data-ttu-id="b9aa1-129">L'espace d'adressage virtuel peut être fragmenté.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-129">Virtual address space can get fragmented.</span></span> <span data-ttu-id="b9aa1-130">Cela signifie qu'il existe des blocs libres, également appelés trous, dans l'espace d'adressage.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-130">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="b9aa1-131">Lorsqu'une allocation de mémoire virtuelle est demandée, le gestionnaire de mémoire virtuelle doit rechercher un bloc unique libre suffisamment grand pour satisfaire la demande d'allocation.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-131">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="b9aa1-132">Même si vous disposez de 2 Go d'espace libre, l'allocation qui requiert 2 Go échoue, sauf si tout cet espace libre est contenu dans un bloc d'adresse unique.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-132">Even if you have 2 GB of free space, the allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="b9aa1-133">Vous pouvez manquer de mémoire si vous manquez d'espace d'adressage virtuel à réserver ou d'espace physique à valider.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-133">You can run out of memory if you run out of virtual address space to reserve or physical space to commit.</span></span>

<span data-ttu-id="b9aa1-134">Votre fichier d'échange est utilisé, même si la sollicitation de la mémoire physique (c'est-à-dire, la demande de mémoire physique) est faible.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-134">Your page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="b9aa1-135">La première fois que la sollicitation de la mémoire physique est élevée, le système d'exploitation doit libérer de la place dans la mémoire physique pour stocker des données et sauvegarde une partie des données qui sont dans la mémoire physique dans le fichier d'échange.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-135">The first time your physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="b9aa1-136">Ces données ne sont pas paginées tant qu'elles ne sont pas nécessaires, il est donc possible de rencontrer la pagination dans les situations dans lesquelles la sollicitation de la mémoire physique est très faible.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-136">That data is not paged until it is needed, so it is possible to encounter paging in situations where the physical memory pressure is very low.</span></span>

[<span data-ttu-id="b9aa1-137">Retour au début</span><span class="sxs-lookup"><span data-stu-id="b9aa1-137">Back to top</span></span>](#top)

<a name="conditions_for_a_garbage_collection"></a>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="b9aa1-138">Conditions pour une opération garbage collection</span><span class="sxs-lookup"><span data-stu-id="b9aa1-138">Conditions for a garbage collection</span></span>

<span data-ttu-id="b9aa1-139">Le garbage collection se produit lorsque l'une des conditions suivantes est vraie :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-139">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="b9aa1-140">Le système possède peu de mémoire physique.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-140">The system has low physical memory.</span></span> <span data-ttu-id="b9aa1-141">Cette information nous est communiquée par la notification de mémoire insuffisante du système d’exploitation ou par un message similaire provenant de l’hôte.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-141">This is detected by either the low memory notification from the OS or low memory indicated by the host.</span></span>

- <span data-ttu-id="b9aa1-142">La mémoire utilisée par les objets alloués sur le tas managé dépasse un seuil acceptable.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-142">The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="b9aa1-143">Ce seuil est continuellement ajusté à mesure que le processus s'exécute.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-143">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="b9aa1-144">La méthode <xref:System.GC.Collect%2A?displayProperty=nameWithType> est appelée.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-144">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="b9aa1-145">Dans presque tous les cas, vous n'avez pas à appeler cette méthode, car le garbage collector s'exécute continuellement.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-145">In almost all cases, you do not have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="b9aa1-146">Cette méthode est principalement utilisée pour les situations uniques et les tests.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-146">This method is primarily used for unique situations and testing.</span></span>

[<span data-ttu-id="b9aa1-147">Retour au début</span><span class="sxs-lookup"><span data-stu-id="b9aa1-147">Back to top</span></span>](#top)

<a name="the_managed_heap"></a>

## <a name="the-managed-heap"></a><span data-ttu-id="b9aa1-148">Tas managé</span><span class="sxs-lookup"><span data-stu-id="b9aa1-148">The managed heap</span></span>

<span data-ttu-id="b9aa1-149">Une fois que le garbage collector est initialisé par le CLR, il alloue un segment de mémoire pour stocker et gérer des objets.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-149">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="b9aa1-150">Cette mémoire est appelée tas managé, par opposition à un tas natif dans le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-150">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="b9aa1-151">Il existe un tas managé pour chaque processus managé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-151">There is a managed heap for each managed process.</span></span> <span data-ttu-id="b9aa1-152">Tous les threads du processus allouent de la mémoire pour les objets sur le même tas.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-152">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="b9aa1-153">Pour réserver de la mémoire, le récupérateur de mémoire appelle la fonction Win32 [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) et réserve un segment de mémoire à la fois pour les applications managées.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-153">To reserve memory, the garbage collector calls the Win32 [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function, and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="b9aa1-154">Le récupérateur de mémoire réserve également des segments si nécessaire, et libère des segments dans le système d’exploitation (après avoir effacé tous leurs objets) en appelant la fonction Win32 [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) .</span><span class="sxs-lookup"><span data-stu-id="b9aa1-154">The garbage collector also reserves segments as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Win32 [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b9aa1-155">La taille des segments alloués par le garbage collector est spécifique à l'implémentation et susceptible de changer à tout moment, y compris les mises à jour périodiques.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-155">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="b9aa1-156">Votre application ne doit jamais faire d'hypothèses concernant une taille de segment particulière, ni dépendre de celle-ci. Elle ne doit pas non plus tenter de configurer la quantité de mémoire disponible pour les allocations de segments.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-156">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="b9aa1-157">Moins il y a d'objets alloués sur le tas, moins le garbage collector a à faire.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-157">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="b9aa1-158">Lorsque vous allouez des objets, n'utilisez pas de valeurs arrondies qui dépassent vos besoins, par exemple en allouant un tableau de 32 octets lorsque vous avez besoin de seulement 15 octets.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-158">When you allocate objects, do not use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="b9aa1-159">Lorsqu'un garbage collection est déclenché, le garbage collector libère la mémoire occupée par les objets morts.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-159">When a garbage collection is triggered, the garbage collector reclaims the memory that is occupied by dead objects.</span></span> <span data-ttu-id="b9aa1-160">Le processus de libération compacte les objets vivants afin qu'ils soient déplacés ensemble, et l'espace inutilisé est supprimé, ce qui entraîne la diminution du tas.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-160">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="b9aa1-161">Les objets alloués ensemble restent ainsi ensemble sur le tas managé, pour conserver leur emplacement.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-161">This ensures that objects that are allocated together stay together on the managed heap, to preserve their locality.</span></span>

<span data-ttu-id="b9aa1-162">Le déroulement (fréquence et durée) des garbage collection est le résultat du volume des allocations et de la quantité de mémoire restante sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-162">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="b9aa1-163">Le tas peut être considéré comme l’accumulation de deux tas : le [tas de grands objets](large-object-heap.md) et le tas de petits objets.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-163">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span>

<span data-ttu-id="b9aa1-164">Le [tas de grands objets](large-object-heap.md) contient des objets d’au moins 85 000 octets.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-164">The [large object heap](large-object-heap.md) contains very large objects that are 85,000 bytes and larger.</span></span> <span data-ttu-id="b9aa1-165">Ces objets du tas d'objets volumineux sont généralement des tableaux.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-165">The objects on the large object heap are usually arrays.</span></span> <span data-ttu-id="b9aa1-166">Il est rare qu'un objet d'instance soit extrêmement grand.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-166">It is rare for an instance object to be extremely large.</span></span>

[<span data-ttu-id="b9aa1-167">Retour au début</span><span class="sxs-lookup"><span data-stu-id="b9aa1-167">Back to top</span></span>](#top)

<a name="generations"></a>

## <a name="generations"></a><span data-ttu-id="b9aa1-168">Générations</span><span class="sxs-lookup"><span data-stu-id="b9aa1-168">Generations</span></span>

<span data-ttu-id="b9aa1-169">Le tas est organisé en générations. Il peut ainsi gérer des objets durables et éphémères.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-169">The heap is organized into generations so it can handle long-lived and short-lived objects.</span></span> <span data-ttu-id="b9aa1-170">Le garbage collection consiste principalement en la récupération d'objets éphémères qui occupent généralement une petite partie du tas.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-170">Garbage collection primarily occurs with the reclamation of short-lived objects that typically occupy only a small part of the heap.</span></span> <span data-ttu-id="b9aa1-171">Il existe trois générations d'objets sur le tas :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-171">There are three generations of objects on the heap:</span></span>

- <span data-ttu-id="b9aa1-172">**Génération 0**.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-172">**Generation 0**.</span></span> <span data-ttu-id="b9aa1-173">Il s'agit de la génération la plus jeune, qui contient des objets éphémères.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-173">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="b9aa1-174">Un exemple d'objet éphémère est une variable temporaire.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-174">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="b9aa1-175">Le garbage collection a le plus souvent lieu dans cette génération.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-175">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="b9aa1-176">Les objets alloués récemment forment une nouvelle génération d'objets et sont implicitement des collections de génération 0, à moins qu'ils ne s'agissent de grands objets, auquel cas ils entrent dans le tas d'objets volumineux dans une collection de génération 2.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-176">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections, unless they are large objects, in which case they go on the large object heap in a generation 2 collection.</span></span>

  <span data-ttu-id="b9aa1-177">La plupart des objets sont libérés pour l'opération garbage collection dans la génération 0 et ne survivent pas à la génération suivante.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-177">Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation.</span></span>

- <span data-ttu-id="b9aa1-178">**Génération 1**.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-178">**Generation 1**.</span></span> <span data-ttu-id="b9aa1-179">Cette génération contient des objets éphémères et sert de tampon entre objets éphémères et objets durables.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-179">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

- <span data-ttu-id="b9aa1-180">**Génération 2**.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-180">**Generation 2**.</span></span> <span data-ttu-id="b9aa1-181">Cette génération contient des objets durables.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-181">This generation contains long-lived objects.</span></span> <span data-ttu-id="b9aa1-182">Un exemple d'objet durable est un objet dans une application serveur qui contient des données statiques qui sont vivantes pour la durée du processus.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-182">An example of a long-lived object is an object in a server application that contains static data that is live for the duration of the process.</span></span>

<span data-ttu-id="b9aa1-183">Les opérations garbage collection se produisent sur des générations spécifiques, selon les conditions spécifiées.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-183">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="b9aa1-184">La collecte d'une génération signifie la collecte des objets de cette génération et de toutes ses générations plus jeunes.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-184">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="b9aa1-185">Les opérations garbage collection de génération 2 sont également appelées garbage collection complet, car elles libèrent tous les objets de toutes les générations (autrement dit, tous les objets du tas managé).</span><span class="sxs-lookup"><span data-stu-id="b9aa1-185">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims all objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="b9aa1-186">Survie et promotions</span><span class="sxs-lookup"><span data-stu-id="b9aa1-186">Survival and promotions</span></span>

<span data-ttu-id="b9aa1-187">Les objets qui ne sont pas libérés dans un garbage collection sont appelé survivants et sont promus à la génération suivante.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-187">Objects that are not reclaimed in a garbage collection are known as survivors, and are promoted to the next generation.</span></span> <span data-ttu-id="b9aa1-188">Les objets qui survivent à un garbage collection de génération 0 sont promus à la génération 1, les objets qui survivent à un garbage collection de génération 1 sont promus à la génération 2 et les objets qui survivent à un garbage collection de génération 2 restent dans la génération 2.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-188">Objects that survive a generation 0 garbage collection are promoted to generation 1; objects that survive a generation 1 garbage collection are promoted to generation 2; and objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="b9aa1-189">Lorsque le garbage collector détecte que le taux de survie est élevé dans une génération, il augmente le seuil des allocations de cette génération. La collecte suivante récupère donc une taille substantielle de mémoire libérée.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-189">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation, so the next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="b9aa1-190">Le CLR équilibre continuellement deux priorités : ne pas permettre au jeu de travail d'une application de devenir trop grand et ne pas permettre pas au garbage collection d'être trop long.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-190">The CLR continually balances two priorities: not letting an application's working set get too big and not letting the garbage collection take too much time.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="b9aa1-191">Segments et générations éphémères</span><span class="sxs-lookup"><span data-stu-id="b9aa1-191">Ephemeral generations and segments</span></span>

<span data-ttu-id="b9aa1-192">Étant donné que les objets des générations 0 et 1 sont éphémères, ces générations sont appelées générations éphémères.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-192">Because objects in generations 0 and 1 are short-lived, these generations are known as the ephemeral generations.</span></span>

<span data-ttu-id="b9aa1-193">Les générations éphémères doivent être allouées dans le segment de mémoire appelé segment éphémère.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-193">Ephemeral generations must be allocated in the memory segment that is known as the ephemeral segment.</span></span> <span data-ttu-id="b9aa1-194">Chaque nouveau segment acquis par le garbage collector devient le nouveau segment éphémère et contient les objets qui ont survécu à un garbage collection de génération 0.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-194">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="b9aa1-195">L'ancien segment éphémère devient le nouveau segment de génération 2.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-195">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="b9aa1-196">La taille du segment éphémère peut varier selon que le système est 32 ou 64 bits. Elle peut également varier en fonction du type de garbage collector exécuté.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-196">The size of the ephemeral segment varies depending on whether a system is 32- or 64-bit, and on the type of garbage collector it is running.</span></span> <span data-ttu-id="b9aa1-197">Le tableau ci-dessous répertorie les valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-197">Default values are shown in the following table.</span></span>

||<span data-ttu-id="b9aa1-198">32 bits</span><span class="sxs-lookup"><span data-stu-id="b9aa1-198">32-bit</span></span>|<span data-ttu-id="b9aa1-199">64 bits</span><span class="sxs-lookup"><span data-stu-id="b9aa1-199">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="b9aa1-200">Garbage collector pour station de travail</span><span class="sxs-lookup"><span data-stu-id="b9aa1-200">Workstation GC</span></span>|<span data-ttu-id="b9aa1-201">16 Mo</span><span class="sxs-lookup"><span data-stu-id="b9aa1-201">16 MB</span></span>|<span data-ttu-id="b9aa1-202">256 Mo</span><span class="sxs-lookup"><span data-stu-id="b9aa1-202">256 MB</span></span>|
|<span data-ttu-id="b9aa1-203">Garbage collector pour serveur</span><span class="sxs-lookup"><span data-stu-id="b9aa1-203">Server GC</span></span>|<span data-ttu-id="b9aa1-204">64 Mo</span><span class="sxs-lookup"><span data-stu-id="b9aa1-204">64 MB</span></span>|<span data-ttu-id="b9aa1-205">4 Go</span><span class="sxs-lookup"><span data-stu-id="b9aa1-205">4 GB</span></span>|
|<span data-ttu-id="b9aa1-206">Garbage collector pour serveur > 4 processeurs logiques</span><span class="sxs-lookup"><span data-stu-id="b9aa1-206">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="b9aa1-207">32 Mo</span><span class="sxs-lookup"><span data-stu-id="b9aa1-207">32 MB</span></span>|<span data-ttu-id="b9aa1-208">2 Go</span><span class="sxs-lookup"><span data-stu-id="b9aa1-208">2 GB</span></span>|
|<span data-ttu-id="b9aa1-209">Garbage collector pour serveur > 8 processeurs logiques</span><span class="sxs-lookup"><span data-stu-id="b9aa1-209">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="b9aa1-210">16 Mo</span><span class="sxs-lookup"><span data-stu-id="b9aa1-210">16 MB</span></span>|<span data-ttu-id="b9aa1-211">1 Go</span><span class="sxs-lookup"><span data-stu-id="b9aa1-211">1 GB</span></span>|

<span data-ttu-id="b9aa1-212">Le segment éphémère peut inclure des objets de la génération 2.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-212">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="b9aa1-213">Les objets de génération 2 peuvent utiliser plusieurs segments (autant que votre processus en requiert et que la mémoire en autorise).</span><span class="sxs-lookup"><span data-stu-id="b9aa1-213">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="b9aa1-214">La quantité de mémoire libérée à partir d'un garbage collection éphémère est limitée à la taille du segment éphémère.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-214">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="b9aa1-215">La quantité de mémoire libérée est proportionnelle à l'espace occupé par les objets morts.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-215">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

[<span data-ttu-id="b9aa1-216">Retour au début</span><span class="sxs-lookup"><span data-stu-id="b9aa1-216">Back to top</span></span>](#top)

<a name="what_happens_during_a_garbage_collection"></a>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="b9aa1-217">Déroulement d'une opération garbage collection</span><span class="sxs-lookup"><span data-stu-id="b9aa1-217">What happens during a garbage collection</span></span>

<span data-ttu-id="b9aa1-218">Une opération garbage collection présente les phases suivantes :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-218">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="b9aa1-219">Une phase de marquage qui recherche et crée une liste de tous les objets actifs.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-219">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="b9aa1-220">Une phase de déplacement qui met à jour les références aux objets qui seront compactés.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-220">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="b9aa1-221">Une phase de compactage qui libère l'espace occupé par les objets morts et compacte les objets survivants.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-221">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="b9aa1-222">La phase de compactage déplace les objets qui ont survécu à un garbage collection vers l'extrémité la plus ancienne du segment.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-222">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="b9aa1-223">Étant donné que les collections de génération 2 peuvent occuper plusieurs segments, les objets promus dans la génération 2 peuvent être déplacés dans un segment plus ancien.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-223">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="b9aa1-224">Les survivants des générations 1 et 2 peuvent être déplacés vers un autre segment, car ils sont promus à la génération 2.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-224">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="b9aa1-225">Normalement, le tas d'objets volumineux n'est pas compacté, car la copie d'objets volumineux implique une diminution des performances.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-225">Ordinarily, the large object heap is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="b9aa1-226">Toutefois, à partir de .NET Framework 4.5.1, vous pouvez utiliser la propriété <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> pour compacter le tas d’objets volumineux à la demande.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-226">However, starting with the .NET Framework 4.5.1, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span>

<span data-ttu-id="b9aa1-227">Le garbage collector utilise les informations suivantes pour déterminer si les objets sont vivants :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-227">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="b9aa1-228">**Racines de pile**.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-228">**Stack roots**.</span></span> <span data-ttu-id="b9aa1-229">Variables de pile fournies par le compilateur juste-à-temps (JIT) et l'explorateur de pile.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-229">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="b9aa1-230">Notez que les optimisations JIT peuvent allonger ou raccourcir les régions de code dans lesquelles les variables de pile sont signalées au garbage collector.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-230">Note that JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="b9aa1-231">**Handles de garbage collection**.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-231">**Garbage collection handles**.</span></span> <span data-ttu-id="b9aa1-232">Handles qui pointent vers les objets managés qui peuvent être alloués par le code utilisateur ou par le Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-232">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="b9aa1-233">**Données statiques**.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-233">**Static data**.</span></span> <span data-ttu-id="b9aa1-234">Objets statiques des domaines d'application qui pourraient référencer d'autres objets.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-234">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="b9aa1-235">Chaque domaine d'application effectue le suivi de ses objets statiques.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-235">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="b9aa1-236">Avant qu'une opération garbage collection ne démarre, tous les threads managés sont suspendus à l'exception du thread qui a déclenché l'opération.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-236">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="b9aa1-237">L'illustration suivante montre un thread qui déclenche un garbage collection et entraîne l'interruption des autres threads.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-237">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

<span data-ttu-id="b9aa1-238">![Quand un thread déclenche un Garbage Collection](../../../docs/standard/garbage-collection/media/gc-triggered.png "GC_Triggered") Thread qui déclenche un garbage collection</span><span class="sxs-lookup"><span data-stu-id="b9aa1-238">![When a thread triggers a Garbage Collection](../../../docs/standard/garbage-collection/media/gc-triggered.png "GC_Triggered") Thread that triggers a garbage collection</span></span>

[<span data-ttu-id="b9aa1-239">Retour au début</span><span class="sxs-lookup"><span data-stu-id="b9aa1-239">Back to top</span></span>](#top)

<a name="manipulating_unmanaged_resources"></a>

## <a name="manipulating-unmanaged-resources"></a><span data-ttu-id="b9aa1-240">Manipulation des ressources non managées</span><span class="sxs-lookup"><span data-stu-id="b9aa1-240">Manipulating unmanaged resources</span></span>

<span data-ttu-id="b9aa1-241">Si vos objets managés référencent des objets non managés à l'aide de leurs handles de fichiers natifs, vous devez libérer explicitement les objets non managés, car le garbage collector effectue le suivi de la mémoire uniquement sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-241">If your managed objects reference unmanaged objects by using their native file handles, you have to explicitly free the unmanaged objects, because the garbage collector tracks memory only on the managed heap.</span></span>

<span data-ttu-id="b9aa1-242">Les utilisateurs de votre objet managé ne peuvent pas supprimer les ressources natives utilisées par l'objet.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-242">Users of your managed object may not dispose the native resources used by the object.</span></span> <span data-ttu-id="b9aa1-243">Pour effectuer le nettoyage, vous pouvez rendre votre objet managé finalisable.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-243">To perform the cleanup, you can make your managed object finalizable.</span></span> <span data-ttu-id="b9aa1-244">La finalisation est constituée des actions de nettoyage que vous exécutez lorsque l'objet n'est plus utilisé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-244">Finalization consists of cleanup actions that you execute when the object is no longer in use.</span></span> <span data-ttu-id="b9aa1-245">Lorsque votre objet managé meurt, il effectue les actions de nettoyage spécifiées dans sa méthode de finaliseur.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-245">When your managed object dies, it performs cleanup actions that are specified in its finalizer method.</span></span>

<span data-ttu-id="b9aa1-246">Lorsqu'un objet finalisable est détecté comme étant mort, son finaliseur est placé dans une file d'attente afin que ses actions de nettoyage soient exécutées, mais l'objet lui-même est promu à la génération suivante.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-246">When a finalizable object is discovered to be dead, its finalizer is put in a queue so that its cleanup actions are executed, but the object itself is promoted to the next generation.</span></span> <span data-ttu-id="b9aa1-247">Par conséquent, vous devez attendre jusqu'au garbage collection suivant sur cette génération (qui n'est pas nécessairement le garbage collection suivant) pour déterminer si l'objet a été récupéré.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-247">Therefore, you have to wait until the next garbage collection that occurs on that generation (which is not necessarily the next garbage collection) to determine whether the object has been reclaimed.</span></span>

[<span data-ttu-id="b9aa1-248">Retour au début</span><span class="sxs-lookup"><span data-stu-id="b9aa1-248">Back to top</span></span>](#top)

<a name="workstation_and_server_garbage_collection"></a>

## <a name="workstation-and-server-garbage-collection"></a><span data-ttu-id="b9aa1-249">Garbage collection de station de travail et de serveur</span><span class="sxs-lookup"><span data-stu-id="b9aa1-249">Workstation and server garbage collection</span></span>

<span data-ttu-id="b9aa1-250">Le garbage collector s'ajuste automatiquement et peut travailler dans une large gamme de scénarios.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-250">The garbage collector is self-tuning and can work in a wide variety of scenarios.</span></span> <span data-ttu-id="b9aa1-251">Vous pouvez utiliser un paramètre du fichier de configuration pour définir le type de garbage collection en fonction des caractéristiques de la charge de travail.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-251">You can use a configuration file setting to set the type of garbage collection based on the characteristics of the workload.</span></span> <span data-ttu-id="b9aa1-252">Le CLR fournit les types de garbage collection suivants :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-252">The CLR provides the following types of garbage collection:</span></span>

- <span data-ttu-id="b9aa1-253">Garbage collection de station de travail, pour toutes les stations de travail clientes et les PC autonomes.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-253">Workstation garbage collection, which is for all client workstations and stand-alone PCs.</span></span> <span data-ttu-id="b9aa1-254">Il s'agit du paramètre par défaut de l'[\<élément <gcServer>](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) dans le schéma de configuration d'exécution.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-254">This is the default setting for the [\<gcServer> element](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) in the runtime configuration schema.</span></span>

  <span data-ttu-id="b9aa1-255">Le garbage collection de station de travail peut être simultané ou non simultané.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-255">Workstation garbage collection can be concurrent or non-concurrent.</span></span> <span data-ttu-id="b9aa1-256">Le garbage collection simultané permet aux threads managés de continuer à fonctionner pendant un garbage collection.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-256">Concurrent garbage collection enables managed threads to continue operations during a garbage collection.</span></span>

  <span data-ttu-id="b9aa1-257">À compter de .NET Framework 4, le garbage collection d’arrière-plan remplace le garbage collection simultané.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-257">Starting with the .NET Framework 4, background garbage collection replaces concurrent garbage collection.</span></span>

- <span data-ttu-id="b9aa1-258">Garbage collection de serveur, prévu pour les applications serveur qui ont besoin d'un débit et d'une extensibilité.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-258">Server garbage collection, which is intended for server applications that need high throughput and scalability.</span></span> <span data-ttu-id="b9aa1-259">Le garbage collection de serveur peut être non simultané ou en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-259">Server garbage collection can be non-concurrent or background.</span></span>

<span data-ttu-id="b9aa1-260">Les illustrations suivantes montrent les threads dédiés qui exécutent un garbage collection sur un serveur.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-260">The following illustration shows the dedicated threads that perform the garbage collection on a server.</span></span>

<span data-ttu-id="b9aa1-261">![Threads de garbage collection du serveur](../../../docs/standard/garbage-collection/media/gc-server.png "GC_Server") Garbage collection du serveur</span><span class="sxs-lookup"><span data-stu-id="b9aa1-261">![Server Garbage Collection Threads](../../../docs/standard/garbage-collection/media/gc-server.png "GC_Server") Server garbage collection</span></span>

### <a name="configuring-garbage-collection"></a><span data-ttu-id="b9aa1-262">Configuration du garbage collection</span><span class="sxs-lookup"><span data-stu-id="b9aa1-262">Configuring garbage collection</span></span>

<span data-ttu-id="b9aa1-263">Vous pouvez utiliser l’[\<élément <gcServer>](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) du schéma de configuration d’exécution pour spécifier le type de garbage collection que vous souhaitez que le CLR exécute.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-263">You can use the [\<gcServer> element](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) of the runtime configuration schema to specify the type of garbage collection you want the CLR to perform.</span></span> <span data-ttu-id="b9aa1-264">Lorsque l'attribut `enabled` de cet élément a la valeur `false` (valeur par défaut), le CLR exécute le garbage collection de station de travail.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-264">When this element's `enabled` attribute is set to `false` (the default), the CLR performs workstation garbage collection.</span></span> <span data-ttu-id="b9aa1-265">Lorsque vous affectez à l'attribut `enabled` la valeur `true`, le CLR exécute le garbage collection de serveur.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-265">When you set the `enabled` attribute to `true`, the CLR performs server garbage collection.</span></span>

<span data-ttu-id="b9aa1-266">Le garbage collection simultané est spécifié avec l[\<’élément <gcConcurrent>](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) du schéma de configuration d’exécution.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-266">Concurrent garbage collection is specified with the [\<gcConcurrent> element](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) of the runtime configuration schema.</span></span> <span data-ttu-id="b9aa1-267">Le paramètre par défaut est `enabled`.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-267">The default setting is `enabled`.</span></span> <span data-ttu-id="b9aa1-268">Ce paramètre contrôle à la fois le garbage collection en cours et celui d'arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-268">This setting controls both concurrent and background garbage collection.</span></span>

<span data-ttu-id="b9aa1-269">Vous pouvez également spécifier le garbage collection de serveur avec des interfaces d'hébergement non managées.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-269">You can also specify server garbage collection with unmanaged hosting interfaces.</span></span> <span data-ttu-id="b9aa1-270">Notez que ASP.NET et SQL Server activent automatiquement le garbage collection de serveur si votre application est hébergée dans un de ces environnements.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-270">Note that ASP.NET and SQL Server enable server garbage collection automatically if your application is hosted inside one of these environments.</span></span>

### <a name="comparing-workstation-and-server-garbage-collection"></a><span data-ttu-id="b9aa1-271">Comparaison des opérations garbage collection de station de travail et de serveur</span><span class="sxs-lookup"><span data-stu-id="b9aa1-271">Comparing workstation and server garbage collection</span></span>

<span data-ttu-id="b9aa1-272">Voici les considérations liées aux threads et aux performances pour le garbage collection de station de travail :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-272">The following are threading and performance considerations for workstation garbage collection:</span></span>

- <span data-ttu-id="b9aa1-273">La collecte se produit sur le thread utilisateur qui a déclenché le garbage collection et reste à la même priorité.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-273">The collection occurs on the user thread that triggered the garbage collection and remains at the same priority.</span></span> <span data-ttu-id="b9aa1-274">Étant donné que les threads utilisateur sont généralement exécutés à la priorité normale, le garbage collector (qui s'exécute sur un thread de priorité normale) doit rivaliser avec d'autres threads pour le temps processeur.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-274">Because user threads typically run at normal priority, the garbage collector (which runs on a normal priority thread) must compete with other threads for CPU time.</span></span>

  <span data-ttu-id="b9aa1-275">Les threads qui exécutent du code natif ne sont pas interrompus.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-275">Threads that are running native code are not suspended.</span></span>

- <span data-ttu-id="b9aa1-276">Le garbage collection de station de travail est toujours utilisé sur un ordinateur doté d’un seul processeur, indépendamment du paramètre [\<<gcServer>](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md).</span><span class="sxs-lookup"><span data-stu-id="b9aa1-276">Workstation garbage collection is always used on a computer that has only one processor, regardless of the [\<gcServer>](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) setting.</span></span> <span data-ttu-id="b9aa1-277">Si vous spécifiez le garbage collection de serveur, le CLR utilise le garbage collection de station de travail avec la concurrence désactivée.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-277">If you specify server garbage collection, the CLR uses workstation garbage collection with concurrency disabled.</span></span>

<span data-ttu-id="b9aa1-278">Voici les considérations liées aux threads et aux performances pour le garbage collection de serveur :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-278">The following are threading and performance considerations for server garbage collection:</span></span>

- <span data-ttu-id="b9aa1-279">La collecte se produit sur plusieurs threads dédiés qui s'exécutent au niveau de priorité `THREAD_PRIORITY_HIGHEST` .</span><span class="sxs-lookup"><span data-stu-id="b9aa1-279">The collection occurs on multiple dedicated threads that are running at `THREAD_PRIORITY_HIGHEST` priority level.</span></span>

- <span data-ttu-id="b9aa1-280">Un tas et un thread dédié pour effectuer le garbage collection sont fournis pour chaque UC, et les tas sont collectés au même moment.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-280">A heap and a dedicated thread to perform garbage collection are provided for each CPU, and the heaps are collected at the same time.</span></span> <span data-ttu-id="b9aa1-281">Chaque tas contient un tas de petits objets et un tas d'objets volumineux, et tous les tas peuvent faire l'objet d'accès par du code utilisateur.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-281">Each heap contains a small object heap and a large object heap, and all heaps can be accessed by user code.</span></span> <span data-ttu-id="b9aa1-282">Les objets des différents tas peuvent faire référence les uns aux autres.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-282">Objects on different heaps can refer to each other.</span></span>

- <span data-ttu-id="b9aa1-283">Étant donné que plusieurs threads de garbage collection fonctionnent ensemble, le garbage collection de serveur est plus rapide que le garbage collection de station de travail sur un tas de même taille.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-283">Because multiple garbage collection threads work together, server garbage collection is faster than workstation garbage collection on the same size heap.</span></span>

- <span data-ttu-id="b9aa1-284">Le garbage collection de serveur présente souvent des segments de plus grande taille.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-284">Server garbage collection often has larger size segments.</span></span> <span data-ttu-id="b9aa1-285">Notez, cependant, qu'il ne s'agit que d'une généralisation : la taille de segment est spécifique à l'implémentation et est susceptible de changer.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-285">Note, however, that this is only a generalization: segment size is implementation-specific and is subject to change.</span></span> <span data-ttu-id="b9aa1-286">Vous ne devez pas faire d'hypothèses sur la taille des segments alloués par le garbage collector lors du paramétrage de votre application.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-286">You should make no assumptions about the size of segments allocated by the garbage collector when tuning your app.</span></span>

- <span data-ttu-id="b9aa1-287">Le garbage collection de serveur peut consommer beaucoup de ressources.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-287">Server garbage collection can be resource-intensive.</span></span> <span data-ttu-id="b9aa1-288">Par exemple, si vous disposez de 12 processus qui s'exécutent sur un ordinateur possédant 4 processeurs, il y aura 48 threads de garbage collection dédiés s'ils utilisent tous le garbage collection de serveur.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-288">For example, if you have 12 processes running on a computer that has 4 processors, there will be 48 dedicated garbage collection threads if they are all using server garbage collection.</span></span> <span data-ttu-id="b9aa1-289">Dans une situation de charge de mémoire élevée, si tous les processus commencent le garbage collection, le garbage collector aura 48 threads à planifier.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-289">In a high memory load situation, if all the processes start doing garbage collection, the garbage collector will have 48 threads to schedule.</span></span>

<span data-ttu-id="b9aa1-290">Si vous exécutez des centaines d'instances d'une application, envisagez d'utiliser le garbage collection de station de travail avec le garbage collection simultané désactivé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-290">If you are running hundreds of instances of an application, consider using workstation garbage collection with concurrent garbage collection disabled.</span></span> <span data-ttu-id="b9aa1-291">Cela provoquera moins de changements de contexte, ce qui peut améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-291">This will result in less context switching, which can improve performance.</span></span>

[<span data-ttu-id="b9aa1-292">Retour au début</span><span class="sxs-lookup"><span data-stu-id="b9aa1-292">Back to top</span></span>](#top)

<a name="concurrent_garbage_collection"></a>

## <a name="concurrent-garbage-collection"></a><span data-ttu-id="b9aa1-293">Garbage collection simultané</span><span class="sxs-lookup"><span data-stu-id="b9aa1-293">Concurrent garbage collection</span></span>

<span data-ttu-id="b9aa1-294">Avec le garbage collection de station de travail ou de serveur, vous pouvez activer un garbage collection simultané, ce qui permet aux threads de fonctionner simultanément avec un thread dédié qui exécute le garbage collection pendant une grande partie de la durée de ce dernier.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-294">In workstation or server garbage collection, you can enable concurrent garbage collection, which enables threads to run concurrently with a dedicated thread that performs the garbage collection for most of the duration of the collection.</span></span> <span data-ttu-id="b9aa1-295">Cette option affecte uniquement les opérations garbage collection de génération 2. Les générations 0 et 1 sont toujours non simultanées car elles se terminent très rapidement.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-295">This option affects only garbage collections in generation 2; generations 0 and 1 are always non-concurrent because they finish very fast.</span></span>

<span data-ttu-id="b9aa1-296">Le garbage collection simultané permet aux applications interactives d'être plus réactives en réduisant les pauses d'une collection.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-296">Concurrent garbage collection enables interactive applications to be more responsive by minimizing pauses for a collection.</span></span> <span data-ttu-id="b9aa1-297">Les threads managés peuvent continuer à s'exécuter une grande partie de la durée du garbage collection simultané.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-297">Managed threads can continue to run most of the time while the concurrent garbage collection thread is running.</span></span> <span data-ttu-id="b9aa1-298">Cela génère des pauses plus courtes pendant l'opération garbage collection.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-298">This results in shorter pauses while a garbage collection is occurring.</span></span>

<span data-ttu-id="b9aa1-299">Pour améliorer les performances lorsque plusieurs processus s'exécutent, désactivez le garbage collection simultané.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-299">To improve performance when several processes are running, disable concurrent garbage collection.</span></span> <span data-ttu-id="b9aa1-300">Pour cela, vous pouvez ajouter un [\<élément <gcConcurrent>](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) dans le fichier de configuration de l’application et définir son attribut `enabled` à la valeur `"false"`.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-300">You can do this by adding a [\<gcConcurrent> element](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) to the app's configuration file and setting the value of its `enabled` attribute to `"false"`.</span></span>

<span data-ttu-id="b9aa1-301">Le garbage collection simultané est exécuté sur un thread dédié.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-301">Concurrent garbage collection is performed on a dedicated thread.</span></span> <span data-ttu-id="b9aa1-302">Par défaut, le CLR effectue le garbage collection de station de travail avec le garbage collection simultané activé.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-302">By default, the CLR runs workstation garbage collection with concurrent garbage collection enabled.</span></span> <span data-ttu-id="b9aa1-303">Ceci est vrai pour les ordinateurs multiprocesseur et à processeur unique.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-303">This is true for single-processor and multi-processor computers.</span></span>

<span data-ttu-id="b9aa1-304">Votre capacité à allouer de petits objets sur le tas pendant un garbage collection simultané est limitée par les objets restants dans le segment éphémère lorsqu'une opération garbage collection simultanée démarre.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-304">Your ability to allocate small objects on the heap during a concurrent garbage collection is limited by the objects left on the ephemeral segment when a concurrent garbage collection starts.</span></span> <span data-ttu-id="b9aa1-305">Dès que vous atteignez la fin du segment, vous devez attendre que le garbage collection simultané se termine pendant que les threads managés qui doivent effectuer les allocations des petits objet sont interrompus.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-305">As soon as you reach the end of the segment, you will have to wait for the concurrent garbage collection to finish while managed threads that have to make small object allocations are suspended.</span></span>

<span data-ttu-id="b9aa1-306">Le garbage collection simultané possède un jeu de travail légèrement plus grand (comparé au garbage collection non simultané) car vous pouvez allouer des objets pendant la collecte simultanée.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-306">Concurrent garbage collection has a slightly bigger working set (compared with non-concurrent garbage collection), because you can allocate objects during concurrent collection.</span></span> <span data-ttu-id="b9aa1-307">Toutefois, cela peut affecter les performances, car les objets que vous allouez deviennent une partie de votre jeu de travail.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-307">However, this can affect performance, because the objects that you allocate become part of your working set.</span></span> <span data-ttu-id="b9aa1-308">Essentiellement, le garbage collection simultané échange de l'UC et de la mémoire contre des pauses plus courtes.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-308">Essentially, concurrent garbage collection trades some CPU and memory for shorter pauses.</span></span>

<span data-ttu-id="b9aa1-309">L'illustration suivante montre le garbage collection simultané exécuté sur un thread dédié différent.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-309">The following illustration shows concurrent garbage collection performed on a separate dedicated thread.</span></span>

<span data-ttu-id="b9aa1-310">![Threads de garbage collection simultané](../../../docs/standard/garbage-collection/media/gc-concurrent.png "GC_Concurrent") Garbage collection simultané</span><span class="sxs-lookup"><span data-stu-id="b9aa1-310">![Concurrent Garbage Collection Threads](../../../docs/standard/garbage-collection/media/gc-concurrent.png "GC_Concurrent") Concurrent garbage collection</span></span>

[<span data-ttu-id="b9aa1-311">Retour au début</span><span class="sxs-lookup"><span data-stu-id="b9aa1-311">Back to top</span></span>](#top)

<a name="background_garbage_collection"></a>

## <a name="background-workstation-garbage-collection"></a><span data-ttu-id="b9aa1-312">Nettoyage de la mémoire de la station de travail en arrière-plan</span><span class="sxs-lookup"><span data-stu-id="b9aa1-312">Background workstation garbage collection</span></span>

<span data-ttu-id="b9aa1-313">Avec le garbage collection d'arrière-plan, les générations éphémères (0 et 1) sont collectées si nécessaire pendant la collecte de la génération 2.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-313">In background garbage collection, ephemeral generations (0 and 1) are collected as needed while the collection of generation 2 is in progress.</span></span> <span data-ttu-id="b9aa1-314">Il n'y a aucun paramètre pour le garbage collection d'arrière-plan. Il est automatiquement activé avec le garbage collection simultané.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-314">There is no setting for background garbage collection; it is automatically enabled with concurrent garbage collection.</span></span> <span data-ttu-id="b9aa1-315">Le garbage collection d'arrière-plan vient en remplacement du garbage collection simultané.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-315">Background garbage collection is a replacement for concurrent garbage collection.</span></span> <span data-ttu-id="b9aa1-316">Comme le garbage collection simultané, le garbage collection d'arrière-plan est exécuté sur un thread dédié et est uniquement applicable aux collections de génération 2.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-316">As with concurrent garbage collection, background garbage collection is performed on a dedicated thread and is applicable only to generation 2 collections.</span></span>

> [!NOTE]
> <span data-ttu-id="b9aa1-317">Le garbage collection d’arrière-plan est uniquement disponible dans .NET Framework 4 et versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-317">Background garbage collection is available only in the .NET Framework 4 and later versions.</span></span> <span data-ttu-id="b9aa1-318">Dans .NET Framework 4, il est pris en charge uniquement pour le garbage collection de station de travail.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-318">In the .NET Framework 4, it is supported only for workstation garbage collection.</span></span> <span data-ttu-id="b9aa1-319">Depuis .NET Framework 4.5, le garbage collection en arrière-plan est disponible pour les deux opérations garbage collection de station de travail et de serveur.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-319">Starting with the .NET Framework 4.5, background garbage collection is available for both workstation and server garbage collection.</span></span>

<span data-ttu-id="b9aa1-320">Une collecte sur des générations éphémères pendant le garbage collection d'arrière-plan est appelée garbage collection de premier plan.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-320">A collection on ephemeral generations during background garbage collection is known as foreground garbage collection.</span></span> <span data-ttu-id="b9aa1-321">Lorsque des opérations garbage collection de premier plan ont lieu, tous les threads managés sont suspendus.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-321">When foreground garbage collections occur, all managed threads are suspended.</span></span>

<span data-ttu-id="b9aa1-322">Lorsque le garbage collection d'arrière-plan est en cours et que vous avez alloué assez d'objets dans la génération 0, le CLR exécute un garbage collection de premier plan de génération 0 ou 1.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-322">When background garbage collection is in progress and you have allocated enough objects in generation 0, the CLR performs a generation 0 or generation 1 foreground garbage collection.</span></span> <span data-ttu-id="b9aa1-323">Le thread de garbage collection d'arrière-plan dédié vérifie des points sécurisés fréquents de façon à déterminer s'il existe une demande de garbage collection de premier plan.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-323">The dedicated background garbage collection thread checks at frequent safe points to determine whether there is a request for foreground garbage collection.</span></span> <span data-ttu-id="b9aa1-324">Le cas échéant, la collecte d'arrière-plan s'interrompt afin que le garbage collection de premier plan puisse se produire.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-324">If there is, the background collection suspends itself so that foreground garbage collection can occur.</span></span> <span data-ttu-id="b9aa1-325">Une fois le garbage collection de premier plan terminé, le thread de garbage collection d'arrière-plan dédié et les threads utilisateur reprennent.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-325">After the foreground garbage collection is completed, the dedicated background garbage collection thread and user threads resume.</span></span>

<span data-ttu-id="b9aa1-326">Le garbage collection d'arrière-plan supprime les restrictions d'allocation imposées par le garbage collection simultané, car des opérations garbage collection éphémères peuvent se produire pendant le garbage collection d'arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-326">Background garbage collection removes allocation restrictions imposed by concurrent garbage collection, because ephemeral garbage collections can occur during background garbage collection.</span></span> <span data-ttu-id="b9aa1-327">Cela signifie que le garbage collection d'arrière-plan peut supprimer des objets morts dans les générations éphémères et peut également développer le tas si nécessaire pendant un garbage collection de génération 1.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-327">This means that background garbage collection can remove dead objects in ephemeral generations and can also expand the heap if needed during a generation 1 garbage collection.</span></span>

<span data-ttu-id="b9aa1-328">L’illustration suivante montre le nettoyage de la mémoire en arrière-plan effectué sur un thread dédié distinct, sur une station de travail :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-328">The following illustration shows background garbage collection performed on a separate dedicated thread on a workstation:</span></span>

![Diagramme illustrant le nettoyage de la mémoire d’une station de travail en arrière-plan.](./media/fundamentals/background-workstation-garbage-collection.png)

[<span data-ttu-id="b9aa1-330">Retour au début</span><span class="sxs-lookup"><span data-stu-id="b9aa1-330">Back to top</span></span>](#top)

<a name="background_server_garbage_collection"></a>

## <a name="background-server-garbage-collection"></a><span data-ttu-id="b9aa1-331">Nettoyage de la mémoire du serveur en arrière-plan</span><span class="sxs-lookup"><span data-stu-id="b9aa1-331">Background server garbage collection</span></span>

<span data-ttu-id="b9aa1-332">Depuis .NET Framework 4.5, le garbage collection de serveur en arrière-plan est le mode par défaut pour le garbage collection de serveur.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-332">Starting with the .NET Framework 4.5, background server garbage collection is the default mode for server garbage collection.</span></span> <span data-ttu-id="b9aa1-333">Pour choisir ce mode, affectez à l'attribut `enabled` de l'[\<élément <gcServer>](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) la valeur `true` dans le schéma de configuration d'exécution.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-333">To choose this mode, set the `enabled` attribute of the [\<gcServer> element](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) to `true` in the runtime configuration schema.</span></span> <span data-ttu-id="b9aa1-334">Ce mode fonctionne de la même façon que le garbage collection de station de travail en arrière-plan, décrit dans la section précédente, mais il existe quelques différences.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-334">This mode functions similarly to background workstation garbage collection, described in the previous section, but there are a few differences.</span></span> <span data-ttu-id="b9aa1-335">Le garbage collection de station de travail en arrière-plan utilise un thread de garbage collection en arrière-plan dédié, tandis que le garbage collection de serveur en arrière-plan utilise plusieurs threads : généralement un thread dédié pour chaque processeur logique.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-335">Background workstation garbage collection uses one dedicated background garbage collection thread, whereas background server garbage collection uses multiple threads, typically a dedicated thread for each logical processor.</span></span> <span data-ttu-id="b9aa1-336">Contrairement au thread du garbage collection de station de travail en arrière-plan, ces threads n'expirent pas.</span><span class="sxs-lookup"><span data-stu-id="b9aa1-336">Unlike the workstation background garbage collection thread, these threads do not time out.</span></span>

<span data-ttu-id="b9aa1-337">L’illustration suivante montre le nettoyage de la mémoire en arrière-plan effectué sur un thread dédié distinct, sur un serveur :</span><span class="sxs-lookup"><span data-stu-id="b9aa1-337">The following illustration shows background garbage collection performed on a separate dedicated thread on a server:</span></span>

![Diagramme illustrant le nettoyage de la mémoire d’un serveur en arrière-plan.](./media/fundamentals/background-server-garbage-collection.png)

## <a name="see-also"></a><span data-ttu-id="b9aa1-339">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="b9aa1-339">See also</span></span>

- [<span data-ttu-id="b9aa1-340">Nettoyage de la mémoire</span><span class="sxs-lookup"><span data-stu-id="b9aa1-340">Garbage Collection</span></span>](../../../docs/standard/garbage-collection/index.md)
