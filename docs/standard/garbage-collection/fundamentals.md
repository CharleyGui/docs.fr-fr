---
title: Notions de base du garbage collection
description: Découvrez comment fonctionne le récupérateur de mémoire et comment le configurer pour optimiser ses performances.
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: ea8aef03d2f5837f35ecb31209e57853c0c8257b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/15/2020
ms.locfileid: "79400539"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="e0c20-103">Notions de base du garbage collection</span><span class="sxs-lookup"><span data-stu-id="e0c20-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="e0c20-104">Dans le langage courant runtime (CLR), le collecteur d’ordures (GC) sert de gestionnaire automatique de mémoire.</span><span class="sxs-lookup"><span data-stu-id="e0c20-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="e0c20-105">Elle vous permet de bénéficier des avantages suivants :</span><span class="sxs-lookup"><span data-stu-id="e0c20-105">It provides the following benefits:</span></span>

- <span data-ttu-id="e0c20-106">Vous permet de développer votre application sans avoir à libérer manuellement la mémoire.</span><span class="sxs-lookup"><span data-stu-id="e0c20-106">Enables you to develop your application without having to manually free memory.</span></span>

- <span data-ttu-id="e0c20-107">Il alloue efficacement les objets sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-107">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="e0c20-108">Il libère les objets qui ne sont plus utilisés, efface leur mémoire et garde la mémoire disponible pour les futures allocations.</span><span class="sxs-lookup"><span data-stu-id="e0c20-108">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="e0c20-109">Les objets managés obtiennent automatiquement un contenu propre au démarrage, ce qui fait que leurs constructeurs n'ont pas à initialiser chaque champ de données.</span><span class="sxs-lookup"><span data-stu-id="e0c20-109">Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</span></span>

- <span data-ttu-id="e0c20-110">Il sécurise la mémoire en s'assurant qu'un objet ne peut pas utiliser le contenu d'un autre objet.</span><span class="sxs-lookup"><span data-stu-id="e0c20-110">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

<span data-ttu-id="e0c20-111">Cet article décrit les concepts fondamentaux de la collecte des ordures.</span><span class="sxs-lookup"><span data-stu-id="e0c20-111">This article describes the core concepts of garbage collection.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="e0c20-112">Notions de base de la mémoire</span><span class="sxs-lookup"><span data-stu-id="e0c20-112">Fundamentals of memory</span></span>

<span data-ttu-id="e0c20-113">La liste suivante résume les concepts importants de la mémoire CLR.</span><span class="sxs-lookup"><span data-stu-id="e0c20-113">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="e0c20-114">Chaque processus possède son propre espace d'adressage virtuel séparé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-114">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="e0c20-115">Tous les processus sur le même ordinateur partagent la même mémoire physique et le fichier de page, s’il y en a un.</span><span class="sxs-lookup"><span data-stu-id="e0c20-115">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="e0c20-116">Par défaut, sur les ordinateurs 32 bits, chaque processus a un espace d'adressage virtuel en mode utilisateur de 2 Go.</span><span class="sxs-lookup"><span data-stu-id="e0c20-116">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="e0c20-117">En tant que développeur d'applications, vous travaillez uniquement avec l'espace d'adressage virtuel et ne gérez jamais directement la mémoire physique.</span><span class="sxs-lookup"><span data-stu-id="e0c20-117">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="e0c20-118">Le garbage collector alloue et libère la mémoire virtuelle pour vous sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-118">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="e0c20-119">Si vous écrivez du code natif, vous utilisez les fonctions Windows pour travailler avec l’espace d’adresse virtuel.</span><span class="sxs-lookup"><span data-stu-id="e0c20-119">If you are writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="e0c20-120">Ces fonctions allouent et libèrent la mémoire virtuelle pour vous sur les tas natifs.</span><span class="sxs-lookup"><span data-stu-id="e0c20-120">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="e0c20-121">La mémoire virtuelle peut être dans trois états :</span><span class="sxs-lookup"><span data-stu-id="e0c20-121">Virtual memory can be in three states:</span></span>

  - <span data-ttu-id="e0c20-122">Libre.</span><span class="sxs-lookup"><span data-stu-id="e0c20-122">Free.</span></span> <span data-ttu-id="e0c20-123">Il n'existe aucune référence au bloc de mémoire et celui-ci est disponible pour allocation.</span><span class="sxs-lookup"><span data-stu-id="e0c20-123">The block of memory has no references to it and is available for allocation.</span></span>

  - <span data-ttu-id="e0c20-124">Réservé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-124">Reserved.</span></span> <span data-ttu-id="e0c20-125">Le bloc de mémoire est disponible pour votre utilisation et ne peut pas être utilisé pour une autre demande d'allocation.</span><span class="sxs-lookup"><span data-stu-id="e0c20-125">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="e0c20-126">Toutefois, vous ne pouvez pas stocker de données dans ce bloc de mémoire tant qu'il n'est pas validé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-126">However, you cannot store data to this memory block until it is committed.</span></span>

  - <span data-ttu-id="e0c20-127">Validé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-127">Committed.</span></span> <span data-ttu-id="e0c20-128">Le bloc de mémoire est assigné au stockage physique.</span><span class="sxs-lookup"><span data-stu-id="e0c20-128">The block of memory is assigned to physical storage.</span></span>

- <span data-ttu-id="e0c20-129">L'espace d'adressage virtuel peut être fragmenté.</span><span class="sxs-lookup"><span data-stu-id="e0c20-129">Virtual address space can get fragmented.</span></span> <span data-ttu-id="e0c20-130">Cela signifie qu'il existe des blocs libres, également appelés trous, dans l'espace d'adressage.</span><span class="sxs-lookup"><span data-stu-id="e0c20-130">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="e0c20-131">Lorsqu'une allocation de mémoire virtuelle est demandée, le gestionnaire de mémoire virtuelle doit rechercher un bloc unique libre suffisamment grand pour satisfaire la demande d'allocation.</span><span class="sxs-lookup"><span data-stu-id="e0c20-131">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="e0c20-132">Même si vous disposez de 2 Go d'espace libre, l'allocation qui requiert 2 Go échoue, sauf si tout cet espace libre est contenu dans un bloc d'adresse unique.</span><span class="sxs-lookup"><span data-stu-id="e0c20-132">Even if you have 2 GB of free space, the allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="e0c20-133">Vous pouvez manquer de mémoire s’il n’y a pas assez d’espace d’adresse virtuelle pour réserver ou de l’espace physique à engager.</span><span class="sxs-lookup"><span data-stu-id="e0c20-133">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="e0c20-134">Le fichier de page est utilisé même si la pression de mémoire physique (c’est-à-dire la demande de mémoire physique) est faible.</span><span class="sxs-lookup"><span data-stu-id="e0c20-134">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="e0c20-135">La première fois que la pression de mémoire physique est élevée, le système d’exploitation doit faire de la place dans la mémoire physique pour stocker des données, et il soutient certaines des données qui sont en mémoire physique au fichier de page.</span><span class="sxs-lookup"><span data-stu-id="e0c20-135">The first time physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="e0c20-136">Ces données ne sont pas bipées jusqu’à ce qu’elles soient nécessaires, il est donc possible de rencontrer des paging dans des situations où la pression de mémoire physique est faible.</span><span class="sxs-lookup"><span data-stu-id="e0c20-136">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="e0c20-137">Conditions pour une opération garbage collection</span><span class="sxs-lookup"><span data-stu-id="e0c20-137">Conditions for a garbage collection</span></span>

<span data-ttu-id="e0c20-138">Le garbage collection se produit lorsque l'une des conditions suivantes est vraie :</span><span class="sxs-lookup"><span data-stu-id="e0c20-138">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="e0c20-139">Le système possède peu de mémoire physique.</span><span class="sxs-lookup"><span data-stu-id="e0c20-139">The system has low physical memory.</span></span> <span data-ttu-id="e0c20-140">Ceci est détecté par la notification à faible mémoire de l’OS ou la mémoire basse comme indiqué par l’hôte.</span><span class="sxs-lookup"><span data-stu-id="e0c20-140">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="e0c20-141">La mémoire utilisée par les objets alloués sur le tas managé dépasse un seuil acceptable.</span><span class="sxs-lookup"><span data-stu-id="e0c20-141">The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="e0c20-142">Ce seuil est continuellement ajusté à mesure que le processus s'exécute.</span><span class="sxs-lookup"><span data-stu-id="e0c20-142">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="e0c20-143">La méthode <xref:System.GC.Collect%2A?displayProperty=nameWithType> est appelée.</span><span class="sxs-lookup"><span data-stu-id="e0c20-143">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="e0c20-144">Dans presque tous les cas, vous n’avez pas à appeler cette méthode, car le garbage collector s’exécute continuellement.</span><span class="sxs-lookup"><span data-stu-id="e0c20-144">In almost all cases, you do not have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="e0c20-145">Cette méthode est principalement utilisée pour les situations uniques et les tests.</span><span class="sxs-lookup"><span data-stu-id="e0c20-145">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="e0c20-146">Tas managé</span><span class="sxs-lookup"><span data-stu-id="e0c20-146">The managed heap</span></span>

<span data-ttu-id="e0c20-147">Une fois que le garbage collector est initialisé par le CLR, il alloue un segment de mémoire pour stocker et gérer des objets.</span><span class="sxs-lookup"><span data-stu-id="e0c20-147">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="e0c20-148">Cette mémoire est appelée tas managé, par opposition à un tas natif dans le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="e0c20-148">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="e0c20-149">Il existe un tas managé pour chaque processus managé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-149">There is a managed heap for each managed process.</span></span> <span data-ttu-id="e0c20-150">Tous les threads du processus allouent de la mémoire pour les objets sur le même tas.</span><span class="sxs-lookup"><span data-stu-id="e0c20-150">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="e0c20-151">Pour réserver la mémoire, le collecteur d’ordures appelle la fonction [Windows VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) et réserve un segment de mémoire à la fois pour les applications gérées.</span><span class="sxs-lookup"><span data-stu-id="e0c20-151">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="e0c20-152">Le collecteur d’ordures réserve également des segments, au besoin, et libère des segments de nouveau au système d’exploitation (après les avoir effacés de tous les objets) en appelant la fonction [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) Windows.</span><span class="sxs-lookup"><span data-stu-id="e0c20-152">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e0c20-153">La taille des segments alloués par le garbage collector est spécifique à l'implémentation et susceptible de changer à tout moment, y compris les mises à jour périodiques.</span><span class="sxs-lookup"><span data-stu-id="e0c20-153">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="e0c20-154">Votre application ne doit jamais faire d'hypothèses concernant une taille de segment particulière, ni dépendre de celle-ci. Elle ne doit pas non plus tenter de configurer la quantité de mémoire disponible pour les allocations de segments.</span><span class="sxs-lookup"><span data-stu-id="e0c20-154">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="e0c20-155">Moins il y a d'objets alloués sur le tas, moins le garbage collector a à faire.</span><span class="sxs-lookup"><span data-stu-id="e0c20-155">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="e0c20-156">Lorsque vous allouez des objets, n'utilisez pas de valeurs arrondies qui dépassent vos besoins, par exemple en allouant un tableau de 32 octets lorsque vous avez besoin de seulement 15 octets.</span><span class="sxs-lookup"><span data-stu-id="e0c20-156">When you allocate objects, do not use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="e0c20-157">Lorsqu'un garbage collection est déclenché, le garbage collector libère la mémoire occupée par les objets morts.</span><span class="sxs-lookup"><span data-stu-id="e0c20-157">When a garbage collection is triggered, the garbage collector reclaims the memory that is occupied by dead objects.</span></span> <span data-ttu-id="e0c20-158">Le processus de libération compacte les objets vivants afin qu'ils soient déplacés ensemble, et l'espace inutilisé est supprimé, ce qui entraîne la diminution du tas.</span><span class="sxs-lookup"><span data-stu-id="e0c20-158">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="e0c20-159">Les objets alloués ensemble restent ainsi ensemble sur le tas managé, pour conserver leur emplacement.</span><span class="sxs-lookup"><span data-stu-id="e0c20-159">This ensures that objects that are allocated together stay together on the managed heap, to preserve their locality.</span></span>

<span data-ttu-id="e0c20-160">Le déroulement (fréquence et durée) des garbage collection est le résultat du volume des allocations et de la quantité de mémoire restante sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-160">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="e0c20-161">Le tas peut être considéré comme l’accumulation de deux tas : le [tas de grands objets](large-object-heap.md) et le tas de petits objets.</span><span class="sxs-lookup"><span data-stu-id="e0c20-161">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span>

<span data-ttu-id="e0c20-162">Le [tas de grands objets](large-object-heap.md) contient des objets d’au moins 85 000 octets.</span><span class="sxs-lookup"><span data-stu-id="e0c20-162">The [large object heap](large-object-heap.md) contains very large objects that are 85,000 bytes and larger.</span></span> <span data-ttu-id="e0c20-163">Ces objets du tas d'objets volumineux sont généralement des tableaux.</span><span class="sxs-lookup"><span data-stu-id="e0c20-163">The objects on the large object heap are usually arrays.</span></span> <span data-ttu-id="e0c20-164">Il est rare qu'un objet d'instance soit extrêmement grand.</span><span class="sxs-lookup"><span data-stu-id="e0c20-164">It is rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="e0c20-165">Vous pouvez [configurer la taille du seuil](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) pour que les objets aillent sur le tas de gros objets.</span><span class="sxs-lookup"><span data-stu-id="e0c20-165">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="e0c20-166">Générations</span><span class="sxs-lookup"><span data-stu-id="e0c20-166">Generations</span></span>

<span data-ttu-id="e0c20-167">Le tas est organisé en générations. Il peut ainsi gérer des objets durables et éphémères.</span><span class="sxs-lookup"><span data-stu-id="e0c20-167">The heap is organized into generations so it can handle long-lived and short-lived objects.</span></span> <span data-ttu-id="e0c20-168">Le garbage collection consiste principalement en la récupération d'objets éphémères qui occupent généralement une petite partie du tas.</span><span class="sxs-lookup"><span data-stu-id="e0c20-168">Garbage collection primarily occurs with the reclamation of short-lived objects that typically occupy only a small part of the heap.</span></span> <span data-ttu-id="e0c20-169">Il existe trois générations d'objets sur le tas :</span><span class="sxs-lookup"><span data-stu-id="e0c20-169">There are three generations of objects on the heap:</span></span>

- <span data-ttu-id="e0c20-170">**Génération 0**.</span><span class="sxs-lookup"><span data-stu-id="e0c20-170">**Generation 0**.</span></span> <span data-ttu-id="e0c20-171">Il s'agit de la génération la plus jeune, qui contient des objets éphémères.</span><span class="sxs-lookup"><span data-stu-id="e0c20-171">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="e0c20-172">Un exemple d'objet éphémère est une variable temporaire.</span><span class="sxs-lookup"><span data-stu-id="e0c20-172">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="e0c20-173">Le garbage collection a le plus souvent lieu dans cette génération.</span><span class="sxs-lookup"><span data-stu-id="e0c20-173">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="e0c20-174">Les objets nouvellement attribués forment une nouvelle génération d’objets et sont implicitement des collections de génération 0.</span><span class="sxs-lookup"><span data-stu-id="e0c20-174">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="e0c20-175">Cependant, s’il s’agit de gros objets, ils vont sur le tas de gros objets dans une collection de génération 2.</span><span class="sxs-lookup"><span data-stu-id="e0c20-175">However, if they are large objects, they go on the large object heap in a generation 2 collection.</span></span>

  <span data-ttu-id="e0c20-176">La plupart des objets sont libérés pour l'opération garbage collection dans la génération 0 et ne survivent pas à la génération suivante.</span><span class="sxs-lookup"><span data-stu-id="e0c20-176">Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation.</span></span>

- <span data-ttu-id="e0c20-177">**Génération 1**.</span><span class="sxs-lookup"><span data-stu-id="e0c20-177">**Generation 1**.</span></span> <span data-ttu-id="e0c20-178">Cette génération contient des objets éphémères et sert de tampon entre objets éphémères et objets durables.</span><span class="sxs-lookup"><span data-stu-id="e0c20-178">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

- <span data-ttu-id="e0c20-179">**Génération 2**.</span><span class="sxs-lookup"><span data-stu-id="e0c20-179">**Generation 2**.</span></span> <span data-ttu-id="e0c20-180">Cette génération contient des objets durables.</span><span class="sxs-lookup"><span data-stu-id="e0c20-180">This generation contains long-lived objects.</span></span> <span data-ttu-id="e0c20-181">Un exemple d’objet à longue durée de vie est un objet dans une application serveur qui contient des données statiques qui sont en direct pendant toute la durée du processus.</span><span class="sxs-lookup"><span data-stu-id="e0c20-181">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

<span data-ttu-id="e0c20-182">Les opérations garbage collection se produisent sur des générations spécifiques, selon les conditions spécifiées.</span><span class="sxs-lookup"><span data-stu-id="e0c20-182">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="e0c20-183">La collecte d'une génération signifie la collecte des objets de cette génération et de toutes ses générations plus jeunes.</span><span class="sxs-lookup"><span data-stu-id="e0c20-183">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="e0c20-184">Les opérations garbage collection de génération 2 sont également appelées garbage collection complet, car elles libèrent tous les objets de toutes les générations (autrement dit, tous les objets du tas managé).</span><span class="sxs-lookup"><span data-stu-id="e0c20-184">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims all objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="e0c20-185">Survie et promotions</span><span class="sxs-lookup"><span data-stu-id="e0c20-185">Survival and promotions</span></span>

<span data-ttu-id="e0c20-186">Les objets qui ne sont pas récupérés dans une collecte des ordures sont connus sous le nom de survivants et sont promus à la prochaine génération.</span><span class="sxs-lookup"><span data-stu-id="e0c20-186">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation.</span></span> <span data-ttu-id="e0c20-187">Les objets qui survivent à un garbage collection de génération 0 sont promus à la génération 1, les objets qui survivent à un garbage collection de génération 1 sont promus à la génération 2 et les objets qui survivent à un garbage collection de génération 2 restent dans la génération 2.</span><span class="sxs-lookup"><span data-stu-id="e0c20-187">Objects that survive a generation 0 garbage collection are promoted to generation 1; objects that survive a generation 1 garbage collection are promoted to generation 2; and objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="e0c20-188">Lorsque le éboueur détecte que le taux de survie est élevé en une génération, il augmente le seuil d’allocation pour cette génération.</span><span class="sxs-lookup"><span data-stu-id="e0c20-188">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="e0c20-189">La collection suivante reçoit une taille substantielle de mémoire récupérée.</span><span class="sxs-lookup"><span data-stu-id="e0c20-189">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="e0c20-190">Le CLR équilibre continuellement deux priorités : ne pas laisser l’ensemble de travail d’une application devenir trop grand en retardant la collecte des ordures et en ne laissant pas la collecte des ordures fonctionner trop fréquemment.</span><span class="sxs-lookup"><span data-stu-id="e0c20-190">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="e0c20-191">Segments et générations éphémères</span><span class="sxs-lookup"><span data-stu-id="e0c20-191">Ephemeral generations and segments</span></span>

<span data-ttu-id="e0c20-192">Étant donné que les objets des générations 0 et 1 sont éphémères, ces générations sont appelées générations éphémères.</span><span class="sxs-lookup"><span data-stu-id="e0c20-192">Because objects in generations 0 and 1 are short-lived, these generations are known as the ephemeral generations.</span></span>

<span data-ttu-id="e0c20-193">Les générations éphémères doivent être allouées dans le segment de mémoire appelé segment éphémère.</span><span class="sxs-lookup"><span data-stu-id="e0c20-193">Ephemeral generations must be allocated in the memory segment that is known as the ephemeral segment.</span></span> <span data-ttu-id="e0c20-194">Chaque nouveau segment acquis par le garbage collector devient le nouveau segment éphémère et contient les objets qui ont survécu à un garbage collection de génération 0.</span><span class="sxs-lookup"><span data-stu-id="e0c20-194">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="e0c20-195">L'ancien segment éphémère devient le nouveau segment de génération 2.</span><span class="sxs-lookup"><span data-stu-id="e0c20-195">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="e0c20-196">La taille du segment éphémère varie selon qu’un système est 32 ou 64 bits, et sur le type de collecteur d’ordures qu’il est en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="e0c20-196">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit, and on the type of garbage collector it is running.</span></span> <span data-ttu-id="e0c20-197">Le tableau ci-dessous répertorie les valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="e0c20-197">Default values are shown in the following table.</span></span>

||<span data-ttu-id="e0c20-198">32 bits</span><span class="sxs-lookup"><span data-stu-id="e0c20-198">32-bit</span></span>|<span data-ttu-id="e0c20-199">64 bits</span><span class="sxs-lookup"><span data-stu-id="e0c20-199">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="e0c20-200">Garbage collector pour station de travail</span><span class="sxs-lookup"><span data-stu-id="e0c20-200">Workstation GC</span></span>|<span data-ttu-id="e0c20-201">16 Mo</span><span class="sxs-lookup"><span data-stu-id="e0c20-201">16 MB</span></span>|<span data-ttu-id="e0c20-202">256 octets</span><span class="sxs-lookup"><span data-stu-id="e0c20-202">256 MB</span></span>|
|<span data-ttu-id="e0c20-203">Garbage collector pour serveur</span><span class="sxs-lookup"><span data-stu-id="e0c20-203">Server GC</span></span>|<span data-ttu-id="e0c20-204">64 Mo</span><span class="sxs-lookup"><span data-stu-id="e0c20-204">64 MB</span></span>|<span data-ttu-id="e0c20-205">4 Go</span><span class="sxs-lookup"><span data-stu-id="e0c20-205">4 GB</span></span>|
|<span data-ttu-id="e0c20-206">Garbage collector pour serveur > 4 processeurs logiques</span><span class="sxs-lookup"><span data-stu-id="e0c20-206">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="e0c20-207">32 Mo</span><span class="sxs-lookup"><span data-stu-id="e0c20-207">32 MB</span></span>|<span data-ttu-id="e0c20-208">2 Go</span><span class="sxs-lookup"><span data-stu-id="e0c20-208">2 GB</span></span>|
|<span data-ttu-id="e0c20-209">Garbage collector pour serveur > 8 processeurs logiques</span><span class="sxs-lookup"><span data-stu-id="e0c20-209">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="e0c20-210">16 Mo</span><span class="sxs-lookup"><span data-stu-id="e0c20-210">16 MB</span></span>|<span data-ttu-id="e0c20-211">1 Go</span><span class="sxs-lookup"><span data-stu-id="e0c20-211">1 GB</span></span>|

<span data-ttu-id="e0c20-212">Le segment éphémère peut inclure des objets de la génération 2.</span><span class="sxs-lookup"><span data-stu-id="e0c20-212">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="e0c20-213">Les objets de génération 2 peuvent utiliser plusieurs segments (autant que votre processus en requiert et que la mémoire en autorise).</span><span class="sxs-lookup"><span data-stu-id="e0c20-213">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="e0c20-214">La quantité de mémoire libérée à partir d'un garbage collection éphémère est limitée à la taille du segment éphémère.</span><span class="sxs-lookup"><span data-stu-id="e0c20-214">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="e0c20-215">La quantité de mémoire libérée est proportionnelle à l'espace occupé par les objets morts.</span><span class="sxs-lookup"><span data-stu-id="e0c20-215">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="e0c20-216">Déroulement d’une opération garbage collection</span><span class="sxs-lookup"><span data-stu-id="e0c20-216">What happens during a garbage collection</span></span>

<span data-ttu-id="e0c20-217">Une opération garbage collection présente les phases suivantes :</span><span class="sxs-lookup"><span data-stu-id="e0c20-217">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="e0c20-218">Une phase de marquage qui recherche et crée une liste de tous les objets actifs.</span><span class="sxs-lookup"><span data-stu-id="e0c20-218">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="e0c20-219">Une phase de déplacement qui met à jour les références aux objets qui seront compactés.</span><span class="sxs-lookup"><span data-stu-id="e0c20-219">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="e0c20-220">Une phase de compactage qui libère l'espace occupé par les objets morts et compacte les objets survivants.</span><span class="sxs-lookup"><span data-stu-id="e0c20-220">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="e0c20-221">La phase de compactage déplace les objets qui ont survécu à un garbage collection vers l'extrémité la plus ancienne du segment.</span><span class="sxs-lookup"><span data-stu-id="e0c20-221">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="e0c20-222">Étant donné que les collections de génération 2 peuvent occuper plusieurs segments, les objets promus dans la génération 2 peuvent être déplacés dans un segment plus ancien.</span><span class="sxs-lookup"><span data-stu-id="e0c20-222">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="e0c20-223">Les survivants des générations 1 et 2 peuvent être déplacés vers un autre segment, car ils sont promus à la génération 2.</span><span class="sxs-lookup"><span data-stu-id="e0c20-223">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="e0c20-224">Normalement, le grand tas d’objets (LOH) n’est pas compacté, car la copie de gros objets impose une pénalité de performance.</span><span class="sxs-lookup"><span data-stu-id="e0c20-224">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="e0c20-225">Cependant, dans .NET Core et en .NET Framework 4.5.1 et plus tard, vous pouvez utiliser la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété pour compacter le tas de gros objets sur demande.</span><span class="sxs-lookup"><span data-stu-id="e0c20-225">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="e0c20-226">En outre, le LOH est automatiquement compacté lorsqu’une limite dure est définie en spécifiant soit :</span><span class="sxs-lookup"><span data-stu-id="e0c20-226">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="e0c20-227">une limite de mémoire sur un conteneur, ou</span><span class="sxs-lookup"><span data-stu-id="e0c20-227">a memory limit on a container, or</span></span>
  - <span data-ttu-id="e0c20-228">les options de configuration [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) ou [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent)</span><span class="sxs-lookup"><span data-stu-id="e0c20-228">the [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) run-time configuration options</span></span>

<span data-ttu-id="e0c20-229">Le garbage collector utilise les informations suivantes pour déterminer si les objets sont vivants :</span><span class="sxs-lookup"><span data-stu-id="e0c20-229">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="e0c20-230">**Empiler les racines**.</span><span class="sxs-lookup"><span data-stu-id="e0c20-230">**Stack roots**.</span></span> <span data-ttu-id="e0c20-231">Variables de pile fournies par le compilateur juste-à-temps (JIT) et l'explorateur de pile.</span><span class="sxs-lookup"><span data-stu-id="e0c20-231">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="e0c20-232">Les optimisations JIT peuvent allonger ou raccourcir les régions de code dans lesquelles les variables de pile sont signalées au collecteur d’ordures.</span><span class="sxs-lookup"><span data-stu-id="e0c20-232">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="e0c20-233">**Poignées de collecte des ordures**.</span><span class="sxs-lookup"><span data-stu-id="e0c20-233">**Garbage collection handles**.</span></span> <span data-ttu-id="e0c20-234">Handles qui pointent vers les objets managés qui peuvent être alloués par le code utilisateur ou par le Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="e0c20-234">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="e0c20-235">**Données statiques**.</span><span class="sxs-lookup"><span data-stu-id="e0c20-235">**Static data**.</span></span> <span data-ttu-id="e0c20-236">Objets statiques des domaines d'application qui pourraient référencer d'autres objets.</span><span class="sxs-lookup"><span data-stu-id="e0c20-236">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="e0c20-237">Chaque domaine d'application effectue le suivi de ses objets statiques.</span><span class="sxs-lookup"><span data-stu-id="e0c20-237">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="e0c20-238">Avant qu'une opération garbage collection ne démarre, tous les threads managés sont suspendus à l'exception du thread qui a déclenché l'opération.</span><span class="sxs-lookup"><span data-stu-id="e0c20-238">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="e0c20-239">L'illustration suivante montre un thread qui déclenche un garbage collection et entraîne l'interruption des autres threads.</span><span class="sxs-lookup"><span data-stu-id="e0c20-239">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![Lorsqu'un thread déclenche un nettoyage de la mémoire](./media/gc-triggered.png)

## <a name="manipulate-unmanaged-resources"></a><span data-ttu-id="e0c20-241">Manipuler les ressources non manipulées</span><span class="sxs-lookup"><span data-stu-id="e0c20-241">Manipulate unmanaged resources</span></span>

<span data-ttu-id="e0c20-242">Si les objets gérés font référence à des objets non gérés en utilisant leurs poignées de fichiers indigènes, vous devez libérer explicitement les objets non gérés, parce que le collecteur d’ordures ne suit la mémoire que sur le tas géré.</span><span class="sxs-lookup"><span data-stu-id="e0c20-242">If managed objects reference unmanaged objects by using their native file handles, you have to explicitly free the unmanaged objects, because the garbage collector only tracks memory on the managed heap.</span></span>

<span data-ttu-id="e0c20-243">Les utilisateurs de l’objet géré ne peuvent pas disposer des ressources indigènes utilisées par l’objet.</span><span class="sxs-lookup"><span data-stu-id="e0c20-243">Users of the managed object may not dispose the native resources used by the object.</span></span> <span data-ttu-id="e0c20-244">Pour effectuer le nettoyage, vous pouvez rendre l’objet géré finalisé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-244">To perform the cleanup, you can make the managed object finalizable.</span></span> <span data-ttu-id="e0c20-245">La finalisation consiste en des actions de nettoyage qui s’exécutent lorsque l’objet n’est plus utilisé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-245">Finalization consists of cleanup actions that execute when the object is no longer in use.</span></span> <span data-ttu-id="e0c20-246">Lorsque l’objet géré meurt, il effectue des actions de nettoyage qui sont spécifiées dans sa méthode de finalisateur.</span><span class="sxs-lookup"><span data-stu-id="e0c20-246">When the managed object dies, it performs cleanup actions that are specified in its finalizer method.</span></span>

<span data-ttu-id="e0c20-247">Lorsqu'un objet finalisable est détecté comme étant mort, son finaliseur est placé dans une file d'attente afin que ses actions de nettoyage soient exécutées, mais l'objet lui-même est promu à la génération suivante.</span><span class="sxs-lookup"><span data-stu-id="e0c20-247">When a finalizable object is discovered to be dead, its finalizer is put in a queue so that its cleanup actions are executed, but the object itself is promoted to the next generation.</span></span> <span data-ttu-id="e0c20-248">Par conséquent, vous devez attendre jusqu'au garbage collection suivant sur cette génération (qui n'est pas nécessairement le garbage collection suivant) pour déterminer si l'objet a été récupéré.</span><span class="sxs-lookup"><span data-stu-id="e0c20-248">Therefore, you have to wait until the next garbage collection that occurs on that generation (which is not necessarily the next garbage collection) to determine whether the object has been reclaimed.</span></span>

<span data-ttu-id="e0c20-249">Pour plus d’informations <xref:System.Object.Finalize?displayProperty=nameWithType>sur la finalisation, voir .</span><span class="sxs-lookup"><span data-stu-id="e0c20-249">For more information about finalization, see <xref:System.Object.Finalize?displayProperty=nameWithType>.</span></span>

## <a name="workstation-and-server-garbage-collection"></a><span data-ttu-id="e0c20-250">Garbage collection de station de travail et de serveur</span><span class="sxs-lookup"><span data-stu-id="e0c20-250">Workstation and server garbage collection</span></span>

<span data-ttu-id="e0c20-251">Le garbage collector s'ajuste automatiquement et peut travailler dans une large gamme de scénarios.</span><span class="sxs-lookup"><span data-stu-id="e0c20-251">The garbage collector is self-tuning and can work in a wide variety of scenarios.</span></span> <span data-ttu-id="e0c20-252">Vous pouvez utiliser un [paramètre de fichiers](../../core/run-time-config/garbage-collector.md#flavors-of-garbage-collection) de configuration pour définir le type de collecte des ordures en fonction des caractéristiques de la charge de travail.</span><span class="sxs-lookup"><span data-stu-id="e0c20-252">You can use a [configuration file setting](../../core/run-time-config/garbage-collector.md#flavors-of-garbage-collection) to set the type of garbage collection based on the characteristics of the workload.</span></span> <span data-ttu-id="e0c20-253">Le CLR fournit les types de garbage collection suivants :</span><span class="sxs-lookup"><span data-stu-id="e0c20-253">The CLR provides the following types of garbage collection:</span></span>

- <span data-ttu-id="e0c20-254">La collecte des ordures de poste de travail (GC) est conçue pour les applications client.</span><span class="sxs-lookup"><span data-stu-id="e0c20-254">Workstation garbage collection (GC) is designed for client apps.</span></span> <span data-ttu-id="e0c20-255">C’est la saveur GC par défaut pour les applications autonomes.</span><span class="sxs-lookup"><span data-stu-id="e0c20-255">It is the default GC flavor for standalone apps.</span></span> <span data-ttu-id="e0c20-256">Pour les applications hébergées, par exemple, celles hébergées par ASP.NET, l’hôte détermine la saveur GC par défaut.</span><span class="sxs-lookup"><span data-stu-id="e0c20-256">For hosted apps, for example, those hosted by ASP.NET, the host determines the default GC flavor.</span></span>

  <span data-ttu-id="e0c20-257">Le garbage collection de station de travail peut être simultané ou non simultané.</span><span class="sxs-lookup"><span data-stu-id="e0c20-257">Workstation garbage collection can be concurrent or non-concurrent.</span></span> <span data-ttu-id="e0c20-258">Le garbage collection simultané permet aux threads managés de continuer à fonctionner pendant un garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e0c20-258">Concurrent garbage collection enables managed threads to continue operations during a garbage collection.</span></span> <span data-ttu-id="e0c20-259">[La collecte des ordures de fond](#background-workstation-garbage-collection) remplace la collecte [simultanée des ordures](#concurrent-garbage-collection) dans .NET Framework 4 et les versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="e0c20-259">[Background garbage collection](#background-workstation-garbage-collection) replaces [concurrent garbage collection](#concurrent-garbage-collection) in .NET Framework 4 and later versions.</span></span>

- <span data-ttu-id="e0c20-260">Garbage collection de serveur, prévu pour les applications serveur qui ont besoin d'un débit et d'une extensibilité.</span><span class="sxs-lookup"><span data-stu-id="e0c20-260">Server garbage collection, which is intended for server applications that need high throughput and scalability.</span></span>

  - <span data-ttu-id="e0c20-261">Dans .NET Core, la collecte des ordures du serveur peut être non simultanée ou arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="e0c20-261">In .NET Core, server garbage collection can be non-concurrent or background.</span></span>

  - <span data-ttu-id="e0c20-262">Dans .NET Framework 4.5 et les versions ultérieures, la collecte des ordures du serveur peut être non simultanée ou arrière-plan (la collecte des ordures de fond remplace la collecte simultanée des ordures).</span><span class="sxs-lookup"><span data-stu-id="e0c20-262">In .NET Framework 4.5 and later versions, server garbage collection can be non-concurrent or background (background garbage collection replaces concurrent garbage collection).</span></span> <span data-ttu-id="e0c20-263">Dans .NET Framework 4 et les versions précédentes, la collecte des ordures du serveur n’est pas simultanée.</span><span class="sxs-lookup"><span data-stu-id="e0c20-263">In .NET Framework 4 and previous versions, server garbage collection is non-concurrent.</span></span>

<span data-ttu-id="e0c20-264">L’illustration suivante montre les fils dédiés qui effectuent la collecte des ordures sur un serveur :</span><span class="sxs-lookup"><span data-stu-id="e0c20-264">The following illustration shows the dedicated threads that perform the garbage collection on a server:</span></span>

![Threads de garbage collection du serveur](./media/gc-server.png)

### <a name="compare-workstation-and-server-garbage-collection"></a><span data-ttu-id="e0c20-266">Comparez la station de travail et la collecte des ordures des serveurs</span><span class="sxs-lookup"><span data-stu-id="e0c20-266">Compare workstation and server garbage collection</span></span>

<span data-ttu-id="e0c20-267">Voici les considérations liées aux threads et aux performances pour le garbage collection de station de travail :</span><span class="sxs-lookup"><span data-stu-id="e0c20-267">The following are threading and performance considerations for workstation garbage collection:</span></span>

- <span data-ttu-id="e0c20-268">La collecte se produit sur le thread utilisateur qui a déclenché le garbage collection et reste à la même priorité.</span><span class="sxs-lookup"><span data-stu-id="e0c20-268">The collection occurs on the user thread that triggered the garbage collection and remains at the same priority.</span></span> <span data-ttu-id="e0c20-269">Étant donné que les threads utilisateur sont généralement exécutés à la priorité normale, le garbage collector (qui s'exécute sur un thread de priorité normale) doit rivaliser avec d'autres threads pour le temps processeur.</span><span class="sxs-lookup"><span data-stu-id="e0c20-269">Because user threads typically run at normal priority, the garbage collector (which runs on a normal priority thread) must compete with other threads for CPU time.</span></span> <span data-ttu-id="e0c20-270">(Les fils qui exécutent le code natif ne sont pas suspendus sur le serveur ou la collecte des ordures de poste de travail.)</span><span class="sxs-lookup"><span data-stu-id="e0c20-270">(Threads that run native code are not suspended on either server or workstation garbage collection.)</span></span>

- <span data-ttu-id="e0c20-271">La collecte des ordures de poste de travail est toujours utilisée sur un ordinateur qui n’a qu’un seul processeur, quel que soit le réglage de [configuration.](../../core/run-time-config/garbage-collector.md#systemgcservercomplus_gcserver)</span><span class="sxs-lookup"><span data-stu-id="e0c20-271">Workstation garbage collection is always used on a computer that has only one processor, regardless of the [configuration setting](../../core/run-time-config/garbage-collector.md#systemgcservercomplus_gcserver).</span></span>

<span data-ttu-id="e0c20-272">Voici les considérations liées aux threads et aux performances pour le garbage collection de serveur :</span><span class="sxs-lookup"><span data-stu-id="e0c20-272">The following are threading and performance considerations for server garbage collection:</span></span>

- <span data-ttu-id="e0c20-273">La collecte se produit sur plusieurs threads dédiés qui s'exécutent au niveau de priorité `THREAD_PRIORITY_HIGHEST` .</span><span class="sxs-lookup"><span data-stu-id="e0c20-273">The collection occurs on multiple dedicated threads that are running at `THREAD_PRIORITY_HIGHEST` priority level.</span></span>

- <span data-ttu-id="e0c20-274">Un tas et un thread dédié pour effectuer le garbage collection sont fournis pour chaque UC, et les tas sont collectés au même moment.</span><span class="sxs-lookup"><span data-stu-id="e0c20-274">A heap and a dedicated thread to perform garbage collection are provided for each CPU, and the heaps are collected at the same time.</span></span> <span data-ttu-id="e0c20-275">Chaque tas contient un tas de petits objets et un tas d'objets volumineux, et tous les tas peuvent faire l'objet d'accès par du code utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e0c20-275">Each heap contains a small object heap and a large object heap, and all heaps can be accessed by user code.</span></span> <span data-ttu-id="e0c20-276">Les objets des différents tas peuvent faire référence les uns aux autres.</span><span class="sxs-lookup"><span data-stu-id="e0c20-276">Objects on different heaps can refer to each other.</span></span>

- <span data-ttu-id="e0c20-277">Étant donné que plusieurs threads de garbage collection fonctionnent ensemble, le garbage collection de serveur est plus rapide que le garbage collection de station de travail sur un tas de même taille.</span><span class="sxs-lookup"><span data-stu-id="e0c20-277">Because multiple garbage collection threads work together, server garbage collection is faster than workstation garbage collection on the same size heap.</span></span>

- <span data-ttu-id="e0c20-278">Le garbage collection de serveur présente souvent des segments de plus grande taille.</span><span class="sxs-lookup"><span data-stu-id="e0c20-278">Server garbage collection often has larger size segments.</span></span> <span data-ttu-id="e0c20-279">Cependant, il ne s’agit que d’une généralisation : la taille du segment est spécifique à la mise en œuvre et peut être modifiée.</span><span class="sxs-lookup"><span data-stu-id="e0c20-279">However, this is only a generalization: segment size is implementation-specific and is subject to change.</span></span> <span data-ttu-id="e0c20-280">Ne faites pas d’hypothèses sur la taille des segments attribués par le collecteur d’ordures lors de l’accordage de votre application.</span><span class="sxs-lookup"><span data-stu-id="e0c20-280">Don't make assumptions about the size of segments allocated by the garbage collector when tuning your app.</span></span>

- <span data-ttu-id="e0c20-281">Le garbage collection de serveur peut consommer beaucoup de ressources.</span><span class="sxs-lookup"><span data-stu-id="e0c20-281">Server garbage collection can be resource-intensive.</span></span> <span data-ttu-id="e0c20-282">Par exemple, imaginez qu’il existe 12 processus qui utilisent le serveur GC fonctionnant sur un ordinateur qui a 4 processeurs.</span><span class="sxs-lookup"><span data-stu-id="e0c20-282">For example, imagine that there are 12 processes that use server GC running on a computer that has 4 processors.</span></span> <span data-ttu-id="e0c20-283">Si tous les processus se produisent pour ramasser les ordures en même temps, ils interfèrent les uns avec les autres, car il y aurait 12 threads prévus sur le même processeur.</span><span class="sxs-lookup"><span data-stu-id="e0c20-283">If all the processes happen to collect garbage at the same time, they would interfere with each other, as there would be 12 threads scheduled on the same processor.</span></span> <span data-ttu-id="e0c20-284">Si les processus sont actifs, ce n’est pas une bonne idée de les avoir tous utiliser serveur GC.</span><span class="sxs-lookup"><span data-stu-id="e0c20-284">If the processes are active, it's not a good idea to have them all use server GC.</span></span>

<span data-ttu-id="e0c20-285">Si vous exécutez des centaines d’instances d’une application, envisagez d’utiliser la collecte des ordures de poste de travail avec la collecte simultanée des ordures désactivées.</span><span class="sxs-lookup"><span data-stu-id="e0c20-285">If you're running hundreds of instances of an application, consider using workstation garbage collection with concurrent garbage collection disabled.</span></span> <span data-ttu-id="e0c20-286">Cela provoquera moins de changements de contexte, ce qui peut améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="e0c20-286">This will result in less context switching, which can improve performance.</span></span>

## <a name="background-workstation-garbage-collection"></a><span data-ttu-id="e0c20-287">Nettoyage de la mémoire de la station de travail en arrière-plan</span><span class="sxs-lookup"><span data-stu-id="e0c20-287">Background workstation garbage collection</span></span>

<span data-ttu-id="e0c20-288">Dans la collecte des ordures de poste de travail de fond, les générations éphémères (0 et 1) sont collectées au besoin pendant que la collecte de la génération 2 est en cours.</span><span class="sxs-lookup"><span data-stu-id="e0c20-288">In background workstation garbage collection, ephemeral generations (0 and 1) are collected as needed while the collection of generation 2 is in progress.</span></span> <span data-ttu-id="e0c20-289">La collecte des ordures de poste de travail de fond est effectuée sur un fil dédié et ne s’applique qu’aux collections de génération 2.</span><span class="sxs-lookup"><span data-stu-id="e0c20-289">Background workstation garbage collection is performed on a dedicated thread and applies only to generation 2 collections.</span></span>

<span data-ttu-id="e0c20-290">La collecte des ordures de fond est activée par défaut et peut être activée ou désactivée avec le paramètre de configuration [gcConcurrent](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) dans les applications .NET Framework ou le paramètre [System.GC.Concurrent](../../core/run-time-config/garbage-collector.md#systemgcconcurrentcomplus_gcconcurrent) dans les applications .NET Core.</span><span class="sxs-lookup"><span data-stu-id="e0c20-290">Background garbage collection is enabled by default and can be enabled or disabled with the [gcConcurrent](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) configuration setting in .NET Framework apps or the [System.GC.Concurrent](../../core/run-time-config/garbage-collector.md#systemgcconcurrentcomplus_gcconcurrent) setting in .NET Core apps.</span></span>

> [!NOTE]
> <span data-ttu-id="e0c20-291">La collecte des ordures de fond remplace [la collecte simultanée des ordures](#concurrent-garbage-collection) et est disponible dans .NET Framework 4 et les versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="e0c20-291">Background garbage collection replaces [concurrent garbage collection](#concurrent-garbage-collection) and is available in .NET Framework 4 and later versions.</span></span> <span data-ttu-id="e0c20-292">Dans .NET Framework 4, il n’est pris en charge que pour la collecte des ordures de poste de travail.</span><span class="sxs-lookup"><span data-stu-id="e0c20-292">In .NET Framework 4, it's supported only for workstation garbage collection.</span></span> <span data-ttu-id="e0c20-293">En commençant par .NET Framework 4.5, la collecte des ordures de fond est disponible pour la collecte des ordures de poste de travail et de serveur.</span><span class="sxs-lookup"><span data-stu-id="e0c20-293">Starting with .NET Framework 4.5, background garbage collection is available for both workstation and server garbage collection.</span></span>

<span data-ttu-id="e0c20-294">Une collecte sur des générations éphémères pendant le garbage collection d'arrière-plan est appelée garbage collection de premier plan.</span><span class="sxs-lookup"><span data-stu-id="e0c20-294">A collection on ephemeral generations during background garbage collection is known as foreground garbage collection.</span></span> <span data-ttu-id="e0c20-295">Lorsque des opérations garbage collection de premier plan ont lieu, tous les threads managés sont suspendus.</span><span class="sxs-lookup"><span data-stu-id="e0c20-295">When foreground garbage collections occur, all managed threads are suspended.</span></span>

<span data-ttu-id="e0c20-296">Lorsque la collecte des ordures de fond est en cours et que vous avez alloué suffisamment d’objets en génération 0, le CLR effectue une collecte des ordures de première génération ou de génération 1.</span><span class="sxs-lookup"><span data-stu-id="e0c20-296">When background garbage collection is in progress and you've allocated enough objects in generation 0, the CLR performs a generation 0 or generation 1 foreground garbage collection.</span></span> <span data-ttu-id="e0c20-297">Le thread de garbage collection d'arrière-plan dédié vérifie des points sécurisés fréquents de façon à déterminer s'il existe une demande de garbage collection de premier plan.</span><span class="sxs-lookup"><span data-stu-id="e0c20-297">The dedicated background garbage collection thread checks at frequent safe points to determine whether there is a request for foreground garbage collection.</span></span> <span data-ttu-id="e0c20-298">Le cas échéant, la collecte d'arrière-plan s'interrompt afin que le garbage collection de premier plan puisse se produire.</span><span class="sxs-lookup"><span data-stu-id="e0c20-298">If there is, the background collection suspends itself so that foreground garbage collection can occur.</span></span> <span data-ttu-id="e0c20-299">Une fois le garbage collection de premier plan terminé, le thread de garbage collection d'arrière-plan dédié et les threads utilisateur reprennent.</span><span class="sxs-lookup"><span data-stu-id="e0c20-299">After the foreground garbage collection is completed, the dedicated background garbage collection thread and user threads resume.</span></span>

<span data-ttu-id="e0c20-300">Le garbage collection d'arrière-plan supprime les restrictions d'allocation imposées par le garbage collection simultané, car des opérations garbage collection éphémères peuvent se produire pendant le garbage collection d'arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="e0c20-300">Background garbage collection removes allocation restrictions imposed by concurrent garbage collection, because ephemeral garbage collections can occur during background garbage collection.</span></span> <span data-ttu-id="e0c20-301">La collecte des ordures de fond peut enlever des objets morts dans des générations éphémères.</span><span class="sxs-lookup"><span data-stu-id="e0c20-301">Background garbage collection can remove dead objects in ephemeral generations.</span></span> <span data-ttu-id="e0c20-302">Il peut également étendre le tas si nécessaire au cours d’une collecte des ordures de génération 1.</span><span class="sxs-lookup"><span data-stu-id="e0c20-302">It can also expand the heap if needed during a generation 1 garbage collection.</span></span>

<span data-ttu-id="e0c20-303">L’illustration suivante montre le nettoyage de la mémoire en arrière-plan effectué sur un thread dédié distinct, sur une station de travail :</span><span class="sxs-lookup"><span data-stu-id="e0c20-303">The following illustration shows background garbage collection performed on a separate dedicated thread on a workstation:</span></span>

![Nettoyage de la mémoire de la station de travail en arrière-plan](./media/fundamentals/background-workstation-garbage-collection.png)

### <a name="background-server-garbage-collection"></a><span data-ttu-id="e0c20-305">Nettoyage de la mémoire du serveur en arrière-plan</span><span class="sxs-lookup"><span data-stu-id="e0c20-305">Background server garbage collection</span></span>

<span data-ttu-id="e0c20-306">À partir de .NET Framework 4.5, la collecte des ordures serveur d’arrière-plan est le mode par défaut pour la collecte des ordures du serveur.</span><span class="sxs-lookup"><span data-stu-id="e0c20-306">Starting with .NET Framework 4.5, background server garbage collection is the default mode for server garbage collection.</span></span>

<span data-ttu-id="e0c20-307">Fonctions de collecte des ordures du serveur de fond de la même façon que la collecte des ordures de poste de travail de fond, décrite dans la section précédente, mais il y a quelques différences :</span><span class="sxs-lookup"><span data-stu-id="e0c20-307">Background server garbage collection functions similarly to background workstation garbage collection, described in the previous section, but there are a few differences:</span></span>

- <span data-ttu-id="e0c20-308">La collecte des ordures de poste de travail de fond utilise un fil de collecte d’ordures de fond dédié, tandis que la collecte des ordures de serveur d’arrière-plan utilise plusieurs fils.</span><span class="sxs-lookup"><span data-stu-id="e0c20-308">Background workstation garbage collection uses one dedicated background garbage collection thread, whereas background server garbage collection uses multiple threads.</span></span> <span data-ttu-id="e0c20-309">Typiquement, il ya un thread dédié pour chaque processeur logique.</span><span class="sxs-lookup"><span data-stu-id="e0c20-309">Typically, there's a dedicated thread for each logical processor.</span></span>

- <span data-ttu-id="e0c20-310">Contrairement au thread du garbage collection de station de travail en arrière-plan, ces threads n'expirent pas.</span><span class="sxs-lookup"><span data-stu-id="e0c20-310">Unlike the workstation background garbage collection thread, these threads do not time out.</span></span>

<span data-ttu-id="e0c20-311">L’illustration suivante montre le nettoyage de la mémoire en arrière-plan effectué sur un thread dédié distinct, sur un serveur :</span><span class="sxs-lookup"><span data-stu-id="e0c20-311">The following illustration shows background garbage collection performed on a separate dedicated thread on a server:</span></span>

![Nettoyage de la mémoire du serveur en arrière-plan](./media/fundamentals/background-server-garbage-collection.png)

## <a name="concurrent-garbage-collection"></a><span data-ttu-id="e0c20-313">Garbage collection simultané</span><span class="sxs-lookup"><span data-stu-id="e0c20-313">Concurrent garbage collection</span></span>

> [!TIP]
> <span data-ttu-id="e0c20-314">Cette section s’applique à :</span><span class="sxs-lookup"><span data-stu-id="e0c20-314">This section applies to:</span></span>
>
> - <span data-ttu-id="e0c20-315">.NET Framework 3.5 et plus tôt pour la collecte des ordures de poste de travail</span><span class="sxs-lookup"><span data-stu-id="e0c20-315">.NET Framework 3.5 and earlier for workstation garbage collection</span></span>
> - <span data-ttu-id="e0c20-316">.NET Framework 4 et plus tôt pour la collecte des ordures du serveur</span><span class="sxs-lookup"><span data-stu-id="e0c20-316">.NET Framework 4 and earlier for server garbage collection</span></span>
>
> <span data-ttu-id="e0c20-317">Les déchets concomitants sont remplacés par [la collecte des ordures de fond](#background-workstation-garbage-collection) dans les versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="e0c20-317">Concurrent garbage is replaced by [background garbage collection](#background-workstation-garbage-collection) in later versions.</span></span>

<span data-ttu-id="e0c20-318">Dans le poste de travail ou la collecte des ordures serveur, vous pouvez activer la [collecte simultanée des ordures](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md), ce qui permet aux threads de fonctionner en même temps qu’un fil dédié qui effectue la collecte des ordures pendant la majeure partie de la durée de la collecte.</span><span class="sxs-lookup"><span data-stu-id="e0c20-318">In workstation or server garbage collection, you can [enable concurrent garbage collection](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md), which enables threads to run concurrently with a dedicated thread that performs the garbage collection for most of the duration of the collection.</span></span> <span data-ttu-id="e0c20-319">Cette option affecte uniquement les opérations garbage collection de génération 2. Les générations 0 et 1 sont toujours non simultanées car elles se terminent très rapidement.</span><span class="sxs-lookup"><span data-stu-id="e0c20-319">This option affects only garbage collections in generation 2; generations 0 and 1 are always non-concurrent because they finish very fast.</span></span>

<span data-ttu-id="e0c20-320">Le garbage collection simultané permet aux applications interactives d'être plus réactives en réduisant les pauses d'une collection.</span><span class="sxs-lookup"><span data-stu-id="e0c20-320">Concurrent garbage collection enables interactive applications to be more responsive by minimizing pauses for a collection.</span></span> <span data-ttu-id="e0c20-321">Les threads managés peuvent continuer à s'exécuter une grande partie de la durée du garbage collection simultané.</span><span class="sxs-lookup"><span data-stu-id="e0c20-321">Managed threads can continue to run most of the time while the concurrent garbage collection thread is running.</span></span> <span data-ttu-id="e0c20-322">Cela génère des pauses plus courtes pendant l'opération garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e0c20-322">This results in shorter pauses while a garbage collection is occurring.</span></span>

<span data-ttu-id="e0c20-323">Le garbage collection simultané est exécuté sur un thread dédié.</span><span class="sxs-lookup"><span data-stu-id="e0c20-323">Concurrent garbage collection is performed on a dedicated thread.</span></span> <span data-ttu-id="e0c20-324">Par défaut, le CLR effectue le garbage collection de station de travail avec le garbage collection simultané activé.</span><span class="sxs-lookup"><span data-stu-id="e0c20-324">By default, the CLR runs workstation garbage collection with concurrent garbage collection enabled.</span></span> <span data-ttu-id="e0c20-325">Ceci est vrai pour les ordinateurs multiprocesseur et à processeur unique.</span><span class="sxs-lookup"><span data-stu-id="e0c20-325">This is true for single-processor and multi-processor computers.</span></span>

<span data-ttu-id="e0c20-326">L'illustration suivante montre le garbage collection simultané exécuté sur un thread dédié différent.</span><span class="sxs-lookup"><span data-stu-id="e0c20-326">The following illustration shows concurrent garbage collection performed on a separate dedicated thread.</span></span>

![Threads de nettoyage de la mémoire simultanés](./media/gc-concurrent.png)

## <a name="see-also"></a><span data-ttu-id="e0c20-328">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="e0c20-328">See also</span></span>

- [<span data-ttu-id="e0c20-329">Options de configuration pour GC</span><span class="sxs-lookup"><span data-stu-id="e0c20-329">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- <span data-ttu-id="e0c20-330">[Nettoyage de la mémoire](index.md) (garbage collection)</span><span class="sxs-lookup"><span data-stu-id="e0c20-330">[Garbage collection](index.md)</span></span>
