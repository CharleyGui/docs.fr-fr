---
title: Notions de base du garbage collection
description: Découvrez comment fonctionne le récupérateur de mémoire et comment le configurer pour optimiser ses performances.
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: 1fdf7fcd61fb4bf9e8e0cbfe28842208f6eadd00
ms.sourcegitcommit: 73aa9653547a1cd70ee6586221f79cc29b588ebd
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/23/2020
ms.locfileid: "82102435"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="5bc24-103">Notions de base du garbage collection</span><span class="sxs-lookup"><span data-stu-id="5bc24-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="5bc24-104">Dans le langage courant runtime (CLR), le collecteur d’ordures (GC) sert de gestionnaire automatique de mémoire.</span><span class="sxs-lookup"><span data-stu-id="5bc24-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="5bc24-105">Le collecteur d’ordures gère l’attribution et la libération de mémoire pour une application.</span><span class="sxs-lookup"><span data-stu-id="5bc24-105">The garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="5bc24-106">Pour les développeurs travaillant avec le code géré, cela signifie que vous n’avez pas à écrire du code pour effectuer des tâches de gestion de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="5bc24-106">For developers working with managed code, this means that you don't have to write code to perform memory management tasks.</span></span> <span data-ttu-id="5bc24-107">La gestion automatique de la mémoire peut éliminer les problèmes courants, comme l’oubli de libérer un objet et provoquer une fuite de mémoire ou tenter d’accéder à la mémoire pour un objet qui a déjà été libéré.</span><span class="sxs-lookup"><span data-stu-id="5bc24-107">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak or attempting to access memory for an object that's already been freed.</span></span>

<span data-ttu-id="5bc24-108">Cet article décrit les concepts fondamentaux de la collecte des ordures.</span><span class="sxs-lookup"><span data-stu-id="5bc24-108">This article describes the core concepts of garbage collection.</span></span>

## <a name="benefits"></a><span data-ttu-id="5bc24-109">Avantages</span><span class="sxs-lookup"><span data-stu-id="5bc24-109">Benefits</span></span>

<span data-ttu-id="5bc24-110">Le collecteur d’ordures offre les avantages suivants :</span><span class="sxs-lookup"><span data-stu-id="5bc24-110">The garbage collector provides the following benefits:</span></span>

- <span data-ttu-id="5bc24-111">Libère les développeurs d’avoir à libérer manuellement la mémoire.</span><span class="sxs-lookup"><span data-stu-id="5bc24-111">Frees developers from having to manually release memory.</span></span>

- <span data-ttu-id="5bc24-112">Il alloue efficacement les objets sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-112">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="5bc24-113">Il libère les objets qui ne sont plus utilisés, efface leur mémoire et garde la mémoire disponible pour les futures allocations.</span><span class="sxs-lookup"><span data-stu-id="5bc24-113">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="5bc24-114">Les objets gérés obtiennent automatiquement du contenu propre pour commencer, de sorte que leurs constructeurs n’ont pas à initialiser tous les champs de données.</span><span class="sxs-lookup"><span data-stu-id="5bc24-114">Managed objects automatically get clean content to start with, so their constructors don't have to initialize every data field.</span></span>

- <span data-ttu-id="5bc24-115">Il sécurise la mémoire en s'assurant qu'un objet ne peut pas utiliser le contenu d'un autre objet.</span><span class="sxs-lookup"><span data-stu-id="5bc24-115">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="5bc24-116">Notions de base de la mémoire</span><span class="sxs-lookup"><span data-stu-id="5bc24-116">Fundamentals of memory</span></span>

<span data-ttu-id="5bc24-117">La liste suivante résume les concepts importants de la mémoire CLR.</span><span class="sxs-lookup"><span data-stu-id="5bc24-117">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="5bc24-118">Chaque processus possède son propre espace d'adressage virtuel séparé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-118">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="5bc24-119">Tous les processus sur le même ordinateur partagent la même mémoire physique et le fichier de page, s’il y en a un.</span><span class="sxs-lookup"><span data-stu-id="5bc24-119">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="5bc24-120">Par défaut, sur les ordinateurs 32 bits, chaque processus a un espace d'adressage virtuel en mode utilisateur de 2 Go.</span><span class="sxs-lookup"><span data-stu-id="5bc24-120">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="5bc24-121">En tant que développeur d'applications, vous travaillez uniquement avec l'espace d'adressage virtuel et ne gérez jamais directement la mémoire physique.</span><span class="sxs-lookup"><span data-stu-id="5bc24-121">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="5bc24-122">Le garbage collector alloue et libère la mémoire virtuelle pour vous sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-122">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="5bc24-123">Si vous écrivez du code natif, vous utilisez les fonctions Windows pour travailler avec l’espace d’adresse virtuel.</span><span class="sxs-lookup"><span data-stu-id="5bc24-123">If you're writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="5bc24-124">Ces fonctions allouent et libèrent la mémoire virtuelle pour vous sur les tas natifs.</span><span class="sxs-lookup"><span data-stu-id="5bc24-124">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="5bc24-125">La mémoire virtuelle peut être dans trois états :</span><span class="sxs-lookup"><span data-stu-id="5bc24-125">Virtual memory can be in three states:</span></span>

  | <span data-ttu-id="5bc24-126">State</span><span class="sxs-lookup"><span data-stu-id="5bc24-126">State</span></span> | <span data-ttu-id="5bc24-127">Description</span><span class="sxs-lookup"><span data-stu-id="5bc24-127">Description</span></span> |
  |---------|---------|
  | <span data-ttu-id="5bc24-128">Gratuit</span><span class="sxs-lookup"><span data-stu-id="5bc24-128">Free</span></span> | <span data-ttu-id="5bc24-129">Il n'existe aucune référence au bloc de mémoire et celui-ci est disponible pour allocation.</span><span class="sxs-lookup"><span data-stu-id="5bc24-129">The block of memory has no references to it and is available for allocation.</span></span> |
  | <span data-ttu-id="5bc24-130">Réservé</span><span class="sxs-lookup"><span data-stu-id="5bc24-130">Reserved</span></span> | <span data-ttu-id="5bc24-131">Le bloc de mémoire est disponible pour votre utilisation et ne peut pas être utilisé pour une autre demande d'allocation.</span><span class="sxs-lookup"><span data-stu-id="5bc24-131">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="5bc24-132">Toutefois, vous ne pouvez pas stocker de données dans ce bloc de mémoire tant qu'il n'est pas validé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-132">However, you cannot store data to this memory block until it is committed.</span></span> |
  | <span data-ttu-id="5bc24-133">Committed</span><span class="sxs-lookup"><span data-stu-id="5bc24-133">Committed</span></span> | <span data-ttu-id="5bc24-134">Le bloc de mémoire est assigné au stockage physique.</span><span class="sxs-lookup"><span data-stu-id="5bc24-134">The block of memory is assigned to physical storage.</span></span> |

- <span data-ttu-id="5bc24-135">L'espace d'adressage virtuel peut être fragmenté.</span><span class="sxs-lookup"><span data-stu-id="5bc24-135">Virtual address space can get fragmented.</span></span> <span data-ttu-id="5bc24-136">Cela signifie qu'il existe des blocs libres, également appelés trous, dans l'espace d'adressage.</span><span class="sxs-lookup"><span data-stu-id="5bc24-136">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="5bc24-137">Lorsqu'une allocation de mémoire virtuelle est demandée, le gestionnaire de mémoire virtuelle doit rechercher un bloc unique libre suffisamment grand pour satisfaire la demande d'allocation.</span><span class="sxs-lookup"><span data-stu-id="5bc24-137">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="5bc24-138">Même si vous avez 2 Go d’espace libre, une allocation qui nécessite 2 Go sera infructueuse à moins que tout cet espace libre est dans un bloc d’adresse unique.</span><span class="sxs-lookup"><span data-stu-id="5bc24-138">Even if you have 2 GB of free space, an allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="5bc24-139">Vous pouvez manquer de mémoire s’il n’y a pas assez d’espace d’adresse virtuelle pour réserver ou de l’espace physique à engager.</span><span class="sxs-lookup"><span data-stu-id="5bc24-139">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="5bc24-140">Le fichier de page est utilisé même si la pression de mémoire physique (c’est-à-dire la demande de mémoire physique) est faible.</span><span class="sxs-lookup"><span data-stu-id="5bc24-140">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="5bc24-141">La première fois que la pression de mémoire physique est élevée, le système d’exploitation doit faire de la place dans la mémoire physique pour stocker des données, et il soutient certaines des données qui sont en mémoire physique au fichier de page.</span><span class="sxs-lookup"><span data-stu-id="5bc24-141">The first time physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="5bc24-142">Ces données ne sont pas bipées jusqu’à ce qu’elles soient nécessaires, il est donc possible de rencontrer des paging dans des situations où la pression de mémoire physique est faible.</span><span class="sxs-lookup"><span data-stu-id="5bc24-142">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>
  
### <a name="memory-allocation"></a><span data-ttu-id="5bc24-143">Allocation de mémoire</span><span class="sxs-lookup"><span data-stu-id="5bc24-143">Memory allocation</span></span>

<span data-ttu-id="5bc24-144">Lorsque vous initialisez un nouveau processus, le runtime réserve une région d'espace d'adressage contigu pour le processus.</span><span class="sxs-lookup"><span data-stu-id="5bc24-144">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="5bc24-145">Cet espace d'adressage est appelé le tas managé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-145">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="5bc24-146">Le tas managé garde un pointeur vers l'adresse qui sera allouée au nouvel objet du tas.</span><span class="sxs-lookup"><span data-stu-id="5bc24-146">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="5bc24-147">À l’origine, ce pointeur indique l’adresse de base du tas managé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-147">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="5bc24-148">Tous les types référence sont alloués sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-148">All reference types are allocated on the managed heap.</span></span> <span data-ttu-id="5bc24-149">Lorsqu’une application crée le premier type référence, la mémoire est allouée pour le type à l’adresse de base du tas managé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-149">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="5bc24-150">Lorsque l'application crée l'objet suivant, le « garbage collector » lui alloue de la mémoire dans l'espace d'adressage qui suit immédiatement le premier objet.</span><span class="sxs-lookup"><span data-stu-id="5bc24-150">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="5bc24-151">Aussi longtemps que de l'espace d'adressage est disponible, le « garbage collector » continue à allouer de l'espace pour de nouveaux objets selon la même procédure.</span><span class="sxs-lookup"><span data-stu-id="5bc24-151">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>

<span data-ttu-id="5bc24-152">L'allocation de mémoire à partir du tas managé est plus rapide que l'allocation de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="5bc24-152">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="5bc24-153">Parce que le temps d’exécution alloue la mémoire pour un objet en ajoutant une valeur à un pointeur, il est presque aussi rapide que l’attribution de la mémoire de la pile.</span><span class="sxs-lookup"><span data-stu-id="5bc24-153">Because the runtime allocates memory for an object by adding a value to a pointer, it's almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="5bc24-154">En outre, parce que les nouveaux objets qui sont attribués consécutivement sont stockés de manière contigu dans le tas géré, une application peut accéder rapidement aux objets.</span><span class="sxs-lookup"><span data-stu-id="5bc24-154">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects quickly.</span></span>

### <a name="memory-release"></a><span data-ttu-id="5bc24-155">Libération de mémoire</span><span class="sxs-lookup"><span data-stu-id="5bc24-155">Memory release</span></span>

<span data-ttu-id="5bc24-156">Le moteur d'optimisation du « garbage collector » détermine le meilleur moment pour lancer une opération garbage collection sur base des allocations de mémoire effectuées.</span><span class="sxs-lookup"><span data-stu-id="5bc24-156">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="5bc24-157">Lorsque le « garbage collector » effectue une opération garbage collection, il libère la mémoire pour les objets qui ne sont plus utilisées par l'application.</span><span class="sxs-lookup"><span data-stu-id="5bc24-157">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="5bc24-158">Il détermine quels objets ne sont plus utilisés en examinant les *racines*de l’application .</span><span class="sxs-lookup"><span data-stu-id="5bc24-158">It determines which objects are no longer being used by examining the application's *roots*.</span></span> <span data-ttu-id="5bc24-159">Les racines de l’application comprennent des champs statiques, des variables et des paramètres locaux sur la pile d’un thread et des Registres du processeur.</span><span class="sxs-lookup"><span data-stu-id="5bc24-159">An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</span></span> <span data-ttu-id="5bc24-160">Chaque racine fait référence à un objet du tas managé ou, à défaut, a la valeur Null.</span><span class="sxs-lookup"><span data-stu-id="5bc24-160">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="5bc24-161">Le Garbage collector a accès à la liste des racines actives entretenues par le compilateur juste-à-temps (JIT) et le runtime.</span><span class="sxs-lookup"><span data-stu-id="5bc24-161">The garbage collector has access to the list of active roots that the just-in-time (JIT) compiler and the runtime maintain.</span></span> <span data-ttu-id="5bc24-162">À l’aide de cette liste, le collecteur d’ordures crée un graphique qui contient tous les objets qui sont accessibles à partir des racines.</span><span class="sxs-lookup"><span data-stu-id="5bc24-162">Using this list, the garbage collector creates a graph that contains all the objects that are reachable from the roots.</span></span>

<span data-ttu-id="5bc24-163">Les objets non compris dans le graphique ne sont pas accessibles à partir des racines de l'application.</span><span class="sxs-lookup"><span data-stu-id="5bc24-163">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="5bc24-164">Le éboueur considère les objets inaccessibles et libère la mémoire qui leur est allouée.</span><span class="sxs-lookup"><span data-stu-id="5bc24-164">The garbage collector considers unreachable objects garbage and releases the memory allocated for them.</span></span> <span data-ttu-id="5bc24-165">Au cours d'une opération garbage collection, le « garbage collector » examine le tas managé pour y détecter les blocs de mémoire occupés par des objets inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="5bc24-165">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="5bc24-166">Chaque fois qu'il détecte un objet inaccessible, il utilise une fonction de copie de mémoire pour compacter les objets accessibles en mémoire et libérer les blocs d'espaces d'adressage alloués aux objets inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="5bc24-166">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="5bc24-167">Lorsque la mémoire allouée aux objets accessibles a été réduite, le « garbage collector » procède aux corrections de pointeurs nécessaires pour que les racines des applications pointent vers les nouveaux emplacements des objets.</span><span class="sxs-lookup"><span data-stu-id="5bc24-167">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="5bc24-168">Il positionne aussi le pointeur du tas managé après le dernier objet accessible.</span><span class="sxs-lookup"><span data-stu-id="5bc24-168">It also positions the managed heap's pointer after the last reachable object.</span></span>

<span data-ttu-id="5bc24-169">La mémoire n’est compactée que si une collection découvre un nombre important d’objets inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="5bc24-169">Memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="5bc24-170">Si tous les objets du tas managé survivent à une collection, il n'est pas nécessaire de procéder à un compactage de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="5bc24-170">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>

<span data-ttu-id="5bc24-171">Pour améliorer les performances, le runtime alloue de la mémoire pour les objets de grandes dimensions dans un tas séparé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-171">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="5bc24-172">Le « garbage collector » libère automatiquement la mémoire des objets de grande dimension.</span><span class="sxs-lookup"><span data-stu-id="5bc24-172">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="5bc24-173">Cependant, pour éviter de déplacer de gros objets dans la mémoire, cette mémoire n’est généralement pas compactée.</span><span class="sxs-lookup"><span data-stu-id="5bc24-173">However, to avoid moving large objects in memory, this memory is usually not compacted.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="5bc24-174">Conditions pour une opération garbage collection</span><span class="sxs-lookup"><span data-stu-id="5bc24-174">Conditions for a garbage collection</span></span>

<span data-ttu-id="5bc24-175">Le garbage collection se produit lorsque l'une des conditions suivantes est vraie :</span><span class="sxs-lookup"><span data-stu-id="5bc24-175">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="5bc24-176">Le système possède peu de mémoire physique.</span><span class="sxs-lookup"><span data-stu-id="5bc24-176">The system has low physical memory.</span></span> <span data-ttu-id="5bc24-177">Ceci est détecté par la notification à faible mémoire de l’OS ou la mémoire basse comme indiqué par l’hôte.</span><span class="sxs-lookup"><span data-stu-id="5bc24-177">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="5bc24-178">La mémoire utilisée par les objets alloués sur le tas géré dépasse un seuil acceptable.</span><span class="sxs-lookup"><span data-stu-id="5bc24-178">The memory that's used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="5bc24-179">Ce seuil est continuellement ajusté à mesure que le processus s'exécute.</span><span class="sxs-lookup"><span data-stu-id="5bc24-179">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="5bc24-180">La méthode <xref:System.GC.Collect%2A?displayProperty=nameWithType> est appelée.</span><span class="sxs-lookup"><span data-stu-id="5bc24-180">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="5bc24-181">Dans presque tous les cas, vous n’avez pas à appeler cette méthode, parce que le collecteur d’ordures fonctionne en permanence.</span><span class="sxs-lookup"><span data-stu-id="5bc24-181">In almost all cases, you don't have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="5bc24-182">Cette méthode est principalement utilisée pour les situations uniques et les tests.</span><span class="sxs-lookup"><span data-stu-id="5bc24-182">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="5bc24-183">Tas managé</span><span class="sxs-lookup"><span data-stu-id="5bc24-183">The managed heap</span></span>

<span data-ttu-id="5bc24-184">Une fois que le garbage collector est initialisé par le CLR, il alloue un segment de mémoire pour stocker et gérer des objets.</span><span class="sxs-lookup"><span data-stu-id="5bc24-184">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="5bc24-185">Cette mémoire est appelée tas managé, par opposition à un tas natif dans le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="5bc24-185">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="5bc24-186">Il existe un tas managé pour chaque processus managé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-186">There is a managed heap for each managed process.</span></span> <span data-ttu-id="5bc24-187">Tous les threads du processus allouent de la mémoire pour les objets sur le même tas.</span><span class="sxs-lookup"><span data-stu-id="5bc24-187">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="5bc24-188">Pour réserver la mémoire, le collecteur d’ordures appelle la fonction [Windows VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) et réserve un segment de mémoire à la fois pour les applications gérées.</span><span class="sxs-lookup"><span data-stu-id="5bc24-188">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="5bc24-189">Le collecteur d’ordures réserve également des segments, au besoin, et libère des segments de nouveau au système d’exploitation (après les avoir effacés de tous les objets) en appelant la fonction [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) Windows.</span><span class="sxs-lookup"><span data-stu-id="5bc24-189">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5bc24-190">La taille des segments alloués par le garbage collector est spécifique à l'implémentation et susceptible de changer à tout moment, y compris les mises à jour périodiques.</span><span class="sxs-lookup"><span data-stu-id="5bc24-190">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="5bc24-191">Votre application ne doit jamais faire d'hypothèses concernant une taille de segment particulière, ni dépendre de celle-ci. Elle ne doit pas non plus tenter de configurer la quantité de mémoire disponible pour les allocations de segments.</span><span class="sxs-lookup"><span data-stu-id="5bc24-191">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="5bc24-192">Moins il y a d'objets alloués sur le tas, moins le garbage collector a à faire.</span><span class="sxs-lookup"><span data-stu-id="5bc24-192">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="5bc24-193">Lorsque vous allouez des objets, n’utilisez pas de valeurs arrondies qui dépassent vos besoins, comme l’attribution d’un tableau de 32 octets lorsque vous n’avez besoin que de 15 octets.</span><span class="sxs-lookup"><span data-stu-id="5bc24-193">When you allocate objects, don't use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="5bc24-194">Lorsqu’une collecte d’ordures est déclenchée, le éboueur récupère la mémoire occupée par des objets morts.</span><span class="sxs-lookup"><span data-stu-id="5bc24-194">When a garbage collection is triggered, the garbage collector reclaims the memory that's occupied by dead objects.</span></span> <span data-ttu-id="5bc24-195">Le processus de libération compacte les objets vivants afin qu'ils soient déplacés ensemble, et l'espace inutilisé est supprimé, ce qui entraîne la diminution du tas.</span><span class="sxs-lookup"><span data-stu-id="5bc24-195">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="5bc24-196">Cela garantit que les objets qui sont alloués ensemble restent ensemble sur le tas géré pour préserver leur localité.</span><span class="sxs-lookup"><span data-stu-id="5bc24-196">This ensures that objects that are allocated together stay together on the managed heap to preserve their locality.</span></span>

<span data-ttu-id="5bc24-197">Le déroulement (fréquence et durée) des garbage collection est le résultat du volume des allocations et de la quantité de mémoire restante sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-197">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="5bc24-198">Le tas peut être considéré comme l’accumulation de deux tas : le [tas de grands objets](large-object-heap.md) et le tas de petits objets.</span><span class="sxs-lookup"><span data-stu-id="5bc24-198">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span> <span data-ttu-id="5bc24-199">Le grand tas d’objets contient des objets qui sont 85.000 octets et plus grands, qui sont généralement des tableaux.</span><span class="sxs-lookup"><span data-stu-id="5bc24-199">The large object heap contains objects that are 85,000 bytes and larger, which are usually arrays.</span></span> <span data-ttu-id="5bc24-200">Il est rare, par exemple, d’être extrêmement grand.</span><span class="sxs-lookup"><span data-stu-id="5bc24-200">It's rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="5bc24-201">Vous pouvez [configurer la taille du seuil](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) pour que les objets aillent sur le tas de gros objets.</span><span class="sxs-lookup"><span data-stu-id="5bc24-201">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="5bc24-202">Générations</span><span class="sxs-lookup"><span data-stu-id="5bc24-202">Generations</span></span>

<span data-ttu-id="5bc24-203">L’algorithme GC est basé sur plusieurs considérations :</span><span class="sxs-lookup"><span data-stu-id="5bc24-203">The GC algorithm is based on several considerations:</span></span>

- <span data-ttu-id="5bc24-204">Il est plus rapide de compacter la mémoire pour une partie du tas géré que pour l’ensemble du tas géré.</span><span class="sxs-lookup"><span data-stu-id="5bc24-204">It's faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span>
- <span data-ttu-id="5bc24-205">Les objets plus récents ont une durée de vie plus courte et les objets plus anciens ont une durée de vie plus longue.</span><span class="sxs-lookup"><span data-stu-id="5bc24-205">Newer objects have shorter lifetimes and older objects have longer lifetimes.</span></span>
- <span data-ttu-id="5bc24-206">Les objets plus récents ont tendance à être liés les uns aux autres et accessibles par l’application à peu près au même moment.</span><span class="sxs-lookup"><span data-stu-id="5bc24-206">Newer objects tend to be related to each other and accessed by the application around the same time.</span></span>

<span data-ttu-id="5bc24-207">La collecte des ordures se produit principalement avec la remise en état d’objets de courte durée.</span><span class="sxs-lookup"><span data-stu-id="5bc24-207">Garbage collection primarily occurs with the reclamation of short-lived objects.</span></span> <span data-ttu-id="5bc24-208">Pour optimiser la performance du collecteur d’ordures, le tas géré est divisé en trois générations, 0, 1 et 2, de sorte qu’il peut gérer des objets de longue durée et de courte durée séparément.</span><span class="sxs-lookup"><span data-stu-id="5bc24-208">To optimize the performance of the garbage collector, the managed heap is divided into three generations, 0, 1, and 2, so it can handle long-lived and short-lived objects separately.</span></span> <span data-ttu-id="5bc24-209">Le collecteur d’ordures stocke de nouveaux objets de la génération 0.</span><span class="sxs-lookup"><span data-stu-id="5bc24-209">The garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="5bc24-210">Les objets qui sont créés à un stade précoce de la durée de vie de l'application et qui survivent aux collectes sont promus et stockés dans les générations 1 et 2.</span><span class="sxs-lookup"><span data-stu-id="5bc24-210">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="5bc24-211">Parce qu’il est plus rapide de compacter une partie du tas géré que l’ensemble du tas, ce régime permet au collecteur d’ordures de libérer la mémoire dans une génération spécifique plutôt que de libérer la mémoire pour l’ensemble du tas géré chaque fois qu’il effectue une collection.</span><span class="sxs-lookup"><span data-stu-id="5bc24-211">Because it's faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>

- <span data-ttu-id="5bc24-212">**Génération 0**.</span><span class="sxs-lookup"><span data-stu-id="5bc24-212">**Generation 0**.</span></span> <span data-ttu-id="5bc24-213">Il s'agit de la génération la plus jeune, qui contient des objets éphémères.</span><span class="sxs-lookup"><span data-stu-id="5bc24-213">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="5bc24-214">Un exemple d'objet éphémère est une variable temporaire.</span><span class="sxs-lookup"><span data-stu-id="5bc24-214">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="5bc24-215">Le garbage collection a le plus souvent lieu dans cette génération.</span><span class="sxs-lookup"><span data-stu-id="5bc24-215">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="5bc24-216">Les objets nouvellement attribués forment une nouvelle génération d’objets et sont implicitement des collections de génération 0.</span><span class="sxs-lookup"><span data-stu-id="5bc24-216">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="5bc24-217">Cependant, s’il s’agit de gros objets, ils vont sur le tas de gros objets dans une collection de génération 2.</span><span class="sxs-lookup"><span data-stu-id="5bc24-217">However, if they are large objects, they go on the large object heap in a generation 2 collection.</span></span>

  <span data-ttu-id="5bc24-218">La plupart des objets sont récupérés pour la collecte des ordures en génération 0 et ne survivent pas à la prochaine génération.</span><span class="sxs-lookup"><span data-stu-id="5bc24-218">Most objects are reclaimed for garbage collection in generation 0 and don't survive to the next generation.</span></span>
  
  <span data-ttu-id="5bc24-219">Si une application tente de créer un nouvel objet lorsque la génération 0 est pleine, le collecteur d’ordures effectue une collection dans une tentative de libérer l’espace d’adresse pour l’objet.</span><span class="sxs-lookup"><span data-stu-id="5bc24-219">If an application attempts to create a new object when generation 0 is full, the garbage collector performs a collection in an attempt to free address space for the object.</span></span> <span data-ttu-id="5bc24-220">Le « garbage collector » commence par examiner les objets de la génération 0 plutôt que tous les objets du tas managé.</span><span class="sxs-lookup"><span data-stu-id="5bc24-220">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="5bc24-221">Une collection de génération 0 à elle seule récupère souvent assez de mémoire pour permettre à l’application de continuer à créer de nouveaux objets.</span><span class="sxs-lookup"><span data-stu-id="5bc24-221">A collection of generation 0 alone often reclaims enough memory to enable the application to continue creating new objects.</span></span>

- <span data-ttu-id="5bc24-222">**Génération 1**.</span><span class="sxs-lookup"><span data-stu-id="5bc24-222">**Generation 1**.</span></span> <span data-ttu-id="5bc24-223">Cette génération contient des objets éphémères et sert de tampon entre objets éphémères et objets durables.</span><span class="sxs-lookup"><span data-stu-id="5bc24-223">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

  <span data-ttu-id="5bc24-224">Après que le collecteur d’ordures effectue une collection de génération 0, il compacte la mémoire pour les objets accessibles et les promeut à la génération 1.</span><span class="sxs-lookup"><span data-stu-id="5bc24-224">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects and promotes them to generation 1.</span></span> <span data-ttu-id="5bc24-225">Étant donné que les objets qui survivent aux collectes ont tendance à avoir de plus longues durées de vie, il est logique de les promouvoir à une génération supérieure.</span><span class="sxs-lookup"><span data-stu-id="5bc24-225">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="5bc24-226">Le collecteur d’ordures n’a pas à réexaminer les objets dans les générations 1 et 2 chaque fois qu’il effectue une collection de génération 0.</span><span class="sxs-lookup"><span data-stu-id="5bc24-226">The garbage collector doesn't have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>
  
  <span data-ttu-id="5bc24-227">Si une collection de génération 0 ne récupère pas suffisamment de mémoire pour que l’application crée un nouvel objet, le collecteur d’ordures peut effectuer une collection de génération 1, puis de génération 2.</span><span class="sxs-lookup"><span data-stu-id="5bc24-227">If a collection of generation 0 does not reclaim enough memory for the application to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="5bc24-228">Les objets qui survivent aux collectes sont promus et stockés dans les générations 1 et 2.</span><span class="sxs-lookup"><span data-stu-id="5bc24-228">Objects in generation 1 that survive collections are promoted to generation 2.</span></span>

- <span data-ttu-id="5bc24-229">**Génération 2**.</span><span class="sxs-lookup"><span data-stu-id="5bc24-229">**Generation 2**.</span></span> <span data-ttu-id="5bc24-230">Cette génération contient des objets durables.</span><span class="sxs-lookup"><span data-stu-id="5bc24-230">This generation contains long-lived objects.</span></span> <span data-ttu-id="5bc24-231">Un exemple d’objet à longue durée de vie est un objet dans une application serveur qui contient des données statiques qui sont en direct pendant toute la durée du processus.</span><span class="sxs-lookup"><span data-stu-id="5bc24-231">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

  <span data-ttu-id="5bc24-232">Les objets de la génération 2 qui survivent à une collection restent dans la génération 2 jusqu’à ce qu’ils soient jugés inaccessibles dans une future collection.</span><span class="sxs-lookup"><span data-stu-id="5bc24-232">Objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>

<span data-ttu-id="5bc24-233">Les opérations garbage collection se produisent sur des générations spécifiques, selon les conditions spécifiées.</span><span class="sxs-lookup"><span data-stu-id="5bc24-233">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="5bc24-234">La collecte d'une génération signifie la collecte des objets de cette génération et de toutes ses générations plus jeunes.</span><span class="sxs-lookup"><span data-stu-id="5bc24-234">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="5bc24-235">Une collecte des ordures de génération 2 est également connue comme une collecte complète des ordures, car elle récupère des objets dans toutes les générations (c’est-à-dire tous les objets dans le tas géré).</span><span class="sxs-lookup"><span data-stu-id="5bc24-235">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="5bc24-236">Survie et promotions</span><span class="sxs-lookup"><span data-stu-id="5bc24-236">Survival and promotions</span></span>

<span data-ttu-id="5bc24-237">Les objets qui ne sont pas récupérés dans une collecte des ordures sont connus sous le nom de survivants et sont promus à la prochaine génération :</span><span class="sxs-lookup"><span data-stu-id="5bc24-237">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation:</span></span>

- <span data-ttu-id="5bc24-238">Les objets qui survivent à une collecte des ordures de génération 0 sont promus à la génération 1.</span><span class="sxs-lookup"><span data-stu-id="5bc24-238">Objects that survive a generation 0 garbage collection are promoted to generation 1.</span></span>
- <span data-ttu-id="5bc24-239">Les objets qui survivent à une collecte des ordures de génération 1 sont promus à la génération 2.</span><span class="sxs-lookup"><span data-stu-id="5bc24-239">Objects that survive a generation 1 garbage collection are promoted to generation 2.</span></span>
- <span data-ttu-id="5bc24-240">Les objets qui survivent à une collecte des ordures de génération 2 restent de la génération 2.</span><span class="sxs-lookup"><span data-stu-id="5bc24-240">Objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="5bc24-241">Lorsque le éboueur détecte que le taux de survie est élevé en une génération, il augmente le seuil d’allocation pour cette génération.</span><span class="sxs-lookup"><span data-stu-id="5bc24-241">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="5bc24-242">La collection suivante reçoit une taille substantielle de mémoire récupérée.</span><span class="sxs-lookup"><span data-stu-id="5bc24-242">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="5bc24-243">Le CLR équilibre continuellement deux priorités : ne pas laisser l’ensemble de travail d’une application devenir trop grand en retardant la collecte des ordures et en ne laissant pas la collecte des ordures fonctionner trop fréquemment.</span><span class="sxs-lookup"><span data-stu-id="5bc24-243">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="5bc24-244">Segments et générations éphémères</span><span class="sxs-lookup"><span data-stu-id="5bc24-244">Ephemeral generations and segments</span></span>

<span data-ttu-id="5bc24-245">Parce que les objets des générations 0 et 1 sont de courte durée, ces générations sont connues comme les *générations éphémères.*</span><span class="sxs-lookup"><span data-stu-id="5bc24-245">Because objects in generations 0 and 1 are short-lived, these generations are known as the *ephemeral generations*.</span></span>

<span data-ttu-id="5bc24-246">Des générations éphémères sont attribuées dans le segment de la mémoire connu sous le nom de segment éphémère.</span><span class="sxs-lookup"><span data-stu-id="5bc24-246">Ephemeral generations are allocated in the memory segment that's known as the ephemeral segment.</span></span> <span data-ttu-id="5bc24-247">Chaque nouveau segment acquis par le garbage collector devient le nouveau segment éphémère et contient les objets qui ont survécu à un garbage collection de génération 0.</span><span class="sxs-lookup"><span data-stu-id="5bc24-247">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="5bc24-248">L'ancien segment éphémère devient le nouveau segment de génération 2.</span><span class="sxs-lookup"><span data-stu-id="5bc24-248">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="5bc24-249">La taille du segment éphémère varie selon qu’un système est 32 bits ou 64 bits et sur le type de collecteur d’ordures qu’il est en cours d’exécution[(poste de travail ou serveur GC](workstation-server-gc.md)).</span><span class="sxs-lookup"><span data-stu-id="5bc24-249">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit and on the type of garbage collector it is running ([workstation or server GC](workstation-server-gc.md)).</span></span> <span data-ttu-id="5bc24-250">Le tableau suivant montre les tailles par défaut du segment éphémère.</span><span class="sxs-lookup"><span data-stu-id="5bc24-250">The following table shows the default sizes of the ephemeral segment.</span></span>

|<span data-ttu-id="5bc24-251">Poste de travail/serveur GC</span><span class="sxs-lookup"><span data-stu-id="5bc24-251">Workstation/server GC</span></span>|<span data-ttu-id="5bc24-252">32 bits</span><span class="sxs-lookup"><span data-stu-id="5bc24-252">32-bit</span></span>|<span data-ttu-id="5bc24-253">64 bits</span><span class="sxs-lookup"><span data-stu-id="5bc24-253">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="5bc24-254">Garbage collector pour station de travail</span><span class="sxs-lookup"><span data-stu-id="5bc24-254">Workstation GC</span></span>|<span data-ttu-id="5bc24-255">16 Mo</span><span class="sxs-lookup"><span data-stu-id="5bc24-255">16 MB</span></span>|<span data-ttu-id="5bc24-256">256 octets</span><span class="sxs-lookup"><span data-stu-id="5bc24-256">256 MB</span></span>|
|<span data-ttu-id="5bc24-257">Garbage collector pour serveur</span><span class="sxs-lookup"><span data-stu-id="5bc24-257">Server GC</span></span>|<span data-ttu-id="5bc24-258">64 Mo</span><span class="sxs-lookup"><span data-stu-id="5bc24-258">64 MB</span></span>|<span data-ttu-id="5bc24-259">4 Go</span><span class="sxs-lookup"><span data-stu-id="5bc24-259">4 GB</span></span>|
|<span data-ttu-id="5bc24-260">Garbage collector pour serveur > 4 processeurs logiques</span><span class="sxs-lookup"><span data-stu-id="5bc24-260">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="5bc24-261">32 Mo</span><span class="sxs-lookup"><span data-stu-id="5bc24-261">32 MB</span></span>|<span data-ttu-id="5bc24-262">2 Go</span><span class="sxs-lookup"><span data-stu-id="5bc24-262">2 GB</span></span>|
|<span data-ttu-id="5bc24-263">Garbage collector pour serveur > 8 processeurs logiques</span><span class="sxs-lookup"><span data-stu-id="5bc24-263">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="5bc24-264">16 Mo</span><span class="sxs-lookup"><span data-stu-id="5bc24-264">16 MB</span></span>|<span data-ttu-id="5bc24-265">1 Go</span><span class="sxs-lookup"><span data-stu-id="5bc24-265">1 GB</span></span>|

<span data-ttu-id="5bc24-266">Le segment éphémère peut inclure des objets de la génération 2.</span><span class="sxs-lookup"><span data-stu-id="5bc24-266">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="5bc24-267">Les objets de génération 2 peuvent utiliser plusieurs segments (autant que votre processus en requiert et que la mémoire en autorise).</span><span class="sxs-lookup"><span data-stu-id="5bc24-267">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="5bc24-268">La quantité de mémoire libérée à partir d'un garbage collection éphémère est limitée à la taille du segment éphémère.</span><span class="sxs-lookup"><span data-stu-id="5bc24-268">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="5bc24-269">La quantité de mémoire libérée est proportionnelle à l'espace occupé par les objets morts.</span><span class="sxs-lookup"><span data-stu-id="5bc24-269">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="5bc24-270">Déroulement d’une opération garbage collection</span><span class="sxs-lookup"><span data-stu-id="5bc24-270">What happens during a garbage collection</span></span>

<span data-ttu-id="5bc24-271">Une opération garbage collection présente les phases suivantes :</span><span class="sxs-lookup"><span data-stu-id="5bc24-271">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="5bc24-272">Une phase de marquage qui recherche et crée une liste de tous les objets actifs.</span><span class="sxs-lookup"><span data-stu-id="5bc24-272">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="5bc24-273">Une phase de déplacement qui met à jour les références aux objets qui seront compactés.</span><span class="sxs-lookup"><span data-stu-id="5bc24-273">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="5bc24-274">Une phase de compactage qui libère l'espace occupé par les objets morts et compacte les objets survivants.</span><span class="sxs-lookup"><span data-stu-id="5bc24-274">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="5bc24-275">La phase de compactage déplace les objets qui ont survécu à un garbage collection vers l'extrémité la plus ancienne du segment.</span><span class="sxs-lookup"><span data-stu-id="5bc24-275">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="5bc24-276">Étant donné que les collections de génération 2 peuvent occuper plusieurs segments, les objets promus dans la génération 2 peuvent être déplacés dans un segment plus ancien.</span><span class="sxs-lookup"><span data-stu-id="5bc24-276">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="5bc24-277">Les survivants des générations 1 et 2 peuvent être déplacés vers un autre segment, car ils sont promus à la génération 2.</span><span class="sxs-lookup"><span data-stu-id="5bc24-277">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="5bc24-278">Normalement, le grand tas d’objets (LOH) n’est pas compacté, car la copie de gros objets impose une pénalité de performance.</span><span class="sxs-lookup"><span data-stu-id="5bc24-278">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="5bc24-279">Cependant, dans .NET Core et en .NET Framework 4.5.1 et plus tard, vous pouvez utiliser la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété pour compacter le tas de gros objets sur demande.</span><span class="sxs-lookup"><span data-stu-id="5bc24-279">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="5bc24-280">En outre, le LOH est automatiquement compacté lorsqu’une limite dure est définie en spécifiant soit :</span><span class="sxs-lookup"><span data-stu-id="5bc24-280">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="5bc24-281">Limite de mémoire sur un récipient.</span><span class="sxs-lookup"><span data-stu-id="5bc24-281">A memory limit on a container.</span></span>
  - <span data-ttu-id="5bc24-282">Les options de configuration [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) ou [GCHeapHardLimitPercent.](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent)</span><span class="sxs-lookup"><span data-stu-id="5bc24-282">The [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) run-time configuration options.</span></span>

<span data-ttu-id="5bc24-283">Le garbage collector utilise les informations suivantes pour déterminer si les objets sont vivants :</span><span class="sxs-lookup"><span data-stu-id="5bc24-283">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="5bc24-284">**Empiler les racines**.</span><span class="sxs-lookup"><span data-stu-id="5bc24-284">**Stack roots**.</span></span> <span data-ttu-id="5bc24-285">Variables de pile fournies par le compilateur juste-à-temps (JIT) et l'explorateur de pile.</span><span class="sxs-lookup"><span data-stu-id="5bc24-285">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="5bc24-286">Les optimisations JIT peuvent allonger ou raccourcir les régions de code dans lesquelles les variables de pile sont signalées au collecteur d’ordures.</span><span class="sxs-lookup"><span data-stu-id="5bc24-286">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="5bc24-287">**Poignées de collecte des ordures**.</span><span class="sxs-lookup"><span data-stu-id="5bc24-287">**Garbage collection handles**.</span></span> <span data-ttu-id="5bc24-288">Handles qui pointent vers les objets managés qui peuvent être alloués par le code utilisateur ou par le Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="5bc24-288">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="5bc24-289">**Données statiques**.</span><span class="sxs-lookup"><span data-stu-id="5bc24-289">**Static data**.</span></span> <span data-ttu-id="5bc24-290">Objets statiques des domaines d'application qui pourraient référencer d'autres objets.</span><span class="sxs-lookup"><span data-stu-id="5bc24-290">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="5bc24-291">Chaque domaine d'application effectue le suivi de ses objets statiques.</span><span class="sxs-lookup"><span data-stu-id="5bc24-291">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="5bc24-292">Avant qu'une opération garbage collection ne démarre, tous les threads managés sont suspendus à l'exception du thread qui a déclenché l'opération.</span><span class="sxs-lookup"><span data-stu-id="5bc24-292">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="5bc24-293">L'illustration suivante montre un thread qui déclenche un garbage collection et entraîne l'interruption des autres threads.</span><span class="sxs-lookup"><span data-stu-id="5bc24-293">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![Lorsqu'un thread déclenche un nettoyage de la mémoire](./media/gc-triggered.png)

## <a name="unmanaged-resources"></a><span data-ttu-id="5bc24-295">Ressources non gestions</span><span class="sxs-lookup"><span data-stu-id="5bc24-295">Unmanaged resources</span></span>

<span data-ttu-id="5bc24-296">Pour la plupart des objets créés par votre application, vous pouvez compter sur la collecte des ordures pour effectuer automatiquement les tâches de gestion de la mémoire nécessaires.</span><span class="sxs-lookup"><span data-stu-id="5bc24-296">For most of the objects that your application creates, you can rely on garbage collection to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="5bc24-297">Cependant, les ressources non managées requièrent un nettoyage explicite.</span><span class="sxs-lookup"><span data-stu-id="5bc24-297">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="5bc24-298">Le type le plus répandu de ressource non managée est un objet qui enveloppe une ressource de système d'exploitation telle qu'un handle de fichier ou de fenêtre ou une connexion réseau.</span><span class="sxs-lookup"><span data-stu-id="5bc24-298">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="5bc24-299">Bien que le collecteur d’ordures soit en mesure de suivre la durée de vie d’un objet géré qui encapsule une ressource non gérée, il n’a pas de connaissances spécifiques sur la façon de nettoyer la ressource.</span><span class="sxs-lookup"><span data-stu-id="5bc24-299">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it doesn't have specific knowledge about how to clean up the resource.</span></span>

<span data-ttu-id="5bc24-300">Lorsque vous créez un objet qui encapsule une ressource non gestion, il est recommandé de fournir le code `Dispose` nécessaire pour nettoyer la ressource non gestion dans une méthode publique.</span><span class="sxs-lookup"><span data-stu-id="5bc24-300">When you create an object that encapsulates an unmanaged resource, it's recommended that you provide the necessary code to clean up the unmanaged resource in a public `Dispose` method.</span></span> <span data-ttu-id="5bc24-301">En fournissant une méthode `Dispose`, vous donnez la possibilité aux utilisateurs de votre objet d’en libérer explicitement la mémoire lorsqu’ils ont fini de s’en servir.</span><span class="sxs-lookup"><span data-stu-id="5bc24-301">By providing a `Dispose` method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="5bc24-302">Lorsque vous utilisez un objet qui encapsule une ressource non `Dispose` gémanie, assurez-vous d’appeler au besoin.</span><span class="sxs-lookup"><span data-stu-id="5bc24-302">When you use an object that encapsulates an unmanaged resource, make sure to call `Dispose` as necessary.</span></span>

<span data-ttu-id="5bc24-303">Vous devez également fournir un moyen pour vos ressources non gestion d’être libérés au cas où un consommateur de votre type oublie d’appeler `Dispose`.</span><span class="sxs-lookup"><span data-stu-id="5bc24-303">You must also provide a way for your unmanaged resources to be released in case a consumer of your type forgets to call `Dispose`.</span></span> <span data-ttu-id="5bc24-304">Vous pouvez soit utiliser une poignée sûre pour envelopper la <xref:System.Object.Finalize?displayProperty=nameWithType> ressource non gérée, ou remplacer la méthode.</span><span class="sxs-lookup"><span data-stu-id="5bc24-304">You can either use a safe handle to wrap the unmanaged resource, or override the <xref:System.Object.Finalize?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="5bc24-305">Pour plus d’informations sur le nettoyage des ressources non gestion, voir [Nettoyer les ressources non gestions](unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="5bc24-305">For more information about cleaning up unmanaged resources, see [Clean up unmanaged resources](unmanaged.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="5bc24-306">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="5bc24-306">See also</span></span>

- [<span data-ttu-id="5bc24-307">Garbage collection de station de travail et de serveur</span><span class="sxs-lookup"><span data-stu-id="5bc24-307">Workstation and server garbage collection</span></span>](workstation-server-gc.md)
- [<span data-ttu-id="5bc24-308">Collecte des ordures de fond</span><span class="sxs-lookup"><span data-stu-id="5bc24-308">Background garbage collection</span></span>](background-gc.md)
- [<span data-ttu-id="5bc24-309">Options de configuration pour GC</span><span class="sxs-lookup"><span data-stu-id="5bc24-309">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- [<span data-ttu-id="5bc24-310">Nettoyage de la mémoire</span><span class="sxs-lookup"><span data-stu-id="5bc24-310">Garbage collection</span></span>](index.md)
