---
title: Implémenter une méthode Dispose
description: Dans cet article, vous apprendrez à implémenter la méthode dispose, qui libère les ressources non managées utilisées par votre code dans .NET.
ms.date: 09/08/2020
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: ec731ff4c1020100c2b7ff5041d42291141a5209
ms.sourcegitcommit: 6d1ae17e60384f3b5953ca7b45ac859ec6d4c3a0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/20/2020
ms.locfileid: "94982405"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="c5b20-103">Implémenter une méthode Dispose</span><span class="sxs-lookup"><span data-stu-id="c5b20-103">Implement a Dispose method</span></span>

<span data-ttu-id="c5b20-104">L’implémentation de la <xref:System.IDisposable.Dispose%2A> méthode est principalement destinée à libérer des ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="c5b20-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources.</span></span> <span data-ttu-id="c5b20-105">Lors de l’utilisation de membres d’instance qui sont des <xref:System.IDisposable> implémentations, il est courant d’appeler en cascade <xref:System.IDisposable.Dispose%2A> .</span><span class="sxs-lookup"><span data-stu-id="c5b20-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="c5b20-106">Il existe des raisons supplémentaires d’implémenter <xref:System.IDisposable.Dispose%2A> , par exemple, pour libérer de la mémoire qui a été allouée, supprimer un élément qui a été ajouté à une collection ou signaler la libération d’un verrou acquis.</span><span class="sxs-lookup"><span data-stu-id="c5b20-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, for example, to free memory that was allocated, remove an item that was added to a collection, or signal the release of a lock that was acquired.</span></span>

<span data-ttu-id="c5b20-107">Le [garbage collector .net](index.md) n’alloue pas ou ne libère pas de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="c5b20-107">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="c5b20-108">Le modèle de suppression d’un objet, appelé modèle de suppression, impose un ordre sur la durée de vie d’un objet.</span><span class="sxs-lookup"><span data-stu-id="c5b20-108">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="c5b20-109">Le modèle de suppression est utilisé pour les objets qui implémentent l' <xref:System.IDisposable> interface et est courant lors de l’interaction avec les handles de fichiers et de canaux, les handles de Registre, les handles d’attente ou les pointeurs vers des blocs de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="c5b20-109">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="c5b20-110">Cela est dû au fait que le garbage collector ne peut pas récupérer les objets non managés.</span><span class="sxs-lookup"><span data-stu-id="c5b20-110">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="c5b20-111">Pour garantir que les ressources sont toujours nettoyées de manière appropriée, une <xref:System.IDisposable.Dispose%2A> méthode doit être idempotent, de sorte qu’elle peut être appelée plusieurs fois sans lever d’exception.</span><span class="sxs-lookup"><span data-stu-id="c5b20-111">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="c5b20-112">En outre, les appels suivants de <xref:System.IDisposable.Dispose%2A> ne doivent rien faire.</span><span class="sxs-lookup"><span data-stu-id="c5b20-112">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="c5b20-113">L’exemple de code fourni pour la <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> méthode montre comment garbage collection peut provoquer l’exécution d’un finaliseur, alors qu’une référence non managée à l’objet ou à ses membres est toujours en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="c5b20-113">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="c5b20-114">Il peut être judicieux d’utiliser <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> pour rendre l’objet inéligible pour garbage collection du début de la routine actuelle jusqu’au point où cette méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="c5b20-114">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="c5b20-115">Handles sécurisés</span><span class="sxs-lookup"><span data-stu-id="c5b20-115">Safe handles</span></span>

<span data-ttu-id="c5b20-116">L’écriture de code pour le finaliseur d’un objet est une tâche complexe qui peut provoquer des problèmes si elle n’est pas effectuée correctement.</span><span class="sxs-lookup"><span data-stu-id="c5b20-116">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="c5b20-117">Par conséquent, nous vous recommandons de construire des objets <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> au lieu d'implémenter un finaliseur.</span><span class="sxs-lookup"><span data-stu-id="c5b20-117">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="c5b20-118">Un <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> est un type managé abstrait qui encapsule un <xref:System.IntPtr?displayProperty=nameWithType> qui identifie une ressource non managée.</span><span class="sxs-lookup"><span data-stu-id="c5b20-118">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="c5b20-119">Sur Windows, il peut identifier un handle sur UNIX, un descripteur de fichier.</span><span class="sxs-lookup"><span data-stu-id="c5b20-119">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="c5b20-120">Il fournit toute la logique nécessaire pour s’assurer que cette ressource est libérée une seule fois, lorsque la `SafeHandle` est supprimée de ou lorsque toutes les références à `SafeHandle` ont été supprimées et que l' `SafeHandle` instance est finalisée.</span><span class="sxs-lookup"><span data-stu-id="c5b20-120">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="c5b20-121"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>Est une classe de base abstraite.</span><span class="sxs-lookup"><span data-stu-id="c5b20-121">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="c5b20-122">Les classes dérivées fournissent des instances spécifiques pour différents genres de handles.</span><span class="sxs-lookup"><span data-stu-id="c5b20-122">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="c5b20-123">Ces classes dérivées valident les valeurs de qui <xref:System.IntPtr?displayProperty=nameWithType> sont considérées comme non valides et comment libérer le handle.</span><span class="sxs-lookup"><span data-stu-id="c5b20-123">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="c5b20-124">Par exemple, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> dérive de `SafeHandle` à Wrap `IntPtrs` qui identifient les descripteurs/descripteurs de fichiers ouverts et substitue sa <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> méthode pour le fermer (via la `close` fonction sur UNIX ou `CloseHandle` Function sur Windows).</span><span class="sxs-lookup"><span data-stu-id="c5b20-124">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="c5b20-125">La plupart des API dans les bibliothèques .NET qui créent une ressource non managée l’encapsulent dans un `SafeHandle` et le renvoient en `SafeHandle` fonction des besoins, plutôt que de transmettre le pointeur brut.</span><span class="sxs-lookup"><span data-stu-id="c5b20-125">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="c5b20-126">Dans les situations où vous interagissez avec un composant non managé et récupérez un `IntPtr` pour une ressource non managée, vous pouvez créer votre propre `SafeHandle` type pour l’encapsuler.</span><span class="sxs-lookup"><span data-stu-id="c5b20-126">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="c5b20-127">Par conséquent, peu de types n' `SafeHandle` ont pas besoin d’implémenter des finaliseurs ; la plupart des implémentations de modèle jetables finissent par encapsuler d’autres ressources managées, dont certaines peuvent être des `SafeHandle` s.</span><span class="sxs-lookup"><span data-stu-id="c5b20-127">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="c5b20-128">Les classes dérivées suivantes de l'espace de noms <xref:Microsoft.Win32.SafeHandles> fournissent des handles sécurisés :</span><span class="sxs-lookup"><span data-stu-id="c5b20-128">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="c5b20-129">La classe <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> et <xref:Microsoft.Win32.SafeHandles.SafePipeHandle>, pour les fichiers, les fichiers mappés en mémoire et les canaux.</span><span class="sxs-lookup"><span data-stu-id="c5b20-129">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="c5b20-130">La classe <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>, pour les vues de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="c5b20-130">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="c5b20-131">Les classes <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> et <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> pour les constructions de chiffrement.</span><span class="sxs-lookup"><span data-stu-id="c5b20-131">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="c5b20-132">La classe <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> pour les clés de Registre.</span><span class="sxs-lookup"><span data-stu-id="c5b20-132">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="c5b20-133">La classe <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>, pour les handles d'attente.</span><span class="sxs-lookup"><span data-stu-id="c5b20-133">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="c5b20-134">Dispose () et dispose (bool)</span><span class="sxs-lookup"><span data-stu-id="c5b20-134">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="c5b20-135">L'interface <xref:System.IDisposable> requiert l'implémentation d'une méthode unique sans paramètre, <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="c5b20-135">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="c5b20-136">En outre, toute classe non scellée doit avoir une `Dispose(bool)` méthode de surcharge supplémentaire à implémenter :</span><span class="sxs-lookup"><span data-stu-id="c5b20-136">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="c5b20-137">`public`Implémentation non virtuelle ( `NonInheritable` en Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> qui n’a aucun paramètre.</span><span class="sxs-lookup"><span data-stu-id="c5b20-137">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="c5b20-138">`protected virtual`Méthode ( `Overridable` en Visual Basic) `Dispose` dont la signature est :</span><span class="sxs-lookup"><span data-stu-id="c5b20-138">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="c5b20-139">Le `disposing` paramètre doit être `false` lorsqu’il est appelé à partir d’un finaliseur, et lorsqu’il est `true` appelé à partir de la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> méthode.</span><span class="sxs-lookup"><span data-stu-id="c5b20-139">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c5b20-140">En d’autres termes, il est quand il est appelé de façon `true` déterministe et lorsqu’il n’est `false` pas appelé de manière déterministe.</span><span class="sxs-lookup"><span data-stu-id="c5b20-140">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="c5b20-141">La méthode Dispose ()</span><span class="sxs-lookup"><span data-stu-id="c5b20-141">The Dispose() method</span></span>

<span data-ttu-id="c5b20-142">Étant donné que le `public` , non virtuel ( `NonInheritable` en Visual Basic), la `Dispose` méthode sans paramètre est appelée par un consommateur du type, son objectif est de libérer des ressources non managées, d’effectuer un nettoyage général et d’indiquer que le finaliseur, s’il en existe un, ne doit pas s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="c5b20-142">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="c5b20-143">La libération de la mémoire réelle associée à un objet géré est toujours le domaine du [garbage collector](index.md).</span><span class="sxs-lookup"><span data-stu-id="c5b20-143">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="c5b20-144">De ce fait, son implémentation standard est la suivante :</span><span class="sxs-lookup"><span data-stu-id="c5b20-144">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="c5b20-145">La méthode `Dispose` effectue le nettoyage de tous les objets, le récupérateur de mémoire n'a plus donc besoin d'appeler la remplacement de <xref:System.Object.Finalize%2A?displayProperty=nameWithType> des objets.</span><span class="sxs-lookup"><span data-stu-id="c5b20-145">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="c5b20-146">Par conséquent, l'appel à la méthode <xref:System.GC.SuppressFinalize%2A> empêche le récupérateur de mémoire d'exécuter le finaliseur.</span><span class="sxs-lookup"><span data-stu-id="c5b20-146">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="c5b20-147">Si le type n'a pas de finaliseur, l'appel à <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> n'a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="c5b20-147">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="c5b20-148">Notez que le nettoyage réel est effectué par la `Dispose(bool)` surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="c5b20-148">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="c5b20-149">Surcharge de la méthode Dispose (bool)</span><span class="sxs-lookup"><span data-stu-id="c5b20-149">The Dispose(bool) method overload</span></span>

<span data-ttu-id="c5b20-150">Dans la surcharge, le `disposing` paramètre est un <xref:System.Boolean> qui indique si l’appel de méthode provient d’une <xref:System.IDisposable.Dispose%2A> méthode (sa valeur est `true` ) ou d’un finaliseur (sa valeur est `false` ).</span><span class="sxs-lookup"><span data-stu-id="c5b20-150">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="c5b20-151">Le corps de la méthode se compose de deux blocs de code :</span><span class="sxs-lookup"><span data-stu-id="c5b20-151">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="c5b20-152">Un bloc qui libère les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="c5b20-152">A block that frees unmanaged resources.</span></span> <span data-ttu-id="c5b20-153">Ce bloc s'exécute indépendamment de la valeur du paramètre `disposing`.</span><span class="sxs-lookup"><span data-stu-id="c5b20-153">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="c5b20-154">Un bloc conditionnel qui libère les ressources managées.</span><span class="sxs-lookup"><span data-stu-id="c5b20-154">A conditional block that frees managed resources.</span></span> <span data-ttu-id="c5b20-155">Ce bloc s'exécute si la valeur de `disposing` est `true`.</span><span class="sxs-lookup"><span data-stu-id="c5b20-155">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="c5b20-156">Les ressources managées qu'il libère peuvent inclure :</span><span class="sxs-lookup"><span data-stu-id="c5b20-156">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="c5b20-157">**Objets managés qui implémentent <xref:System.IDisposable>.**</span><span class="sxs-lookup"><span data-stu-id="c5b20-157">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="c5b20-158">Le bloc conditionnel peut être utilisé pour appeler leur <xref:System.IDisposable.Dispose%2A> implémentation (dispose en cascade).</span><span class="sxs-lookup"><span data-stu-id="c5b20-158">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="c5b20-159">Si vous avez utilisé une classe dérivée de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> pour encapsuler votre ressource non managée, vous devez appeler l' <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implémentation ici.</span><span class="sxs-lookup"><span data-stu-id="c5b20-159">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="c5b20-160">**Objets managés qui consomment de grandes quantités de mémoire ou consomment des ressources rares.**</span><span class="sxs-lookup"><span data-stu-id="c5b20-160">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="c5b20-161">Affectez des références d’objets managés volumineux à `null` pour les rendre plus susceptibles d’être inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="c5b20-161">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="c5b20-162">Cela les libère plus rapidement que s’ils étaient récupérés de façon non déterministe, ce qui est généralement effectué en dehors du bloc conditionnel.</span><span class="sxs-lookup"><span data-stu-id="c5b20-162">This releases them faster than if they were reclaimed non-deterministically, and this is usually done outside of the conditional block.</span></span>

<span data-ttu-id="c5b20-163">Si l’appel de méthode provient d’un finaliseur, seul le code qui libère les ressources non managées doit s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="c5b20-163">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="c5b20-164">L’implémenteur est chargé de s’assurer que le chemin d’accès faux n’interagit pas avec les objets managés qui ont pu être récupérés.</span><span class="sxs-lookup"><span data-stu-id="c5b20-164">The implementer is responsible for ensuring that the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="c5b20-165">Cela est important, car l’ordre dans lequel le garbage collector détruit les objets managés pendant la finalisation n’est pas déterministe.</span><span class="sxs-lookup"><span data-stu-id="c5b20-165">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="c5b20-166">Appels de suppression en cascade</span><span class="sxs-lookup"><span data-stu-id="c5b20-166">Cascade dispose calls</span></span>

<span data-ttu-id="c5b20-167">Si votre classe possède un champ ou une propriété et que son type implémente <xref:System.IDisposable> , la classe conteneur elle-même doit également implémenter <xref:System.IDisposable> .</span><span class="sxs-lookup"><span data-stu-id="c5b20-167">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="c5b20-168">Une classe qui instancie une <xref:System.IDisposable> implémentation et la stocke en tant que membre d’instance est également responsable de son nettoyage.</span><span class="sxs-lookup"><span data-stu-id="c5b20-168">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="c5b20-169">Cela permet de s’assurer que les types jetables référencés ont la possibilité de procéder à un nettoyage déterministe à l’aide de la <xref:System.IDisposable.Dispose%2A> méthode.</span><span class="sxs-lookup"><span data-stu-id="c5b20-169">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="c5b20-170">Dans cet exemple, la classe est `sealed` (ou `NotInheritable` dans Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="c5b20-170">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="c5b20-171">Implémenter le modèle de suppression</span><span class="sxs-lookup"><span data-stu-id="c5b20-171">Implement the dispose pattern</span></span>

<span data-ttu-id="c5b20-172">Toutes les classes non-sealed ou (classes Visual Basic non modifiées comme `NotInheritable` ) doivent être considérées comme une classe de base potentielle, car elles peuvent être héritées.</span><span class="sxs-lookup"><span data-stu-id="c5b20-172">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="c5b20-173">Si vous implémentez le modèle de suppression pour une classe de base potentielle quelconque, vous devez fournir les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="c5b20-173">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="c5b20-174">Une implémentation de <xref:System.IDisposable.Dispose%2A> qui appelle la méthode `Dispose(bool)`.</span><span class="sxs-lookup"><span data-stu-id="c5b20-174">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="c5b20-175">`Dispose(bool)`Méthode qui effectue le nettoyage réel.</span><span class="sxs-lookup"><span data-stu-id="c5b20-175">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="c5b20-176">Une classe dérivée de <xref:System.Runtime.InteropServices.SafeHandle> qui encapsule votre ressource managée (recommandée) ou une substitution de la méthode <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c5b20-176">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c5b20-177">La <xref:System.Runtime.InteropServices.SafeHandle> classe fournit un finaliseur, donc vous n’avez pas besoin d’en écrire un vous-même.</span><span class="sxs-lookup"><span data-stu-id="c5b20-177">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c5b20-178">Une classe de base peut uniquement référencer des objets managés et implémenter le modèle de suppression.</span><span class="sxs-lookup"><span data-stu-id="c5b20-178">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="c5b20-179">Dans ce cas, un finaliseur n’est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c5b20-179">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="c5b20-180">Un finaliseur est requis uniquement si vous référencez directement des ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="c5b20-180">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="c5b20-181">Voici le modèle général d’implémentation du modèle de suppression d’une classe de base qui utilise un handle sécurisé.</span><span class="sxs-lookup"><span data-stu-id="c5b20-181">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="c5b20-182">L'exemple précédent utilise un objet <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> pour illustrer le modèle, mais il est possible d'utiliser à la place n'importe quel objet dérivé de <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="c5b20-182">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="c5b20-183">Notez que l'exemple n'instancie pas correctement son objet <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="c5b20-183">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="c5b20-184">Voici le modèle général d’implémentation du modèle de suppression d’une classe de base qui remplace <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c5b20-184">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="c5b20-185">En C#, vous créez un [finaliseur](../../csharp/programming-guide/classes-and-structs/destructors.md) en substituant <xref:System.Object.Finalize%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c5b20-185">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c5b20-186">Dans Visual Basic, cette opération s’effectue à l’aide de `Protected Overrides Sub Finalize()` .</span><span class="sxs-lookup"><span data-stu-id="c5b20-186">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="c5b20-187">Implémenter le modèle de suppression d’une classe dérivée</span><span class="sxs-lookup"><span data-stu-id="c5b20-187">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="c5b20-188">Une classe dérivée d'une classe qui implémente l'interface <xref:System.IDisposable> ne doit pas implémenter <xref:System.IDisposable>, car l'implémentation de la classe de base de <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> est héritée par les classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="c5b20-188">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="c5b20-189">Au lieu de cela, pour nettoyer une classe dérivée, vous devez fournir les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="c5b20-189">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="c5b20-190">`protected override void Dispose(bool)`Méthode qui remplace la méthode de la classe de base et effectue le nettoyage réel de la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="c5b20-190">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="c5b20-191">Cette méthode doit également appeler la `base.Dispose(bool)` `MyBase.Dispose(bool)` méthode (en Visual Basic) de la classe de base et passer son état de suppression pour l’argument.</span><span class="sxs-lookup"><span data-stu-id="c5b20-191">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="c5b20-192">Une classe dérivée de <xref:System.Runtime.InteropServices.SafeHandle> qui encapsule votre ressource managée (recommandée) ou une substitution de la méthode <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c5b20-192">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c5b20-193">La classe <xref:System.Runtime.InteropServices.SafeHandle> fournit un finaliseur qui vous permet de ne pas avoir à en coder un.</span><span class="sxs-lookup"><span data-stu-id="c5b20-193">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="c5b20-194">Si vous fournissez un finaliseur, il doit appeler la `Dispose(bool)` surcharge avec un `disposing` argument de `false` .</span><span class="sxs-lookup"><span data-stu-id="c5b20-194">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="c5b20-195">Voici le modèle général d’implémentation du modèle de suppression d’une classe dérivée qui utilise un handle sécurisé :</span><span class="sxs-lookup"><span data-stu-id="c5b20-195">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="c5b20-196">L'exemple précédent utilise un objet <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> pour illustrer le modèle, mais il est possible d'utiliser à la place n'importe quel objet dérivé de <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="c5b20-196">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="c5b20-197">Notez que l'exemple n'instancie pas correctement son objet <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="c5b20-197">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="c5b20-198">Voici le modèle général d'implémentation du modèle de suppression d'une classe dérivée qui remplace <xref:System.Object.Finalize%2A?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="c5b20-198">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="c5b20-199">Implémenter le modèle de suppression avec des Handles sécurisés</span><span class="sxs-lookup"><span data-stu-id="c5b20-199">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="c5b20-200">L'exemple suivant illustre le modèle de suppression d'une classe de base, `DisposableStreamResource`, qui utilise un handle sécurisé pour encapsuler les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="c5b20-200">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="c5b20-201">Il définit une classe `DisposableStreamResource` qui utilise <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> pour encapsuler un objet <xref:System.IO.Stream> qui représente un fichier ouvert.</span><span class="sxs-lookup"><span data-stu-id="c5b20-201">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="c5b20-202">La classe comprend également une seule propriété, `Size` , qui retourne le nombre total d’octets dans le flux de fichier.</span><span class="sxs-lookup"><span data-stu-id="c5b20-202">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="c5b20-203">Implémenter le modèle de suppression d’une classe dérivée avec des Handles sécurisés</span><span class="sxs-lookup"><span data-stu-id="c5b20-203">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="c5b20-204">L'exemple suivant illustre le modèle de suppression d'une classe dérivée, `DisposableStreamResource2`, qui hérite de la classe `DisposableStreamResource` présentée dans l'exemple précédent.</span><span class="sxs-lookup"><span data-stu-id="c5b20-204">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="c5b20-205">La classe ajoute une méthode supplémentaire, `WriteFileInfo`, et utilise un objet <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> pour encapsuler le handle du fichier accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="c5b20-205">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="c5b20-206">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="c5b20-206">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="c5b20-207">Définir et utiliser des classes et des structs (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="c5b20-207">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
