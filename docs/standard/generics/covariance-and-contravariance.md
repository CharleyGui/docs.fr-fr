---
title: Covariance et contravariance dans les génériques
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
ms.openlocfilehash: b11b5fc93d9b7289e62d6abc9d3ca19027a107c5
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/02/2020
ms.locfileid: "84287556"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="c4051-102">Covariance et contravariance dans les génériques</span><span class="sxs-lookup"><span data-stu-id="c4051-102">Covariance and Contravariance in Generics</span></span>
<span data-ttu-id="c4051-103"> La covariance et la contravariance sont des termes qui font référence à la possibilité d’utiliser un type plus dérivé (plus spécifique) ou moins dérivé (moins spécifique) que celui spécifié à l’origine.</span><span class="sxs-lookup"><span data-stu-id="c4051-103">Covariance and contravariance are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="c4051-104">Les paramètres de type générique prennent en charge la covariance et la contravariance afin de fournir une meilleure flexibilité dans l'assignation et l'utilisation des types génériques.</span><span class="sxs-lookup"><span data-stu-id="c4051-104">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span> <span data-ttu-id="c4051-105">Lorsque vous faites référence à un système de type, la covariance, la contravariance et l'invariance ont les définitions suivantes.</span><span class="sxs-lookup"><span data-stu-id="c4051-105">When you are referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="c4051-106">Les exemples supposent qu'une classe de base est nommée `Base` et qu'une classe dérivée est nommée `Derived`.</span><span class="sxs-lookup"><span data-stu-id="c4051-106">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="c4051-107">Vous permet d'utiliser un type plus dérivé que celui spécifié à l'origine.</span><span class="sxs-lookup"><span data-stu-id="c4051-107">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="c4051-108">Vous pouvez assigner une instance de `IEnumerable<Derived>` (`IEnumerable(Of Derived)` en Visual Basic) à une variable de type `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="c4051-108">You can assign an instance of `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="c4051-109">Vous permet d'utiliser un type plus générique (moins dérivé) que celui spécifié à l'origine.</span><span class="sxs-lookup"><span data-stu-id="c4051-109">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="c4051-110">Vous pouvez assigner une instance de `Action<Base>` (`Action(Of Base)` en Visual Basic) à une variable de type `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="c4051-110">You can assign an instance of `Action<Base>` (`Action(Of Base)` in Visual Basic) to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="c4051-111">Signifie que vous pouvez utiliser uniquement le type spécifié à l'origine ; pour un paramètre de type générique indifférent, il n'est ni covariant ni contravariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-111">Means that you can use only the type originally specified; so an invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="c4051-112">Vous ne pouvez pas attribuer une instance de `List<Base>` (`List(Of Base)` en Visual Basic) à une variable de type `List<Derived>` et inversement.</span><span class="sxs-lookup"><span data-stu-id="c4051-112">You cannot assign an instance of `List<Base>` (`List(Of Base)` in Visual Basic) to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="c4051-113">Les paramètres de type covariant vous permettent d'effectuer des assignations très similaires au [Polymorphisme](../../csharp/programming-guide/classes-and-structs/polymorphism.md) ordinaire, comme indiqué dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="c4051-113">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](../../csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="c4051-114">La classe <xref:System.Collections.Generic.List%601> implémente l'interface générique <xref:System.Collections.Generic.IEnumerable%601> , donc `List<Derived>` (`List(Of Derived)` en Visual Basic) implémente `IEnumerable<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="c4051-114">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="c4051-115">Le paramètre de type covariant fait le reste.</span><span class="sxs-lookup"><span data-stu-id="c4051-115">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="c4051-116">La contravariance, en revanche, paraît peu intuitive.</span><span class="sxs-lookup"><span data-stu-id="c4051-116">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="c4051-117">L'exemple suivant crée un délégué de type `Action<Base>` (`Action(Of Base)` en Visual Basic), puis assigne ce délégué à une variable de type `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="c4051-117">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="c4051-118">Cela peut paraître rétrograde, mais c'est le code de type sécurisé qui est compilé et exécuté.</span><span class="sxs-lookup"><span data-stu-id="c4051-118">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="c4051-119">L'expression lambda correspond au délégué auquel elle est assignée, elle définit donc une méthode qui prend un paramètre de type `Base` et n'a aucune valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="c4051-119">The lambda expression matches the delegate it is assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="c4051-120">Le délégué résultant peut être assigné à une variable de type `Action<Derived>` parce que le paramètre de type `T` du délégué <xref:System.Action%601> est contravariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-120">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="c4051-121">Le code est de type sécurisé parce que `T` spécifie un type de paramètre.</span><span class="sxs-lookup"><span data-stu-id="c4051-121">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="c4051-122">Lorsque le délégué de type `Action<Base>` est appelé comme s'il était de type `Action<Derived>`, son argument doit être de type `Derived`.</span><span class="sxs-lookup"><span data-stu-id="c4051-122">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="c4051-123">Cet argument peut toujours être passé sans risque à la méthode sous-jacente, parce que le paramètre de la méthode est de type `Base`.</span><span class="sxs-lookup"><span data-stu-id="c4051-123">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="c4051-124">En général, un paramètre de type covariant peut être utilisé comme type de retour d'un délégué et les paramètres de type contravariant peuvent être utilisés comme types de paramètres.</span><span class="sxs-lookup"><span data-stu-id="c4051-124">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="c4051-125">Pour une interface, les paramètres de type covariant peuvent être utilisés comme types de retour des méthodes de l'interface et les paramètres de type contravariant peuvent être utilisés comme types de paramètres des méthodes de l'interface.</span><span class="sxs-lookup"><span data-stu-id="c4051-125">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="c4051-126">La covariance et la contravariance sont désignées collectivement sous le nom de *variation*.</span><span class="sxs-lookup"><span data-stu-id="c4051-126">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="c4051-127">Un paramètre de type générique qui n'est marqué ni comme étant covariant, ni comme étant contravariant, est appelé *indifférent*.</span><span class="sxs-lookup"><span data-stu-id="c4051-127">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="c4051-128">Récapitulatif des informations relatives à la variance dans le common language runtime :</span><span class="sxs-lookup"><span data-stu-id="c4051-128">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="c4051-129">Dans .NET Framework 4, les paramètres de type variant sont limités aux types d’interfaces génériques et aux types délégués génériques.</span><span class="sxs-lookup"><span data-stu-id="c4051-129">In the .NET Framework 4, variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="c4051-130">Un type d'interface générique ou un type délégué générique peut avoir des paramètres de type covariant et contravariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-130">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="c4051-131">La variance s'applique uniquement aux types référence ; si vous spécifiez un type valeur pour un paramètre de type variant, ce paramètre de type est indifférent pour le type construit résultant.</span><span class="sxs-lookup"><span data-stu-id="c4051-131">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="c4051-132">La variance ne s'applique pas à la combinaison de délégués.</span><span class="sxs-lookup"><span data-stu-id="c4051-132">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="c4051-133">Autrement dit, avec deux délégués de types `Action<Derived>` et `Action<Base>` (`Action(Of Derived)` et `Action(Of Base)` en Visual Basic), il n'est pas possible de combiner le deuxième délégué avec le premier, même si le résultat sera de type sécurisé.</span><span class="sxs-lookup"><span data-stu-id="c4051-133">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="c4051-134">La variance permet au deuxième délégué d'être assigné à une variable de type `Action<Derived>`, mais les délégués peuvent uniquement être combinés si leurs types correspondent exactement.</span><span class="sxs-lookup"><span data-stu-id="c4051-134">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>

<a name="InterfaceCovariantTypeParameters"></a>
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="c4051-135">Interfaces génériques avec paramètres de type covariant</span><span class="sxs-lookup"><span data-stu-id="c4051-135">Generic Interfaces with Covariant Type Parameters</span></span>  
 <span data-ttu-id="c4051-136">À compter de .NET Framework 4, plusieurs interfaces génériques ont des paramètres de type covariant, par exemple <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601> et <xref:System.Linq.IGrouping%602>.</span><span class="sxs-lookup"><span data-stu-id="c4051-136">Starting with the .NET Framework 4, several generic interfaces have covariant type parameters; for example: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="c4051-137">Tous les paramètres de type de ces interfaces sont covariants, les paramètres de type sont donc uniquement utilisés pour les types de retour des membres.</span><span class="sxs-lookup"><span data-stu-id="c4051-137">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="c4051-138">L'exemple suivant illustre les paramètres de type covariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-138">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="c4051-139">L'exemple définit deux types : `Base` a une méthode statique nommée `PrintBases` qui prend un `IEnumerable<Base>` (`IEnumerable(Of Base)` en Visual Basic) et imprime les éléments.</span><span class="sxs-lookup"><span data-stu-id="c4051-139">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="c4051-140">`Derived` hérite de `Base`.</span><span class="sxs-lookup"><span data-stu-id="c4051-140">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="c4051-141">L'exemple crée un `List<Derived>` vide (`List(Of Derived)` en Visual Basic) et montre que ce type peut être passé à `PrintBases` et assigné à une variable de type `IEnumerable<Base>` sans cast.</span><span class="sxs-lookup"><span data-stu-id="c4051-141">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="c4051-142"><xref:System.Collections.Generic.List%601> implémente <xref:System.Collections.Generic.IEnumerable%601>, qui a un paramètre de type covariant unique.</span><span class="sxs-lookup"><span data-stu-id="c4051-142"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="c4051-143">Le paramètre de type covariant est la raison pour laquelle une instance de `IEnumerable<Derived>` peut être utilisée au lieu de `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="c4051-143">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
## <a name="generic-interfaces-with-contravariant-generic-type-parameters"></a><span data-ttu-id="c4051-144">Interfaces génériques avec paramètres de type générique contravariant</span><span class="sxs-lookup"><span data-stu-id="c4051-144">Generic Interfaces with Contravariant Generic Type Parameters</span></span>  
 <span data-ttu-id="c4051-145">À compter de .NET Framework 4, plusieurs interfaces génériques ont des paramètres de type contravariant, par exemple <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601> et <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="c4051-145">Starting with the .NET Framework 4, several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="c4051-146">Ces interfaces ont des paramètres de type contravariant uniquement, par conséquent, les paramètres de type sont utilisés uniquement comme types de paramètre dans les membres des interfaces.</span><span class="sxs-lookup"><span data-stu-id="c4051-146">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="c4051-147">L'exemple suivant illustre les paramètres de type contravariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-147">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="c4051-148">L'exemple définit une classe abstraite (`MustInherit` dans Visual Basic) `Shape` avec une propriété `Area` .</span><span class="sxs-lookup"><span data-stu-id="c4051-148">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="c4051-149">L'exemple définit également une classe `ShapeAreaComparer` qui implémente `IComparer<Shape>` (`IComparer(Of Shape)` dans Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="c4051-149">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="c4051-150">L'implémentation de la méthode <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> est basée sur la valeur de la propriété `Area` , de sorte que `ShapeAreaComparer` peut être utilisé pour trier des objets `Shape` par zone.</span><span class="sxs-lookup"><span data-stu-id="c4051-150">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="c4051-151">La classe `Circle` hérite de `Shape` et remplace `Area`.</span><span class="sxs-lookup"><span data-stu-id="c4051-151">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="c4051-152">L'exemple crée un <xref:System.Collections.Generic.SortedSet%601> d'objets `Circle` , à l'aide d'un constructeur qui accepte un `IComparer<Circle>` (`IComparer(Of Circle)` dans Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="c4051-152">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="c4051-153">Toutefois, au lieu de passer un `IComparer<Circle>`, l'exemple passe un objet `ShapeAreaComparer` qui implémente `IComparer<Shape>`.</span><span class="sxs-lookup"><span data-stu-id="c4051-153">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="c4051-154">L'exemple peut passer un comparateur d'un type moins dérivé (`Shape`) lorsque le code appelle un comparateur d'un type plus dérivé (`Circle`), parce que le paramètre de type de l'interface générique <xref:System.Collections.Generic.IComparer%601> est contravariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-154">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="c4051-155">Lorsqu'un nouvel objet `Circle` est ajouté au `SortedSet<Circle>`, la méthode `IComparer<Shape>.Compare` (méthode `IComparer(Of Shape).Compare` dans Visual Basic) de l'objet `ShapeAreaComparer` est appelée chaque fois que le nouvel élément est comparé à un élément existant.</span><span class="sxs-lookup"><span data-stu-id="c4051-155">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="c4051-156">Le type de paramètre de la méthode (`Shape`) étant moins dérivé que le type passé (`Circle`), l'appel garantit la cohérence des types.</span><span class="sxs-lookup"><span data-stu-id="c4051-156">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="c4051-157">La contravariance permet à `ShapeAreaComparer` de trier une collection d'un type unique, ainsi qu'une collection mixte de types, qui dérivent de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="c4051-157">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  

## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="c4051-158">Délégués génériques avec paramètres de type variant</span><span class="sxs-lookup"><span data-stu-id="c4051-158">Generic Delegates with Variant Type Parameters</span></span>  
 <span data-ttu-id="c4051-159">Dans .NET Framework 4, les délégués génériques `Func`, tels que <xref:System.Func%602>, ont des types de retours covariants et des types de paramètres contravariants.</span><span class="sxs-lookup"><span data-stu-id="c4051-159">In the .NET Framework 4, the `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="c4051-160">Les délégués génériques `Action` , tels que <xref:System.Action%602>, ont des types de paramètres contravariants.</span><span class="sxs-lookup"><span data-stu-id="c4051-160">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="c4051-161">Cela signifie que les délégués peuvent être assignés à des variables avec des types de paramètres plus dérivés et (dans le cas des délégués génériques `Func` ) des types de retour moins dérivés.</span><span class="sxs-lookup"><span data-stu-id="c4051-161">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c4051-162">Le dernier paramètre de type générique des délégués génériques `Func` spécifie le type de la valeur de retour dans la signature du délégué.</span><span class="sxs-lookup"><span data-stu-id="c4051-162">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="c4051-163">Il est covariant (mot clé`out` ), alors que les autres paramètres de type générique sont contravariants (mot clé`in` ).</span><span class="sxs-lookup"><span data-stu-id="c4051-163">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="c4051-164">Le code suivant illustre ce comportement :</span><span class="sxs-lookup"><span data-stu-id="c4051-164">The following code illustrates this.</span></span> <span data-ttu-id="c4051-165">La première partie du code définit une classe nommée `Base`, une classe nommée `Derived` qui hérite de `Base`, et une autre classe avec une méthode `static` (`Shared` en Visual Basic) nommée `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="c4051-165">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="c4051-166">La méthode prend une instance de `Base` et retourne une instance de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="c4051-166">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="c4051-167">(Si l’argument est une instance de `Derived` , le `MyMethod` retourne ; si l’argument est une instance de `Base` , `MyMethod` retourne une nouvelle instance de `Derived` .) Dans `Main()` , l’exemple crée une instance de `Func<Base, Derived>` ( `Func(Of Base, Derived)` dans Visual Basic) qui représente `MyMethod` et le stocke dans la variable `f1` .</span><span class="sxs-lookup"><span data-stu-id="c4051-167">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="c4051-168">La deuxième partie du code indique que le délégué peut être assigné à une variable de type `Func<Base, Base>` (`Func(Of Base, Base)` en Visual Basic), car le type de retour est covariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-168">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="c4051-169">La troisième partie du code indique que le délégué peut être assigné à une variable de type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` en Visual Basic), car le type de paramètre est contravariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-169">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="c4051-170">La dernière partie du code indique que le délégué peut être assigné à une variable de type `Func<Derived, Base>` (`Func(Of Derived, Base)` en Visual Basic), ce qui combine les effets du type de paramètre contravariant et du type de valeur de retour covariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-170">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-generic-and-non-generic-delegates"></a><span data-ttu-id="c4051-171">Variance dans les délégués génériques et non génériques</span><span class="sxs-lookup"><span data-stu-id="c4051-171">Variance in Generic and Non-Generic Delegates</span></span>  
 <span data-ttu-id="c4051-172">Dans le code précédent, la signature de `MyMethod` correspond exactement à la signature du délégué générique construit : `Func<Base, Derived>` (`Func(Of Base, Derived)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="c4051-172">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="c4051-173">L'exemple montre que ce délégué générique peut être stocké dans des variables ou des paramètres de méthode qui ont des types de paramètres plus dérivés et des types de retour moins dérivés, tant que tous les types délégués sont construits à partir du type délégué générique <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="c4051-173">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="c4051-174">Ceci est un point important.</span><span class="sxs-lookup"><span data-stu-id="c4051-174">This is an important point.</span></span> <span data-ttu-id="c4051-175">Les effets de la covariance et de la contravariance dans les paramètres de type des délégués génériques sont semblables aux effets de la covariance et de la contravariance dans la liaison de délégués ordinaire (consultez [Variance dans les délégués (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) et [Variance dans les délégués (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="c4051-175">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="c4051-176">Toutefois, la variance dans la liaison de délégués fonctionne avec tous les types délégués, et pas seulement les types délégués génériques qui ont des paramètres de type variant.</span><span class="sxs-lookup"><span data-stu-id="c4051-176">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="c4051-177">En outre, la variance dans la liaison de délégués permet de lier une méthode à tout délégué disposant de types de paramètres plus restrictifs et d'un type de retour moins restrictif, alors que l'assignation de délégués génériques fonctionne uniquement si les deux types délégués sont construits à partir de la même définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="c4051-177">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="c4051-178">L'exemple suivant indique les effets combinés de la variance dans la liaison de délégués et de la variance dans les paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="c4051-178">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="c4051-179">L'exemple définit une hiérarchie de type qui inclut trois types, du moins dérivé (`Type1`) au plus dérivé (`Type3`).</span><span class="sxs-lookup"><span data-stu-id="c4051-179">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="c4051-180">La variance dans la liaison de délégués ordinaire est utilisée pour lier une méthode avec le type de paramètre `Type1` et le type de retour `Type3` à un délégué générique avec le type de paramètre `Type2` et le type de retour `Type2`.</span><span class="sxs-lookup"><span data-stu-id="c4051-180">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="c4051-181">Le délégué générique résultant est ensuite assigné à une autre variable dont le type délégué générique a un paramètre de type `Type3` et le type de retour `Type1`, à l'aide de la covariance et de la contravariance de paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="c4051-181">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="c4051-182">La deuxième assignation requiert que le type de variable et le type délégué soient construits à partir de la même définition de type générique, dans ce cas, <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="c4051-182">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  

## <a name="defining-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="c4051-183">Définition d'interfaces et de délégués génériques variants</span><span class="sxs-lookup"><span data-stu-id="c4051-183">Defining Variant Generic Interfaces and Delegates</span></span>
 <span data-ttu-id="c4051-184">À compter de .NET Framework 4, Visual Basic et Visual C# ont des mots clés qui vous permettent de marquer les paramètres de type générique des interfaces et des délégués comme covariants ou contravariants.</span><span class="sxs-lookup"><span data-stu-id="c4051-184">Starting with the .NET Framework 4, Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c4051-185">Depuis le .NET Framework version 2.0, le Common Language Runtime prend en charge les annotations de variance sur les paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="c4051-185">Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters.</span></span> <span data-ttu-id="c4051-186">Avant .NET Framework 4, la seule méthode pour définir une classe générique avec ces annotations consistait à utiliser le langage MSIL (Microsoft Intermediate Language), en compilant la classe avec [Ilasm.exe (Assembleur IL)](../../framework/tools/ilasm-exe-il-assembler.md) ou en l’émettant dans un assembly dynamique.</span><span class="sxs-lookup"><span data-stu-id="c4051-186">Prior to the .NET Framework 4, the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly.</span></span>  
  
 <span data-ttu-id="c4051-187">Un paramètre de type covariant est marqué avec le mot clé `out` (mot clé `Out` en Visual Basic, `+` pour [l’assembleur MSIL](../../framework/tools/ilasm-exe-il-assembler.md)).</span><span class="sxs-lookup"><span data-stu-id="c4051-187">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic, `+` for the [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="c4051-188">Vous pouvez utiliser un paramètre de type covariant comme valeur de retour d'une méthode qui appartient à une interface ou comme type de retour d'un délégué.</span><span class="sxs-lookup"><span data-stu-id="c4051-188">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="c4051-189">Vous ne pouvez pas utiliser un paramètre de type covariant comme contrainte de type générique pour les méthodes d'interface.</span><span class="sxs-lookup"><span data-stu-id="c4051-189">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c4051-190">Si une méthode d'une interface a un paramètre qui est un type délégué générique, un paramètre de type covariant du type d'interface peut être utilisé pour spécifier un paramètre de type contravariant du type délégué.</span><span class="sxs-lookup"><span data-stu-id="c4051-190">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="c4051-191">Un paramètre de type contravariant est marqué avec le mot clé `in` (mot clé`In` en Visual Basic, `-` pour l' [assembleur MSIL](../../framework/tools/ilasm-exe-il-assembler.md)).</span><span class="sxs-lookup"><span data-stu-id="c4051-191">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic, `-` for the [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="c4051-192">Vous pouvez utiliser un paramètre de type contravariant comme type d'un paramètre d'une méthode qui appartient à une interface ou comme type d'un paramètre d'un délégué.</span><span class="sxs-lookup"><span data-stu-id="c4051-192">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="c4051-193">Vous pouvez utiliser un paramètre de type contravariant comme contrainte de type générique pour une méthode d'interface.</span><span class="sxs-lookup"><span data-stu-id="c4051-193">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="c4051-194">Seuls les types d'interfaces et les types délégués peuvent avoir des paramètres de type variant.</span><span class="sxs-lookup"><span data-stu-id="c4051-194">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="c4051-195">Un type d'interface ou un type délégué peut avoir à la fois des paramètres de type covariant et contravariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-195">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="c4051-196">Visual Basic et Visual C# ne vous permettent pas de violer les règles d'utilisation des paramètres de type covariant et contravariant ou d'ajouter des annotations de covariance et de contravariance aux paramètres qui diffèrent des types d'interfaces et des types délégués.</span><span class="sxs-lookup"><span data-stu-id="c4051-196">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span> <span data-ttu-id="c4051-197">L' [assembleur MSIL](../../framework/tools/ilasm-exe-il-assembler.md) n'exécute pas ce type de contrôle, mais une exception <xref:System.TypeLoadException> est levée si vous essayez de charger un type qui viole les règles.</span><span class="sxs-lookup"><span data-stu-id="c4051-197">The [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md) does not perform such checks, but a <xref:System.TypeLoadException> is thrown if you try to load a type that violates the rules.</span></span>  
  
 <span data-ttu-id="c4051-198">Pour obtenir des informations et un exemple de code, consultez [Variance dans les interfaces génériques (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) et [Variance dans les interfaces génériques (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="c4051-198">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  

## <a name="list-of-variant-generic-interface-and-delegate-types"></a><span data-ttu-id="c4051-199">Liste des types d'interfaces et des types délégués génériques variants</span><span class="sxs-lookup"><span data-stu-id="c4051-199">List of Variant Generic Interface and Delegate Types</span></span>
 <span data-ttu-id="c4051-200">Dans .NET Framework 4, les types d’interfaces et les types délégués suivants ont des paramètres de type covariant et/ou contravariant.</span><span class="sxs-lookup"><span data-stu-id="c4051-200">In the .NET Framework 4, the following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="c4051-201">Type</span><span class="sxs-lookup"><span data-stu-id="c4051-201">Type</span></span>|<span data-ttu-id="c4051-202">Paramètres de type covariant</span><span class="sxs-lookup"><span data-stu-id="c4051-202">Covariant type parameters</span></span>|<span data-ttu-id="c4051-203">Paramètres de type contravariant</span><span class="sxs-lookup"><span data-stu-id="c4051-203">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="c4051-204">Il lance <xref:System.Action%601> sur <xref:System.Action%6016>.</span><span class="sxs-lookup"><span data-stu-id="c4051-204"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="c4051-205">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-205">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="c4051-206">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-206">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="c4051-207">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-207">Yes</span></span>|<span data-ttu-id="c4051-208">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-208">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="c4051-209">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-209">Yes</span></span>||  
|<span data-ttu-id="c4051-210">Il lance <xref:System.Func%602> sur <xref:System.Func%6017>.</span><span class="sxs-lookup"><span data-stu-id="c4051-210"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="c4051-211">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-211">Yes</span></span>|<span data-ttu-id="c4051-212">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-212">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="c4051-213">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-213">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="c4051-214">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-214">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="c4051-215">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-215">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="c4051-216">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-216">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="c4051-217">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-217">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="c4051-218">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-218">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="c4051-219">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-219">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="c4051-220">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-220">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="c4051-221">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-221">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="c4051-222">Oui</span><span class="sxs-lookup"><span data-stu-id="c4051-222">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="c4051-223">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="c4051-223">See also</span></span>

- [<span data-ttu-id="c4051-224">Covariance et contravariance (C#)</span><span class="sxs-lookup"><span data-stu-id="c4051-224">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="c4051-225">Covariance et contravariance (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="c4051-225">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="c4051-226">Variance dans les délégués (C#)</span><span class="sxs-lookup"><span data-stu-id="c4051-226">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="c4051-227">Variance dans les délégués (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="c4051-227">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
