---
title: Introduction à PLINQ
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, introduction to
ms.assetid: eaa720d8-8999-4eb7-8df5-3c19ca61cad0
ms.openlocfilehash: ed1b2df57c118a0ebb6b5ffa4326b3e2eac81dec
ms.sourcegitcommit: 7bc6887ab658550baa78f1520ea735838249345e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/03/2020
ms.locfileid: "75632361"
---
# <a name="introduction-to-plinq"></a><span data-ttu-id="b8808-102">Introduction à PLINQ</span><span class="sxs-lookup"><span data-stu-id="b8808-102">Introduction to PLINQ</span></span>

## <a name="what-is-a-parallel-query"></a><span data-ttu-id="b8808-103">Qu’est une requête parallèle ?</span><span class="sxs-lookup"><span data-stu-id="b8808-103">What is a Parallel Query?</span></span>

<span data-ttu-id="b8808-104">Language-Integrated Query (LINQ) a été introduit dans .NET Framework 3.5.</span><span class="sxs-lookup"><span data-stu-id="b8808-104">Language-Integrated Query (LINQ) was introduced in the .NET Framework 3.5.</span></span> <span data-ttu-id="b8808-105">Elle propose un modèle unifié pour interroger une source de données <xref:System.Collections.IEnumerable?displayProperty=nameWithType> ou <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> de manière sécurisée.</span><span class="sxs-lookup"><span data-stu-id="b8808-105">It features a unified model for querying any <xref:System.Collections.IEnumerable?displayProperty=nameWithType> or <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> data source in a type-safe manner.</span></span> <span data-ttu-id="b8808-106">LINQ to Objects est le nom des requêtes LINQ exécutées sur les collections en mémoire telles que <xref:System.Collections.Generic.List%601> et les tableaux.</span><span class="sxs-lookup"><span data-stu-id="b8808-106">LINQ to Objects is the name for LINQ queries that are run against in-memory collections such as <xref:System.Collections.Generic.List%601> and arrays.</span></span> <span data-ttu-id="b8808-107">Cet article suppose que vous avez une connaissance de base de LINQ.</span><span class="sxs-lookup"><span data-stu-id="b8808-107">This article assumes that you have a basic understanding of LINQ.</span></span> <span data-ttu-id="b8808-108">Pour plus d’informations, consultez [LINQ (Language Integrated Query) - C#](../../csharp/programming-guide/concepts/linq/index.md) ou [LINQ (Language Integrated Query) - Visual Basic](../../visual-basic/programming-guide/concepts/linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="b8808-108">For more information, see [Language-Integrated Query (LINQ) - C#](../../csharp/programming-guide/concepts/linq/index.md) or [Language-Integrated Query (LINQ) - Visual Basic](../../visual-basic/programming-guide/concepts/linq/index.md).</span></span>

<span data-ttu-id="b8808-109">Parallel LINQ (PLINQ) est une implémentation parallèle du modèle de requête LINQ.</span><span class="sxs-lookup"><span data-stu-id="b8808-109">Parallel LINQ (PLINQ) is a parallel implementation of the LINQ pattern.</span></span> <span data-ttu-id="b8808-110">Une requête PLINQ ressemble à bien des égards à une requête LINQ to Objects non parallèle.</span><span class="sxs-lookup"><span data-stu-id="b8808-110">A PLINQ query in many ways resembles a non-parallel LINQ to Objects query.</span></span> <span data-ttu-id="b8808-111">Les requêtes PLINQ, tout comme les requêtes LINQ séquentielles, fonctionnent sur tout <xref:System.Collections.IEnumerable> en mémoire ou <xref:System.Collections.Generic.IEnumerable%601> source de données, et ont une exécution différée, ce qui signifie qu’elles ne commencent pas à s’exécuter jusqu’à ce que la requête soit énumérée.</span><span class="sxs-lookup"><span data-stu-id="b8808-111">PLINQ queries, just like sequential LINQ queries, operate on any in-memory <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> data source, and have deferred execution, which means they do not begin executing until the query is enumerated.</span></span> <span data-ttu-id="b8808-112">La principale différence est que PLINQ essaie d’utiliser pleinement tous les processeurs sur le système.</span><span class="sxs-lookup"><span data-stu-id="b8808-112">The primary difference is that PLINQ attempts to make full use of all the processors on the system.</span></span> <span data-ttu-id="b8808-113">Cela s’effectue par le partitionnement de la source de données en segments et l’exécution de la requête sur chaque segment sur des threads de travail distincts en parallèle sur plusieurs processeurs.</span><span class="sxs-lookup"><span data-stu-id="b8808-113">It does this by partitioning the data source into segments, and then executing the query on each segment on separate worker threads in parallel on multiple processors.</span></span> <span data-ttu-id="b8808-114">Dans de nombreux cas, l’exécution parallèle signifie une exécution beaucoup plus rapide de la requête.</span><span class="sxs-lookup"><span data-stu-id="b8808-114">In many cases, parallel execution means that the query runs significantly faster.</span></span>

<span data-ttu-id="b8808-115">L’exécution parallèle permet à PLINQ d’améliorer de manière significative les performances du code hérité pour certains types de requêtes, souvent par le simple ajout de l’opération de requête <xref:System.Linq.ParallelEnumerable.AsParallel%2A> à la source de données.</span><span class="sxs-lookup"><span data-stu-id="b8808-115">Through parallel execution, PLINQ can achieve significant performance improvements over legacy code for certain kinds of queries, often just by adding the <xref:System.Linq.ParallelEnumerable.AsParallel%2A> query operation to the data source.</span></span> <span data-ttu-id="b8808-116">Toutefois, le parallélisme peut présenter ses propres complexités et toutes les opérations de requête ne s’exécutent pas plus rapidement dans PLINQ.</span><span class="sxs-lookup"><span data-stu-id="b8808-116">However, parallelism can introduce its own complexities, and not all query operations run faster in PLINQ.</span></span> <span data-ttu-id="b8808-117">En fait, la parallélisation ralentit réellement certaines requêtes.</span><span class="sxs-lookup"><span data-stu-id="b8808-117">In fact, parallelization actually slows down certain queries.</span></span> <span data-ttu-id="b8808-118">Par conséquent, vous devez comprendre comment des problèmes, tels que ceux liés à l’ordre, affectent les requêtes parallèles.</span><span class="sxs-lookup"><span data-stu-id="b8808-118">Therefore, you should understand how issues such as ordering affect parallel queries.</span></span> <span data-ttu-id="b8808-119">Pour plus d’informations, consultez [Fonctionnement de l’accélération dans PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="b8808-119">For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).</span></span>

> [!NOTE]
> <span data-ttu-id="b8808-120">Cette documentation utilise des expressions lambda pour définir les délégués en PLINQ.</span><span class="sxs-lookup"><span data-stu-id="b8808-120">This documentation uses lambda expressions to define delegates in PLINQ.</span></span> <span data-ttu-id="b8808-121">Si les expressions lambda en C# ou Visual Basic ne vous sont pas familières, consultez la page [Expressions lambda en PLINQ et dans la bibliothèque parallèle de tâches](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="b8808-121">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span></span>

<span data-ttu-id="b8808-122">Le reste de cet article donne une vue d’ensemble des principales classes PLINQ et explique comment créer des requêtes PLINQ.</span><span class="sxs-lookup"><span data-stu-id="b8808-122">The remainder of this article gives an overview of the main PLINQ classes, and discusses how to create PLINQ queries.</span></span> <span data-ttu-id="b8808-123">Chaque section contient des liens vers des exemples de code et des informations plus détaillées.</span><span class="sxs-lookup"><span data-stu-id="b8808-123">Each section contains links to more detailed information and code examples.</span></span>

## <a name="the-parallelenumerable-class"></a><span data-ttu-id="b8808-124">Classe ParallelEnumerable</span><span class="sxs-lookup"><span data-stu-id="b8808-124">The ParallelEnumerable Class</span></span>

<span data-ttu-id="b8808-125">La classe <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> expose presque toutes les fonctionnalités de PLINQ.</span><span class="sxs-lookup"><span data-stu-id="b8808-125">The <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> class exposes almost all of PLINQ's functionality.</span></span> <span data-ttu-id="b8808-126">Celle-ci et le reste des types d’espaces de noms <xref:System.Linq?displayProperty=nameWithType> sont compilés dans l’assembly System.Core.dll.</span><span class="sxs-lookup"><span data-stu-id="b8808-126">It and the rest of the <xref:System.Linq?displayProperty=nameWithType> namespace types are compiled into the System.Core.dll assembly.</span></span> <span data-ttu-id="b8808-127">Les projets C# et Visual Basic par défaut de Visual Studio font tous deux référence à l’assembly et importent l’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="b8808-127">The default C# and Visual Basic projects in Visual Studio both reference the assembly and import the namespace.</span></span>

<span data-ttu-id="b8808-128"><xref:System.Linq.ParallelEnumerable> inclut les implémentations de tous les opérateurs de requête standard pris en charge par LINQ to Objects, bien qu’il ne tente pas de paralléliser chacun d’eux.</span><span class="sxs-lookup"><span data-stu-id="b8808-128"><xref:System.Linq.ParallelEnumerable> includes implementations of all the standard query operators that LINQ to Objects supports, although it does not attempt to parallelize each one.</span></span> <span data-ttu-id="b8808-129">Si vous n’êtes pas familiarisé avec LINQ, consultez [Introduction à LINQC#()](../../csharp/programming-guide/concepts/linq/index.md) et [Introduction à LINQ (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md).</span><span class="sxs-lookup"><span data-stu-id="b8808-129">If you are not familiar with LINQ, see [Introduction to LINQ (C#)](../../csharp/programming-guide/concepts/linq/index.md) and [Introduction to LINQ (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md).</span></span>

<span data-ttu-id="b8808-130">Outre les opérateurs de requête standard, la classe <xref:System.Linq.ParallelEnumerable> contient un ensemble de méthodes qui activent des comportements spécifiques à l’exécution parallèle.</span><span class="sxs-lookup"><span data-stu-id="b8808-130">In addition to the standard query operators, the <xref:System.Linq.ParallelEnumerable> class contains a set of methods that enable behaviors specific to parallel execution.</span></span> <span data-ttu-id="b8808-131">Ces méthodes spécifiques de PLINQ sont répertoriées dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="b8808-131">These PLINQ-specific methods are listed in the following table.</span></span>

|<span data-ttu-id="b8808-132">Opérateur ParallelEnumerable</span><span class="sxs-lookup"><span data-stu-id="b8808-132">ParallelEnumerable Operator</span></span>|<span data-ttu-id="b8808-133">Description</span><span class="sxs-lookup"><span data-stu-id="b8808-133">Description</span></span>|
|---------------------------------|-----------------|
|<xref:System.Linq.ParallelEnumerable.AsParallel%2A>|<span data-ttu-id="b8808-134">Point d’entrée de PLINQ.</span><span class="sxs-lookup"><span data-stu-id="b8808-134">The entry point for PLINQ.</span></span> <span data-ttu-id="b8808-135">Indique que le reste de la requête doit être parallélisé, si possible.</span><span class="sxs-lookup"><span data-stu-id="b8808-135">Specifies that the rest of the query should be parallelized, if it is possible.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsSequential%2A>|<span data-ttu-id="b8808-136">Indique que le reste de la requête doit être exécuté de manière séquentielle, comme requête LINQ non parallèle.</span><span class="sxs-lookup"><span data-stu-id="b8808-136">Specifies that the rest of the query should be run sequentially, as a non-parallel LINQ query.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsOrdered%2A>|<span data-ttu-id="b8808-137">Indique que PLINQ doit conserver l’ordre de la séquence source pour le reste de la requête, ou jusqu’à ce que l’ordre soit modifié, par exemple à l’aide d’une clause orderby (Order By en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b8808-137">Specifies that PLINQ should preserve the ordering of the source sequence for the rest of the query, or until the ordering is changed, for example by the use of an orderby (Order By in Visual Basic) clause.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsUnordered%2A>|<span data-ttu-id="b8808-138">Indique que PLINQ ne doit pas conserver l’ordre de la séquence source pour le reste de la requête.</span><span class="sxs-lookup"><span data-stu-id="b8808-138">Specifies that PLINQ for the rest of the query is not required to preserve the ordering of the source sequence.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithCancellation%2A>|<span data-ttu-id="b8808-139">Indique que PLINQ doit régulièrement surveiller l’état du jeton d’annulation fourni et annuler l’exécution si cela est demandé.</span><span class="sxs-lookup"><span data-stu-id="b8808-139">Specifies that PLINQ should periodically monitor the state of the provided cancellation token and cancel execution if it is requested.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A>|<span data-ttu-id="b8808-140">Spécifie le nombre maximal de processeurs que PLINQ doit utiliser pour paralléliser la requête.</span><span class="sxs-lookup"><span data-stu-id="b8808-140">Specifies the maximum number of processors that PLINQ should use to parallelize the query.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A>|<span data-ttu-id="b8808-141">Fournit une indication sur la manière dont PLINQ doit, si possible, fusionner les résultats parallèles en une seule séquence sur le thread utilisé.</span><span class="sxs-lookup"><span data-stu-id="b8808-141">Provides a hint about how PLINQ should, if it is possible, merge parallel results back into just one sequence on the consuming thread.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A>|<span data-ttu-id="b8808-142">Indique si PLINQ doit paralléliser la requête même si le comportement par défaut consisterait à l’exécuter de manière séquentielle.</span><span class="sxs-lookup"><span data-stu-id="b8808-142">Specifies whether PLINQ should parallelize the query even when the default behavior would be to run it sequentially.</span></span>|
|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|<span data-ttu-id="b8808-143">Méthode d’énumération multithread qui, contrairement à l’itération sur les résultats de la requête, permet leur traitement en parallèle sans nécessiter la fusion préalable dans le thread utilisé.</span><span class="sxs-lookup"><span data-stu-id="b8808-143">A multithreaded enumeration method that, unlike iterating over the results of the query, enables results to be processed in parallel without first merging back to the consumer thread.</span></span>|
|<span data-ttu-id="b8808-144"><xref:System.Linq.ParallelEnumerable.Aggregate%2A> surcharge</span><span class="sxs-lookup"><span data-stu-id="b8808-144"><xref:System.Linq.ParallelEnumerable.Aggregate%2A> overload</span></span>|<span data-ttu-id="b8808-145">Surcharge propre à PLINQ qui permet l’agrégation intermédiaire sur des partitions locales des threads,et fonction d’agrégation finale permettant de combiner les résultats de toutes les partitions.</span><span class="sxs-lookup"><span data-stu-id="b8808-145">An overload that is unique to PLINQ and enables intermediate aggregation over thread-local partitions, plus a final aggregation function to combine the results of all partitions.</span></span>|

## <a name="the-opt-in-model"></a><span data-ttu-id="b8808-146">Modèle Opt-in</span><span class="sxs-lookup"><span data-stu-id="b8808-146">The Opt-in Model</span></span>

<span data-ttu-id="b8808-147">Lorsque vous écrivez une requête, utilisez PLINQ en appelant la méthode d’extension <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> sur la source de données, comme illustré dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="b8808-147">When you write a query, opt in to PLINQ by invoking the <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> extension method on the data source, as shown in the following example.</span></span>

[!code-csharp[PLINQ#1](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#1)]
[!code-vb[PLINQ#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#1)]

<span data-ttu-id="b8808-148">La méthode d’extension <xref:System.Linq.ParallelEnumerable.AsParallel%2A> lie les opérateurs de requête suivants, dans ce cas, `where` et `select`, aux implémentations <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b8808-148">The <xref:System.Linq.ParallelEnumerable.AsParallel%2A> extension method binds the subsequent query operators, in this case, `where` and `select`, to the <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> implementations.</span></span>

## <a name="execution-modes"></a><span data-ttu-id="b8808-149">Modes d’exécution</span><span class="sxs-lookup"><span data-stu-id="b8808-149">Execution Modes</span></span>

<span data-ttu-id="b8808-150">Par défaut, PLINQ est conservateur.</span><span class="sxs-lookup"><span data-stu-id="b8808-150">By default, PLINQ is conservative.</span></span> <span data-ttu-id="b8808-151">Au moment de l’exécution, l’infrastructure PLINQ analyse la structure globale de la requête.</span><span class="sxs-lookup"><span data-stu-id="b8808-151">At run time, the PLINQ infrastructure analyzes the overall structure of the query.</span></span> <span data-ttu-id="b8808-152">Si la requête est susceptible de produire des accélérations par parallélisation, PLINQ partitionne la séquence source en tâches pouvant être exécutées simultanément.</span><span class="sxs-lookup"><span data-stu-id="b8808-152">If the query is likely to yield speedups by parallelization, PLINQ partitions the source sequence into tasks that can be run concurrently.</span></span> <span data-ttu-id="b8808-153">Si la parallélisation d’une requête présente un risque, PLINQ exécute uniquement la requête de manière séquentielle.</span><span class="sxs-lookup"><span data-stu-id="b8808-153">If it is not safe to parallelize a query, PLINQ just runs the query sequentially.</span></span> <span data-ttu-id="b8808-154">Si PLINQ a le choix entre un algorithme parallèle potentiellement coûteux ou un algorithme séquentiel abordable, il choisit l’algorithme séquentiel par défaut.</span><span class="sxs-lookup"><span data-stu-id="b8808-154">If PLINQ has a choice between a potentially expensive parallel algorithm or an inexpensive sequential algorithm, it chooses the sequential algorithm by default.</span></span> <span data-ttu-id="b8808-155">Vous pouvez utiliser la méthode <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> et l’énumération <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> pour indiquer à PLINQ de sélectionner l’algorithme parallèle.</span><span class="sxs-lookup"><span data-stu-id="b8808-155">You can use the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method and the <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> enumeration to instruct PLINQ to select the parallel algorithm.</span></span> <span data-ttu-id="b8808-156">Cela est utile lorsque vous savez suite à des tests ou des mesures qu’une requête spécifique s’exécute plus rapidement en parallèle.</span><span class="sxs-lookup"><span data-stu-id="b8808-156">This is useful when you know by testing and measurement that a particular query executes faster in parallel.</span></span> <span data-ttu-id="b8808-157">Pour plus d’informations, consultez [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md) (Guide pratique pour spécifier le mode d’exécution dans PLINQ).</span><span class="sxs-lookup"><span data-stu-id="b8808-157">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>

## <a name="degree-of-parallelism"></a><span data-ttu-id="b8808-158">Degré de parallélisme</span><span class="sxs-lookup"><span data-stu-id="b8808-158">Degree of Parallelism</span></span>

<span data-ttu-id="b8808-159">Par défaut, PLINQ utilise tous les processeurs de l’ordinateur hôte.</span><span class="sxs-lookup"><span data-stu-id="b8808-159">By default, PLINQ uses all of the processors on the host computer.</span></span> <span data-ttu-id="b8808-160">Vous pouvez demander à PLINQ de ne pas utiliser plus d’un nombre spécifié de processeurs à l’aide de la méthode <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8808-160">You can instruct PLINQ to use no more than a specified number of processors by using the <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A> method.</span></span> <span data-ttu-id="b8808-161">Cela est utile lorsque vous souhaitez vous assurer que les autres processus en cours d’exécution sur l’ordinateur reçoivent une certaine quantité de temps CPU.</span><span class="sxs-lookup"><span data-stu-id="b8808-161">This is useful when you want to make sure that other processes running on the computer receive a certain amount of CPU time.</span></span> <span data-ttu-id="b8808-162">L’extrait suivant limite la requête à l’utilisation de deux processeurs maximum.</span><span class="sxs-lookup"><span data-stu-id="b8808-162">The following snippet limits the query to utilizing a maximum of two processors.</span></span>

[!code-csharp[PLINQ#5](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#5)]
[!code-vb[PLINQ#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#5)]

<span data-ttu-id="b8808-163">Si une requête effectue une quantité importante de travaux non liés au calcul, comme des E/S de fichier, il peut être utile de spécifier un degré de parallélisme supérieur au nombre de cœurs de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="b8808-163">In cases where a query is performing a significant amount of non-compute-bound work such as File I/O, it might be beneficial to specify a degree of parallelism greater than the number of cores on the machine.</span></span>

## <a name="ordered-versus-unordered-parallel-queries"></a><span data-ttu-id="b8808-164">Comparatif des requêtes parallèles ordonnées et non ordonnées</span><span class="sxs-lookup"><span data-stu-id="b8808-164">Ordered Versus Unordered Parallel Queries</span></span>

<span data-ttu-id="b8808-165">Dans certaines requêtes, un opérateur de requête doit produire des résultats qui conservent l’ordre de la séquence source.</span><span class="sxs-lookup"><span data-stu-id="b8808-165">In some queries, a query operator must produce results that preserve the ordering of the source sequence.</span></span> <span data-ttu-id="b8808-166">PLINQ fournit l’opérateur <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> à cet effet.</span><span class="sxs-lookup"><span data-stu-id="b8808-166">PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator for this purpose.</span></span> <span data-ttu-id="b8808-167"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> est différent de <xref:System.Linq.ParallelEnumerable.AsSequential%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8808-167"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> is distinct from <xref:System.Linq.ParallelEnumerable.AsSequential%2A>.</span></span> <span data-ttu-id="b8808-168">Une séquence <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> est toujours traitée en parallèle, mais ses résultats sont mis en mémoire tampon et triés.</span><span class="sxs-lookup"><span data-stu-id="b8808-168">An <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence is still processed in parallel, but its results are buffered and sorted.</span></span> <span data-ttu-id="b8808-169">Étant donné que la conservation de l’ordre implique généralement un travail supplémentaire, une séquence <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> peut être traitée plus lentement que la séquence <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> par défaut.</span><span class="sxs-lookup"><span data-stu-id="b8808-169">Because order preservation typically involves extra work, an <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence might be processed more slowly than the default <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> sequence.</span></span> <span data-ttu-id="b8808-170">Le fait qu’une opération parallèle ordonnée de manière spécifique soit plus rapide qu’une version séquentielle de l’opération dépend de nombreux facteurs.</span><span class="sxs-lookup"><span data-stu-id="b8808-170">Whether a particular ordered parallel operation is faster than a sequential version of the operation depends on many factors.</span></span>

<span data-ttu-id="b8808-171">L’exemple de code suivant montre comment utiliser la conservation de l’ordre.</span><span class="sxs-lookup"><span data-stu-id="b8808-171">The following code example shows how to opt in to order preservation.</span></span>

[!code-csharp[PLINQ#3](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#3)]
[!code-vb[PLINQ#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#3)]

<span data-ttu-id="b8808-172">Pour plus d’informations, consultez [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md) (Conservation de l’ordre dans PLINQ).</span><span class="sxs-lookup"><span data-stu-id="b8808-172">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>

## <a name="parallel-vs-sequential-queries"></a><span data-ttu-id="b8808-173">Requêtes parallèles et requêtes séquentielles</span><span class="sxs-lookup"><span data-stu-id="b8808-173">Parallel vs. Sequential Queries</span></span>

<span data-ttu-id="b8808-174">Certaines opérations requièrent que la source de données soit proposée de manière séquentielle.</span><span class="sxs-lookup"><span data-stu-id="b8808-174">Some operations require that the source data be delivered in a sequential manner.</span></span> <span data-ttu-id="b8808-175">Les opérateurs de requête <xref:System.Linq.ParallelEnumerable> basculent automatiquement en mode séquentiel lorsque cela est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="b8808-175">The <xref:System.Linq.ParallelEnumerable> query operators revert to sequential mode automatically when it is required.</span></span> <span data-ttu-id="b8808-176">Pour les opérateurs de requête et les délégués d’utilisateurs définis par l’utilisateur qui nécessitent une exécution séquentielle, PLINQ fournit la méthode <xref:System.Linq.ParallelEnumerable.AsSequential%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8808-176">For user-defined query operators and user delegates that require sequential execution, PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsSequential%2A> method.</span></span> <span data-ttu-id="b8808-177">Lorsque vous utilisez <xref:System.Linq.ParallelEnumerable.AsSequential%2A>, tous les opérateurs suivants dans la requête sont exécutés séquentiellement jusqu'à ce que <xref:System.Linq.ParallelEnumerable.AsParallel%2A> soit à nouveau appelé.</span><span class="sxs-lookup"><span data-stu-id="b8808-177">When you use <xref:System.Linq.ParallelEnumerable.AsSequential%2A>, all subsequent operators in the query are executed sequentially until <xref:System.Linq.ParallelEnumerable.AsParallel%2A> is called again.</span></span> <span data-ttu-id="b8808-178">Pour plus d’informations, voir [Comment : combiner des requêtes LINQ parallèles et séquentielles](../../../docs/standard/parallel-programming/how-to-combine-parallel-and-sequential-linq-queries.md).</span><span class="sxs-lookup"><span data-stu-id="b8808-178">For more information, see [How to: Combine Parallel and Sequential LINQ Queries](../../../docs/standard/parallel-programming/how-to-combine-parallel-and-sequential-linq-queries.md).</span></span>

## <a name="options-for-merging-query-results"></a><span data-ttu-id="b8808-179">Options de fusion des résultats de requête</span><span class="sxs-lookup"><span data-stu-id="b8808-179">Options for Merging Query Results</span></span>

<span data-ttu-id="b8808-180">Quand une requête PLINQ s’exécute en parallèle, les résultats issus de chaque thread de travail doivent être refusionnés sur le thread principal pour être utilisés par une boucle `foreach` (`For Each` en Visual Basic), ou insérés dans une liste ou un tableau.</span><span class="sxs-lookup"><span data-stu-id="b8808-180">When a PLINQ query executes in parallel, its results from each worker thread must be merged back onto the main thread for consumption by a `foreach` loop (`For Each` in Visual Basic), or insertion into a list or array.</span></span> <span data-ttu-id="b8808-181">Dans certains cas, il peut être utile de spécifier un type particulier d’opération de fusion, par exemple, pour commencer à générer des résultats plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="b8808-181">In some cases, it might be beneficial to specify a particular kind of merge operation, for example, to begin producing results more quickly.</span></span> <span data-ttu-id="b8808-182">Pour cela, PLINQ prend en charge la méthode <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> et l’énumération <xref:System.Linq.ParallelMergeOptions>.</span><span class="sxs-lookup"><span data-stu-id="b8808-182">For this purpose, PLINQ supports the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, and the <xref:System.Linq.ParallelMergeOptions> enumeration.</span></span> <span data-ttu-id="b8808-183">Pour plus d’informations, consultez l’article [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md) (Options de fusion de PLINQ).</span><span class="sxs-lookup"><span data-stu-id="b8808-183">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>

## <a name="the-forall-operator"></a><span data-ttu-id="b8808-184">Opérateur ForAll</span><span class="sxs-lookup"><span data-stu-id="b8808-184">The ForAll Operator</span></span>

<span data-ttu-id="b8808-185">Dans les requêtes LINQ séquentielles, l’exécution est différée jusqu’à ce que la requête soit énumérée dans une boucle `foreach` (`For Each` dans Visual Basic) ou en appelant une méthode telle que <xref:System.Linq.ParallelEnumerable.ToList%2A>, <xref:System.Linq.ParallelEnumerable.ToArray%2A> ou <xref:System.Linq.ParallelEnumerable.ToDictionary%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8808-185">In sequential LINQ queries, execution is deferred until the query is enumerated either in a `foreach` (`For Each` in Visual Basic) loop or by invoking a method such as <xref:System.Linq.ParallelEnumerable.ToList%2A> , <xref:System.Linq.ParallelEnumerable.ToArray%2A> , or <xref:System.Linq.ParallelEnumerable.ToDictionary%2A>.</span></span> <span data-ttu-id="b8808-186">Dans PLINQ, vous pouvez également utiliser `foreach` pour exécuter la requête et itérer dans les résultats.</span><span class="sxs-lookup"><span data-stu-id="b8808-186">In PLINQ, you can also use `foreach` to execute the query and iterate through the results.</span></span> <span data-ttu-id="b8808-187">Toutefois, `foreach` lui-même ne s’exécute pas en parallèle, et par conséquent, requiert que les résultats de toutes les tâches parallèles soient refusionnés dans le thread sur lequel la boucle s’exécute.</span><span class="sxs-lookup"><span data-stu-id="b8808-187">However, `foreach` itself does not run in parallel, and therefore, it requires that the output from all parallel tasks be merged back into the thread on which the loop is running.</span></span> <span data-ttu-id="b8808-188">Dans PLINQ, vous pouvez utiliser `foreach` lorsque vous devez conserver l’ordre final des résultats de requête, et également chaque fois que vous traitez des résultats en série, par exemple, lorsque vous appelez `Console.WriteLine` pour chaque élément.</span><span class="sxs-lookup"><span data-stu-id="b8808-188">In PLINQ, you can use `foreach` when you must preserve the final ordering of the query results, and also whenever you are processing the results in a serial manner, for example when you are calling `Console.WriteLine` for each element.</span></span> <span data-ttu-id="b8808-189">Pour une exécution plus rapide des requêtes lorsque la conservation de l’ordre n’est pas nécessaire et lorsque le traitement des résultats peut lui-même être parallélisé, utilisez la méthode <xref:System.Linq.ParallelEnumerable.ForAll%2A> pour exécuter une requête PLINQ.</span><span class="sxs-lookup"><span data-stu-id="b8808-189">For faster query execution when order preservation is not required and when the processing of the results can itself be parallelized, use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method to execute a PLINQ query.</span></span> <span data-ttu-id="b8808-190"><xref:System.Linq.ParallelEnumerable.ForAll%2A> n’effectue pas cette dernière étape de fusion.</span><span class="sxs-lookup"><span data-stu-id="b8808-190"><xref:System.Linq.ParallelEnumerable.ForAll%2A> does not perform this final merge step.</span></span> <span data-ttu-id="b8808-191">L'exemple de code suivant montre comment utiliser la méthode <xref:System.Linq.ParallelEnumerable.ForAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8808-191">The following code example shows how to use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method.</span></span> <span data-ttu-id="b8808-192"><xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> est utilisée ici, car elle est optimisée pour l’ajout simultané de plusieurs threads sans tentative de suppression d’éléments.</span><span class="sxs-lookup"><span data-stu-id="b8808-192"><xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> is used here because it is optimized for multiple threads adding concurrently without attempting to remove any items.</span></span>

[!code-csharp[PLINQ#4](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#4)]
[!code-vb[PLINQ#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#4)]

<span data-ttu-id="b8808-193">L’illustration suivante montre la différence entre `foreach` et <xref:System.Linq.ParallelEnumerable.ForAll%2A> en ce qui concerne l’exécution des requêtes.</span><span class="sxs-lookup"><span data-stu-id="b8808-193">The following illustration shows the difference between `foreach` and <xref:System.Linq.ParallelEnumerable.ForAll%2A> with regard to query execution.</span></span>

<span data-ttu-id="b8808-194">![ForAll et ForEach](../../../docs/standard/parallel-programming/media/vs-isvnt-allvseach.png "VS_ISVNT_ALLvsEACH")</span><span class="sxs-lookup"><span data-stu-id="b8808-194">![ForAll vs. ForEach](../../../docs/standard/parallel-programming/media/vs-isvnt-allvseach.png "VS_ISVNT_ALLvsEACH")</span></span>

## <a name="cancellation"></a><span data-ttu-id="b8808-195">Annulation</span><span class="sxs-lookup"><span data-stu-id="b8808-195">Cancellation</span></span>

<span data-ttu-id="b8808-196">PLINQ est intégré aux types d’annulation dans .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="b8808-196">PLINQ is integrated with the cancellation types in .NET Framework 4.</span></span> <span data-ttu-id="b8808-197">(Pour plus d’informations, consultez [annulation dans les threads managés](../../../docs/standard/threading/cancellation-in-managed-threads.md).) Par conséquent, contrairement aux requêtes LINQ to Objects séquentielles, les requêtes PLINQ peuvent être annulées.</span><span class="sxs-lookup"><span data-stu-id="b8808-197">(For more information, see [Cancellation in Managed Threads](../../../docs/standard/threading/cancellation-in-managed-threads.md).) Therefore, unlike sequential LINQ to Objects queries, PLINQ queries can be canceled.</span></span> <span data-ttu-id="b8808-198">Pour créer une requête PLINQ annulable, utilisez l’opérateur <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> sur la requête et fournissez une instance <xref:System.Threading.CancellationToken> comme argument.</span><span class="sxs-lookup"><span data-stu-id="b8808-198">To create a cancelable PLINQ query, use the <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> operator on the query and provide a <xref:System.Threading.CancellationToken> instance as the argument.</span></span> <span data-ttu-id="b8808-199">Lorsque la propriété <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> sur le jeton est définie sur true, PLINQ le remarque, arrête le traitement sur tous les threads et lève une <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="b8808-199">When the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on the token is set to true, PLINQ will notice it, stop processing on all threads, and throw an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="b8808-200">Il est possible qu’une requête PLINQ continue de traiter certains éléments après la définition du jeton d’annulation.</span><span class="sxs-lookup"><span data-stu-id="b8808-200">It is possible that a PLINQ query might continue to process some elements after the cancellation token is set.</span></span>

<span data-ttu-id="b8808-201">Pour une plus grande réactivité, vous pouvez également répondre aux demandes d’annulation dans les délégués d’utilisateur de longue durée.</span><span class="sxs-lookup"><span data-stu-id="b8808-201">For greater responsiveness, you can also respond to cancellation requests in long-running user delegates.</span></span> <span data-ttu-id="b8808-202">Pour plus d’informations, consultez [How to: Cancel a PLINQ Query](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md) (Guide pratique pour annuler une requête PLINQ).</span><span class="sxs-lookup"><span data-stu-id="b8808-202">For more information, see [How to: Cancel a PLINQ Query](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md).</span></span>

## <a name="exceptions"></a><span data-ttu-id="b8808-203">Exceptions</span><span class="sxs-lookup"><span data-stu-id="b8808-203">Exceptions</span></span>

<span data-ttu-id="b8808-204">Lorsqu’une requête PLINQ s’exécute, plusieurs exceptions peuvent être générées simultanément à partir de plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="b8808-204">When a PLINQ query executes, multiple exceptions might be thrown from different threads simultaneously.</span></span> <span data-ttu-id="b8808-205">En outre, le code destiné à traiter l’exception peut se trouver sur un thread différent de celui du code ayant généré l’exception.</span><span class="sxs-lookup"><span data-stu-id="b8808-205">Also, the code to handle the exception might be on a different thread than the code that threw the exception.</span></span> <span data-ttu-id="b8808-206">PLINQ utilise le type <xref:System.AggregateException> afin d’encapsuler toutes les exceptions levées par une requête et de les marshaler à sur le thread appelant.</span><span class="sxs-lookup"><span data-stu-id="b8808-206">PLINQ uses the <xref:System.AggregateException> type to encapsulate all the exceptions that were thrown by a query, and marshal those exceptions back to the calling thread.</span></span> <span data-ttu-id="b8808-207">Le thread appelant ne requiert qu’un seul bloc try-catch.</span><span class="sxs-lookup"><span data-stu-id="b8808-207">On the calling thread, only one try-catch block is required.</span></span> <span data-ttu-id="b8808-208">Toutefois, vous pouvez itérer sur toutes les exceptions encapsulées dans <xref:System.AggregateException> et intercepter celles à partir desquelles vous pouvez effectuer une récupération en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="b8808-208">However, you can iterate through all of the exceptions that are encapsulated in the <xref:System.AggregateException> and catch any that you can safely recover from.</span></span> <span data-ttu-id="b8808-209">Dans de rares cas, certaines exceptions qui ne sont pas encapsulées dans <xref:System.AggregateException> peuvent être levées, et les exceptions <xref:System.Threading.ThreadAbortException> ne sont pas non plus incluses dans un wrapper.</span><span class="sxs-lookup"><span data-stu-id="b8808-209">In rare cases, some exceptions may be thrown that are not wrapped in an <xref:System.AggregateException>, and <xref:System.Threading.ThreadAbortException>s  are also not wrapped.</span></span>

<span data-ttu-id="b8808-210">Lorsque les exceptions sont autorisées à se propager vers le thread lié, il est possible qu'une requête puisse continuer à traiter des éléments après que l'exception ait été levée.</span><span class="sxs-lookup"><span data-stu-id="b8808-210">When exceptions are allowed to bubble up back to the joining thread, then it is possible that a query may continue to process some items after the exception is raised.</span></span>

<span data-ttu-id="b8808-211">Pour plus d’informations, consultez [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md) (Comment : traiter des exceptions dans une requête PLINQ).</span><span class="sxs-lookup"><span data-stu-id="b8808-211">For more information, see [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="b8808-212">Partitionneurs personnalisés</span><span class="sxs-lookup"><span data-stu-id="b8808-212">Custom Partitioners</span></span>

<span data-ttu-id="b8808-213">Dans certains cas, vous pouvez améliorer les performances des requêtes en écrivant un partitionneur personnalisé qui tire parti de certaines caractéristiques de la source de données.</span><span class="sxs-lookup"><span data-stu-id="b8808-213">In some cases, you can improve query performance by writing a custom partitioner that takes advantage of some characteristic of the source data.</span></span> <span data-ttu-id="b8808-214">Dans la requête, le partitionneur personnalisé lui-même est l’objet énumérable interrogé.</span><span class="sxs-lookup"><span data-stu-id="b8808-214">In the query, the custom partitioner itself is the enumerable object that is queried.</span></span>

[!code-csharp[PLINQ#2](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#2)]
[!code-vb[PLINQ#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq3.vb#2)]

<span data-ttu-id="b8808-215">PLINQ prend en charge un nombre fixe de partitions (bien que les données puissent être réaffectées de manière dynamique à ces partitions pendant l’exécution pour l’équilibrage de charge.).</span><span class="sxs-lookup"><span data-stu-id="b8808-215">PLINQ supports a fixed number of partitions (although data may be dynamically reassigned to those partitions during run time for load balancing.).</span></span> <span data-ttu-id="b8808-216"><xref:System.Threading.Tasks.Parallel.For%2A> et <xref:System.Threading.Tasks.Parallel.ForEach%2A> prennent en charge uniquement le partitionnement dynamique, ce qui signifie que le nombre de partitions change en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="b8808-216"><xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> support only dynamic partitioning, which means that the number of partitions changes at run time.</span></span> <span data-ttu-id="b8808-217">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et la bibliothèque parallèle de tâches (TPL)](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="b8808-217">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>

## <a name="measuring-plinq-performance"></a><span data-ttu-id="b8808-218">Mesure des performances de PLINQ</span><span class="sxs-lookup"><span data-stu-id="b8808-218">Measuring PLINQ Performance</span></span>

<span data-ttu-id="b8808-219">Dans de nombreux cas, une requête peut être parallélisée, mais la surcharge liée à la configuration de la requête parallèle annule le gain obtenu en termes de performances.</span><span class="sxs-lookup"><span data-stu-id="b8808-219">In many cases, a query can be parallelized, but the overhead of setting up the parallel query outweighs the performance benefit gained.</span></span> <span data-ttu-id="b8808-220">Si une requête n’effectue pas beaucoup de calculs ou si la source de données est petite, une requête PLINQ peut être plus lente qu’une requête LINQ to Objects séquentielle.</span><span class="sxs-lookup"><span data-stu-id="b8808-220">If a query does not perform much computation or if the data source is small, a PLINQ query may be slower than a sequential LINQ to Objects query.</span></span> <span data-ttu-id="b8808-221">Vous pouvez utiliser l’outil d’analyse des performances parallèles de Visual Studio Team Server pour comparer les performances de diverses requêtes, localiser des goulots d’étranglement et déterminer si votre requête s’exécute en parallèle ou de manière séquentielle.</span><span class="sxs-lookup"><span data-stu-id="b8808-221">You can use the Parallel Performance Analyzer in Visual Studio Team Server to compare the performance of various queries, to locate processing bottlenecks, and to determine whether your query is running in parallel or sequentially.</span></span> <span data-ttu-id="b8808-222">Pour plus d’informations, consultez [Visualiseur concurrentiel](/visualstudio/profiling/concurrency-visualizer) et [How to: Measure PLINQ Query Performance](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md) (Comment : mesurer les performances des requêtes PLINQ).</span><span class="sxs-lookup"><span data-stu-id="b8808-222">For more information, see [Concurrency Visualizer](/visualstudio/profiling/concurrency-visualizer) and [How to: Measure PLINQ Query Performance](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="b8808-223">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="b8808-223">See also</span></span>

- [<span data-ttu-id="b8808-224">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="b8808-224">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
- [<span data-ttu-id="b8808-225">Fonctionnement de l’accélération dans PLINQ</span><span class="sxs-lookup"><span data-stu-id="b8808-225">Understanding Speedup in PLINQ</span></span>](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)
