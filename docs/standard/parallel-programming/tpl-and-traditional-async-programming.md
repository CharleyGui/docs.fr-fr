---
title: Bibliothèque parallèle de tâches (TPL) et programmation asynchrone .NET Framework
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, with other asynchronous models
ms.assetid: e7b31170-a156-433f-9f26-b1fc7cd1776f
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 57f274d55ba5723ce8e0b51a7a39e98e95855e28
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64653927"
---
# <a name="tpl-and-traditional-net-framework-asynchronous-programming"></a><span data-ttu-id="70674-102">Bibliothèque parallèle de tâches (TPL) et programmation asynchrone .NET Framework</span><span class="sxs-lookup"><span data-stu-id="70674-102">TPL and Traditional .NET Framework Asynchronous Programming</span></span>
<span data-ttu-id="70674-103">Le .NET Framework fournit les deux modèles standard suivants pour l’exécution d’opérations asynchrones liées aux E/S et orientées calculs :</span><span class="sxs-lookup"><span data-stu-id="70674-103">The .NET Framework provides the following two standard patterns for performing I/O-bound and compute-bound asynchronous operations:</span></span>  
  
- <span data-ttu-id="70674-104">Le modèle de programmation asynchrone, dans lequel les opérations asynchrones sont représentées par une paire de méthodes Begin/End telles que <xref:System.IO.FileStream.BeginRead%2A?displayProperty=nameWithType> et <xref:System.IO.Stream.EndRead%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="70674-104">Asynchronous Programming Model (APM), in which asynchronous operations are represented by a pair of Begin/End methods such as <xref:System.IO.FileStream.BeginRead%2A?displayProperty=nameWithType> and <xref:System.IO.Stream.EndRead%2A?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="70674-105">Le modèle asynchrone basé sur des événements, dans lequel les opérations asynchrones sont représentées par une paire méthode/événement et nommées *OperationName*Async et *OperationName* Completed, par exemple, <xref:System.Net.WebClient.DownloadStringAsync%2A?displayProperty=nameWithType> et <xref:System.Net.WebClient.DownloadStringCompleted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="70674-105">Event-based asynchronous pattern (EAP), in which asynchronous operations are represented by a method/event pair that are named *OperationName*Async and *OperationName*Completed, for example, <xref:System.Net.WebClient.DownloadStringAsync%2A?displayProperty=nameWithType> and <xref:System.Net.WebClient.DownloadStringCompleted?displayProperty=nameWithType>.</span></span> <span data-ttu-id="70674-106">(Le modèle asynchrone basé sur des événements a été introduit avec le .NET Framework version 2.0).</span><span class="sxs-lookup"><span data-stu-id="70674-106">(EAP was introduced in the .NET Framework version 2.0.)</span></span>  
  
 <span data-ttu-id="70674-107">La bibliothèque parallèle de tâches peut être utilisée de plusieurs façons conjointement à l'un ou l'autre des modèles asynchrones.</span><span class="sxs-lookup"><span data-stu-id="70674-107">The Task Parallel Library (TPL) can be used in various ways in conjunction with either of the asynchronous patterns.</span></span> <span data-ttu-id="70674-108">Vous pouvez exposer à la fois les opérations de modèle de programmation asynchrone et de modèle asynchrone basé sur des événements en tant que Tâches aux consommateurs de la bibliothèque, ou bien exposer les modèles de programmation asynchrone et utiliser des objets Task pour les implémenter en interne.</span><span class="sxs-lookup"><span data-stu-id="70674-108">You can expose both APM and EAP operations as Tasks to library consumers, or you can expose the APM patterns but use Task objects to implement them internally.</span></span> <span data-ttu-id="70674-109">Dans les deux scénarios, en utilisant des objets Task, vous pouvez simplifier le code et bénéficier des fonctionnalités utiles suivantes :</span><span class="sxs-lookup"><span data-stu-id="70674-109">In both scenarios, by using Task objects, you can simplify the code and take advantage of the following useful functionality:</span></span>  
  
- <span data-ttu-id="70674-110">Enregistrer des rappels sous la forme de continuations de tâches, à tout moment après le lancement de la tâche.</span><span class="sxs-lookup"><span data-stu-id="70674-110">Register callbacks, in the form of task continuations, at any time after the task has started.</span></span>  
  
- <span data-ttu-id="70674-111">Coordonner plusieurs opérations qui s'exécutent en réponse à une méthode `Begin_`, à l'aide des méthodes <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> et <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A>, ou des méthodes <xref:System.Threading.Tasks.Task.WaitAll%2A> ou <xref:System.Threading.Tasks.Task.WaitAny%2A>.</span><span class="sxs-lookup"><span data-stu-id="70674-111">Coordinate multiple operations that execute in response to a `Begin_` method, by using the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> methods, or the <xref:System.Threading.Tasks.Task.WaitAll%2A> method or the <xref:System.Threading.Tasks.Task.WaitAny%2A> method.</span></span>  
  
- <span data-ttu-id="70674-112">Encapsuler des opérations asynchrones liées aux E/S et orientées calcul dans le même objet Task.</span><span class="sxs-lookup"><span data-stu-id="70674-112">Encapsulate asynchronous I/O-bound and compute-bound operations in the same Task object.</span></span>  
  
- <span data-ttu-id="70674-113">Surveiller l'état de l'objet Task.</span><span class="sxs-lookup"><span data-stu-id="70674-113">Monitor the status of the Task object.</span></span>  
  
- <span data-ttu-id="70674-114">Marshaler le statut d'une opération sur un objet Task à l'aide de <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="70674-114">Marshal the status of an operation to a Task object by using <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span></span>  
  
## <a name="wrapping-apm-operations-in-a-task"></a><span data-ttu-id="70674-115">Encapsulation d’opérations de modèle de programmation asynchrone dans une tâche</span><span class="sxs-lookup"><span data-stu-id="70674-115">Wrapping APM Operations in a Task</span></span>  
 <span data-ttu-id="70674-116">Les classes <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType> et <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType> fournissent plusieurs surcharges des méthodes <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=nameWithType> et <xref:System.Threading.Tasks.TaskFactory%601.FromAsync%2A?displayProperty=nameWithType> qui vous permettent d'encapsuler une paire de méthodes de modèle de programmation asynchrone Begin/End dans une instance <xref:System.Threading.Tasks.Task> ou <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="70674-116">Both the <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType> classes provide several overloads of the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory%601.FromAsync%2A?displayProperty=nameWithType> methods that let you encapsulate an APM Begin/End method pair in one <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="70674-117">Les différentes surcharges s'adaptent à toutes les paires de méthode Begin/End possédant de zéro à trois paramètres d'entrée.</span><span class="sxs-lookup"><span data-stu-id="70674-117">The various overloads accommodate any Begin/End method pair that have from zero to three input parameters.</span></span>  
  
 <span data-ttu-id="70674-118">Pour les paires ayant des méthodes `End` qui retournent une valeur (`Function` en Visual Basic), utilisez les méthodes de <xref:System.Threading.Tasks.TaskFactory%601> qui créent un <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="70674-118">For pairs that have `End` methods that return a value (`Function` in Visual Basic), use the methods in <xref:System.Threading.Tasks.TaskFactory%601> that create a <xref:System.Threading.Tasks.Task%601>.</span></span> <span data-ttu-id="70674-119">Pour les méthodes `End` qui retournent void (`Sub` en Visual Basic), utilisez les méthodes de <xref:System.Threading.Tasks.TaskFactory> qui créent un <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="70674-119">For `End` methods that return void (`Sub` in Visual Basic), use the methods in <xref:System.Threading.Tasks.TaskFactory> that create a <xref:System.Threading.Tasks.Task>.</span></span>  
  
 <span data-ttu-id="70674-120">Pour les rares cas dans lesquels la méthode `Begin` a plus de trois paramètres ou contient les paramètres `ref` ou `out`, les surcharges `FromAsync` supplémentaires qui encapsulent uniquement la méthode `End` sont fournies.</span><span class="sxs-lookup"><span data-stu-id="70674-120">For those few cases in which the `Begin` method has more than three parameters or contains `ref` or `out` parameters, additional `FromAsync` overloads that encapsulate only the `End` method are provided.</span></span>  
  
 <span data-ttu-id="70674-121">L'exemple suivant montre la signature de la surcharge `FromAsync` qui correspond aux méthodes <xref:System.IO.FileStream.BeginRead%2A?displayProperty=nameWithType> et <xref:System.IO.FileStream.EndRead%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="70674-121">The following example shows the signature for the `FromAsync` overload that matches the <xref:System.IO.FileStream.BeginRead%2A?displayProperty=nameWithType> and <xref:System.IO.FileStream.EndRead%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="70674-122">Cette surcharge prend trois paramètres d'entrée, comme suit.</span><span class="sxs-lookup"><span data-stu-id="70674-122">This overload takes three input parameters, as follows.</span></span>  
  
 [!code-csharp[FromAsync#01](../../../samples/snippets/csharp/VS_Snippets_Misc/fromasync/cs/fromasync.cs#01)]
 [!code-vb[FromAsync#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/fromasync/vb/module1.vb#01)]  
  
 <span data-ttu-id="70674-123">Le premier paramètre est un délégué <xref:System.Func%606> qui correspond à la signature de la méthode <xref:System.IO.FileStream.BeginRead%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="70674-123">The first parameter is a <xref:System.Func%606> delegate that matches the signature of the <xref:System.IO.FileStream.BeginRead%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="70674-124">Le deuxième paramètre est un délégué <xref:System.Func%602> qui prend un <xref:System.IAsyncResult> et retourne un `TResult`.</span><span class="sxs-lookup"><span data-stu-id="70674-124">The second parameter is a <xref:System.Func%602> delegate that takes an <xref:System.IAsyncResult> and returns a `TResult`.</span></span> <span data-ttu-id="70674-125">Étant donné que <xref:System.IO.FileStream.EndRead%2A> retourne un entier, le compilateur déduit le type de `TResult` en tant que <xref:System.Int32> et le type de la tâche en tant que <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="70674-125">Because <xref:System.IO.FileStream.EndRead%2A> returns an integer, the compiler infers the type of `TResult` as <xref:System.Int32> and the type of the task as <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="70674-126">Les quatre derniers paramètres sont identiques à ceux de la méthode <xref:System.IO.FileStream.BeginRead%2A?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="70674-126">The last four parameters are identical to those in the <xref:System.IO.FileStream.BeginRead%2A?displayProperty=nameWithType> method:</span></span>  
  
- <span data-ttu-id="70674-127">Tampon dans lequel stocker les données de fichiers.</span><span class="sxs-lookup"><span data-stu-id="70674-127">The buffer in which to store the file data.</span></span>  
  
- <span data-ttu-id="70674-128">Dans le tampon, offset à partir duquel commencer l'écriture des données.</span><span class="sxs-lookup"><span data-stu-id="70674-128">The offset in the buffer at which to begin writing data.</span></span>  
  
- <span data-ttu-id="70674-129">Quantité maximale de données à lire dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="70674-129">The maximum amount of data to read from the file.</span></span>  
  
- <span data-ttu-id="70674-130">Objet facultatif qui stocke les données d'état définies par l'utilisateur à passer au rappel.</span><span class="sxs-lookup"><span data-stu-id="70674-130">An optional object that stores user-defined state data to pass to the callback.</span></span>  
  
### <a name="using-continuewith-for-the-callback-functionality"></a><span data-ttu-id="70674-131">Utilisation de ContinueWith pour les fonctionnalités de rappel</span><span class="sxs-lookup"><span data-stu-id="70674-131">Using ContinueWith for the Callback Functionality</span></span>  
 <span data-ttu-id="70674-132">Si vous devez accéder aux données d'un fichier, et non juste au nombre d'octets, la méthode <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> n'est pas suffisante.</span><span class="sxs-lookup"><span data-stu-id="70674-132">If you require access to the data in the file, as opposed to just the number of bytes, the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> method is not sufficient.</span></span> <span data-ttu-id="70674-133">Utilisez plutôt <xref:System.Threading.Tasks.Task>, dont la propriété `Result` contient les données de fichier.</span><span class="sxs-lookup"><span data-stu-id="70674-133">Instead, use <xref:System.Threading.Tasks.Task>, whose `Result` property contains the file data.</span></span> <span data-ttu-id="70674-134">Pour cela, ajoutez une continuation à la tâche d’origine.</span><span class="sxs-lookup"><span data-stu-id="70674-134">You can do this by adding a continuation to the original task.</span></span> <span data-ttu-id="70674-135">La continuation exécute le travail généralement effectué par le délégué <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="70674-135">The continuation performs the work that would typically be performed by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="70674-136">Elle est appelée quand l'antécédent est terminé et que le tampon de données est rempli.</span><span class="sxs-lookup"><span data-stu-id="70674-136">It is invoked when the antecedent completes, and the data buffer has been filled.</span></span> <span data-ttu-id="70674-137">(L'objet <xref:System.IO.FileStream> doit être fermé avant le retour.)</span><span class="sxs-lookup"><span data-stu-id="70674-137">(The <xref:System.IO.FileStream> object should be closed before returning.)</span></span>  
  
 <span data-ttu-id="70674-138">L'exemple suivant montre comment retourner un <xref:System.Threading.Tasks.Task> qui encapsule la paire BeginRead/EndRead de la classe <xref:System.IO.FileStream>.</span><span class="sxs-lookup"><span data-stu-id="70674-138">The following example shows how to return a <xref:System.Threading.Tasks.Task> that encapsulates the BeginRead/EndRead pair of the <xref:System.IO.FileStream> class.</span></span>  
  
 [!code-csharp[FromAsync#03](../../../samples/snippets/csharp/VS_Snippets_Misc/fromasync/cs/fromasync.cs#03)]
 [!code-vb[FromAsync#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/fromasync/vb/module1.vb#03)]  
  
 <span data-ttu-id="70674-139">La méthode peut ensuite être appelée, comme suit.</span><span class="sxs-lookup"><span data-stu-id="70674-139">The method can then be called, as follows.</span></span>  
  
 [!code-csharp[FromAsync#04](../../../samples/snippets/csharp/VS_Snippets_Misc/fromasync/cs/fromasync.cs#04)]
 [!code-vb[FromAsync#04](../../../samples/snippets/visualbasic/VS_Snippets_Misc/fromasync/vb/module1.vb#04)]  
  
### <a name="providing-custom-state-data"></a><span data-ttu-id="70674-140">Fourniture de données d'état personnalisées</span><span class="sxs-lookup"><span data-stu-id="70674-140">Providing Custom State Data</span></span>  
 <span data-ttu-id="70674-141">Dans les opérations <xref:System.IAsyncResult> typiques, si votre délégué <xref:System.AsyncCallback> a besoin de certaines données d'état personnalisées, vous devez les passer via le dernier paramètre de la méthode `Begin`, afin que les données puissent être empaquetées dans l'objet <xref:System.IAsyncResult> qui est finalement passé à la méthode de rappel.</span><span class="sxs-lookup"><span data-stu-id="70674-141">In typical <xref:System.IAsyncResult> operations, if your <xref:System.AsyncCallback> delegate requires some custom state data, you have to pass it in through the last parameter in the `Begin` method, so that the data can be packaged into the <xref:System.IAsyncResult> object that is eventually passed to the callback method.</span></span> <span data-ttu-id="70674-142">Cela n'est en général pas obligatoire quand les méthodes `FromAsync` sont utilisées.</span><span class="sxs-lookup"><span data-stu-id="70674-142">This is typically not required when the `FromAsync` methods are used.</span></span> <span data-ttu-id="70674-143">Si les données personnalisées sont connues de la continuation, elles peuvent être capturées directement dans le délégué de continuation.</span><span class="sxs-lookup"><span data-stu-id="70674-143">If the custom data is known to the continuation, then it can be captured directly in the continuation delegate.</span></span> <span data-ttu-id="70674-144">L'exemple suivant ressemble au précédent, mais au lieu d'examiner la propriété `Result` de la tâche antérieure, la continuation examine les données d'état personnalisées directement accessibles au délégué utilisateur de la continuation.</span><span class="sxs-lookup"><span data-stu-id="70674-144">The following example resembles the previous example, but instead of examining the `Result` property of the antecedent, the continuation examines the custom state data that is directly accessible to the user delegate of the continuation.</span></span>  
  
 [!code-csharp[FromAsync#05](../../../samples/snippets/csharp/VS_Snippets_Misc/fromasync/cs/fromasync.cs#05)]
 [!code-vb[FromAsync#05](../../../samples/snippets/visualbasic/VS_Snippets_Misc/fromasync/vb/module1.vb#05)]  
  
### <a name="synchronizing-multiple-fromasync-tasks"></a><span data-ttu-id="70674-145">Synchronisation de plusieurs tâches FromAsync</span><span class="sxs-lookup"><span data-stu-id="70674-145">Synchronizing Multiple FromAsync Tasks</span></span>  
 <span data-ttu-id="70674-146">Les méthodes <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> et <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> statiques offrent une flexibilité supplémentaire en cas d'utilisation avec les méthodes `FromAsync`.</span><span class="sxs-lookup"><span data-stu-id="70674-146">The static <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> methods provide added flexibility when used in conjunction with the `FromAsync` methods.</span></span> <span data-ttu-id="70674-147">L'exemple suivant montre comment initialiser plusieurs opérations d'E/S asynchrones et attendre qu'elles soient toutes terminées avant d'exécuter la continuation.</span><span class="sxs-lookup"><span data-stu-id="70674-147">The following example shows how to initiate multiple asynchronous I/O operations, and then wait for all of them to complete before you execute the continuation.</span></span>  
  
 [!code-csharp[FromAsync#06](../../../samples/snippets/csharp/VS_Snippets_Misc/fromasync/cs/fromasync.cs#06)]
 [!code-vb[FromAsync#06](../../../samples/snippets/visualbasic/VS_Snippets_Misc/fromasync/vb/module1.vb#06)]  
  
### <a name="fromasync-tasks-for-only-the-end-method"></a><span data-ttu-id="70674-148">Tâches FromAsync pour la méthode End uniquement</span><span class="sxs-lookup"><span data-stu-id="70674-148">FromAsync Tasks For Only the End Method</span></span>  
 <span data-ttu-id="70674-149">Pour les rares cas dans lesquels la méthode `Begin` nécessite plus de trois paramètres d'entrée, ou a des paramètres `ref` ou `out`, vous pouvez utiliser les surcharges `FromAsync`, par exemple, <xref:System.Threading.Tasks.TaskFactory%601.FromAsync%28System.IAsyncResult%2CSystem.Func%7BSystem.IAsyncResult%2C%600%7D%29?displayProperty=nameWithType>, qui représentent uniquement la méthode `End`.</span><span class="sxs-lookup"><span data-stu-id="70674-149">For those few cases in which the `Begin` method requires more than three input parameters, or has `ref` or `out` parameters, you can use the `FromAsync` overloads, for example, <xref:System.Threading.Tasks.TaskFactory%601.FromAsync%28System.IAsyncResult%2CSystem.Func%7BSystem.IAsyncResult%2C%600%7D%29?displayProperty=nameWithType>, that represent only the `End` method.</span></span> <span data-ttu-id="70674-150">Ces méthodes peuvent également être utilisées pour tous les scénarios dans lesquels vous est passé un <xref:System.IAsyncResult> que vous voulez encapsuler dans une tâche.</span><span class="sxs-lookup"><span data-stu-id="70674-150">These methods can also be used in any scenario in which you are passed an <xref:System.IAsyncResult> and want to encapsulate it in a Task.</span></span>  
  
 [!code-csharp[FromAsync#07](../../../samples/snippets/csharp/VS_Snippets_Misc/fromasync/cs/fromasync.cs#07)]
 [!code-vb[FromAsync#07](../../../samples/snippets/visualbasic/VS_Snippets_Misc/fromasync/vb/module1.vb#07)]  
  
### <a name="starting-and-canceling-fromasync-tasks"></a><span data-ttu-id="70674-151">Lancement et annulation de tâches FromAsync</span><span class="sxs-lookup"><span data-stu-id="70674-151">Starting and Canceling FromAsync Tasks</span></span>  
 <span data-ttu-id="70674-152">La tâche retournée par une méthode `FromAsync` a l’état WaitingForActivation et sera lancée à un moment donné par le système après la création de la tâche.</span><span class="sxs-lookup"><span data-stu-id="70674-152">The task returned by a `FromAsync` method has a status of WaitingForActivation and will be started by the system at some point after the task is created.</span></span> <span data-ttu-id="70674-153">Si vous essayez d’appeler Start pour une telle tâche, une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="70674-153">If you attempt to call Start on such a task, an exception will be raised.</span></span>  
  
 <span data-ttu-id="70674-154">Vous ne pouvez pas annuler une tâche `FromAsync`, car les API .NET Framework sous-jacentes ne prennent actuellement pas en charge l’annulation d’opérations d’E/S réseau ou de fichier en cours.</span><span class="sxs-lookup"><span data-stu-id="70674-154">You cannot cancel a `FromAsync` task, because the underlying .NET Framework APIs currently do not support in-progress cancellation of file or network I/O.</span></span> <span data-ttu-id="70674-155">Vous pouvez ajouter des fonctionnalités d’annulation à une méthode qui encapsule un appel `FromAsync`, mais vous pouvez répondre uniquement à l’annulation avant que `FromAsync` soit appelé ou terminé (par exemple, dans une tâche de continuation).</span><span class="sxs-lookup"><span data-stu-id="70674-155">You can add cancellation functionality to a method that encapsulates a `FromAsync` call, but you can only respond to the cancellation before `FromAsync` is called or after it completed (for example, in a continuation task).</span></span>  
  
 <span data-ttu-id="70674-156">Certaines classes prenant en charge le modèle asynchrone basé sur des événements, comme <xref:System.Net.WebClient>, prennent en charge l'annulation et vous pouvez intégrer ces fonctionnalités d'annulation native à l'aide de jetons d'annulation.</span><span class="sxs-lookup"><span data-stu-id="70674-156">Some classes that support EAP, for example, <xref:System.Net.WebClient>, do support cancellation, and you can integrate that native cancellation functionality by using cancellation tokens.</span></span>  
  
## <a name="exposing-complex-eap-operations-as-tasks"></a><span data-ttu-id="70674-157">Exposition d’opérations complexes de modèle asynchrone basé sur des événements en tant que tâches</span><span class="sxs-lookup"><span data-stu-id="70674-157">Exposing Complex EAP Operations As Tasks</span></span>  
 <span data-ttu-id="70674-158">La bibliothèque parallèle de tâches ne fournit pas de méthodes conçues spécifiquement pour encapsuler une opération asynchrone basée sur des événements de la même façon que la famille `FromAsync` de méthodes encapsule le modèle <xref:System.IAsyncResult>.</span><span class="sxs-lookup"><span data-stu-id="70674-158">The TPL does not provide any methods that are specifically designed to encapsulate an event-based asynchronous operation in the same way that the `FromAsync` family of methods wrap the <xref:System.IAsyncResult> pattern.</span></span> <span data-ttu-id="70674-159">Toutefois, la bibliothèque parallèle de tâches fournit la classe <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType>, qui peut être utilisée pour représenter tout ensemble d'opérations arbitraire tel qu'un <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="70674-159">However, the TPL does provide the <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> class, which can be used to represent any arbitrary set of operations as a <xref:System.Threading.Tasks.Task%601>.</span></span> <span data-ttu-id="70674-160">Les opérations peuvent être synchrones ou asynchrones et peuvent être liées aux E/S ou orientées calcul, ou les deux.</span><span class="sxs-lookup"><span data-stu-id="70674-160">The operations may be synchronous or asynchronous, and may be I/O bound or compute-bound, or both.</span></span>  
  
 <span data-ttu-id="70674-161">L'exemple suivant montre comment utiliser un <xref:System.Threading.Tasks.TaskCompletionSource%601> pour exposer un ensemble d'opérations <xref:System.Net.WebClient> asynchrones à du code client en tant que <xref:System.Threading.Tasks.Task%601> de base.</span><span class="sxs-lookup"><span data-stu-id="70674-161">The following example shows how to use a <xref:System.Threading.Tasks.TaskCompletionSource%601> to expose a set of asynchronous <xref:System.Net.WebClient> operations to client code as a basic <xref:System.Threading.Tasks.Task%601>.</span></span> <span data-ttu-id="70674-162">Cette méthode vous permet d'entrer un tableau d'URL web et un terme ou nom à rechercher, puis retourne le nombre d'occurrences de ce terme ou nom sur chaque site.</span><span class="sxs-lookup"><span data-stu-id="70674-162">The method lets you enter an array of Web URLs, and a term or name to search for, and then returns the number of times the search term occurs on each site.</span></span>  
  
 [!code-csharp[FromAsync#10](../../../samples/snippets/csharp/VS_Snippets_Misc/fromasync/cs/snippet10.cs#10)]
 [!code-vb[FromAsync#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/fromasync/vb/snippet10.vb#10)]  
  
 <span data-ttu-id="70674-163">Pour obtenir un exemple plus complet incluant une gestion supplémentaire des exceptions et indiquant comment appeler la méthode depuis le code client, consultez [Guide pratique : Inclure dans un wrapper des modèles EAP dans une tâche](../../../docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md).</span><span class="sxs-lookup"><span data-stu-id="70674-163">For a more complete example, which includes additional exception handling and shows how to call the method from client code, see [How to: Wrap EAP Patterns in a Task](../../../docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md).</span></span>  
  
 <span data-ttu-id="70674-164">Souvenez-vous que toute tâche créée par un <xref:System.Threading.Tasks.TaskCompletionSource%601> sera lancée par ce TaskCompletionSource et que le code utilisateur ne doit donc pas appeler la méthode Start dans cette tâche.</span><span class="sxs-lookup"><span data-stu-id="70674-164">Remember that any task that is created by a <xref:System.Threading.Tasks.TaskCompletionSource%601> will be started by that TaskCompletionSource and, therefore, user code should not call the Start method on that task.</span></span>  
  
## <a name="implementing-the-apm-pattern-by-using-tasks"></a><span data-ttu-id="70674-165">Implémentation du modèle de programmation asynchrone à l’aide de tâches</span><span class="sxs-lookup"><span data-stu-id="70674-165">Implementing the APM Pattern By Using Tasks</span></span>  
 <span data-ttu-id="70674-166">Dans certains scénarios, il peut être souhaitable d’exposer directement le modèle <xref:System.IAsyncResult> à l’aide de paires de méthodes Begin/End dans une API.</span><span class="sxs-lookup"><span data-stu-id="70674-166">In some scenarios, it may be desirable to directly expose the <xref:System.IAsyncResult> pattern by using Begin/End method pairs in an API.</span></span> <span data-ttu-id="70674-167">Vous pouvez, par exemple, maintenir la cohérence avec les API existantes ou posséder des outils automatisés qui nécessitent ce modèle.</span><span class="sxs-lookup"><span data-stu-id="70674-167">For example, you may want to maintain consistency with existing APIs, or you may have automated tools that require this pattern.</span></span> <span data-ttu-id="70674-168">Dans de tels cas, vous pouvez utiliser des tâches pour simplifier l'implémentation en interne du modèle de programmation asynchrone.</span><span class="sxs-lookup"><span data-stu-id="70674-168">In such cases, you can use Tasks to simplify how the APM pattern is implemented internally.</span></span>  
  
 <span data-ttu-id="70674-169">L’exemple suivant montre comment utiliser des tâches pour implémenter une paire de méthodes de modèle de programmation asynchrone Begin/End pour une méthode orientée calcul de longue durée.</span><span class="sxs-lookup"><span data-stu-id="70674-169">The following example shows how to use tasks to implement an APM Begin/End method pair for a long-running compute-bound method.</span></span>  
  
 [!code-csharp[FromAsync#09](../../../samples/snippets/csharp/VS_Snippets_Misc/fromasync/cs/fromasync.cs#09)]
 [!code-vb[FromAsync#09](../../../samples/snippets/visualbasic/VS_Snippets_Misc/fromasync/vb/module1.vb#09)]  
  
## <a name="using-the-streamextensions-sample-code"></a><span data-ttu-id="70674-170">Utilisation de l'exemple de code StreamExtensions</span><span class="sxs-lookup"><span data-stu-id="70674-170">Using the StreamExtensions Sample Code</span></span>  
 <span data-ttu-id="70674-171">Le fichier Streamextensions.cs, dans [Exemples de programmation parallèle avec .NET Framework 4](https://code.msdn.microsoft.com/ParExtSamples), contient plusieurs implémentations de référence qui utilisent des objets Task pour des opérations d’E/S réseau ou de fichier asynchrones.</span><span class="sxs-lookup"><span data-stu-id="70674-171">The Streamextensions.cs file, in [Samples for Parallel Programming with the .NET Framework 4](https://code.msdn.microsoft.com/ParExtSamples), contains several reference implementations that use Task objects for asynchronous file and network I/O.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="70674-172">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="70674-172">See also</span></span>

- [<span data-ttu-id="70674-173">La bibliothèque parallèle de tâches</span><span class="sxs-lookup"><span data-stu-id="70674-173">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
