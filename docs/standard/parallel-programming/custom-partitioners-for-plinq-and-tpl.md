---
title: Partitionneurs personnalisés pour PLINQ et la bibliothèque parallèle de tâches (TPL)
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
ms.openlocfilehash: 8caea6d8a97b8c0daf7c59718479ea2e12a52d78
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/15/2020
ms.locfileid: "73141567"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="2a10c-102">Partitionneurs personnalisés pour PLINQ et la bibliothèque parallèle de tâches (TPL)</span><span class="sxs-lookup"><span data-stu-id="2a10c-102">Custom Partitioners for PLINQ and TPL</span></span>

<span data-ttu-id="2a10c-103">Pour paralléliser une opération sur une source de données, l’une des étapes essentielles consiste à *partitionner* la source en plusieurs sections accessibles simultanément par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="2a10c-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="2a10c-104">PLINQ et la bibliothèque parallèle de tâches (TPL) fournissent des partitionneurs par défaut qui fonctionnent de façon transparente lorsque vous écrivez une requête parallèle ou une boucle <xref:System.Threading.Tasks.Parallel.ForEach%2A>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="2a10c-105">Pour des scénarios plus élaborés, vous pouvez incorporer votre propre partitionneur.</span><span class="sxs-lookup"><span data-stu-id="2a10c-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>

## <a name="kinds-of-partitioning"></a><span data-ttu-id="2a10c-106">Types de partitionnement</span><span class="sxs-lookup"><span data-stu-id="2a10c-106">Kinds of Partitioning</span></span>

<span data-ttu-id="2a10c-107">Il existe de nombreuses façons de partitionner une source de données.</span><span class="sxs-lookup"><span data-stu-id="2a10c-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="2a10c-108">Dans les approches les plus efficaces, plusieurs threads coopèrent pour traiter la séquence source d’origine, au lieu de séparer physiquement la source en plusieurs sous-séquences.</span><span class="sxs-lookup"><span data-stu-id="2a10c-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="2a10c-109">Pour des tableaux et d’autres sources indexées telles que des collections <xref:System.Collections.IList> où la longueur est connue à l’avance, le *partitionnement par plage de valeurs* est le type de partitionnement le plus simple.</span><span class="sxs-lookup"><span data-stu-id="2a10c-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="2a10c-110">Chaque thread reçoit des index de début et de fin uniques pour pouvoir traiter sa plage de la source, sans remplacer ni être remplacé par un autre thread.</span><span class="sxs-lookup"><span data-stu-id="2a10c-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="2a10c-111">La seule surcharge impliquée dans le partitionnement par plage de valeurs est le travail initial consistant à créer les plages : aucune synchronisation supplémentaire n’est requise par la suite.</span><span class="sxs-lookup"><span data-stu-id="2a10c-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="2a10c-112">Par conséquent, cette méthode offre de bonnes performances tant que la charge de travail est répartie uniformément.</span><span class="sxs-lookup"><span data-stu-id="2a10c-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="2a10c-113">L’inconvénient du partitionnement par plage de valeurs réside dans le fait que si un thread se termine plus tôt, il ne peut pas aider les autres threads à terminer leur travail.</span><span class="sxs-lookup"><span data-stu-id="2a10c-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>

<span data-ttu-id="2a10c-114">Pour les listes liées ou d’autres collections dont la longueur n’est pas connue, vous pouvez utiliser le *partitionnement par segments*.</span><span class="sxs-lookup"><span data-stu-id="2a10c-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="2a10c-115">Dans le partitionnement par segments, chaque thread ou tâche d’une boucle parallèle ou d’une requête consomme un certain nombre d’éléments de la source dans un segment, les traite, puis revient pour extraire des éléments supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="2a10c-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="2a10c-116">Le partitionneur s’assure que tous les éléments sont distribués et qu’il n’y a pas de doublons.</span><span class="sxs-lookup"><span data-stu-id="2a10c-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="2a10c-117">Un segment peut être de n’importe quelle taille.</span><span class="sxs-lookup"><span data-stu-id="2a10c-117">A chunk may be any size.</span></span> <span data-ttu-id="2a10c-118">Par exemple, le partitionneur présenté dans la section [Guide pratique pour implémenter des partitions dynamiques](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) crée des segments qui ne contiennent qu’un seul élément.</span><span class="sxs-lookup"><span data-stu-id="2a10c-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="2a10c-119">Tant que les segments ne sont pas trop volumineux, ce type de partitionnement effectue, par nature, un équilibrage de charge car l’affectation des éléments aux threads n’est pas prédéfinie.</span><span class="sxs-lookup"><span data-stu-id="2a10c-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="2a10c-120">Cependant, le partitionneur déclenche la surcharge de synchronisation chaque fois que le thread a besoin d’un autre segment.</span><span class="sxs-lookup"><span data-stu-id="2a10c-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="2a10c-121">Le niveau de synchronisation effectué dans ce cas est inversement proportionnel à la taille des segments.</span><span class="sxs-lookup"><span data-stu-id="2a10c-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>

<span data-ttu-id="2a10c-122">En règle générale, le partitionnement par plage de valeurs n’est plus rapide que lorsque la durée d’exécution du délégué est faible à modérée, que la source comporte un grand nombre d’éléments, et que le travail total de chaque partition est à peu près équivalent.</span><span class="sxs-lookup"><span data-stu-id="2a10c-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="2a10c-123">Le partitionnement par segments est donc généralement plus rapide dans la plupart des cas.</span><span class="sxs-lookup"><span data-stu-id="2a10c-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="2a10c-124">Sur les sources comportant un petit nombre d’éléments ou avec des durées d’exécution plus longues pour le délégué, les performances du partitionnement par plage de valeurs et du partitionnement par segments sont équivalentes.</span><span class="sxs-lookup"><span data-stu-id="2a10c-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>

<span data-ttu-id="2a10c-125">Les partitionneurs TPL prennent également en charge un nombre dynamique de partitions.</span><span class="sxs-lookup"><span data-stu-id="2a10c-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="2a10c-126">Cela signifie qu’ils peuvent créer des partitions à la volée, par exemple lorsque la boucle <xref:System.Threading.Tasks.Parallel.ForEach%2A> génère une nouvelle tâche.</span><span class="sxs-lookup"><span data-stu-id="2a10c-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="2a10c-127">Cette fonctionnalité permet la mise à l’échelle du partitionneur par rapport à la boucle elle-même.</span><span class="sxs-lookup"><span data-stu-id="2a10c-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="2a10c-128">Par nature, les partitionneurs dynamiques effectuent également un équilibrage de charge.</span><span class="sxs-lookup"><span data-stu-id="2a10c-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="2a10c-129">Lorsque vous créez un partitionneur personnalisé, vous devez faire en sortie que le partitionnement dynamique soit utilisable par une boucle <xref:System.Threading.Tasks.Parallel.ForEach%2A>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>

### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="2a10c-130">Configuration des partitionneurs d’équilibrage de charge pour PLINQ</span><span class="sxs-lookup"><span data-stu-id="2a10c-130">Configuring Load Balancing Partitioners for PLINQ</span></span>

<span data-ttu-id="2a10c-131">Certaines surcharges de la méthode <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> vous permettent de créer un partitionneur pour un tableau ou une source <xref:System.Collections.IList> et de spécifier s’il doit tenter d’équilibrer la charge de travail entre les threads.</span><span class="sxs-lookup"><span data-stu-id="2a10c-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="2a10c-132">Lorsque le partitionneur est configuré pour l’équilibrage de charge, le partitionnement par segments est utilisé, et les éléments sont transmis, à la demande, par petits segments à chaque partition.</span><span class="sxs-lookup"><span data-stu-id="2a10c-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="2a10c-133">Cette approche garantit que toutes les partitions disposent d’éléments à traiter jusqu'à ce que la boucle ou la requête soit terminée.</span><span class="sxs-lookup"><span data-stu-id="2a10c-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="2a10c-134">Une surcharge supplémentaire peut être utilisée pour fournir le partitionnement d’équilibrage de charge de n’importe quelle source <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>

<span data-ttu-id="2a10c-135">En général, l’équilibrage de charge requiert que les partitions sollicitent fréquemment le partitionneur pour obtenir des éléments.</span><span class="sxs-lookup"><span data-stu-id="2a10c-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="2a10c-136">En revanche, un partitionneur qui effectue un partitionnement statique peut affecter les éléments à chaque partitionneur en même temps à l’aide d’un partitionnement par plage de valeurs ou par segments.</span><span class="sxs-lookup"><span data-stu-id="2a10c-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="2a10c-137">Cette méthode nécessite moins de surcharge que l’équilibrage de charge, mais elle peut prendre plus de temps à s’exécuter si un thread se retrouve avec beaucoup plus de travail que les autres.</span><span class="sxs-lookup"><span data-stu-id="2a10c-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="2a10c-138">Par défaut, lorsqu’il reçoit un objet IList ou un tableau, PLINQ utilise toujours le partitionnement par plage de valeurs sans équilibrage de charge.</span><span class="sxs-lookup"><span data-stu-id="2a10c-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="2a10c-139">Pour activer l’équilibrage de charge pour PLINQ, utilisez la méthode `Partitioner.Create`, comme indiqué dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="2a10c-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>

[!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
[!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]

<span data-ttu-id="2a10c-140">La meilleure méthode pour déterminer si vous devez utiliser l’équilibrage de charge dans un scénario donné consiste à faire des essais et à mesurer la durée des opérations avec des charges et des configurations d’ordinateur représentatives.</span><span class="sxs-lookup"><span data-stu-id="2a10c-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="2a10c-141">Par exemple, le partitionnement statique peut accélérer considérablement les opérations sur un ordinateur multicœur doté de quelques cœurs, mais il peut entraîner des ralentissements sur les ordinateurs qui disposent de nombreux cœurs.</span><span class="sxs-lookup"><span data-stu-id="2a10c-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>

<span data-ttu-id="2a10c-142">Le tableau ci-dessous répertorie les surcharges disponibles avec la méthode <xref:System.Collections.Concurrent.Partitioner.Create%2A>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="2a10c-143">L’utilisation de ces partitionneurs ne se limite pas à PLINQ ou à <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="2a10c-144">Ils peuvent également être utilisés avec n’importe quelle construction parallèle personnalisée.</span><span class="sxs-lookup"><span data-stu-id="2a10c-144">They can also be used with any custom parallel construct.</span></span>

|<span data-ttu-id="2a10c-145">Surcharge</span><span class="sxs-lookup"><span data-stu-id="2a10c-145">Overload</span></span>|<span data-ttu-id="2a10c-146">Utiliser l'équilibrage de charge</span><span class="sxs-lookup"><span data-stu-id="2a10c-146">Uses load balancing</span></span>|
|--------------|-------------------------|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="2a10c-147">Toujours</span><span class="sxs-lookup"><span data-stu-id="2a10c-147">Always</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="2a10c-148">Lorsque l’argument booléen est spécifié comme true</span><span class="sxs-lookup"><span data-stu-id="2a10c-148">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="2a10c-149">Lorsque l’argument booléen est spécifié comme true</span><span class="sxs-lookup"><span data-stu-id="2a10c-149">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="2a10c-150">Jamais</span><span class="sxs-lookup"><span data-stu-id="2a10c-150">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="2a10c-151">Jamais</span><span class="sxs-lookup"><span data-stu-id="2a10c-151">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="2a10c-152">Jamais</span><span class="sxs-lookup"><span data-stu-id="2a10c-152">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="2a10c-153">Jamais</span><span class="sxs-lookup"><span data-stu-id="2a10c-153">Never</span></span>|

### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="2a10c-154">Configuration de partitionneurs de plages statiques pour Parallel.ForEach</span><span class="sxs-lookup"><span data-stu-id="2a10c-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>

<span data-ttu-id="2a10c-155">Dans une boucle <xref:System.Threading.Tasks.Parallel.For%2A>, le corps de la boucle est transmis à la méthode en tant que délégué.</span><span class="sxs-lookup"><span data-stu-id="2a10c-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="2a10c-156">Le coût d’un appel à ce délégué est équivalent à celui d’un appel à une méthode virtuelle.</span><span class="sxs-lookup"><span data-stu-id="2a10c-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="2a10c-157">Dans certains scénarios, le corps d’une boucle parallèle peut être suffisamment petit de sorte que le coût d’un appel au délégué sur chaque itération de la boucle devient important.</span><span class="sxs-lookup"><span data-stu-id="2a10c-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="2a10c-158">Dans ce cas, vous pouvez utiliser une des surcharges <xref:System.Collections.Concurrent.Partitioner.Create%2A> pour créer un objet <xref:System.Collections.Generic.IEnumerable%601> de partitions par plages de valeurs sur les éléments sources.</span><span class="sxs-lookup"><span data-stu-id="2a10c-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="2a10c-159">Vous pouvez ensuite transmettre cette collection de plages de valeurs à une méthode <xref:System.Threading.Tasks.Parallel.ForEach%2A> dont le corps se compose d’une boucle `for` standard.</span><span class="sxs-lookup"><span data-stu-id="2a10c-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="2a10c-160">L’avantage de cette approche est que le coût d’un appel au délégué n’est généré qu’une seule fois par plage au lieu d’une seule fois par élément.</span><span class="sxs-lookup"><span data-stu-id="2a10c-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="2a10c-161">L'exemple suivant illustre le modèle de base.</span><span class="sxs-lookup"><span data-stu-id="2a10c-161">The following example demonstrates the basic pattern.</span></span>

[!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
[!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]

<span data-ttu-id="2a10c-162">Chaque thread de la boucle reçoit son propre objet <xref:System.Tuple%602>, qui contient les valeurs d’index de début et de fin dans la sous-plage spécifiée.</span><span class="sxs-lookup"><span data-stu-id="2a10c-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="2a10c-163">La boucle `for` interne utilise les valeurs `fromInclusive` et `toExclusive` pour parcourir le tableau ou <xref:System.Collections.IList> directement.</span><span class="sxs-lookup"><span data-stu-id="2a10c-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>

<span data-ttu-id="2a10c-164">Une des surcharges <xref:System.Collections.Concurrent.Partitioner.Create%2A> vous permet de spécifier la taille des partitions ainsi que leur nombre.</span><span class="sxs-lookup"><span data-stu-id="2a10c-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="2a10c-165">Cette surcharge peut être utilisée dans des scénarios où le travail par élément est si faible que même un appel à une méthode virtuelle par élément a un impact perceptible sur les performances.</span><span class="sxs-lookup"><span data-stu-id="2a10c-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="2a10c-166">Partitionneurs personnalisés</span><span class="sxs-lookup"><span data-stu-id="2a10c-166">Custom Partitioners</span></span>

<span data-ttu-id="2a10c-167">Dans certains scénarios, il peut être utile ou même obligatoire d’implémenter votre propre partitionneur.</span><span class="sxs-lookup"><span data-stu-id="2a10c-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="2a10c-168">Par exemple, vous pouvez partionner une classe de collection personnalisée plus efficacement qu’avec les partitionneurs par défaut, selon votre connaissance de la structure interne de la classe.</span><span class="sxs-lookup"><span data-stu-id="2a10c-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="2a10c-169">Ou vous pouvez créer des partitions de plages de valeurs de tailles différentes en fonction du temps nécessaire pour traiter les éléments situés en différents emplacements de la collection source.</span><span class="sxs-lookup"><span data-stu-id="2a10c-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>

<span data-ttu-id="2a10c-170">Pour créer un partitionneur personnalisé de base, dérivez une classe de <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> puis remplacez les méthodes virtuelles, comme décrit dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="2a10c-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="2a10c-171">Cette méthode est appelée une fois par le thread principal et retourne un objet IList(IEnumerator(TSource)).</span><span class="sxs-lookup"><span data-stu-id="2a10c-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="2a10c-172">Chaque thread de travail dans la boucle ou la requête peut appeler `GetEnumerator` sur la liste pour récupérer un objet <xref:System.Collections.Generic.IEnumerator%601> sur une partition distincte.</span><span class="sxs-lookup"><span data-stu-id="2a10c-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="2a10c-173">Retournez `true` si vous implémentez <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, et `false` dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="2a10c-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="2a10c-174">Si <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> est `true`, cette méthode peut éventuellement être appelée à la place de <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="2a10c-175">Si les résultats doivent pouvoir être triés ou que vous avez besoin d’un accès indexé aux éléments, dérivez <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> et remplacez ses méthodes virtuelles, comme décrit dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="2a10c-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="2a10c-176">Cette méthode est appelée une fois par le thread principal et retourne un objet `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="2a10c-177">Chaque thread de travail dans la boucle ou la requête peut appeler `GetEnumerator` sur la liste pour récupérer un objet <xref:System.Collections.Generic.IEnumerator%601> sur une partition distincte.</span><span class="sxs-lookup"><span data-stu-id="2a10c-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="2a10c-178">Retournez `true` si vous implémentez <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>, et false dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="2a10c-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="2a10c-179">En règle générale, cette méthode appelle simplement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="2a10c-180">Si <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> est `true`, cette méthode peut éventuellement être appelée à la place de <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="2a10c-181">Le tableau suivant fournit des détails supplémentaires sur la façon dont les trois types de partitionneurs d’équilibrage de charge implémentent la classe <xref:System.Collections.Concurrent.OrderablePartitioner%601>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>

|<span data-ttu-id="2a10c-182">Méthode/propriété</span><span class="sxs-lookup"><span data-stu-id="2a10c-182">Method/Property</span></span>|<span data-ttu-id="2a10c-183">IList / tableau sans équilibrage de charge</span><span class="sxs-lookup"><span data-stu-id="2a10c-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="2a10c-184">IList / tableau avec équilibrage de charge</span><span class="sxs-lookup"><span data-stu-id="2a10c-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="2a10c-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="2a10c-185">IEnumerable</span></span>|
|----------------------|-------------------------------------------|----------------------------------------|-----------------|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="2a10c-186">Utilise le partitionnement par plages de valeurs</span><span class="sxs-lookup"><span data-stu-id="2a10c-186">Uses range partitioning</span></span>|<span data-ttu-id="2a10c-187">Utilise le partitionnement par segments, optimisé pour les listes, pour la valeur partitionCount spécifiée</span><span class="sxs-lookup"><span data-stu-id="2a10c-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="2a10c-188">Utilise le partitionnement par segments en créant un nombre statique de partitions.</span><span class="sxs-lookup"><span data-stu-id="2a10c-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="2a10c-189">Lève une exception non prise en charge</span><span class="sxs-lookup"><span data-stu-id="2a10c-189">Throws not-supported exception</span></span>|<span data-ttu-id="2a10c-190">Utilise le partitionnement par segments, optimisé pour les listes, pour les partitions dynamiques</span><span class="sxs-lookup"><span data-stu-id="2a10c-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="2a10c-191">Utilise le partitionnement par segments en créant un nombre dynamique de partitions.</span><span class="sxs-lookup"><span data-stu-id="2a10c-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="2a10c-192">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-192">Returns `true`</span></span>|<span data-ttu-id="2a10c-193">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-193">Returns `true`</span></span>|<span data-ttu-id="2a10c-194">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-194">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="2a10c-195">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-195">Returns `true`</span></span>|<span data-ttu-id="2a10c-196">Retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-196">Returns `false`</span></span>|<span data-ttu-id="2a10c-197">Retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-197">Returns `false`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="2a10c-198">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-198">Returns `true`</span></span>|<span data-ttu-id="2a10c-199">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-199">Returns `true`</span></span>|<span data-ttu-id="2a10c-200">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-200">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="2a10c-201">Retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-201">Returns `false`</span></span>|<span data-ttu-id="2a10c-202">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-202">Returns `true`</span></span>|<span data-ttu-id="2a10c-203">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-203">Returns `true`</span></span>|

### <a name="dynamic-partitions"></a><span data-ttu-id="2a10c-204">Partitions dynamiques</span><span class="sxs-lookup"><span data-stu-id="2a10c-204">Dynamic Partitions</span></span>

<span data-ttu-id="2a10c-205">Si vous envisagez d’utiliser le partitionneur dans une méthode <xref:System.Threading.Tasks.Parallel.ForEach%2A>, vous devez être en mesure de retourner un nombre dynamique de partitions.</span><span class="sxs-lookup"><span data-stu-id="2a10c-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="2a10c-206">Cela signifie que le partitionneur peut fournir un énumérateur pour une nouvelle partition, à la demande et à tout moment pendant l’exécution de la boucle.</span><span class="sxs-lookup"><span data-stu-id="2a10c-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="2a10c-207">En fait, chaque fois que la boucle ajoute une nouvelle tâche parallèle, elle demande une nouvelle partition pour cette tâche.</span><span class="sxs-lookup"><span data-stu-id="2a10c-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="2a10c-208">Si vous avez besoin de pouvoir classer les données, effectuez une dérivation <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> afin d’affecter un index unique à chaque élément de chaque partition.</span><span class="sxs-lookup"><span data-stu-id="2a10c-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>

<span data-ttu-id="2a10c-209">Pour plus d’informations et consulter un exemple, voir [Guide pratique pour implémenter des partitions dynamiques](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="2a10c-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>

### <a name="contract-for-partitioners"></a><span data-ttu-id="2a10c-210">Contrat pour les partitionneurs</span><span class="sxs-lookup"><span data-stu-id="2a10c-210">Contract for Partitioners</span></span>

<span data-ttu-id="2a10c-211">Lorsque vous implémentez un partitionneur personnalisé, suivez ces instructions pour garantir une interaction correcte avec PLINQ et <xref:System.Threading.Tasks.Parallel.ForEach%2A> dans la bibliothèque parallèle de tâches (TPL) :</span><span class="sxs-lookup"><span data-stu-id="2a10c-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>

- <span data-ttu-id="2a10c-212">Si <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> est appelé avec un argument de zéro ou moins pour `partitionsCount`, levez <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="2a10c-213">Bien que PLINQ et TPL ne fourniront jamais une valeur `partitionCount` égale à 0, nous vous recommandons néanmoins de vous prémunir contre ce risque.</span><span class="sxs-lookup"><span data-stu-id="2a10c-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>

- <span data-ttu-id="2a10c-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> et <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> devraient toujours renvoyer un nombre de partitions équivalant à `partitionsCount`.</span><span class="sxs-lookup"><span data-stu-id="2a10c-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="2a10c-215">Si le partitionneur manque de données et ne peut pas créer autant de partitions que demandé, la méthode devrait retourner un énumérateur vide pour chacune des partitions restantes.</span><span class="sxs-lookup"><span data-stu-id="2a10c-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="2a10c-216">Sinon, PLINQ et TPL lèveront une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="2a10c-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, et <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> ne devraient jamais retourner `null` (`Nothing` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2a10c-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="2a10c-218">Si tel est le cas, PLINQ/TPL lèveront une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="2a10c-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="2a10c-219">Les méthodes qui retournent des partitions devraient toujours renvoyer des partitions capables d’énumérer totalement et de manière unique la source de données.</span><span class="sxs-lookup"><span data-stu-id="2a10c-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="2a10c-220">Il ne devrait y avoir aucune duplication dans la source de données ou les éléments ignorés, sauf si cela est spécifiquement requis par la conception du partitionneur.</span><span class="sxs-lookup"><span data-stu-id="2a10c-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="2a10c-221">Si cette règle n’est pas suivie, l’ordre de sortie peut être brouillé.</span><span class="sxs-lookup"><span data-stu-id="2a10c-221">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="2a10c-222">Les accesseurs booléens suivants doivent toujours retourner correctement les valeurs ci-dessous afin que l’ordre de sortie ne soit pas brouillé :</span><span class="sxs-lookup"><span data-stu-id="2a10c-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>

  - <span data-ttu-id="2a10c-223">`KeysOrderedInEachPartition` : chaque partition retourne des éléments en augmentant les index clés.</span><span class="sxs-lookup"><span data-stu-id="2a10c-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>

  - <span data-ttu-id="2a10c-224">`KeysOrderedAcrossPartitions` : pour toutes les partitions retournées, les index clés dans la partition *i* sont plus élevés que les index clés de la partition *i*-1.</span><span class="sxs-lookup"><span data-stu-id="2a10c-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>

  - <span data-ttu-id="2a10c-225">`KeysNormalized`: tous les index clés augmentent de monotone, sans écarts, à partir de zéro.</span><span class="sxs-lookup"><span data-stu-id="2a10c-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>

- <span data-ttu-id="2a10c-226">Tous les index doivent être uniques.</span><span class="sxs-lookup"><span data-stu-id="2a10c-226">All indices must be unique.</span></span> <span data-ttu-id="2a10c-227">Il ne doit pas y avoir de doublons.</span><span class="sxs-lookup"><span data-stu-id="2a10c-227">There may not be duplicate indices.</span></span> <span data-ttu-id="2a10c-228">Si cette règle n’est pas suivie, l’ordre de sortie peut être brouillé.</span><span class="sxs-lookup"><span data-stu-id="2a10c-228">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="2a10c-229">Tous les index doivent être non négatifs.</span><span class="sxs-lookup"><span data-stu-id="2a10c-229">All indices must be nonnegative.</span></span> <span data-ttu-id="2a10c-230">Si cette règle n’est pas suivie, PLINQ/TPL peuvent lever des exceptions.</span><span class="sxs-lookup"><span data-stu-id="2a10c-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>

## <a name="see-also"></a><span data-ttu-id="2a10c-231">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="2a10c-231">See also</span></span>

- [<span data-ttu-id="2a10c-232">Programmation parallèle</span><span class="sxs-lookup"><span data-stu-id="2a10c-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="2a10c-233">Comment : implémenter des partitions dynamiques</span><span class="sxs-lookup"><span data-stu-id="2a10c-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="2a10c-234">Comment : implémenter un partitionneur pour un partitionnement statique</span><span class="sxs-lookup"><span data-stu-id="2a10c-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
