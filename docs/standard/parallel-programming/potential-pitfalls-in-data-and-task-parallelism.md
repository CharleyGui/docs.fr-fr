---
title: Pièges potentiels dans le parallélisme des données et des tâches
description: Découvrez les pièges potentiels dans le parallélisme des données et des tâches, car le parallélisme augmente la complexité qui n’est pas rencontrée dans le code séquentiel.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallel programming, pitfalls
ms.assetid: 1e357177-e699-4b8f-9e49-56d3513ed128
ms.openlocfilehash: c66eae48df54b330843b4967f957264f2bddee1d
ms.sourcegitcommit: 6d09ae36acba0b0e2ba47999f8f1a725795462a2
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/29/2020
ms.locfileid: "92925309"
---
# <a name="potential-pitfalls-in-data-and-task-parallelism"></a><span data-ttu-id="55b57-103">Pièges potentiels dans le parallélisme des données et des tâches</span><span class="sxs-lookup"><span data-stu-id="55b57-103">Potential Pitfalls in Data and Task Parallelism</span></span>
<span data-ttu-id="55b57-104">Dans de nombreux cas, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> et <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> permettent une amélioration significative des performances par rapport à des boucles séquentielles ordinaires.</span><span class="sxs-lookup"><span data-stu-id="55b57-104">In many cases, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> can provide significant performance improvements over ordinary sequential loops.</span></span> <span data-ttu-id="55b57-105">Toutefois, le travail de la parallélisation de la boucle présente une certaine complexité pouvant entraîner des problèmes qui, dans du code séquentiel, ne sont pas si courants ou ne surviennent pas du tout.</span><span class="sxs-lookup"><span data-stu-id="55b57-105">However, the work of parallelizing the loop introduces complexity that can lead to problems that, in sequential code, are not as common or are not encountered at all.</span></span> <span data-ttu-id="55b57-106">Cette rubrique répertorie les pratiques à éviter lorsque vous écrivez des boucles parallèles.</span><span class="sxs-lookup"><span data-stu-id="55b57-106">This topic lists some practices to avoid when you write parallel loops.</span></span>  
  
## <a name="do-not-assume-that-parallel-is-always-faster"></a><span data-ttu-id="55b57-107">Ne partez pas du principe qu’une boucle parallèle est toujours plus rapide</span><span class="sxs-lookup"><span data-stu-id="55b57-107">Do Not Assume That Parallel Is Always Faster</span></span>  
 <span data-ttu-id="55b57-108">Dans certains cas, elle peut s’exécuter plus lentement qu’une boucle séquentielle équivalente.</span><span class="sxs-lookup"><span data-stu-id="55b57-108">In certain cases a parallel loop might run slower than its sequential equivalent.</span></span> <span data-ttu-id="55b57-109">La règle empirique de base veut que les boucles parallèles ayant peu d’itérations et des délégués utilisateurs rapides ne soient pas susceptibles d’apporter une grande accélération.</span><span class="sxs-lookup"><span data-stu-id="55b57-109">The basic rule of thumb is that parallel loops that have few iterations and fast user delegates are unlikely to speedup much.</span></span> <span data-ttu-id="55b57-110">Toutefois, étant donné que de nombreux facteurs sont impliqués dans les performances, nous vous recommandons de toujours mesurer les résultats réels.</span><span class="sxs-lookup"><span data-stu-id="55b57-110">However, because many factors are involved in performance, we recommend that you always measure actual results.</span></span>  
  
## <a name="avoid-writing-to-shared-memory-locations"></a><span data-ttu-id="55b57-111">Éviter d’écrire à des emplacements de mémoire partagés</span><span class="sxs-lookup"><span data-stu-id="55b57-111">Avoid Writing to Shared Memory Locations</span></span>  
 <span data-ttu-id="55b57-112">Dans du code séquentiel, il n’est pas rare de lire des variables statiques ou d’écrire dans ces dernières ou dans des champs de classe.</span><span class="sxs-lookup"><span data-stu-id="55b57-112">In sequential code, it is not uncommon to read from or write to static variables or class fields.</span></span> <span data-ttu-id="55b57-113">Toutefois, l’accès simultané de plusieurs threads à de telles variables entraîne un fort risque d’engorgement.</span><span class="sxs-lookup"><span data-stu-id="55b57-113">However, whenever multiple threads are accessing such variables concurrently, there is a big potential for race conditions.</span></span> <span data-ttu-id="55b57-114">Bien que vous puissiez utiliser des verrous pour synchroniser l’accès à la variable, le coût de synchronisation peut nuire aux performances.</span><span class="sxs-lookup"><span data-stu-id="55b57-114">Even though you can use locks to synchronize access to the variable, the cost of synchronization can hurt performance.</span></span> <span data-ttu-id="55b57-115">Par conséquent, nous vous recommandons d’éviter, ou au moins de limiter autant que possible l’accès à un état partagé dans une boucle parallèle.</span><span class="sxs-lookup"><span data-stu-id="55b57-115">Therefore, we recommend that you avoid, or at least limit, access to shared state in a parallel loop as much as possible.</span></span> <span data-ttu-id="55b57-116">La meilleure façon de procéder consiste à utiliser les surcharges de <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> et <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> qui utilisent une variable <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> pour stocker l’état local du thread pendant l’exécution de la boucle.</span><span class="sxs-lookup"><span data-stu-id="55b57-116">The best way to do this is to use the overloads of <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> that use a <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> variable to store thread-local state during loop execution.</span></span> <span data-ttu-id="55b57-117">Pour plus d’informations, consultez [Guide pratique pour écrire une boucle Parallel.For avec des variables locales de thread](how-to-write-a-parallel-for-loop-with-thread-local-variables.md) et [Guide pratique pour écrire une boucle Parallel.ForEach avec des variables locales de partition](how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="55b57-117">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="avoid-over-parallelization"></a><span data-ttu-id="55b57-118">Éviter la surparallélisation</span><span class="sxs-lookup"><span data-stu-id="55b57-118">Avoid Over-Parallelization</span></span>  
 <span data-ttu-id="55b57-119">L’utilisation de boucles parallèles entraîne des coûts de surcharge liés au partitionnement de la collection source et à la synchronisation des threads de travail.</span><span class="sxs-lookup"><span data-stu-id="55b57-119">By using parallel loops, you incur the overhead costs of partitioning the source collection and synchronizing the worker threads.</span></span> <span data-ttu-id="55b57-120">Les avantages de la parallélisation sont également limités par le nombre de processeurs de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="55b57-120">The benefits of parallelization are further limited by the number of processors on the computer.</span></span> <span data-ttu-id="55b57-121">L’exécution de plusieurs threads liés au calcul sur un seul processeur ne permet aucune accélération.</span><span class="sxs-lookup"><span data-stu-id="55b57-121">There is no speedup to be gained by running multiple compute-bound threads on just one processor.</span></span> <span data-ttu-id="55b57-122">Par conséquent, vous devez veiller à ne pas surparalléliser une boucle.</span><span class="sxs-lookup"><span data-stu-id="55b57-122">Therefore, you must be careful not to over-parallelize a loop.</span></span>  
  
 <span data-ttu-id="55b57-123">Les boucles imbriquées sont le scénario le plus courant dans lequel une surparallélisation peut se produire.</span><span class="sxs-lookup"><span data-stu-id="55b57-123">The most common scenario in which over-parallelization can occur is in nested loops.</span></span> <span data-ttu-id="55b57-124">Dans la plupart des cas, il est préférable de paralléliser uniquement la boucle externe, sauf si une ou plusieurs conditions suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="55b57-124">In most cases, it is best to parallelize only the outer loop unless one or more of the following conditions apply:</span></span>  
  
- <span data-ttu-id="55b57-125">La boucle interne est réputée être très longue.</span><span class="sxs-lookup"><span data-stu-id="55b57-125">The inner loop is known to be very long.</span></span>  
  
- <span data-ttu-id="55b57-126">Vous effectuez un calcul coûteux sur chaque commande.</span><span class="sxs-lookup"><span data-stu-id="55b57-126">You are performing an expensive computation on each order.</span></span> <span data-ttu-id="55b57-127">(l’opération montrée dans l’exemple n’est pas coûteuse)</span><span class="sxs-lookup"><span data-stu-id="55b57-127">(The operation shown in the example is not expensive.)</span></span>  
  
- <span data-ttu-id="55b57-128">Le système cible est connu pour avoir suffisamment de processeurs pour gérer le nombre de threads produits en parallélisant la requête sur `cust.Orders`.</span><span class="sxs-lookup"><span data-stu-id="55b57-128">The target system is known to have enough processors to handle the number of threads that will be produced by parallelizing the query on `cust.Orders`.</span></span>  
  
 <span data-ttu-id="55b57-129">Dans tous les cas, le test et la mesure sont la meilleure façon de déterminer la forme de requête optimale.</span><span class="sxs-lookup"><span data-stu-id="55b57-129">In all cases, the best way to determine the optimum query shape is to test and measure.</span></span>  
  
## <a name="avoid-calls-to-non-thread-safe-methods"></a><span data-ttu-id="55b57-130">Éviter de faire appel aux méthodes qui ne sont pas thread-safe</span><span class="sxs-lookup"><span data-stu-id="55b57-130">Avoid Calls to Non-Thread-Safe Methods</span></span>  
 <span data-ttu-id="55b57-131">L’écriture dans des méthodes d’instance qui ne sont pas thread-safe à partir d’une boucle parallèle peut entraîner une corruption des données qui peut être détectée ou non dans votre programme.</span><span class="sxs-lookup"><span data-stu-id="55b57-131">Writing to non-thread-safe instance methods from a parallel loop can lead to data corruption which may or may not go undetected in your program.</span></span> <span data-ttu-id="55b57-132">Cela peut également entraîner des exceptions.</span><span class="sxs-lookup"><span data-stu-id="55b57-132">It can also lead to exceptions.</span></span> <span data-ttu-id="55b57-133">Dans l’exemple suivant, plusieurs threads tenteraient d’appeler simultanément la méthode <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType>, qui n’est pas prise en charge par la classe.</span><span class="sxs-lookup"><span data-stu-id="55b57-133">In the following example, multiple threads would be attempting to call the <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType> method simultaneously, which is not supported by the class.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#04](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#04)]
 [!code-vb[TPL_Pitfalls#04](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#04)]  
  
## <a name="limit-calls-to-thread-safe-methods"></a><span data-ttu-id="55b57-134">Limiter les appels aux méthodes qui ne sont pas thread-safe</span><span class="sxs-lookup"><span data-stu-id="55b57-134">Limit Calls to Thread-Safe Methods</span></span>  
 <span data-ttu-id="55b57-135">La plupart des méthodes statiques dans .NET sont thread-safe et peuvent être appelées à partir de plusieurs threads simultanément.</span><span class="sxs-lookup"><span data-stu-id="55b57-135">Most static methods in .NET are thread-safe and can be called from multiple threads concurrently.</span></span> <span data-ttu-id="55b57-136">Toutefois, même dans ces cas, la synchronisation impliquée peut entraîner un ralentissement significatif de la requête.</span><span class="sxs-lookup"><span data-stu-id="55b57-136">However, even in these cases, the synchronization involved can lead to significant slowdown in the query.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="55b57-137">Vous pouvez le tester vous-même en insérant des appels à <xref:System.Console.WriteLine%2A> dans vos requêtes.</span><span class="sxs-lookup"><span data-stu-id="55b57-137">You can test for this yourself by inserting some calls to <xref:System.Console.WriteLine%2A> in your queries.</span></span> <span data-ttu-id="55b57-138">Bien que cette méthode soit utilisée dans les exemples de documentation destinés à la démonstration, ne l’utilisez pas dans les boucles parallèles, sauf si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="55b57-138">Although this method is used in the documentation examples for demonstration purposes, do not use it in parallel loops unless necessary.</span></span>  
  
## <a name="be-aware-of-thread-affinity-issues"></a><span data-ttu-id="55b57-139">Tenir compte des problèmes d’affinité de thread</span><span class="sxs-lookup"><span data-stu-id="55b57-139">Be Aware of Thread Affinity Issues</span></span>  
 <span data-ttu-id="55b57-140">Certaines technologies, par exemple, les composants STA (Single-Threaded Apartment), Windows Forms et Windows Presentation Foundation (WPF) imposent des restrictions d’affinité de thread qui requièrent l’exécution de code sur un thread spécifique.</span><span class="sxs-lookup"><span data-stu-id="55b57-140">Some technologies, for example, COM interoperability for Single-Threaded Apartment (STA) components, Windows Forms, and Windows Presentation Foundation (WPF), impose thread affinity restrictions that require code to run on a specific thread.</span></span> <span data-ttu-id="55b57-141">Par exemple, dans Windows Forms et WPF, un contrôle est uniquement accessible sur le thread sur lequel il a été créé.</span><span class="sxs-lookup"><span data-stu-id="55b57-141">For example, in both Windows Forms and WPF, a control can only be accessed on the thread on which it was created.</span></span> <span data-ttu-id="55b57-142">Cela signifie, par exemple, que vous ne pouvez pas mettre à jour un contrôle de liste à partir d’une boucle parallèle, sauf si vous configurez le planificateur de threads de sorte qu’il planifie le travail uniquement sur le thread d’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="55b57-142">This means, for example, that you cannot update a list control from a parallel loop unless you configure the thread scheduler to schedule work only on the UI thread.</span></span> <span data-ttu-id="55b57-143">Pour plus d’informations, consultez [Spécification d’un contexte de synchronisation](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context).</span><span class="sxs-lookup"><span data-stu-id="55b57-143">For more information, see [Specifying a synchronization context](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context).</span></span>  
  
## <a name="use-caution-when-waiting-in-delegates-that-are-called-by-parallelinvoke"></a><span data-ttu-id="55b57-144">Être vigilant lors de l’attente dans des délégués appelés par Parallel.Invoke</span><span class="sxs-lookup"><span data-stu-id="55b57-144">Use Caution When Waiting in Delegates That Are Called by Parallel.Invoke</span></span>  
 <span data-ttu-id="55b57-145">Dans certaines circonstances, la bibliothèque parallèle de tâches intègre une tâche, ce qui signifie qu’elle s’exécute sur la tâche du thread en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="55b57-145">In certain circumstances, the Task Parallel Library will inline a task, which means it runs on the task on the currently executing thread.</span></span> <span data-ttu-id="55b57-146">(Pour plus d’informations, consultez [planificateurs de tâches](xref:System.Threading.Tasks.TaskScheduler).) Cette optimisation des performances peut entraîner un blocage dans certains cas.</span><span class="sxs-lookup"><span data-stu-id="55b57-146">(For more information, see [Task Schedulers](xref:System.Threading.Tasks.TaskScheduler).) This performance optimization can lead to deadlock in certain cases.</span></span> <span data-ttu-id="55b57-147">Par exemple, deux tâches peuvent exécuter le même code de délégué, qui signale la survenue d’un événement et attend l’autre tâche à signaler.</span><span class="sxs-lookup"><span data-stu-id="55b57-147">For example, two tasks might run the same delegate code, which signals when an event occurs, and then waits for the other task to signal.</span></span> <span data-ttu-id="55b57-148">Si la seconde tâche est incluse sur le même thread que la première et que cette dernière passe à l’état En attente, la seconde tâche ne pourra jamais signaler son événement.</span><span class="sxs-lookup"><span data-stu-id="55b57-148">If the second task is inlined on the same thread as the first, and the first goes into a Wait state, the second task will never be able to signal its event.</span></span> <span data-ttu-id="55b57-149">Pour éviter une telle situation, vous pouvez spécifier un délai d’expiration sur l’opération d’attente, ou utiliser les constructeurs de thread explicites pour s’assurer qu’une tâche ne peut pas bloquer l’autre.</span><span class="sxs-lookup"><span data-stu-id="55b57-149">To avoid such an occurrence, you can specify a timeout on the Wait operation, or use explicit thread constructors to help ensure that one task cannot block the other.</span></span>  
  
## <a name="do-not-assume-that-iterations-of-foreach-for-and-forall-always-execute-in-parallel"></a><span data-ttu-id="55b57-150">Ne pas supposer que les itérations de ForEach, For et ForAll s’exécutent toujours en parallèle</span><span class="sxs-lookup"><span data-stu-id="55b57-150">Do Not Assume that Iterations of ForEach, For and ForAll Always Execute in Parallel</span></span>  
 <span data-ttu-id="55b57-151">Il est important de garder à l’esprit que les itérations individuelles dans une boucle <xref:System.Threading.Tasks.Parallel.For%2A>, <xref:System.Threading.Tasks.Parallel.ForEach%2A> ou <xref:System.Linq.ParallelEnumerable.ForAll%2A> peuvent, mais ne doivent pas forcément, s’exécuter en parallèle.</span><span class="sxs-lookup"><span data-stu-id="55b57-151">It is important to keep in mind that individual iterations in a <xref:System.Threading.Tasks.Parallel.For%2A>, <xref:System.Threading.Tasks.Parallel.ForEach%2A> or <xref:System.Linq.ParallelEnumerable.ForAll%2A> loop may but do not have to execute in parallel.</span></span> <span data-ttu-id="55b57-152">Par conséquent, vous devez éviter d’écrire du code dont l’exactitude dépend de l’exécution parallèle d’itérations ou de l’exécution d’itérations dans un ordre particulier.</span><span class="sxs-lookup"><span data-stu-id="55b57-152">Therefore, you should avoid writing any code that depends for correctness on parallel execution of iterations or on the execution of iterations in any particular order.</span></span> <span data-ttu-id="55b57-153">Par exemple, ce code est susceptible d’interbloquer :</span><span class="sxs-lookup"><span data-stu-id="55b57-153">For example, this code is likely to deadlock:</span></span>  
  
 [!code-csharp[TPL_Pitfalls#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#01)]
 [!code-vb[TPL_Pitfalls#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#01)]  
  
 <span data-ttu-id="55b57-154">Dans cet exemple, une itération définit un événement que toutes les autres itérations attendent.</span><span class="sxs-lookup"><span data-stu-id="55b57-154">In this example, one iteration sets an event, and all other iterations wait on the event.</span></span> <span data-ttu-id="55b57-155">Aucune des itérations en attente ne peut s’achever tant que l’itération de définition d’événement n’est pas terminée.</span><span class="sxs-lookup"><span data-stu-id="55b57-155">None of the waiting iterations can complete until the event-setting iteration has completed.</span></span> <span data-ttu-id="55b57-156">Toutefois, il est possible que les itérations en attente bloquent tous les threads utilisés pour exécuter la boucle parallèle, avant que l’itération de définition d’événement ait eu une chance de s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="55b57-156">However, it is possible that the waiting iterations block all threads that are used to execute the parallel loop, before the event-setting iteration has had a chance to execute.</span></span> <span data-ttu-id="55b57-157">Cela provoque un interblocage : l’itération de définition d’événement ne s’exécute jamais et les itérations en attente ne s’activent pas non plus.</span><span class="sxs-lookup"><span data-stu-id="55b57-157">This results in a deadlock – the event-setting iteration will never execute, and the waiting iterations will never wake up.</span></span>  
  
 <span data-ttu-id="55b57-158">En particulier, une itération de boucle parallèle ne doit jamais attendre une autre itération de la boucle pour progresser.</span><span class="sxs-lookup"><span data-stu-id="55b57-158">In particular, one iteration of a parallel loop should never wait on another iteration of the loop to make progress.</span></span> <span data-ttu-id="55b57-159">Si la boucle parallèle décide de planifier les itérations de manière séquentielle, mais dans l’ordre inverse, un interblocage se produit.</span><span class="sxs-lookup"><span data-stu-id="55b57-159">If the parallel loop decides to schedule the iterations sequentially but in the opposite order, a deadlock will occur.</span></span>  
  
## <a name="avoid-executing-parallel-loops-on-the-ui-thread"></a><span data-ttu-id="55b57-160">Éviter d’exécuter des boucles parallèles sur le thread d’interface utilisateur</span><span class="sxs-lookup"><span data-stu-id="55b57-160">Avoid Executing Parallel Loops on the UI Thread</span></span>  
 <span data-ttu-id="55b57-161">Il est important de maintenir la réactivité de l’interface utilisateur de l’application (IU).</span><span class="sxs-lookup"><span data-stu-id="55b57-161">It is important to keep your application's user interface (UI) responsive.</span></span> <span data-ttu-id="55b57-162">Si une opération contient suffisamment de travail pour assurer la parallélisation, cette opération ne doit pas être exécutée sur le thread d’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="55b57-162">If an operation contains enough work to warrant parallelization, then it likely should not be run that operation on the UI thread.</span></span>  <span data-ttu-id="55b57-163">Au lieu de cela, elle doit décharger cette opération de sorte qu’elle s’exécute sur un thread d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="55b57-163">Instead, it should offload that operation to be run on a background thread.</span></span> <span data-ttu-id="55b57-164">Par exemple, si vous souhaitez utiliser une boucle parallèle pour calculer des données qui doivent ensuite être restituées dans un contrôle d’interface utilisateur, vous devez envisager l’exécution de la boucle dans une instance de tâche plutôt que directement dans un gestionnaire d’événements de l’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="55b57-164">For example, if you want to use a parallel loop to compute some data that should then be rendered into a UI control, you should consider executing the loop within a task instance rather than directly in a UI event handler.</span></span>  <span data-ttu-id="55b57-165">Vous ne devez marshaler la mise à jour de l’interface utilisateur vers le thread de l’interface utilisateur qu’une fois le calcul principal terminé.</span><span class="sxs-lookup"><span data-stu-id="55b57-165">Only when the core computation has completed should you then marshal the UI update back to the UI thread.</span></span>  
  
 <span data-ttu-id="55b57-166">Si vous exécutez des boucles parallèles sur le thread d’interface utilisateur, veillez à éviter la mise à jour des contrôles d’interface utilisateur à partir de la boucle.</span><span class="sxs-lookup"><span data-stu-id="55b57-166">If you do run parallel loops on the UI thread, be careful to avoid updating UI controls from within the loop.</span></span> <span data-ttu-id="55b57-167">Toute tentative de mise à jour des contrôles d’interface utilisateur à partir d’une boucle parallèle qui s’exécute sur le thread d’interface utilisateur peut entraîner une altération de l’état, des exceptions, des reports de mise à jour et même des interblocages, selon la manière dont la mise à jour de l’interface utilisateur est appelée.</span><span class="sxs-lookup"><span data-stu-id="55b57-167">Attempting to update UI controls from within a parallel loop that is executing on the UI thread can lead to state corruption, exceptions, delayed updates, and even deadlocks, depending on how the UI update is invoked.</span></span> <span data-ttu-id="55b57-168">Dans l’exemple suivant, la boucle parallèle bloque le thread d’interface utilisateur sur lequel elle s’exécute jusqu’à ce que toutes les itérations soient terminées.</span><span class="sxs-lookup"><span data-stu-id="55b57-168">In the following example, the parallel loop blocks the UI thread on which it's executing until all iterations are complete.</span></span> <span data-ttu-id="55b57-169">Toutefois, si une itération de la boucle s’exécute sur un thread d’arrière-plan (comme <xref:System.Threading.Tasks.Parallel.For%2A> peut le faire), l’appel à Invoke entraîne l’envoi d’un message au thread d’interface utilisateur et bloque en attendant que ce message soit traité.</span><span class="sxs-lookup"><span data-stu-id="55b57-169">However, if an iteration of the loop is running on a background thread (as <xref:System.Threading.Tasks.Parallel.For%2A> may do), the call to Invoke causes a message to be submitted to the UI thread and blocks waiting for that message to be processed.</span></span> <span data-ttu-id="55b57-170">Étant donné que le thread d’interface utilisateur est bloqué lors de l’exécution de <xref:System.Threading.Tasks.Parallel.For%2A>, le message ne peut jamais être traité et le thread d’interface utilisateur est soumis à des interblocages.</span><span class="sxs-lookup"><span data-stu-id="55b57-170">Since the UI thread is blocked running the <xref:System.Threading.Tasks.Parallel.For%2A>, the message can never be processed, and the UI thread deadlocks.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#02)]
 [!code-vb[TPL_Pitfalls#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#02)]  
  
 <span data-ttu-id="55b57-171">L’exemple suivant montre comment éviter l’interblocage, en exécutant la boucle à l’intérieur d’une instance de tâche.</span><span class="sxs-lookup"><span data-stu-id="55b57-171">The following example shows how to avoid the deadlock, by running the loop inside a task instance.</span></span> <span data-ttu-id="55b57-172">Le thread d’interface utilisateur n’est pas bloqué par la boucle, et le message peut être traité.</span><span class="sxs-lookup"><span data-stu-id="55b57-172">The UI thread is not blocked by the loop, and the message can be processed.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#03)]
 [!code-vb[TPL_Pitfalls#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#03)]  
  
## <a name="see-also"></a><span data-ttu-id="55b57-173">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="55b57-173">See also</span></span>

- [<span data-ttu-id="55b57-174">Programmation parallèle</span><span class="sxs-lookup"><span data-stu-id="55b57-174">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="55b57-175">Pièges potentiels avec PLINQ</span><span class="sxs-lookup"><span data-stu-id="55b57-175">Potential Pitfalls with PLINQ</span></span>](potential-pitfalls-with-plinq.md)
- [<span data-ttu-id="55b57-176">Modèles de programmation parallèle : présentation et application des modèles parallèles avec le .NET Framework 4 (page éventuellement en anglais)</span><span class="sxs-lookup"><span data-stu-id="55b57-176">Patterns for Parallel Programming: Understanding and Applying Parallel Patterns with the .NET Framework 4</span></span>](https://www.microsoft.com/download/details.aspx?id=19222)
