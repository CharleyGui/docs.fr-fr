---
title: Semaphore et SemaphoreSlim
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- counting semaphores
- semaphores
- threading [.NET Framework], cross-process synchronization
- Semaphore class, about Semaphore class
- SemaphoreSlim class, about SemaphoreSlim class
- threading [.NET Framework], Semaphore class
ms.assetid: 7722a333-b974-47a2-a7c0-f09097fb644e
ms.openlocfilehash: 9a18a6517548bb402e1e3b9ac02e95aae32a8f4a
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/02/2020
ms.locfileid: "84291134"
---
# <a name="semaphore-and-semaphoreslim"></a><span data-ttu-id="73f8f-102">Semaphore et SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="73f8f-102">Semaphore and SemaphoreSlim</span></span>
<span data-ttu-id="73f8f-103">La classe <xref:System.Threading.Semaphore?displayProperty=nameWithType> représente un sémaphore local ou nommé (visible à l'échelle du système).</span><span class="sxs-lookup"><span data-stu-id="73f8f-103">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> class represents a named (systemwide) or local semaphore.</span></span> <span data-ttu-id="73f8f-104">Il s'agit d'un wrapper mince entourant l'objet sémaphore Win32.</span><span class="sxs-lookup"><span data-stu-id="73f8f-104">It is a thin wrapper around the Win32 semaphore object.</span></span> <span data-ttu-id="73f8f-105">Les sémaphores Win32 sont des sémaphores de comptage qui peuvent être utilisés pour contrôler l'accès à un pool de ressources.</span><span class="sxs-lookup"><span data-stu-id="73f8f-105">Win32 semaphores are counting semaphores, which can be used to control access to a pool of resources.</span></span>  
  
 <span data-ttu-id="73f8f-106">La classe <xref:System.Threading.SemaphoreSlim> représente un sémaphore léger et rapide qui peut être utilisé pour l'attente dans un processus unique quand les temps d'attente sont censés être très courts.</span><span class="sxs-lookup"><span data-stu-id="73f8f-106">The <xref:System.Threading.SemaphoreSlim> class represents a lightweight, fast semaphore that can be used for waiting within a single process when wait times are expected to be very short.</span></span> <span data-ttu-id="73f8f-107"><xref:System.Threading.SemaphoreSlim> repose autant que possible sur les primitives de synchronisation fournies par le Common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="73f8f-107"><xref:System.Threading.SemaphoreSlim> relies as much as possible on synchronization primitives provided by the common language runtime (CLR).</span></span> <span data-ttu-id="73f8f-108">Toutefois, il fournit également des handles d'attente initialisés tardivement et basés sur le noyau qui permettent l'attente de plusieurs sémaphores.</span><span class="sxs-lookup"><span data-stu-id="73f8f-108">However, it also provides lazily initialized, kernel-based wait handles as necessary to support waiting on multiple semaphores.</span></span> <span data-ttu-id="73f8f-109"><xref:System.Threading.SemaphoreSlim> prend également en charge l'utilisation de jetons d'annulation, mais il ne prend pas en charge les sémaphores nommés ni l'utilisation d'un handle d'attente pour la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="73f8f-109"><xref:System.Threading.SemaphoreSlim> also supports the use of cancellation tokens, but it does not support named semaphores or the use of a wait handle for synchronization.</span></span>  
  
## <a name="managing-a-limited-resource"></a><span data-ttu-id="73f8f-110">Gestion d'une ressource limitée</span><span class="sxs-lookup"><span data-stu-id="73f8f-110">Managing a Limited Resource</span></span>  
 <span data-ttu-id="73f8f-111">Les threads entrent dans le sémaphore en appelant la méthode <xref:System.Threading.WaitHandle.WaitOne%2A>, qui est héritée de la classe <xref:System.Threading.WaitHandle>, dans le cas d'un objet <xref:System.Threading.Semaphore?displayProperty=nameWithType>, ou la méthode <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> ou <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> dans le cas d'un objet <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="73f8f-111">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, in the case of a <xref:System.Threading.Semaphore?displayProperty=nameWithType> object, or the <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> method, in the case of a <xref:System.Threading.SemaphoreSlim> object.</span></span> <span data-ttu-id="73f8f-112">Quand l'appel est retourné, le nombre du sémaphore est décrémenté.</span><span class="sxs-lookup"><span data-stu-id="73f8f-112">When the call returns, the count on the semaphore is decremented.</span></span> <span data-ttu-id="73f8f-113">Quand un thread demande à entrer et que le nombre est égal à zéro, le thread se bloque.</span><span class="sxs-lookup"><span data-stu-id="73f8f-113">When a thread requests entry and the count is zero, the thread blocks.</span></span> <span data-ttu-id="73f8f-114">Quand les threads libèrent le sémaphore en appelant la méthode <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> ou <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType>, les threads bloqués sont autorisés à entrer.</span><span class="sxs-lookup"><span data-stu-id="73f8f-114">As threads release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> method, blocked threads are allowed to enter.</span></span> <span data-ttu-id="73f8f-115">Il n'existe aucun ordre garanti (tel que premier entré, premier sorti (FIFO) ou dernier entré, premier sorti (LIFO)), pour les threads bloqués devant entrer dans le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="73f8f-115">There is no guaranteed order, such as first-in, first-out (FIFO) or last-in, first-out (LIFO), for blocked threads to enter the semaphore.</span></span>  
  
 <span data-ttu-id="73f8f-116">Un thread peut entrer dans le sémaphore plusieurs fois en appelant la méthode <xref:System.Threading.Semaphore?displayProperty=nameWithType> de l'objet <xref:System.Threading.WaitHandle.WaitOne%2A> ou la méthode <xref:System.Threading.SemaphoreSlim> de l'objet <xref:System.Threading.SemaphoreSlim.Wait%2A> à plusieurs reprises.</span><span class="sxs-lookup"><span data-stu-id="73f8f-116">A thread can enter the semaphore multiple times by calling the <xref:System.Threading.Semaphore?displayProperty=nameWithType> object's <xref:System.Threading.WaitHandle.WaitOne%2A> method or the  <xref:System.Threading.SemaphoreSlim> object's <xref:System.Threading.SemaphoreSlim.Wait%2A> method repeatedly.</span></span> <span data-ttu-id="73f8f-117">Pour libérer le sémaphore, le thread peut appeler la surcharge de méthode <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> ou <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> le même nombre de fois, ou appeler la surcharge de méthode <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> ou <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> et spécifier le nombre d’entrées à libérer.</span><span class="sxs-lookup"><span data-stu-id="73f8f-117">To release the semaphore, the thread can either call the <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> method overload the same number of times, or call the <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> method overload and specify the number of entries to be released.</span></span>  
  
### <a name="semaphores-and-thread-identity"></a><span data-ttu-id="73f8f-118">Sémaphores et identité de thread</span><span class="sxs-lookup"><span data-stu-id="73f8f-118">Semaphores and Thread Identity</span></span>  
 <span data-ttu-id="73f8f-119">Les deux types de sémaphores n'appliquent pas l'identité de thread sur les appels aux méthodes <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A> et <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="73f8f-119">The two semaphore types do not enforce thread identity on calls to the <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="73f8f-120">Par exemple, un scénario classique d'utilisation des sémaphores implique un thread producteur et un thread consommateur, avec un thread incrémentant le nombre du sémaphore et l'autre le décrémentant.</span><span class="sxs-lookup"><span data-stu-id="73f8f-120">For example, a common usage scenario for semaphores involves a producer thread and a consumer thread, with one thread always incrementing the semaphore count and the other always decrementing it.</span></span>  
  
 <span data-ttu-id="73f8f-121">Il est de la responsabilité du programmeur de garantir qu’un thread ne libère pas le sémaphore trop souvent.</span><span class="sxs-lookup"><span data-stu-id="73f8f-121">It is the programmer's responsibility to ensure that a thread does not release the semaphore too many times.</span></span> <span data-ttu-id="73f8f-122">Supposons, par exemple, qu'un sémaphore ait un nombre maximal égal à deux et que le thread A et le thread B entrent dans le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="73f8f-122">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="73f8f-123">Si une erreur de programmation dans le thread B le conduit à appeler `Release` deux fois, les deux appels aboutiront.</span><span class="sxs-lookup"><span data-stu-id="73f8f-123">If a programming error in thread B causes it to call  `Release` twice, both calls succeed.</span></span> <span data-ttu-id="73f8f-124">Le nombre maximal du sémaphore sera alors atteint, et quand le thread A appellera `Release`, une exception <xref:System.Threading.SemaphoreFullException> sera levée.</span><span class="sxs-lookup"><span data-stu-id="73f8f-124">The count on the semaphore is full, and when thread A eventually calls `Release`, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
## <a name="named-semaphores"></a><span data-ttu-id="73f8f-125">Sémaphores nommés</span><span class="sxs-lookup"><span data-stu-id="73f8f-125">Named Semaphores</span></span>  
 <span data-ttu-id="73f8f-126">Le système d'exploitation Windows permet d'attribuer un nom aux sémaphores.</span><span class="sxs-lookup"><span data-stu-id="73f8f-126">The Windows operating system allows semaphores to have names.</span></span> <span data-ttu-id="73f8f-127">Un sémaphore nommé est disponible à l'échelle du système.</span><span class="sxs-lookup"><span data-stu-id="73f8f-127">A named semaphore is system wide.</span></span> <span data-ttu-id="73f8f-128">C'est-à-dire qu'une fois créé, le sémaphore nommé est visible par tous les threads de tous les processus.</span><span class="sxs-lookup"><span data-stu-id="73f8f-128">That is, once the named semaphore is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="73f8f-129">Par conséquent, un sémaphore nommé peut être utilisé pour synchroniser aussi bien des activités de processus que des threads.</span><span class="sxs-lookup"><span data-stu-id="73f8f-129">Thus, named semaphore can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="73f8f-130">Vous pouvez créer un objet <xref:System.Threading.Semaphore> qui représente un sémaphore système nommé en utilisant l'un des constructeurs qui spécifient un nom.</span><span class="sxs-lookup"><span data-stu-id="73f8f-130">You can create a <xref:System.Threading.Semaphore> object that represents a named system semaphore by using one of the constructors that specifies a name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="73f8f-131">Étant donné que les sémaphores nommés sont disponibles à l'échelle du système, il est possible que plusieurs objets <xref:System.Threading.Semaphore> représentent le même sémaphore nommé.</span><span class="sxs-lookup"><span data-stu-id="73f8f-131">Because named semaphores are system wide, it is possible to have multiple <xref:System.Threading.Semaphore> objects that represent the same named semaphore.</span></span> <span data-ttu-id="73f8f-132">Chaque fois que vous appelez un constructeur ou la méthode <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>, un nouvel objet <xref:System.Threading.Semaphore> est créé.</span><span class="sxs-lookup"><span data-stu-id="73f8f-132">Each time you call a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method, a new <xref:System.Threading.Semaphore> object is created.</span></span> <span data-ttu-id="73f8f-133">Le fait de spécifier un même nom plusieurs fois crée plusieurs objets qui représentent le même sémaphore nommé.</span><span class="sxs-lookup"><span data-stu-id="73f8f-133">Specifying the same name repeatedly creates multiple objects that represent the same named semaphore.</span></span>  
  
 <span data-ttu-id="73f8f-134">Soyez prudent lorsque vous utilisez des sémaphores nommés.</span><span class="sxs-lookup"><span data-stu-id="73f8f-134">Be careful when you use named semaphores.</span></span> <span data-ttu-id="73f8f-135">Étant donné qu'ils sont disponibles à l'échelle du système, un autre processus portant le même nom peut entrer dans votre sémaphore sans que vous vous y attendiez.</span><span class="sxs-lookup"><span data-stu-id="73f8f-135">Because they are system wide, another process that uses the same name can enter your semaphore unexpectedly.</span></span> <span data-ttu-id="73f8f-136">Du code malveillant exécuté sur le même ordinateur pourrait s'en servir pour une attaque par déni de service.</span><span class="sxs-lookup"><span data-stu-id="73f8f-136">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="73f8f-137">Utilisez la sécurité de contrôle d'accès pour protéger un objet <xref:System.Threading.Semaphore> qui représente un sémaphore nommé, de préférence en utilisant un constructeur qui spécifie un objet <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="73f8f-137">Use access control security to protect a <xref:System.Threading.Semaphore> object that represents a named semaphore, preferably by using a constructor that specifies a <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="73f8f-138">Vous pouvez également appliquer la sécurité de contrôle d'accès à l'aide de la méthode <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>. Sachez toutefois que cela crée une vulnérabilité entre le moment où le sémaphore est créé et celui où il est protégé.</span><span class="sxs-lookup"><span data-stu-id="73f8f-138">You can also apply access control security using the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method, but this leaves a window of vulnerability between the time the semaphore is created and the time it is protected.</span></span> <span data-ttu-id="73f8f-139">La protection des sémaphores grâce à la sécurité de contrôle d'accès empêche les attaques malveillantes, mais ne résout pas le problème des conflits de noms involontaires.</span><span class="sxs-lookup"><span data-stu-id="73f8f-139">Protecting semaphores with access control security helps prevent malicious attacks, but does not solve the problem of unintentional name collisions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="73f8f-140">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="73f8f-140">See also</span></span>

- <xref:System.Threading.Semaphore>
- <xref:System.Threading.SemaphoreSlim>
- [<span data-ttu-id="73f8f-141">Objets et fonctionnalités de Threading</span><span class="sxs-lookup"><span data-stu-id="73f8f-141">Threading Objects and Features</span></span>](threading-objects-and-features.md)
