---
title: Vue d’ensemble des primitives de synchronisation
description: En savoir plus sur les primitives de synchronisation de thread .NET utilisées pour synchroniser l’accès à une ressource partagée ou contrôler l’interaction des threads
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: d5ae0fe5813952742950582a4282cd1c6ab6a870
ms.sourcegitcommit: 7588b1f16b7608bc6833c05f91ae670c22ef56f8
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/02/2020
ms.locfileid: "93188976"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="166f7-103">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="166f7-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="166f7-104">.NET fournit un éventail de types que vous pouvez utiliser pour synchroniser l’accès à une ressource partagée ou coordonner l’interaction des threads.</span><span class="sxs-lookup"><span data-stu-id="166f7-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="166f7-105">Utilisez la même instance de primitives de synchronisation pour protéger l’accès à une ressource partagée.</span><span class="sxs-lookup"><span data-stu-id="166f7-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="166f7-106">Si vous utilisez différentes instances de primitives de synchronisation pour protéger la même ressource, vous contournerez la protection fournie par une primitive de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="166f7-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="166f7-107">Classe WaitHandle et types de synchronisation légers</span><span class="sxs-lookup"><span data-stu-id="166f7-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="166f7-108">Plusieurs primitives de synchronisation .NET dérivent la classe <xref:System.Threading.WaitHandle?displayProperty=nameWithType>, qui encapsule un descripteur de synchronisation du système d’exploitation natif et utilise un mécanisme de signalisation pour l’interaction des threads.</span><span class="sxs-lookup"><span data-stu-id="166f7-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="166f7-109">Ces classes incluent :</span><span class="sxs-lookup"><span data-stu-id="166f7-109">Those classes include:</span></span>

- <span data-ttu-id="166f7-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, qui accorde un accès exclusif à une ressource partagée.</span><span class="sxs-lookup"><span data-stu-id="166f7-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="166f7-111">L’état d’un mutex est signalé si aucun thread ne le possède.</span><span class="sxs-lookup"><span data-stu-id="166f7-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="166f7-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, qui limite le nombre de threads qui peuvent accéder simultanément à une ressource partagée ou à un pool de ressources.</span><span class="sxs-lookup"><span data-stu-id="166f7-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="166f7-113">L’état d’un sémaphore est défini sur « signalé » quand son nombre est supérieur à zéro et sur « non signalé » quand son nombre est égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="166f7-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="166f7-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, qui représente un événement de synchronisation de thread et peut être dans un état signalé ou non signalé.</span><span class="sxs-lookup"><span data-stu-id="166f7-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="166f7-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, qui est dérivé de <xref:System.Threading.EventWaitHandle> et, quand il est signalé, se réinitialise automatiquement à un état non signalé après avoir libéré un seul thread en attente.</span><span class="sxs-lookup"><span data-stu-id="166f7-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="166f7-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, qui est dérivé à son <xref:System.Threading.EventWaitHandle> et, quand il est signalé, reste dans un état signalé jusqu'à ce que la méthode <xref:System.Threading.EventWaitHandle.Reset%2A> soit appelée.</span><span class="sxs-lookup"><span data-stu-id="166f7-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="166f7-117">Dans .NET Framework, étant donné que <xref:System.Threading.WaitHandle> dérive de <xref:System.MarshalByRefObject?displayProperty=nameWithType> , ces types peuvent être utilisés pour synchroniser les activités des threads au-delà des limites du domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="166f7-117">In .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="166f7-118">Dans .NET Framework, .NET Core et .NET 5 +, certains de ces types peuvent représenter des handles de synchronisation du système nommés, qui sont visibles dans tout le système d’exploitation et peuvent être utilisés pour la synchronisation inter-processus :</span><span class="sxs-lookup"><span data-stu-id="166f7-118">In .NET Framework, .NET Core, and .NET 5+, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <xref:System.Threading.Mutex>
- <span data-ttu-id="166f7-119"><xref:System.Threading.Semaphore> (sur Windows)</span><span class="sxs-lookup"><span data-stu-id="166f7-119"><xref:System.Threading.Semaphore> (on Windows)</span></span>
- <span data-ttu-id="166f7-120"><xref:System.Threading.EventWaitHandle> (sur Windows)</span><span class="sxs-lookup"><span data-stu-id="166f7-120"><xref:System.Threading.EventWaitHandle> (on Windows)</span></span>

<span data-ttu-id="166f7-121">Pour plus d'informations, consultez la référence d’API <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="166f7-121">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="166f7-122">Les types de synchronisation légers ne s’appuient pas sur les descripteurs de système d’exploitation sous-jacents et fournissent généralement de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="166f7-122">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="166f7-123">Toutefois, ils ne peuvent pas être utilisés pour la synchronisation entre processus.</span><span class="sxs-lookup"><span data-stu-id="166f7-123">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="166f7-124">Utilisez ces types pour la synchronisation de threads dans une même application.</span><span class="sxs-lookup"><span data-stu-id="166f7-124">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="166f7-125">Certains de ces types sont des alternatives aux types dérivés de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="166f7-125">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="166f7-126">Par exemple, <xref:System.Threading.SemaphoreSlim> est une alternative légère à <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="166f7-126">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="166f7-127">Synchronisation de l'accès à une ressource partagée</span><span class="sxs-lookup"><span data-stu-id="166f7-127">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="166f7-128">.NET fournit une plage de primitives de synchronisation pour contrôler l’accès à une ressource partagée par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="166f7-128">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="166f7-129">Monitor (classe)</span><span class="sxs-lookup"><span data-stu-id="166f7-129">Monitor class</span></span>

<span data-ttu-id="166f7-130">La classe <xref:System.Threading.Monitor?displayProperty=nameWithType> accorde l’accès mutuellement exclusif à une ressource partagée par l’acquisition ou la libération d’un verrou sur l’objet qui identifie la ressource.</span><span class="sxs-lookup"><span data-stu-id="166f7-130">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="166f7-131">Tant qu’un verrou est maintenu, le thread qui contient le verrou peut à nouveau obtenir et libérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="166f7-131">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="166f7-132">Tout autre thread se voit bloquer l’acquisition du verrou et la méthode <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> attend que ce dernier soit libéré.</span><span class="sxs-lookup"><span data-stu-id="166f7-132">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="166f7-133">La méthode <xref:System.Threading.Monitor.Enter%2A> acquiert un verrou libéré.</span><span class="sxs-lookup"><span data-stu-id="166f7-133">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="166f7-134">Vous pouvez également utiliser la méthode <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> pour spécifier la quantité de temps pendant lequel un thread tente d’acquérir un verrou.</span><span class="sxs-lookup"><span data-stu-id="166f7-134">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="166f7-135">Étant donné que la classe <xref:System.Threading.Monitor> possède l’affinité de thread, le thread qui a acquis un verrou doit le libérer en appelant la méthode <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="166f7-135">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="166f7-136">Vous pouvez coordonner l’interaction des threads qui acquièrent un verrou sur le même objet à l’aide des méthodes <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> et <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="166f7-136">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="166f7-137">Pour plus d'informations, consultez la référence d’API <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="166f7-137">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="166f7-138">Utilisez l’instruction [lock](../../csharp/language-reference/keywords/lock-statement.md) dans C# et l’instruction [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) dans Visual Basic pour synchroniser l’accès à une ressource partagée au lieu d’utiliser la classe <xref:System.Threading.Monitor> directement.</span><span class="sxs-lookup"><span data-stu-id="166f7-138">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="166f7-139">Ces instructions sont implémentées à l’aide des méthodes <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> et d’un bloc `try…finally` pour garantir que le verrou acquis est toujours libéré.</span><span class="sxs-lookup"><span data-stu-id="166f7-139">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="166f7-140">Mutex (classe)</span><span class="sxs-lookup"><span data-stu-id="166f7-140">Mutex class</span></span>

<span data-ttu-id="166f7-141">La classe <xref:System.Threading.Mutex?displayProperty=nameWithType>, telle que <xref:System.Threading.Monitor>, accorde un accès exclusif à une ressource partagée.</span><span class="sxs-lookup"><span data-stu-id="166f7-141">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="166f7-142">Utilisez une des surcharges de méthode [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) pour demander la propriété d’un mutex.</span><span class="sxs-lookup"><span data-stu-id="166f7-142">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="166f7-143">Comme <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> possède l’affinité de thread et le thread qui a acquis un mutex doit le libérer en appelant la méthode <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="166f7-143">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="166f7-144">Contrairement à <xref:System.Threading.Monitor>, la classe <xref:System.Threading.Mutex> peut être utilisée pour la synchronisation entre processus.</span><span class="sxs-lookup"><span data-stu-id="166f7-144">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="166f7-145">Pour ce faire, utilisez un mutex nommé, qui est visible dans tout le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="166f7-145">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="166f7-146">Pour créer une instance de mutex nommé, utilisez un [constructeur de mutex](<xref:System.Threading.Mutex.%23ctor%2A>) qui spécifie un nom.</span><span class="sxs-lookup"><span data-stu-id="166f7-146">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="166f7-147">Vous pouvez également appeler la <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> méthode pour ouvrir un mutex système nommé existant.</span><span class="sxs-lookup"><span data-stu-id="166f7-147">You can also call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="166f7-148">Pour plus d’informations, consultez l’article [Mutex](mutexes.md) et la référence d’API <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="166f7-148">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="166f7-149">Structure SpinLock</span><span class="sxs-lookup"><span data-stu-id="166f7-149">SpinLock structure</span></span>

<span data-ttu-id="166f7-150">La structure <xref:System.Threading.SpinLock?displayProperty=nameWithType>, comme <xref:System.Threading.Monitor>, accorde un accès exclusif à une ressource partagée, basée sur la disponibilité d’un verrou.</span><span class="sxs-lookup"><span data-stu-id="166f7-150">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="166f7-151">Lorsque <xref:System.Threading.SpinLock> tente d’acquérir un verrou qui n’est pas disponible, il est conservé dans une boucle et effectue des vérifications à plusieurs reprises jusqu'à ce que le verrou devienne disponible.</span><span class="sxs-lookup"><span data-stu-id="166f7-151">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="166f7-152">Pour plus d’informations sur les avantages et les inconvénients de l’utilisation de verrou de rotation, consultez l’article [SpinLock](spinlock.md) et la référence d’API <xref:System.Threading.SpinLock>.</span><span class="sxs-lookup"><span data-stu-id="166f7-152">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="166f7-153">Classe ReaderWriterLockSlim</span><span class="sxs-lookup"><span data-stu-id="166f7-153">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="166f7-154">La classe <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> accorde un accès exclusif à une ressource partagée pour l’écriture et permet à plusieurs threads d’accéder à la ressource simultanément pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="166f7-154">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="166f7-155">Vous souhaiterez peut-être utiliser <xref:System.Threading.ReaderWriterLockSlim> pour synchroniser l’accès à une structure de données partagée qui prend en charge les opérations de lecture thread-safe, mais nécessite un accès exclusif pour effectuer l’opération d’écriture.</span><span class="sxs-lookup"><span data-stu-id="166f7-155">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="166f7-156">Quand un thread demande un accès exclusif (par exemple, en appelant la méthode <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType>), les demandes suivantes des lecteurs et enregistreurs sont bloquées jusqu’à ce que tous les lecteurs existants aient quitté le verrou et que l’enregistreur soit entré et sorti du verrou.</span><span class="sxs-lookup"><span data-stu-id="166f7-156">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="166f7-157">Pour plus d'informations, consultez la référence d’API <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="166f7-157">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="166f7-158">Classes Sémaphore et SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="166f7-158">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="166f7-159">Les classes <xref:System.Threading.Semaphore?displayProperty=nameWithType> et <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> limitent le nombre de threads pouvant accéder simultanément à une ressource partagée ou à un pool de ressources.</span><span class="sxs-lookup"><span data-stu-id="166f7-159">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="166f7-160">Les autres threads qui demandent la ressource attendent qu’un thread libère le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="166f7-160">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="166f7-161">Étant donné que le sémaphore n’a pas d’affinité de thread, un thread peut acquérir le sémaphore et un autre peut le libérer.</span><span class="sxs-lookup"><span data-stu-id="166f7-161">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="166f7-162"><xref:System.Threading.SemaphoreSlim> est une alternative légère à <xref:System.Threading.Semaphore> et ne peut être utilisé que pour la synchronisation dans une limite de processus unique.</span><span class="sxs-lookup"><span data-stu-id="166f7-162"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="166f7-163">Sur Windows, vous pouvez utiliser <xref:System.Threading.Semaphore> pour la synchronisation entre processus.</span><span class="sxs-lookup"><span data-stu-id="166f7-163">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="166f7-164">Pour ce faire, créez une instance <xref:System.Threading.Semaphore> qui représente un sémaphore système nommé à l’aide d’un des [constructeurs de sémaphores](<xref:System.Threading.Semaphore.%23ctor%2A>) qui spécifient un nom ou de la méthode <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="166f7-164">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="166f7-165"><xref:System.Threading.SemaphoreSlim> ne prend pas en charge les sémaphores système nommés.</span><span class="sxs-lookup"><span data-stu-id="166f7-165"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="166f7-166">Pour plus d’informations, consultez l’article [Sémaphore et SemaphoreSlim](semaphore-and-semaphoreslim.md) et la référence d’API <xref:System.Threading.Semaphore> ou <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="166f7-166">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="166f7-167">Interaction des threads ou signalisation</span><span class="sxs-lookup"><span data-stu-id="166f7-167">Thread interaction, or signaling</span></span>

<span data-ttu-id="166f7-168">Interaction des threads (ou signalisation des threads) signifie qu’un thread doit attendre la notification ou un signal d’un ou de plusieurs threads pour pouvoir continuer.</span><span class="sxs-lookup"><span data-stu-id="166f7-168">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="166f7-169">Par exemple, si le thread A appelle la méthode <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> du thread B, le thread A est bloqué jusqu'à ce que le thread B soit terminé.</span><span class="sxs-lookup"><span data-stu-id="166f7-169">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="166f7-170">Les primitives de synchronisation décrites dans la section précédente fournissent un mécanisme différent pour la signalisation : en libérant un verrou, un thread indique à un autre thread qu’il peut poursuivre en acquérant le verrou.</span><span class="sxs-lookup"><span data-stu-id="166f7-170">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="166f7-171">Cette section décrit des constructions de signalisation supplémentaires fournies par .NET.</span><span class="sxs-lookup"><span data-stu-id="166f7-171">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="166f7-172">Classes EventWaitHandle, AutoResetEvent, ManualResetEvent et ManualResetEventSlim</span><span class="sxs-lookup"><span data-stu-id="166f7-172">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="166f7-173">La classe <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> représente un événement de synchronisation de threads.</span><span class="sxs-lookup"><span data-stu-id="166f7-173">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="166f7-174">Un événement de synchronisation peut être dans un état non signalé ou signalé.</span><span class="sxs-lookup"><span data-stu-id="166f7-174">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="166f7-175">Lorsque l’état d’un événement est non signalé, un thread qui appelle la surcharge <xref:System.Threading.WaitHandle.WaitOne%2A?> de l’événement est bloqué jusqu'à ce qu’un événement soit signalé.</span><span class="sxs-lookup"><span data-stu-id="166f7-175">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="166f7-176">La méthode <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> définit l’état d’un événement sur « signalé ».</span><span class="sxs-lookup"><span data-stu-id="166f7-176">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="166f7-177">Le comportement d’un <xref:System.Threading.EventWaitHandle> qui a été signalé dépend de son mode de réinitialisation :</span><span class="sxs-lookup"><span data-stu-id="166f7-177">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="166f7-178">Un <xref:System.Threading.EventWaitHandle> créé avec l’indicateur <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> se réinitialise automatiquement après avoir libéré un seul thread en attente.</span><span class="sxs-lookup"><span data-stu-id="166f7-178">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="166f7-179">C'est comme un tourniquet qui ne laisse passer qu'un seul thread à chaque fois qu'il est signalé.</span><span class="sxs-lookup"><span data-stu-id="166f7-179">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="166f7-180">La classe <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, qui est dérivée de <xref:System.Threading.EventWaitHandle>, représente ce comportement.</span><span class="sxs-lookup"><span data-stu-id="166f7-180">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="166f7-181">Un <xref:System.Threading.EventWaitHandle> créé avec l’indicateur <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> reste signalé jusqu'à ce que la méthode <xref:System.Threading.EventWaitHandle.Reset%2A> soit appelée.</span><span class="sxs-lookup"><span data-stu-id="166f7-181">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="166f7-182">C’est comme une barrière qui reste fermée jusqu'au signalement, puis ouverte jusqu'à ce que quelqu'un la ferme.</span><span class="sxs-lookup"><span data-stu-id="166f7-182">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="166f7-183">La classe <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, qui est dérivée de <xref:System.Threading.EventWaitHandle>, représente ce comportement.</span><span class="sxs-lookup"><span data-stu-id="166f7-183">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="166f7-184">La classe <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> est une alternative légère à <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="166f7-184">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="166f7-185">Sur Windows, vous pouvez utiliser <xref:System.Threading.EventWaitHandle> pour la synchronisation entre processus.</span><span class="sxs-lookup"><span data-stu-id="166f7-185">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="166f7-186">Pour ce faire, créez une instance <xref:System.Threading.EventWaitHandle> qui représente un événement de synchronisation système nommé à l’aide d’un des [constructeurs EventWaitHandle](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) qui spécifient un nom ou de la méthode <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="166f7-186">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="166f7-187">Pour plus d’informations, consultez l’article [EventWaitHandle](eventwaithandle.md).</span><span class="sxs-lookup"><span data-stu-id="166f7-187">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="166f7-188">Pour la référence d’API, consultez <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent> et <xref:System.Threading.ManualResetEventSlim>.</span><span class="sxs-lookup"><span data-stu-id="166f7-188">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="166f7-189">Classe CountdownEvent</span><span class="sxs-lookup"><span data-stu-id="166f7-189">CountdownEvent class</span></span>

<span data-ttu-id="166f7-190">La classe <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> représente un événement défini quand son nombre est égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="166f7-190">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="166f7-191">Bien que <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> soit supérieure à zéro, un thread qui appelle <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> est bloqué.</span><span class="sxs-lookup"><span data-stu-id="166f7-191">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="166f7-192">Appelez <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> pour décrémenter le nombre d’événements.</span><span class="sxs-lookup"><span data-stu-id="166f7-192">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="166f7-193">Contrairement à <xref:System.Threading.ManualResetEvent> ou à <xref:System.Threading.ManualResetEventSlim>, que vous pouvez utiliser pour débloquer plusieurs threads avec un signal d’un thread, vous pouvez utiliser <xref:System.Threading.CountdownEvent> pour débloquer un ou plusieurs threads avec des signaux de plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="166f7-193">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="166f7-194">Pour plus d’informations, consultez l’article [CountdownEvent](countdownevent.md) et la référence d’API <xref:System.Threading.CountdownEvent>.</span><span class="sxs-lookup"><span data-stu-id="166f7-194">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="166f7-195">Classe de cloisonnement</span><span class="sxs-lookup"><span data-stu-id="166f7-195">Barrier class</span></span>

<span data-ttu-id="166f7-196">La classe <xref:System.Threading.Barrier?displayProperty=nameWithType> représente une barrière de l’exécution du thread.</span><span class="sxs-lookup"><span data-stu-id="166f7-196">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="166f7-197">Un thread qui appelle la méthode <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> signale qu’il a atteint le cloisonnement et attend que d’autres threads participants atteignent également le cloisonnement.</span><span class="sxs-lookup"><span data-stu-id="166f7-197">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="166f7-198">Lorsque tous les threads participants atteignent le cloisonnement, ils continuent. La barrière est réinitialisée et peut être à nouveau utilisée.</span><span class="sxs-lookup"><span data-stu-id="166f7-198">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="166f7-199">Vous pouvez utiliser <xref:System.Threading.Barrier> quand un ou plusieurs threads requièrent les résultats d’autres threads avant de passer à la phase de calcul suivante.</span><span class="sxs-lookup"><span data-stu-id="166f7-199">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="166f7-200">Pour plus d’informations, consultez l’article [Cloisonnement](barrier.md) et la référence d’API <xref:System.Threading.Barrier>.</span><span class="sxs-lookup"><span data-stu-id="166f7-200">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="166f7-201">Interlocked (classe)</span><span class="sxs-lookup"><span data-stu-id="166f7-201">Interlocked class</span></span>

<span data-ttu-id="166f7-202">La classe <xref:System.Threading.Interlocked?displayProperty=nameWithType> fournit des méthodes statiques qui effectuent des opérations atomiques simples sur une variable.</span><span class="sxs-lookup"><span data-stu-id="166f7-202">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="166f7-203">Ces opérations atomiques incluent l'addition, l’incrémentation et la décrémentation, l’échange et l’échange conditionnel en fonction d'une comparaison, ainsi qu’une opération de lecture d’une valeur entière 64 bits.</span><span class="sxs-lookup"><span data-stu-id="166f7-203">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="166f7-204">Pour plus d'informations, consultez la référence d’API <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="166f7-204">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="166f7-205">Structure SpinWait</span><span class="sxs-lookup"><span data-stu-id="166f7-205">SpinWait structure</span></span>

<span data-ttu-id="166f7-206">La structure <xref:System.Threading.SpinWait?displayProperty=nameWithType> prend en charge l'attente basée sur les spins.</span><span class="sxs-lookup"><span data-stu-id="166f7-206">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="166f7-207">Vous voudrez peut-être l’utiliser quand un thread doit attendre le signalement d'un événement ou la satisfaction d'une condition, mais que le temps d'attente réel est supposé être inférieur à la latence requise, en utilisant un descripteur d'attente ou en bloquant le thread.</span><span class="sxs-lookup"><span data-stu-id="166f7-207">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="166f7-208">À l'aide de <xref:System.Threading.SpinWait>, vous pouvez spécifier une courte période de rotation pendant l'attente, puis générer (par exemple, en attente ou en veille) uniquement si la condition n'a pas été remplie dans le délai spécifié.</span><span class="sxs-lookup"><span data-stu-id="166f7-208">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="166f7-209">Pour plus d’informations, consultez l’article [SpinWait](spinwait.md) et la référence d’API <xref:System.Threading.SpinWait>.</span><span class="sxs-lookup"><span data-stu-id="166f7-209">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="166f7-210">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="166f7-210">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="166f7-211">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="166f7-211">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="166f7-212">Objets et fonctionnalités de Threading</span><span class="sxs-lookup"><span data-stu-id="166f7-212">Threading objects and features</span></span>](threading-objects-and-features.md)
