---
title: Utilisation de conteneurs graphiques imbriqués
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- graphics [Windows Forms], nested containers
- graphics [Windows Forms], clipping
- graphics [Windows Forms], transformations in nested objects
ms.assetid: a0d9f178-43a4-4323-bb5a-d3e3f77ae6c1
ms.openlocfilehash: 4533fbba62c36714f55cd8bd55fde7a1c8f6c9e6
ms.sourcegitcommit: b1cfd260928d464d91e20121f9bdba7611c94d71
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/02/2019
ms.locfileid: "67505047"
---
# <a name="using-nested-graphics-containers"></a><span data-ttu-id="c77ae-102">Utilisation de conteneurs graphiques imbriqués</span><span class="sxs-lookup"><span data-stu-id="c77ae-102">Using Nested Graphics Containers</span></span>
<span data-ttu-id="c77ae-103">GDI + fournit des conteneurs que vous pouvez utiliser pour remplacer ou augmenter la partie de l’état dans temporairement un <xref:System.Drawing.Graphics> objet.</span><span class="sxs-lookup"><span data-stu-id="c77ae-103">GDI+ provides containers that you can use to temporarily replace or augment part of the state in a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="c77ae-104">Vous créez un conteneur en appelant le <xref:System.Drawing.Graphics.BeginContainer%2A> méthode d’un <xref:System.Drawing.Graphics> objet.</span><span class="sxs-lookup"><span data-stu-id="c77ae-104">You create a container by calling the <xref:System.Drawing.Graphics.BeginContainer%2A> method of a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="c77ae-105">Vous pouvez appeler <xref:System.Drawing.Graphics.BeginContainer%2A> à plusieurs reprises pour former des conteneurs imbriqués.</span><span class="sxs-lookup"><span data-stu-id="c77ae-105">You can call <xref:System.Drawing.Graphics.BeginContainer%2A> repeatedly to form nested containers.</span></span> <span data-ttu-id="c77ae-106">Chaque appel à <xref:System.Drawing.Graphics.BeginContainer%2A> doit être associé à un appel à <xref:System.Drawing.Graphics.EndContainer%2A>.</span><span class="sxs-lookup"><span data-stu-id="c77ae-106">Each call to <xref:System.Drawing.Graphics.BeginContainer%2A> must be paired with a call to <xref:System.Drawing.Graphics.EndContainer%2A>.</span></span>  
  
## <a name="transformations-in-nested-containers"></a><span data-ttu-id="c77ae-107">Transformations dans les conteneurs imbriqués</span><span class="sxs-lookup"><span data-stu-id="c77ae-107">Transformations in Nested Containers</span></span>  
 <span data-ttu-id="c77ae-108">L’exemple suivant crée un <xref:System.Drawing.Graphics> objet et un conteneur dans qui <xref:System.Drawing.Graphics> objet.</span><span class="sxs-lookup"><span data-stu-id="c77ae-108">The following example creates a <xref:System.Drawing.Graphics> object and a container within that <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="c77ae-109">La transformation universelle de la <xref:System.Drawing.Graphics> objet est une translation 100 unités sur l’axe x et 80 unités dans la direction y.</span><span class="sxs-lookup"><span data-stu-id="c77ae-109">The world transformation of the <xref:System.Drawing.Graphics> object is a translation 100 units in the x direction and 80 units in the y direction.</span></span> <span data-ttu-id="c77ae-110">La transformation universelle du conteneur est une rotation de 30 degrés.</span><span class="sxs-lookup"><span data-stu-id="c77ae-110">The world transformation of the container is a 30-degree rotation.</span></span> <span data-ttu-id="c77ae-111">Le code effectue l’appel `DrawRectangle(pen, -60, -30, 120, 60)` à deux reprises.</span><span class="sxs-lookup"><span data-stu-id="c77ae-111">The code makes the call `DrawRectangle(pen, -60, -30, 120, 60)` twice.</span></span> <span data-ttu-id="c77ae-112">Le premier appel à <xref:System.Drawing.Graphics.DrawRectangle%2A> est à l’intérieur du conteneur ; autrement dit, l’appel est entre les appels à <xref:System.Drawing.Graphics.BeginContainer%2A> et <xref:System.Drawing.Graphics.EndContainer%2A>.</span><span class="sxs-lookup"><span data-stu-id="c77ae-112">The first call to <xref:System.Drawing.Graphics.DrawRectangle%2A> is inside the container; that is, the call is in between the calls to <xref:System.Drawing.Graphics.BeginContainer%2A> and <xref:System.Drawing.Graphics.EndContainer%2A>.</span></span> <span data-ttu-id="c77ae-113">Le deuxième appel à <xref:System.Drawing.Graphics.DrawRectangle%2A> est après l’appel à <xref:System.Drawing.Graphics.EndContainer%2A>.</span><span class="sxs-lookup"><span data-stu-id="c77ae-113">The second call to <xref:System.Drawing.Graphics.DrawRectangle%2A> is after the call to <xref:System.Drawing.Graphics.EndContainer%2A>.</span></span>  
  
 [!code-csharp[System.Drawing.MiscLegacyTopics#61](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/CS/Class1.cs#61)]
 [!code-vb[System.Drawing.MiscLegacyTopics#61](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/VB/Class1.vb#61)]  
  
 <span data-ttu-id="c77ae-114">Dans le code précédent, le rectangle dessiné à l’intérieur du conteneur est modifié d’abord par la transformation universelle du conteneur (rotation), puis par la transformation universelle de la <xref:System.Drawing.Graphics> objet (translation).</span><span class="sxs-lookup"><span data-stu-id="c77ae-114">In the preceding code, the rectangle drawn from inside the container is transformed first by the world transformation of the container (rotation) and then by the world transformation of the <xref:System.Drawing.Graphics> object (translation).</span></span> <span data-ttu-id="c77ae-115">Le rectangle dessiné à l’extérieur du conteneur est transformé uniquement par la transformation universelle de la <xref:System.Drawing.Graphics> objet (translation).</span><span class="sxs-lookup"><span data-stu-id="c77ae-115">The rectangle drawn from outside the container is transformed only by the world transformation of the <xref:System.Drawing.Graphics> object (translation).</span></span> <span data-ttu-id="c77ae-116">L’illustration suivante montre les deux rectangles :</span><span class="sxs-lookup"><span data-stu-id="c77ae-116">The following illustration shows the two rectangles:</span></span> 
  
 ![Illustration des conteneurs imbriqués.](./media/using-nested-graphics-containers/nested-containers-illustration.png)  
  
## <a name="clipping-in-nested-containers"></a><span data-ttu-id="c77ae-118">Découpage dans les conteneurs imbriqués</span><span class="sxs-lookup"><span data-stu-id="c77ae-118">Clipping in Nested Containers</span></span>  
 <span data-ttu-id="c77ae-119">L’exemple suivant montre les conteneurs imbriqués comment gérer les régions de découpage.</span><span class="sxs-lookup"><span data-stu-id="c77ae-119">The following example demonstrates how nested containers handle clipping regions.</span></span> <span data-ttu-id="c77ae-120">Le code crée un <xref:System.Drawing.Graphics> objet et un conteneur dans qui <xref:System.Drawing.Graphics> objet.</span><span class="sxs-lookup"><span data-stu-id="c77ae-120">The code creates a <xref:System.Drawing.Graphics> object and a container within that <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="c77ae-121">La zone de découpage de le <xref:System.Drawing.Graphics> objet est un rectangle et la zone de découpage du conteneur est une ellipse.</span><span class="sxs-lookup"><span data-stu-id="c77ae-121">The clipping region of the <xref:System.Drawing.Graphics> object is a rectangle, and the clipping region of the container is an ellipse.</span></span> <span data-ttu-id="c77ae-122">Le code effectue deux appels à la <xref:System.Drawing.Graphics.DrawLine%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="c77ae-122">The code makes two calls to the <xref:System.Drawing.Graphics.DrawLine%2A> method.</span></span> <span data-ttu-id="c77ae-123">Le premier appel à <xref:System.Drawing.Graphics.DrawLine%2A> se trouve dans le conteneur et le deuxième appel à <xref:System.Drawing.Graphics.DrawLine%2A> est en dehors du conteneur (après l’appel à <xref:System.Drawing.Graphics.EndContainer%2A>).</span><span class="sxs-lookup"><span data-stu-id="c77ae-123">The first call to <xref:System.Drawing.Graphics.DrawLine%2A> is inside the container, and the second call to <xref:System.Drawing.Graphics.DrawLine%2A> is outside the container (after the call to <xref:System.Drawing.Graphics.EndContainer%2A>).</span></span> <span data-ttu-id="c77ae-124">La première ligne est découpée par l’intersection des deux régions de découpage.</span><span class="sxs-lookup"><span data-stu-id="c77ae-124">The first line is clipped by the intersection of the two clipping regions.</span></span> <span data-ttu-id="c77ae-125">La deuxième ligne est découpée par la région de découpage rectangulaire de la <xref:System.Drawing.Graphics> objet.</span><span class="sxs-lookup"><span data-stu-id="c77ae-125">The second line is clipped only by the rectangular clipping region of the <xref:System.Drawing.Graphics> object.</span></span>  
  
 [!code-csharp[System.Drawing.MiscLegacyTopics#62](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/CS/Class1.cs#62)]
 [!code-vb[System.Drawing.MiscLegacyTopics#62](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/VB/Class1.vb#62)]  
  
 <span data-ttu-id="c77ae-126">L’illustration suivante montre les deux lignes ajustées :</span><span class="sxs-lookup"><span data-stu-id="c77ae-126">The following illustration shows the two clipped lines:</span></span>
  
 ![Illustration qui montre un conteneur imbriqué avec traits découpés.](./media/using-nested-graphics-containers/nested-container-clipped-lines.png)  
  
 <span data-ttu-id="c77ae-128">Comme les deux exemples précédents montrent, les transformations et les régions de découpage sont cumulatifs dans des conteneurs imbriqués.</span><span class="sxs-lookup"><span data-stu-id="c77ae-128">As the two preceding examples show, transformations and clipping regions are cumulative in nested containers.</span></span> <span data-ttu-id="c77ae-129">Si vous définissez les transformations universelles du conteneur et le <xref:System.Drawing.Graphics> de l’objet, les deux transformations s’appliqueront aux éléments dessinés à l’intérieur du conteneur.</span><span class="sxs-lookup"><span data-stu-id="c77ae-129">If you set the world transformations of the container and the <xref:System.Drawing.Graphics> object, both transformations will apply to items drawn from inside the container.</span></span> <span data-ttu-id="c77ae-130">La transformation du conteneur sera appliquée en premier et la transformation de la <xref:System.Drawing.Graphics> objet s’appliquera ensuite.</span><span class="sxs-lookup"><span data-stu-id="c77ae-130">The transformation of the container will be applied first, and the transformation of the <xref:System.Drawing.Graphics> object will be applied second.</span></span> <span data-ttu-id="c77ae-131">Si vous définissez les régions de découpage du conteneur et le <xref:System.Drawing.Graphics> de l’objet, les éléments dessinés à l’intérieur du conteneur seront découpés par l’intersection des deux régions de découpage.</span><span class="sxs-lookup"><span data-stu-id="c77ae-131">If you set the clipping regions of the container and the <xref:System.Drawing.Graphics> object, items drawn from inside the container will be clipped by the intersection of the two clipping regions.</span></span>  
  
## <a name="quality-settings-in-nested-containers"></a><span data-ttu-id="c77ae-132">Paramètres de qualité dans les conteneurs imbriqués</span><span class="sxs-lookup"><span data-stu-id="c77ae-132">Quality Settings in Nested Containers</span></span>  
 <span data-ttu-id="c77ae-133">Paramètres de qualité (<xref:System.Drawing.Graphics.SmoothingMode%2A>, <xref:System.Drawing.Graphics.TextRenderingHint%2A>et autres) dans les conteneurs imbriqués ne sont pas cumulatifs ; au lieu de cela, les paramètres de qualité du conteneur remplacent temporairement les paramètres de qualité d’un <xref:System.Drawing.Graphics> objet.</span><span class="sxs-lookup"><span data-stu-id="c77ae-133">Quality settings (<xref:System.Drawing.Graphics.SmoothingMode%2A>, <xref:System.Drawing.Graphics.TextRenderingHint%2A>, and the like) in nested containers are not cumulative; rather, the quality settings of the container temporarily replace the quality settings of a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="c77ae-134">Lorsque vous créez un nouveau conteneur, les paramètres de qualité pour ce conteneur sont définis aux valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="c77ae-134">When you create a new container, the quality settings for that container are set to default values.</span></span> <span data-ttu-id="c77ae-135">Par exemple, supposons que vous ayez un <xref:System.Drawing.Graphics> objet avec le mode de lissage <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span><span class="sxs-lookup"><span data-stu-id="c77ae-135">For example, suppose you have a <xref:System.Drawing.Graphics> object with a smoothing mode of <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span></span> <span data-ttu-id="c77ae-136">Lorsque vous créez un conteneur, le mode de lissage dans le conteneur est la valeur par défaut en mode de lissage.</span><span class="sxs-lookup"><span data-stu-id="c77ae-136">When you create a container, the smoothing mode inside the container is the default smoothing mode.</span></span> <span data-ttu-id="c77ae-137">Vous êtes libre de définir le mode de lissage du conteneur et tous les éléments dessinés à l’intérieur du conteneur seront dessinés selon le mode que vous définissez.</span><span class="sxs-lookup"><span data-stu-id="c77ae-137">You are free to set the smoothing mode of the container, and any items drawn from inside the container will be drawn according to the mode you set.</span></span> <span data-ttu-id="c77ae-138">Éléments dessinés après l’appel à <xref:System.Drawing.Graphics.EndContainer%2A> sera dessiné selon le mode de lissage (<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>) qui était en place avant l’appel à <xref:System.Drawing.Graphics.BeginContainer%2A>.</span><span class="sxs-lookup"><span data-stu-id="c77ae-138">Items drawn after the call to <xref:System.Drawing.Graphics.EndContainer%2A> will be drawn according to the smoothing mode (<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>) that was in place before the call to <xref:System.Drawing.Graphics.BeginContainer%2A>.</span></span>  
  
## <a name="several-layers-of-nested-containers"></a><span data-ttu-id="c77ae-139">Plusieurs couches de conteneurs imbriqués</span><span class="sxs-lookup"><span data-stu-id="c77ae-139">Several Layers of Nested Containers</span></span>  
 <span data-ttu-id="c77ae-140">Vous n’êtes pas limité à un conteneur dans un <xref:System.Drawing.Graphics> objet.</span><span class="sxs-lookup"><span data-stu-id="c77ae-140">You are not limited to one container in a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="c77ae-141">Vous pouvez créer une séquence de conteneurs, chacun imbriqués dans l’exemple précédent, et vous pouvez spécifier la transformation universelle, zone de découpage et les paramètres de qualité de chacun de ces conteneurs imbriqués.</span><span class="sxs-lookup"><span data-stu-id="c77ae-141">You can create a sequence of containers, each nested in the preceding, and you can specify the world transformation, clipping region, and quality settings of each of those nested containers.</span></span> <span data-ttu-id="c77ae-142">Si vous appelez une méthode de dessin du conteneur le plus interne, les transformations sont appliquées dans l’ordre, en commençant par le conteneur le plus interne et en terminant par le conteneur le plus éloigné.</span><span class="sxs-lookup"><span data-stu-id="c77ae-142">If you call a drawing method from inside the innermost container, the transformations will be applied in order, starting with the innermost container and ending with the outermost container.</span></span> <span data-ttu-id="c77ae-143">Les éléments dessinés dans le conteneur le plus interne seront découpés par l’intersection de toutes les régions de découpage.</span><span class="sxs-lookup"><span data-stu-id="c77ae-143">Items drawn from inside the innermost container will be clipped by the intersection of all the clipping regions.</span></span>  
  
 <span data-ttu-id="c77ae-144">L’exemple suivant crée un <xref:System.Drawing.Graphics> de l’objet et affecte à son indicateur de rendu de texte <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span><span class="sxs-lookup"><span data-stu-id="c77ae-144">The following example creates a <xref:System.Drawing.Graphics> object and sets its text rendering hint to <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span></span> <span data-ttu-id="c77ae-145">Le code crée deux conteneurs, un imbriqué dans l’autre.</span><span class="sxs-lookup"><span data-stu-id="c77ae-145">The code creates two containers, one nested within the other.</span></span> <span data-ttu-id="c77ae-146">L’indicateur de rendu de texte du conteneur externe est défini sur <xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>, et l’indicateur de rendu de texte du conteneur interne est défini sur <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span><span class="sxs-lookup"><span data-stu-id="c77ae-146">The text rendering hint of the outer container is set to <xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>, and the text rendering hint of the inner container is set to <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span></span> <span data-ttu-id="c77ae-147">Le code dessine trois chaînes : une dans le conteneur interne, un dans le conteneur externe et un à partir de la <xref:System.Drawing.Graphics> objet lui-même.</span><span class="sxs-lookup"><span data-stu-id="c77ae-147">The code draws three strings: one from the inner container, one from the outer container, and one from the <xref:System.Drawing.Graphics> object itself.</span></span>  
  
 [!code-csharp[System.Drawing.MiscLegacyTopics#63](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/CS/Class1.cs#63)]
 [!code-vb[System.Drawing.MiscLegacyTopics#63](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/VB/Class1.vb#63)]  
  
 <span data-ttu-id="c77ae-148">L’illustration suivante montre les trois chaînes.</span><span class="sxs-lookup"><span data-stu-id="c77ae-148">The following illustration shows the three strings.</span></span> <span data-ttu-id="c77ae-149">Les chaînes dessinées dans le conteneur interne et à partir de la <xref:System.Drawing.Graphics> objet sont lissées par l’anticrénelage.</span><span class="sxs-lookup"><span data-stu-id="c77ae-149">The strings drawn from the inner container and from the <xref:System.Drawing.Graphics> object are smoothed by antialiasing.</span></span> <span data-ttu-id="c77ae-150">La chaîne dessinée dans le conteneur externe n’est pas lissée par l’anticrénelage car le <xref:System.Drawing.Graphics.TextRenderingHint%2A> propriété est définie sur <xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>.</span><span class="sxs-lookup"><span data-stu-id="c77ae-150">The string drawn from the outer container is not smoothed by antialiasing because the <xref:System.Drawing.Graphics.TextRenderingHint%2A> property is set to <xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>.</span></span>  
  
 ![Illustration qui affiche les chaînes issues des conteneurs imbriqués.](./media/using-nested-graphics-containers/nested-containers-three-strings.png)  
  
## <a name="see-also"></a><span data-ttu-id="c77ae-152">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="c77ae-152">See also</span></span>

- <xref:System.Drawing.Graphics>
- [<span data-ttu-id="c77ae-153">Gestion de l'état d'un objet graphique</span><span class="sxs-lookup"><span data-stu-id="c77ae-153">Managing the State of a Graphics Object</span></span>](managing-the-state-of-a-graphics-object.md)
