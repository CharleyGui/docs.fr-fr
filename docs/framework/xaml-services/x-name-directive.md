---
title: x:Name, directive
ms.date: 03/30/2017
f1_keywords:
- x:Name
- xName
- Name
helpviewer_keywords:
- x:Name attribute [XAML Services]
- XAML [XAML Services], x:Name attribute
- Name attribute in XAML [XAML Services]
ms.assetid: b7e61222-e8cf-48d2-acd0-6df3b7685d48
ms.openlocfilehash: 8a790ea964ffe399136a82ea298e1c7600f48366
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/03/2019
ms.locfileid: "73459968"
---
# <a name="xname-directive"></a><span data-ttu-id="a4b98-102">x:Name, directive</span><span class="sxs-lookup"><span data-stu-id="a4b98-102">x:Name Directive</span></span>
<span data-ttu-id="a4b98-103">Identifie de façon unique les éléments définis en XAML dans une portée de code XAML.</span><span class="sxs-lookup"><span data-stu-id="a4b98-103">Uniquely identifies XAML-defined elements in a XAML namescope.</span></span> <span data-ttu-id="a4b98-104">Les portées de code XAML et leurs modèles d’unicité peuvent être appliqués aux objets instanciés, lorsque les infrastructures fournissent des API ou implémentent des comportements qui accèdent au graphique d’objet créé en XAML au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="a4b98-104">XAML namescopes and their uniqueness models can be applied to the instantiated objects, when frameworks provide APIs or implement behaviors that access the XAML-created object graph at run time.</span></span>  
  
## <a name="xaml-attribute-usage"></a><span data-ttu-id="a4b98-105">Utilisation d'attributs XAML</span><span class="sxs-lookup"><span data-stu-id="a4b98-105">XAML Attribute Usage</span></span>  
  
```xaml  
<object x:Name="XAMLNameValue".../>  
```  
  
## <a name="xaml-values"></a><span data-ttu-id="a4b98-106">Valeurs XAML</span><span class="sxs-lookup"><span data-stu-id="a4b98-106">XAML Values</span></span>  
  
|||  
|-|-|  
|`XAMLNameValue`|<span data-ttu-id="a4b98-107">Chaîne conforme aux restrictions de la [grammaire XamlName](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="a4b98-107">A string that conforms to the restrictions of the [XamlName Grammar](xamlname-grammar.md).</span></span>|  
  
## <a name="remarks"></a><span data-ttu-id="a4b98-108">Notes</span><span class="sxs-lookup"><span data-stu-id="a4b98-108">Remarks</span></span>  
 <span data-ttu-id="a4b98-109">Une fois que `x:Name` est appliqué au modèle de programmation de stockage d’une infrastructure, le nom est équivalent à la variable qui contient une référence d’objet ou une instance de retournée par un constructeur.</span><span class="sxs-lookup"><span data-stu-id="a4b98-109">After `x:Name` is applied to a framework's backing programming model, the name is equivalent to the variable that holds an object reference or an instance as returned by a constructor.</span></span>  
  
 <span data-ttu-id="a4b98-110">La valeur de l’utilisation d’une directive `x:Name` doit être unique dans une portée de code XAML.</span><span class="sxs-lookup"><span data-stu-id="a4b98-110">The value of an `x:Name` directive usage must be unique within a XAML namescope.</span></span> <span data-ttu-id="a4b98-111">Par défaut lorsqu’il est utilisé par .NET Framework API des services XAML, la portée de code XAML principale est définie au niveau de l’élément racine XAML d’une production XAML unique et englobe les éléments contenus dans cette production XAML.</span><span class="sxs-lookup"><span data-stu-id="a4b98-111">By default when used by .NET Framework XAML Services API, the primary XAML namescope is defined at the XAML root element of a single XAML production, and encompasses the elements that are contained in that XAML production.</span></span> <span data-ttu-id="a4b98-112">Des portées de code XAML discrètes supplémentaires susceptibles de se produire dans une seule production XAML peuvent être définies par des infrastructures pour traiter des scénarios spécifiques.</span><span class="sxs-lookup"><span data-stu-id="a4b98-112">Additional discrete XAML namescopes that might occur within a single XAML production can be defined by frameworks to address specific scenarios.</span></span> <span data-ttu-id="a4b98-113">Par exemple, dans WPF, les nouvelles portées de code XAML sont définies et créées par n’importe quel modèle qui est également défini sur cette production XAML.</span><span class="sxs-lookup"><span data-stu-id="a4b98-113">For example, in WPF, new XAML namescopes are defined and created by any template that is also defined on that XAML production.</span></span> <span data-ttu-id="a4b98-114">Pour plus d’informations sur les portées de code XAML (écrites pour WPF, mais pertinentes pour de nombreux concepts de portée de code XAML), consultez portées de [code XAML WPF](../wpf/advanced/wpf-xaml-namescopes.md).</span><span class="sxs-lookup"><span data-stu-id="a4b98-114">For more information about XAML namescopes (written for WPF but relevant for many XAML namescope concepts), see [WPF XAML Namescopes](../wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="a4b98-115">En général, `x:Name` ne doit pas être appliqué dans les situations qui utilisent également `x:Key`.</span><span class="sxs-lookup"><span data-stu-id="a4b98-115">In general, `x:Name` should not be applied in situations that also use `x:Key`.</span></span> <span data-ttu-id="a4b98-116">Les implémentations XAML par des infrastructures existantes spécifiques ont introduit des concepts de substitution entre `x:Key` et `x:Name`, mais cela n’est pas une pratique recommandée.</span><span class="sxs-lookup"><span data-stu-id="a4b98-116">XAML implementations by specific existing frameworks have introduced substitution concepts between `x:Key` and `x:Name`, but that is not a recommended practice.</span></span> <span data-ttu-id="a4b98-117">Les services XAML .NET Framework ne prennent pas en charge les concepts de substitution de ce type lors de la gestion des informations de nom/clé, telles que <xref:System.Windows.Markup.INameScope> ou <xref:System.Windows.Markup.DictionaryKeyPropertyAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a4b98-117">.NET Framework XAML Services does not support such substitution concepts when handling name/key information such as <xref:System.Windows.Markup.INameScope> or <xref:System.Windows.Markup.DictionaryKeyPropertyAttribute>.</span></span>  
  
 <span data-ttu-id="a4b98-118">Les règles d’autorisation des `x:Name`, ainsi que la mise en application de l’unicité des noms, sont potentiellement définies par des frameworks d’implémentation spécifiques.</span><span class="sxs-lookup"><span data-stu-id="a4b98-118">Rules for permittance of `x:Name` as well as the name uniqueness enforcement are potentially defined by specific implementing frameworks.</span></span> <span data-ttu-id="a4b98-119">Toutefois, pour pouvoir être utilisé avec .NET Framework les services XAML, les définitions d’infrastructure de l’unicité de la portée de code XAML doivent être cohérentes avec la définition des informations d' <xref:System.Windows.Markup.INameScope> dans cette documentation et doivent utiliser les mêmes règles relatives à l’emplacement des informations est appliqué.</span><span class="sxs-lookup"><span data-stu-id="a4b98-119">However, to be usable with .NET Framework XAML Services, the framework definitions of XAML namescope uniqueness should be consistent with the definition of <xref:System.Windows.Markup.INameScope> information in this documentation, and should use the same rules regarding where the information is applied.</span></span> <span data-ttu-id="a4b98-120">Par exemple, l’implémentation de [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] divise différents éléments de balisage en plages <xref:System.Windows.NameScope> distinctes, telles que les dictionnaires de ressources, l’arborescence logique créée par le code XAML au niveau de la page, les modèles et d’autres contenus différés, puis applique le nom XAML unicité dans chacune de ces portées de code XAML.</span><span class="sxs-lookup"><span data-stu-id="a4b98-120">For example, the [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] implementation divides various markup elements into separate <xref:System.Windows.NameScope> ranges, such as resource dictionaries, the logical tree created by the page-level XAML, templates, and other deferred content, and then enforces XAML name uniqueness within each of those XAML namescopes.</span></span>  
  
 <span data-ttu-id="a4b98-121">Pour les types personnalisés qui utilisent .NET Framework Writers d’objet XAML des services XAML, une propriété qui mappe à `x:Name` sur un type peut être établie ou modifiée.</span><span class="sxs-lookup"><span data-stu-id="a4b98-121">For custom types that use .NET Framework XAML Services XAML object writers, a property that maps to `x:Name` on a type can be established or changed.</span></span> <span data-ttu-id="a4b98-122">Vous définissez ce comportement en référençant le nom de la propriété à mapper avec les <xref:System.Windows.Markup.RuntimeNamePropertyAttribute> dans le code de définition de type.</span><span class="sxs-lookup"><span data-stu-id="a4b98-122">You define this behavior by referencing the name of the property to map with the <xref:System.Windows.Markup.RuntimeNamePropertyAttribute> in the type definition code.</span></span>  <span data-ttu-id="a4b98-123"><xref:System.Windows.Markup.RuntimeNamePropertyAttribute> est un attribut de niveau type.</span><span class="sxs-lookup"><span data-stu-id="a4b98-123"><xref:System.Windows.Markup.RuntimeNamePropertyAttribute> is a type-level attribute.</span></span>  
  
 <span data-ttu-id="a4b98-124">Services XAML Using.NET Framework, la logique de stockage pour la prise en charge de la portée de code XAML peut être définie de façon indépendante du point de vue en implémentant l’interface <xref:System.Windows.Markup.INameScope>.</span><span class="sxs-lookup"><span data-stu-id="a4b98-124">Using.NET Framework XAML Services, the backing logic for XAML namescope support can be defined in a framework-neutral way by implementing the <xref:System.Windows.Markup.INameScope> interface.</span></span>  
  
## <a name="wpf-usage-notes"></a><span data-ttu-id="a4b98-125">Remarques sur l’utilisation de WPF</span><span class="sxs-lookup"><span data-stu-id="a4b98-125">WPF Usage Notes</span></span>  
 <span data-ttu-id="a4b98-126">Dans le cadre de la configuration de build standard pour une application [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] qui utilise XAML, des classes partielles et du code-behind, le `x:Name` spécifié devient le nom d’un champ créé dans le code sous-jacent lorsque [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] est traité par une build de compilation de balisage et ce champ contient une référence à l’objet.</span><span class="sxs-lookup"><span data-stu-id="a4b98-126">Under the standard build configuration for a [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] application that uses XAML, partial classes, and code-behind, the specified `x:Name` becomes the name of a field that is created in the underlying code when [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] is processed by a markup compilation build task, and that field holds a reference to the object.</span></span> <span data-ttu-id="a4b98-127">Par défaut, le champ créé est interne.</span><span class="sxs-lookup"><span data-stu-id="a4b98-127">By default, the created field is internal.</span></span> <span data-ttu-id="a4b98-128">Vous pouvez modifier l’accès aux champs en spécifiant l' [attribut x :FieldModifier](x-fieldmodifier-directive.md).</span><span class="sxs-lookup"><span data-stu-id="a4b98-128">You can change field access by specifying the [x:FieldModifier attribute](x-fieldmodifier-directive.md).</span></span> <span data-ttu-id="a4b98-129">Dans WPF et Silverlight, la séquence est que la compilation du balisage définit et nomme le champ dans une classe partielle, mais la valeur est initialement vide.</span><span class="sxs-lookup"><span data-stu-id="a4b98-129">In WPF and Silverlight, the sequence is that the markup compile defines and names the field in a partial class, but the value is initially empty.</span></span> <span data-ttu-id="a4b98-130">Ensuite, une méthode générée nommée `InitializeComponent` est appelée à partir du constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="a4b98-130">Then, a generated method named `InitializeComponent` is called from within the class constructor.</span></span> <span data-ttu-id="a4b98-131">`InitializeComponent` se compose d' `FindName` appels à l’aide de chacune des valeurs de `x:Name` qui existent dans la partie définie en XAML de la classe partielle en tant que chaînes d’entrée.</span><span class="sxs-lookup"><span data-stu-id="a4b98-131">`InitializeComponent` consists of `FindName` calls using each of the `x:Name` values that exist in the XAML-defined part of the partial class as input strings.</span></span> <span data-ttu-id="a4b98-132">Les valeurs de retour sont ensuite assignées à la référence de champ de nom similaire pour remplir les valeurs de champ avec les objets créés à partir de l’analyse XAML.</span><span class="sxs-lookup"><span data-stu-id="a4b98-132">The return values are then assigned to the like-named field reference to fill the field values with objects that were created from XAML parsing.</span></span> <span data-ttu-id="a4b98-133">L’exécution de `InitializeComponent` permet de référencer le graphique d’objet au moment de l’exécution en utilisant directement le nom de `x:Name`/champ, plutôt que d’appeler `FindName` explicitement chaque fois que vous avez besoin d’une référence à un objet défini en XAML.</span><span class="sxs-lookup"><span data-stu-id="a4b98-133">The execution of `InitializeComponent` make it possible to reference the run time object graph using the `x:Name` / field name directly, rather than having to call `FindName` explicitly any time you need a reference to a XAML-defined object.</span></span>  
  
 <span data-ttu-id="a4b98-134">Pour une application WPF qui utilise les cibles Microsoft Visual Basic et inclut des fichiers XAML avec `Page` action de génération, une propriété de référence distincte est créée lors de la compilation, qui ajoute le mot clé `WithEvents` à tous les éléments qui ont un `x:Name`, pour prendre en charge @no syntaxe __t_3_ pour les délégués de gestionnaires d’événements.</span><span class="sxs-lookup"><span data-stu-id="a4b98-134">For a WPF application that uses the Microsoft Visual Basic targets and includes XAML files with `Page` build action, a separate reference property is created during compilation that adds the `WithEvents` keyword to all elements that have an `x:Name`, to support `Handles` syntax for event handler delegates.</span></span> <span data-ttu-id="a4b98-135">Cette propriété est toujours publique.</span><span class="sxs-lookup"><span data-stu-id="a4b98-135">This property is always public.</span></span> <span data-ttu-id="a4b98-136">Pour plus d’informations, consultez [Gestion des événements Visual Basic et WPF](../wpf/advanced/visual-basic-and-wpf-event-handling.md).</span><span class="sxs-lookup"><span data-stu-id="a4b98-136">For more information, see [Visual Basic and WPF Event Handling](../wpf/advanced/visual-basic-and-wpf-event-handling.md).</span></span>  
  
 <span data-ttu-id="a4b98-137">`x:Name` est utilisé par le processeur XAML WPF pour inscrire un nom dans une portée de nom XAML au moment du chargement, même dans les cas où la page n’est pas compilée par balisage par des actions de génération (par exemple, le code XAML libre d’un dictionnaire de ressources).</span><span class="sxs-lookup"><span data-stu-id="a4b98-137">`x:Name` is used by the WPF XAML processor to register a name into a XAML namescope at load time, even for cases where the page is not markup-compiled by build actions (for example, loose XAML of a resource dictionary).</span></span> <span data-ttu-id="a4b98-138">Ce comportement peut être dû au fait que le `x:Name` est potentiellement nécessaire pour la liaison <xref:System.Windows.Data.Binding.ElementName%2A>.</span><span class="sxs-lookup"><span data-stu-id="a4b98-138">One reason for this behavior is because the `x:Name` is potentially needed for <xref:System.Windows.Data.Binding.ElementName%2A> binding.</span></span> <span data-ttu-id="a4b98-139">Pour plus d’informations, consultez [vue d’ensemble](../../desktop-wpf/data/data-binding-overview.md)de la liaison de données.</span><span class="sxs-lookup"><span data-stu-id="a4b98-139">For details, see [Data Binding Overview](../../desktop-wpf/data/data-binding-overview.md).</span></span>  
  
 <span data-ttu-id="a4b98-140">Comme mentionné précédemment, `x:Name` (ou `Name`) ne doit pas être appliqué dans les situations qui utilisent également `x:Key`.</span><span class="sxs-lookup"><span data-stu-id="a4b98-140">As mentioned previously, `x:Name` (or `Name`) should not be applied in situations that also use `x:Key`.</span></span> <span data-ttu-id="a4b98-141">Le <xref:System.Windows.ResourceDictionary> [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] a un comportement spécial qui se définit lui-même en tant que portée de code XAML, mais qui retourne des valeurs non implémentées ou null pour les API <xref:System.Windows.Markup.INameScope> comme un moyen d’appliquer ce comportement.</span><span class="sxs-lookup"><span data-stu-id="a4b98-141">The [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.ResourceDictionary> has a special behavior of defining itself as a XAML namescope but returning Not Implemented or null values for <xref:System.Windows.Markup.INameScope> APIs as a way to enforce this behavior.</span></span> <span data-ttu-id="a4b98-142">Si l’analyseur XAML WPF rencontre `Name` ou `x:Name` dans un <xref:System.Windows.ResourceDictionary>défini en XAML, le nom n’est pas ajouté à une portée de nom XAML.</span><span class="sxs-lookup"><span data-stu-id="a4b98-142">If the WPF XAML parser encounters `Name` or `x:Name` in a XAML-defined <xref:System.Windows.ResourceDictionary>, the name is not added to any XAML namescope.</span></span> <span data-ttu-id="a4b98-143">Toute tentative de recherche de ce nom à partir d’une portée de nom XAML et des méthodes `FindName` ne retourne pas de résultats valides.</span><span class="sxs-lookup"><span data-stu-id="a4b98-143">Attempting to find that name from any XAML namescope and the `FindName` methods will not return valid results.</span></span>  
  
### <a name="xname-and-name"></a><span data-ttu-id="a4b98-144">x :Name et Name</span><span class="sxs-lookup"><span data-stu-id="a4b98-144">x:Name and Name</span></span>  
 <span data-ttu-id="a4b98-145">De nombreux scénarios d’application WPF peuvent éviter toute utilisation de l’attribut `x:Name`, car l' `Name` propriété de dépendance telle qu’elle est spécifiée dans l’espace de noms XAML par défaut pour plusieurs classes de base importantes, telles que <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> remplit ce même objectif.</span><span class="sxs-lookup"><span data-stu-id="a4b98-145">Many WPF application scenarios can avoid any use of the `x:Name` attribute, because the `Name` dependency property as specified in the default XAML namespace for several of the important base classes such as <xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> satisfies this same purpose.</span></span> <span data-ttu-id="a4b98-146">Il existe toujours des scénarios XAML et WPF courants dans lesquels le code qui accède à un élément sans `Name` propriété au niveau de l’infrastructure est important.</span><span class="sxs-lookup"><span data-stu-id="a4b98-146">There are still some common XAML and WPF scenarios where code access to an element with no `Name` property at the framework level is important.</span></span> <span data-ttu-id="a4b98-147">Par exemple, certaines classes d’animation et de prise en charge des storyboards ne prennent pas en charge une propriété `Name`, mais elles doivent souvent être référencées dans le code afin de contrôler l’animation.</span><span class="sxs-lookup"><span data-stu-id="a4b98-147">For example, certain animation and storyboard support classes do not support a `Name` property, but they often need to be referenced in code in order to control the animation.</span></span> <span data-ttu-id="a4b98-148">Vous devez spécifier `x:Name` en tant qu’attribut sur les chronologies et les transformations créées en XAML, si vous envisagez de les référencer à partir du code ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="a4b98-148">You should specify `x:Name` as an attribute on timelines and transforms that are created in XAML, if you intend to reference them from code later.</span></span>  
  
 <span data-ttu-id="a4b98-149">Si <xref:System.Windows.FrameworkElement.Name%2A> est disponible en tant que propriété sur la classe, <xref:System.Windows.FrameworkElement.Name%2A> et `x:Name` peuvent être utilisés de manière interchangeable en tant qu’attributs, mais une exception d’analyse se produit si les deux sont spécifiés sur le même élément.</span><span class="sxs-lookup"><span data-stu-id="a4b98-149">If <xref:System.Windows.FrameworkElement.Name%2A> is available as a property on the class, <xref:System.Windows.FrameworkElement.Name%2A> and `x:Name` can be used interchangeably as attributes, but a parse exception will result if both are specified on the same element.</span></span> <span data-ttu-id="a4b98-150">Si le code XAML est compilé par balisage, l’exception se produit lors de la compilation du balisage. dans le cas contraire, il se produit lors du chargement.</span><span class="sxs-lookup"><span data-stu-id="a4b98-150">If the XAML is markup compiled, the exception will occur on the markup compile, otherwise it occurs on load.</span></span>  
  
 <span data-ttu-id="a4b98-151"><xref:System.Windows.FrameworkElement.Name%2A> peut être défini à l’aide de la syntaxe d’attribut XAML et dans le code à l’aide de <xref:System.Windows.DependencyObject.SetValue%2A>; Notez cependant que la définition de la propriété <xref:System.Windows.FrameworkElement.Name%2A> dans le code ne crée pas la référence de champ représentative dans la portée de code XAML dans la plupart des cas où le code XAML est déjà chargé.</span><span class="sxs-lookup"><span data-stu-id="a4b98-151"><xref:System.Windows.FrameworkElement.Name%2A> can be set using XAML attribute syntax, and in code using <xref:System.Windows.DependencyObject.SetValue%2A>; note however that setting the <xref:System.Windows.FrameworkElement.Name%2A> property in code does not create the representative field reference within the XAML namescope in most circumstances where the XAML is already loaded.</span></span> <span data-ttu-id="a4b98-152">Au lieu de tenter de définir <xref:System.Windows.FrameworkElement.Name%2A> dans le code, utilisez <xref:System.Windows.NameScope> méthodes à partir du code, par rapport à la portée de code appropriée.</span><span class="sxs-lookup"><span data-stu-id="a4b98-152">Instead of attempting to set <xref:System.Windows.FrameworkElement.Name%2A> in code, use <xref:System.Windows.NameScope> methods from code, against the appropriate namescope.</span></span>  
  
 <span data-ttu-id="a4b98-153"><xref:System.Windows.FrameworkElement.Name%2A> peut également être défini à l’aide de la syntaxe d’élément de propriété avec du texte interne, mais cela n’est pas courant.</span><span class="sxs-lookup"><span data-stu-id="a4b98-153"><xref:System.Windows.FrameworkElement.Name%2A> can also be set using property element syntax with inner text, but that is uncommon.</span></span> <span data-ttu-id="a4b98-154">En revanche, `x:Name` ne peut pas être défini dans la syntaxe d’élément de propriété XAML ou dans le code à l’aide de <xref:System.Windows.DependencyObject.SetValue%2A>; elle ne peut être définie qu’à l’aide de la syntaxe d’attribut sur les objets, car il s’agit d’une directive.</span><span class="sxs-lookup"><span data-stu-id="a4b98-154">In contrast, `x:Name` cannot be set in XAML property element syntax, or in code using <xref:System.Windows.DependencyObject.SetValue%2A>; it can only be set using attribute syntax on objects because it is a directive.</span></span>  
  
## <a name="silverlight-usage-notes"></a><span data-ttu-id="a4b98-155">Remarques sur l’utilisation de Silverlight</span><span class="sxs-lookup"><span data-stu-id="a4b98-155">Silverlight Usage Notes</span></span>  
 <span data-ttu-id="a4b98-156">`x:Name` pour Silverlight est documenté séparément.</span><span class="sxs-lookup"><span data-stu-id="a4b98-156">`x:Name` for Silverlight is documented separately.</span></span> <span data-ttu-id="a4b98-157">Pour plus d’informations, consultez [espace de noms XAML (x :) Fonctionnalités de langage (Silverlight)](https://go.microsoft.com/fwlink/?LinkId=199081).</span><span class="sxs-lookup"><span data-stu-id="a4b98-157">For more information, see [XAML Namespace (x:) Language Features (Silverlight)](https://go.microsoft.com/fwlink/?LinkId=199081).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a4b98-158">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="a4b98-158">See also</span></span>

- <xref:System.Windows.FrameworkElement.Name%2A?displayProperty=nameWithType>
- <xref:System.Windows.FrameworkContentElement.Name%2A?displayProperty=nameWithType>
- [<span data-ttu-id="a4b98-159">Arborescences dans WPF</span><span class="sxs-lookup"><span data-stu-id="a4b98-159">Trees in WPF</span></span>](../wpf/advanced/trees-in-wpf.md)
