---
title: Vue d'ensemble de l'architecture de transfert de données
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: f34bf82ec44140827c5d8da59911afe10ab7a853
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84576471"
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="ad4a4-102">Vue d'ensemble de l'architecture de transfert de données</span><span class="sxs-lookup"><span data-stu-id="ad4a4-102">Data Transfer Architectural Overview</span></span>
<span data-ttu-id="ad4a4-103">Windows Communication Foundation (WCF) peut être considéré comme une infrastructure de messagerie.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-103">Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="ad4a4-104">Il peut recevoir des messages, les traiter et les distribuer au code utilisateur pour action ultérieure, ou il peut construire des messages à partir des données fournies par le code utilisateur et les transmettre vers une destination.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="ad4a4-105">Cette rubrique, conçue à l'attention des développeurs avancés, décrit l'architecture de gestion des messages et des données qu'ils contiennent.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="ad4a4-106">Pour une approche plus simple des tâches d’envoi et de réception des données, consultez [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ad4a4-107">Cette rubrique traite des détails de l’implémentation de WCF qui ne sont pas visibles en examinant le modèle objet WCF.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-107">This topic discusses WCF implementation details that are not visible by examining the WCF object model.</span></span> <span data-ttu-id="ad4a4-108">Deux mots d'avertissement s'imposent concernant les détails d'implémentation documentés.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="ad4a4-109">Premièrement, les descriptions sont simplifiées ; l'implémentation réelle peut s'avérer plus complexe en raison des optimisations ou pour d'autres raisons.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="ad4a4-110">Deuxièmement, vous ne devez jamais vous appuyer sur des détails d'implémentation spécifiques, même s'ils sont documentés, car ils peuvent changer sans préavis d'une version à une autre, voire même dans une version de maintenance.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="ad4a4-111">Architecture de base</span><span class="sxs-lookup"><span data-stu-id="ad4a4-111">Basic Architecture</span></span>  
 <span data-ttu-id="ad4a4-112">La <xref:System.ServiceModel.Channels.Message> classe, qui est décrite en détail dans [utilisation de la classe message](using-the-message-class.md), est au cœur des fonctionnalités de gestion des messages WCF.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-112">At the core of WCF message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](using-the-message-class.md).</span></span> <span data-ttu-id="ad4a4-113">Les composants runtime de WCF peuvent être divisés en deux parties principales : la pile de canaux et l’infrastructure de service, la <xref:System.ServiceModel.Channels.Message> classe étant le point de connexion.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-113">The run-time components of WCF can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="ad4a4-114">La pile de canaux est chargée d'effectuer la conversion entre une instance <xref:System.ServiceModel.Channels.Message> valide et des actions qui correspondent à l'émission ou à la réception de données de message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="ad4a4-115">Du côté envoi, la pile de canaux prend une instance <xref:System.ServiceModel.Channels.Message> valide et, après traitement, exécute des actions qui logiquement correspondent à l'envoi du message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="ad4a4-116">L'action peut envoyer des paquets TCP ou HTTP, mettre le message en file d'attente dans Message Queuing, écrire le message dans une base de données, l'enregistrer dans un partage de fichiers, ou effectuer toute autre action, selon l'implémentation.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="ad4a4-117">L'action la plus courante consiste à envoyer les messages sur un protocole réseau.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="ad4a4-118">Du côté réception, c'est la procédure inverse qui se produit : l'action est détectée (il peut s'agir de paquets TCP ou HTTP qui arrivent ou de toute autre action), et, après traitement, la pile de canaux convertit cette action en instance <xref:System.ServiceModel.Channels.Message> valide.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="ad4a4-119">Vous pouvez utiliser WCF à l’aide de la <xref:System.ServiceModel.Channels.Message> classe et de la pile de canaux directement.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-119">You can use WCF by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="ad4a4-120">Cependant, cette procédure s'avère difficile et fastidieuse.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="ad4a4-121">En outre, l' <xref:System.ServiceModel.Channels.Message> objet ne fournit aucune prise en charge des métadonnées. vous ne pouvez donc pas générer de clients WCF fortement typés si vous utilisez WCF de cette manière.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed WCF clients if you use WCF in this manner.</span></span>  
  
 <span data-ttu-id="ad4a4-122">Par conséquent, WCF inclut une infrastructure de service qui fournit un modèle de programmation facile à utiliser que vous pouvez utiliser pour construire et recevoir des `Message` objets.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-122">Therefore, WCF includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="ad4a4-123">L’infrastructure de service mappe des services aux types de .NET Framework via la notion de contrats de service et distribue des messages aux opérations utilisateur qui sont simplement .NET Framework méthodes marquées avec l' <xref:System.ServiceModel.OperationContractAttribute> attribut (pour plus d’informations, consultez [conception de contrats de service](../designing-service-contracts.md)).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-123">The service framework maps services to .NET Framework types through the notion of service contracts, and dispatches messages to user operations that are simply .NET Framework methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../designing-service-contracts.md)).</span></span> <span data-ttu-id="ad4a4-124">Ces méthodes peuvent avoir des paramètres et des valeurs de retour.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="ad4a4-125">Du côté service, l'infrastructure de service convertit les instances entrantes <xref:System.ServiceModel.Channels.Message> en paramètres, et convertit les valeurs de retour en instances sortantes <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="ad4a4-126">Du côté client, elle fait le contraire.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="ad4a4-127">Examinons, par exemple, l'opération `FindAirfare` ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="ad4a4-128">Supposons que `FindAirfare` est appelé sur le client.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="ad4a4-129">L'infrastructure de service sur le client convertit les paramètres `FromCity` et `ToCity` en instance sortante <xref:System.ServiceModel.Channels.Message> et la passe à la pile de canaux afin de l'envoyer.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="ad4a4-130">Du côté service, lorsqu'une instance <xref:System.ServiceModel.Channels.Message> arrive de la pile de canaux, l'infrastructure de service extrait les données pertinentes du message afin de renseigner les paramètres `FromCity` et `ToCity` , puis appelle la méthode `FindAirfare` côté service.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="ad4a4-131">Lorsque la méthode retourne, l'infrastructure de service prend la valeur entière retournée et le paramètre de sortie `IsDirectFlight` , puis crée une instance d'objet <xref:System.ServiceModel.Channels.Message> qui contient ces informations.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="ad4a4-132">Elle passe ensuite l'instance `Message` à la pile de canaux afin de la renvoyer au client.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="ad4a4-133">Du côté client, une instance <xref:System.ServiceModel.Channels.Message> qui contient le message de réponse émerge de la pile de canaux.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="ad4a4-134">L'infrastructure de service extrait la valeur de retour et la valeur `IsDirectFlight` , puis les retourne à l'appelant du client.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="ad4a4-135">Classe Message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-135">Message Class</span></span>  
 <span data-ttu-id="ad4a4-136">La classe <xref:System.ServiceModel.Channels.Message> est destinée à être la représentation abstraite d'un message, mais sa conception est fortement associée au message SOAP.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="ad4a4-137"><xref:System.ServiceModel.Channels.Message> contient trois éléments d'information principaux : corps du message, en-têtes de message et propriétés de message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="ad4a4-138">Corps du message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-138">Message Body</span></span>  
 <span data-ttu-id="ad4a4-139">Le corps du message est destiné à représenter la charge utile de données réelle du message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="ad4a4-140">Le corps du message est toujours représenté sous forme d'un ensemble d'informations XML.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="ad4a4-141">Cela ne signifie pas que tous les messages créés ou reçus dans WCF doivent être au format XML.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-141">This does not mean that all messages created or received in WCF must be in XML format.</span></span> <span data-ttu-id="ad4a4-142">C'est à la pile de canaux qu'il revient de décider de l'interprétation du corps du message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="ad4a4-143">Elle peut l'émettre au format XML, le convertir dans un autre, ou même l'omettre entièrement.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="ad4a4-144">Bien entendu, avec la plupart des liaisons fournies par WCF, le corps du message est représenté sous forme de contenu XML dans la section de corps d’une enveloppe SOAP.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-144">Of course, with most of the bindings WCF supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="ad4a4-145">Il est important de savoir que la classe `Message` ne contient pas nécessairement de mémoire tampon avec des données XML représentant le corps.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="ad4a4-146">Logiquement, `Message` contient un ensemble d'informations XML, mais celui-ci peut être construit dynamiquement et peut ne jamais exister physiquement en mémoire.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="ad4a4-147">Placement de données dans le corps du message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-147">Putting Data into the Message Body</span></span>  
 <span data-ttu-id="ad4a4-148">Il n'existe pas de mécanisme uniforme pour placer des données dans le corps d'un message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="ad4a4-149">La classe <xref:System.ServiceModel.Channels.Message> a une méthode abstraite, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, qui prend un <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="ad4a4-150">Chaque sous-classe de la classe <xref:System.ServiceModel.Channels.Message> est chargée de substituer cette méthode et d'écrire son propre contenu.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="ad4a4-151">Le corps du message contient logiquement l'ensemble d'informations XML généré par `OnWriteBodyContent` .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="ad4a4-152">Examinons, par exemple, la classe `Message` suivante :</span><span class="sxs-lookup"><span data-stu-id="ad4a4-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="ad4a4-153">Physiquement, une instance `AirfareRequestMessage` contient uniquement deux chaînes (« fromCity » et « toCity »).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="ad4a4-154">Cependant, le message contient logiquement l'ensemble d'informations XML suivant :</span><span class="sxs-lookup"><span data-stu-id="ad4a4-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="ad4a4-155">Bien évidemment, vous ne créez pas de message de cette manière normalement, car vous pouvez utiliser l'infrastructure de service pour créer un message comme le précédent à partir des paramètres de contrat d'opération.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="ad4a4-156">En outre, la classe <xref:System.ServiceModel.Channels.Message> a des méthodes `CreateMessage` statiques qui vous permettent de créer des messages avec des types courants de contenu : un message vide, un message contenant un objet sérialisé en XML avec <xref:System.Runtime.Serialization.DataContractSerializer>, un message contenant une erreur SOAP, un message contenant du XML représenté par <xref:System.Xml.XmlReader>, etc.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="ad4a4-157">Extraction des données du corps d'un message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-157">Getting Data from a Message Body</span></span>  
 <span data-ttu-id="ad4a4-158">Vous pouvez extraire les données stockées dans le corps d'un message de deux principales manières :</span><span class="sxs-lookup"><span data-stu-id="ad4a4-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
- <span data-ttu-id="ad4a4-159">Vous pouvez extraire l'ensemble du corps du message en une seule opération en appelant la méthode <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> et en le passant dans un enregistreur XML.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="ad4a4-160">L'ensemble du corps du message est écrit dans cet enregistreur.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="ad4a4-161">L'extraction de l'ensemble du corps du message en une seule opération est également appelée *écriture de message*.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="ad4a4-162">L'écriture est principalement effectuée par la pile de canaux lors de l'envoi des messages : certaines parties de la pile de canaux accèdent généralement à l'ensemble du corps du message, l'encodent et l'envoient.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
- <span data-ttu-id="ad4a4-163">Une autre méthode consiste à appeler <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> et à placer un lecteur XML.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="ad4a4-164">Le corps du message peut être accédé séquentiellement si nécessaire en appelant des méthodes sur le lecteur.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="ad4a4-165">L'extraction du corps du message élément par élément est également appelée *lecture de message*.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="ad4a4-166">La lecture du message est principalement utilisée par l'infrastructure de service lors de la réception des messages.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="ad4a4-167">Par exemple, lorsque <xref:System.Runtime.Serialization.DataContractSerializer> est en cours d'utilisation, l'infrastructure de service place un lecteur XML sur le corps et le passe au moteur de désérialisation, qui commence ensuite à lire le message élément par élément et à construire le graphique d'objets correspondant.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="ad4a4-168">Le corps d'un message ne peut être récupéré qu'une seule fois.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="ad4a4-169">Cela permet d'utiliser des flux avant uniquement.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="ad4a4-170">Par exemple, vous pouvez écrire une substitution <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> que lit à partir de <xref:System.IO.FileStream> et retourne les résultats sous forme d'un ensemble d'informations XML.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="ad4a4-171">Vous n’aurez jamais besoin de « rembobiner » au début du fichier.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="ad4a4-172">Les méthodes `WriteBodyContents` et `GetReaderAtBodyContents` vérifient simplement que le corps du message n'a jamais été récupéré auparavant, puis appellent `OnWriteBodyContents` ou `OnGetReaderAtBodyContents`, respectivement.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="ad4a4-173">Utilisation des messages dans WCF</span><span class="sxs-lookup"><span data-stu-id="ad4a4-173">Message Usage in WCF</span></span>  
 <span data-ttu-id="ad4a4-174">La plupart des messages peuvent être classés comme étant *sortants* (ceux créés par l'infrastructure de service pour être envoyés par la pile de canaux) ou *entrants* (ceux qui proviennent de la pile de canaux et qui sont interprétés par l'infrastructure de service).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="ad4a4-175">En outre, la pile de canaux peut fonctionner en mode de mise en mémoire tampon ou en mode de diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="ad4a4-176">L'infrastructure de service peut également exposer un modèle de programmation avec ou sans diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="ad4a4-177">Cela conduit aux cas répertoriés dans le tableau suivant, accompagnés des détails simplifiés de leur implémentation.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="ad4a4-178">type de message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-178">Message type</span></span>|<span data-ttu-id="ad4a4-179">Données relatives au corps du message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-179">Body data in message</span></span>|<span data-ttu-id="ad4a4-180">Implémentation de l'écriture (OnWriteBodyContents)</span><span class="sxs-lookup"><span data-stu-id="ad4a4-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="ad4a4-181">Implémentation de la lecture (OnGetReaderAtBodyContents)</span><span class="sxs-lookup"><span data-stu-id="ad4a4-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="ad4a4-182">Sortant, créé à partir du modèle de programmation sans diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="ad4a4-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="ad4a4-183">Les données nécessaires pour écrire le message (par exemple, un objet et l'instance <xref:System.Runtime.Serialization.DataContractSerializer> nécessaires pour le sérialiser)\*</span><span class="sxs-lookup"><span data-stu-id="ad4a4-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="ad4a4-184">Logique personnalisée d'écriture du message basée sur les données stockées (par exemple, appelez `WriteObject` sur `DataContractSerializer` s'il s'agit du sérialiseur utilisé)\*</span><span class="sxs-lookup"><span data-stu-id="ad4a4-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="ad4a4-185">Appelle `OnWriteBodyContents`, met les résultats en mémoire tampon, retourne un lecteur XML sur la mémoire tampon</span><span class="sxs-lookup"><span data-stu-id="ad4a4-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="ad4a4-186">Sortant, créé à partir du modèle de programmation avec diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="ad4a4-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="ad4a4-187">`Stream` dans lequel les données doivent être écrites\*</span><span class="sxs-lookup"><span data-stu-id="ad4a4-187">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="ad4a4-188">Écrit les données provenant du flux stocké à l'aide du mécanisme <xref:System.Xml.IStreamProvider> \*</span><span class="sxs-lookup"><span data-stu-id="ad4a4-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="ad4a4-189">Appelle `OnWriteBodyContents`, met les résultats en mémoire tampon, retourne un lecteur XML sur la mémoire tampon</span><span class="sxs-lookup"><span data-stu-id="ad4a4-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="ad4a4-190">Entrant, provenant de la pile de canaux de diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="ad4a4-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="ad4a4-191">Objet `Stream` qui représente les données entrant sur le réseau avec un <xref:System.Xml.XmlReader> placé sur celui-ci</span><span class="sxs-lookup"><span data-stu-id="ad4a4-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="ad4a4-192">Écrit le contenu provenant du `XmlReader` stocké à l'aide de `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="ad4a4-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="ad4a4-193">Retourne le `XmlReader`stocké</span><span class="sxs-lookup"><span data-stu-id="ad4a4-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="ad4a4-194">Entrant, provenant de la pile de canaux sans diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="ad4a4-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="ad4a4-195">Mémoire tampon qui contient les données relatives au corps avec un `XmlReader` placé sur celle-ci</span><span class="sxs-lookup"><span data-stu-id="ad4a4-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="ad4a4-196">Écrit le contenu provenant du `XmlReader` stocké à l'aide de `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="ad4a4-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="ad4a4-197">Retourne le langage stocké</span><span class="sxs-lookup"><span data-stu-id="ad4a4-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="ad4a4-198">\*Ces éléments ne sont pas implémentés directement dans les sous- `Message` classes, mais dans les sous-classes de la <xref:System.ServiceModel.Channels.BodyWriter> classe.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="ad4a4-199">Pour plus d'informations sur le <xref:System.ServiceModel.Channels.BodyWriter>, consultez [Using the Message Class](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="ad4a4-200">En-têtes de message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-200">Message Headers</span></span>  
 <span data-ttu-id="ad4a4-201">Un message peut contenir des en-têtes.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-201">A message may contain headers.</span></span> <span data-ttu-id="ad4a4-202">Un en-tête se compose logiquement d'un ensemble d'informations XML associé à un nom, à un espace de noms et à d'autres propriétés.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="ad4a4-203">Les en-têtes de message sont accessibles à l'aide de la propriété `Headers` sur <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="ad4a4-204">Chaque en-tête est représenté par une classe <xref:System.ServiceModel.Channels.MessageHeader> .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="ad4a4-205">En général, les en-têtes de message sont mappés vers les en-têtes de message SOAP lors de l'utilisation d'une pile de canaux configurée pour fonctionner avec des messages SOAP.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="ad4a4-206">Placer des informations dans un en-tête de message et les en extraire est un processus similaire à celui qui consiste à utiliser le corps du message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="ad4a4-207">Il est quelque peu simplifié car la diffusion en continu n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="ad4a4-208">Il est possible d'accéder plusieurs fois au contenu du même en-tête, et les en-têtes sont accessibles dans un ordre arbitraire, en forçant systématiquement leur mise en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="ad4a4-209">Il n’existe pas de mécanisme à usage général pour obtenir un lecteur XML sur un en-tête, mais il existe une `MessageHeader` sous-classe interne à WCF qui représente un en-tête lisible avec une telle fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to WCF that represents a readable header with such a capability.</span></span> <span data-ttu-id="ad4a4-210">Ce type de `MessageHeader` est créé par la pile de canaux lors de la réception d'un message avec en-têtes d'application personnalisés.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="ad4a4-211">Cela permet à l'infrastructure de service d'utiliser un moteur de désérialisation, tel que l'objet <xref:System.Runtime.Serialization.DataContractSerializer>, pour interpréter ces en-têtes.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 <span data-ttu-id="ad4a4-212">Pour plus d’informations, consultez [utilisation de la classe message](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-212">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="ad4a4-213">Propriétés de message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-213">Message Properties</span></span>  
 <span data-ttu-id="ad4a4-214">Un message peut contenir des propriétés.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-214">A message may contain properties.</span></span> <span data-ttu-id="ad4a4-215">Une *propriété* est un objet .NET Framework associé à un nom de chaîne.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-215">A *property* is any .NET Framework object that is associated with a string name.</span></span> <span data-ttu-id="ad4a4-216">Les propriétés sont accessibles via la propriété `Properties` sur `Message`.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="ad4a4-217">Contrairement au corps et aux en-têtes de message (qui mappent normalement vers le corps et les en-têtes SOAP, respectivement), les propriétés de message ne sont en général pas envoyées ou reçues avec les messages.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="ad4a4-218">Les propriétés de message constituent principalement un mécanisme de communication permettant de passer les données sur le message entre les divers canaux de la pile, et entre la pile de canaux et le modèle de service.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="ad4a4-219">Par exemple, le canal de transport HTTP inclus dans le cadre de WCF est en mesure de produire divers codes d’état HTTP, tels que « 404 (introuvable) » et « 500 (erreur de serveur interne) », lorsqu’il envoie des réponses aux clients.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-219">For example, the HTTP transport channel included as part of WCF is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="ad4a4-220">Avant d’envoyer un message de réponse, il vérifie si le `Properties` du `Message` contient une propriété appelée « HttpResponse » qui contient un objet de type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty> .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="ad4a4-221">Si une propriété de ce type est trouvée, il regardera au niveau de la propriété <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> et utilisera ce code d'état.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="ad4a4-222">Dans le cas contraire, le code "200 (OK)" par défaut est utilisé.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 <span data-ttu-id="ad4a4-223">Pour plus d’informations, consultez [utilisation de la classe message](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-223">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="ad4a4-224">Le message dans son ensemble</span><span class="sxs-lookup"><span data-stu-id="ad4a4-224">The Message as a Whole</span></span>  
 <span data-ttu-id="ad4a4-225">Nous avons jusqu'à maintenant présenté les méthodes d'accès aux diverses parties du message indépendamment les unes des autres.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="ad4a4-226">Toutefois, la classe <xref:System.ServiceModel.Channels.Message> fournit également des méthodes permettant d'utiliser le message dans son ensemble.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="ad4a4-227">Par exemple, la méthode `WriteMessage` écrit l'ensemble du message dans un enregistreur XML.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="ad4a4-228">Pour que cela soit possible, un mappage doit être défini entre l'instance `Message` entière et un ensemble d'informations XML.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="ad4a4-229">En fait, un mappage de ce type existe : WCF utilise la norme SOAP pour définir ce mappage.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-229">Such a mapping, in fact, exists: WCF uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="ad4a4-230">Lorsqu'une instance `Message` est écrite en tant qu'ensemble d'informations XML, l'ensemble d'informations résultant est l'enveloppe SOAP valide qui contient le message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="ad4a4-231">Par conséquent, `WriteMessage` exécute normalement les étapes suivantes :</span><span class="sxs-lookup"><span data-stu-id="ad4a4-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1. <span data-ttu-id="ad4a4-232">Écrire la balise d'ouverture de l'élément d'enveloppe SOAP.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-232">Write the SOAP envelope element opening tag.</span></span>  
  
2. <span data-ttu-id="ad4a4-233">Écrire la balise d'ouverture de l'élément d'en-tête SOAP, écrire tous les en-têtes et fermer l'élément d'en-tête.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3. <span data-ttu-id="ad4a4-234">Écrire la balise d'ouverture de l'élément de corps SOAP.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-234">Write the SOAP body element opening tag.</span></span>  
  
4. <span data-ttu-id="ad4a4-235">Appeler `WriteBodyContents` ou une méthode équivalente pour écrire le corps.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5. <span data-ttu-id="ad4a4-236">Fermer les éléments de corps et d'enveloppe.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="ad4a4-237">Les étapes précédentes sont étroitement liées au standard SOAP.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="ad4a4-238">Cela est compliqué par le fait que plusieurs versions de SOAP existent ; à titre d'exemple, il est impossible d'écrire l'élément d'enveloppe SOAP correctement sans connaître la version SOAP utilisée.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="ad4a4-239">Par ailleurs, il peut dans certains cas s'avérer souhaitable de désactiver complètement ce mappage complexe spécifique à SOAP.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="ad4a4-240">À ces fins, une propriété `Version` est fournie sur `Message`.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="ad4a4-241">Elle peut être définie à la version SOAP à utiliser lors de l'écriture du message, ou avoir la valeur `None` afin d'empêcher tout mappage spécifique à SOAP.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="ad4a4-242">Si la propriété `Version` a la valeur `None`, les méthodes qui utilisent l'ensemble du message agissent comme si le message était uniquement composé de son corps ; par exemple, `WriteMessage` appelle simplement `WriteBodyContents` au lieu d'exécuter les multiples étapes répertoriées ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="ad4a4-243">`Version` est supposé être détecté automatiquement et être défini correctement sur les messages entrants.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="ad4a4-244">Pile de canaux</span><span class="sxs-lookup"><span data-stu-id="ad4a4-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="ad4a4-245">Canaux</span><span class="sxs-lookup"><span data-stu-id="ad4a4-245">Channels</span></span>  
 <span data-ttu-id="ad4a4-246">Comme indiqué précédemment, la pile de canaux est chargée de convertir les instances <xref:System.ServiceModel.Channels.Message> sortantes en actions (par exemple envoyer des paquets sur le réseau), ou de convertir des actions (par exemple recevoir des paquets réseau) en instances `Message` entrantes.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="ad4a4-247">La pile de canaux est composée d'un ou de plusieurs canaux ordonnés dans une séquence.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="ad4a4-248">Une instance `Message` sortante est passée au premier canal dans la pile (également appelé *canal le plus haut*), qui le passe au canal immédiatement inférieur dans la pile, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="ad4a4-249">Le message se termine dans le dernier canal, appelé *canal de transport*.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="ad4a4-250">Les messages entrants sont générés dans le canal de transport et sont passés d'un canal à l'autre vers le haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="ad4a4-251">Lorsqu'il se trouve dans le canal le plus haut, le message est généralement passé dans l'infrastructure de service.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="ad4a4-252">Bien qu'il s'agisse du modèle habituel pour les messages d'application, certains canaux peuvent fonctionner légèrement différemment ; ils peuvent, par exemple, envoyer leurs propres messages d'infrastructure sans passer de message à partir d'un canal supérieur.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="ad4a4-253">Les canaux peuvent agir sur le message de diverses façons lorsqu'il traverse la pile.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="ad4a4-254">L'opération la plus courante consiste à ajouter un en-tête à un message sortant et à lire les en-têtes sur un message entrant.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="ad4a4-255">Par exemple, un canal peut calculer la signature numérique d'un message et l'ajouter en tant qu'en-tête.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="ad4a4-256">Un canal peut également inspecter cet en-tête de signature numérique sur les messages entrants et empêcher ceux qui n'ont pas de signature valide d'atteindre le haut de la pile de canaux.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="ad4a4-257">Les canaux définissent ou inspectent également souvent les propriétés de message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="ad4a4-258">Le corps du message n’est généralement pas modifié, bien que cela soit autorisé, par exemple, le canal de sécurité WCF peut chiffrer le corps du message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-258">The message body is usually not modified, although this is allowed, for example, the WCF security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="ad4a4-259">Canaux de transport et encodeurs de message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-259">Transport Channels and Message Encoders</span></span>  
 <span data-ttu-id="ad4a4-260">Le canal le plus bas dans la pile est chargé de transformer réellement en actions un <xref:System.ServiceModel.Channels.Message>sortant, tel qu'il a été modifié par d'autres canaux.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="ad4a4-261">Du côté réception, c'est le canal qui convertit des actions en `Message` que les autres canaux traitent.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="ad4a4-262">Comme indiqué précédemment, les actions peuvent être diverses : envoyer ou recevoir des paquets réseau sur différents protocoles, lire ou écrire le message dans une base de données, mettre le message en file d'attente ou le supprimer de la file d'attente Message Queuing, pour ne citer que quelques exemples.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="ad4a4-263">Toutes ces actions ont une chose en commun : elles requièrent une transformation entre l' `Message` instance WCF et un groupe réel d’octets qui peut être envoyé, reçu, lu, écrit, mis en file d’attente ou supprimé de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-263">All these actions have one thing in common: they require a transformation between the WCF`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="ad4a4-264">Le processus de conversion d'un `Message` en groupe d'octets est appelé *encodage*, et le processus inverse de création d'un `Message` à partir d'un groupe d'octets est appelé *décodage*.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="ad4a4-265">La plupart des canaux de transport utilisent des composants appelés *encodeurs de message* pour procéder à l'encodage et au décodage.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="ad4a4-266">Un encodeur de message est une sous-classe de la classe <xref:System.ServiceModel.Channels.MessageEncoder> .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="ad4a4-267">`MessageEncoder` inclut différentes surcharges de méthode `ReadMessage` et `WriteMessage` pour effectuer la conversion entre `Message` et des groupes d'octets.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="ad4a4-268">Du côté envoi, un canal de transport de mise en mémoire tampon passe l'objet `Message` qu'il a reçu d'un canal supérieur à `WriteMessage`.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="ad4a4-269">Il récupère un tableau d'octets, qu'il utilise ensuite pour exécuter son action (par exemple emballer ces octets sous forme de paquets TCP valides et les envoyer vers la destination correcte).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="ad4a4-270">Un canal de transport de diffusion en continu crée d'abord un `Stream` (par exemple, sur la connexion TCP sortante), puis passe à la fois le `Stream` et le `Message` qu'il doit envoyer à la surcharge `WriteMessage` appropriée, qui écrit le message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="ad4a4-271">Du côté réception, un canal de transport de mise en mémoire tampon extrait les octets entrants (provenant par exemple des paquets TCP entrants) dans un tableau et appelle `ReadMessage` pour obtenir un objet `Message` qu'il peut remonter plus haut dans la pile de canaux.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="ad4a4-272">Un canal de transport de diffusion en continu crée un objet `Stream` (par exemple, un flux réseau sur la connexion TCP entrante) et le passe à `ReadMessage` pour récupérer un objet `Message` .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="ad4a4-273">La séparation entre les canaux de transport et l'encodeur de message n'est pas obligatoire ; il est possible d'écrire un canal de transport qui n'utilise pas d'encodeur de message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="ad4a4-274">Toutefois, l'avantage de cette séparation est la facilité de composition.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="ad4a4-275">Tant qu’un canal de transport utilise uniquement la base <xref:System.ServiceModel.Channels.MessageEncoder> , il peut fonctionner avec n’importe quel encodeur de message WCF ou tiers.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any WCF or third-party message encoder.</span></span> <span data-ttu-id="ad4a4-276">En outre, le même encodeur peut normalement être utilisé dans n'importe quel canal de transport.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="ad4a4-277">Opération d'encodeur de message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-277">Message Encoder Operation</span></span>  
 <span data-ttu-id="ad4a4-278">Pour décrire l'opération classique d'un encodeur, il est utile de prendre en compte les quatre cas suivants.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="ad4a4-279">Opération</span><span class="sxs-lookup"><span data-stu-id="ad4a4-279">Operation</span></span>|<span data-ttu-id="ad4a4-280">Commentaire</span><span class="sxs-lookup"><span data-stu-id="ad4a4-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="ad4a4-281">Encodage, mise en mémoire tampon</span><span class="sxs-lookup"><span data-stu-id="ad4a4-281">Encoding, Buffered</span></span>|<span data-ttu-id="ad4a4-282">En mode de mise en mémoire tampon, l'encodeur crée normalement une mémoire tampon de taille variable, puis crée un enregistreur XML sur celle-ci.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="ad4a4-283">Il appelle ensuite <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> sur le message encodé, qui écrit les en-têtes, puis le corps à l'aide de <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, tel qu'expliqué dans la section portant sur `Message` précédemment développée dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="ad4a4-284">Le contenu de la mémoire tampon (représenté sous forme d'un tableau d'octets) est ensuite retourné pour être utilisé par le canal de transport.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="ad4a4-285">Encodage, avec diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="ad4a4-285">Encoding, Streamed</span></span>|<span data-ttu-id="ad4a4-286">En mode avec diffusion en continu, l'opération est semblable à celle ci-dessus, mais elle est plus simple.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="ad4a4-287">Une mémoire tampon n'est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-287">There is no need for a buffer.</span></span> <span data-ttu-id="ad4a4-288">Un enregistreur XML est normalement créé sur le flux et <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> est appelé sur `Message` pour l'écrire dans cet enregistreur.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="ad4a4-289">Décodage, mise en mémoire tampon</span><span class="sxs-lookup"><span data-stu-id="ad4a4-289">Decoding, Buffered</span></span>|<span data-ttu-id="ad4a4-290">Lors du décodage en mode de mise en mémoire tampon, une sous-classe `Message` spéciale qui contient les données mises en mémoire tampon est normalement créée.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="ad4a4-291">Les en-têtes du message sont lus, et un lecteur XML positionné sur le corps du message est créé.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="ad4a4-292">Il s'agit du lecteur qui sera retourné avec <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="ad4a4-293">Décodage, avec diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="ad4a4-293">Decoding, Streamed</span></span>|<span data-ttu-id="ad4a4-294">Lors du décodage en mode avec diffusion en continu, une sous-classe Message spéciale est normalement créée.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="ad4a4-295">Le flux est avancé juste assez suffisamment pour lire tous les en-têtes et le positionner sur le corps du message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="ad4a4-296">Un lecteur XML est ensuite créé sur le flux.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="ad4a4-297">Il s'agit du lecteur qui sera retourné avec <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="ad4a4-298">Les encodeurs peuvent également exécuter d'autres fonctions.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="ad4a4-299">Ils peuvent, par exemple, regrouper des lecteurs et des enregistreurs XML.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="ad4a4-300">La création d'un lecteur ou d'un enregistreur XML chaque fois que cela s'avère nécessaire est très coûteuse.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="ad4a4-301">Par conséquent, les encodeurs conservent normalement un pool de lecteurs et d'enregistreurs de taille configurable.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="ad4a4-302">Dans les descriptions de l’opération d’encodeur décrite précédemment, chaque fois que l’expression « créer un lecteur/enregistreur XML » est utilisée, cela signifie généralement « prendre un du pool ou en créer un s’il n’est pas disponible ».</span><span class="sxs-lookup"><span data-stu-id="ad4a4-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="ad4a4-303">L’encodeur (et les sous-classes `Message` créées durant le décodage) contient une logique renvoyant les lecteurs et les enregistreurs au pool une fois qu’ils ne sont plus nécessaires (par exemple, lorsque le `Message` est fermé).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 <span data-ttu-id="ad4a4-304">WCF fournit trois encodeurs de message, bien qu’il soit possible de créer des types personnalisés supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-304">WCF provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="ad4a4-305">Les types fournis sont de type texte, binaire et MTOM (Message Transmission Optimization Mechanism).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="ad4a4-306">Ils sont décrits en détail dans [Choosing a Message Encoder](choosing-a-message-encoder.md).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-306">These are described in detail in [Choosing a Message Encoder](choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="ad4a4-307">Interface IStreamProvider</span><span class="sxs-lookup"><span data-stu-id="ad4a4-307">The IStreamProvider Interface</span></span>  
 <span data-ttu-id="ad4a4-308">Lors de l'écriture d'un message sortant contenant un corps avec diffusion en continu vers un enregistreur XML, <xref:System.ServiceModel.Channels.Message> utilise une séquence d'appels similaire à la suivante dans son implémentation <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> :</span><span class="sxs-lookup"><span data-stu-id="ad4a4-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
- <span data-ttu-id="ad4a4-309">Écrivez toutes les informations nécessaires précédant le flux (par exemple, la balise XML d'ouverture).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
- <span data-ttu-id="ad4a4-310">Écrire le flux.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-310">Write the stream.</span></span>  
  
- <span data-ttu-id="ad4a4-311">Écrivez toutes les informations suivant le flux (par exemple, la balise XML de fermeture).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="ad4a4-312">Cela fonctionne correctement avec des encodages similaires à l'encodage XML textuel.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="ad4a4-313">Toutefois, certains encodages ne placent pas l'ensemble d'informations XML (par exemple, les balises permettant de démarrer et de terminer les éléments XML) avec les données contenues dans des éléments.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="ad4a4-314">Avec l'encodage MTOM par exemple, le message est fractionné en plusieurs parties.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="ad4a4-315">Une partie contient l'ensemble d'informations XML, qui peut contenir des références à d'autres parties du contenu d'éléments réels.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="ad4a4-316">La taille de l'ensemble d'informations XML étant normalement réduite par rapport à celle du contenu avec diffusion en continu, il est donc logique de mettre cet ensemble en mémoire tampon, de l'écrire, puis d'écrire le contenu avec diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="ad4a4-317">Cela signifie que lorsque la balise d'élément de fermeture est écrite, le flux ne doit pas encore avoir été écrit.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="ad4a4-318">L'interface <xref:System.Xml.IStreamProvider> est utilisée à cette fin.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="ad4a4-319">Elle dispose d'une méthode <xref:System.Xml.IStreamProvider.GetStream> qui retourne le flux à écrire.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="ad4a4-320">Pour écrire un corps de message avec diffusion en continu dans <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> , procédez comme suit :</span><span class="sxs-lookup"><span data-stu-id="ad4a4-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1. <span data-ttu-id="ad4a4-321">Écrivez toutes les informations nécessaires précédant le flux (par exemple, la balise XML d'ouverture).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2. <span data-ttu-id="ad4a4-322">Appelez la surcharge `WriteValue` sur le <xref:System.Xml.XmlDictionaryWriter> qui accepte <xref:System.Xml.IStreamProvider>, avec une implémentation `IStreamProvider` qui retourne le flux à écrire.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3. <span data-ttu-id="ad4a4-323">Écrivez toutes les informations suivant le flux (par exemple, la balise XML de fermeture).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="ad4a4-324">Avec cette approche, l'enregistreur XML peut choisir à quel moment appeler <xref:System.Xml.IStreamProvider.GetStream> et écrire les données avec diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="ad4a4-325">Par exemple, les enregistreurs XML textuels et binaires l'appellent immédiatement et écrivent le contenu avec diffusion en continu entre les balises de début et de fin.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="ad4a4-326">L'enregistreur MTOM peut décider d'appeler <xref:System.Xml.IStreamProvider.GetStream> ultérieurement, lorsqu'il est prêt à écrire la partie appropriée du message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="ad4a4-327">Représentation des données dans l'infrastructure de service</span><span class="sxs-lookup"><span data-stu-id="ad4a4-327">Representing Data in the Service Framework</span></span>  
 <span data-ttu-id="ad4a4-328">Comme indiqué dans la section « architecture de base » de cette rubrique, l’infrastructure de service est la partie de WCF qui, entre autres choses, est responsable de la conversion entre un modèle de programmation convivial pour les données de message et les `Message` instances réelles.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of WCF that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="ad4a4-329">Normalement, un échange de messages est représenté dans l’infrastructure de service sous la forme d’une méthode .NET Framework marquée avec l' <xref:System.ServiceModel.OperationContractAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-329">Normally, a message exchange is represented in the service framework as a .NET Framework method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="ad4a4-330">La méthode peut prendre quelques paramètres et retourner une valeur de retour ou des paramètres de sortie (ou les deux).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="ad4a4-331">Du côté service, les paramètres d'entrée représentent le message entrant, et la valeur de retour et les paramètres de sortie représentent le message sortant.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="ad4a4-332">Du côté client, l'inverse est vérifié.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="ad4a4-333">Le modèle de programmation permettant de décrire des messages à l’aide de paramètres et de la valeur de retour est présenté en détail dans [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="ad4a4-334">Cependant, cette section fournit une brève vue d'ensemble.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="ad4a4-335">Modèles de programmation</span><span class="sxs-lookup"><span data-stu-id="ad4a4-335">Programming Models</span></span>  
 <span data-ttu-id="ad4a4-336">L’infrastructure de service WCF prend en charge cinq modèles de programmation différents pour la description des messages :</span><span class="sxs-lookup"><span data-stu-id="ad4a4-336">The WCF service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="ad4a4-337">1. Message vide</span><span class="sxs-lookup"><span data-stu-id="ad4a4-337">1. The Empty Message</span></span>  
 <span data-ttu-id="ad4a4-338">C'est le cas le plus simple.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-338">This is the simplest case.</span></span> <span data-ttu-id="ad4a4-339">Pour décrire un message entrant vide, n'utilisez pas de paramètre d'entrée.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="ad4a4-340">Pour décrire un message sortant vide, utilisez une valeur de retour void et n'utilisez pas de paramètre de sortie :</span><span class="sxs-lookup"><span data-stu-id="ad4a4-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="ad4a4-341">Notez que cela est différent à partir d'un contrat d'opération monodirectionnel :</span><span class="sxs-lookup"><span data-stu-id="ad4a4-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="ad4a4-342">Dans l'exemple `SetDesiredTemperature` , un modèle d'échange de messages bidirectionnel est décrit.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="ad4a4-343">Un message est retourné par l'opération, mais il est vide.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="ad4a4-344">Il est possible de retourner une erreur à partir de l'opération.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="ad4a4-345">Dans l'exemple « Set Lightbulb », le modèle d'échange de messages est monodirectionnel, il n'y a donc pas de message sortant à décrire.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="ad4a4-346">Dans ce cas, le service ne peut pas communiquer d'état au client.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="ad4a4-347">2. Utilisation de la classe Message directement</span><span class="sxs-lookup"><span data-stu-id="ad4a4-347">2. Using the Message Class Directly</span></span>  
 <span data-ttu-id="ad4a4-348">Il est possible d'utiliser la classe <xref:System.ServiceModel.Channels.Message> (ou l'une de ses sous-classes) directement dans un contrat d'opération.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="ad4a4-349">Dans ce cas, l'infrastructure de service passe uniquement le `Message` de l'opération à la pile de canaux et vice versa, sans traitement supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="ad4a4-350">Il existe deux principaux cas dans lesquels utiliser `Message` directement.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="ad4a4-351">Dans le cas de scénarios avancés, lorsqu'aucun des autres modèles de programmation ne vous donne suffisamment de souplesse pour décrire votre message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="ad4a4-352">Par exemple, vous souhaitez utiliser des fichiers sur disque pour décrire un message, les propriétés du fichier devenant les en-têtes de message et le contenu du fichier devenant le corps du message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="ad4a4-353">Vous pouvez ensuite créer du code similaire au suivant.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="ad4a4-354">Le deuxième cas d'utilisation courante de `Message` dans un contrat d'opération est lorsqu'un service ne se soucie pas du contenu de message spécifique et agit sur le message comme sur une boîte noire.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="ad4a4-355">Par exemple, vous pouvez avoir un service qui transfère des messages à plusieurs autres destinataires.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="ad4a4-356">Le contrat peut être écrit comme suit.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="ad4a4-357">La ligne action = "\*" désactive la distribution des messages et s’assure que tous les messages envoyés au `IForwardingService` contrat sont en mesure de l' `ForwardMessage` opération.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-357">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="ad4a4-358">(Normalement, le répartiteur examine l’en-tête « action » du message pour déterminer l’opération à laquelle il est destiné.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="ad4a4-359">Action = " \* " signifie "toutes les valeurs possibles de l’en-tête d’action".) La combinaison de action = " \* " et de l’utilisation de message en tant que paramètre est appelée « contrat universel », car elle est en mesure de recevoir tous les messages possibles.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="ad4a4-360">Pour être en mesure d’envoyer tous les messages possibles, utilisez le message comme valeur de retour et affectez-lui la valeur `ReplyAction` " \* ".</span><span class="sxs-lookup"><span data-stu-id="ad4a4-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="ad4a4-361">Cela empêche l'infrastructure de service d'ajouter son propre en-tête Action, et vous permet ainsi de contrôler cet en-tête à l'aide de l'objet `Message` que vous retournez.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="ad4a4-362">3. Contrats de message</span><span class="sxs-lookup"><span data-stu-id="ad4a4-362">3. Message Contracts</span></span>  
 <span data-ttu-id="ad4a4-363">WCF fournit un modèle de programmation déclaratif pour la description des messages, appelés *contrats de message*.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-363">WCF provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="ad4a4-364">Ce modèle est décrit en détail dans [Using Message Contracts](using-message-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-364">This model is described in detail in [Using Message Contracts](using-message-contracts.md).</span></span> <span data-ttu-id="ad4a4-365">Fondamentalement, l’ensemble du message est représenté par un type de .NET Framework unique qui utilise des attributs tels que <xref:System.ServiceModel.MessageBodyMemberAttribute> et <xref:System.ServiceModel.MessageHeaderAttribute> pour décrire les parties de la classe de contrat de message qui doivent être mappées à une partie du message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-365">Essentially, the entire message is represented by a single .NET Framework type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="ad4a4-366">Les contrats de message offrent un contrôle important sur les instances `Message` résultantes (bien que celui-ci ne soit évidemment pas aussi complet qu'en utilisant la classe `Message` directement).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="ad4a4-367">Par exemple, les corps de message sont souvent composés de plusieurs éléments d'information, chacun représenté par son propre élément XML.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="ad4a4-368">Ces éléments peuvent se produire directement dans le corps (mode*nu* ) ou être *encapsulés* dans un élément XML englobant.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="ad4a4-369">Le modèle de programmation de contrat de message vous permet de prendre une décision de type « nu ou encapsulé » et de contrôler le nom de wrapper et d'espace de noms.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="ad4a4-370">L'exemple de code suivant d'un contrat de message présente ces fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="ad4a4-371">Les éléments marqués pour la sérialisation (avec <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>ou d'autres attributs associés) doivent être sérialisables pour participer à un contrat de message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> <span data-ttu-id="ad4a4-372">Pour plus d’informations, consultez la section « sérialisation » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-372">For more information, see the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="ad4a4-373">4. Paramètres</span><span class="sxs-lookup"><span data-stu-id="ad4a4-373">4. Parameters</span></span>  
 <span data-ttu-id="ad4a4-374">Bien souvent, un développeur qui souhaite décrire une opération qui agit sur plusieurs éléments de données n'a pas besoin du niveau de contrôle fourni par les contrats de message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="ad4a4-375">Par exemple, lors de la création de services, on ne souhaite généralement pas prendre de décision de type « nu ou encapsulé » et décider du nom de l'élément wrapper.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="ad4a4-376">Prendre ces décisions requiert souvent une connaissance approfondie des services Web et de SOAP.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="ad4a4-377">L’infrastructure de service WCF peut sélectionner automatiquement la représentation SOAP la mieux adaptée et la plus interopérable pour l’envoi ou la réception de plusieurs éléments d’information connexes, sans imposer ces choix à l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-377">The WCF service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="ad4a4-378">Cela s'effectue en décrivant tout simplement ces éléments d'informations comme paramètres ou valeurs de retour d'un contrat d'opération.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="ad4a4-379">Examinons, par exemple, le contrat d'opération suivant :</span><span class="sxs-lookup"><span data-stu-id="ad4a4-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="ad4a4-380">L'infrastructure de service décide automatiquement de mettre l'ensemble des trois éléments d'information (`customerID`, `item`et `quantity`) dans le corps du message et de les encapsuler dans un élément wrapper appelé `SubmitOrderRequest`.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="ad4a4-381">Décrire les informations à envoyer ou à recevoir sous forme d'une liste simple de paramètres de contrat d'opération est l'approche que nous recommandons, à moins qu'il existe des raisons particulières de passer à des modèles de programmation basée sur `Message`ou de contrat de message plus complexes.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="ad4a4-382">5. Flux de données</span><span class="sxs-lookup"><span data-stu-id="ad4a4-382">5. Stream</span></span>  
 <span data-ttu-id="ad4a4-383">L'utilisation de `Stream` ou de l'une de ses sous-classes dans un contrat d'opération en tant que partie de corps de message unique dans un contrat de message peut être considérée comme un modèle de programmation distincts de ceux décrits précédemment.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="ad4a4-384">L'utilisation de `Stream` de cette manière est le seul moyen de garantir que votre contrat sera utilisable dans le cadre d'une diffusion en continu, en écrivant en abrégé votre propre sous-classe `Message` compatible avec la diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> <span data-ttu-id="ad4a4-385">Pour plus d’informations, consultez [données volumineuses et diffusion en continu](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-385">For more information, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="ad4a4-386">Lorsque `Stream` ou l'une de ses sous-classes est utilisée de cette manière, le sérialiseur n'est pas appelé.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="ad4a4-387">Pour les messages sortants, une sous-classe `Message` de diffusion en continu spéciale est créée et le flux est écrit tel qu'indiqué dans la section sur l'interface <xref:System.Xml.IStreamProvider> .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="ad4a4-388">Pour les messages entrants, l'infrastructure de service crée une sous-classe `Stream` sur le message entrant et la fournit à l'opération.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="ad4a4-389">Restrictions du modèle de programmation</span><span class="sxs-lookup"><span data-stu-id="ad4a4-389">Programming Model Restrictions</span></span>  
 <span data-ttu-id="ad4a4-390">Les modèles de programmation décrits précédemment ne peuvent pas être combinés de manière arbitraire.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="ad4a4-391">Par exemple, si une opération accepte un type de contrat de message, le contrat de message doit être son seul paramètre d'entrée.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="ad4a4-392">En outre, l'opération doit ensuite retourner un message vide (type de retour void) ou un autre contrat de message.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="ad4a4-393">Ces restrictions sont décrites dans les rubriques relatives à chaque modèle de programmation spécifique : [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md)et [Large Data and Streaming](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md), and [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="ad4a4-394">Formateurs de messages</span><span class="sxs-lookup"><span data-stu-id="ad4a4-394">Message Formatters</span></span>  
 <span data-ttu-id="ad4a4-395">Les modèles de programmation décrits précédemment sont pris en charge en branchant des composants appelés *formateurs de messages* dans l'infrastructure de service.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="ad4a4-396">Les formateurs de messages sont des types qui implémentent l' <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface ou, ou les deux, pour une utilisation dans les clients et les clients WCF de service, respectivement.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service WCF clients, respectively.</span></span>  
  
 <span data-ttu-id="ad4a4-397">Les formateurs de messages sont normalement branchés par les comportements.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="ad4a4-398">Par exemple, <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> branche le formateur de messages de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="ad4a4-399">Cette opération s'effectue du côté service en affectant <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> au formateur correct dans la méthode <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> , ou du côté client en affectant <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> au formateur correct dans la méthode <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="ad4a4-400">Le tableau suivant répertorie les méthodes qu'un formateur de messages peut implémenter.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="ad4a4-401">Interface</span><span class="sxs-lookup"><span data-stu-id="ad4a4-401">Interface</span></span>|<span data-ttu-id="ad4a4-402">Méthode</span><span class="sxs-lookup"><span data-stu-id="ad4a4-402">Method</span></span>|<span data-ttu-id="ad4a4-403">Action</span><span class="sxs-lookup"><span data-stu-id="ad4a4-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="ad4a4-404">Convertit un `Message` entrant en paramètres d'opération</span><span class="sxs-lookup"><span data-stu-id="ad4a4-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="ad4a4-405">Crée un `Message` sortant à partir de la valeur de retour/des paramètres de sortie d'opération</span><span class="sxs-lookup"><span data-stu-id="ad4a4-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="ad4a4-406">Crée un `Message` sortant à partir des paramètres d'opération</span><span class="sxs-lookup"><span data-stu-id="ad4a4-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="ad4a4-407">Convertit un `Message` entrant en valeur de retour/paramètres de sortie</span><span class="sxs-lookup"><span data-stu-id="ad4a4-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="ad4a4-408">Sérialisation</span><span class="sxs-lookup"><span data-stu-id="ad4a4-408">Serialization</span></span>  
 <span data-ttu-id="ad4a4-409">Chaque fois que vous utilisez des contrats de message ou des paramètres pour décrire le contenu d’un message, vous devez utiliser la sérialisation pour effectuer la conversion entre les types .NET Framework et la représentation XML Infoset.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between .NET Framework types and XML Infoset representation.</span></span> <span data-ttu-id="ad4a4-410">La sérialisation est utilisée à d’autres emplacements dans WCF, par exemple, <xref:System.ServiceModel.Channels.Message> a une <xref:System.ServiceModel.Channels.Message.GetBody%2A> méthode générique que vous pouvez utiliser pour lire l’ensemble du corps du message désérialisé dans un objet.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-410">Serialization is used in other places in WCF, for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 <span data-ttu-id="ad4a4-411">WCF prend en charge deux technologies de sérialisation « prêtes à l’emploi » pour la sérialisation et la désérialisation des paramètres et des parties de message : <xref:System.Runtime.Serialization.DataContractSerializer> et `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-411">WCF supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="ad4a4-412">En outre, vous pouvez écrire des sérialiseurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="ad4a4-413">Toutefois, d’autres parties de WCF (telles que la `GetBody` méthode générique ou la sérialisation d’erreur SOAP) peuvent être restreintes pour utiliser uniquement les <xref:System.Runtime.Serialization.XmlObjectSerializer> sous-classes ( <xref:System.Runtime.Serialization.DataContractSerializer> et <xref:System.Runtime.Serialization.NetDataContractSerializer> , mais pas <xref:System.Xml.Serialization.XmlSerializer> ), ou peuvent même être codées en dur pour utiliser uniquement <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-413">However, other parts of WCF (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="ad4a4-414">`XmlSerializer`Est le moteur de sérialisation utilisé dans les services Web ASP.net.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-414">The `XmlSerializer` is the serialization engine used in ASP.NET Web services.</span></span> <span data-ttu-id="ad4a4-415">`DataContractSerializer` est le nouveau moteur de sérialisation qui comprend le nouveau modèle de programmation de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="ad4a4-416">`DataContractSerializer` est l'option par défaut, et le choix d'utiliser `XmlSerializer` peut s'effectuer par opération à l'aide de l'attribut <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="ad4a4-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> et <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> sont les comportements d'opération chargés de brancher les formateurs de messages de `DataContractSerializer` et `XmlSerializer`, respectivement.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="ad4a4-418">Le comportement <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> peut réellement fonctionner avec n'importe quel sérialiseur qui dérive de <xref:System.Runtime.Serialization.XmlObjectSerializer>, y compris <xref:System.Runtime.Serialization.NetDataContractSerializer> (décrit en détail dans Utilisation de la sérialisation autonome).</span><span class="sxs-lookup"><span data-stu-id="ad4a4-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="ad4a4-419">Le comportement appelle l'une des surcharges de méthode virtuelle `CreateSerializer` pour obtenir le sérialiseur.</span><span class="sxs-lookup"><span data-stu-id="ad4a4-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="ad4a4-420">Pour brancher un autre sérialiseur, créez une sous-classe <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> et substituez les deux surcharges `CreateSerializer` .</span><span class="sxs-lookup"><span data-stu-id="ad4a4-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ad4a4-421">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="ad4a4-421">See also</span></span>

- [<span data-ttu-id="ad4a4-422">Specifying Data Transfer in Service Contracts</span><span class="sxs-lookup"><span data-stu-id="ad4a4-422">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
