---
title: Sérialisation autonome de JSON à l’aide de DataContractJsonSerializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 614776a905ec319624f76876762c25bfca15a357
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249446"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="51929-102">Sérialisation autonome de JSON à l’aide de DataContractJsonSerializer</span><span class="sxs-lookup"><span data-stu-id="51929-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="51929-103">Cet article <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>est d’environ .</span><span class="sxs-lookup"><span data-stu-id="51929-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="51929-104">Pour la plupart des scénarios qui impliquent la sérialisation et la désétération JSON, nous recommandons les API dans le [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span><span class="sxs-lookup"><span data-stu-id="51929-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="51929-105">JSON (JavaScript Object Notation) est un format de données spécialement conçu pour être utilisé par du code JavaScript exécuté sur les pages web dans le navigateur.</span><span class="sxs-lookup"><span data-stu-id="51929-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="51929-106">Il s’agit du format de données par défaut utilisé par ASP.NET services AJAX créés par Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="51929-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="51929-107">Ce format peut également être utilisé lors de la création de services AJAX sans intégration avec ASP.NET ; dans ce cas, XML est le format par défaut, mais il est possible de choisir le format JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="51929-108">Enfin, si vous avez besoin d'une prise en charge du format JSON mais que vous ne créez pas de service AJAX, le <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> permet de sérialiser directement les objets .NET en données JSON, et de désérialiser ces données en instances de types .NET.</span><span class="sxs-lookup"><span data-stu-id="51929-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="51929-109">Pour une description de la façon de le faire, voir [Comment: Serialize et Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="51929-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="51929-110">Lorsque vous utilisez JSON, le types de données .NET pris en charge sont les mêmes que ceux pris en charge par <xref:System.Runtime.Serialization.DataContractSerializer>, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="51929-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="51929-111">Pour une liste des types pris en charge, voir [Types Pris en charge par le Serializer contrat de données](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="51929-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="51929-112">Il s'agit de la plupart des types primitifs, des types de collections et de tableaux, ainsi que des types complexes qui utilisent <xref:System.Runtime.Serialization.DataContractAttribute> et <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="51929-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="51929-113">Mappage de types .NET aux types JSON</span><span class="sxs-lookup"><span data-stu-id="51929-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="51929-114">Le tableau suivant indique la correspondance entre les types .NET et les types JSON/JavaScript lorsqu'ils sont mappés par les procédures de sérialisation et de désérialisation.</span><span class="sxs-lookup"><span data-stu-id="51929-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="51929-115">Types .NET</span><span class="sxs-lookup"><span data-stu-id="51929-115">.NET Types</span></span>|<span data-ttu-id="51929-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="51929-116">JSON/JavaScript</span></span>|<span data-ttu-id="51929-117">Notes</span><span class="sxs-lookup"><span data-stu-id="51929-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="51929-118">Tous les types numériques, par exemple <xref:System.Int32>, <xref:System.Decimal> ou <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="51929-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="51929-119">Number</span><span class="sxs-lookup"><span data-stu-id="51929-119">Number</span></span>|<span data-ttu-id="51929-120">Les valeurs spéciales telles que `Double.NaN`, `Double.PositiveInfinity` et `Double.NegativeInfinity` ne sont pas prises en charge et entraînent des données JSON non valides.</span><span class="sxs-lookup"><span data-stu-id="51929-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="51929-121">Number</span><span class="sxs-lookup"><span data-stu-id="51929-121">Number</span></span>|<span data-ttu-id="51929-122">Voir « Énumérations et JSON » ci-après dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="51929-123">Boolean</span><span class="sxs-lookup"><span data-stu-id="51929-123">Boolean</span></span>|--|
|<span data-ttu-id="51929-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="51929-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="51929-125">String</span><span class="sxs-lookup"><span data-stu-id="51929-125">String</span></span>|--|
|<span data-ttu-id="51929-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="51929-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="51929-127">String</span><span class="sxs-lookup"><span data-stu-id="51929-127">String</span></span>|<span data-ttu-id="51929-128">Le format de ces types dans JSON est le même que dans XML (essentiellement, TimeSpan dans le format ISO 8601 Durée, GUID dans le "12345678-ABCD-ABCD-ABCD-1234567890AB" format et URI sous sa forme de chaîne naturelle comme ").http://www.example.com</span><span class="sxs-lookup"><span data-stu-id="51929-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="51929-129">Pour plus d’informations précises, voir [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="51929-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="51929-130">String</span><span class="sxs-lookup"><span data-stu-id="51929-130">String</span></span>|<span data-ttu-id="51929-131">Le format est « nom:espacedenoms » (ce qui apparaît avant le premier signe deux-points constitue le nom).</span><span class="sxs-lookup"><span data-stu-id="51929-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="51929-132">Le nom ou l'espace de noms peut être manquant.</span><span class="sxs-lookup"><span data-stu-id="51929-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="51929-133">En l'absence d'espace de noms, le signe deux-points peut également être omis.</span><span class="sxs-lookup"><span data-stu-id="51929-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="51929-134"><xref:System.Array> de type <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="51929-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="51929-135">Tableau de nombres</span><span class="sxs-lookup"><span data-stu-id="51929-135">Array of numbers</span></span>|<span data-ttu-id="51929-136">Chaque chiffre représente la valeur d'un octet.</span><span class="sxs-lookup"><span data-stu-id="51929-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="51929-137">DateTime ou chaîne</span><span class="sxs-lookup"><span data-stu-id="51929-137">DateTime or String</span></span>|<span data-ttu-id="51929-138">Voir « Dates/heures et JSON » ci-après dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="51929-139">Type complexe</span><span class="sxs-lookup"><span data-stu-id="51929-139">Complex type</span></span>|<span data-ttu-id="51929-140">Voir « Dates/heures et JSON » ci-après dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="51929-141">Types XML et ADO.NET (objet <xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="51929-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="51929-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="51929-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="51929-143">Tableaux d'objet <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="51929-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="51929-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="51929-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="51929-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="51929-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="51929-146">String</span><span class="sxs-lookup"><span data-stu-id="51929-146">String</span></span>|<span data-ttu-id="51929-147">Voir la section Types XML et JSON de cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="51929-148">Type complexe vide</span><span class="sxs-lookup"><span data-stu-id="51929-148">Empty complex type</span></span>|--|
|<span data-ttu-id="51929-149">Collections, dictionnaires et tableaux</span><span class="sxs-lookup"><span data-stu-id="51929-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="51929-150">Array</span><span class="sxs-lookup"><span data-stu-id="51929-150">Array</span></span>|<span data-ttu-id="51929-151">Voir la section Collections, dictionnaires et tableaux de cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="51929-152">Types complexes (avec <xref:System.Runtime.Serialization.DataContractAttribute> ou <xref:System.SerializableAttribute> appliqué)</span><span class="sxs-lookup"><span data-stu-id="51929-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="51929-153">Type complexe</span><span class="sxs-lookup"><span data-stu-id="51929-153">Complex type</span></span>|<span data-ttu-id="51929-154">Les membres de données deviennent membres du type complexe JavaScript.</span><span class="sxs-lookup"><span data-stu-id="51929-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="51929-155">Types complexes implémentant l'interface <xref:System.Runtime.Serialization.ISerializable>)</span><span class="sxs-lookup"><span data-stu-id="51929-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="51929-156">Type complexe</span><span class="sxs-lookup"><span data-stu-id="51929-156">Complex type</span></span>|<span data-ttu-id="51929-157">Identique à d'autres types complexes mais certains types <xref:System.Runtime.Serialization.ISerializable> ne sont pas pris en charge ; consultez Prise en charge de l'interface ISerializable dans la section Informations avancées de cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="51929-158">Valeur `Null` pour tout type</span><span class="sxs-lookup"><span data-stu-id="51929-158">`Null` value for any type</span></span>|<span data-ttu-id="51929-159">Null</span><span class="sxs-lookup"><span data-stu-id="51929-159">Null</span></span>|<span data-ttu-id="51929-160">Les types de valeur nulables sont également pris en charge et cartographient JSON de la même manière que les types de valeur non annulables.</span><span class="sxs-lookup"><span data-stu-id="51929-160">Nullable value types are also supported and map to JSON in the same way as non-nullable value types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="51929-161">Énumérations et JSON</span><span class="sxs-lookup"><span data-stu-id="51929-161">Enumerations and JSON</span></span>

<span data-ttu-id="51929-162">Les valeurs de membre de l'énumération sont traitées comme des nombres dans JSON, ce qui diffère de la manière dont elles sont traitées dans les contrats de données, où elles sont incluses comme noms de membres.</span><span class="sxs-lookup"><span data-stu-id="51929-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="51929-163">Pour plus d’informations sur le traitement des contrats de données, voir [Les types d’énumération dans les contrats de données](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="51929-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="51929-164">Par exemple, si vous avez `public enum Color {red, green, blue, yellow, pink}`, `yellow` produit le nombre 3 et pas la chaîne "yellow".</span><span class="sxs-lookup"><span data-stu-id="51929-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="51929-165">Tous les membres `enum` sont sérialisables.</span><span class="sxs-lookup"><span data-stu-id="51929-165">All `enum` members are serializable.</span></span> <span data-ttu-id="51929-166">Les attributs <xref:System.Runtime.Serialization.EnumMemberAttribute> et <xref:System.NonSerializedAttribute> sont ignorés s'ils sont utilisés.</span><span class="sxs-lookup"><span data-stu-id="51929-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="51929-167">Il est possible de désérialiser une valeur `enum` inexistante ; par exemple, la valeur 87 peut être désérialisée en l'énumération Color précédente même s'il n'existe aucun nom de couleur correspondant défini.</span><span class="sxs-lookup"><span data-stu-id="51929-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="51929-168">Un indicateur `enum` n'est pas spécial et est traité comme tous les autres `enum`.</span><span class="sxs-lookup"><span data-stu-id="51929-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="51929-169">Dates/heures et JSON</span><span class="sxs-lookup"><span data-stu-id="51929-169">Dates/Times and JSON</span></span>

<span data-ttu-id="51929-170">Le format JSON ne prend pas directement en charge les dates et heures.</span><span class="sxs-lookup"><span data-stu-id="51929-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="51929-171">Cependant, elles sont fréquemment utilisées et ASP.NET AJAX assure une prise en charge spéciale de ces types.</span><span class="sxs-lookup"><span data-stu-id="51929-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="51929-172">Lorsque vous utilisez des proxys ASP.NET AJAX, le type <xref:System.DateTime> dans .NET correspond exactement au type `DateTime` dans JavaScript.</span><span class="sxs-lookup"><span data-stu-id="51929-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="51929-173">Lorsque vous n'utilisez pas ASP.NET, un type <xref:System.DateTime> est représenté dans JSON sous forme de chaîne avec un format spécial qui est décrit dans la section Informations avancées de cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="51929-174"><xref:System.DateTimeOffset> est représenté dans JSON comme un type complexe : {"DateTime": dateTime, "OffsetMinutes": offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="51929-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="51929-175">Le membre `offsetMinutes` est le décalage de l'heure locale par rapport à l'heure de Greenwich (GMT, Greenwich Mean Time), également appelée heure universelle coordonnée (UTC, Coordinated Universal Time), associé à l'emplacement de l'événement concerné.</span><span class="sxs-lookup"><span data-stu-id="51929-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="51929-176">Le membre `dateTime` représente l'instant où l'événement s'est produit (ici encore, il devient un `DateTime` dans JavaScript lorsque ASP.NET AJAX est utilisé, et une chaîne dans le cas contraire).</span><span class="sxs-lookup"><span data-stu-id="51929-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="51929-177">Lors de la sérialisation, le membre `dateTime` est toujours sérialisé au format GMT.</span><span class="sxs-lookup"><span data-stu-id="51929-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="51929-178">Par conséquent, si vous décrivez 3 h 00 du matin, heure de New York, `dateTime` a un composant horaire de 8 h 00 du matin et `offsetMinutes` correspond à 300 (moins 300 minutes ou 5 heures par rapport à GMT).</span><span class="sxs-lookup"><span data-stu-id="51929-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="51929-179">Les objets <xref:System.DateTime> et <xref:System.DateTimeOffset>, lorsqu'ils sont sérialisés en JSON, préservent uniquement les informations avec une précision égale à la milliseconde.</span><span class="sxs-lookup"><span data-stu-id="51929-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="51929-180">Les valeurs plus précises que les millisecondes (micro/nanosecondes) sont perdues lors de la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="51929-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="51929-181">Types XML et JSON</span><span class="sxs-lookup"><span data-stu-id="51929-181">XML Types and JSON</span></span>

<span data-ttu-id="51929-182">Les types XML deviennent des chaînes JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="51929-183">Par exemple, si un membre de la donnée \<"q" de type XElement contient\<abc/>, le JSON est "q":" abc/>".</span><span class="sxs-lookup"><span data-stu-id="51929-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="51929-184">Il existe des règles spéciales qui spécifient la manière dont le code XML est encapsulé. Pour plus d'informations, consultez la section Informations Avancées ci-après dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="51929-185">Si vous utilisez ASP.NET AJAX et que vous ne souhaitez pas utiliser des chaînes dans JavaScript mais le type XML DOM à la place, définissez XML sur <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> pour la propriété <xref:System.ServiceModel.Web.WebGetAttribute> ou définissez XML sur <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> pour la propriété <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="51929-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="51929-186">Collections, dictionnaires et tableaux</span><span class="sxs-lookup"><span data-stu-id="51929-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="51929-187">Tous les dictionnaires, tableaux et collections sont représentés dans JSON sous forme de tableaux.</span><span class="sxs-lookup"><span data-stu-id="51929-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="51929-188">Toute personnalisation qui utilise le <xref:System.Runtime.Serialization.CollectionDataContractAttribute> est ignorée dans la représentation JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="51929-189">Les dictionnaires ne permettent pas de travailler directement avec JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="51929-190">Chaîne\<de dictionnaire,> d’objet peuvent ne pas être pris en charge de la même manière dans WCF que prévu de travailler avec d’autres technologies JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="51929-191">Par exemple, si "abc" est mappé à "xyz" et "def" est mappé à 42 dans un dictionnaire, la représentation JSON n'est pas {"abc":"xyz","def":42}, mais [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}].</span><span class="sxs-lookup"><span data-stu-id="51929-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="51929-192">Si vous souhaitez travailler directement avec JSON (en accédant aux clés et aux valeurs dynamiquement sans prédéfinir un contrat rigide), vous disposez de plusieurs options :</span><span class="sxs-lookup"><span data-stu-id="51929-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="51929-193">Envisagez d’utiliser l’échantillon [de Sérialisation JSON (AJAX) de faible type.](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md)</span><span class="sxs-lookup"><span data-stu-id="51929-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="51929-194">Utilisez les constructeurs de désérialisation et l’interface <xref:System.Runtime.Serialization.ISerializable> : ces deux mécanismes vous permettent d’accéder aux paires clé/valeur JSON lors de la sérialisation et de la désérialisation respectivement, mais ils ne fonctionnent pas dans les scénarios de confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="51929-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="51929-195">Envisagez de travailler avec la [cartographie entre JSON et XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) au lieu d’utiliser un sérialisateur.</span><span class="sxs-lookup"><span data-stu-id="51929-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="51929-196">*Le polymorphisme* dans le contexte de la sérialisation se réfère à la capacité de sérialiser un type dérivé où son type de base est attendu.</span><span class="sxs-lookup"><span data-stu-id="51929-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="51929-197">Il existe des règles spéciales propres à JSON lorsque les collections sont utilisées de manière polymorphique, lors de l’affectation d’une collection à un <xref:System.Object> par exemple.</span><span class="sxs-lookup"><span data-stu-id="51929-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="51929-198">Ce problème est abordé de manière plus détaillée dans la section Informations avancées ci-après dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="51929-199">Détails supplémentaires</span><span class="sxs-lookup"><span data-stu-id="51929-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="51929-200">Ordre des membres de données</span><span class="sxs-lookup"><span data-stu-id="51929-200">Order of Data Members</span></span>

<span data-ttu-id="51929-201">L'ordre des membres de données n'est pas important lors de l'utilisation de JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="51929-202">Plus précisément, même si la propriété <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> est définie, les données JSON peuvent toujours être désérialisées dans n'importe quel ordre.</span><span class="sxs-lookup"><span data-stu-id="51929-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="51929-203">Types JSON</span><span class="sxs-lookup"><span data-stu-id="51929-203">JSON Types</span></span>

<span data-ttu-id="51929-204">Le type JSON ne doit pas nécessairement correspondre au tableau précédent lors de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="51929-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="51929-205">Par exemple, un type `Int` est normalement mappé à un nombre JSON, mais il peut également être correctement désérialisé à partir d'une chaîne JSON dans la mesure où cette chaîne contient un nombre valide.</span><span class="sxs-lookup"><span data-stu-id="51929-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="51929-206">Autrement dit, {"q":42} et {"q":"42"} sont tous deux valides s'il existe un membre de données `Int` appelé "q".</span><span class="sxs-lookup"><span data-stu-id="51929-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="51929-207">Polymorphisme</span><span class="sxs-lookup"><span data-stu-id="51929-207">Polymorphism</span></span>

<span data-ttu-id="51929-208">La sérialisation polymorphique désigne la capacité à sérialiser un type dérivé lorsque son type de base est attendu.</span><span class="sxs-lookup"><span data-stu-id="51929-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="51929-209">Ceci est pris en charge pour la sérialisation JSON par WCF comparable à la façon dont la sérialisation XML est pris en charge.</span><span class="sxs-lookup"><span data-stu-id="51929-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="51929-210">Par exemple, vous `MyDerivedType` pouvez `MyBaseType` sérialiser `Int` où on s’attend, ou sérialiser où `Object` on s’attend.</span><span class="sxs-lookup"><span data-stu-id="51929-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="51929-211">Les informations de type peuvent être perdues lors de la désérialisation d'un type dérivé si le type de base est attendu, sauf si vous désérialisez un type complexe.</span><span class="sxs-lookup"><span data-stu-id="51929-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="51929-212">Par exemple, si un <xref:System.Uri> est sérialisé lorsque <xref:System.Object> est attendu, il se traduit par une chaîne JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="51929-213">Si cette chaîne est désérialisée de nouveau en un <xref:System.Object>, un <xref:System.String> .NET  est retourné.</span><span class="sxs-lookup"><span data-stu-id="51929-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="51929-214">Le désérialiseur ne sait pas que la chaîne était au départ de type <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="51929-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="51929-215">En général, lorsque <xref:System.Object> est attendu, toutes les chaînes JSON sont désérialisées en tant que chaînes .NET, et tous les tableaux JSON utilisés pour sérialiser des collections, dictionnaires et tableaux .NET sont désérialisés en tant que <xref:System.Array> .NET de type <xref:System.Object>, indépendamment du type initial réel.</span><span class="sxs-lookup"><span data-stu-id="51929-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="51929-216">Un booléen JSON est mappé à un <xref:System.Boolean> .NET.</span><span class="sxs-lookup"><span data-stu-id="51929-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="51929-217">Cependant, lorsqu'un <xref:System.Object> est attendu, les nombres JSON sont désérialisés en tant que types <xref:System.Int32>, <xref:System.Decimal> ou <xref:System.Double> .NET, le type le plus approprié étant automatiquement choisi.</span><span class="sxs-lookup"><span data-stu-id="51929-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="51929-218">Lors de la désérialisation en un type d'interface, le <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> procède à la désérialisation comme si le type déclaré était Object.</span><span class="sxs-lookup"><span data-stu-id="51929-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="51929-219">Lorsque vous travaillez avec vos propres types dérivés et de base, l'utilisation du <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> ou d'un mécanisme équivalent est généralement nécessaire.</span><span class="sxs-lookup"><span data-stu-id="51929-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="51929-220">Par exemple, si vous avez `Animal` une opération qui a une `Cat` valeur `Animal`de retour et <xref:System.Runtime.Serialization.KnownTypeAttribute>qu’elle `Animal` renvoie <xref:System.ServiceModel.ServiceKnownTypeAttribute> en fait une `Cat` instance de (dérivée), vous devez soit appliquer le , sur le type ou l’opération et spécifier le type dans ces attributs.</span><span class="sxs-lookup"><span data-stu-id="51929-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="51929-221">Pour plus d’informations, voir [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="51929-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="51929-222">Pour obtenir des informations détaillées sur le fonctionnement de la sérialisation polymorphique et connaître certaines limitations qui doivent être respectées lors de son utilisation, consultez la section Informations avancées ci-après dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="51929-223">Gestion de version</span><span class="sxs-lookup"><span data-stu-id="51929-223">Versioning</span></span>

<span data-ttu-id="51929-224">Les fonctionnalités de contrôle de version des contrats de données, notamment l’interface <xref:System.Runtime.Serialization.IExtensibleDataObject>, sont intégralement prises en charge dans JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="51929-225">Qui plus est, dans la plupart des cas, il est possible de désérialiser un type dans un format (par exemple, XML) puis de le sérialiser dans un autre format (par exemple, JSON) tout en préservant les données dans <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="51929-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="51929-226">Pour plus d’informations, consultez [Contrats de données compatibles avec des versions ultérieures](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="51929-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="51929-227">Rappelez-vous que l'ordre n'intervient pas dans JSON et que les informations sur l'ordre sont donc perdues.</span><span class="sxs-lookup"><span data-stu-id="51929-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="51929-228">De plus, JSON ne prend pas en charge plusieurs paires clé/valeur dotées du même nom de clé.</span><span class="sxs-lookup"><span data-stu-id="51929-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="51929-229">En dernier lieu, toutes les opérations sur <xref:System.Runtime.Serialization.IExtensibleDataObject> sont polymorphiques par nature, c'est-à-dire que leur type dérivé est assigné à <xref:System.Object>, le type de base pour tous les types.</span><span class="sxs-lookup"><span data-stu-id="51929-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="51929-230">JSON dans les URL</span><span class="sxs-lookup"><span data-stu-id="51929-230">JSON in URLs</span></span>

<span data-ttu-id="51929-231">Lorsque vous utilisez des points de terminaison ASP.NET AJAX avec le verbe HTTP GET (en utilisant l'attribut <xref:System.ServiceModel.Web.WebGetAttribute>), les paramètres entrants apparaissent dans l'URL de demande au lieu du corps du message.</span><span class="sxs-lookup"><span data-stu-id="51929-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="51929-232">JSON est pris en charge même dans l’URL `Int` de demande, donc `Person` si vous avez une opération qui prend un "numéro" appelé et un type complexe appelé "p", l’URL peut ressembler à l’URL suivante.</span><span class="sxs-lookup"><span data-stu-id="51929-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="51929-233">Si vous utilisez un contrôle Script Manager ASP.NET AJAX et un proxy pour appeler le service, cette URL n'est pas automatiquement générée par le proxy et n'est pas visible.</span><span class="sxs-lookup"><span data-stu-id="51929-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="51929-234">JSON ne peut pas être utilisé dans les URL sur les points de terminaison AJAX non-ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="51929-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="51929-235">Informations avancées</span><span class="sxs-lookup"><span data-stu-id="51929-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="51929-236">Prise en charge de ISerializable</span><span class="sxs-lookup"><span data-stu-id="51929-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="51929-237">Types ISerializable pris en charge et non pris en charge</span><span class="sxs-lookup"><span data-stu-id="51929-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="51929-238">En règle générale, les types qui implémentent l'interface <xref:System.Runtime.Serialization.ISerializable> sont totalement pris en charge lors de la sérialisation/désérialisation de données JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="51929-239">Cependant, certains de ces types (notamment certains types .NET Framework) sont implémentés de telle manière que les aspects de la sérialisation propres à JSON entraînent une désérialisation incorrecte de ces types :</span><span class="sxs-lookup"><span data-stu-id="51929-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="51929-240">Avec <xref:System.Runtime.Serialization.ISerializable>, le type des différents membres de données n'est jamais connu à l'avance.</span><span class="sxs-lookup"><span data-stu-id="51929-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="51929-241">Ceci conduit à une situation polymorphique similaire à la désérialisation des types en un objet.</span><span class="sxs-lookup"><span data-stu-id="51929-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="51929-242">Comme nous l'avons mentionné précédemment, il est possible que les informations de type soient perdues dans JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="51929-243">Par exemple, un type qui sérialise un `enum` dans son implémentation <xref:System.Runtime.Serialization.ISerializable> et tente de le désérialiser directement en un `enum` (sans cast approprié) échoue, car un `enum` est sérialisé à l'aide de nombres dans JSON et les nombres JSON sont désérialisés en types numériques .NET intégrés (Int32, Decimal ou Double).</span><span class="sxs-lookup"><span data-stu-id="51929-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="51929-244">Par conséquent, la valeur `enum` initiale du nombre n'est pas conservée.</span><span class="sxs-lookup"><span data-stu-id="51929-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="51929-245">Un type <xref:System.Runtime.Serialization.ISerializable> qui repose sur un ordre de désérialisation spécifique dans son constructeur de désérialisation peut également ne pas parvenir à désérialiser certaines données JSON, car la plupart des sérialiseurs JSON ne garantissent pas un ordre spécifique.</span><span class="sxs-lookup"><span data-stu-id="51929-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="51929-246">Types de fabrique</span><span class="sxs-lookup"><span data-stu-id="51929-246">Factory Types</span></span>

<span data-ttu-id="51929-247">Bien que l’interface <xref:System.Runtime.Serialization.IObjectReference> soit prise en charge dans JSON en général, tous les types qui nécessitent la fonctionnalité « type de fabrique » (qui retourne une instance d’un type de <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> différent de celui qui implémente l’interface) ne sont pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="51929-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="51929-248">Format de transmission DateTime</span><span class="sxs-lookup"><span data-stu-id="51929-248">DateTime Wire Format</span></span>

<span data-ttu-id="51929-249">Les valeurs <xref:System.DateTime> apparaissent en tant que chaînes JSON au format "/Date(700000+0500)/", où le premier nombre (700000, dans l'exemple fourni) est le nombre de millisecondes dans le fuseau horaire GMT, heure standard (n'appliquant pas l'heure d'été) depuis le 1er janvier 1970 à minuit.</span><span class="sxs-lookup"><span data-stu-id="51929-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="51929-250">Le nombre peut être négatif pour représenter des heures antérieures.</span><span class="sxs-lookup"><span data-stu-id="51929-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="51929-251">La partie composée de "+0500" dans l’exemple est facultative et indique que l’heure est de type <xref:System.DateTimeKind.Local> ; c’est-à-dire qu’elle doit être convertie dans le fuseau horaire local lors de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="51929-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="51929-252">Si cette partie est omise, l'heure est désérialisée en tant que <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="51929-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="51929-253">Le nombre réel ("0500" dans cet exemple) et son signe (+ ou -) sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="51929-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="51929-254">Lorsque vous sérialisez <xref:System.DateTime>, les heures <xref:System.DateTimeKind.Local> et <xref:System.DateTimeKind.Unspecified> sont écrites avec un offset, et <xref:System.DateTimeKind.Utc> est écrite sans offset.</span><span class="sxs-lookup"><span data-stu-id="51929-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="51929-255">Le code JavaScript client ASP.NET AJAX convertit automatiquement ces chaînes en instances `DateTime` JavaScript.</span><span class="sxs-lookup"><span data-stu-id="51929-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="51929-256">S'il existe d'autres chaînes avec un format similaire qui ne sont pas de type <xref:System.DateTime> dans .NET, elles sont également converties.</span><span class="sxs-lookup"><span data-stu-id="51929-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="51929-257">La conversion n’a lieu que si les caractères "/"\\sont échappés (c’est-à-dire que le\\JSON ressemble à " /Date(700000-0500) /"), et pour cette raison WCF JSON encoder (activé par le <xref:System.ServiceModel.WebHttpBinding>) échappe toujours le "/" caractère.</span><span class="sxs-lookup"><span data-stu-id="51929-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="51929-258">XML dans les chaînes JSON</span><span class="sxs-lookup"><span data-stu-id="51929-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="51929-259">XmlElement</span><span class="sxs-lookup"><span data-stu-id="51929-259">XmlElement</span></span>

<span data-ttu-id="51929-260"><xref:System.Xml.XmlElement> est sérialisé tel quel, sans encapsulation.</span><span class="sxs-lookup"><span data-stu-id="51929-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="51929-261">Par exemple, le membre des <xref:System.Xml.XmlElement> données \<« x » de type qui contient abc/> est représenté comme suit :</span><span class="sxs-lookup"><span data-stu-id="51929-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="51929-262">Tableaux de XmlNode</span><span class="sxs-lookup"><span data-stu-id="51929-262">Arrays of XmlNode</span></span>

<span data-ttu-id="51929-263">Les objets <xref:System.Array> de type <xref:System.Xml.XmlNode> sont encapsulés dans un élément appelé ArrayOfXmlNode dans l'espace de noms de contrat de données standard du type.</span><span class="sxs-lookup"><span data-stu-id="51929-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="51929-264">Si "x" est un tableau qui contient un nœud d'attribut "N" dans l'espace de noms "ns" qui contient "value" et un nœud d'élément vide "M", la représentation est la suivante.</span><span class="sxs-lookup"><span data-stu-id="51929-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="51929-265">Les attributs dans l'espace de noms vide au début des tableaux XmlNode (avant les autres éléments) ne sont pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="51929-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="51929-266">Types IXmlSerializable y compris XElement et DataSet</span><span class="sxs-lookup"><span data-stu-id="51929-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="51929-267">Les types <xref:System.Runtime.Serialization.ISerializable> sont subdivisés en "types de contenu", "type DataSet" et "types d'éléments".</span><span class="sxs-lookup"><span data-stu-id="51929-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="51929-268">Pour les définitions de ces types, voir [XML et ADO.NET Types dans les contrats de données](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="51929-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="51929-269">Le types "Contenu" et "DataSet" sont sérialisés de la même manière que les objets <xref:System.Array> de <xref:System.Xml.XmlNode> traités dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="51929-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="51929-270">Ils sont encapsulés dans un élément dont le nom et l'espace de noms correspond au nom et à l'espace de noms de contrat de données du type en question.</span><span class="sxs-lookup"><span data-stu-id="51929-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="51929-271">Le types "Élément" tels que <xref:System.Xml.Linq.XElement> sont sérialisés tels quels, de la même manière que les types <xref:System.Xml.XmlElement> traités ci-avant dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="51929-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="51929-272">Polymorphisme</span><span class="sxs-lookup"><span data-stu-id="51929-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="51929-273">Préservation des informations de type</span><span class="sxs-lookup"><span data-stu-id="51929-273">Preserving Type Information</span></span>

<span data-ttu-id="51929-274">Comme nous l'avons indiqué précédemment, le polymorphisme est pris en charge dans JSON avec certaines limitations.</span><span class="sxs-lookup"><span data-stu-id="51929-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="51929-275">JavaScript est un langage faiblement typé et l'identité des types ne constitue généralement pas un problème.</span><span class="sxs-lookup"><span data-stu-id="51929-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="51929-276">Toutefois, lorsque vous utilisez JSON pour communiquer entre un système fortement typé (.NET) et un système faiblement typé (JavaScript), il est utile de préserver l'identité des types.</span><span class="sxs-lookup"><span data-stu-id="51929-276">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="51929-277">Par exemple, les types avec les noms de contrat de données "Circle" et "Square" dérivent d'un type avec un nom de contrat de données "Shape".</span><span class="sxs-lookup"><span data-stu-id="51929-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="51929-278">Si « Circle » est envoyé de .NET à Javascript et est ultérieurement retourné en une méthode .NET qui attend « Shape », il est utile pour le côté .NET de savoir que l'objet était initialement un « Circle » : dans le cas contraire, toutes les informations spécifiques au type dérivé (par exemple, le membre de données « radius » sur « Circle ») pourront être perdues.</span><span class="sxs-lookup"><span data-stu-id="51929-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="51929-279">Pour préserver l'identité des types lors de la sérialisation de types complexes au format JSON, un « affinage du type » peut être ajouté, et le désérialiseur reconnaît l'affinage et agit en conséquence.</span><span class="sxs-lookup"><span data-stu-id="51929-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="51929-280">Le « indice de type » est une paire de\_\_touches/valeur JSON avec le nom clé de « type » (deux souligne suivis du mot « type »).</span><span class="sxs-lookup"><span data-stu-id="51929-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="51929-281">La valeur est une chaîne JSON au format "NomContratDonnées:EspaceDeNomsContratDonnées" (les éléments qui précèdent le signe deux-points constituent le nom).</span><span class="sxs-lookup"><span data-stu-id="51929-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="51929-282">Avec l'exemple précédent, "Circle" peut être sérialisé comme suit.</span><span class="sxs-lookup"><span data-stu-id="51929-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="51929-283">L'affinage du type est très semblable à l'attribut `xsi:type` défini par la norme d'instance de schéma XML, et il est utilisé lors de la sérialisation/désérialisation XML.</span><span class="sxs-lookup"><span data-stu-id="51929-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="51929-284">Les membres\_\_de données appelés « type » sont interdits en raison d’un conflit potentiel avec l’indice de type.</span><span class="sxs-lookup"><span data-stu-id="51929-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="51929-285">Réduction de la taille des affinages de type</span><span class="sxs-lookup"><span data-stu-id="51929-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="51929-286">Pour réduire la taille des messages JSON, le`http://schemas.datacontract.org/2004/07/`préfixe de l’espace de nom de contrat de données par défaut () est remplacé par le caractère « ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '</span><span class="sxs-lookup"><span data-stu-id="51929-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="51929-287">(Pour rendre ce remplacement réversible, une règle d’évasion est utilisée:\\si l’espace de nom commence\\par le " ou " caractères ", ils sont annexés par un caractère supplémentaire ").</span><span class="sxs-lookup"><span data-stu-id="51929-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="51929-288">Ainsi, si "Circle" est un type dans le namespace .NET "MyApp.Shapes", son namespace contrat de données par défaut est `http://schemas.datacontract.org/2004/07/MyApp`.</span><span class="sxs-lookup"><span data-stu-id="51929-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="51929-289">Les formes (shapes) et la représentation JSON sont les suivantes.</span><span class="sxs-lookup"><span data-stu-id="51929-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="51929-290">Tant le tronqué (#MyApp.Shapes) et lehttp://schemas.datacontract.org/2004/07/MyApp.Shapes) plein (noms sont compris sur la désétérialisation.</span><span class="sxs-lookup"><span data-stu-id="51929-290">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="51929-291">Emplacement des affinages de type dans les objets  JSON</span><span class="sxs-lookup"><span data-stu-id="51929-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="51929-292">Notez que l'affinage du type doit apparaître en premier dans la représentation JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="51929-293">C'est le cas uniquement lorsque l'ordre des paires clé/valeur est important dans le traitement JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="51929-294">Par exemple, la méthode suivante n'est pas valide pour spécifier l'affinage du type.</span><span class="sxs-lookup"><span data-stu-id="51929-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="51929-295">Tant <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> l’utilisation par WCF et ASP.NET pages client AJAX émettent toujours l’indice de type en premier.</span><span class="sxs-lookup"><span data-stu-id="51929-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="51929-296">Les affinages de type s'appliquent uniquement à des types complexes</span><span class="sxs-lookup"><span data-stu-id="51929-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="51929-297">Il n'est pas possible d'émettre un affinage du type pour les types non complexes.</span><span class="sxs-lookup"><span data-stu-id="51929-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="51929-298">Par exemple, si le type de retour d’une opération est <xref:System.Object> mais que l’opération retourne Circle, la représentation JSON peut être semblable à celle présentée précédemment et les informations de type sont préservées.</span><span class="sxs-lookup"><span data-stu-id="51929-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="51929-299">Cependant, si Uri est retourné, la représentation JSON est une chaîne et les informations qui indiquaient que la chaîne représentait auparavant un Uri sont perdues.</span><span class="sxs-lookup"><span data-stu-id="51929-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="51929-300">Ceci s’applique non seulement aux types primitifs mais également aux collections et aux tableaux.</span><span class="sxs-lookup"><span data-stu-id="51929-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="51929-301">Quand les affinages de type sont-ils émis ?</span><span class="sxs-lookup"><span data-stu-id="51929-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="51929-302">Les affinages de type peuvent générer une augmentation importante de la taille des messages (pour limiter ce problème, vous pouvez utiliser des espaces de noms de contrats de données plus courts si possible).</span><span class="sxs-lookup"><span data-stu-id="51929-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="51929-303">Par conséquent, les règles suivantes déterminent si des affinages de type sont émis :</span><span class="sxs-lookup"><span data-stu-id="51929-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="51929-304">Lorsque vous utilisez ASP.NET AJAX, les affinages de type sont toujours émis chaque fois que cela est possible, même s'il n'existe aucune attribution de type dérivé/de base ; par exemple, même si Circle est attribué à Circle.</span><span class="sxs-lookup"><span data-stu-id="51929-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="51929-305">(Ceci est nécessaire pour activer totalement le processus d'appel depuis l'environnement JSON faiblement typé vers l'environnement .NET fortement typé sans perte d'informations inattendue.)</span><span class="sxs-lookup"><span data-stu-id="51929-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="51929-306">Lorsque vous utilisez les services AJAX sans intégration ASP.NET, les affinages de type sont émis uniquement s'il existe une attribution de type dérivé/de base ; c'est-à-dire qu'ils sont émis lorsque Circle est attribué à Shape ou à <xref:System.Object> mais n'est pas attribué à Circle.</span><span class="sxs-lookup"><span data-stu-id="51929-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="51929-307">Vous disposez ainsi des informations minimales requises pour implémenter correctement un client JavaScript et améliorer ainsi les performances, sans pour autant vous protéger contre les pertes d'informations de type dans les clients conçus de manière incorrecte.</span><span class="sxs-lookup"><span data-stu-id="51929-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="51929-308">Évitez systématiquement les attributions de type de base/dérivé sur le serveur si vous ne voulez pas être contraint de gérer ce problème sur le client.</span><span class="sxs-lookup"><span data-stu-id="51929-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="51929-309">Lorsque vous utilisez le type <xref:System.Runtime.Serialization.DataContractSerializer>, le paramètre de constructeur `alwaysEmitTypeInformation` vous permet de choisir entre les deux modes précédents, la valeur par défaut étant "`false`" (émission des affinages de type uniquement lorsqu'ils sont nécessaires).</span><span class="sxs-lookup"><span data-stu-id="51929-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="51929-310">Noms de membres de données dupliqués</span><span class="sxs-lookup"><span data-stu-id="51929-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="51929-311">Les informations de type dérivé sont présentes dans le même objet JSON avec les informations de type de base, et elles peuvent apparaître dans n'importe quel ordre.</span><span class="sxs-lookup"><span data-stu-id="51929-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="51929-312">Par exemple, `Shape` peut être représenté comme suit.</span><span class="sxs-lookup"><span data-stu-id="51929-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="51929-313">Quant à Circle, il peut être représenté comme suit.</span><span class="sxs-lookup"><span data-stu-id="51929-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="51929-314">Si le `Shape` type de base contenait`radius`également un membre de données appelé « », cela conduit à une collision à la fois sur la sérialisation (parce que les objets JSON ne peuvent pas avoir des noms clés répétitifs) et la désétérialisation (parce qu’il n’est pas clair si «radius» se réfère à `Shape.radius` ou `Circle.radius`).</span><span class="sxs-lookup"><span data-stu-id="51929-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="51929-315">Par conséquent, le concept de « masquage de propriété » (membres de données du même nom sur des classes de base et dérivées), qui est généralement déconseillé dans les classes de contrats de données, est en fait interdit dans le cas de JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="51929-316">Polymorphisme et types IXmlSerializable </span><span class="sxs-lookup"><span data-stu-id="51929-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="51929-317">Les types <xref:System.Xml.Serialization.IXmlSerializable> peuvent être assignés de manière polymorphique les uns aux autres normalement, à condition que les impératifs de types connus soient respectés, conformément aux règles de contrats de données standard.</span><span class="sxs-lookup"><span data-stu-id="51929-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="51929-318">Cependant, la sérialisation d'un type <xref:System.Xml.Serialization.IXmlSerializable> à la place de <xref:System.Object> entraîne la perte des informations de type et le résultat est une chaîne JSON.</span><span class="sxs-lookup"><span data-stu-id="51929-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="51929-319">Polymorphisme et certains types d'interface</span><span class="sxs-lookup"><span data-stu-id="51929-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="51929-320">Il est interdit de sérialiser un type de collection ou un type qui implémente <xref:System.Xml.Serialization.IXmlSerializable> lorsqu’un type autre qu’une collection qui n’est pas <xref:System.Xml.Serialization.IXmlSerializable> (à l’exception de <xref:System.Object>) est attendu.</span><span class="sxs-lookup"><span data-stu-id="51929-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="51929-321">Par exemple, une `IMyInterface` interface personnalisée `MyType` appelée <xref:System.Collections.Generic.IEnumerable%601> et `int` un `IMyInterface`type qui implémente à la fois le type et .</span><span class="sxs-lookup"><span data-stu-id="51929-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="51929-322">Il est interdit `MyType` de revenir d’une opération dont le type de retour est `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="51929-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="51929-323">C’est `MyType` parce qu’il doit être sérialisé comme un tableau JSON et nécessite un indice de type, et comme indiqué avant vous ne pouvez pas inclure un indice de type avec des tableaux, seulement avec des types complexes.</span><span class="sxs-lookup"><span data-stu-id="51929-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="51929-324">Types connus et configuration</span><span class="sxs-lookup"><span data-stu-id="51929-324">Known Types and Configuration</span></span>

<span data-ttu-id="51929-325">Tous les mécanismes de types connus utilisés par le <xref:System.Runtime.Serialization.DataContractSerializer> sont pris en charge de la même manière par le <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="51929-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="51929-326">Les deux sérialisateurs lisent le même élément de configuration, [ \<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) dans [ \<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), pour découvrir les types connus ajoutés à travers un fichier de configuration.</span><span class="sxs-lookup"><span data-stu-id="51929-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="51929-327">Collections assignées à Object</span><span class="sxs-lookup"><span data-stu-id="51929-327">Collections Assigned to Object</span></span>

<span data-ttu-id="51929-328">Les collections assignées à Object sont sérialisées comme s'il s'agissait de collections qui implémentent <xref:System.Collections.Generic.IEnumerable%601> : tableau JSON dont chaque entrée comporte un affinage de type s'il s'agit d'un type complexe.</span><span class="sxs-lookup"><span data-stu-id="51929-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="51929-329">Par exemple, <xref:System.Collections.Generic.List%601> un `Shape` type <xref:System.Object> assigné à ressemble à ce qui suit.</span><span class="sxs-lookup"><span data-stu-id="51929-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="51929-330">Lorsque vous procédez à la désérialisation vers <xref:System.Object> :</span><span class="sxs-lookup"><span data-stu-id="51929-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="51929-331">`Shape`doit figurer dans la liste des types connus.</span><span class="sxs-lookup"><span data-stu-id="51929-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="51929-332">Avoir <xref:System.Collections.Generic.List%601> le `Shape` type dans les types connus n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="51929-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="51929-333">Notez que vous n’avez pas à ajouter `Shape` à des types connus sur la sérialisation dans ce cas - cela se fait automatiquement.</span><span class="sxs-lookup"><span data-stu-id="51929-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="51929-334">La collection est déséialisée <xref:System.Object> comme `Shape` un <xref:System.Array> type qui contient des instances.</span><span class="sxs-lookup"><span data-stu-id="51929-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="51929-335">Collections dérivées assignées aux collections de base</span><span class="sxs-lookup"><span data-stu-id="51929-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="51929-336">Lorsqu’une collection dérivée est assignée à une collection de base, elle est généralement sérialisée comme s’il s’agissait d’une collection du type de base.</span><span class="sxs-lookup"><span data-stu-id="51929-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="51929-337">Toutefois, si le type d'élément de la collection dérivée ne peut pas être assigné au type d'élément de la collection de base, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="51929-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="51929-338">Affinages de type et dictionnaires</span><span class="sxs-lookup"><span data-stu-id="51929-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="51929-339">Lorsqu'un dictionnaire est assigné à un <xref:System.Object>, chaque entrée de clé et de valeur du dictionnaire est traitée comme si elle était assignée à <xref:System.Object> et obtient un affinage du type.</span><span class="sxs-lookup"><span data-stu-id="51929-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="51929-340">Lors de la sérialisation des types de dictionnaire, l’objet JSON qui contient les membres "Clé" et "Valeur" n’est pas affecté par le paramètre `alwaysEmitTypeInformation` et contient un affinage du type uniquement lorsqu’il est requis par les règles de collection précédentes.</span><span class="sxs-lookup"><span data-stu-id="51929-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="51929-341">Nom de clés JSON valides</span><span class="sxs-lookup"><span data-stu-id="51929-341">Valid JSON Key Names</span></span>

<span data-ttu-id="51929-342">Le sérialiseur encode au format XML les noms de clés qui ne constituent pas des noms XML valides.</span><span class="sxs-lookup"><span data-stu-id="51929-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="51929-343">Par exemple, un membre de données ayant le nom de « 123 » aurait\_\_un nom\_\_codé tel que\_«\_x0031 x0032 x0033 » parce que « 123 » est un nom d’élément XML invalide (commence par un chiffre).</span><span class="sxs-lookup"><span data-stu-id="51929-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="51929-344">Une situation similaire peut se produire avec certains jeux de caractères internationaux non valides dans les noms XML.</span><span class="sxs-lookup"><span data-stu-id="51929-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="51929-345">Pour une explication de cet effet de XML sur le traitement JSON, voir [Cartographie entre JSON et XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="51929-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="51929-346">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="51929-346">See also</span></span>

- [<span data-ttu-id="51929-347">Prise en charge du format JSON et d'autres formats de transfert de données</span><span class="sxs-lookup"><span data-stu-id="51929-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
