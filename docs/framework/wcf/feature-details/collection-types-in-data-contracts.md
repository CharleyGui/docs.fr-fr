---
title: Types de collections dans les contrats de données
description: Découvrez comment le modèle de contrat de données traite les collections dans le .NET Framework et comment WCF prend en charge la sérialisation des données pour les types de collections.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: 83acf1f74bf3cb117f3f94743eda32d3f2cc4b82
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/23/2020
ms.locfileid: "85245178"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="816ec-103">Types de collections dans les contrats de données</span><span class="sxs-lookup"><span data-stu-id="816ec-103">Collection Types in Data Contracts</span></span>

<span data-ttu-id="816ec-104">Une *collection* est une liste d'éléments d'un certain type.</span><span class="sxs-lookup"><span data-stu-id="816ec-104">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="816ec-105">Dans le .NET Framework, ces listes peuvent être représentées à l’aide de tableaux ou de divers autres types (liste générique, générique <xref:System.ComponentModel.BindingList%601> , <xref:System.Collections.Specialized.StringCollection> ou <xref:System.Collections.ArrayList> ).</span><span class="sxs-lookup"><span data-stu-id="816ec-105">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="816ec-106">Par exemple, une collection peut contenir une liste d'adresses pour un client donné.</span><span class="sxs-lookup"><span data-stu-id="816ec-106">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="816ec-107">Ces collections sont appelées *collections liste*, indépendamment de leur type réel.</span><span class="sxs-lookup"><span data-stu-id="816ec-107">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="816ec-108">Il existe une forme spéciale de collection qui représente une association entre un élément (la "clé") et un autre élément (la "valeur").</span><span class="sxs-lookup"><span data-stu-id="816ec-108">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="816ec-109">Dans le .NET Framework, ils sont représentés par des types tels que <xref:System.Collections.Hashtable> et le dictionnaire générique.</span><span class="sxs-lookup"><span data-stu-id="816ec-109">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="816ec-110">Par exemple, une collection association peut mapper une ville ("clé") à sa population ("valeur").</span><span class="sxs-lookup"><span data-stu-id="816ec-110">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="816ec-111">Ces collections sont appelées *collections dictionnaire*, indépendamment de leur type réel.</span><span class="sxs-lookup"><span data-stu-id="816ec-111">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="816ec-112">Les collections reçoivent un traitement spécial dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="816ec-112">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="816ec-113">Les types qui implémentent l'interface <xref:System.Collections.IEnumerable> , y compris des tableaux et des collections génériques, sont reconnus en tant que collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-113">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="816ec-114">Parmi eux, les types qui implémentent les interfaces <xref:System.Collections.IDictionary> ou <xref:System.Collections.Generic.IDictionary%602> générique sont des collections dictionnaire ; tous les autres sont des collections liste.</span><span class="sxs-lookup"><span data-stu-id="816ec-114">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="816ec-115">Des exigences supplémentaires sur les types de collections, telles que le fait d’avoir une méthode appelée `Add` et un constructeur sans paramètre, sont décrites en détail dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="816ec-115">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="816ec-116">Cela garantit que les types de collections peuvent être à la fois sérialisés et désérialisés.</span><span class="sxs-lookup"><span data-stu-id="816ec-116">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="816ec-117">Cela signifie que certaines collections ne sont pas prises en charge directement, telles que le générique <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (car elle n’a aucun constructeur sans paramètre).</span><span class="sxs-lookup"><span data-stu-id="816ec-117">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="816ec-118">Toutefois, pour plus d'informations sur la façon de contourner ces restrictions, consultez la section « Utilisation des types d'interfaces de collection et des collections en lecture seule » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="816ec-118">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="816ec-119">Les types contenus dans les collections doivent être des types de contrat de données ou, dans le cas contraire, ils doivent être sérialisables.</span><span class="sxs-lookup"><span data-stu-id="816ec-119">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="816ec-120">Pour plus d’informations, consultez [types pris en charge par le sérialiseur de contrat de données](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="816ec-120">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="816ec-121">Pour plus d’informations sur ce qui est et ce qui n’est pas considéré comme une collection valide, ainsi que sur la façon dont les collections sont sérialisées, consultez les informations relatives à la sérialisation des collections dans la section « règles de collection avancées » de cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="816ec-121">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="816ec-122">Collections interchangeables</span><span class="sxs-lookup"><span data-stu-id="816ec-122">Interchangeable Collections</span></span>

<span data-ttu-id="816ec-123">Toutes les collections liste du même type sont considérées comme ayant le même contrat de données (à moins d'être personnalisées à l'aide de l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , comme cela est présenté ultérieurement dans cette rubrique).</span><span class="sxs-lookup"><span data-stu-id="816ec-123">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="816ec-124">Ainsi, par exemple, les contrats de données suivants sont équivalents :</span><span class="sxs-lookup"><span data-stu-id="816ec-124">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="816ec-125">Les deux contrats de données génèrent un XML semblable au code suivant :</span><span class="sxs-lookup"><span data-stu-id="816ec-125">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="816ec-126">L'interchangeabilité des collections vous permet d'utiliser, par exemple, un type de collection optimisé pour les performances sur le serveur, et un type de collection conçu pour être lié aux composants de l'interface utilisateur sur le client.</span><span class="sxs-lookup"><span data-stu-id="816ec-126">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="816ec-127">Semblables aux collections liste, toutes les collections dictionnaire qui ont les mêmes types de clé et de valeur sont considérées comme ayant le même contrat de données (à moins d'être personnalisées à l'aide de l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> ).</span><span class="sxs-lookup"><span data-stu-id="816ec-127">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="816ec-128">Seul le type de contrat de données importe en ce qui concerne l'équivalence de collections, pas les types .NET.</span><span class="sxs-lookup"><span data-stu-id="816ec-128">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="816ec-129">Autrement dit, une collection de Type1 est considérée équivalente à une collection de Type2 si Type1 et Type2 ont des contrats de données équivalents.</span><span class="sxs-lookup"><span data-stu-id="816ec-129">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="816ec-130">Les collections non génériques sont considérées comme ayant le même contrat de données que les collections génériques de type `Object`.</span><span class="sxs-lookup"><span data-stu-id="816ec-130">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="816ec-131">(Par exemple, les contrats de données pour <xref:System.Collections.ArrayList> et la <xref:System.Collections.Generic.List%601> générique de type `Object` sont les mêmes.)</span><span class="sxs-lookup"><span data-stu-id="816ec-131">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="816ec-132">Utilisation des types d'interfaces de collection et des collections en lecture seule</span><span class="sxs-lookup"><span data-stu-id="816ec-132">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="816ec-133">Les types d'interfaces de collection (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, <xref:System.Collections.Generic.IDictionary%602>générique, ou les interfaces dérivées de ces interfaces) sont également considérés comme ayant des contrats de données de collection équivalents aux contrats de données de collection pour les types de collections réels.</span><span class="sxs-lookup"><span data-stu-id="816ec-133">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="816ec-134">Par conséquent, il est possible de déclarer le type en cours de sérialisation comme type d'interface de collection et les résultats sont les mêmes que si un type de collection réel était utilisé.</span><span class="sxs-lookup"><span data-stu-id="816ec-134">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="816ec-135">Par exemple, les contrats de données suivants sont équivalents.</span><span class="sxs-lookup"><span data-stu-id="816ec-135">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="816ec-136">Pendant la sérialisation, lorsque le type déclaré est une interface, le type d'instance réel utilisé peut être tout type qui implémente cette interface.</span><span class="sxs-lookup"><span data-stu-id="816ec-136">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="816ec-137">Les restrictions présentées précédemment (avec un constructeur sans paramètre et une `Add` méthode) ne s’appliquent pas.</span><span class="sxs-lookup"><span data-stu-id="816ec-137">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="816ec-138">Par exemple, vous pouvez définir les adresses dans Customer2 sur une instance de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> générique d'adresse, bien que vous ne puissiez pas déclarer directement un membre de données de type <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>générique.</span><span class="sxs-lookup"><span data-stu-id="816ec-138">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="816ec-139">Pendant la désérialisation, lorsque le type déclaré est une interface, le moteur de sérialisation choisit un type qui implémente l'interface déclarée, et ce type est instancié.</span><span class="sxs-lookup"><span data-stu-id="816ec-139">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="816ec-140">Le mécanisme des types connus (décrit dans [types de contrat de données connus](data-contract-known-types.md)) n’a aucun effet ici ; le choix du type est intégré à WCF.</span><span class="sxs-lookup"><span data-stu-id="816ec-140">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="816ec-141">Personnalisation des types de collections</span><span class="sxs-lookup"><span data-stu-id="816ec-141">Customizing Collection Types</span></span>

<span data-ttu-id="816ec-142">Vous pouvez personnaliser les types de collections à l'aide de l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , qui présente plusieurs utilisations.</span><span class="sxs-lookup"><span data-stu-id="816ec-142">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="816ec-143">Notez que la personnalisation de types collection compromet l'interchangeabilité des collections. Il est donc généralement recommandé d'éviter d'appliquer cet attribut chaque fois que cela est possible.</span><span class="sxs-lookup"><span data-stu-id="816ec-143">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="816ec-144">Pour plus d’informations sur ce problème, consultez la section « règles de collection avancées » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="816ec-144">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="816ec-145">Attribution de noms aux contrats de données de collection</span><span class="sxs-lookup"><span data-stu-id="816ec-145">Collection Data Contract Naming</span></span>

<span data-ttu-id="816ec-146">Les règles d’attribution de noms aux types de collections sont semblables à celles d’attribution de noms aux types de contrat de données classiques, comme cela est décrit dans [Data Contract Names](data-contract-names.md), bien que certaines différences importantes existent :</span><span class="sxs-lookup"><span data-stu-id="816ec-146">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="816ec-147">L'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> permet de personnaliser le nom, à la place de l'attribut <xref:System.Runtime.Serialization.DataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="816ec-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="816ec-148">L'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> possède également les propriétés `Name` et `Namespace` .</span><span class="sxs-lookup"><span data-stu-id="816ec-148">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="816ec-149">Lorsque l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> n'est pas appliqué, le nom et l'espace de noms par défaut pour les types de collections dépendent des noms et des espaces de noms des types inclus dans la collection.</span><span class="sxs-lookup"><span data-stu-id="816ec-149">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="816ec-150">Ils ne sont pas affectés par le nom et l'espace de noms du type de collection lui-même.</span><span class="sxs-lookup"><span data-stu-id="816ec-150">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="816ec-151">Pour obtenir un exemple, consultez les types suivants.</span><span class="sxs-lookup"><span data-stu-id="816ec-151">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="816ec-152">Le nom de contrat de données des deux types est "ArrayOfstring" et non pas "CustomerList1" ou "StringList1".</span><span class="sxs-lookup"><span data-stu-id="816ec-152">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="816ec-153">Cela signifie que la sérialisation de n'importe lequel de ces types au niveau racine retourne un XML semblable au code suivant.</span><span class="sxs-lookup"><span data-stu-id="816ec-153">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="816ec-154">Cette règle d'attribution de noms a été choisie pour garantir que tous les types non personnalisés représentant une liste de chaînes aient les mêmes contrat de données et représentation XML.</span><span class="sxs-lookup"><span data-stu-id="816ec-154">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="816ec-155">Cela permet l'interchangeabilité des collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-155">This makes collection interchangeability possible.</span></span> <span data-ttu-id="816ec-156">Dans cet exemple, CustomerList1 et StringList1 sont complètement interchangeables.</span><span class="sxs-lookup"><span data-stu-id="816ec-156">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="816ec-157">Toutefois, lorsque l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> est appliqué, la collection devient un contrat de données de collection personnalisé, même si aucune propriété n'est définie sur l'attribut.</span><span class="sxs-lookup"><span data-stu-id="816ec-157">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="816ec-158">Le nom et l'espace de noms du contrat de données de collection dépendent alors du type de collection lui-même.</span><span class="sxs-lookup"><span data-stu-id="816ec-158">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="816ec-159">Pour obtenir un exemple, consultez le type suivant.</span><span class="sxs-lookup"><span data-stu-id="816ec-159">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="816ec-160">En cas de sérialisation, le XML obtenu est semblable au code ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="816ec-160">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="816ec-161">Vous remarquerez qu'il n'est plus équivalent à la représentation XML des types non personnalisés.</span><span class="sxs-lookup"><span data-stu-id="816ec-161">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="816ec-162">Vous pouvez utiliser les propriétés `Name` et `Namespace` pour personnaliser encore plus l'attribution de noms.</span><span class="sxs-lookup"><span data-stu-id="816ec-162">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="816ec-163">Consultez la classe suivante.</span><span class="sxs-lookup"><span data-stu-id="816ec-163">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="816ec-164">Le XML obtenu est semblable au code suivant :</span><span class="sxs-lookup"><span data-stu-id="816ec-164">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="816ec-165">Pour plus d’informations, consultez la section « règles de collection avancées » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="816ec-165">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="816ec-166">Personnalisation du nom d'élément répétitif dans les collections liste</span><span class="sxs-lookup"><span data-stu-id="816ec-166">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="816ec-167">Les collections liste contiennent des entrées répétitives.</span><span class="sxs-lookup"><span data-stu-id="816ec-167">List collections contain repeating entries.</span></span> <span data-ttu-id="816ec-168">Normalement, chaque entrée répétitive est représentée comme un élément nommé en fonction du nom de contrat de données du type contenu dans la collection.</span><span class="sxs-lookup"><span data-stu-id="816ec-168">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="816ec-169">Dans les exemples `CustomerList` , les collections contenaient des chaînes.</span><span class="sxs-lookup"><span data-stu-id="816ec-169">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="816ec-170">Le nom du contrat de données pour le type primitif de chaîne est « String », donc l’élément répété était « \<string> ».</span><span class="sxs-lookup"><span data-stu-id="816ec-170">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="816ec-171">Toutefois, le nom de cet élément répétitif peut être personnalisé à l'aide de la propriété <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> sur l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="816ec-171">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="816ec-172">Pour obtenir un exemple, consultez le type suivant.</span><span class="sxs-lookup"><span data-stu-id="816ec-172">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="816ec-173">Le XML obtenu est semblable au code suivant :</span><span class="sxs-lookup"><span data-stu-id="816ec-173">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="816ec-174">L'espace de noms de l'élément répétitif est toujours identique à celui du contrat de données de collection, qui peut être personnalisé à l'aide de la propriété `Namespace` , comme décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="816ec-174">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="816ec-175">Personnalisation des collections dictionnaire</span><span class="sxs-lookup"><span data-stu-id="816ec-175">Customizing Dictionary Collections</span></span>

<span data-ttu-id="816ec-176">Les collections dictionnaire sont essentiellement des listes d'entrées dans lesquelles chaque entrée a une clé suivie par une valeur.</span><span class="sxs-lookup"><span data-stu-id="816ec-176">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="816ec-177">Comme avec les listes normales, vous pouvez modifier le nom d'élément qui correspond à l'élément répétitif en utilisant la propriété <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> .</span><span class="sxs-lookup"><span data-stu-id="816ec-177">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="816ec-178">En outre, vous pouvez modifier les noms d'élément qui représentent la clé et la valeur en utilisant les propriétés <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> et <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> .</span><span class="sxs-lookup"><span data-stu-id="816ec-178">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="816ec-179">Les espaces de noms pour ces éléments sont les mêmes que l'espace de noms du contrat de données de collection.</span><span class="sxs-lookup"><span data-stu-id="816ec-179">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="816ec-180">Pour obtenir un exemple, consultez le type suivant.</span><span class="sxs-lookup"><span data-stu-id="816ec-180">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="816ec-181">En cas de sérialisation, le XML obtenu est semblable au code ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="816ec-181">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="816ec-182">Pour plus d’informations sur les collections de dictionnaires, consultez la section « règles de collection avancées » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="816ec-182">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="816ec-183">Collections et types connus</span><span class="sxs-lookup"><span data-stu-id="816ec-183">Collections and Known Types</span></span>

<span data-ttu-id="816ec-184">Vous n'avez pas besoin d'ajouter de types de collections aux types connus lorsqu'ils sont utilisés de manière polymorphe à la place d'autres collections ou interfaces de collection.</span><span class="sxs-lookup"><span data-stu-id="816ec-184">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="816ec-185">Par exemple, si vous déclarez un membre de données de type <xref:System.Collections.IEnumerable> et l'utilisez pour envoyer une instance de <xref:System.Collections.ArrayList>, vous n'avez pas besoin d'ajouter <xref:System.Collections.ArrayList> aux types connus.</span><span class="sxs-lookup"><span data-stu-id="816ec-185">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="816ec-186">Lorsque vous utilisez des collections de manière polymorphe au lieu de types qui ne sont pas des collections, elles doivent être ajoutées aux types connus.</span><span class="sxs-lookup"><span data-stu-id="816ec-186">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="816ec-187">Par exemple, si vous déclarez un membre de données de type `Object` et l'utilisez pour envoyer une instance de <xref:System.Collections.ArrayList>, ajoutez <xref:System.Collections.ArrayList> aux types connus.</span><span class="sxs-lookup"><span data-stu-id="816ec-187">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="816ec-188">Cela ne vous permet pas de sérialiser toute collection équivalente de manière polymorphe.</span><span class="sxs-lookup"><span data-stu-id="816ec-188">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="816ec-189">Par exemple, lorsque vous ajoutez <xref:System.Collections.ArrayList> à la liste des types connus dans l'exemple précédent, cela ne vous permet pas d'assigner la classe `Array of Object` , bien qu'elle ait un contrat de données équivalent.</span><span class="sxs-lookup"><span data-stu-id="816ec-189">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="816ec-190">Ce comportement n'est pas différent du comportement normal des types connus sur la sérialisation des types qui ne sont pas des collections, mais il est particulièrement important de le comprendre dans le cas des collections car celles-ci sont très souvent équivalentes.</span><span class="sxs-lookup"><span data-stu-id="816ec-190">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="816ec-191">Pendant la sérialisation, un seul type peut être connu dans toute portée donnée d'un contrat de données particulier et toutes les collections équivalentes ont les mêmes contrats de données.</span><span class="sxs-lookup"><span data-stu-id="816ec-191">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="816ec-192">Cela signifie que, dans l'exemple précédent, vous ne pouvez pas ajouter à la fois <xref:System.Collections.ArrayList> et `Array of Object` aux types connus au niveau de la même portée.</span><span class="sxs-lookup"><span data-stu-id="816ec-192">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="816ec-193">Encore une fois, cela est équivalent au comportement des types connus pour les types qui ne sont pas des collections, mais cela est particulièrement important à comprendre pour les collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-193">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="816ec-194">Les types connus peuvent également être requis pour le contenu des collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-194">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="816ec-195">Par exemple, si un <xref:System.Collections.ArrayList> contient réellement des instances de `Type1` et `Type2`, ces deux types doivent être ajoutés aux types connus.</span><span class="sxs-lookup"><span data-stu-id="816ec-195">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="816ec-196">L'exemple ci-dessous montre un graphique d'objet construit correctement à l'aide de collections et des types connus.</span><span class="sxs-lookup"><span data-stu-id="816ec-196">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="816ec-197">Cet exemple est quelque peu inventé car, dans une application réelle, vous ne définiriez normalement pas les membres de données suivants comme `Object`et, par conséquent, vous ne rencontreriez aucun problème de polymorphisme ou de type connu.</span><span class="sxs-lookup"><span data-stu-id="816ec-197">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="816ec-198">Lors de la désérialisation, si le type déclaré est un type de collection, le type déclaré est instancié indépendamment du type qui a été réellement envoyé.</span><span class="sxs-lookup"><span data-stu-id="816ec-198">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="816ec-199">Si le type déclaré est une interface de collection, le désérialiseur choisit un type à instancier sans se soucier des types connus.</span><span class="sxs-lookup"><span data-stu-id="816ec-199">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="816ec-200">De plus, lors de la désérialisation, si le type déclaré n'est pas un type de collection mais un type de collection est envoyé, un type de collection correspondant est choisi dans la liste des types connus.</span><span class="sxs-lookup"><span data-stu-id="816ec-200">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="816ec-201">Il est possible d'ajouter des types d'interfaces de collection à la liste des types connus lors de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="816ec-201">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="816ec-202">Dans ce cas, le moteur de désérialisation choisit de nouveau un type à instancier.</span><span class="sxs-lookup"><span data-stu-id="816ec-202">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="816ec-203">Collections et classe NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="816ec-203">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="816ec-204">Lorsque la classe <xref:System.Runtime.Serialization.NetDataContractSerializer> est utilisée, les types de collections non personnalisés (sans l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> ) qui ne sont pas des tableaux perdent leur signification spéciale.</span><span class="sxs-lookup"><span data-stu-id="816ec-204">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="816ec-205">Les types de collections non personnalisés marqués avec l'attribut <xref:System.SerializableAttribute> peuvent encore être sérialisés par la classe <xref:System.Runtime.Serialization.NetDataContractSerializer> en fonction de l'attribut <xref:System.SerializableAttribute> ou des règles d'interface <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="816ec-205">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="816ec-206">Les types de collections personnalisés, les interfaces de collection et les tableaux sont encore traités comme des collections, même lorsque la classe <xref:System.Runtime.Serialization.NetDataContractSerializer> est utilisée.</span><span class="sxs-lookup"><span data-stu-id="816ec-206">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="816ec-207">Collections et schéma</span><span class="sxs-lookup"><span data-stu-id="816ec-207">Collections and Schema</span></span>

<span data-ttu-id="816ec-208">Toutes les collections équivalentes ont la même représentation dans le schéma XSD (XML Schema Definition).</span><span class="sxs-lookup"><span data-stu-id="816ec-208">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="816ec-209">C'est pourquoi vous n'obtiendrez normalement pas le même type de collection dans le code client généré que sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="816ec-209">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="816ec-210">Par exemple, le serveur peut utiliser un contrat de données avec un membre de données <xref:System.Collections.Generic.List%601> générique d'éléments Integer, alors que, dans le code client généré, le même membre de données peut devenir un tableau d'entiers.</span><span class="sxs-lookup"><span data-stu-id="816ec-210">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="816ec-211">Les collections dictionnaire sont marquées avec une annotation de schéma spécifique à WCF qui indique qu’il s’agit de dictionnaires ; dans le cas contraire, ils ne peuvent pas être différenciés des listes simples qui contiennent des entrées avec une clé et une valeur.</span><span class="sxs-lookup"><span data-stu-id="816ec-211">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="816ec-212">Pour une description exacte de la façon dont les collections sont représentées dans le schéma de contrat de données, consultez [Data Contract Schema Reference](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="816ec-212">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="816ec-213">Par défaut, les types ne sont pas générés pour les collections non personnalisées dans le code importé.</span><span class="sxs-lookup"><span data-stu-id="816ec-213">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="816ec-214">Les membres de données des types de collections liste sont importés en tant que tableaux, alors que les membres de données des types de collections dictionnaire sont importés en tant que dictionnaire générique.</span><span class="sxs-lookup"><span data-stu-id="816ec-214">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="816ec-215">Toutefois, pour les collections personnalisées, des types distincts sont générés, marqués avec l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="816ec-215">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="816ec-216">(Un type de collection personnalisé dans le schéma est un type qui n’utilise pas l’espace de noms, le nom, le nom d’élément répétitif ou les noms d’éléments clé/valeur par défaut.) Ces types sont des types vides qui dérivent de generic <xref:System.Collections.Generic.List%601> pour les types de liste et le dictionnaire générique pour les types de dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="816ec-216">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="816ec-217">Par exemple, vous pouvez avoir les types ci-dessous sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="816ec-217">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="816ec-218">Lorsque le schéma est exporté puis importé de nouveau, le code client généré est semblable à ce qui suit (les propriétés sont remplacées par des champs pour une meilleure lisibilité).</span><span class="sxs-lookup"><span data-stu-id="816ec-218">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="816ec-219">Vous pouvez utiliser des types différents dans le code généré à la place des types par défaut.</span><span class="sxs-lookup"><span data-stu-id="816ec-219">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="816ec-220">Par exemple, vous pouvez utiliser le <xref:System.ComponentModel.BindingList%601> générique à la place de tableaux normaux pour vos membres de données pour pouvoir les lier plus facilement aux composants d'interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="816ec-220">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="816ec-221">Pour choisir des types de collections à générer, passez une liste de types de collections que vous souhaitez utiliser dans la propriété <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> de l'objet <xref:System.Runtime.Serialization.ImportOptions> lors de l'importation du schéma.</span><span class="sxs-lookup"><span data-stu-id="816ec-221">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="816ec-222">Ces types sont appelés *types de collections référencés*.</span><span class="sxs-lookup"><span data-stu-id="816ec-222">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="816ec-223">Lorsque des types génériques sont référencés, il doit s'agir de génériques complètement ouverts ou complètement fermés.</span><span class="sxs-lookup"><span data-stu-id="816ec-223">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="816ec-224">Lorsque vous utilisez l’outil Svcutil.exe, cette référence peut être réalisée à l’aide du commutateur de ligne de commande **/collectionType** (forme abrégée : **/ct**).</span><span class="sxs-lookup"><span data-stu-id="816ec-224">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="816ec-225">N’oubliez pas que vous devez également spécifier l’assembly pour les types de collections référencés à l’aide du commutateur **/reference** (forme abrégée : **/r**).</span><span class="sxs-lookup"><span data-stu-id="816ec-225">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="816ec-226">Si le type est générique, il doit être suivi par une apostrophe inverse et le nombre de paramètres génériques.</span><span class="sxs-lookup"><span data-stu-id="816ec-226">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="816ec-227">Le guillemet () ne doit \` pas être confondu avec le caractère guillemet simple (').</span><span class="sxs-lookup"><span data-stu-id="816ec-227">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="816ec-228">Vous pouvez spécifier plusieurs types de collections référencés en utilisant plusieurs fois le commutateur **/collectionType** .</span><span class="sxs-lookup"><span data-stu-id="816ec-228">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="816ec-229">Par exemple, pour provoquer l'importation de toutes les listes en tant que <xref:System.Collections.Generic.List%601>générique.</span><span class="sxs-lookup"><span data-stu-id="816ec-229">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="816ec-230">Lors de l'importation d'une collection quelconque, cette liste de types de collections référencés est analysée et la collection qui correspond le mieux est utilisée, le cas échéant, soit comme type de membre de données (pour les collections non personnalisées), soit comme type de base à partir duquel dériver (pour les collections personnalisées).</span><span class="sxs-lookup"><span data-stu-id="816ec-230">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="816ec-231">Les dictionnaires sont comparés uniquement à des dictionnaires, tandis que les listes sont comparées à des listes.</span><span class="sxs-lookup"><span data-stu-id="816ec-231">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="816ec-232">Par exemple, si vous ajoutez le <xref:System.ComponentModel.BindingList%601> générique et <xref:System.Collections.Hashtable> à la liste des types référencés, le code client généré pour l'exemple précédent sera semblable au code ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="816ec-232">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="816ec-233">Vous pouvez spécifier des types d'interfaces de collection dans le cadre de vos types de collections référencés, mais vous ne pouvez pas spécifier de types de collections non valides (tels que des types sans méthode `Add` ou sans constructeur public).</span><span class="sxs-lookup"><span data-stu-id="816ec-233">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="816ec-234">Un générique fermé est considéré comme la solution la mieux adaptée.</span><span class="sxs-lookup"><span data-stu-id="816ec-234">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="816ec-235">(Les types non génériques sont considérés équivalents aux génériques fermés d' `Object`.)</span><span class="sxs-lookup"><span data-stu-id="816ec-235">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="816ec-236">Par exemple, si les types <xref:System.Collections.Generic.List%601> générique de <xref:System.DateTime>, <xref:System.ComponentModel.BindingList%601> générique (générique ouvert) et <xref:System.Collections.ArrayList> sont les types de collections référencés, le code ci-dessous est généré.</span><span class="sxs-lookup"><span data-stu-id="816ec-236">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="816ec-237">Pour les collections liste, seuls les cas indiqués dans le tableau suivant sont pris en charge.</span><span class="sxs-lookup"><span data-stu-id="816ec-237">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="816ec-238">Type référencé</span><span class="sxs-lookup"><span data-stu-id="816ec-238">Referenced type</span></span>|<span data-ttu-id="816ec-239">Interface implémentée par le type référencé</span><span class="sxs-lookup"><span data-stu-id="816ec-239">Interface implemented by referenced type</span></span>|<span data-ttu-id="816ec-240">Exemple</span><span class="sxs-lookup"><span data-stu-id="816ec-240">Example</span></span>|<span data-ttu-id="816ec-241">Type traité comme :</span><span class="sxs-lookup"><span data-stu-id="816ec-241">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="816ec-242">Non générique ou générique fermé (nombre de paramètres quelconque)</span><span class="sxs-lookup"><span data-stu-id="816ec-242">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="816ec-243">Non générique</span><span class="sxs-lookup"><span data-stu-id="816ec-243">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="816ec-244">ou</span><span class="sxs-lookup"><span data-stu-id="816ec-244">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="816ec-245">où T= `int`</span><span class="sxs-lookup"><span data-stu-id="816ec-245">where T= `int`</span></span>|<span data-ttu-id="816ec-246">Générique fermé d' `Object` (par exemple, `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="816ec-246">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="816ec-247">Non générique ou générique fermé (nombre quelconque de paramètres qui ne correspondent pas nécessairement au type de collection)</span><span class="sxs-lookup"><span data-stu-id="816ec-247">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="816ec-248">Générique fermé</span><span class="sxs-lookup"><span data-stu-id="816ec-248">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="816ec-249">ou</span><span class="sxs-lookup"><span data-stu-id="816ec-249">or</span></span><br /><br /> <span data-ttu-id="816ec-250">`MyType<T> : IList<string>` où T=`int`</span><span class="sxs-lookup"><span data-stu-id="816ec-250">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="816ec-251">Générique fermé (par exemple, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="816ec-251">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="816ec-252">Générique fermé avec un nombre quelconque de paramètres</span><span class="sxs-lookup"><span data-stu-id="816ec-252">Closed generic with any number of parameters</span></span>|<span data-ttu-id="816ec-253">Générique ouvert utilisant un des paramètres du type</span><span class="sxs-lookup"><span data-stu-id="816ec-253">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="816ec-254">où T=`int`, U=`string`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="816ec-254">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="816ec-255">Générique fermé (par exemple, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="816ec-255">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="816ec-256">Générique ouvert avec un paramètre</span><span class="sxs-lookup"><span data-stu-id="816ec-256">Open generic with one parameter</span></span>|<span data-ttu-id="816ec-257">Générique ouvert utilisant le paramètre du type</span><span class="sxs-lookup"><span data-stu-id="816ec-257">Open generic using the type’s parameter</span></span>|<span data-ttu-id="816ec-258">`MyType<T> : IList<T>`, T est ouvert</span><span class="sxs-lookup"><span data-stu-id="816ec-258">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="816ec-259">Générique ouvert (par exemple, `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="816ec-259">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="816ec-260">Si un type implémente plusieurs interfaces de collection liste, les restrictions suivantes s'appliquent :</span><span class="sxs-lookup"><span data-stu-id="816ec-260">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="816ec-261">Si le type implémente le <xref:System.Collections.Generic.IEnumerable%601> générique (ou ses interfaces dérivées) plusieurs fois pour des types différents, le type n'est pas considéré comme un type de collection référencé valide et il est ignoré.</span><span class="sxs-lookup"><span data-stu-id="816ec-261">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="816ec-262">Cela est vrai même si certaines implémentations ne sont pas valides ou utilisent des génériques ouverts.</span><span class="sxs-lookup"><span data-stu-id="816ec-262">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="816ec-263">Par exemple, un type qui implémente le <xref:System.Collections.Generic.IEnumerable%601> générique d' `int` et le <xref:System.Collections.Generic.IEnumerable%601> générique de T ne serait jamais utilisé comme collection référencée d' `int` ou tout autre type, que le type ait ou non une méthode `Add` qui accepte `int` ou une méthode `Add` qui accepte un paramètre de type T, ou les deux.</span><span class="sxs-lookup"><span data-stu-id="816ec-263">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="816ec-264">Si le type implémente une interface de collection générique ainsi que <xref:System.Collections.IList>, le type ne sera jamais utilisé comme type de collection référencé à moins que l'interface de collection générique ne soit un générique fermé de type <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="816ec-264">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="816ec-265">Pour les collections dictionnaire, seuls les cas indiqués dans le tableau suivant sont pris en charge.</span><span class="sxs-lookup"><span data-stu-id="816ec-265">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="816ec-266">Type référencé</span><span class="sxs-lookup"><span data-stu-id="816ec-266">Referenced type</span></span>|<span data-ttu-id="816ec-267">Interface implémentée par le type référencé</span><span class="sxs-lookup"><span data-stu-id="816ec-267">Interface implemented by referenced type</span></span>|<span data-ttu-id="816ec-268">Exemple</span><span class="sxs-lookup"><span data-stu-id="816ec-268">Example</span></span>|<span data-ttu-id="816ec-269">Type traité comme</span><span class="sxs-lookup"><span data-stu-id="816ec-269">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="816ec-270">Non générique ou générique fermé (nombre de paramètres quelconque)</span><span class="sxs-lookup"><span data-stu-id="816ec-270">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="816ec-271">ou</span><span class="sxs-lookup"><span data-stu-id="816ec-271">or</span></span><br /><br /> <span data-ttu-id="816ec-272">`MyType<T> : IDictionary` où T=`int`</span><span class="sxs-lookup"><span data-stu-id="816ec-272">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="816ec-273">Générique fermé `IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="816ec-273">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="816ec-274">Générique fermé (nombre quelconque de paramètres)</span><span class="sxs-lookup"><span data-stu-id="816ec-274">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="816ec-275"><xref:System.Collections.Generic.IDictionary%602>, fermé</span><span class="sxs-lookup"><span data-stu-id="816ec-275"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="816ec-276">`MyType<T> : IDictionary<string, bool>` où T=`int`</span><span class="sxs-lookup"><span data-stu-id="816ec-276">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="816ec-277">Générique fermé (par exemple, `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="816ec-277">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="816ec-278">Générique fermé (nombre quelconque de paramètres)</span><span class="sxs-lookup"><span data-stu-id="816ec-278">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="816ec-279"><xref:System.Collections.Generic.IDictionary%602>générique, la clé ou la valeur est fermée, l'autre est ouverte et utilise un des paramètres du type</span><span class="sxs-lookup"><span data-stu-id="816ec-279">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="816ec-280">`MyType<T,U,V> : IDictionary<string,V>` où T=`int`, U=`float`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="816ec-280">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="816ec-281">ou</span><span class="sxs-lookup"><span data-stu-id="816ec-281">or</span></span><br /><br /> <span data-ttu-id="816ec-282">`MyType<Z> : IDictionary<Z,bool>` où Z=`string`</span><span class="sxs-lookup"><span data-stu-id="816ec-282">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="816ec-283">Générique fermé (par exemple, `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="816ec-283">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="816ec-284">Générique fermé (nombre quelconque de paramètres)</span><span class="sxs-lookup"><span data-stu-id="816ec-284">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="816ec-285"><xref:System.Collections.Generic.IDictionary%602>générique, la clé et la valeur sont ouvertes et chacune d'elles utilise un des paramètres du type</span><span class="sxs-lookup"><span data-stu-id="816ec-285">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="816ec-286">`MyType<T,U,V> : IDictionary<V,U>` où T=`int`, U=`bool`, V=`string`</span><span class="sxs-lookup"><span data-stu-id="816ec-286">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="816ec-287">Générique fermé (par exemple, `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="816ec-287">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="816ec-288">Générique ouvert (deux paramètres)</span><span class="sxs-lookup"><span data-stu-id="816ec-288">Open generic (two parameters)</span></span>|<span data-ttu-id="816ec-289"><xref:System.Collections.Generic.IDictionary%602>générique, ouvert, utilise les deux paramètres génériques du type dans l'ordre où ils apparaissent</span><span class="sxs-lookup"><span data-stu-id="816ec-289">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="816ec-290">`MyType<K,V> : IDictionary<K,V>`, K et V sont ouverts tous les deux</span><span class="sxs-lookup"><span data-stu-id="816ec-290">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="816ec-291">Générique ouvert (par exemple, `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="816ec-291">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="816ec-292">Si le type implémente <xref:System.Collections.IDictionary> et le <xref:System.Collections.Generic.IDictionary%602>générique, seul le <xref:System.Collections.Generic.IDictionary%602> générique est pris en compte.</span><span class="sxs-lookup"><span data-stu-id="816ec-292">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="816ec-293">Le référencement de types génériques partiels n'est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="816ec-293">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="816ec-294">Les doublons ne sont pas autorisés. Par exemple, vous ne pouvez pas ajouter à la fois la <xref:System.Collections.Generic.List%601> générique d'éléments `Integer` et la collection générique d'éléments `Integer` à <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, car cela empêche de déterminer laquelle utiliser si une liste d'entiers est détectée dans le schéma.</span><span class="sxs-lookup"><span data-stu-id="816ec-294">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="816ec-295">Les doublons sont détectés uniquement si un type présent dans le schéma expose le problème des doublons.</span><span class="sxs-lookup"><span data-stu-id="816ec-295">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="816ec-296">Par exemple, si le schéma en cours d'importation ne contient pas de listes d'entiers, il est autorisé d'avoir à la fois la <xref:System.Collections.Generic.List%601> générique d'éléments `Integer` et la collection générique d'éléments `Integer` dans <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, mais aucune d'elles n'a un quelconque effet.</span><span class="sxs-lookup"><span data-stu-id="816ec-296">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="816ec-297">Règles de collection avancées</span><span class="sxs-lookup"><span data-stu-id="816ec-297">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="816ec-298">Sérialisation de collections</span><span class="sxs-lookup"><span data-stu-id="816ec-298">Serializing Collections</span></span>

<span data-ttu-id="816ec-299">La liste suivante répertorie les règles de collection pour la sérialisation :</span><span class="sxs-lookup"><span data-stu-id="816ec-299">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="816ec-300">L'association de types de collections (avoir des collections de collections) est autorisée.</span><span class="sxs-lookup"><span data-stu-id="816ec-300">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="816ec-301">Les tableaux en escalier sont traités comme des collections de collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-301">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="816ec-302">Les tableaux multidimensionnels ne sont pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="816ec-302">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="816ec-303">Les tableaux d'octets et les tableaux de <xref:System.Xml.XmlNode> sont des types de tableau spéciaux qui sont traités comme des primitifs, pas comme des collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-303">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="816ec-304">La sérialisation d'un tableau d'octets génère un élément XML unique qui contient un segment de données encodées en Base64, au lieu d'un élément distinct pour chaque octet.</span><span class="sxs-lookup"><span data-stu-id="816ec-304">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="816ec-305">Pour plus d’informations sur la façon dont un tableau de <xref:System.Xml.XmlNode> est traité, consultez [types XML et ADO.net dans les contrats de données](xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="816ec-305">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="816ec-306">Naturellement, ces types spéciaux peuvent eux-mêmes participer aux collections : un tableau de tableaux d'octets génère plusieurs éléments XML contenant chacun un segment de données encodées en Base64.</span><span class="sxs-lookup"><span data-stu-id="816ec-306">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="816ec-307">Si l'attribut <xref:System.Runtime.Serialization.DataContractAttribute> est appliqué à un type de collection, le type est traité comme un type de contrat de données standard, pas comme une collection.</span><span class="sxs-lookup"><span data-stu-id="816ec-307">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="816ec-308">Si un type de collection implémente l'interface <xref:System.Xml.Serialization.IXmlSerializable> , les restrictions suivantes s'appliquent, s'il s'agit d'un type `myType:IList<string>, IXmlSerializable`:</span><span class="sxs-lookup"><span data-stu-id="816ec-308">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="816ec-309">Si le type déclaré est `IList<string>`, le type est sérialisé en tant que liste.</span><span class="sxs-lookup"><span data-stu-id="816ec-309">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="816ec-310">Si le type déclaré est `myType`, il est sérialisé en tant que `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="816ec-310">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="816ec-311">Si le type déclaré est `IXmlSerializable`, il est sérialisé en tant que `IXmlSerializable`, mais uniquement si vous ajoutez `myType` à la liste des types connus.</span><span class="sxs-lookup"><span data-stu-id="816ec-311">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="816ec-312">Les collections sont sérialisées et désérialisées à l'aide des méthodes indiquées dans le tableau ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="816ec-312">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="816ec-313">Le type de collection implémente</span><span class="sxs-lookup"><span data-stu-id="816ec-313">Collection type implements</span></span>|<span data-ttu-id="816ec-314">Méthodes appelées lors de la sérialisation</span><span class="sxs-lookup"><span data-stu-id="816ec-314">Method(s) called on serialization</span></span>|<span data-ttu-id="816ec-315">Méthodes appelées lors de la désérialisation</span><span class="sxs-lookup"><span data-stu-id="816ec-315">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>|<span data-ttu-id="816ec-317">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="816ec-317">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="816ec-318">Generic Add</span><span class="sxs-lookup"><span data-stu-id="816ec-318">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="816ec-319">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="816ec-319">`get_Keys`, `get_Values`</span></span>|`Add`|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph>|<span data-ttu-id="816ec-321">Indexeur <xref:System.Collections.Generic.IList%601> générique</span><span class="sxs-lookup"><span data-stu-id="816ec-321">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="816ec-322">Generic Add</span><span class="sxs-lookup"><span data-stu-id="816ec-322">Generic Add</span></span>|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.ICollection%601&gt;</ph>|<span data-ttu-id="816ec-324">Énumérateur</span><span class="sxs-lookup"><span data-stu-id="816ec-324">Enumerator</span></span>|<span data-ttu-id="816ec-325">Generic Add</span><span class="sxs-lookup"><span data-stu-id="816ec-325">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="816ec-326">Indexeur<xref:System.Collections.IList></span><span class="sxs-lookup"><span data-stu-id="816ec-326"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>|`GetEnumerator`|<span data-ttu-id="816ec-328">Méthode non statique nommée `Add` qui accepte un paramètre du type approprié (le type du paramètre générique ou un de ses types de base).</span><span class="sxs-lookup"><span data-stu-id="816ec-328">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="816ec-329">Une telle méthode doit exister pour que le sérialiseur traite un type de collection comme une collection lors de la sérialisation et de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="816ec-329">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="816ec-330"><xref:System.Collections.IEnumerable> (et donc <xref:System.Collections.ICollection>, qui en dérive)</span><span class="sxs-lookup"><span data-stu-id="816ec-330"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="816ec-331">Méthode non statique nommée `Add` qui accepte un paramètre de type `Object`.</span><span class="sxs-lookup"><span data-stu-id="816ec-331">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="816ec-332">Une telle méthode doit exister pour que le sérialiseur traite un type de collection comme une collection lors de la sérialisation et de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="816ec-332">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="816ec-333">Le tableau précédent répertorie les interfaces de collection dans l'ordre de priorité décroissant.</span><span class="sxs-lookup"><span data-stu-id="816ec-333">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="816ec-334">Cela signifie, par exemple, que si un type implémente à la fois <xref:System.Collections.IList> et <xref:System.Collections.Generic.IEnumerable%601>générique, la collection est sérialisée et désérialisée en fonction des règles <xref:System.Collections.IList> :</span><span class="sxs-lookup"><span data-stu-id="816ec-334">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="816ec-335">Lors de la désérialisation, toutes les collections sont désérialisées en créant d’abord une instance du type en appelant le constructeur sans paramètre, qui doit être présent pour que le sérialiseur traite un type de collection comme une collection lors de la sérialisation et de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="816ec-335">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="816ec-336">Si la même interface de collection générique est implémentée plusieurs fois (par exemple, si un type implémente à la fois le <xref:System.Collections.Generic.ICollection%601> générique d'éléments `Integer` et le <xref:System.Collections.Generic.ICollection%601> générique d'éléments <xref:System.String>) et qu'aucune interface de priorité supérieure n'est trouvée, la collection n'est pas traitée comme une collection valide.</span><span class="sxs-lookup"><span data-stu-id="816ec-336">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="816ec-337">L'attribut <xref:System.SerializableAttribute> peut être appliqué aux types de collections et ces derniers peuvent implémenter l'interface <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="816ec-337">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="816ec-338">Ces deux éléments sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="816ec-338">Both of these are ignored.</span></span> <span data-ttu-id="816ec-339">Toutefois, si le type ne satisfait pas pleinement les spécifications de type de collection (par exemple, si la méthode `Add` est manquante), le type n'est pas considéré comme un type de collection, et par conséquent l'attribut <xref:System.SerializableAttribute> et l'interface <xref:System.Runtime.Serialization.ISerializable> sont utilisés pour déterminer si le type peut être sérialisé.</span><span class="sxs-lookup"><span data-stu-id="816ec-339">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="816ec-340">L'application de l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> à une collection pour la personnaliser supprime le mécanisme de secours <xref:System.SerializableAttribute> mentionné précédemment.</span><span class="sxs-lookup"><span data-stu-id="816ec-340">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="816ec-341">À la place, si une collection personnalisée ne satisfait pas les spécifications de type de collection, une exception <xref:System.Runtime.Serialization.InvalidDataContractException> est levée.</span><span class="sxs-lookup"><span data-stu-id="816ec-341">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="816ec-342">La chaîne d’exception contient souvent des informations qui expliquent pourquoi un type donné n’est pas considéré comme une collection valide (aucune `Add` méthode, aucun constructeur sans paramètre, etc.). il est donc souvent utile d’appliquer l' <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribut à des fins de débogage.</span><span class="sxs-lookup"><span data-stu-id="816ec-342">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="816ec-343">Attribution des noms de collections</span><span class="sxs-lookup"><span data-stu-id="816ec-343">Collection Naming</span></span>

<span data-ttu-id="816ec-344">La liste suivante répertorie les règles d'attribution des noms des collections :</span><span class="sxs-lookup"><span data-stu-id="816ec-344">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="816ec-345">L’espace de noms par défaut pour tous les contrats de données de collection de dictionnaires, ainsi que pour les contrats de données de collection de listes qui contiennent des types primitifs, est, `http://schemas.microsoft.com/2003/10/Serialization/Arrays` sauf s’il est substitué à l’aide de l’espace</span><span class="sxs-lookup"><span data-stu-id="816ec-345">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="816ec-346">Les types qui correspondent aux types XSD intégrés, ainsi que les types `char`, `Timespan`et `Guid` , sont considérés comme des primitifs à cette fin.</span><span class="sxs-lookup"><span data-stu-id="816ec-346">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="816ec-347">L'espace de noms par défaut des types de collections contenant des types non primitifs, à moins qu'il soit remplacé à l'aide de Namespace, est le même que celui des noms de contrat de données du type inclus dans la collection.</span><span class="sxs-lookup"><span data-stu-id="816ec-347">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="816ec-348">Le nom par défaut pour les contrats de données de collection de liste, à moins qu'il ne soit remplacé à l'aide de Name, est la chaîne "ArrayOf" associée au nom du contrat de données du type inclus dans la collection.</span><span class="sxs-lookup"><span data-stu-id="816ec-348">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="816ec-349">Par exemple, le nom du contrat de données pour une liste générique d'éléments Integer est "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="816ec-349">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="816ec-350">N'oubliez pas que le nom de contrat de données d' `Object` est "anyType", afin que le nom de contrat de données de listes non génériques comme <xref:System.Collections.ArrayList> soit "ArrayOfanyType".</span><span class="sxs-lookup"><span data-stu-id="816ec-350">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="816ec-351">Le nom par défaut pour les contrats de données de collection dictionnaire, à moins qu'il soit remplacé à l'aide de `Name`, est la chaîne "ArrayOfKeyValueOf" associée au nom du contrat de données du type de clé suivie par le nom du contrat de données du type de valeur.</span><span class="sxs-lookup"><span data-stu-id="816ec-351">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="816ec-352">Par exemple, le nom du contrat de données pour un dictionnaire générique d'éléments String et Integer est "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="816ec-352">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="816ec-353">En outre, si les types de clé ou de valeur ne sont pas des types primitifs, un hachage d'espace de noms des espaces de noms de contrat de données des types de clé et de valeur est ajouté au nom.</span><span class="sxs-lookup"><span data-stu-id="816ec-353">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="816ec-354">Pour plus d’informations sur les hachages d’espaces de noms, consultez [noms de contrat de données](data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="816ec-354">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="816ec-355">Chaque contrat de données de collection dictionnaire possède un contrat de données auxiliaire qui représente une entrée dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="816ec-355">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="816ec-356">Son nom est le même que pour le contrat de données de dictionnaire, à l'exception du préfixe "ArrayOf", et son espace de noms est le même que pour le contrat de données de dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="816ec-356">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="816ec-357">Par exemple, pour le contrat de données de dictionnaire "ArrayOfKeyValueOfstringint", le contrat de données "KeyValueofstringint" représente une entrée dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="816ec-357">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="816ec-358">Vous pouvez personnaliser le nom de ce contrat de données en utilisant la propriété `ItemName` tel que cela est décrit dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="816ec-358">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="816ec-359">Les règles d’attribution de noms de type générique, comme décrit dans [Data Contract Names](data-contract-names.md), s’appliquent pleinement aux types de collections ; en d’autres termes, vous pouvez utiliser des accolades dans Name pour indiquer des paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="816ec-359">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="816ec-360">Toutefois, notez que les nombres indiqués entre les accolades font référence aux paramètres génériques et non aux types inclus dans la collection.</span><span class="sxs-lookup"><span data-stu-id="816ec-360">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="816ec-361">Personnalisation des collections</span><span class="sxs-lookup"><span data-stu-id="816ec-361">Collection Customization</span></span>

<span data-ttu-id="816ec-362">Les utilisations suivantes de l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> sont interdites et entraînent une exception <xref:System.Runtime.Serialization.InvalidDataContractException> :</span><span class="sxs-lookup"><span data-stu-id="816ec-362">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="816ec-363">Application de l'attribut <xref:System.Runtime.Serialization.DataContractAttribute> à un type auquel l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> a été appliqué, ou à l'un de ses types dérivés.</span><span class="sxs-lookup"><span data-stu-id="816ec-363">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="816ec-364">Application de l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> à un type qui implémente l'interface <xref:System.Xml.Serialization.IXmlSerializable> .</span><span class="sxs-lookup"><span data-stu-id="816ec-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="816ec-365">Application de l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> à un type qui n'est pas une collection.</span><span class="sxs-lookup"><span data-stu-id="816ec-365">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="816ec-366">Tentative de définir <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> ou <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> sur un attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> appliqué à un type qui n'est pas un dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="816ec-366">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="816ec-367">Règles de polymorphisme</span><span class="sxs-lookup"><span data-stu-id="816ec-367">Polymorphism Rules</span></span>

<span data-ttu-id="816ec-368">Comme cela a été mentionné précédemment, la personnalisation de collections à l'aide de l'attribut <xref:System.Runtime.Serialization.CollectionDataContractAttribute> peut interférer avec l'interchangeabilité des collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-368">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="816ec-369">Deux types de collections personnalisés peuvent être considérés équivalents uniquement si leurs noms, leurs espaces de noms, leurs noms d'élément, ainsi que leurs noms de clé et de valeur (si ce sont des collections dictionnaire) correspondent.</span><span class="sxs-lookup"><span data-stu-id="816ec-369">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="816ec-370">En raison des personnalisations, il est possible d'utiliser par inadvertance un contrat de données de collection lorsqu'un autre contrat est attendu.</span><span class="sxs-lookup"><span data-stu-id="816ec-370">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="816ec-371">Cela doit être évité.</span><span class="sxs-lookup"><span data-stu-id="816ec-371">This should be avoided.</span></span> <span data-ttu-id="816ec-372">Consultez les types suivants.</span><span class="sxs-lookup"><span data-stu-id="816ec-372">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="816ec-373">Dans ce cas, une instance de `Marks1` peut être assignée à `testMarks`.</span><span class="sxs-lookup"><span data-stu-id="816ec-373">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="816ec-374">Toutefois, `Marks2` ne doit pas être utilisé car son contrat de données n'est pas considéré équivalent au contrat de données `IList<int>` .</span><span class="sxs-lookup"><span data-stu-id="816ec-374">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="816ec-375">Le nom du contrat de données est « marks2 » et non « ArrayOfint », et le nom de l’élément répétitif est « \<mark> » et non «» \<int> .</span><span class="sxs-lookup"><span data-stu-id="816ec-375">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="816ec-376">Les règles indiquées dans le tableau ci-dessous s'appliquent à l'assignation polymorphe de collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-376">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="816ec-377">Type déclaré</span><span class="sxs-lookup"><span data-stu-id="816ec-377">Declared type</span></span>|<span data-ttu-id="816ec-378">Assignation d'une collection non personnalisée</span><span class="sxs-lookup"><span data-stu-id="816ec-378">Assigning a non-customized collection</span></span>|<span data-ttu-id="816ec-379">Assignation d'une collection personnalisée</span><span class="sxs-lookup"><span data-stu-id="816ec-379">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="816ec-380">Object</span><span class="sxs-lookup"><span data-stu-id="816ec-380">Object</span></span>|<span data-ttu-id="816ec-381">Le nom de contrat est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="816ec-381">Contract name is serialized.</span></span>|<span data-ttu-id="816ec-382">Le nom de contrat est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="816ec-382">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="816ec-383">La personnalisation est utilisée.</span><span class="sxs-lookup"><span data-stu-id="816ec-383">Customization is used.</span></span>|
|<span data-ttu-id="816ec-384">Interface de collection</span><span class="sxs-lookup"><span data-stu-id="816ec-384">Collection interface</span></span>|<span data-ttu-id="816ec-385">Le nom de contrat n'est pas sérialisé.</span><span class="sxs-lookup"><span data-stu-id="816ec-385">Contract name is not serialized.</span></span>|<span data-ttu-id="816ec-386">Le nom de contrat n'est pas sérialisé.</span><span class="sxs-lookup"><span data-stu-id="816ec-386">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="816ec-387">La personnalisation n’est pas utilisée.\*</span><span class="sxs-lookup"><span data-stu-id="816ec-387">Customization is not used.\*</span></span>|
|<span data-ttu-id="816ec-388">Collection non personnalisée</span><span class="sxs-lookup"><span data-stu-id="816ec-388">Non-customized collection</span></span>|<span data-ttu-id="816ec-389">Le nom de contrat n'est pas sérialisé.</span><span class="sxs-lookup"><span data-stu-id="816ec-389">Contract name is not serialized.</span></span>|<span data-ttu-id="816ec-390">Le nom de contrat est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="816ec-390">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="816ec-391">La personnalisation est utilisée.\*\*</span><span class="sxs-lookup"><span data-stu-id="816ec-391">Customization is used.\*\*</span></span>|
|<span data-ttu-id="816ec-392">Collection personnalisée</span><span class="sxs-lookup"><span data-stu-id="816ec-392">Customized collection</span></span>|<span data-ttu-id="816ec-393">Le nom de contrat est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="816ec-393">Contract name is serialized.</span></span> <span data-ttu-id="816ec-394">La personnalisation n’est pas utilisée.\*\*</span><span class="sxs-lookup"><span data-stu-id="816ec-394">Customization is not used.\*\*</span></span>|<span data-ttu-id="816ec-395">Le nom de contrat est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="816ec-395">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="816ec-396">La personnalisation du type assigné est utilisée.\*\*</span><span class="sxs-lookup"><span data-stu-id="816ec-396">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="816ec-397">\*Avec la <xref:System.Runtime.Serialization.NetDataContractSerializer> classe, la personnalisation est utilisée dans ce cas.</span><span class="sxs-lookup"><span data-stu-id="816ec-397">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="816ec-398">La classe <xref:System.Runtime.Serialization.NetDataContractSerializer> sérialise également le nom de type réel dans ce cas, si bien que la désérialisation fonctionne comme prévu.</span><span class="sxs-lookup"><span data-stu-id="816ec-398">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="816ec-399">\*\*Ces cas entraînent des instances de schéma non valides et doivent donc être évitées.</span><span class="sxs-lookup"><span data-stu-id="816ec-399">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="816ec-400">Dans les cas où le nom de contrat est sérialisé, le type de collection assigné doit figurer dans la liste des types connus.</span><span class="sxs-lookup"><span data-stu-id="816ec-400">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="816ec-401">Le contraire est également vrai : dans les cas où le nom n'est pas sérialisé, l'ajout du type dans la liste des types connus n'est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="816ec-401">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="816ec-402">Un tableau d'un type dérivé peut être assigné à un tableau d'un type de base.</span><span class="sxs-lookup"><span data-stu-id="816ec-402">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="816ec-403">Dans ce cas, le nom de contrat pour le type dérivé est sérialisé pour chaque élément répétitif.</span><span class="sxs-lookup"><span data-stu-id="816ec-403">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="816ec-404">Par exemple, si un type `Book` dérive du type `LibraryItem`, vous pouvez assigner un tableau d'éléments `Book` à un tableau d'éléments `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="816ec-404">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="816ec-405">Cela ne s'applique pas aux autres types de collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-405">This does not apply to other collection types.</span></span> <span data-ttu-id="816ec-406">Par exemple, vous ne pouvez pas assigner une `Generic List of Book` à une `Generic List of LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="816ec-406">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="816ec-407">Toutefois, vous pouvez assigner une `Generic List of LibraryItem` qui contient des instances `Book` .</span><span class="sxs-lookup"><span data-stu-id="816ec-407">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="816ec-408">Dans les deux cas avec tableau et sans tableau, `Book` doit figurer dans la liste des types connus.</span><span class="sxs-lookup"><span data-stu-id="816ec-408">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="816ec-409">Collections et conservation des références aux objets</span><span class="sxs-lookup"><span data-stu-id="816ec-409">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="816ec-410">Lorsqu'un sérialiseur fonctionne dans un mode où il conserve les références aux objets, la conservation des références aux objets s'applique également aux collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-410">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="816ec-411">Spécifiquement, l'identité des objets est conservée à la fois pour les collections entières et pour les éléments individuels inclus dans les collections.</span><span class="sxs-lookup"><span data-stu-id="816ec-411">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="816ec-412">Pour les dictionnaires, l'identité des objets est conservée à la fois pour les objets paire clé/valeur et pour les objets clé et valeur individuels.</span><span class="sxs-lookup"><span data-stu-id="816ec-412">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="816ec-413">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="816ec-413">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
