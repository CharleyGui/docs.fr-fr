---
title: Considérations sur la sécurité des données
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 530bb54936f97f1d7460d63cfa316c760cbd449d
ms.sourcegitcommit: 2543a78be6e246aa010a01decf58889de53d1636
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/17/2020
ms.locfileid: "86441815"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="23e8f-102">Considérations sur la sécurité des données</span><span class="sxs-lookup"><span data-stu-id="23e8f-102">Security Considerations for Data</span></span>

<span data-ttu-id="23e8f-103">Lorsque vous traitez des données dans Windows Communication Foundation (WCF), vous devez prendre en compte un certain nombre de catégories de menaces.</span><span class="sxs-lookup"><span data-stu-id="23e8f-103">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="23e8f-104">Le tableau suivant répertorie les classes de menace les plus importantes concernant le traitement de données.</span><span class="sxs-lookup"><span data-stu-id="23e8f-104">The following table lists the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="23e8f-105">WCF fournit des outils pour atténuer ces menaces.</span><span class="sxs-lookup"><span data-stu-id="23e8f-105">WCF provides tools to mitigate these threats.</span></span>

<span data-ttu-id="23e8f-106">Déni de service lors de la réception de données non fiables, les données peuvent amener le côté réception à accéder à une quantité disproportionnée de diverses ressources, telles que la mémoire, les threads, les connexions disponibles ou les cycles de processeur, en provoquant des calculs de longue durée.</span><span class="sxs-lookup"><span data-stu-id="23e8f-106">Denial of service When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="23e8f-107">Une attaque par déni de service contre un serveur peut engendrer son blocage et son incapacité à traiter les messages en provenance d'autres clients légitimes.</span><span class="sxs-lookup"><span data-stu-id="23e8f-107">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

<span data-ttu-id="23e8f-108">L’exécution de code malveillant des données non fiables entrantes provoque l’exécution par le côté réception du code qu’il n’avait pas prévu.</span><span class="sxs-lookup"><span data-stu-id="23e8f-108">Malicious code execution Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

<span data-ttu-id="23e8f-109">Divulgation d’informations : l’attaquant distant force le tiers destinataire à répondre à ses demandes de manière à divulguer plus d’informations que prévu.</span><span class="sxs-lookup"><span data-stu-id="23e8f-109">Information disclosure The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="23e8f-110">Code fourni par l'utilisateur et sécurité d'accès du code</span><span class="sxs-lookup"><span data-stu-id="23e8f-110">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="23e8f-111">Un certain nombre d’emplacements dans l’infrastructure Windows Communication Foundation (WCF) exécutent du code fourni par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="23e8f-111">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="23e8f-112">Par exemple, le moteur de sérialisation <xref:System.Runtime.Serialization.DataContractSerializer> peut appeler des accesseurs `set` de propriété fournis par l'utilisateur et des accesseurs `get` .</span><span class="sxs-lookup"><span data-stu-id="23e8f-112">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="23e8f-113">L’infrastructure de canal WCF peut également appeler des classes dérivées fournies par l’utilisateur de la <xref:System.ServiceModel.Channels.Message> classe.</span><span class="sxs-lookup"><span data-stu-id="23e8f-113">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="23e8f-114">Il incombe à l'auteur du code de garantir qu'aucune faille de sécurité n'existe.</span><span class="sxs-lookup"><span data-stu-id="23e8f-114">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="23e8f-115">Par exemple, si vous créez un type de contrat de données avec une propriété de membre de données de type entier, et que dans l'implémentation de l'accesseur `set` vous allouez un tableau en fonction de la valeur de la propriété, vous risquez une attaque par déni de service si un message malveillant contient une valeur extrêmement élevée pour ce membre.</span><span class="sxs-lookup"><span data-stu-id="23e8f-115">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="23e8f-116">En général, évitez toutes les allocations basées sur des données entrantes ou un long traitement dans le code fourni par l'utilisateur (surtout si ce long traitement peut être provoqué par une petite quantité de données entrantes).</span><span class="sxs-lookup"><span data-stu-id="23e8f-116">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="23e8f-117">Lorsque vous exécutez une analyse de sécurité du code fourni par l'utilisateur, assurez-vous de considérer également tous les cas d'échec (c'est-à-dire, toutes les branches de code où des exceptions sont levées).</span><span class="sxs-lookup"><span data-stu-id="23e8f-117">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="23e8f-118">Le dernier exemple de code fourni par l'utilisateur correspond au code figurant à l'intérieur de votre implémentation de service pour chaque opération.</span><span class="sxs-lookup"><span data-stu-id="23e8f-118">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="23e8f-119">La sécurité de votre implémentation de service relève de votre responsabilité.</span><span class="sxs-lookup"><span data-stu-id="23e8f-119">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="23e8f-120">Il est facile de créer par inadvertance des implémentations d'opérations incertaines qui peuvent provoquer des vulnérabilités au déni de service.</span><span class="sxs-lookup"><span data-stu-id="23e8f-120">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="23e8f-121">Par exemple, une opération qui prend une chaîne et renvoie la liste des clients d'une base de données dont le nom commence par cette chaîne.</span><span class="sxs-lookup"><span data-stu-id="23e8f-121">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="23e8f-122">Si vous utilisez une base de données volumineuse et que la chaîne passée comporte une seule lettre, votre code risque d'essayer de créer un message plus volumineux que toute la mémoire disponible, ce qui entraîne l'échec du service entier.</span><span class="sxs-lookup"><span data-stu-id="23e8f-122">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="23e8f-123">(Un <xref:System.OutOfMemoryException> n’est pas récupérable dans le .NET Framework et entraîne toujours l’arrêt de votre application.)</span><span class="sxs-lookup"><span data-stu-id="23e8f-123">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="23e8f-124">Vous devez garantir qu'aucun code malveillant n'est intégré dans les divers points d'extensibilité.</span><span class="sxs-lookup"><span data-stu-id="23e8f-124">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="23e8f-125">Cela est particulièrement vrai pour l'exécution en confiance partielle, pour le traitement des types issus d'assemblys d'un niveau de confiance partiel ou pour créer des composants utilisables par un code de niveau de confiance partiel.</span><span class="sxs-lookup"><span data-stu-id="23e8f-125">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="23e8f-126">Pour plus d'informations, consultez « Menaces liées à une confiance partielle » dans une section ultérieure.</span><span class="sxs-lookup"><span data-stu-id="23e8f-126">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="23e8f-127">Notez que lors de l'exécution en confiance partielle, l'infrastructure de sérialisation de contrat de données prend en charge uniquement un sous-ensemble limité du modèle de programmation de contrat de données, par exemple, des types ou des membres de données privés qui utilisent l'attribut <xref:System.SerializableAttribute> ne sont pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="23e8f-127">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="23e8f-128">Pour plus d’informations, consultez [confiance partielle](partial-trust.md).</span><span class="sxs-lookup"><span data-stu-id="23e8f-128">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="23e8f-129">Éviter la divulgation d'informations involontaire</span><span class="sxs-lookup"><span data-stu-id="23e8f-129">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="23e8f-130">Dans le cadre de la conception de types sérialisables en gardant la sécurité à l'esprit, la divulgation d'informations est une préoccupation possible.</span><span class="sxs-lookup"><span data-stu-id="23e8f-130">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="23e8f-131">Observez les points suivants :</span><span class="sxs-lookup"><span data-stu-id="23e8f-131">Consider the following points:</span></span>

- <span data-ttu-id="23e8f-132">Le modèle de programmation <xref:System.Runtime.Serialization.DataContractSerializer> autorise l'exposition de données privées et internes en dehors du type ou assembly pendant la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-132">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="23e8f-133">En outre, la forme d'un type peut être exposée pendant l'exportation de schéma.</span><span class="sxs-lookup"><span data-stu-id="23e8f-133">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="23e8f-134">Veillez à comprendre la projection de sérialisation de votre type.</span><span class="sxs-lookup"><span data-stu-id="23e8f-134">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="23e8f-135">Si vous souhaitez que rien ne soit exposé, désactivez-en la sérialisation (par exemple, en n'appliquant pas l'attribut <xref:System.Runtime.Serialization.DataMemberAttribute> dans le cas d'un contrat de données).</span><span class="sxs-lookup"><span data-stu-id="23e8f-135">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="23e8f-136">Soyez conscient que le même type peut avoir plusieurs projections de sérialisation, selon le sérialiseur utilisé.</span><span class="sxs-lookup"><span data-stu-id="23e8f-136">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="23e8f-137">Le même type peut exposer un jeu de données lorsqu'il est utilisé avec <xref:System.Runtime.Serialization.DataContractSerializer> et un autre jeu de données lorsqu'il est utilisé avec <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-137">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="23e8f-138">Une utilisation accidentelle du mauvais sérialiseur peut entraîner une divulgation d'informations.</span><span class="sxs-lookup"><span data-stu-id="23e8f-138">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="23e8f-139">L'utilisation de <xref:System.Xml.Serialization.XmlSerializer> en mode d'appel de procédure distante (RPC)/encodé hérité peut exposer involontairement la forme du graphique d'objets située sur le côté envoi au côté réception.</span><span class="sxs-lookup"><span data-stu-id="23e8f-139">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="23e8f-140">Prévention des attaques par déni de service</span><span class="sxs-lookup"><span data-stu-id="23e8f-140">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="23e8f-141">Quotas</span><span class="sxs-lookup"><span data-stu-id="23e8f-141">Quotas</span></span>

<span data-ttu-id="23e8f-142">Entraîner le côté réception à allouer une quantité de mémoire importante constitue une attaque par déni de service potentielle.</span><span class="sxs-lookup"><span data-stu-id="23e8f-142">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="23e8f-143">Alors que cette section se concentre sur les problèmes de consommation de mémoire provenant de messages volumineux, d'autres attaques peuvent se produire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-143">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="23e8f-144">Par exemple, les messages peuvent utiliser une quantité disproportionnée de temps de traitement.</span><span class="sxs-lookup"><span data-stu-id="23e8f-144">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="23e8f-145">Les attaques par déni de service sont habituellement atténuées à l'aide de quotas.</span><span class="sxs-lookup"><span data-stu-id="23e8f-145">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="23e8f-146">Lorsqu'un quota est dépassé, une exception <xref:System.ServiceModel.QuotaExceededException> est normalement levée.</span><span class="sxs-lookup"><span data-stu-id="23e8f-146">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="23e8f-147">Sans le quota, un message malveillant peut provoquer l'accès à toute la mémoire disponible, ce qui engendre une exception <xref:System.OutOfMemoryException> , ou l'accès à toutes les piles disponibles, ce qui engendre une <xref:System.StackOverflowException>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-147">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="23e8f-148">Le scénario du dépassement de quota est récupérable ; s'il se produit dans un service en cours d'exécution, le message en cours de traitement est ignoré et le service continue à s'exécuter et traite d'autres messages.</span><span class="sxs-lookup"><span data-stu-id="23e8f-148">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="23e8f-149">Toutefois, les scénarios de mémoire insuffisante et de dépassement de capacité de la pile ne sont pas récupérables dans le .NET Framework ; le service s’arrête s’il rencontre de telles exceptions.</span><span class="sxs-lookup"><span data-stu-id="23e8f-149">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="23e8f-150">Dans WCF, les quotas n’impliquent pas de pré-allocation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-150">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="23e8f-151">Par exemple, si le quota <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> (existant sur différentes classes) a la valeur 128 Ko, cela ne signifie pas que 128 Ko sont automatiquement alloués pour chaque message.</span><span class="sxs-lookup"><span data-stu-id="23e8f-151">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="23e8f-152">La quantité réelle allouée dépend de la taille réelle du message entrant.</span><span class="sxs-lookup"><span data-stu-id="23e8f-152">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="23e8f-153">De nombreux quotas sont disponibles au niveau de la couche transport.</span><span class="sxs-lookup"><span data-stu-id="23e8f-153">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="23e8f-154">Il s'agit de quotas appliqués par le canal de transport spécifique en cours d'utilisation (HTTP, TCP, et ainsi de suite).</span><span class="sxs-lookup"><span data-stu-id="23e8f-154">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="23e8f-155">Même si cette rubrique présente une partie de ces quotas, ceux-ci sont décrits de manière détaillée dans [Transport Quotas](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="23e8f-155">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="23e8f-156">Vulnérabilité de table de hachage</span><span class="sxs-lookup"><span data-stu-id="23e8f-156">Hashtable Vulnerability</span></span>

<span data-ttu-id="23e8f-157">Il existe une vulnérabilité lorsque les contrats de données contiennent des tables de hachage ou des collections.</span><span class="sxs-lookup"><span data-stu-id="23e8f-157">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="23e8f-158">Ce problème se pose si un grand nombre de valeurs sont insérées dans une table de hachage où un grand nombre de ces valeurs génèrent la même valeur de hachage.</span><span class="sxs-lookup"><span data-stu-id="23e8f-158">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="23e8f-159">Cela peut être utilisé comme attaque par déni de service.</span><span class="sxs-lookup"><span data-stu-id="23e8f-159">This can be used as a DOS attack.</span></span>  <span data-ttu-id="23e8f-160">Cette vulnérabilité peut être atténuée en définissant le quota de liaison MaxReceivedMessageSize.</span><span class="sxs-lookup"><span data-stu-id="23e8f-160">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="23e8f-161">La prudence est de mise lors de la définition de ce quota, de façon à empêcher de telles attaques.</span><span class="sxs-lookup"><span data-stu-id="23e8f-161">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="23e8f-162">Ce quota spécifie une limite supérieure pour la taille du message WCF.</span><span class="sxs-lookup"><span data-stu-id="23e8f-162">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="23e8f-163">En outre, évitez d'utiliser des tables de hachage ou des collections dans les contrats de données.</span><span class="sxs-lookup"><span data-stu-id="23e8f-163">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="23e8f-164">Limitation de la consommation de mémoire sans la diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="23e8f-164">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="23e8f-165">Le modèle de sécurité lié aux messages volumineux dépend de l'utilisation de la diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="23e8f-165">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="23e8f-166">Dans le cas simple de la non-diffusion en continu, les messages sont mis en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="23e8f-166">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="23e8f-167">Dans ce cas, utilisez le quota <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> sur <xref:System.ServiceModel.Channels.TransportBindingElement> ou sur les liaisons fournies par le système à des fins de protection contre les messages volumineux en limitant la taille maximale des messages auxquels accéder.</span><span class="sxs-lookup"><span data-stu-id="23e8f-167">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="23e8f-168">Notez qu'un service peut traiter plusieurs messages en même temps. Dans ce cas, ils sont tous en mémoire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-168">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="23e8f-169">Utilisez la fonctionnalité de limitation pour atténuer cette menace.</span><span class="sxs-lookup"><span data-stu-id="23e8f-169">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="23e8f-170">Notez également que `MaxReceivedMessageSize` n'impose pas de limite supérieure à la consommation de mémoire par message, mais la restreint à un facteur constant.</span><span class="sxs-lookup"><span data-stu-id="23e8f-170">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="23e8f-171">Par exemple, si `MaxReceivedMessageSize` s'élève à 1 Mo et qu'un message de 1 Mo est reçu puis désérialisé, de la mémoire supplémentaire est nécessaire pour contenir le graphique d'objets désérialisé, ce qui engendre une consommation de mémoire totale bien supérieure à 1 Mo.</span><span class="sxs-lookup"><span data-stu-id="23e8f-171">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="23e8f-172">Pour cette raison, évitez de créer des types sérialisables qui pourraient provoquer une consommation de mémoire importante sans beaucoup de données entrantes.</span><span class="sxs-lookup"><span data-stu-id="23e8f-172">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="23e8f-173">Par exemple, un contrat de données « MonContrat » avec 50 champs de données membres facultatifs et un 100 de champs privés supplémentaires pourraient être instanciés avec la construction XML « \<MyContract/> ».</span><span class="sxs-lookup"><span data-stu-id="23e8f-173">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="23e8f-174">Ce XML provoque un accès de la mémoire pour 150 champs.</span><span class="sxs-lookup"><span data-stu-id="23e8f-174">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="23e8f-175">Notez que les membres de données sont facultatifs par défaut.</span><span class="sxs-lookup"><span data-stu-id="23e8f-175">Note that data members are optional by default.</span></span> <span data-ttu-id="23e8f-176">Le problème est aggravé lorsqu'un tel type fait partie d'un tableau.</span><span class="sxs-lookup"><span data-stu-id="23e8f-176">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="23e8f-177">`MaxReceivedMessageSize` uniquement ne suffit pas à empêcher toutes les attaques par déni de service.</span><span class="sxs-lookup"><span data-stu-id="23e8f-177">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="23e8f-178">Par exemple, le désérialiseur peut être forcé à désérialiser un graphique d'objets très imbriqué (un objet qui contient un autre objet qui en contient encore un autre, et ainsi de suite) par un message entrant.</span><span class="sxs-lookup"><span data-stu-id="23e8f-178">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="23e8f-179"><xref:System.Runtime.Serialization.DataContractSerializer> et <xref:System.Xml.Serialization.XmlSerializer> appellent des méthodes d'une manière imbriquée pour désérialiser de tels graphiques.</span><span class="sxs-lookup"><span data-stu-id="23e8f-179">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="23e8f-180">L'imbrication profonde des appels de méthode peut provoquer une <xref:System.StackOverflowException>irrécupérable.</span><span class="sxs-lookup"><span data-stu-id="23e8f-180">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="23e8f-181">Cette menace est atténuée en définissant le quota <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> de sorte à limiter le niveau d'imbrication XML, comme indiqué dans la section « Utilisation du XML en toute sécurité » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="23e8f-181">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="23e8f-182">L'affectation de la valeur `MaxReceivedMessageSize` à des quotas supplémentaires s'avère particulièrement importante lors de l'utilisation de l'encodage XML binaire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-182">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="23e8f-183">L'utilisation de l'encodage binaire équivaut presque à la compression : un petit groupe d'octets dans le message entrant peut représenter beaucoup de données.</span><span class="sxs-lookup"><span data-stu-id="23e8f-183">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="23e8f-184">Ainsi, même un message qui respecte la limite `MaxReceivedMessageSize` peut consommer beaucoup plus de mémoire dans sa forme complètement développée.</span><span class="sxs-lookup"><span data-stu-id="23e8f-184">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="23e8f-185">Pour atténuer de telles menaces propres au XML, tous les quotas de lecteur XML doivent être définis correctement, comme indiqué dans la section « Utilisation du XML en toute sécurité » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="23e8f-185">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="23e8f-186">Limitation de la consommation de mémoire avec la diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="23e8f-186">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="23e8f-187">Dans le cadre de la diffusion en continu, vous pouvez utiliser un petit paramètre `MaxReceivedMessageSize` à des fins de protection contre les attaques par déni de service.</span><span class="sxs-lookup"><span data-stu-id="23e8f-187">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="23e8f-188">Toutefois, des scénarios plus compliqués sont possibles avec la diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="23e8f-188">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="23e8f-189">Par exemple, un service de téléchargement de fichiers accepte des fichiers plus volumineux que toute la mémoire disponible.</span><span class="sxs-lookup"><span data-stu-id="23e8f-189">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="23e8f-190">Dans ce cas, affectez à `MaxReceivedMessageSize` une valeur extrêmement élevée, en pensant que quasiment aucune donnée n'est mise en mémoire tampon et que le message se diffuse en continu directement sur le disque.</span><span class="sxs-lookup"><span data-stu-id="23e8f-190">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="23e8f-191">Si un message malveillant peut forcer WCF à mettre en mémoire tampon des données au lieu de le diffuser dans ce cas, `MaxReceivedMessageSize` ne protège plus le message qui accède à toute la mémoire disponible.</span><span class="sxs-lookup"><span data-stu-id="23e8f-191">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="23e8f-192">Pour atténuer cette menace, des paramètres de quota spécifiques existent sur différents composants de traitement de données WCF qui limitent la mise en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="23e8f-192">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="23e8f-193">Le plus important de ces quotas est la propriété `MaxBufferSize` sur différents éléments de liaison de transport et liaisons standard.</span><span class="sxs-lookup"><span data-stu-id="23e8f-193">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="23e8f-194">Dans le cadre de la diffusion en continu, ce quota doit être défini en tenant compte de la quantité de mémoire maximale que vous êtes disposé à allouer par message.</span><span class="sxs-lookup"><span data-stu-id="23e8f-194">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="23e8f-195">Comme avec `MaxReceivedMessageSize`, le paramètre n'impose pas de maximum absolu à la consommation de mémoire mais il la limite à un facteur constant.</span><span class="sxs-lookup"><span data-stu-id="23e8f-195">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="23e8f-196">En outre, comme avec `MaxReceivedMessageSize`, soyez conscient de la possibilité de traiter plusieurs messages en même temps.</span><span class="sxs-lookup"><span data-stu-id="23e8f-196">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="23e8f-197">Détails sur MaxBufferSize</span><span class="sxs-lookup"><span data-stu-id="23e8f-197">MaxBufferSize Details</span></span>

<span data-ttu-id="23e8f-198">La `MaxBufferSize` propriété limite la mise en mémoire tampon en bloc WCF.</span><span class="sxs-lookup"><span data-stu-id="23e8f-198">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="23e8f-199">Par exemple, WCF met toujours en mémoire tampon les en-têtes SOAP et les erreurs SOAP, ainsi que toutes les parties MIME qui ne sont pas dans l’ordre de lecture naturel dans un message MTOM (Message Transmission Optimization Mechanism).</span><span class="sxs-lookup"><span data-stu-id="23e8f-199">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="23e8f-200">Ce paramètre limite la quantité de mise en mémoire tampon dans tous ces cas.</span><span class="sxs-lookup"><span data-stu-id="23e8f-200">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="23e8f-201">WCF effectue cette opération en passant la `MaxBufferSize` valeur aux divers composants qui peuvent être mis en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="23e8f-201">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="23e8f-202">Par exemple, certaines surcharges <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> de la classe <xref:System.ServiceModel.Channels.Message> acceptent un paramètre `maxSizeOfHeaders` .</span><span class="sxs-lookup"><span data-stu-id="23e8f-202">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="23e8f-203">WCF passe la `MaxBufferSize` valeur à ce paramètre pour limiter la quantité de mise en mémoire tampon d’en-tête SOAP.</span><span class="sxs-lookup"><span data-stu-id="23e8f-203">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="23e8f-204">Il est important de définir ce paramètre lors de l'utilisation directe de la classe <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="23e8f-204">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="23e8f-205">En général, lors de l’utilisation d’un composant dans WCF qui prend des paramètres de quota, il est important de comprendre les implications en matière de sécurité de ces paramètres et de les définir correctement.</span><span class="sxs-lookup"><span data-stu-id="23e8f-205">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="23e8f-206">L'encodeur de message MTOM possède également un paramètre `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="23e8f-206">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="23e8f-207">Lorsque vous utilisez des liaisons standard, la valeur `MaxBufferSize` au niveau du transport est automatiquement affectée à ce paramètre.</span><span class="sxs-lookup"><span data-stu-id="23e8f-207">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="23e8f-208">Toutefois, lorsque vous utilisez l'élément de la liaison de l'encodeur de message MTOM pour construire une liaison personnalisée, il est important d'affecter à la propriété `MaxBufferSize` une valeur sûre lorsque la diffusion en continu est utilisée.</span><span class="sxs-lookup"><span data-stu-id="23e8f-208">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="23e8f-209">Attaques de diffusion en continu basées sur XML</span><span class="sxs-lookup"><span data-stu-id="23e8f-209">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="23e8f-210">`MaxBufferSize`seul n’est pas suffisant pour s’assurer que WCF ne peut pas être forcé dans la mise en mémoire tampon lorsque la diffusion en continu est attendue.</span><span class="sxs-lookup"><span data-stu-id="23e8f-210">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="23e8f-211">Par exemple, les lecteurs XML WCF met toujours en mémoire tampon l’intégralité de la balise de début de l’élément XML lors du démarrage de la lecture d’un nouvel élément.</span><span class="sxs-lookup"><span data-stu-id="23e8f-211">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="23e8f-212">Cette mise en mémoire tampon permet de traiter correctement les espaces de noms et les attributs.</span><span class="sxs-lookup"><span data-stu-id="23e8f-212">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="23e8f-213">Si le paramètre `MaxReceivedMessageSize` est configuré afin d'être élevé (par exemple, pour permettre un scénario de diffusion en continu d'un fichier volumineux directement sur le disque), un message malveillant peut être construit dans lequel le corps du message entier est une balise de début d'élément XML volumineuse.</span><span class="sxs-lookup"><span data-stu-id="23e8f-213">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="23e8f-214">Une tentative de le lire provoque une <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-214">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="23e8f-215">Il s’agit de l’une des nombreuses attaques par déni de service XML possibles qui peuvent toutes être atténuées à l’aide de quotas de lecteur XML, abordés dans la section « utilisation du XML en toute sécurité » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="23e8f-215">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="23e8f-216">Dans le cadre de la diffusion en continu, il s'avère particulièrement important de définir tous ces quotas.</span><span class="sxs-lookup"><span data-stu-id="23e8f-216">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="23e8f-217">Combinaison des modèles de programmation de diffusion en continu et de mise en mémoire tampon</span><span class="sxs-lookup"><span data-stu-id="23e8f-217">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="23e8f-218">De nombreuses attaques possibles émanent du mélange de modèles de programmation de diffusion en continu et de non-diffusion en continu dans le même service.</span><span class="sxs-lookup"><span data-stu-id="23e8f-218">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="23e8f-219">Supposez qu'il existe un contrat de service contenant deux opérations : une qui prend un <xref:System.IO.Stream> et une autre qui prend un tableau de type personnalisé.</span><span class="sxs-lookup"><span data-stu-id="23e8f-219">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="23e8f-220">Supposez également qu'une valeur élevée est affectée à `MaxReceivedMessageSize` pour permettre à la première opération de traiter des flux volumineux.</span><span class="sxs-lookup"><span data-stu-id="23e8f-220">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="23e8f-221">Malheureusement, cela signifie que des messages volumineux peuvent à présent être envoyés à la seconde opération, et que le désérialiseur met en mémoire tampon des données sous la forme d'un tableau avant d'appeler l'opération.</span><span class="sxs-lookup"><span data-stu-id="23e8f-221">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="23e8f-222">Il s'agit d'une attaque par déni de service potentielle : le quota `MaxBufferSize` ne limite pas la taille du corps du message, avec laquelle le désérialiseur fonctionne.</span><span class="sxs-lookup"><span data-stu-id="23e8f-222">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="23e8f-223">Pour cette raison, évitez de combiner des opérations de diffusion et des opérations non diffusées dans le même contrat.</span><span class="sxs-lookup"><span data-stu-id="23e8f-223">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="23e8f-224">Si vous devez absolument associer les deux modèles de programmation, prenez les précautions suivantes :</span><span class="sxs-lookup"><span data-stu-id="23e8f-224">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="23e8f-225">Désactivez la fonctionnalité <xref:System.Runtime.Serialization.IExtensibleDataObject> en affectant à la propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> de <xref:System.ServiceModel.ServiceBehaviorAttribute> la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="23e8f-225">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="23e8f-226">Cette désactivation permet de veiller à ce que seuls les membres qui font partie du contrat soient désérialisés.</span><span class="sxs-lookup"><span data-stu-id="23e8f-226">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="23e8f-227">Affectez à la propriété <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> de <xref:System.Runtime.Serialization.DataContractSerializer> une valeur sûre.</span><span class="sxs-lookup"><span data-stu-id="23e8f-227">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="23e8f-228">Ce quota est également disponible sur l'attribut <xref:System.ServiceModel.ServiceBehaviorAttribute> ou via la configuration.</span><span class="sxs-lookup"><span data-stu-id="23e8f-228">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="23e8f-229">Ce quota limite le nombre d'objets désérialisés au cours d'un épisode de désérialisation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-229">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="23e8f-230">Normalement, chaque paramètre d'opération ou partie de corps du message dans un contrat de message sont désérialisés dans un seul épisode.</span><span class="sxs-lookup"><span data-stu-id="23e8f-230">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="23e8f-231">Lors de la désérialisation de tableaux, chaque entrée de tableau est comptée comme un objet distinct.</span><span class="sxs-lookup"><span data-stu-id="23e8f-231">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="23e8f-232">Affectez à tous les quotas de lecteurs XML des valeurs sûres.</span><span class="sxs-lookup"><span data-stu-id="23e8f-232">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="23e8f-233">Faites attention à <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>et <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> et évitez les chaînes dans les opérations de non-diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="23e8f-233">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="23e8f-234">Consultez la liste des types connus, en n'oubliant pas que l'un d'eux peut être instancié à tout moment (consultez la section « Prévention du chargement de types involontaires » plus loin dans cette rubrique).</span><span class="sxs-lookup"><span data-stu-id="23e8f-234">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="23e8f-235">N'utilisez pas les types qui implémentent l'interface <xref:System.Xml.Serialization.IXmlSerializable> qui met beaucoup de données en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="23e8f-235">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="23e8f-236">N'ajoutez pas de tels types à la liste des types connus.</span><span class="sxs-lookup"><span data-stu-id="23e8f-236">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="23e8f-237">N'utilisez pas les tableaux <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> , <xref:System.Byte> ou des types qui implémentent <xref:System.Runtime.Serialization.ISerializable> dans un contrat.</span><span class="sxs-lookup"><span data-stu-id="23e8f-237">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="23e8f-238">N'utilisez pas les tableaux <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> , <xref:System.Byte> ou des types qui implémentent <xref:System.Runtime.Serialization.ISerializable> dans la liste des types connus.</span><span class="sxs-lookup"><span data-stu-id="23e8f-238">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="23e8f-239">Les précautions précédentes s'appliquent lorsque l'opération de non-diffusion en continu utilise <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-239">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="23e8f-240">Ne mélangez jamais les modèles de programmation de diffusion en continu et de non-diffusion en continu sur le même service si vous utilisez <xref:System.Xml.Serialization.XmlSerializer>, parce qu'il ne possède pas la protection du quota <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> .</span><span class="sxs-lookup"><span data-stu-id="23e8f-240">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="23e8f-241">Attaques de flux lent</span><span class="sxs-lookup"><span data-stu-id="23e8f-241">Slow Stream Attacks</span></span>

<span data-ttu-id="23e8f-242">Une classe d'attaques par déni de service de diffusion en continu n'implique pas la consommation de mémoire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-242">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="23e8f-243">Cette attaque implique plutôt un expéditeur ou destinataire lent des données.</span><span class="sxs-lookup"><span data-stu-id="23e8f-243">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="23e8f-244">En attendant que les données soient envoyées ou reçues, des ressources telles que des threads et des connexions disponibles s'épuisent.</span><span class="sxs-lookup"><span data-stu-id="23e8f-244">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="23e8f-245">Cette situation peut survenir soit à la suite d'une attaque malveillante, soit à partir d'un expéditeur/destinataire légitime sur une connexion réseau lente.</span><span class="sxs-lookup"><span data-stu-id="23e8f-245">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="23e8f-246">Pour réduire ces attaques, définissez correctement les délais d'attente de transport.</span><span class="sxs-lookup"><span data-stu-id="23e8f-246">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="23e8f-247">Pour plus d’informations, consultez [quotas de transport](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="23e8f-247">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="23e8f-248">Deuxièmement, n’utilisez jamais `Read` des opérations synchrones ou `Write` lorsque vous utilisez des flux dans WCF.</span><span class="sxs-lookup"><span data-stu-id="23e8f-248">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="23e8f-249">Utilisation du XML en toute sécurité</span><span class="sxs-lookup"><span data-stu-id="23e8f-249">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="23e8f-250">Même si cette section est consacrée au XML, les informations s'appliquent aussi aux documents JSON (JavaScript Object Notation).</span><span class="sxs-lookup"><span data-stu-id="23e8f-250">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="23e8f-251">Les quotas fonctionnent de manière identique et utilisent [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="23e8f-251">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="23e8f-252">Lecteurs XML sécurisés</span><span class="sxs-lookup"><span data-stu-id="23e8f-252">Secure XML Readers</span></span>

<span data-ttu-id="23e8f-253">Le jeu d’informations XML forme la base de tout le traitement des messages dans WCF.</span><span class="sxs-lookup"><span data-stu-id="23e8f-253">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="23e8f-254">Lors de l'acceptation de données XML provenant d'une source non fiable, il existe plusieurs possibilités d'attaques par déni de service qu'il convient d'atténuer.</span><span class="sxs-lookup"><span data-stu-id="23e8f-254">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="23e8f-255">WCF fournit des lecteurs XML spécifiques et sécurisés.</span><span class="sxs-lookup"><span data-stu-id="23e8f-255">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="23e8f-256">Ces lecteurs sont créés automatiquement lors de l’utilisation de l’un des encodages standard dans WCF (texte, binaire ou MTOM).</span><span class="sxs-lookup"><span data-stu-id="23e8f-256">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="23e8f-257">Certaines des fonctionnalités de sécurité sur ces lecteurs sont toujours actives.</span><span class="sxs-lookup"><span data-stu-id="23e8f-257">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="23e8f-258">Par exemple, les lecteurs ne traitent jamais les définitions de type de document (DTD), qui constituent une source potentielle d'attaques par déni de service et ne doivent jamais apparaître dans les messages SOAP légitimes.</span><span class="sxs-lookup"><span data-stu-id="23e8f-258">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="23e8f-259">D'autres fonctionnalités de sécurité incluent des quotas de lecteurs à configurer, lesquels sont décrits dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="23e8f-259">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="23e8f-260">Quand vous travaillez directement avec des lecteurs XML (par exemple, lors de l’écriture de votre propre encodeur personnalisé ou lorsque vous travaillez directement avec la <xref:System.ServiceModel.Channels.Message> classe), utilisez toujours les lecteurs sécurisés WCF lorsqu’il existe un risque d’utilisation de données non fiables.</span><span class="sxs-lookup"><span data-stu-id="23e8f-260">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="23e8f-261">Créez les lecteurs sécurisés en appelant l'une des surcharges de méthode de fabrique statique de <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>ou <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> sur la classe <xref:System.Xml.XmlDictionaryReader> .</span><span class="sxs-lookup"><span data-stu-id="23e8f-261">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="23e8f-262">Lorsque vous créez un lecteur, passez des valeurs de quotas sécurisées.</span><span class="sxs-lookup"><span data-stu-id="23e8f-262">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="23e8f-263">N'appelez pas les surcharges de la méthode `Create` .</span><span class="sxs-lookup"><span data-stu-id="23e8f-263">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="23e8f-264">Celles-ci ne créent pas de lecteur WCF.</span><span class="sxs-lookup"><span data-stu-id="23e8f-264">These do not create a WCF reader.</span></span> <span data-ttu-id="23e8f-265">Elles créent un lecteur qui n'est pas protégé par les fonctionnalités de sécurité décrites dans cette section.</span><span class="sxs-lookup"><span data-stu-id="23e8f-265">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="23e8f-266">Quotas de lecteurs</span><span class="sxs-lookup"><span data-stu-id="23e8f-266">Reader Quotas</span></span>

<span data-ttu-id="23e8f-267">Les lecteurs XML sécurisés possèdent cinq quotas configurables.</span><span class="sxs-lookup"><span data-stu-id="23e8f-267">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="23e8f-268">Ceux-ci sont normalement configurés à l'aide de la propriété `ReaderQuotas` sur les éléments de liaison d'encodage ou les liaisons standard, ou encore en utilisant un objet <xref:System.Xml.XmlDictionaryReaderQuotas> passé lors de la création d'un lecteur.</span><span class="sxs-lookup"><span data-stu-id="23e8f-268">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="23e8f-269">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="23e8f-269">MaxBytesPerRead</span></span>

<span data-ttu-id="23e8f-270">Ce quota limite le nombre d'octets lus dans une seule opération `Read` lors de la lecture de la balise de début d'élément et ses attributs.</span><span class="sxs-lookup"><span data-stu-id="23e8f-270">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="23e8f-271">(Dans les cas non diffusés en continu, le nom de l’élément lui-même n’est pas compté dans le quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> est importante pour les raisons suivantes :</span><span class="sxs-lookup"><span data-stu-id="23e8f-271">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="23e8f-272">Le nom de l'élément et ses attributs sont toujours mis en mémoire tampon lorsqu'ils sont lus.</span><span class="sxs-lookup"><span data-stu-id="23e8f-272">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="23e8f-273">Par conséquent, il est important de définir correctement ce quota en mode de diffusion en continu afin d'empêcher une mise en mémoire tampon excessive lorsqu'une diffusion en continu est prévue.</span><span class="sxs-lookup"><span data-stu-id="23e8f-273">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="23e8f-274">Reportez-vous à la section sur les quotas `MaxDepth` ci-dessous pour plus d'informations sur l'importance réelle de la mise en mémoire tampon qui se produit.</span><span class="sxs-lookup"><span data-stu-id="23e8f-274">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="23e8f-275">Un nombre trop élevé d'attributs XML risque d'utiliser un temps de traitement disproportionné parce que le caractère unique des noms d'attributs doit être vérifié.</span><span class="sxs-lookup"><span data-stu-id="23e8f-275">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="23e8f-276">`MaxBytesPerRead` atténue cette menace.</span><span class="sxs-lookup"><span data-stu-id="23e8f-276">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="23e8f-277">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="23e8f-277">MaxDepth</span></span>

<span data-ttu-id="23e8f-278">Ce quota limite la profondeur d'imbrication maximale des éléments XML.</span><span class="sxs-lookup"><span data-stu-id="23e8f-278">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="23e8f-279">Par exemple, le document « \<A> \<B> \<C/> \</B> \</A> » a une profondeur d’imbrication de trois.</span><span class="sxs-lookup"><span data-stu-id="23e8f-279">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="23e8f-280">La propriété<xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> est importante pour les raisons suivantes :</span><span class="sxs-lookup"><span data-stu-id="23e8f-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="23e8f-281">`MaxDepth` interagit avec `MaxBytesPerRead`: le lecteur conserve toujours des données en mémoire pour l'élément actuel et tous ses ancêtres, donc la consommation de mémoire maximale du lecteur est proportionnelle au produit de ces deux paramètres.</span><span class="sxs-lookup"><span data-stu-id="23e8f-281">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="23e8f-282">Lors de la désérialisation d'un graphique d'objets très imbriqué, le désérialiseur est obligé d'accéder à la pile entière et de lever une exception <xref:System.StackOverflowException>irrécupérable.</span><span class="sxs-lookup"><span data-stu-id="23e8f-282">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="23e8f-283">Une corrélation directe existe entre l'imbrication XML et l'imbrication d'objets pour <xref:System.Runtime.Serialization.DataContractSerializer> et <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-283">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="23e8f-284">Utilisez `MaxDepth` pour atténuer cette menace.</span><span class="sxs-lookup"><span data-stu-id="23e8f-284">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="23e8f-285">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="23e8f-285">MaxNameTableCharCount</span></span>

<span data-ttu-id="23e8f-286">Ce quota limite la taille du *nametable*du lecteur.</span><span class="sxs-lookup"><span data-stu-id="23e8f-286">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="23e8f-287">Le nametable contient certaines chaînes (telles que des espaces de noms et des préfixes) rencontrées lors du traitement d'un document XML.</span><span class="sxs-lookup"><span data-stu-id="23e8f-287">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="23e8f-288">Étant donné que ces chaînes sont mises en mémoire tampon, définissez ce quota afin d'empêcher une mise en mémoire tampon excessive lorsqu'une diffusion en continu est prévue.</span><span class="sxs-lookup"><span data-stu-id="23e8f-288">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="23e8f-289">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="23e8f-289">MaxStringContentLength</span></span>

<span data-ttu-id="23e8f-290">Ce quota limite la taille maximale de la chaîne que le lecteur XML renvoie.</span><span class="sxs-lookup"><span data-stu-id="23e8f-290">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="23e8f-291">Ce quota ne limite pas la consommation de mémoire dans le lecteur XML lui-même, mais dans le composant qui utilise le lecteur.</span><span class="sxs-lookup"><span data-stu-id="23e8f-291">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="23e8f-292">Par exemple, lorsque <xref:System.Runtime.Serialization.DataContractSerializer> utilise un lecteur sécurisé avec <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, il ne désérialise pas les chaînes supérieures à ce quota.</span><span class="sxs-lookup"><span data-stu-id="23e8f-292">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="23e8f-293">Lorsque vous utilisez directement la classe <xref:System.Xml.XmlDictionaryReader> , toutes les méthodes ne respectent pas ce quota, mais uniquement les méthodes particulièrement conçues pour lire des chaînes, telles que la méthode <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> .</span><span class="sxs-lookup"><span data-stu-id="23e8f-293">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="23e8f-294">La propriété <xref:System.Xml.XmlReader.Value%2A> sur le lecteur n'est pas affectée par ce quota. Vous ne devez donc pas utiliser cette propriété lorsque la protection que ce quota fournit est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-294">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="23e8f-295">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="23e8f-295">MaxArrayLength</span></span>

<span data-ttu-id="23e8f-296">Ce quota limite la taille maximale d'un tableau de primitives que le lecteur XML renvoie, notamment un tableau d'octets.</span><span class="sxs-lookup"><span data-stu-id="23e8f-296">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="23e8f-297">Ce quota ne limite pas la consommation de mémoire dans le lecteur XML lui-même, mais dans le composant qui utilise le lecteur.</span><span class="sxs-lookup"><span data-stu-id="23e8f-297">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="23e8f-298">Par exemple, lorsque <xref:System.Runtime.Serialization.DataContractSerializer> utilise un lecteur sécurisé avec <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, il ne désérialise pas les tableaux d'octets supérieurs à ce quota.</span><span class="sxs-lookup"><span data-stu-id="23e8f-298">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="23e8f-299">Il est important de définir ce quota lorsque vous essayez de combiner des modèles de programmation mis en mémoire tampon et de diffusion en continu dans un contrat unique.</span><span class="sxs-lookup"><span data-stu-id="23e8f-299">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="23e8f-300">N'oubliez pas que lorsque vous utilisez directement la classe <xref:System.Xml.XmlDictionaryReader> , seules les méthodes particulièrement conçues pour lire les tableaux de taille arbitraire de certains types de primitives, tels que <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respectent ce quota.</span><span class="sxs-lookup"><span data-stu-id="23e8f-300">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="23e8f-301">Menaces propres à l'encodage binaire</span><span class="sxs-lookup"><span data-stu-id="23e8f-301">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="23e8f-302">L’encodage XML binaire pris en charge par WCF comprend une fonctionnalité de *chaînes de dictionnaire* .</span><span class="sxs-lookup"><span data-stu-id="23e8f-302">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="23e8f-303">Une grande chaîne peut être encodée à l'aide de seulement quelques octets.</span><span class="sxs-lookup"><span data-stu-id="23e8f-303">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="23e8f-304">Cette fonctionnalité permet des gains de performance significatifs, mais introduit de nouvelles menaces de déni de service à atténuer.</span><span class="sxs-lookup"><span data-stu-id="23e8f-304">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="23e8f-305">Il existe deux types de dictionnaires : *statiques* et *dynamiques*.</span><span class="sxs-lookup"><span data-stu-id="23e8f-305">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="23e8f-306">Le dictionnaire statique est une liste intégrée de longues chaînes qui peuvent être représentées à l'aide d'un code court dans l'encodage binaire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-306">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="23e8f-307">Cette liste de chaînes est déterminée lorsque le lecteur est créé et ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="23e8f-307">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="23e8f-308">Aucune des chaînes du dictionnaire statique que WCF utilise par défaut n’est suffisamment grande pour poser une menace de déni de service sérieuse, bien qu’elles puissent toujours être utilisées dans une attaque par expansion de dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-308">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="23e8f-309">Dans les scénarios complexes où vous fournissez votre propre dictionnaire statique, faites preuve de prudence lorsque vous introduisez de grandes chaînes de dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-309">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="23e8f-310">Les dictionnaires dynamiques permettent aux messages de définir leurs propres chaînes et de les associer à des codes courts.</span><span class="sxs-lookup"><span data-stu-id="23e8f-310">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="23e8f-311">Ces mappages de chaînes à du code sont conservés en mémoire pendant toute la session de communication, de sorte à ce que les messages suivants n'aient pas à renvoyer les chaînes et puissent utiliser les codes déjà définis.</span><span class="sxs-lookup"><span data-stu-id="23e8f-311">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="23e8f-312">Ces chaînes peuvent être de longueur arbitraire et représentent donc une menace plus sérieuse que celles du dictionnaire statique.</span><span class="sxs-lookup"><span data-stu-id="23e8f-312">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="23e8f-313">La première menace à atténuer est la possibilité qu'a le dictionnaire dynamique (le tableau de mappage des chaînes à du code) de devenir trop volumineux.</span><span class="sxs-lookup"><span data-stu-id="23e8f-313">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="23e8f-314">Ce dictionnaire peut se développer au cours de plusieurs messages, et ainsi, le quota `MaxReceivedMessageSize` n'offre aucune protection parce qu'il s'applique uniquement à chaque message séparément.</span><span class="sxs-lookup"><span data-stu-id="23e8f-314">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="23e8f-315">Par conséquent, une propriété <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> distincte existe sur <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> qui limite la taille du dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-315">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="23e8f-316">À la différence de la plupart des autres quotas, ce quota s'applique également lors de l'écriture de messages.</span><span class="sxs-lookup"><span data-stu-id="23e8f-316">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="23e8f-317">S'il est dépassé lors de la lecture d'un message, `QuotaExceededException` est levée comme d'habitude.</span><span class="sxs-lookup"><span data-stu-id="23e8f-317">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="23e8f-318">S'il est dépassé lors de l'écriture d'un message, toutes les chaînes qui provoquent le dépassement du quota sont écrites en l'état, sans utiliser la fonctionnalité des dictionnaires dynamiques.</span><span class="sxs-lookup"><span data-stu-id="23e8f-318">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="23e8f-319">Menaces d'expansion de dictionnaire</span><span class="sxs-lookup"><span data-stu-id="23e8f-319">Dictionary Expansion Threats</span></span>

<span data-ttu-id="23e8f-320">Une importante classe d'attaques propres au binaire provient de l'expansion des dictionnaires.</span><span class="sxs-lookup"><span data-stu-id="23e8f-320">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="23e8f-321">Un petit message au format binaire peut devenir un message très volumineux au format texte complètement développé s'il utilise de manière excessive la fonctionnalité des dictionnaires de chaînes.</span><span class="sxs-lookup"><span data-stu-id="23e8f-321">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="23e8f-322">Le facteur d'expansion pour les chaînes de dictionnaires dynamiques est limité par le quota <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> , parce qu'aucune chaîne de dictionnaire dynamique ne dépasse la taille maximale du dictionnaire entier.</span><span class="sxs-lookup"><span data-stu-id="23e8f-322">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="23e8f-323">Les propriétés <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`et `MaxArrayLength` limitent seulement la consommation de mémoire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-323">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="23e8f-324">Elles ne sont normalement pas nécessaires pour atténuer toutes les menaces liées à la non-diffusion en continu parce que l'utilisation de la mémoire est déjà limitée par `MaxReceivedMessageSize`.</span><span class="sxs-lookup"><span data-stu-id="23e8f-324">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="23e8f-325">Toutefois, `MaxReceivedMessageSize` compte les octets de préexpansion.</span><span class="sxs-lookup"><span data-stu-id="23e8f-325">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="23e8f-326">Lorsque vous utilisez l'encodage binaire, la consommation de mémoire peut dépasser la valeur `MaxReceivedMessageSize`, uniquement limitée par un facteur de <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-326">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="23e8f-327">Pour cette raison, il est important de toujours définir tous les quotas de lecteurs (surtout <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) lors de l'utilisation de l'encodage binaire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-327">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="23e8f-328">Lors de l'utilisation de l'encodage binaire avec <xref:System.Runtime.Serialization.DataContractSerializer>, l'interface `IExtensibleDataObject` peut être employée à mauvais escient pour monter une attaque par expansion de dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-328">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="23e8f-329">Cette interface fournit principalement le stockage illimité des données arbitraires qui ne font pas partie du contrat.</span><span class="sxs-lookup"><span data-stu-id="23e8f-329">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="23e8f-330">S'il n'est pas possible de définir les quotas à un niveau suffisamment bas pour que la valeur `MaxSessionSize` multipliée par la valeur `MaxReceivedMessageSize` ne pose pas de problème, désactivez la fonctionnalité `IExtensibleDataObject` lors de l'utilisation de l'encodage binaire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-330">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="23e8f-331">Affectez à la propriété `IgnoreExtensionDataObject` la valeur `true` sur l'attribut `ServiceBehaviorAttribute` .</span><span class="sxs-lookup"><span data-stu-id="23e8f-331">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="23e8f-332">Vous pouvez également ne pas implémenter l'interface `IExtensibleDataObject` .</span><span class="sxs-lookup"><span data-stu-id="23e8f-332">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="23e8f-333">Pour plus d’informations, consultez [Contrats de données compatibles avec des versions ultérieures](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="23e8f-333">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="23e8f-334">Résumé des quotas</span><span class="sxs-lookup"><span data-stu-id="23e8f-334">Quotas Summary</span></span>

<span data-ttu-id="23e8f-335">Le tableau suivant résume les conseils relatifs aux quotas.</span><span class="sxs-lookup"><span data-stu-id="23e8f-335">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="23e8f-336">Condition</span><span class="sxs-lookup"><span data-stu-id="23e8f-336">Condition</span></span>|<span data-ttu-id="23e8f-337">Quotas importants à définir</span><span class="sxs-lookup"><span data-stu-id="23e8f-337">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="23e8f-338">Aucune diffusion en continu ou diffusion en continu de petits messages, texte ou encodage MTOM</span><span class="sxs-lookup"><span data-stu-id="23e8f-338">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="23e8f-339">`MaxReceivedMessageSize`, `MaxBytesPerRead` et `MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="23e8f-339">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="23e8f-340">Aucune diffusion en continu ou diffusion en continu de petits messages, encodage binaire</span><span class="sxs-lookup"><span data-stu-id="23e8f-340">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="23e8f-341">`MaxReceivedMessageSize`, `MaxSessionSize`et tous les `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="23e8f-341">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="23e8f-342">Diffusion en continu de messages, texte ou encodage MTOM volumineux</span><span class="sxs-lookup"><span data-stu-id="23e8f-342">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="23e8f-343">`MaxBufferSize` et tous les `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="23e8f-343">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="23e8f-344">Diffusion en continu de messages, encodage binaire volumineux</span><span class="sxs-lookup"><span data-stu-id="23e8f-344">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="23e8f-345">`MaxBufferSize`, `MaxSessionSize`et tous les `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="23e8f-345">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="23e8f-346">Les délais d'attente au niveau du transport doivent toujours être définis et ne jamais utiliser des lectures/écritures synchrones lorsque la diffusion en continu est utilisée, que vous diffusiez en continu des messages volumineux ou non.</span><span class="sxs-lookup"><span data-stu-id="23e8f-346">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="23e8f-347">Lorsque vous n'êtes pas sûr d'un quota, affectez-lui une valeur sûre plutôt que de le laisser ouvert.</span><span class="sxs-lookup"><span data-stu-id="23e8f-347">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="23e8f-348">Prévention de l'exécution de code malveillant</span><span class="sxs-lookup"><span data-stu-id="23e8f-348">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="23e8f-349">Les classes générales suivantes de menaces peuvent exécuter du code et avoir des effets involontaires :</span><span class="sxs-lookup"><span data-stu-id="23e8f-349">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="23e8f-350">Le désérialiseur charge un type malveillant, potentiellement dangereux ou sensible pour la sécurité.</span><span class="sxs-lookup"><span data-stu-id="23e8f-350">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="23e8f-351">Un message entrant provoque la construction par le désérialiseur d'une instance d'un type normalement sûr de façon à ce qu'elle engendre des conséquences involontaires.</span><span class="sxs-lookup"><span data-stu-id="23e8f-351">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="23e8f-352">Les sections suivantes présentent de manière plus approfondie ces classes de menaces.</span><span class="sxs-lookup"><span data-stu-id="23e8f-352">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="23e8f-353">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="23e8f-353">DataContractSerializer</span></span>

<span data-ttu-id="23e8f-354">(Pour obtenir des informations de sécurité sur le <xref:System.Xml.Serialization.XmlSerializer> , consultez la documentation correspondante.) Le modèle de sécurité de <xref:System.Xml.Serialization.XmlSerializer> est similaire à celui de <xref:System.Runtime.Serialization.DataContractSerializer> , et diffère principalement en détail.</span><span class="sxs-lookup"><span data-stu-id="23e8f-354">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="23e8f-355">Par exemple, l'attribut <xref:System.Xml.Serialization.XmlIncludeAttribute> est utilisé pour l'inclusion de type au lieu de l'attribut <xref:System.Runtime.Serialization.KnownTypeAttribute> .</span><span class="sxs-lookup"><span data-stu-id="23e8f-355">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="23e8f-356">Toutefois, certaines menaces propres à <xref:System.Xml.Serialization.XmlSerializer> sont présentées plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="23e8f-356">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="23e8f-357">Prévention du chargement de types involontaires</span><span class="sxs-lookup"><span data-stu-id="23e8f-357">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="23e8f-358">Le chargement de types involontaires peut avoir de lourdes conséquences, que le type soit malveillant ou qu'il implique simplement des effets secondaires sensibles pour la sécurité.</span><span class="sxs-lookup"><span data-stu-id="23e8f-358">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="23e8f-359">Un type peut contenir une faille de sécurité exploitable, exécuter des actions sensibles pour la sécurité dans son constructeur ou son constructeur de classe, subir un grand encombrement de mémoire qui facilite les attaques par déni de service ou lever des exceptions irrécupérables.</span><span class="sxs-lookup"><span data-stu-id="23e8f-359">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="23e8f-360">Les types peuvent avoir des constructeurs de classe qui s'exécutent dès que le type est chargé et avant qu'une instance ne soit créée.</span><span class="sxs-lookup"><span data-stu-id="23e8f-360">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="23e8f-361">Pour ces raisons, il est important de contrôler le jeu de types que le désérialiseur peut charger.</span><span class="sxs-lookup"><span data-stu-id="23e8f-361">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="23e8f-362"><xref:System.Runtime.Serialization.DataContractSerializer> désérialise d'une manière faiblement couplée.</span><span class="sxs-lookup"><span data-stu-id="23e8f-362">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="23e8f-363">Il ne lit jamais le type CLR (Common Language Runtime) ni les noms d'assembly à partir des données entrantes.</span><span class="sxs-lookup"><span data-stu-id="23e8f-363">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="23e8f-364">Ce comportement est similaire à celui de <xref:System.Xml.Serialization.XmlSerializer>, mais diffère de celui de <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>et de <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-364">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="23e8f-365">Le couplage faible introduit un degré de sécurité, parce que l'intrus distant ne peut pas indiquer un type arbitraire à charger en se contentant de le nommer dans le message.</span><span class="sxs-lookup"><span data-stu-id="23e8f-365">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="23e8f-366"><xref:System.Runtime.Serialization.DataContractSerializer> est toujours autorisé à charger un type actuellement prévu conformément au contrat.</span><span class="sxs-lookup"><span data-stu-id="23e8f-366">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="23e8f-367">Par exemple, si un contrat de données comporte un membre de données du type `Customer`, <xref:System.Runtime.Serialization.DataContractSerializer> est autorisé à charger le type `Customer` lorsqu'il désérialise ce membre de données.</span><span class="sxs-lookup"><span data-stu-id="23e8f-367">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="23e8f-368">En outre, <xref:System.Runtime.Serialization.DataContractSerializer> prend en charge le polymorphisme.</span><span class="sxs-lookup"><span data-stu-id="23e8f-368">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="23e8f-369">Un membre de données peut être déclaré comme <xref:System.Object>, mais les données entrantes peuvent contenir une instance `Customer` .</span><span class="sxs-lookup"><span data-stu-id="23e8f-369">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="23e8f-370">Cette situation est possible uniquement si le type `Customer` a été indiqué au désérialiseur via l'un de ces mécanismes :</span><span class="sxs-lookup"><span data-stu-id="23e8f-370">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="23e8f-371">attribut<xref:System.Runtime.Serialization.KnownTypeAttribute> appliqué à un type ;</span><span class="sxs-lookup"><span data-stu-id="23e8f-371"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="23e8f-372">attribut`KnownTypeAttribute` qui spécifie une méthode qui renvoie une liste de types ;</span><span class="sxs-lookup"><span data-stu-id="23e8f-372">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="23e8f-373">attribut`ServiceKnownTypeAttribute` ;</span><span class="sxs-lookup"><span data-stu-id="23e8f-373">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="23e8f-374">section de configuration `KnownTypes` ;</span><span class="sxs-lookup"><span data-stu-id="23e8f-374">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="23e8f-375">liste des types connus passée explicitement à <xref:System.Runtime.Serialization.DataContractSerializer> pendant la construction, en cas d'utilisation directe du sérialiseur.</span><span class="sxs-lookup"><span data-stu-id="23e8f-375">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="23e8f-376">Chacun de ces mécanismes augmente la surface d'exposition en introduisant plus de types que le désérialiseur est capable de charger.</span><span class="sxs-lookup"><span data-stu-id="23e8f-376">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="23e8f-377">Contrôlez chacun de ces mécanismes pour vérifier qu'aucun type malveillant ou involontaire n'est ajouté à la liste des types connus.</span><span class="sxs-lookup"><span data-stu-id="23e8f-377">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="23e8f-378">Une fois qu'un type connu se trouve dans la portée, il peut être chargé à tout moment, et des instances du type peuvent être créées, même si le contrat en interdit l'utilisation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-378">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="23e8f-379">Par exemple, supposez que le type « MyDangerousType » soit ajouté à la liste des types connus à l'aide de l'un des mécanismes ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="23e8f-379">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="23e8f-380">Cela signifie que :</span><span class="sxs-lookup"><span data-stu-id="23e8f-380">This means that:</span></span>

- <span data-ttu-id="23e8f-381">`MyDangerousType` est chargé et son constructeur de classe s'exécute.</span><span class="sxs-lookup"><span data-stu-id="23e8f-381">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="23e8f-382">Même lors de la désérialisation d'un contrat de données avec un membre de données de chaîne, un message malveillant peut quand même provoquer la création d'une instance de `MyDangerousType` .</span><span class="sxs-lookup"><span data-stu-id="23e8f-382">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="23e8f-383">Le code inclus dans `MyDangerousType`, tel que les accesseurs Set de propriété, peuvent s'exécuter.</span><span class="sxs-lookup"><span data-stu-id="23e8f-383">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="23e8f-384">À l'issue de cette exécution, le désérialiseur essaie d'assigner cette instance au membre de données de chaîne et échoue avec une exception.</span><span class="sxs-lookup"><span data-stu-id="23e8f-384">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="23e8f-385">Lors de l'écriture d'une méthode qui renvoie la liste des types connus, ou lors du passage directe d'une liste au constructeur <xref:System.Runtime.Serialization.DataContractSerializer> , vérifiez que le code qui prépare la liste est sécurisé et qu'il fonctionne uniquement sur les données approuvées.</span><span class="sxs-lookup"><span data-stu-id="23e8f-385">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="23e8f-386">Lors de la spécification de types connus dans la configuration, vérifiez que le fichier de configuration est sécurisé.</span><span class="sxs-lookup"><span data-stu-id="23e8f-386">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="23e8f-387">Utilisez toujours des noms forts dans la configuration (en spécifiant la clé publique de l'assembly signé où le type réside), mais ne spécifiez pas la version du type à charger.</span><span class="sxs-lookup"><span data-stu-id="23e8f-387">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="23e8f-388">Le chargeur de type choisit automatiquement la version la plus récente, si possible.</span><span class="sxs-lookup"><span data-stu-id="23e8f-388">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="23e8f-389">Si vous spécifiez une version particulière dans la configuration, vous exécutez le risque suivant : un type peut comporter une faille de sécurité qui peut être résolue dans une future version, mais la version vulnérable continue de se charger parce qu'elle sera spécifiée explicitement dans la configuration.</span><span class="sxs-lookup"><span data-stu-id="23e8f-389">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="23e8f-390">Un nombre trop élevé de types connus a une autre conséquence : <xref:System.Runtime.Serialization.DataContractSerializer> crée un cache de code de sérialisation/désérialisation dans le domaine d'application, avec une entrée pour chaque type qu'il doit sérialiser et désérialiser.</span><span class="sxs-lookup"><span data-stu-id="23e8f-390">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="23e8f-391">Ce cache n'est jamais effacé tant que le domaine d'application s'exécute.</span><span class="sxs-lookup"><span data-stu-id="23e8f-391">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="23e8f-392">Par conséquent, un intrus qui sait qu'une application utilise de nombreux types connus peut provoquer la désérialisation de tous ces types, ce qui engendre la consommation d'une quantité de mémoire disproportionnellement élevée par le cache.</span><span class="sxs-lookup"><span data-stu-id="23e8f-392">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="23e8f-393">Prévention des états involontaires affectés aux types</span><span class="sxs-lookup"><span data-stu-id="23e8f-393">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="23e8f-394">Un type peut avoir des contraintes de cohérence interne qui doivent être appliquées.</span><span class="sxs-lookup"><span data-stu-id="23e8f-394">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="23e8f-395">Il faut veiller à ne pas violer ces contraintes pendant la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-395">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="23e8f-396">L'exemple de type suivant représente l'état d'un sas dans un vaisseau spatial et applique la contrainte selon laquelle les portes intérieure et extérieure ne peuvent pas être ouvertes en même temps.</span><span class="sxs-lookup"><span data-stu-id="23e8f-396">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="23e8f-397">Un intrus peut envoyer un message malveillant comme celui-ci, qui contourne les contraintes et fait passer l'objet dans un état non valide, susceptible d'avoir des conséquences involontaires et imprévisibles.</span><span class="sxs-lookup"><span data-stu-id="23e8f-397">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="23e8f-398">Cette situation peut être évitée en prenant conscience des points suivants :</span><span class="sxs-lookup"><span data-stu-id="23e8f-398">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="23e8f-399">Lorsque <xref:System.Runtime.Serialization.DataContractSerializer> désérialise la plupart des classes, les constructeurs ne s'exécutent pas.</span><span class="sxs-lookup"><span data-stu-id="23e8f-399">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="23e8f-400">Par conséquent, ne comptez pas sur la gestion d'état effectuée dans le constructeur.</span><span class="sxs-lookup"><span data-stu-id="23e8f-400">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="23e8f-401">Utilisez des rappels pour veiller à ce que l'objet soit dans un état valide.</span><span class="sxs-lookup"><span data-stu-id="23e8f-401">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="23e8f-402">Le rappel marqué avec l'attribut <xref:System.Runtime.Serialization.OnDeserializedAttribute> s'avère particulièrement utile parce qu'il s'exécute à la fin de la désérialisation et parce qu'il obtient une occasion d'examiner et de corriger l'état global.</span><span class="sxs-lookup"><span data-stu-id="23e8f-402">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="23e8f-403">Pour plus d’informations, consultez [rappels de sérialisation avec tolérance de version](version-tolerant-serialization-callbacks.md).</span><span class="sxs-lookup"><span data-stu-id="23e8f-403">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="23e8f-404">Ne concevez pas de types de contrat de données de sorte à compter sur un ordre particulier dans lequel les accesseurs Set de propriété doivent être appelés.</span><span class="sxs-lookup"><span data-stu-id="23e8f-404">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="23e8f-405">Faites preuve de prudence lorsque vous utilisez des types hérités marqués avec l'attribut <xref:System.SerializableAttribute> .</span><span class="sxs-lookup"><span data-stu-id="23e8f-405">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="23e8f-406">Un grand nombre d’entre eux ont été conçus pour fonctionner avec .NET Framework Remoting pour une utilisation avec des données approuvées uniquement.</span><span class="sxs-lookup"><span data-stu-id="23e8f-406">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="23e8f-407">Les types existants marqués avec cet attribut n'ont peut-être pas été conçus en tenant compte de la sécurité des états.</span><span class="sxs-lookup"><span data-stu-id="23e8f-407">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="23e8f-408">Ne comptez pas sur la propriété <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> de l'attribut <xref:System.Runtime.Serialization.DataMemberAttribute> pour garantir la présence des données en ce qui concerne la sécurité des états.</span><span class="sxs-lookup"><span data-stu-id="23e8f-408">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="23e8f-409">Les données pourraient toujours être `null`, `zero`ou `invalid`.</span><span class="sxs-lookup"><span data-stu-id="23e8f-409">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="23e8f-410">N'approuvez jamais un graphique d'objets désérialisé provenant d'une source de données non fiable sans le valider au préalable.</span><span class="sxs-lookup"><span data-stu-id="23e8f-410">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="23e8f-411">Chaque objet individuel peut être dans un état cohérent, à la différence du graphique d'objets dans son ensemble.</span><span class="sxs-lookup"><span data-stu-id="23e8f-411">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="23e8f-412">En outre, même si le mode de conservation des graphiques d'objets est désactivé, le graphique désérialisé peut avoir plusieurs références au même objet ou des références circulaires.</span><span class="sxs-lookup"><span data-stu-id="23e8f-412">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="23e8f-413">Pour plus d’informations, consultez [sérialisation et désérialisation](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="23e8f-413">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="23e8f-414">Utilisation de NetDataContractSerializer en toute sécurité</span><span class="sxs-lookup"><span data-stu-id="23e8f-414">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="23e8f-415"><xref:System.Runtime.Serialization.NetDataContractSerializer> est un moteur de sérialisation qui utilise le couplage étroit des types.</span><span class="sxs-lookup"><span data-stu-id="23e8f-415">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="23e8f-416">Ce moteur est similaire à <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> et à <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-416">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="23e8f-417">Autrement dit, il détermine le type à instancier en lisant l’assembly de .NET Framework et le nom de type à partir des données entrantes.</span><span class="sxs-lookup"><span data-stu-id="23e8f-417">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="23e8f-418">Bien qu’il fasse partie de WCF, il n’existe aucun moyen de brancher ce moteur de sérialisation. le code personnalisé doit être écrit.</span><span class="sxs-lookup"><span data-stu-id="23e8f-418">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="23e8f-419">`NetDataContractSerializer`Est fourni principalement pour faciliter la migration de .NET Framework communication à distance vers WCF.</span><span class="sxs-lookup"><span data-stu-id="23e8f-419">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="23e8f-420">Pour plus d’informations, consultez la section relative à la [sérialisation et à la désérialisation](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="23e8f-420">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="23e8f-421">Parce que le message lui-même peut indiquer la possibilité de charger tout type, le mécanisme <xref:System.Runtime.Serialization.NetDataContractSerializer> est par sa nature incertain et doit être utilisé uniquement avec des données approuvées.</span><span class="sxs-lookup"><span data-stu-id="23e8f-421">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="23e8f-422">Pour plus d’informations, consultez le [Guide de sécurité BinaryFormatter](/dotnet/standard/serialization/binaryformatter-security-guide).</span><span class="sxs-lookup"><span data-stu-id="23e8f-422">For more information, see the [BinaryFormatter security guide](/dotnet/standard/serialization/binaryformatter-security-guide).</span></span>

<span data-ttu-id="23e8f-423">Même en cas d'utilisation avec des données approuvées, les données entrantes peuvent spécifier insuffisamment le type à charger, surtout si la propriété <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> a la valeur <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-423">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="23e8f-424">Toute personne ayant accès au répertoire de l'application ou au Global Assembly Cache peut remplacer par un type malveillant celui qui est supposé se charger.</span><span class="sxs-lookup"><span data-stu-id="23e8f-424">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="23e8f-425">Vérifiez toujours la sécurité du répertoire de votre application et du Global Assembly Cache en définissant correctement les autorisations.</span><span class="sxs-lookup"><span data-stu-id="23e8f-425">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="23e8f-426">En général, si vous autorisez l'accès du code de niveau de confiance partiel à votre instance `NetDataContractSerializer` ou le contrôle du sélecteur de substitut (<xref:System.Runtime.Serialization.ISurrogateSelector>) ou le binder de sérialisation (<xref:System.Runtime.Serialization.SerializationBinder>), le code risque de contrôler en grande partie le processus de sérialisation/désérialisation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-426">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="23e8f-427">Par exemple, il peut injecter des types arbitraires, entraîner la divulgation d'informations, falsifier les données sérialisées ou le graphique résultant ou dépasser le flux sérialisé résultant.</span><span class="sxs-lookup"><span data-stu-id="23e8f-427">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="23e8f-428">Un autre problème de sécurité avec `NetDataContractSerializer` est le déni de service, qui n'est pas une menace d'exécution de code malveillant.</span><span class="sxs-lookup"><span data-stu-id="23e8f-428">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="23e8f-429">Lorsque vous utilisez `NetDataContractSerializer`, affectez toujours au quota <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> une valeur sûre.</span><span class="sxs-lookup"><span data-stu-id="23e8f-429">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="23e8f-430">Il est facile de construire un petit message malveillant qui alloue un tableau d'objets dont la taille est limitée uniquement par ce quota.</span><span class="sxs-lookup"><span data-stu-id="23e8f-430">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="23e8f-431">Menaces propres à XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="23e8f-431">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="23e8f-432">Le modèle de sécurité <xref:System.Xml.Serialization.XmlSerializer> est similaire à celui de <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-432">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="23e8f-433">Toutefois, quelques menaces sont propres à <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="23e8f-433">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="23e8f-434"><xref:System.Xml.Serialization.XmlSerializer> génère des *assemblys de sérialisation* au moment de l'exécution qui contiennent du code qui sérialise et désérialise réellement ; ces assemblys sont créés dans un répertoire de fichiers temporaires.</span><span class="sxs-lookup"><span data-stu-id="23e8f-434">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="23e8f-435">Si un autre processus ou utilisateur a des droits d'accès à ce répertoire, il peut remplacer le code de sérialisation/désérialisation par du code arbitraire.</span><span class="sxs-lookup"><span data-stu-id="23e8f-435">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="23e8f-436"><xref:System.Xml.Serialization.XmlSerializer> exécute alors ce code à l'aide de son contexte de sécurité, au lieu du code de sérialisation/désérialisation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-436">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="23e8f-437">Assurez-vous que les autorisations sont correctement définies sur le répertoire de fichiers temporaires afin d'empêcher ce remplacement.</span><span class="sxs-lookup"><span data-stu-id="23e8f-437">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="23e8f-438"><xref:System.Xml.Serialization.XmlSerializer> possède également un mode dans lequel il utilise des assemblys de sérialisation préalablement générés au lieu de les générer au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="23e8f-438">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="23e8f-439">Ce mode est déclenché chaque fois que <xref:System.Xml.Serialization.XmlSerializer> peut détecter un assembly de sérialisation approprié.</span><span class="sxs-lookup"><span data-stu-id="23e8f-439">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="23e8f-440"><xref:System.Xml.Serialization.XmlSerializer> vérifie si l'assembly de sérialisation a été signé ou non par la même clé que celle utilisée pour signer l'assembly qui contient les types en cours de sérialisation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-440">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="23e8f-441">Cette vérification offre une protection contre les assemblys malveillants déguisés en assemblys de sérialisation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-441">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="23e8f-442">Toutefois, si l'assembly qui contient vos types sérialisables n'est pas signé, <xref:System.Xml.Serialization.XmlSerializer> ne peut pas effectuer cette vérification et utilise alors tout assembly dont le nom est correct.</span><span class="sxs-lookup"><span data-stu-id="23e8f-442">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="23e8f-443">L'exécution de code malveillant est alors possible.</span><span class="sxs-lookup"><span data-stu-id="23e8f-443">This makes running malicious code possible.</span></span> <span data-ttu-id="23e8f-444">Signez toujours les assemblys qui contiennent vos types sérialisables ou contrôlez de près l'accès au répertoire de votre application et au Global Assembly Cache pour empêcher l'introduction d'assemblys malveillants.</span><span class="sxs-lookup"><span data-stu-id="23e8f-444">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="23e8f-445"><xref:System.Xml.Serialization.XmlSerializer> peut être l'objet d'une attaque par déni de service.</span><span class="sxs-lookup"><span data-stu-id="23e8f-445">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="23e8f-446"><xref:System.Xml.Serialization.XmlSerializer> n'a pas de quota `MaxItemsInObjectGraph` (tel que celui disponible sur <xref:System.Runtime.Serialization.DataContractSerializer>).</span><span class="sxs-lookup"><span data-stu-id="23e8f-446">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="23e8f-447">Ainsi, il désérialise une quantité arbitraire d'objets, limitée uniquement par la taille du message.</span><span class="sxs-lookup"><span data-stu-id="23e8f-447">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="23e8f-448">Menaces liées à une confiance partielle</span><span class="sxs-lookup"><span data-stu-id="23e8f-448">Partial Trust Threats</span></span>

<span data-ttu-id="23e8f-449">Notez les préoccupations suivantes concernant des menaces liées à l'exécution de code avec un niveau de confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="23e8f-449">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="23e8f-450">Ces menaces incluent le code malveillant de niveau de confiance partiel aussi bien que le code malveillant de niveau de confiance partiel en association avec d'autres scénarios d'attaque (par exemple, du code de niveau de confiance partiel qui construit une chaîne spécifique, puis qui la désérialise).</span><span class="sxs-lookup"><span data-stu-id="23e8f-450">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="23e8f-451">Lorsque vous utilisez des composants de sérialisation, ne déclarez jamais des autorisations avant cette utilisation, même si le scénario de sérialisation entier s'intègre dans la portée de votre assertion et si vous ne traitez pas des données ou objets non fiables.</span><span class="sxs-lookup"><span data-stu-id="23e8f-451">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="23e8f-452">Une telle utilisation peut engendrer des failles de sécurité.</span><span class="sxs-lookup"><span data-stu-id="23e8f-452">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="23e8f-453">Dans les cas où le code de confiance partielle contrôle le processus de sérialisation, soit par le biais des points d'extensibilité (substituts), des types sérialisés, soit par d'autres moyens, ce code peut forcer le sérialiseur à générer une grande quantité de données dans le flux sérialisé, ce qui peut entraîner un déni de service auprès du récepteur du flux.</span><span class="sxs-lookup"><span data-stu-id="23e8f-453">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="23e8f-454">Si vous sérialisez des données destinées à une cible exposée à des menaces de déni de service, ne sérialisez pas les types de confiance partielle, ou sinon laissez le code de confiance partielle contrôler la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-454">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="23e8f-455">Si vous autorisez l’accès du code de confiance partielle à votre <xref:System.Runtime.Serialization.DataContractSerializer> instance ou si vous contrôlez les [substituts de contrat de données](../extending/data-contract-surrogates.md), cela peut exercer un grand contrôle sur le processus de sérialisation/désérialisation.</span><span class="sxs-lookup"><span data-stu-id="23e8f-455">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="23e8f-456">Par exemple, il peut injecter des types arbitraires, entraîner la divulgation d'informations, falsifier les données sérialisées ou le graphique résultant ou dépasser le flux sérialisé résultant.</span><span class="sxs-lookup"><span data-stu-id="23e8f-456">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="23e8f-457">Une menace <xref:System.Runtime.Serialization.NetDataContractSerializer> équivalente est décrite dans la section « Utilisation de NetDataContractSerializer en toute sécurité ».</span><span class="sxs-lookup"><span data-stu-id="23e8f-457">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="23e8f-458">Si l'attribut <xref:System.Runtime.Serialization.DataContractAttribute> est appliqué à un type (ou au type marqué comme <xref:System.SerializableAttribute> mais qu'il n'est pas <xref:System.Runtime.Serialization.ISerializable>), le désérialiseur peut créer une instance d'un tel type même si tous les constructeurs sont non publics ou protégés par des demandes.</span><span class="sxs-lookup"><span data-stu-id="23e8f-458">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="23e8f-459">N'approuvez jamais le résultat de la désérialisation sauf si les données à désérialiser sont approuvées et que vous êtes certain que tous les types connus sont des types que vous approuvez.</span><span class="sxs-lookup"><span data-stu-id="23e8f-459">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="23e8f-460">Notez que les types connus ne sont pas chargés depuis le fichier de configuration de l'application (mais sont chargés depuis le fichier de configuration de l'ordinateur) lorsqu'ils s'exécutent en confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="23e8f-460">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="23e8f-461">Si vous passez une instance <xref:System.Runtime.Serialization.DataContractSerializer> avec un substitut ajouté au code de niveau de confiance partiel, le code peut modifier tous les paramètres modifiables sur ce substitut.</span><span class="sxs-lookup"><span data-stu-id="23e8f-461">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="23e8f-462">Pour un objet désérialisé, si le lecteur XML (ou les données qui s'y trouvent) vient de code de niveau de confiance partiel, traitez l'objet désérialisé obtenu comme des données non fiables.</span><span class="sxs-lookup"><span data-stu-id="23e8f-462">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="23e8f-463">Le fait que le type <xref:System.Runtime.Serialization.ExtensionDataObject> n'ait pas de membres publics ne signifie pas que les données qu'il contient sont sécurisées.</span><span class="sxs-lookup"><span data-stu-id="23e8f-463">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="23e8f-464">Par exemple, si vous désérialisez à partir d'une source de données privilégiée dans un objet dans lequel certaines données résident, puis remettez cet objet à du code de niveau de confiance partiel, le code de niveau de confiance partiel peut lire les données dans `ExtensionDataObject` en sérialisant l'objet.</span><span class="sxs-lookup"><span data-stu-id="23e8f-464">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="23e8f-465">Envisagez d'affecter à <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> la valeur `true` lors d'une désérialisation à partir d'une source de données privilégiée dans un objet qui est passé ultérieurement à du code de niveau de confiance partiel.</span><span class="sxs-lookup"><span data-stu-id="23e8f-465">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="23e8f-466"><xref:System.Runtime.Serialization.DataContractSerializer> et <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> prennent en charge la sérialisation de membres privés, protégés, internes et publics en mode de confiance totale.</span><span class="sxs-lookup"><span data-stu-id="23e8f-466"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="23e8f-467">Toutefois, en mode de confiance partielle, seuls les membres publics peuvent être sérialisés.</span><span class="sxs-lookup"><span data-stu-id="23e8f-467">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="23e8f-468">Une <xref:System.Security.SecurityException> est levée si une application tente de sérialiser un membre qui n'est pas public.</span><span class="sxs-lookup"><span data-stu-id="23e8f-468">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="23e8f-469">Pour autoriser la sérialisation de membres internes ou protégés en mode de confiance partielle, utilisez l'attribut d'assembly <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> .</span><span class="sxs-lookup"><span data-stu-id="23e8f-469">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="23e8f-470">Cet attribut permet à un assembly de déclarer que ses membres internes sont visibles à certains autres assemblys.</span><span class="sxs-lookup"><span data-stu-id="23e8f-470">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="23e8f-471">Dans ce cas, un assembly qui souhaite sérialiser ses membres internes déclare que ces derniers sont visibles à System.Runtime.Serialization.dll.</span><span class="sxs-lookup"><span data-stu-id="23e8f-471">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="23e8f-472">L'avantage de cette approche réside dans le fait qu'elle ne nécessite pas de chemin de génération de code élevé.</span><span class="sxs-lookup"><span data-stu-id="23e8f-472">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="23e8f-473">Toutefois, elle présente deux inconvénients principaux.</span><span class="sxs-lookup"><span data-stu-id="23e8f-473">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="23e8f-474">Le premier étant que la propriété de sélection de l'attribut <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> est au niveau de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="23e8f-474">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="23e8f-475">En d'autres termes, vous ne pouvez pas spécifier que seule une certaine classe peut avoir ses membres internes sérialisés.</span><span class="sxs-lookup"><span data-stu-id="23e8f-475">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="23e8f-476">Il va de soi que vous pouvez toujours choisir de ne pas sérialiser un membre interne spécifique, en n'ajoutant pas d'attribut <xref:System.Runtime.Serialization.DataMemberAttribute> à ce membre.</span><span class="sxs-lookup"><span data-stu-id="23e8f-476">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="23e8f-477">De la même façon, un développeur peut aussi choisir de rendre un membre interne au lieu de privé ou protégé, avec de légers problèmes de visibilité.</span><span class="sxs-lookup"><span data-stu-id="23e8f-477">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="23e8f-478">Le second réside dans le fait que cette approche ne prend pas encore en charge les membres privés ou protégés.</span><span class="sxs-lookup"><span data-stu-id="23e8f-478">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="23e8f-479">Pour illustrer l'utilisation de l'attribut <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> en mode de confiance partielle, prenons l'exemple du programme suivant :</span><span class="sxs-lookup"><span data-stu-id="23e8f-479">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="23e8f-480">Dans l'exemple ci-dessus, l'objet `PermissionsHelper.InternetZone` correspond à l'objet <xref:System.Security.PermissionSet> en mode de confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="23e8f-480">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="23e8f-481">Désormais, sans l' <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribut, l’application échouera, en levant une <xref:System.Security.SecurityException> indiquant que les membres non publics ne peuvent pas être sérialisés en confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="23e8f-481">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="23e8f-482">Toutefois, si nous ajoutons la ligne suivante au fichier source, le programme s'exécute.</span><span class="sxs-lookup"><span data-stu-id="23e8f-482">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="23e8f-483">Autres préoccupations liées à la gestion d'état</span><span class="sxs-lookup"><span data-stu-id="23e8f-483">Other State Management Concerns</span></span>

<span data-ttu-id="23e8f-484">Il est judicieux de mentionner quelques autres préoccupations liées à la gestion d'état d'objet :</span><span class="sxs-lookup"><span data-stu-id="23e8f-484">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="23e8f-485">Lors de l'utilisation du modèle de programmation basé sur le flux avec un transport de diffusion en continu, le traitement du message se produit au moment où le message arrive.</span><span class="sxs-lookup"><span data-stu-id="23e8f-485">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="23e8f-486">L'expéditeur du message peut abandonner l'opération d'envoi en cours de flux, ce qui laisse votre code dans un état imprévisible si davantage de contenu était attendu.</span><span class="sxs-lookup"><span data-stu-id="23e8f-486">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="23e8f-487">En général, ne comptez pas sur l'exhaustivité du flux et n'exécutez rien dans une opération basée sur le flux qui ne puisse pas être restauré au cas où le flux de données serait abandonné.</span><span class="sxs-lookup"><span data-stu-id="23e8f-487">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="23e8f-488">Ces recommandations s'appliquent également au cas dans lequel un message peut s'avérer incorrect après la diffusion en continu du corps (par exemple, il peut manquer une balise de fin pour l'enveloppe SOAP ou le message peut comporter un deuxième corps).</span><span class="sxs-lookup"><span data-stu-id="23e8f-488">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="23e8f-489">L'utilisation de la fonctionnalité `IExtensibleDataObject` peut engendrer l'émission de données sensibles.</span><span class="sxs-lookup"><span data-stu-id="23e8f-489">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="23e8f-490">Si vous acceptez des données d'une source non fiable dans des contrats de données avec `IExtensibleObjectData` , puis vous les émettez de nouveau sur un canal sécurisé où les messages sont signés, vous vous portez potentiellement garant de données dont vous ne savez rien.</span><span class="sxs-lookup"><span data-stu-id="23e8f-490">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="23e8f-491">De plus, l'état global que vous envoyez risque de ne pas être valide si vous prenez à la fois en considération les morceaux de données connus et inconnus.</span><span class="sxs-lookup"><span data-stu-id="23e8f-491">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="23e8f-492">Évitez cette situation en affectant sélectivement à la propriété des données d'extension la valeur `null` ou en désactivant sélectivement la fonctionnalité `IExtensibleObjectData` .</span><span class="sxs-lookup"><span data-stu-id="23e8f-492">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="23e8f-493">Importation de schéma</span><span class="sxs-lookup"><span data-stu-id="23e8f-493">Schema Import</span></span>

<span data-ttu-id="23e8f-494">Normalement, le processus d’importation du schéma pour générer des types s’exécute uniquement au moment de la conception, par exemple, lors de l’utilisation de [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) sur un service web pour générer une classe de client.</span><span class="sxs-lookup"><span data-stu-id="23e8f-494">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="23e8f-495">Toutefois, dans des scénarios plus avances, vous pouvez traiter le schéma au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="23e8f-495">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="23e8f-496">N'oubliez pas que ce traitement peut vous exposer à des risques de déni de service.</span><span class="sxs-lookup"><span data-stu-id="23e8f-496">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="23e8f-497">L'importation de certains schémas peut nécessiter beaucoup de temps.</span><span class="sxs-lookup"><span data-stu-id="23e8f-497">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="23e8f-498">N'utilisez jamais le composant d'importation de schéma <xref:System.Xml.Serialization.XmlSerializer> dans de tels scénarios si les schémas peuvent venir d'une source non fiable.</span><span class="sxs-lookup"><span data-stu-id="23e8f-498">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="23e8f-499">Menaces spécifiques à l'intégration ASP.NET AJAX</span><span class="sxs-lookup"><span data-stu-id="23e8f-499">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="23e8f-500">Lorsque l’utilisateur implémente <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> ou <xref:System.ServiceModel.Description.WebHttpBehavior> , WCF expose un point de terminaison qui peut accepter à la fois les messages XML et JSON.</span><span class="sxs-lookup"><span data-stu-id="23e8f-500">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="23e8f-501">Cependant, il n'existe qu'un jeu de quotas de lecteurs utilisés par les lecteurs XML et JSON.</span><span class="sxs-lookup"><span data-stu-id="23e8f-501">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="23e8f-502">Certains paramètres de quota peuvent convenir à un lecteur mais sont trop grands pour l'autre.</span><span class="sxs-lookup"><span data-stu-id="23e8f-502">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="23e8f-503">Lors de l'implémentation de `WebScriptEnablingBehavior`, l'utilisateur peut exposer un proxy JavaScript au point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="23e8f-503">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="23e8f-504">Tenez compte des éléments suivants en examinant les questions de sécurité :</span><span class="sxs-lookup"><span data-stu-id="23e8f-504">The following security issues must be considered:</span></span>

- <span data-ttu-id="23e8f-505">Les informations sur le service (noms d'opération, noms de paramètre etc.) peuvent être obtenues par l'examen du proxy JavaScript.</span><span class="sxs-lookup"><span data-stu-id="23e8f-505">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="23e8f-506">Lors de l'utilisation du point de terminaison JavaScript, des informations privées et sensibles peuvent être conservées dans le cache du navigateur Web du client.</span><span class="sxs-lookup"><span data-stu-id="23e8f-506">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="23e8f-507">Remarque sur les composants</span><span class="sxs-lookup"><span data-stu-id="23e8f-507">A Note on Components</span></span>

<span data-ttu-id="23e8f-508">WCF est un système flexible et personnalisable.</span><span class="sxs-lookup"><span data-stu-id="23e8f-508">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="23e8f-509">La majeure partie du contenu de cette rubrique se concentre sur les scénarios d’utilisation WCF les plus courants.</span><span class="sxs-lookup"><span data-stu-id="23e8f-509">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="23e8f-510">Toutefois, il est possible de composer les composants fournis par WCF de différentes manières.</span><span class="sxs-lookup"><span data-stu-id="23e8f-510">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="23e8f-511">Il est important de comprendre les implications en matière de sécurité de l'utilisation de chaque composant.</span><span class="sxs-lookup"><span data-stu-id="23e8f-511">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="23e8f-512">En particulier :</span><span class="sxs-lookup"><span data-stu-id="23e8f-512">In particular:</span></span>

- <span data-ttu-id="23e8f-513">Lorsque vous devez utiliser des lecteurs XML, utilisez les lecteurs que la classe <xref:System.Xml.XmlDictionaryReader> fournit au lieu de tous les autres lecteurs.</span><span class="sxs-lookup"><span data-stu-id="23e8f-513">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="23e8f-514">Les lecteurs sûrs sont créés à l'aide des méthodes <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>ou <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> .</span><span class="sxs-lookup"><span data-stu-id="23e8f-514">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="23e8f-515">N'utilisez pas la méthode <xref:System.Xml.XmlReader.Create%2A> .</span><span class="sxs-lookup"><span data-stu-id="23e8f-515">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="23e8f-516">Configurez toujours les lecteurs avec des quotas sûrs.</span><span class="sxs-lookup"><span data-stu-id="23e8f-516">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="23e8f-517">Les moteurs de sérialisation dans WCF sont sécurisés uniquement lorsqu’ils sont utilisés avec des lecteurs XML sécurisés de WCF.</span><span class="sxs-lookup"><span data-stu-id="23e8f-517">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="23e8f-518">Lorsque vous utilisez <xref:System.Runtime.Serialization.DataContractSerializer> pour désérialiser des données potentiellement non fiables, affectez toujours une valeur à la propriété <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> .</span><span class="sxs-lookup"><span data-stu-id="23e8f-518">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="23e8f-519">Lorsque vous créez un message, définissez le paramètre `maxSizeOfHeaders` si `MaxReceivedMessageSize` n'offre pas assez de protection.</span><span class="sxs-lookup"><span data-stu-id="23e8f-519">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="23e8f-520">Lorsque vous créez un encodeur, configurez toujours les quotas correspondants, tels que `MaxSessionSize` et `MaxBufferSize`.</span><span class="sxs-lookup"><span data-stu-id="23e8f-520">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="23e8f-521">Lorsque vous utilisez un filtre de message XPath, affectez une valeur à <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> de sorte à limiter le nombre de nœuds XML visités par le filtre.</span><span class="sxs-lookup"><span data-stu-id="23e8f-521">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="23e8f-522">N'utilisez pas les expressions XPath qui peuvent nécessiter beaucoup de temps de calcul sans pour autant visiter de nombreux nœuds.</span><span class="sxs-lookup"><span data-stu-id="23e8f-522">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="23e8f-523">En général, lorsque vous utilisez un composant qui accepte un quota, comprenez ses implications en matière de sécurité et affectez-lui une valeur sûre.</span><span class="sxs-lookup"><span data-stu-id="23e8f-523">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="23e8f-524">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="23e8f-524">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="23e8f-525">Types connus de contrats de données</span><span class="sxs-lookup"><span data-stu-id="23e8f-525">Data Contract Known Types</span></span>](data-contract-known-types.md)
