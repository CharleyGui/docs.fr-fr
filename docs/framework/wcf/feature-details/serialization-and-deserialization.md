---
title: Sérialisation et désérialisation
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
ms.openlocfilehash: cf68834c5612ed51fb3e6c0ed18667cbc13482bc
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64586217"
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="bf84a-102">Sérialisation et désérialisation</span><span class="sxs-lookup"><span data-stu-id="bf84a-102">Serialization and Deserialization</span></span>
<span data-ttu-id="bf84a-103">Windows Communication Foundation (WCF) inclut un nouveau moteur de sérialisation, le <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="bf84a-103">Windows Communication Foundation (WCF) includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="bf84a-104">Le <xref:System.Runtime.Serialization.DataContractSerializer> traduit des objets [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] en langage XML et inversement.</span><span class="sxs-lookup"><span data-stu-id="bf84a-104">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects and XML, in both directions.</span></span> <span data-ttu-id="bf84a-105">Cette rubrique explique comment le sérialiseur fonctionne.</span><span class="sxs-lookup"><span data-stu-id="bf84a-105">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="bf84a-106">Lors de la sérialisation d'objets [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] , le sérialiseur interprète divers modèles de programmation de sérialisation, y compris le nouveau modèle de *contrat de données* .</span><span class="sxs-lookup"><span data-stu-id="bf84a-106">When serializing [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="bf84a-107">Pour obtenir une liste complète des types pris en charge, consultez [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="bf84a-107">For a full list of supported types, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="bf84a-108">Pour obtenir une introduction aux contrats de données, consultez [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="bf84a-108">For an introduction to data contracts, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="bf84a-109">Lors de la désérialisation du XML, le sérialiseur utilise les classes <xref:System.Xml.XmlReader> et <xref:System.Xml.XmlWriter> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-109">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="bf84a-110">Il prend également en charge la <xref:System.Xml.XmlDictionaryReader> et <xref:System.Xml.XmlDictionaryWriter> classes pour lui permettre de produire le XML optimisé dans certains cas, notamment lors de l’aide de XML binaire WCF format.</span><span class="sxs-lookup"><span data-stu-id="bf84a-110">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</span></span>  
  
 <span data-ttu-id="bf84a-111">WCF inclut également un sérialiseur auxiliaire, le <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="bf84a-111">WCF also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="bf84a-112">Le sérialiseur <xref:System.Runtime.Serialization.NetDataContractSerializer> est semblable aux sérialiseurs <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> et <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> parce qu'il émet également des noms de type [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] dans le cadre des données sérialisées.</span><span class="sxs-lookup"><span data-stu-id="bf84a-112">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type names as part of the serialized data.</span></span> <span data-ttu-id="bf84a-113">Il est utilisé lorsque les mêmes types sont partagés sur les fins de sérialisation et de désérialisation.</span><span class="sxs-lookup"><span data-stu-id="bf84a-113">It is used when the same types are shared on the serializing and the deserializing ends.</span></span> <span data-ttu-id="bf84a-114">Les <xref:System.Runtime.Serialization.DataContractSerializer> et <xref:System.Runtime.Serialization.NetDataContractSerializer> dérivent d'une classe de base commune, <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span><span class="sxs-lookup"><span data-stu-id="bf84a-114">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, the <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="bf84a-115"><xref:System.Runtime.Serialization.DataContractSerializer> sérialise les chaînes contenant des caractères de contrôle avec une valeur hexadécimale inférieure à 20 comme entités XML.</span><span class="sxs-lookup"><span data-stu-id="bf84a-115">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="bf84a-116">Cela peut entraîner un problème avec un client non-WCF lors de l’envoi de ces données à un service WCF.</span><span class="sxs-lookup"><span data-stu-id="bf84a-116">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="bf84a-117">Création d'une instance DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="bf84a-117">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="bf84a-118">Construire une instance du <xref:System.Runtime.Serialization.DataContractSerializer> est une étape importante.</span><span class="sxs-lookup"><span data-stu-id="bf84a-118">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="bf84a-119">Après la construction, vous ne pouvez pas en modifier les paramètres.</span><span class="sxs-lookup"><span data-stu-id="bf84a-119">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="bf84a-120">Spécification du type racine</span><span class="sxs-lookup"><span data-stu-id="bf84a-120">Specifying the Root Type</span></span>  
 <span data-ttu-id="bf84a-121">Le *type de racine* est le type à partir duquel les instances sont sérialisées ou désérialisées.</span><span class="sxs-lookup"><span data-stu-id="bf84a-121">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="bf84a-122">Le <xref:System.Runtime.Serialization.DataContractSerializer> a de nombreuses surcharges de constructeur, mais, au minimum, un type racine doit être fourni à l'aide du paramètre `type` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-122">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="bf84a-123">Un sérialiseur créé pour un certain type de racine ne peut pas être utilisé pour sérialiser (ou désérialiser) un autre type, sauf si le type est dérivé du type racine.</span><span class="sxs-lookup"><span data-stu-id="bf84a-123">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="bf84a-124">L'exemple suivant illustre deux classes.</span><span class="sxs-lookup"><span data-stu-id="bf84a-124">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="bf84a-125">Ce code construit une instance du `DataContractSerializer` qui peut être utilisée uniquement pour sérialiser ou désérialiser des instances de la classe `Person` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-125">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="bf84a-126">Spécification de types connus</span><span class="sxs-lookup"><span data-stu-id="bf84a-126">Specifying Known Types</span></span>  
 <span data-ttu-id="bf84a-127">Si le polymorphisme affecte les types qui sont sérialisés et n'est pas déjà géré par l'attribut <xref:System.Runtime.Serialization.KnownTypeAttribute> ou un autre mécanisme, une liste de types connus possibles doit être passée au constructeur du sérialiseur à l'aide du paramètre `knownTypes` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-127">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> <span data-ttu-id="bf84a-128">Pour plus d’informations sur les types connus, consultez [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="bf84a-128">For more information about known types, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="bf84a-129">L'exemple suivant affiche une classe, `LibraryPatron`, qui inclut une collection d'un type spécifique, le `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="bf84a-129">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="bf84a-130">La deuxième classe définit le type `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-130">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="bf84a-131">Les troisième et quatrième classes (`Book` et `Newspaper`) héritent de la classe `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-131">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="bf84a-132">Le code suivant construit une instance du sérialiseur à l'aide du paramètre `knownTypes` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-132">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="bf84a-133">Spécification de l'espace de nom et du nom racine par défaut</span><span class="sxs-lookup"><span data-stu-id="bf84a-133">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="bf84a-134">Normalement, lorsqu'un objet est sérialisé, l'espace de noms et le nom par défaut de l'élément XML le plus à l'extérieur sont déterminés d'après l'espace de noms et le nom de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="bf84a-134">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="bf84a-135">Les noms de tous les éléments internes sont déterminés à partir des noms de membre de données, et leur espace de noms est l'espace de noms du contrat de données.</span><span class="sxs-lookup"><span data-stu-id="bf84a-135">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="bf84a-136">L'exemple suivant définit les valeurs `Name` et `Namespace` dans les constructeurs des classes <xref:System.Runtime.Serialization.DataContractAttribute> et <xref:System.Runtime.Serialization.DataMemberAttribute> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-136">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="bf84a-137">La sérialisation d'une instance de la classe `Person` produit du XML semblable aux éléments suivants.</span><span class="sxs-lookup"><span data-stu-id="bf84a-137">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="bf84a-138">Toutefois, vous pouvez personnaliser le nom et l'espace de noms par défaut de l'élément racine en passant les valeurs des paramètres `rootName` et `rootNamespace` au constructeur <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-138">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="bf84a-139">Notez que le `rootNamespace` n'affecte pas l'espace de noms des éléments contenus qui correspondent aux membres de données.</span><span class="sxs-lookup"><span data-stu-id="bf84a-139">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="bf84a-140">Il affecte uniquement l'espace de noms de l'élément le plus à l'extérieur.</span><span class="sxs-lookup"><span data-stu-id="bf84a-140">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="bf84a-141">Ces valeurs peuvent être passées comme chaînes ou instances de la classe <xref:System.Xml.XmlDictionaryString> pour permettre leur optimisation à l'aide du format XML binaire.</span><span class="sxs-lookup"><span data-stu-id="bf84a-141">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="bf84a-142">Définition du quota d'objets maximal</span><span class="sxs-lookup"><span data-stu-id="bf84a-142">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="bf84a-143">Certaines surcharges de constructeur `DataContractSerializer` ont un paramètre `maxItemsInObjectGraph` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-143">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="bf84a-144">Ce paramètre détermine le nombre maximal d'objets que le sérialiseur sérialise ou désérialise dans un appel de méthode <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> unique.</span><span class="sxs-lookup"><span data-stu-id="bf84a-144">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="bf84a-145">(La méthode lit toujours un objet racine, mais cet objet peut avoir d'autres objets dans ses membres de données.</span><span class="sxs-lookup"><span data-stu-id="bf84a-145">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="bf84a-146">Ces objets peuvent avoir d'autres objets, et ainsi de suite.) La valeur par défaut est 65536.</span><span class="sxs-lookup"><span data-stu-id="bf84a-146">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="bf84a-147">Notez qu'en matière de sérialisation ou de désérialisation de tableaux, chaque entrée de tableau compte comme un objet distinct.</span><span class="sxs-lookup"><span data-stu-id="bf84a-147">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="bf84a-148">Notez également que certains objets ont une grande représentation de mémoire, de sorte que ce quota peut ne pas suffire pour empêcher les attaques par déni de service.</span><span class="sxs-lookup"><span data-stu-id="bf84a-148">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> <span data-ttu-id="bf84a-149">Pour plus d’informations, consultez [considérations de sécurité pour les données](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="bf84a-149">For more information, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span> <span data-ttu-id="bf84a-150">Si vous devez augmenter ce quota au delà de la valeur par défaut, il est important de le faire sur l'émission (sérialisation) et la réception (désérialisation) étant donné qu'il s'applique à la fois à la lecture et à l'écriture des données.</span><span class="sxs-lookup"><span data-stu-id="bf84a-150">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="bf84a-151">Allers-retours</span><span class="sxs-lookup"><span data-stu-id="bf84a-151">Round Trips</span></span>  
 <span data-ttu-id="bf84a-152">Un *aller-retour* se produit lorsqu'un objet est désérialisé et ré-sérialisé dans une opération.</span><span class="sxs-lookup"><span data-stu-id="bf84a-152">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="bf84a-153">Ainsi, celui-ci passe du format XML à une instance d'objet, puis est reconverti en un flux de données XML.</span><span class="sxs-lookup"><span data-stu-id="bf84a-153">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="bf84a-154">Certaines surcharges de constructeur `DataContractSerializer` ont un paramètre `ignoreExtensionDataObject` , affecté par défaut de la valeur `false` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-154">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="bf84a-155">Dans ce mode par défaut, les données peuvent être envoyées sur un aller-retour d'une version plus récente d'un contrat de données via une version antérieure puis retournées vers la version plus récente sans perte, à condition que le contrat de données implémente l'interface <xref:System.Runtime.Serialization.IExtensibleDataObject> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-155">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="bf84a-156">Par exemple, supposons que la version 1 du contrat de données `Person` contient les membres de données `Name` et `PhoneNumber` , et la version 2 ajoute un membre `Nickname` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-156">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="bf84a-157">Si `IExtensibleDataObject` est implémenté, lors de l'envoi d'informations de la version 2 à la version 1, les données `Nickname` sont stockées, et puis sont ré-émises lorsque les données sont encore sérialisées ; par conséquent, aucune donnée n'est perdue au cours de l'aller-retour.</span><span class="sxs-lookup"><span data-stu-id="bf84a-157">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> <span data-ttu-id="bf84a-158">Pour plus d’informations, consultez [les contrats de données de compatibilité ascendante](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) et [concernant les contrats de données](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="bf84a-158">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) and [Data Contract Versioning](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="bf84a-159">Problèmes liés à la sécurité et à la validation de schéma avec les allers-retours</span><span class="sxs-lookup"><span data-stu-id="bf84a-159">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="bf84a-160">Les allers-retours peuvent avoir des conséquences sur la sécurité.</span><span class="sxs-lookup"><span data-stu-id="bf84a-160">Round trips may have security implications.</span></span> <span data-ttu-id="bf84a-161">Par exemple, la désérialisation et le stockage de grandes quantités de données superflues peuvent présenter un risque pour la sécurité.</span><span class="sxs-lookup"><span data-stu-id="bf84a-161">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="bf84a-162">Il peut y avoir des problèmes de sécurité invérifiables pour ré-émettre ces données, surtout si les signatures numériques sont concernées.</span><span class="sxs-lookup"><span data-stu-id="bf84a-162">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="bf84a-163">Par exemple, dans le scénario précédent, le point de terminaison version 1 peut signer une valeur `Nickname` qui contient des données malveillantes.</span><span class="sxs-lookup"><span data-stu-id="bf84a-163">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="bf84a-164">Enfin, il peut y avoir des problèmes concernant la validité du schéma : un point de terminaison peut toujours émettre des données qui sont strictement conformes à son contrat défini et aucune valeur supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="bf84a-164">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="bf84a-165">Dans l'exemple précédent, la version 1 du contrat de point de terminaison indique qu'il émet uniquement `Name` et `PhoneNumber`, et si la validation de schéma est utilisée, l'émission de la valeur `Nickname` supplémentaire fait échouer la validation.</span><span class="sxs-lookup"><span data-stu-id="bf84a-165">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="bf84a-166">Activation et désactivation de allers-retours</span><span class="sxs-lookup"><span data-stu-id="bf84a-166">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="bf84a-167">Pour désactiver les allers-retours, n'implémentez pas l'interface <xref:System.Runtime.Serialization.IExtensibleDataObject> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-167">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="bf84a-168">Si vous n'avez aucun contrôle sur les types, affectez au paramètre `ignoreExtensionDataObject` la valeur `true` pour accomplir le même effet.</span><span class="sxs-lookup"><span data-stu-id="bf84a-168">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="bf84a-169">Conservation de graphique d'objet</span><span class="sxs-lookup"><span data-stu-id="bf84a-169">Object Graph Preservation</span></span>  
 <span data-ttu-id="bf84a-170">Normalement, le sérialiseur ne se soucie pas de l'identité d'objet, comme dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="bf84a-170">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="bf84a-171">Le code suivant crée un bon de commande.</span><span class="sxs-lookup"><span data-stu-id="bf84a-171">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="bf84a-172">Remarquez que les champs `billTo` et `shipTo` ont pour valeur la même instance d'objet.</span><span class="sxs-lookup"><span data-stu-id="bf84a-172">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="bf84a-173">Toutefois, le XML généré duplique les informations dupliquées et ressemble au XML suivant.</span><span class="sxs-lookup"><span data-stu-id="bf84a-173">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="bf84a-174">Toutefois, cette approche a les caractéristiques suivantes, qui peuvent être indésirables :</span><span class="sxs-lookup"><span data-stu-id="bf84a-174">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
- <span data-ttu-id="bf84a-175">Performances.</span><span class="sxs-lookup"><span data-stu-id="bf84a-175">Performance.</span></span> <span data-ttu-id="bf84a-176">Répliquer des données est inefficace.</span><span class="sxs-lookup"><span data-stu-id="bf84a-176">Replicating data is inefficient.</span></span>  
  
- <span data-ttu-id="bf84a-177">Références circulaires.</span><span class="sxs-lookup"><span data-stu-id="bf84a-177">Circular references.</span></span> <span data-ttu-id="bf84a-178">Si les objets font référence à eux-mêmes, même par le biais d'autres objets, la sérialisation par réplication crée une boucle infinie.</span><span class="sxs-lookup"><span data-stu-id="bf84a-178">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="bf84a-179">(Dans ce cas, le sérialiseur lève une exception <xref:System.Runtime.Serialization.SerializationException> .)</span><span class="sxs-lookup"><span data-stu-id="bf84a-179">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
- <span data-ttu-id="bf84a-180">Sémantique.</span><span class="sxs-lookup"><span data-stu-id="bf84a-180">Semantics.</span></span> <span data-ttu-id="bf84a-181">Parfois, il est important de conserver le fait qu'il existe deux références au même objet, et pas à deux objets identiques.</span><span class="sxs-lookup"><span data-stu-id="bf84a-181">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="bf84a-182">Pour ces raisons, certaines surcharges de constructeur `DataContractSerializer` ont un paramètre `preserveObjectReferences` (la valeur par défaut est `false`).</span><span class="sxs-lookup"><span data-stu-id="bf84a-182">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="bf84a-183">Lorsque ce paramètre est défini sur `true`, une méthode spéciale de codage des références d’objet uniquement WCF comprend, est utilisée.</span><span class="sxs-lookup"><span data-stu-id="bf84a-183">When this parameter is set to `true`, a special method of encoding object references, which only WCF understands, is used.</span></span> <span data-ttu-id="bf84a-184">Lorsque le paramètre a la valeur `true`, l'exemple de code XML ressemble aux éléments suivants.</span><span class="sxs-lookup"><span data-stu-id="bf84a-184">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="bf84a-185">L’espace de noms « ser » fait référence à l’espace de noms standard de sérialisation `http://schemas.microsoft.com/2003/10/Serialization/`.</span><span class="sxs-lookup"><span data-stu-id="bf84a-185">The "ser" namespace refers to the standard serialization namespace, `http://schemas.microsoft.com/2003/10/Serialization/`.</span></span> <span data-ttu-id="bf84a-186">Chaque portion de données est sérialisée une seule fois seulement et reçoit un numéro d'ID, et les utilisations ultérieures génèrent une référence aux données déjà sérialisées.</span><span class="sxs-lookup"><span data-stu-id="bf84a-186">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="bf84a-187">Si à la fois, les attributs id et ref sont présents dans le contrat de données `XMLElement`, l'attribut ref est honoré tandis que l'attribut id est ignoré.</span><span class="sxs-lookup"><span data-stu-id="bf84a-187">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="bf84a-188">Il est important de comprendre les limitations de ce mode :</span><span class="sxs-lookup"><span data-stu-id="bf84a-188">It is important to understand the limitations of this mode:</span></span>  
  
- <span data-ttu-id="bf84a-189">Le XML que `DataContractSerializer` produit avec `preserveObjectReferences` affecté de la valeur `true` n'est pas interopérable avec les autres technologies et n'est accessible qu'à une autre instance `DataContractSerializer` , également avec `preserveObjectReferences` affecté de la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="bf84a-189">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
- <span data-ttu-id="bf84a-190">Il n'existe aucune prise en charge des métadonnées (schéma) pour cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="bf84a-190">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="bf84a-191">Le schéma produit est uniquement valide lorsque `preserveObjectReferences` a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="bf84a-191">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
- <span data-ttu-id="bf84a-192">Cette fonctionnalité peut entraîner une exécution plus lente du processus de sérialisation et de désérialisation.</span><span class="sxs-lookup"><span data-stu-id="bf84a-192">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="bf84a-193">Même si les données ne doivent pas à être répliquées, les comparaisons d'objet supplémentaires doivent être effectuées dans ce mode.</span><span class="sxs-lookup"><span data-stu-id="bf84a-193">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="bf84a-194">Lorsque le mode `preserveObjectReferences` est activé, il est particulièrement important d'affecter à la valeur `maxItemsInObjectGraph` le quota correct.</span><span class="sxs-lookup"><span data-stu-id="bf84a-194">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="bf84a-195">En raison du traitement des tableaux dans ce mode, il est facile pour un intrus de construire un message malveillant de petite taille qui entraîne une consommation importante de la mémoire limitée uniquement par le quota `maxItemsInObjectGraph` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-195">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="bf84a-196">Spécification d'un substitut de contrat de données</span><span class="sxs-lookup"><span data-stu-id="bf84a-196">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="bf84a-197">Certaines surcharges de constructeur `DataContractSerializer` ont un paramètre `dataContractSurrogate` qui peut avoir la valeur `null`.</span><span class="sxs-lookup"><span data-stu-id="bf84a-197">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="bf84a-198">Sinon, vous pouvez l'utiliser pour spécifier un *substitut de contrat de données*qui est un type qui implémente l'interface <xref:System.Runtime.Serialization.IDataContractSurrogate> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-198">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="bf84a-199">Vous pouvez utiliser ensuite l'interface pour personnaliser le processus de sérialisation et de désérialisation.</span><span class="sxs-lookup"><span data-stu-id="bf84a-199">You can then use the interface to customize the serialization and deserialization process.</span></span> <span data-ttu-id="bf84a-200">Pour plus d’informations, consultez [substituts de contrats de données](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).</span><span class="sxs-lookup"><span data-stu-id="bf84a-200">For more information, see [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="bf84a-201">Sérialisation</span><span class="sxs-lookup"><span data-stu-id="bf84a-201">Serialization</span></span>  
 <span data-ttu-id="bf84a-202">Les informations suivantes s'appliquent à toute classe qui hérite du <xref:System.Runtime.Serialization.XmlObjectSerializer>, y compris les classes <xref:System.Runtime.Serialization.DataContractSerializer> et <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-202">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="bf84a-203">Sérialisation simple</span><span class="sxs-lookup"><span data-stu-id="bf84a-203">Simple Serialization</span></span>  
 <span data-ttu-id="bf84a-204">La méthode la plus simple pour sérialiser un objet est de le passer à la méthode <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-204">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="bf84a-205">Il y a trois surcharges, chacune pour écrire dans un <xref:System.IO.Stream>, un <xref:System.Xml.XmlWriter>ou un <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="bf84a-205">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="bf84a-206">Avec la surcharge <xref:System.IO.Stream> , la sortie est XML dans l'encodage UTF-8.</span><span class="sxs-lookup"><span data-stu-id="bf84a-206">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="bf84a-207">Avec la surcharge <xref:System.Xml.XmlDictionaryWriter> , le sérialiseur optimise sa sortie pour le XML binaire.</span><span class="sxs-lookup"><span data-stu-id="bf84a-207">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="bf84a-208">Lorsque vous utilisez le <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> (méthode), le sérialiseur utilise le nom par défaut et l’espace de noms pour l’élément wrapper et l’écrit, ainsi que le contenu (voir la section précédente « Spécifiant la valeur par défaut racine nom et Namespace »).</span><span class="sxs-lookup"><span data-stu-id="bf84a-208">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="bf84a-209">L'exemple de code suivant illustre l'écriture avec un <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="bf84a-209">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="bf84a-210">Elle produit du XML similaire au code suivant.</span><span class="sxs-lookup"><span data-stu-id="bf84a-210">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="bf84a-211">Sérialisation pas à pas</span><span class="sxs-lookup"><span data-stu-id="bf84a-211">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="bf84a-212">Utilisez les méthodes <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>et <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> pour écrire l'élément de fin, écrivez le contenu d'objet et fermez l'élément wrapper, respectivement.</span><span class="sxs-lookup"><span data-stu-id="bf84a-212">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bf84a-213">Il n'y a pas de surcharges <xref:System.IO.Stream> de ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="bf84a-213">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="bf84a-214">Cette sérialisation pas à pas fait l'objet de deux utilisations courantes.</span><span class="sxs-lookup"><span data-stu-id="bf84a-214">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="bf84a-215">La première est d'insérer du contenu tel que des attributs ou des commentaires entre `WriteStartObject` et `WriteObjectContent`, comme indiqué dans l'exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="bf84a-215">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="bf84a-216">Elle produit du XML similaire au code suivant.</span><span class="sxs-lookup"><span data-stu-id="bf84a-216">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="bf84a-217">L'autre utilisation courante est d'éviter l'utilisation complète de <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> et <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> , et d'écrire votre propre élément wrapper personnalisé (voir d'ignorer entièrement l'écriture d'un wrapper), comme indiqué dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="bf84a-217">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="bf84a-218">Elle produit du XML similaire au code suivant.</span><span class="sxs-lookup"><span data-stu-id="bf84a-218">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
>  <span data-ttu-id="bf84a-219">L'utilisation de la sérialisation pas à pas peut générer du XML de schéma non valide.</span><span class="sxs-lookup"><span data-stu-id="bf84a-219">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="bf84a-220">Désérialisation</span><span class="sxs-lookup"><span data-stu-id="bf84a-220">Deserialization</span></span>  
 <span data-ttu-id="bf84a-221">Les informations suivantes s'appliquent à toute classe qui hérite du <xref:System.Runtime.Serialization.XmlObjectSerializer>, y compris les classes <xref:System.Runtime.Serialization.DataContractSerializer> et <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-221">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="bf84a-222">La méthode la plus simple pour désérialiser un objet est d'appeler l'une des surcharges de méthode <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-222">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="bf84a-223">Il y a trois surcharges, chacune pour lire avec un <xref:System.Xml.XmlDictionaryReader>, un `XmlReader`ou un `Stream`.</span><span class="sxs-lookup"><span data-stu-id="bf84a-223">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="bf84a-224">Notez que la surcharge `Stream` crée un <xref:System.Xml.XmlDictionaryReader> textuel qui n'est pas protégé par des quotas, et doit être utilisé uniquement pour lire des données approuvées.</span><span class="sxs-lookup"><span data-stu-id="bf84a-224">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="bf84a-225">Notez également que l'objet retourné par la méthode `ReadObject` doivent être converti au type approprié.</span><span class="sxs-lookup"><span data-stu-id="bf84a-225">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="bf84a-226">Le code suivant construit une instance du <xref:System.Runtime.Serialization.DataContractSerializer> et d'un <xref:System.Xml.XmlDictionaryReader>, puis désérialise une instance `Person` .</span><span class="sxs-lookup"><span data-stu-id="bf84a-226">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="bf84a-227">Avant d'appeler la méthode <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> , positionnez le lecteur XML sur l'élément wrapper ou sur un nœud qui n'est pas un nœud de contenu qui précède l'élément wrapper.</span><span class="sxs-lookup"><span data-stu-id="bf84a-227">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="bf84a-228">Pour ce faire, appelez la méthode <xref:System.Xml.XmlReader.Read%2A> du <xref:System.Xml.XmlReader> ou sa dérivation, et testez le <xref:System.Xml.XmlReader.NodeType%2A>, comme indiquez dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="bf84a-228">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="bf84a-229">Notez que vous pouvez lire des attributs sur cet élément wrapper avant de passer le lecteur à `ReadObject`.</span><span class="sxs-lookup"><span data-stu-id="bf84a-229">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="bf84a-230">Lorsque vous utilisez une des simple `ReadObject` surcharges, le désérialiseur recherche le nom par défaut et l’espace de noms sur l’élément wrapper (voir la section précédente, « Spécifiant la valeur par défaut racine nom et Namespace ») et lève une exception s’il en trouve une inconnue élément.</span><span class="sxs-lookup"><span data-stu-id="bf84a-230">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="bf84a-231">Dans l'exemple précédent, l'élément wrapper `<Person>` est attendu.</span><span class="sxs-lookup"><span data-stu-id="bf84a-231">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="bf84a-232">La méthode <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> est appelée pour vérifier que le lecteur est positionné sur un élément dont le nom est attendu.</span><span class="sxs-lookup"><span data-stu-id="bf84a-232">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="bf84a-233">Une méthode permet de désactiver ce contrôle du nom de l'élément wrapper ; certaines surcharges de la méthode `ReadObject` acceptent le paramètre booléen `verifyObjectName`qui la valeur `true` par défaut.</span><span class="sxs-lookup"><span data-stu-id="bf84a-233">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="bf84a-234">Lorsqu'il a la valeur `false`, le nom et l'espace de noms de l'élément wrapper sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="bf84a-234">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="bf84a-235">Ce procédé est utile pour lire le XML écrit à l'aide du mécanisme de sérialisation pas à pas décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="bf84a-235">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="bf84a-236">Utilisation de NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="bf84a-236">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="bf84a-237">La différence principale entre `DataContractSerializer` et <xref:System.Runtime.Serialization.NetDataContractSerializer> est que `DataContractSerializer` utilise des noms de contrat de données, alors que `NetDataContractSerializer` génère des noms de types et d'assembly [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] complets dans le XML sérialisé.</span><span class="sxs-lookup"><span data-stu-id="bf84a-237">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] assembly and type names in the serialized XML.</span></span> <span data-ttu-id="bf84a-238">Cela signifie que les mêmes types exacts doivent être partagés entre les points de terminaison de sérialisation et de désérialisation.</span><span class="sxs-lookup"><span data-stu-id="bf84a-238">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="bf84a-239">Cela signifie que le mécanisme de types connus n'est pas requis avec `NetDataContractSerializer` parce que les types exacts à désérialiser sont toujours connus.</span><span class="sxs-lookup"><span data-stu-id="bf84a-239">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="bf84a-240">Toutefois, plusieurs problèmes peuvent se produire :</span><span class="sxs-lookup"><span data-stu-id="bf84a-240">However, several problems can occur:</span></span>  
  
- <span data-ttu-id="bf84a-241">Sécurité.</span><span class="sxs-lookup"><span data-stu-id="bf84a-241">Security.</span></span> <span data-ttu-id="bf84a-242">Tout type trouvé dans le XML désérialisé est chargé.</span><span class="sxs-lookup"><span data-stu-id="bf84a-242">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="bf84a-243">Cela peut être exploité pour forcer le chargement de types malveillants.</span><span class="sxs-lookup"><span data-stu-id="bf84a-243">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="bf84a-244">L'utilisation de `NetDataContractSerializer` avec des données non fiables doit s'effectuer uniquement si un *binder de sérialisation* est utilisé (à l'aide de la propriété ou du paramètre de constructeur <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> ).</span><span class="sxs-lookup"><span data-stu-id="bf84a-244">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="bf84a-245">Le binder autorise uniquement le chargement des types sûrs.</span><span class="sxs-lookup"><span data-stu-id="bf84a-245">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="bf84a-246">Le mécanisme de binder est identique à celui utilisé par les types dans l'espace de noms <xref:System.Runtime.Serialization> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-246">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
- <span data-ttu-id="bf84a-247">Contrôle de version.</span><span class="sxs-lookup"><span data-stu-id="bf84a-247">Versioning.</span></span> <span data-ttu-id="bf84a-248">L'utilisation des noms de type et d'assembly complets dans le XML limite fortement la gestion de la version des types.</span><span class="sxs-lookup"><span data-stu-id="bf84a-248">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="bf84a-249">Les éléments suivants ne peuvent pas être modifiés : noms de type, espaces de noms, noms d'assembly et versions d'assembly.</span><span class="sxs-lookup"><span data-stu-id="bf84a-249">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="bf84a-250">Affecter à la propriété ou au paramètre de constructeur <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> la valeur <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> au lieu de la valeur par défaut de <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> permet de modifier la version des assemblys, mais pas des types de paramètre génériques.</span><span class="sxs-lookup"><span data-stu-id="bf84a-250">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
- <span data-ttu-id="bf84a-251">Interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="bf84a-251">Interoperability.</span></span> <span data-ttu-id="bf84a-252">Comme les noms d'assembly et de type [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] sont inclus dans le XML, les plateformes autres que le [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] ne peuvent pas accéder aux données résultantes.</span><span class="sxs-lookup"><span data-stu-id="bf84a-252">Because [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type and assembly names are included in the XML, platforms other than the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] cannot access the resulting data.</span></span>  
  
- <span data-ttu-id="bf84a-253">Performances.</span><span class="sxs-lookup"><span data-stu-id="bf84a-253">Performance.</span></span> <span data-ttu-id="bf84a-254">L'écriture des noms de type et d'assembly augmente nettement la taille du XML résultant.</span><span class="sxs-lookup"><span data-stu-id="bf84a-254">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="bf84a-255">Ce mécanisme est semblable à la sérialisation binaire ou SOAP utilisée par [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] Remoting (en particulier, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> et <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span><span class="sxs-lookup"><span data-stu-id="bf84a-255">This mechanism is similar to binary or SOAP serialization used by [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="bf84a-256">L'utilisation du `NetDataContractSerializer` est semblable à l'utilisation du `DataContractSerializer`, avec les différences suivantes :</span><span class="sxs-lookup"><span data-stu-id="bf84a-256">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
- <span data-ttu-id="bf84a-257">Les constructeurs n'exigent pas de spécifier un type racine.</span><span class="sxs-lookup"><span data-stu-id="bf84a-257">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="bf84a-258">Vous pouvez sérialiser tout type avec la même instance du `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="bf84a-258">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
- <span data-ttu-id="bf84a-259">Les constructeurs n'acceptent pas une liste de types connus.</span><span class="sxs-lookup"><span data-stu-id="bf84a-259">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="bf84a-260">Le mécanisme de types connus est inutile si les noms de type sont sérialisés dans le XML.</span><span class="sxs-lookup"><span data-stu-id="bf84a-260">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
- <span data-ttu-id="bf84a-261">Les constructeurs n'acceptent pas de substitut de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="bf84a-261">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="bf84a-262">À la place, ils acceptent un paramètre <xref:System.Runtime.Serialization.ISurrogateSelector> appelé `surrogateSelector` (qui mappe à la propriété <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> ).</span><span class="sxs-lookup"><span data-stu-id="bf84a-262">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="bf84a-263">Il s'agit d'un mécanisme de remplacement hérité.</span><span class="sxs-lookup"><span data-stu-id="bf84a-263">This is a legacy surrogate mechanism.</span></span>  
  
- <span data-ttu-id="bf84a-264">Le constructeur accepte un paramètre appelé `assemblyFormat` du <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> qui mappe à la propriété <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-264">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="bf84a-265">Comme évoqué précédemment, cette opération peut servir à améliorer les fonctions de contrôle de version du sérialiseur.</span><span class="sxs-lookup"><span data-stu-id="bf84a-265">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="bf84a-266">Elle est identique au mécanisme <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> dans la sérialisation binaire ou SOAP.</span><span class="sxs-lookup"><span data-stu-id="bf84a-266">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
- <span data-ttu-id="bf84a-267">Les constructeurs acceptent un paramètre <xref:System.Runtime.Serialization.StreamingContext> appelé `context` qui mappe à la propriété <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-267">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="bf84a-268">Vous pouvez utiliser cela pour passer des informations dans les types qui sont sérialisés.</span><span class="sxs-lookup"><span data-stu-id="bf84a-268">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="bf84a-269">Cette utilisation est identique à celle du mécanisme <xref:System.Runtime.Serialization.StreamingContext> utilisé dans d'autres classes <xref:System.Runtime.Serialization> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-269">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
- <span data-ttu-id="bf84a-270">Les méthodes <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> et <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> sont des alias pour les méthodes <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> et <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="bf84a-270">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="bf84a-271">Elles existent pour fournir un modèle de programmation plus cohérent avec la sérialisation binaire ou SOAP.</span><span class="sxs-lookup"><span data-stu-id="bf84a-271">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 <span data-ttu-id="bf84a-272">Pour plus d’informations sur ces fonctionnalités, consultez [sérialisation binaire](../../../../docs/standard/serialization/binary-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="bf84a-272">For more information about these features, see [Binary Serialization](../../../../docs/standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="bf84a-273">Les formats XML utilisés par `NetDataContractSerializer` et `DataContractSerializer` ne sont pas normalement compatibles.</span><span class="sxs-lookup"><span data-stu-id="bf84a-273">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="bf84a-274">Autrement dit, toute tentative de sérialiser avec l'un de ces sérialiseurs et de désérialiser avec l'autre n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="bf84a-274">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="bf84a-275">De plus, notez que `NetDataContractSerializer` ne génère pas le nom de l'assembly et du type [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] complet pour chaque nœud dans le graphique d'objets.</span><span class="sxs-lookup"><span data-stu-id="bf84a-275">Also, note that the `NetDataContractSerializer` does not output the full [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="bf84a-276">Il génère ces informations uniquement en cas d'ambiguïté.</span><span class="sxs-lookup"><span data-stu-id="bf84a-276">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="bf84a-277">Autrement dit, il génère au niveau de l'objet racine et pour les cas polymorphes.</span><span class="sxs-lookup"><span data-stu-id="bf84a-277">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bf84a-278">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="bf84a-278">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.NetDataContractSerializer>
- <xref:System.Runtime.Serialization.XmlObjectSerializer>
- [<span data-ttu-id="bf84a-279">Sérialisation binaire</span><span class="sxs-lookup"><span data-stu-id="bf84a-279">Binary Serialization</span></span>](../../../../docs/standard/serialization/binary-serialization.md)
- [<span data-ttu-id="bf84a-280">Types pris en charge par le sérialiseur de contrat de données</span><span class="sxs-lookup"><span data-stu-id="bf84a-280">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
