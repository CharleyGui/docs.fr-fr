---
title: Données volumineuses et diffusion en continu
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 55001904557efa1c3136a4f619348296681986ed
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64585048"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="b5a1e-102">Données volumineuses et diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="b5a1e-102">Large Data and Streaming</span></span>
<span data-ttu-id="b5a1e-103">Windows Communication Foundation (WCF) est une infrastructure de communications basées sur XML.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-103">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="b5a1e-104">Étant donné que les données XML sont généralement codées au format texte standard défini dans le [spécification XML 1.0](https://go.microsoft.com/fwlink/?LinkId=94838), connecté les architectes et développeurs de systèmes sont généralement concernées par l’encombrement du câble (ou taille) de messages envoyés entre le réseau et l’encodage de texte du XML pose des défis particuliers pour le transfert efficace de données binaires.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-104">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://go.microsoft.com/fwlink/?LinkId=94838), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="b5a1e-105">Considérations de base</span><span class="sxs-lookup"><span data-stu-id="b5a1e-105">Basic Considerations</span></span>  
 <span data-ttu-id="b5a1e-106">Pour fournir des informations générales sur les informations suivantes pour WCF, cette section met en évidence certaines préoccupations et considérations générales pour les encodages, les données binaires, et la diffusion en continu générale qui s’appliquent aux infrastructures de systèmes connectés.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-106">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="b5a1e-107">Encodage de données : Visual Studio de texte. Binaire</span><span class="sxs-lookup"><span data-stu-id="b5a1e-107">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="b5a1e-108">Les préoccupations couramment exprimées par les développeurs incluent l’idée que le XML possède une charge mémoire considérable par rapport aux formats binaires en raison de la nature répétitive des étiquettes de début et de fin, que l’encodage de valeurs numériques est considéré comme nettement plus volumineux parce qu’elles sont exprimées en valeurs texte, et que ces données binaires ne peuvent pas être exprimées efficacement parce qu’elles doivent être encodées spécialement à des fins d’incorporation dans un format texte.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-108">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="b5a1e-109">Même si de nombreuses préoccupations comme celle-ci ainsi que d’autres sont justifiées, la différence réelle entre les messages à encodage texte XML dans un environnement de services web XML et les messages à encodage binaire dans un environnement d’appel de procédure distante (RPC) hérité est souvent beaucoup moins importante que la considération initiale peut le suggérer.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-109">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="b5a1e-110">Alors que les messages à encodage texte XML sont transparents et lisibles par l'utilisateur, les messages binaires sont souvent assez opaques en comparaison et difficiles à décoder sans outils.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-110">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="b5a1e-111">Cette différence de lisibilité amène à négliger le fait que ces messages binaires comportent aussi souvent des métadonnées inline dans la charge utile, ce qui ajoute une charge mémoire tout comme avec les messages texte XML.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-111">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="b5a1e-112">Ceci s'avère particulièrement vrai pour les formats binaires qui ont pour but de fournir des fonctionnalités de couplage faible et d'appel dynamique.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-112">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="b5a1e-113">Toutefois, les formats binaires comportent généralement ces métadonnées descriptives dans un « en-tête », qui déclare également le format de données pour les enregistrements de données suivants.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-113">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="b5a1e-114">La charge utile suit ensuite cette déclaration de blocs de métadonnées communes avec une charge mémoire supplémentaire minime.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-114">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="b5a1e-115">Par opposition, le XML englobe chaque élément de données dans un élément ou attribut afin que les métadonnées englobantes soient incluses de façon répétitive pour chaque objet de charge utile sérialisé.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-115">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="b5a1e-116">En conséquence, la taille d'un objet de charge utile sérialisé unique est semblable si vous comparez les représentations texte et binaires étant donné que des métadonnées descriptives doivent être exprimées pour les deux, mais le format binaire tire parti de la description des métadonnées partagées avec chaque objet de charge utile supplémentaire transféré en raison d'une charge mémoire totale inférieure.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-116">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="b5a1e-117">Pourtant, pour certains types de données, tels que les nombres, il peut exister un inconvénient à l'utilisation de représentations numériques binaires à taille fixe, telles qu'un type décimal de 128 bits au lieu du texte brut, car la représentation de texte brut peut être inférieure de plusieurs octets.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-117">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="b5a1e-118">Les données texte peuvent également présenter des avantages de taille par rapport au choix de l'encodage basé sur le texte XML en général plus flexible, alors que certains formats binaires peuvent être par défaut des formats Unicode à 16 bits ou même 32 bits, qui ne s'appliquent pas au format XML binaire .NET.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-118">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="b5a1e-119">Par conséquent, pour choisir le format texte ou le format binaire, il ne suffit pas de partir du principe que les messages binaires sont toujours plus petits que les messages texte XML.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-119">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="b5a1e-120">Un avantage net des messages texte XML est qu'ils sont basés sur des normes et qu'ils offrent le choix le plus large d'options d'interopérabilité et de prise en charge de plateformes.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-120">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="b5a1e-121">Pour plus d’informations, consultez la section « Encodages » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-121">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="b5a1e-122">Contenu binaire</span><span class="sxs-lookup"><span data-stu-id="b5a1e-122">Binary Content</span></span>  
 <span data-ttu-id="b5a1e-123">Un domaine dans lequel les encodages binaires sont supérieurs aux encodages basés sur le texte en termes de taille des messages obtenus concerne les éléments de données binaires volumineux tels que les photos, vidéos, clips audio ou tout autre forme de données binaires et opaques qui doivent être échangées entre des services et leurs consommateurs.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-123">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="b5a1e-124">Pour adapter ces types de données au texte XML, l'approche courante consiste à les encoder à l'aide d'un encodage Base64.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-124">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="b5a1e-125">Dans une chaîne encodée en Base64, chaque caractère représente 6 bits des données de 8 bits d'origine, ce qui donne un rapport encodage/charge mémoire de 4:3 pour Base64, en ne comptant pas les caractères de mise en forme supplémentaires (retour chariot/saut de ligne) habituellement ajoutés par convention.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-125">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="b5a1e-126">Alors que l'importance des différences entre les encodages XML et binaire dépend en général du scénario, un gain de taille de plus de 33 % lors d'une transmission d'une charge utile de 500 Mo n'est habituellement pas acceptable.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-126">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="b5a1e-127">Pour éviter cette charge lié à l'encodage, la norme MTOM (Message Transmission Optimization Mechanism) tient compte de l'extériorisation des éléments de données volumineux contenus dans un message et de leur transport avec le message en tant que données binaires sans encodage spécial.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-127">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="b5a1e-128">Avec MTOM, les messages sont échangés de manière similaire aux messages de courrier électronique SMTP Simple Mail Transfer Protocol () avec des pièces jointes ou du contenu incorporé (images et autre contenu incorporé) ; Les messages MTOM sont empaquetés sous forme de séquences MIME à parties multiples/associée avec la partie racine constituant le message SOAP réel.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-128">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="b5a1e-129">Un message SOAP MTOM est modifié par rapport à sa version non encodée afin que les balises d'éléments spéciales qui font référence aux parties MIME respectives prennent la place des éléments d'origine dans le message contenait des données binaires.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-129">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="b5a1e-130">En conséquence, le message SOAP fait référence au contenu binaire en pointant vers les parties MIME envoyées avec lui, mais sinon il transporte uniquement les données texte XML.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-130">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="b5a1e-131">Parce que ce modèle s'aligne étroitement sur le modèle SMTP bien établi, il existe une large prise en charge d'outils permettant d'encoder et de décoder les messages MTOM sur de nombreuses plateformes, ce qui en fait un choix extrêmement interopérable.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-131">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="b5a1e-132">Pour autant, comme avec Base64, MTOM s'accompagne également d'une charge mémoire nécessaire pour le format MIME, de sorte que les avantages de l'utilisation de MTOM s'aperçoivent uniquement quand la taille d'un élément de données binaires dépasse 1 Ko environ.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-132">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="b5a1e-133">En raison de la charge mémoire, les messages encodés MTOM peuvent être plus volumineux que les messages qui utilisent l'encodage Base64 pour les données binaires, si la charge utile binaire reste sous ce seuil.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-133">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="b5a1e-134">Pour plus d’informations, consultez la section « Encodages » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-134">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="b5a1e-135">Contenu de données volumineux</span><span class="sxs-lookup"><span data-stu-id="b5a1e-135">Large Data Content</span></span>  
 <span data-ttu-id="b5a1e-136">L'encombrement du câble mis de côté, la charge utile de 500 Mo précédemment mentionnée représente également un grand challenge local pour le service et le client.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-136">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="b5a1e-137">Par défaut, WCF traite les messages de *mode mémoire tampon*.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-137">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="b5a1e-138">Cela signifie que le contenu entier d'un message est présent en mémoire avant son envoi ou après sa réception.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-138">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="b5a1e-139">Alors qu’il s’agit d’une bonne stratégie pour la plupart des scénarios et qu’elle est nécessaire pour les fonctionnalités de messagerie telles que les signatures numériques et la remise fiable, les messages volumineux peuvent épuiser les ressources d’un système.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-139">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="b5a1e-140">La stratégie permettant de gérer les grandes charges utiles est la diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-140">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="b5a1e-141">Alors que les messages, surtout ceux exprimés en XML, sont généralement considérés comme des packages de données relativement compacts, un message peut avoir une taille de plusieurs giga-octets et ressembler à un flux de données continu plus qu'à un package de données.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-141">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="b5a1e-142">Lorsque les données sont transférées en mode de diffusion en continu plutôt qu'en mode mémoire tampon, l'expéditeur rend le contenu du corps du message disponible au destinataire sous la forme d'un flux, et l'infrastructure du message transfère en continu les données de l'expéditeur au destinataire au fur et à mesure de leur disponibilité.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-142">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="b5a1e-143">Le scénario le plus courant dans lequel de tels transferts de contenu de données volumineux se produisent implique les transferts d'objets de données binaires qui :</span><span class="sxs-lookup"><span data-stu-id="b5a1e-143">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="b5a1e-144">ne peuvent pas être facilement divisés en séquence de message ;</span><span class="sxs-lookup"><span data-stu-id="b5a1e-144">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="b5a1e-145">doivent être remis de façon opportune ;</span><span class="sxs-lookup"><span data-stu-id="b5a1e-145">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="b5a1e-146">ne sont pas disponibles dans leur intégralité lors de l'initialisation du transfert.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-146">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="b5a1e-147">Pour les données qui ne présentent pas ces contraintes, il est en général préférable d'envoyer des séquences de messages au sein de la portée d'une session plutôt qu'un message volumineux.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-147">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="b5a1e-148">Pour plus d’informations, consultez la section « Diffusion en continu des données » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-148">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="b5a1e-149">Lors de l’envoi de grandes quantités de données, vous devez définir le `maxAllowedContentLength` paramètre IIS (pour plus d’informations, consultez [configuration des limites de demande IIS](https://go.microsoft.com/fwlink/?LinkId=253165)) et le `maxReceivedMessageSize` paramètre de liaison (par exemple [ System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) ou <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span><span class="sxs-lookup"><span data-stu-id="b5a1e-149">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](https://go.microsoft.com/fwlink/?LinkId=253165)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="b5a1e-150">Le `maxAllowedContentLength` propriété par défaut 28,6 M et `maxReceivedMessageSize` propriété valeur par défaut est 64 Ko.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-150">The `maxAllowedContentLength` property defaults to 28.6 M and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="b5a1e-151">Encodages</span><span class="sxs-lookup"><span data-stu-id="b5a1e-151">Encodings</span></span>  
 <span data-ttu-id="b5a1e-152">Un *encodage* définit un ensemble de règles sur la façon de présenter des messages sur le câble.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-152">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="b5a1e-153">Un *encodeur* implémente un tel encodage et est responsable du côté expéditeur, pour activer les messages en mémoire <xref:System.ServiceModel.Channels.Message> dans un flux d’octets ou de la mémoire tampon d’octets qui peut être envoyé sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-153">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="b5a1e-154">Du côté destinataire, l'encodeur transforme une séquence d'octets en un message en mémoire.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-154">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="b5a1e-155">WCF inclut trois encodeurs et vous permet d’écrire et brancher vos propres encodeurs, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-155">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="b5a1e-156">Chacune des liaisons standard inclut un encodeur préconfiguré, selon lequel les liaisons avec le préfixe Net\* utilisent l’encodeur binaire (en incluant la classe <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>) pendant que les classes <xref:System.ServiceModel.BasicHttpBinding> et <xref:System.ServiceModel.WSHttpBinding> utilisent l’encodeur de message texte par défaut (au moyen de la classe <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>).</span><span class="sxs-lookup"><span data-stu-id="b5a1e-156">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="b5a1e-157">Élément de liaison d’encodeur</span><span class="sxs-lookup"><span data-stu-id="b5a1e-157">Encoder binding element</span></span>|<span data-ttu-id="b5a1e-158">Description</span><span class="sxs-lookup"><span data-stu-id="b5a1e-158">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="b5a1e-159">L’encodeur de message texte constitue l’encodeur par défaut de toutes les liaisons HTTP et le choix approprié pour toutes les liaisons personnalisées où l’interopérabilité est la première préoccupation.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-159">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="b5a1e-160">Cet encodeur lit et écrit les messages texte SOAP 1.1/SOAP 1.2 standard sans gestion spéciale des données binaires.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-160">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="b5a1e-161">Si le <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> propriété d’un message est définie sur <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, le wrapper d’enveloppe SOAP est omis de la sortie et seul le contenu du corps de message est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-161">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="b5a1e-162">L’encodeur de message MTOM est un encodeur de texte qui implémente une gestion spéciale pour les données binaires et qui n’est pas utilisé par défaut dans chacune des liaisons standard parce qu’il s’agit strictement d’un utilitaire d’optimisation au cas par cas.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-162">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="b5a1e-163">Si le message contient des données binaires qui dépassent un seuil auquel l'encodage MTOM apporte un avantage, les données sont externalisées dans une partie MIME qui suit l'enveloppe de message.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-163">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="b5a1e-164">Consultez le paragraphe Activation de MTOM plus loin dans cette section.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-164">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="b5a1e-165">L’encodeur de message binaire est l’encodeur par défaut pour les liaisons Net \* et le choix approprié chaque fois que les deux parties communicantes sont basées sur WCF.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-165">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="b5a1e-166">L'encodeur de message binaire utilise le format XML binaire .NET, une représentation binaire spécifique à Microsoft pour les jeux d'informations XML qui en général engendre un plus petit encombrement que la représentation XML 1.0 équivalente et qui encode les données binaires en un flux d'octets.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-166">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="b5a1e-167">L’encodage de message texte constitue en général le meilleur choix pour tout chemin de communication qui requiert une interopérabilité, alors que l’encodage de message binaire constitue le meilleur choix pour tous les autres chemins de communication.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-167">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="b5a1e-168">L'encodage de message binaire engendre généralement des tailles de message plus petites par rapport au texte d'un message unique et des tailles progressivement encore plus petites sur la durée d'une session de communication.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-168">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="b5a1e-169">À la différence de l'encodage de texte, l'encodage binaire ne doit pas utiliser une gestion spéciale pour les données binaires, telle que l'utilisation de Base64, mais il représente les octets comme des octets.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-169">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="b5a1e-170">Si votre solution ne requiert pas une interopérabilité, mais que vous souhaitez quand même utiliser le transport HTTP, vous pouvez composer un <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> dans une liaison personnalisée qui utilise la classe <xref:System.ServiceModel.Channels.HttpTransportBindingElement> pour le transport.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-170">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="b5a1e-171">Si plusieurs clients sur votre service ont besoin d'interopérabilité, il est recommandé d'exposer des points de terminaison parallèles qui ont tous le transport approprié et le choix de l'encodage pour les clients respectifs activés.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-171">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="b5a1e-172">Activation de MTOM</span><span class="sxs-lookup"><span data-stu-id="b5a1e-172">Enabling MTOM</span></span>  
 <span data-ttu-id="b5a1e-173">Lorsque l’interopérabilité est une exigence et que vous devez envoyer des données binaires volumineuses, l’encodage de message MTOM constitue la stratégie d’encodage alternative que vous pouvez activer sur les liaisons <xref:System.ServiceModel.BasicHttpBinding> ou <xref:System.ServiceModel.WSHttpBinding> standard en affectant à la propriété `MessageEncoding` respective la valeur <xref:System.ServiceModel.WSMessageEncoding.Mtom> ou en composant le <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> dans une <xref:System.ServiceModel.Channels.CustomBinding>.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-173">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="b5a1e-174">L’exemple de code suivant, extrait à partir de la [encodage MTOM](../../../../docs/framework/wcf/samples/mtom-encoding.md) exemple montre comment activer MTOM dans la configuration.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-174">The following example code, extracted from the [MTOM Encoding](../../../../docs/framework/wcf/samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="b5a1e-175">Comme mentionné précédemment, la décision d'utiliser l'encodage MTOM dépend du volume des données que vous envoyez.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-175">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="b5a1e-176">En outre, parce que MTOM est activé au niveau de la liaison, l'activation de MTOM a des répercussions sur toutes les opérations sur un point de terminaison donné.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-176">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="b5a1e-177">Étant donné que l'encodeur MTOM émet toujours un message MIME/multi-part encodé par MTOM, que les données binaires finissent par être externalisées ou non, vous devez en général activer MTOM uniquement pour les points de terminaison qui échangent des messages contenant plus de 1 Ko de données binaires.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-177">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="b5a1e-178">En outre, les contrats de service conçus pour une utilisation avec des points de terminaison activés pour MTOM doivent, lorsque cela est possible, être contraints à la spécification de telles opérations de transferts de données.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-178">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="b5a1e-179">Les fonctionnalités de contrôle associées doivent se trouver sur un contrat distinct.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-179">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="b5a1e-180">Cette règle « MTOM uniquement » s'applique uniquement aux messages envoyés via un point de terminaison activé pour MTOM. L'encodeur MTOM peut également décoder et analyser les messages non-MTOM entrants.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-180">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="b5a1e-181">À l’aide de l’encodeur MTOM est conforme avec toutes les autres fonctionnalités WCF.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-181">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="b5a1e-182">Notez qu'il peut ne pas être possible d'observer cette règle dans tous les cas, par exemple lorsque la prise en charge des sessions est requise.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-182">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="b5a1e-183">Modèle de programmation</span><span class="sxs-lookup"><span data-stu-id="b5a1e-183">Programming Model</span></span>  
 <span data-ttu-id="b5a1e-184">Quel que soit l'encodeur intégré que vous utilisiez dans votre application parmi les trois disponibles, l'expérience en matière de programmation est identique en ce qui concerne le transfert de données binaires.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-184">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="b5a1e-185">La différence réside dans la façon dont WCF gère les données en fonction de leurs types de données.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-185">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```  
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}   
```  
  
 <span data-ttu-id="b5a1e-186">Lors de l'utilisation de MTOM, le contrat de données précédent est sérialisé d'après les règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="b5a1e-186">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="b5a1e-187">Si `binaryBuffer` n'a pas la valeur `null` et contient individuellement assez de données pour justifier une charge mémoire d'externalisation MTOM (en-têtes MIME, et ainsi de suite) par rapport à un encodage Base64, les données sont externalisées et transportées avec le message en tant que partie MIME binaire.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-187">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="b5a1e-188">Si le seuil n'est pas dépassé, les données sont encodées en tant que Base64.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-188">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="b5a1e-189">La chaîne (et tous les autres types qui ne sont pas binaires) est toujours représentée comme une chaîne à l'intérieur du corps du message, indépendamment de sa taille.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-189">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="b5a1e-190">L'effet sur l'encodage MTOM est le même, que vous utilisiez un contrat de données explicite, comme indiqué dans l'exemple précédent, une liste de paramètres dans une opération, des contrats de données imbriqués ou que vous transfériez un objet de contrat de données dans une collection.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-190">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="b5a1e-191">Les tableaux d'octets sont toujours des candidats à l'optimisation et sont optimisés si les seuils d'optimisation sont atteints.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-191">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b5a1e-192">Vous ne devez pas utiliser des types dérivés <xref:System.IO.Stream?displayProperty=nameWithType> dans les contrats de données.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-192">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="b5a1e-193">Les données de flux doivent être communiquées à l'aide du modèle de diffusion en continu, expliqué dans la section « Diffusion en continu de données » ci-après.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-193">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="b5a1e-194">Diffusion en continu de données</span><span class="sxs-lookup"><span data-stu-id="b5a1e-194">Streaming Data</span></span>  
 <span data-ttu-id="b5a1e-195">Lorsque vous avez une grande quantité de données à transférer, le mode de transfert de diffusion en continu dans WCF est une alternative possible au comportement par défaut de la mise en mémoire tampon et le traitement des messages en mémoire dans leur intégralité.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-195">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="b5a1e-196">Comme mentionné précédemment, activez uniquement la diffusion en continu pour les messages volumineux (avec un contenu texte ou binaire) si les données ne peuvent pas être segmentées, si le message doit être remis en temps voulu ou si les données ne sont pas encore complètement disponibles au moment où le transfert est initialisé.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-196">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="b5a1e-197">Restrictions</span><span class="sxs-lookup"><span data-stu-id="b5a1e-197">Restrictions</span></span>  
 <span data-ttu-id="b5a1e-198">Vous ne pouvez pas utiliser un nombre important de fonctionnalités WCF lors de la diffusion en continu est activée :</span><span class="sxs-lookup"><span data-stu-id="b5a1e-198">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="b5a1e-199">Les signatures numériques pour le corps du message ne peuvent pas être effectuées parce qu'elles requièrent un calcul de hachage sur le contenu entier du message.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-199">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="b5a1e-200">Avec la diffusion en continu, le contenu n'est pas complètement disponible lorsque les en-têtes de message sont construits et envoyés et, par conséquent, une signature numérique ne peut pas être calculée.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-200">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="b5a1e-201">Le chiffrement dépend des signatures numériques pour vérifier que les données ont été reconstruites correctement.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-201">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="b5a1e-202">Les sessions fiables doivent mettre en mémoire tampon les messages envoyés sur le client à des fins de nouvelle livraison si un message se perd lors du transfert et elles doivent conserver les messages sur le service avant de les rendre à l'implémentation du service afin de conserver leur ordre s'ils ne sont pas reçus dans l'ordre.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-202">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="b5a1e-203">En raison de ces contraintes fonctionnelles, vous pouvez uniquement utiliser des options de sécurité au niveau du transport pour diffuser en continu et vous ne pouvez pas activer de sessions fiables.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-203">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="b5a1e-204">La diffusion en continu est uniquement disponible avec les liaisons définies par le système suivantes :</span><span class="sxs-lookup"><span data-stu-id="b5a1e-204">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="b5a1e-205">Parce que les transports sous-jacents de <xref:System.ServiceModel.NetTcpBinding> et <xref:System.ServiceModel.NetNamedPipeBinding> prennent en charge la remise fiable inhérente et les sessions basées sur la connexion, contrairement à HTTP, ces deux liaisons sont uniquement affectées de manière minime par ces contraintes, dans la pratique.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-205">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="b5a1e-206">La diffusion en continu n'est pas disponible avec le transport MSMQ (Message Queuing) et ne peut donc pas être utilisée avec <xref:System.ServiceModel.NetMsmqBinding> ou la classe <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-206">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="b5a1e-207">Le transport Message Queuing prend uniquement en charge les transferts de données mises en mémoire tampon avec une taille contrainte, alors que tous les autres transports n'ont pas de limite de taille de message dans la grande majorité des scénarios.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-207">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="b5a1e-208">La diffusion en continu n'est pas disponible non plus lors de l'utilisation du transport de canal homologue, elle n'est donc pas disponible avec <xref:System.ServiceModel.NetPeerTcpBinding>.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-208">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="b5a1e-209">Sessions et diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="b5a1e-209">Streaming and Sessions</span></span>  
 <span data-ttu-id="b5a1e-210">Vous pouvez obtenir un comportement inattendu lors de la diffusion en continu des appels avec une liaison basée sur session.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="b5a1e-211">Tous les appels en streaming passent par un canal unique (le canal de datagramme) qui ne prend pas en charge les sessions même si la liaison utilisée est configurée pour utiliser des sessions.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="b5a1e-212">Si plusieurs clients effectuent des appels de diffusion en continu vers le même objet de service sur une liaison basée sur session, et si le mode d’accès concurrentiel de l’objet de service est configuré comme unique et son mode de contexte d’instance a la valeur PerSession, les appels généraux doivent traverser le canal de datagramme et un seul appel à la fois est traité.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-212">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="b5a1e-213">Un ou plusieurs clients peuvent ainsi être temporisés. Vous pouvez contourner ce problème en attribuant au mode de contexte d'instance de l'objet de service la valeur PerCall, ou au mode d'accès concurrentiel la valeur Multiple.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-213">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b5a1e-214">MaxConcurrentSessions n'a aucun effet dans ce cas parce qu'il n'y a qu'une seule « session » disponible.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-214">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="b5a1e-215">Activation de la diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="b5a1e-215">Enabling Streaming</span></span>  
 <span data-ttu-id="b5a1e-216">Vous pouvez activer la diffusion en continu des manières suivantes :</span><span class="sxs-lookup"><span data-stu-id="b5a1e-216">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="b5a1e-217">Envoyez et acceptez des demandes en mode de diffusion en continu, puis acceptez et renvoyez les réponses en mode mémoire tampon (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span><span class="sxs-lookup"><span data-stu-id="b5a1e-217">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="b5a1e-218">Envoyez et acceptez des demandes en mode mémoire tampon, puis acceptez et renvoyez les réponses en mode de diffusion en continu (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span><span class="sxs-lookup"><span data-stu-id="b5a1e-218">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="b5a1e-219">Envoyez et recevez des demandes et des réponses en mode de diffusion en continu dans les deux sens.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-219">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="b5a1e-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="b5a1e-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="b5a1e-221">Vous pouvez désactiver la diffusion en continu en affectant au mode de transfert la valeur <xref:System.ServiceModel.TransferMode.Buffered>, ce qui correspond au paramètre par défaut sur toutes les liaisons.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-221">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="b5a1e-222">Le code suivant montre comment définir le mode de transfert dans la configuration.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-222">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="b5a1e-223">Lorsque vous instanciez votre liaison dans le code, vous devez affecter à la propriété `TransferMode` respective de la liaison (ou à l’élément de la liaison de transport si vous composez une liaison personnalisée) l’une des valeurs mentionnées précédemment.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-223">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="b5a1e-224">Vous pouvez activer la diffusion en continu pour les demandes et les réponses ou pour les deux sens de manière indépendante à l'un ou l'autre côté des parties communicantes sans affecter les fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-224">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="b5a1e-225">Toutefois, vous devez toujours partir du principe que la taille des données transférées est si importante que l'activation de la diffusion en continu est justifiée sur les deux points de terminaison d'une liaison de communication.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-225">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="b5a1e-226">Pour la communication multiplateforme où un point de terminaison n’est pas implémenté avec WCF, la possibilité d’utiliser la diffusion en continu dépend des fonctionnalités de diffusion en continu de la plateforme.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-226">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="b5a1e-227">Une autre exception rare peut impliquer un scénario piloté par la consommation de mémoire dans lequel un client ou service doit minimiser son jeu de travail et peut uniquement accepter de petites tailles de mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-227">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="b5a1e-228">Activation de la diffusion en continu asynchrone</span><span class="sxs-lookup"><span data-stu-id="b5a1e-228">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="b5a1e-229">Pour activer la diffusion en continu asynchrone, ajoutez le comportement de point de terminaison <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> à l'hôte de service et affectez à sa propriété <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-229">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="b5a1e-230">Nous avons également ajouté la fonction de diffusion en continu asynchrone du côté expéditeur.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-230">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="b5a1e-231">Cela améliore l'extensibilité du service dans les scénarios où des messages sont diffusés en continu à plusieurs clients, dont certains sont lents dans la lecture ; probablement en raison de la congestion du réseau ou ne lisent pas du tout.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-231">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="b5a1e-232">Dans ces scénarios, nous ne bloquons plus les différents threads sur le service par client.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-232">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="b5a1e-233">Cela garantit que le service peut gérer beaucoup plus de clients fournissant ainsi l'extensibilité du service.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-233">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="b5a1e-234">Modèle de programmation pour les transferts en continu</span><span class="sxs-lookup"><span data-stu-id="b5a1e-234">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="b5a1e-235">Le modèle de programmation pour la diffusion en continu est simple.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-235">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="b5a1e-236">Pour recevoir des données en continu, spécifiez un contrat d'opération qui possède un seul paramètre d'entrée <xref:System.IO.Stream> saisi.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-236">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="b5a1e-237">Pour renvoyer des données en continu, renvoyez une référence <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-237">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```  
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="b5a1e-238">L’opération `Echo` dans l’exemple précédent reçoit et renvoie un flux et doit donc être utilisée sur une liaison avec <xref:System.ServiceModel.TransferMode.Streamed>.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-238">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="b5a1e-239">Pour l’opération `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> convient mieux, car seul un <xref:System.IO.Stream> est renvoyé.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-239">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="b5a1e-240">L'opération unidirectionnelle convient mieux à <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-240">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="b5a1e-241">Notez que l'ajout d'un deuxième paramètre à `Echo` ou aux opérations `ProvideInfo` suivantes engendre le retour du modèle de service à une stratégie de mise en mémoire tampon et l'utilisation de la représentation de sérialisation à l'exécution du flux.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-241">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="b5a1e-242">Seules les opérations avec un paramètre de flux d'entrée unique sont compatibles avec la diffusion en continu des demandes de bout en bout.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-242">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="b5a1e-243">Cette règle s'applique de la même façon aux contrats de message.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-243">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="b5a1e-244">Comme indiqué dans le contrat de message suivant, votre contrat de message peut uniquement comporter un seul membre de corps qui est un flux.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-244">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="b5a1e-245">Si vous souhaitez communiquer des informations supplémentaires avec le flux, ces informations doivent être transmises dans des en-têtes de message.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-245">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="b5a1e-246">Le corps du message est exclusivement réservé au contenu de flux.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-246">The message body is exclusively reserved for the stream content.</span></span>  
  
```  
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}   
```  
  
 <span data-ttu-id="b5a1e-247">Les transferts en continu se terminent et le message est fermé lorsque le flux atteint la fin du fichier (EOF).</span><span class="sxs-lookup"><span data-stu-id="b5a1e-247">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="b5a1e-248">Lors de l’envoi d’un message (qui retourne une valeur ou appel d’une opération), vous pouvez passer un <xref:System.IO.FileStream> et l’infrastructure WCF tire ensuite toutes les données à partir de ce flux de données jusqu'à ce que le flux a été complètement lues et atteint EOF.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-248">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="b5a1e-249">Pour transférer des données en continu pour la source pour laquelle aucune classe dérivée <xref:System.IO.Stream> pré-intégrée n’existe, construisez une telle classe, superposez-la sur votre source de flux et utilisez-la en tant qu’argument ou valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-249">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="b5a1e-250">Lors de la réception d’un message, WCF construit un flux de données sur le contenu du corps de message codé en Base64 (ou la partie MIME respective si à l’aide de MTOM) et le flux atteint EOF lorsque le contenu a été lu.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-250">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="b5a1e-251">La diffusion en continu au niveau du transport fonctionne également avec tout autre type de contrat de message (listes de paramètres, arguments de contrat de données et contrat de message explicite), mais étant donné que la sérialisation et la désérialisation de tels messages requièrent une mise en mémoire tampon par le sérialiseur, l’utilisation de telles variantes de contrat n’est pas recommandée.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-251">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="b5a1e-252">Considérations spéciales en matière de sécurité pour les données volumineuses</span><span class="sxs-lookup"><span data-stu-id="b5a1e-252">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="b5a1e-253">Toutes les liaisons vous permettent de contraindre la taille des messages entrants afin d’empêcher des attaques par déni de service.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-253">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="b5a1e-254">Le <xref:System.ServiceModel.BasicHttpBinding>, par exemple, expose un [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) propriété limitant la taille du message entrant et donc également délimite la quantité maximale de mémoire qui est accessible lors du traitement du message.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-254">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="b5a1e-255">Cette unité est définie en octets et s'élève par défaut à 65 536 octets.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-255">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="b5a1e-256">Une menace pour la sécurité, spécifique à la diffusion en continu de données volumineuses, engendre un déni de service en provoquant la mise en mémoire tampon des données lorsque le destinataire s'attend à ce qu'elles soient diffusées en continu.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-256">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="b5a1e-257">Par exemple, WCF met toujours les en-têtes SOAP d’un message, et par conséquent, un intrus peut construire un message malveillant volumineux qui se compose entièrement d’en-têtes pour forcer les données en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-257">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="b5a1e-258">Lorsque la diffusion en continu est activée, `MaxReceivedMessageSize` peut avoir une valeur extrêmement élevée, parce que le destinataire ne s'attend jamais à ce que le message entier soit mis en mémoire tampon en une seule fois.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-258">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="b5a1e-259">Si WCF est forcé à mettre en mémoire tampon du message, un dépassement de capacité de mémoire se produit.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-259">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="b5a1e-260">Par conséquent, la restriction de la taille maximale des messages entrants n'est pas suffisante dans ce cas.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-260">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="b5a1e-261">Le `MaxBufferSize` propriété est requise pour contraindre la mémoire que mémoires tampons WCF.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-261">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="b5a1e-262">Il est important d'affecter à cette propriété une valeur sûre (ou de conserver sa valeur par défaut) lors de la diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-262">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="b5a1e-263">Par exemple, supposez que votre service doive recevoir des fichiers d'une taille allant jusqu'à 4 Go afin de les stocker sur le disque local.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-263">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="b5a1e-264">Supposez également que votre mémoire soit contrainte de sorte à ce que vous puissiez uniquement mettre en mémoire tampon 64 Ko de données à la fois.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-264">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="b5a1e-265">Vous devez alors affecter la valeur 4 Go à `MaxReceivedMessageSize` et la valeur 64 Ko à `MaxBufferSize`.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-265">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="b5a1e-266">En outre, dans votre implémentation de service, vous devez veiller à lire uniquement à partir du flux entrant par segment de 64 Ko et à ne pas lire le segment suivant avant que le précédent ne soit écrit sur le disque et qu'il soit effacé de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-266">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="b5a1e-267">Il est également important de comprendre que ce quota limite uniquement la mise en mémoire tampon effectuée par WCF et ne vous protège pas contre toute mise en mémoire tampon que vous effectuez dans votre propre implémentation de service ou client.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-267">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="b5a1e-268">Pour plus d’informations sur les considérations de sécurité supplémentaires, consultez [considérations de sécurité pour les données](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="b5a1e-268">For more information about additional security considerations, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b5a1e-269">La décision d'utiliser des transferts mis en mémoire tampon ou diffusés en continu est une décision locale du point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-269">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="b5a1e-270">Pour les transports HTTP, le mode de transfert ne se propage pas sur une connexion ou sur des serveurs proxy et d'autres intermédiaires.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-270">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="b5a1e-271">La description de l'interface de service ne reflète pas le mode de transfert défini.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-271">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="b5a1e-272">Après avoir généré un client WCF pour un service, vous devez modifier le fichier de configuration des services destinés à être utilisés avec des transferts en flux continu pour définir le mode.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-272">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="b5a1e-273">Pour les transports TCP et les transports de canal nommé, le mode de transfert est propagé sous forme d'assertion de stratégie.</span><span class="sxs-lookup"><span data-stu-id="b5a1e-273">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b5a1e-274">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="b5a1e-274">See also</span></span>

- [<span data-ttu-id="b5a1e-275">Guide pratique pour Activer la diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="b5a1e-275">How to: Enable Streaming</span></span>](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)
