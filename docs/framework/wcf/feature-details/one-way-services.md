---
title: Services monodirectionnels
ms.date: 03/30/2017
helpviewer_keywords:
- Windows Communication Foundation [WCF], one-way service contracts
- WCF [WCF], one-way service contracts
- service contracts [WCF], defining one-way
ms.assetid: 19053a36-4492-45a3-bfe6-0365ee0205a3
ms.openlocfilehash: 0d69af40e4b9a0133e44b64b45466f9aac84ffe2
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84598747"
---
# <a name="one-way-services"></a><span data-ttu-id="49003-102">Services monodirectionnels</span><span class="sxs-lookup"><span data-stu-id="49003-102">One-Way Services</span></span>
<span data-ttu-id="49003-103">Le comportement par défaut d'une opération de service est le modèle demande-réponse.</span><span class="sxs-lookup"><span data-stu-id="49003-103">The default behavior of a service operation is the request-reply pattern.</span></span> <span data-ttu-id="49003-104">Dans un modèle demande-réponse, le client attend le message de réponse, même si l'opération de service est représentée dans le code en tant que méthode `void`.</span><span class="sxs-lookup"><span data-stu-id="49003-104">In a request-reply pattern, the client waits for the reply message, even if the service operation is represented in code as a `void` method.</span></span> <span data-ttu-id="49003-105">Avec une opération monodirectionnelle, un seul message est transmis.</span><span class="sxs-lookup"><span data-stu-id="49003-105">With a one-way operation, only one message is transmitted.</span></span> <span data-ttu-id="49003-106">Le récepteur n'envoie pas de message de réponse, l'expéditeur n'en attend pas.</span><span class="sxs-lookup"><span data-stu-id="49003-106">The receiver does not send a reply message, nor does the sender expect one.</span></span>  
  
 <span data-ttu-id="49003-107">Utilisez le modèle de design monodirectionnel :</span><span class="sxs-lookup"><span data-stu-id="49003-107">Use the one-way design pattern:</span></span>  
  
- <span data-ttu-id="49003-108">Lorsque le client doit appeler des opérations et n'est pas affecté par le résultat de l'opération au niveau de l'opération.</span><span class="sxs-lookup"><span data-stu-id="49003-108">When the client must call operations and is not affected by the result of the operation at the operation level.</span></span>  
  
- <span data-ttu-id="49003-109">Lorsque vous utilisez la classe <xref:System.ServiceModel.NetMsmqBinding> ou <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="49003-109">When using the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="49003-110">(Pour plus d’informations sur ce scénario, consultez [files d’attente dans WCF](queues-in-wcf.md).)</span><span class="sxs-lookup"><span data-stu-id="49003-110">(For more information about this scenario, see [Queues in WCF](queues-in-wcf.md).)</span></span>  
  
 <span data-ttu-id="49003-111">Lorsqu'une opération est monodirectionnelle, il n'y a pas de message pour renvoyer des informations sur l'erreur au client.</span><span class="sxs-lookup"><span data-stu-id="49003-111">When an operation is one-way, there is no response message to carry error information back to the client.</span></span> <span data-ttu-id="49003-112">Vous pouvez détecter des conditions d’erreur à l’aide de fonctionnalités de la liaison sous-jacente, telle que les sessions fiables, ou en concevant un contrat de service duplex qui utilise deux opérations monodirectionnelles : un contrat monodirectionnel du client au service afin d’appeler l’opération de service, et un autre contrat monodirectionnel entre le service et le client afin que le service puisse renvoyer des erreurs au client à l’aide d’un rappel que le client implémente.</span><span class="sxs-lookup"><span data-stu-id="49003-112">You can detect error conditions by using features of the underlying binding, such as reliable sessions, or by designing a duplex service contract that uses two one-way operations—a one-way contract from the client to the service to call service operation and another one-way contract between the service and the client so that the service can send back faults to the client using a callback that the client implements.</span></span>  
  
 <span data-ttu-id="49003-113">Pour créer un contrat de service monodirectionnel, définissez votre contrat de service, appliquez la classe <xref:System.ServiceModel.OperationContractAttribute> à chaque opération et affectez <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> à la propriété `true`, tel qu'indiqué dans l'exemple de code suivant.</span><span class="sxs-lookup"><span data-stu-id="49003-113">To create a one-way service contract, define your service contract, apply the <xref:System.ServiceModel.OperationContractAttribute> class to each operation, and set the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true`, as shown in the following sample code.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IOneWayCalculator  
{  
    [OperationContract(IsOneWay=true)]  
    void Add(double n1, double n2);  
    [OperationContract(IsOneWay = true)]  
    void Subtract(double n1, double n2);  
    [OperationContract(IsOneWay = true)]  
    void Multiply(double n1, double n2);  
    [OperationContract(IsOneWay = true)]  
    void Divide(double n1, double n2);  
}  
```  
  
 <span data-ttu-id="49003-114">Pour obtenir un exemple complet, consultez l’exemple [unidirectionnel](../samples/one-way.md) .</span><span class="sxs-lookup"><span data-stu-id="49003-114">For a complete example, see the [One-Way](../samples/one-way.md) sample.</span></span>  
  
## <a name="clients-blocking-with-one-way-operations"></a><span data-ttu-id="49003-115">Blocage de clients à l'aide d'opérations monodirectionnelles</span><span class="sxs-lookup"><span data-stu-id="49003-115">Clients Blocking with One-Way Operations</span></span>  
 <span data-ttu-id="49003-116">Il est important de se rendre compte que bien que certaines applications monodirectionnelles retournent dès que les données sortantes sont écrites dans la connexion réseau, dans plusieurs scénarios, l’implémentation d’une liaison ou d’un service peut provoquer le blocage d’un client WCF à l’aide d’opérations unidirectionnelles.</span><span class="sxs-lookup"><span data-stu-id="49003-116">It is important to realize that while some one-way applications return as soon as the outbound data is written to the network connection, in several scenarios the implementation of a binding or of a service can cause a WCF client to block using one-way operations.</span></span> <span data-ttu-id="49003-117">Dans les applications clientes WCF, l’objet client WCF ne retourne pas de valeur tant que les données sortantes n’ont pas été écrites dans la connexion réseau.</span><span class="sxs-lookup"><span data-stu-id="49003-117">In WCF client applications, the WCF client object does not return until the outbound data has been written to the network connection.</span></span> <span data-ttu-id="49003-118">Cela se vérifie pour l'ensemble des modèles d'échange de messages, dont les opérations monodirectionnelles ; cela signifie que les problèmes d'écriture de données sur le transport empêchent le client de retourner.</span><span class="sxs-lookup"><span data-stu-id="49003-118">This is true for all message exchange patterns, including one-way operations; this means that any problem writing the data to the transport prevents the client from returning.</span></span> <span data-ttu-id="49003-119">Selon le problème, le résultat peut être une exception ou un retard d'envoi des messages au service.</span><span class="sxs-lookup"><span data-stu-id="49003-119">Depending upon the problem, the result could be an exception or a delay in sending messages to the service.</span></span>  
  
 <span data-ttu-id="49003-120">Par exemple, si le transport ne peut pas trouver le point de terminaison, une exception <xref:System.ServiceModel.EndpointNotFoundException?displayProperty=nameWithType> est levée sans beaucoup de retard.</span><span class="sxs-lookup"><span data-stu-id="49003-120">For example, if the transport cannot find the endpoint, a <xref:System.ServiceModel.EndpointNotFoundException?displayProperty=nameWithType> exception is thrown without much delay.</span></span> <span data-ttu-id="49003-121">Toutefois, il est également possible que le service ne puisse pas lire les données du câble pour une raison quelconque, ce qui empêche l'opération d'envoi du transport client de retourner.</span><span class="sxs-lookup"><span data-stu-id="49003-121">However, it is also possible that the service is unable to read the data off the wire for some reason, which prevents the client transport send operation from returning.</span></span> <span data-ttu-id="49003-122">Dans ce cas, si le délai <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A?displayProperty=nameWithType> sur la liaison de transport client est dépassé, une exception <xref:System.TimeoutException?displayProperty=nameWithType> est levée, mais pas tant que le délai d’attente n’a pas été dépassé.</span><span class="sxs-lookup"><span data-stu-id="49003-122">In these cases, if the <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A?displayProperty=nameWithType> period on the client transport binding is exceeded, a <xref:System.TimeoutException?displayProperty=nameWithType> is thrown—but not until the timeout period has been exceeded.</span></span> <span data-ttu-id="49003-123">Il est également possible qu'il y ait un nombre si élevé de messages sur un service que celui-ci ne puisse pas les traiter passé un certain stade.</span><span class="sxs-lookup"><span data-stu-id="49003-123">It is also possible to fire so many messages at a service that the service cannot process them past a certain point.</span></span> <span data-ttu-id="49003-124">Dans ce cas également, le client monodirectionnel se bloque jusqu'à ce que le service puisse traiter les messages ou jusqu'à ce qu'une exception soit levée.</span><span class="sxs-lookup"><span data-stu-id="49003-124">In this case, too, the one-way client blocks until the service can process the messages or until an exception is thrown.</span></span>  
  
 <span data-ttu-id="49003-125">Une autre variante est le cas où la propriété de service <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> a la valeur <xref:System.ServiceModel.ConcurrencyMode.Single> et la liaison utilise des sessions.</span><span class="sxs-lookup"><span data-stu-id="49003-125">Another variation is the situation in which the service <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> property is set to <xref:System.ServiceModel.ConcurrencyMode.Single> and the binding uses sessions.</span></span> <span data-ttu-id="49003-126">Dans ce cas, le répartiteur applique un classement sur les messages entrants (exigence de sessions), ce qui empêche les messages suivants d’être lus sur le réseau tant que le service n’a pas traité le message précédent de cette session.</span><span class="sxs-lookup"><span data-stu-id="49003-126">In this case, the dispatcher enforces ordering on the incoming messages (a requirement of sessions), which prevents subsequent messages from being read off the network until the service has processed the preceding message for that session.</span></span> <span data-ttu-id="49003-127">À nouveau, le client se bloque, mais la survenue d'une exception repose sur la capacité du service à traiter les données en attente avant le dépassement du délai défini sur le client.</span><span class="sxs-lookup"><span data-stu-id="49003-127">Again, the client blocks, but whether an exception occurs depends upon whether the service is able to process the waiting data prior to the timeout settings on the client.</span></span>  
  
 <span data-ttu-id="49003-128">Vous pouvez limiter ce problème en insérant une mémoire tampon entre l'objet client et l'opération d'envoi du transport client.</span><span class="sxs-lookup"><span data-stu-id="49003-128">You can mitigate some of this problem by inserting a buffer between the client object and the client transport's send operation.</span></span> <span data-ttu-id="49003-129">Par exemple, l'utilisation d'appels asynchrones ou d'une file d'attente de messages en mémoire permet à l'objet client de retourner rapidement.</span><span class="sxs-lookup"><span data-stu-id="49003-129">For example, using asynchronous calls or using an in-memory message queue can enable the client object to return quickly.</span></span> <span data-ttu-id="49003-130">Ces deux approches peuvent augmenter la fonctionnalité, mais la taille du pool de threads et de la file d'attente de messages pose encore des limites.</span><span class="sxs-lookup"><span data-stu-id="49003-130">Both approaches may increase functionality, but the size of the thread pool and the message queue still enforce limits.</span></span>  
  
 <span data-ttu-id="49003-131">Nous vous recommandons, à la place, d'examinez les divers contrôles sur le service ainsi que sur le client, puis de tester vos scénarios d'application afin de déterminer la meilleure configuration de part et d'autre.</span><span class="sxs-lookup"><span data-stu-id="49003-131">It is recommended, instead, that you examine the various controls on the service as well as on the client, and then test your application scenarios to determine the best configuration on either side.</span></span> <span data-ttu-id="49003-132">Par exemple, si l'utilisation de sessions bloque le traitement de messages sur votre service, vous pouvez affecter <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> à la propriété <xref:System.ServiceModel.InstanceContextMode.PerCall> afin que chaque message puisse être traité par une instance de service différente, et affecter <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> à <xref:System.ServiceModel.ConcurrencyMode.Multiple> afin de permettre à plusieurs threads de distribuer des messages simultanément.</span><span class="sxs-lookup"><span data-stu-id="49003-132">For example, if the use of sessions is blocking the processing of messages on your service, you can set the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.InstanceContextMode.PerCall> so that each message can be processed by a different service instance, and set the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> to <xref:System.ServiceModel.ConcurrencyMode.Multiple> in order to allow more than one thread to dispatch messages at a time.</span></span> <span data-ttu-id="49003-133">Une autre approche consiste à augmenter les quotas de lecture du service et les liaisons clientes.</span><span class="sxs-lookup"><span data-stu-id="49003-133">Another approach is to increase the read quotas of the service and client bindings.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="49003-134">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="49003-134">See also</span></span>

- [<span data-ttu-id="49003-135">One-Way</span><span class="sxs-lookup"><span data-stu-id="49003-135">One-Way</span></span>](../samples/one-way.md)
