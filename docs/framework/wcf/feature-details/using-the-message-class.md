---
title: Utilisation de la classe Message
description: En savoir plus sur la classe message, qui est fondamentale pour WCF. Vous devez programmer à l’aide de la classe de message directement uniquement dans certains scénarios avancés.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d1d62bfb-2aa3-4170-b6f8-c93d3afdbbed
ms.openlocfilehash: f806e257cfd3ccc5118a5783e2eda48eef4ba0bf
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/23/2020
ms.locfileid: "85246491"
---
# <a name="using-the-message-class"></a><span data-ttu-id="7f128-104">Utilisation de la classe Message</span><span class="sxs-lookup"><span data-stu-id="7f128-104">Using the Message Class</span></span>
<span data-ttu-id="7f128-105">La <xref:System.ServiceModel.Channels.Message> classe est fondamentale pour Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="7f128-105">The <xref:System.ServiceModel.Channels.Message> class is fundamental to Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="7f128-106">Toute la communication entre les clients et les services a pour résultat l'envoi et la réception d'instances <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="7f128-106">All communication between clients and services ultimately results in <xref:System.ServiceModel.Channels.Message> instances being sent and received.</span></span>  
  
 <span data-ttu-id="7f128-107">Aucune interaction directe n'a généralement lieu avec la classe <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="7f128-107">You would not usually interact with the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="7f128-108">Au lieu de cela, les constructions de modèle de service WCF, telles que les contrats de données, les contrats de message et les contrats d’opération, sont utilisées pour décrire les messages entrants et sortants.</span><span class="sxs-lookup"><span data-stu-id="7f128-108">Instead, WCF service model constructs, such as data contracts, message contracts, and operation contracts, are used to describe incoming and outgoing messages.</span></span> <span data-ttu-id="7f128-109">Toutefois, dans certains scénarios avancés, vous pouvez programmer directement à l'aide de la classe <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="7f128-109">However, in some advanced scenarios you can program using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="7f128-110">Par exemple, il est possible que vous souhaitiez utiliser la classe <xref:System.ServiceModel.Channels.Message> :</span><span class="sxs-lookup"><span data-stu-id="7f128-110">For example, you might want to use the <xref:System.ServiceModel.Channels.Message> class:</span></span>  
  
- <span data-ttu-id="7f128-111">Lorsque vous avez besoin d’une autre façon de créer le contenu des messages sortants (par exemple, créer un message directement à partir d’un fichier sur le disque) au lieu de sérialiser des objets .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="7f128-111">When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing .NET Framework objects.</span></span>  
  
- <span data-ttu-id="7f128-112">Lorsque vous avez besoin d’une autre façon d’utiliser le contenu des messages entrants (par exemple, lorsque vous souhaitez appliquer une transformation XSLT au contenu XML brut) au lieu de désérialiser dans .NET Framework objets.</span><span class="sxs-lookup"><span data-stu-id="7f128-112">When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into .NET Framework objects.</span></span>  
  
- <span data-ttu-id="7f128-113">Lorsque vous devez gérer des messages d'une manière générale indépendamment du contenu de message (par exemple, lors du routage ou du transfert de messages lors de la création d'un routeur, d'un équilibreur de charge ou d'un système de publication-souscription).</span><span class="sxs-lookup"><span data-stu-id="7f128-113">When you need to deal with messages in a general way regardless of message contents (for example, when routing or forwarding messages when building a router, load-balancer, or a publish-subscribe system).</span></span>  
  
 <span data-ttu-id="7f128-114">Avant d’utiliser la <xref:System.ServiceModel.Channels.Message> classe, familiarisez-vous avec l’architecture de transfert de données WCF dans [transfert de données vue d’ensemble](data-transfer-architectural-overview.md)de l’architecture.</span><span class="sxs-lookup"><span data-stu-id="7f128-114">Before using the <xref:System.ServiceModel.Channels.Message> class, familiarize yourself with the WCF data transfer architecture in [Data Transfer Architectural Overview](data-transfer-architectural-overview.md).</span></span>  
  
 <span data-ttu-id="7f128-115">Un <xref:System.ServiceModel.Channels.Message> est un conteneur de données à usage général, mais sa conception suit étroitement celle d'un message dans le protocole SOAP.</span><span class="sxs-lookup"><span data-stu-id="7f128-115">A <xref:System.ServiceModel.Channels.Message> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol.</span></span> <span data-ttu-id="7f128-116">Tout comme dans SOAP, un message possède à la fois un en-tête et un corps de message.</span><span class="sxs-lookup"><span data-stu-id="7f128-116">Just like in SOAP, a message has both a message body and headers.</span></span> <span data-ttu-id="7f128-117">Le corps du message contient les données de charge utile, tandis que les en-têtes contiennent des conteneurs de données nommés supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="7f128-117">The message body contains the actual payload data, while the headers contain additional named data containers.</span></span> <span data-ttu-id="7f128-118">Les règles de lecture et d'écriture du corps et des en-têtes sont différentes ; par exemple, les en-têtes sont toujours mis en mémoire tampon et sont accessibles dans un ordre quelconque et un nombre de fois quelconque, alors que le corps peut être lu une seule fois et peut être transmis en continu.</span><span class="sxs-lookup"><span data-stu-id="7f128-118">The rules for reading and writing the body and the headers are different, for example, the headers are always buffered in memory and may be accessed in any order any number of times, while the body may be read only once and may be streamed.</span></span> <span data-ttu-id="7f128-119">Normalement, lors de l'utilisation de SOAP, le corps du message est mappé au corps SOAP et les en-têtes de messages sont mappés aux en-têtes SOAP.</span><span class="sxs-lookup"><span data-stu-id="7f128-119">Normally, when using SOAP, the message body is mapped to the SOAP body and the message headers are mapped to the SOAP headers.</span></span>  
  
## <a name="using-the-message-class-in-operations"></a><span data-ttu-id="7f128-120">Utilisation de la classe Message dans des opérations</span><span class="sxs-lookup"><span data-stu-id="7f128-120">Using the Message Class in Operations</span></span>  
 <span data-ttu-id="7f128-121">Vous pouvez utiliser la classe <xref:System.ServiceModel.Channels.Message> comme paramètre d'entrée d'une opération, valeur de retour d'une opération ou les deux.</span><span class="sxs-lookup"><span data-stu-id="7f128-121">You can use the <xref:System.ServiceModel.Channels.Message> class as an input parameter of an operation, the return value of an operation, or both.</span></span> <span data-ttu-id="7f128-122">Si <xref:System.ServiceModel.Channels.Message> est utilisé dans une opération, les restrictions suivantes s'appliquent :</span><span class="sxs-lookup"><span data-stu-id="7f128-122">If <xref:System.ServiceModel.Channels.Message> is used anywhere in an operation, the following restrictions apply:</span></span>  
  
- <span data-ttu-id="7f128-123">L'opération ne peut pas avoir de paramètres `out` ou `ref`.</span><span class="sxs-lookup"><span data-stu-id="7f128-123">The operation cannot have any `out` or `ref` parameters.</span></span>  
  
- <span data-ttu-id="7f128-124">Il ne peut pas y avoir plusieurs paramètres `input`.</span><span class="sxs-lookup"><span data-stu-id="7f128-124">There cannot be more than one `input` parameter.</span></span> <span data-ttu-id="7f128-125">Si le paramètre est présent, il doit s'agir de Message ou d'un type de contrat de message.</span><span class="sxs-lookup"><span data-stu-id="7f128-125">If the parameter is present, it must be either Message or a message contract type.</span></span>  
  
- <span data-ttu-id="7f128-126">Le type de retour doit être `void`, `Message` ou un type de contrat de message.</span><span class="sxs-lookup"><span data-stu-id="7f128-126">The return type must be either `void`, `Message`, or a message contract type.</span></span>  
  
 <span data-ttu-id="7f128-127">L'exemple de code suivant contient un contrat d'opération valide.</span><span class="sxs-lookup"><span data-stu-id="7f128-127">The following code example contains a valid operation contract.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#1)]
 [!code-vb[C_UsingTheMessageClass#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#1)]  
  
## <a name="creating-basic-messages"></a><span data-ttu-id="7f128-128">Création de messages simples</span><span class="sxs-lookup"><span data-stu-id="7f128-128">Creating Basic Messages</span></span>  
 <span data-ttu-id="7f128-129">La classe <xref:System.ServiceModel.Channels.Message> fournit des méthodes de fabrique `CreateMessage` statiques que vous pouvez utiliser pour créer des messages simples.</span><span class="sxs-lookup"><span data-stu-id="7f128-129">The <xref:System.ServiceModel.Channels.Message> class provides static `CreateMessage` factory methods that you can use to create basic messages.</span></span>  
  
 <span data-ttu-id="7f128-130">Toutes les surcharges `CreateMessage` prennent un paramètre de version de type <xref:System.ServiceModel.Channels.MessageVersion> qui indique les versions SOAP et WS-Addressing à utiliser pour le message.</span><span class="sxs-lookup"><span data-stu-id="7f128-130">All `CreateMessage` overloads take a version parameter of type <xref:System.ServiceModel.Channels.MessageVersion> that indicates the SOAP and WS-Addressing versions to use for the message.</span></span> <span data-ttu-id="7f128-131">Si vous souhaitez utiliser les mêmes versions de protocole que le message entrant, vous pouvez utiliser la propriété <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> sur l'instance <xref:System.ServiceModel.OperationContext> obtenue à partir de la propriété <xref:System.ServiceModel.OperationContext.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f128-131">If you want to use the same protocol versions as the incoming message, you can use the <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> property on the <xref:System.ServiceModel.OperationContext> instance obtained from the <xref:System.ServiceModel.OperationContext.Current%2A> property.</span></span> <span data-ttu-id="7f128-132">La plupart des surcharges `CreateMessage` ont également un paramètre de chaîne qui indique l'action SOAP à utiliser pour le message.</span><span class="sxs-lookup"><span data-stu-id="7f128-132">Most `CreateMessage` overloads also have a string parameter that indicates the SOAP action to use for the message.</span></span> <span data-ttu-id="7f128-133">La version peut avoir la valeur `None` pour désactiver la génération d'enveloppe SOAP ; le message est uniquement composé du corps.</span><span class="sxs-lookup"><span data-stu-id="7f128-133">Version can be set to `None` to disable SOAP envelope generation; the message consists of only the body.</span></span>  
  
## <a name="creating-messages-from-objects"></a><span data-ttu-id="7f128-134">Création de messages à partir d'objets</span><span class="sxs-lookup"><span data-stu-id="7f128-134">Creating Messages from Objects</span></span>  
 <span data-ttu-id="7f128-135">La surcharge `CreateMessage` la plus simple qui prend uniquement une version et une action crée un message dont le corps est vide.</span><span class="sxs-lookup"><span data-stu-id="7f128-135">The most basic `CreateMessage` overload that takes only a version and an action creates a message with an empty body.</span></span> <span data-ttu-id="7f128-136">Une autre surcharge prend un paramètre <xref:System.Object> supplémentaire ; cela crée un message dont le corps est la représentation sérialisée de l'objet donné.</span><span class="sxs-lookup"><span data-stu-id="7f128-136">Another overload takes an additional <xref:System.Object> parameter; this creates a message whose body is the serialized representation of the given object.</span></span> <span data-ttu-id="7f128-137">Utilisez le <xref:System.Runtime.Serialization.DataContractSerializer> avec les paramètres par défaut pour la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="7f128-137">Use the <xref:System.Runtime.Serialization.DataContractSerializer> with default settings for serialization.</span></span> <span data-ttu-id="7f128-138">Si vous souhaitez utiliser un sérialiseur différent ou si vous souhaitez configurer le `DataContractSerializer` différemment, utilisez la surcharge `CreateMessage` qui prend également un paramètre `XmlObjectSerializer`.</span><span class="sxs-lookup"><span data-stu-id="7f128-138">If you want to use a different serializer, or you want the `DataContractSerializer` configured differently, use the `CreateMessage` overload that also takes an `XmlObjectSerializer` parameter.</span></span>  
  
 <span data-ttu-id="7f128-139">Par exemple, pour retourner un objet dans un message, vous pouvez utiliser le code suivant.</span><span class="sxs-lookup"><span data-stu-id="7f128-139">For example, to return an object in a message, you can use the following code.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#2)]
 [!code-vb[C_UsingTheMessageClass#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#2)]  
  
## <a name="creating-messages-from-xml-readers"></a><span data-ttu-id="7f128-140">Création de messages à partir de lecteurs XML</span><span class="sxs-lookup"><span data-stu-id="7f128-140">Creating Messages from XML Readers</span></span>  
 <span data-ttu-id="7f128-141">Il existe des surcharges `CreateMessage` qui prennent un <xref:System.Xml.XmlReader> ou un <xref:System.Xml.XmlDictionaryReader> pour le corps au lieu d'un objet.</span><span class="sxs-lookup"><span data-stu-id="7f128-141">There are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> for the body instead of an object.</span></span> <span data-ttu-id="7f128-142">Dans ce cas, le corps du message contient le XML résultant de la lecture du lecteur XML passé.</span><span class="sxs-lookup"><span data-stu-id="7f128-142">In this case, the body of the message contains the XML that results from reading from the passed XML reader.</span></span> <span data-ttu-id="7f128-143">Par exemple, le code suivant retourne un message dont le contenu du corps est lu à partir d'un fichier XML.</span><span class="sxs-lookup"><span data-stu-id="7f128-143">For example, the following code returns a message with body contents read from an XML file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#3)]
 [!code-vb[C_UsingTheMessageClass#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#3)]  
  
 <span data-ttu-id="7f128-144">De plus, il existe des surcharges `CreateMessage` qui prennent un <xref:System.Xml.XmlReader> ou un <xref:System.Xml.XmlDictionaryReader> qui représente le message entier, et non simplement le corps.</span><span class="sxs-lookup"><span data-stu-id="7f128-144">Additionally, there are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> that represents the entire message and not just the body.</span></span> <span data-ttu-id="7f128-145">Ces surcharges prennent également un paramètre `maxSizeOfHeaders` entier.</span><span class="sxs-lookup"><span data-stu-id="7f128-145">These overloads also take an integer `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="7f128-146">Les en-têtes sont toujours mis en mémoire tampon dès que le message est créé, et ce paramètre limite la quantité de mise en mémoire tampon qui a lieu.</span><span class="sxs-lookup"><span data-stu-id="7f128-146">Headers are always buffered into memory as soon as the message is created, and this parameter limits the amount of buffering that takes place.</span></span> <span data-ttu-id="7f128-147">Il est important d'affecter à ce paramètre une valeur sûre si le XML provient d'une source non fiable, afin d'atténuer le risque d'attaque par déni de service.</span><span class="sxs-lookup"><span data-stu-id="7f128-147">It is important to set this parameter to a safe value if the XML is coming from an untrusted source to mitigate the possibility of a denial of service attack.</span></span> <span data-ttu-id="7f128-148">Les versions SOAP et WS-Addressing du message que le lecteur XML représente doivent correspondre aux versions indiquées à l'aide du paramètre de version.</span><span class="sxs-lookup"><span data-stu-id="7f128-148">The SOAP and WS-Addressing versions of the message the XML reader represents must match the versions indicated using the version parameter.</span></span>  
  
## <a name="creating-messages-with-bodywriter"></a><span data-ttu-id="7f128-149">Création de messages avec BodyWriter</span><span class="sxs-lookup"><span data-stu-id="7f128-149">Creating Messages with BodyWriter</span></span>  
 <span data-ttu-id="7f128-150">Une surcharge `CreateMessage` prend une instance `BodyWriter` pour décrire le corps du message.</span><span class="sxs-lookup"><span data-stu-id="7f128-150">One `CreateMessage` overload takes a `BodyWriter` instance to describe the body of the message.</span></span> <span data-ttu-id="7f128-151">Un `BodyWriter` est une classe abstraite qui peut être dérivée afin de personnaliser la façon dont les corps de message sont créés.</span><span class="sxs-lookup"><span data-stu-id="7f128-151">A `BodyWriter` is an abstract class that can be derived to customize how message bodies are created.</span></span> <span data-ttu-id="7f128-152">Vous pouvez créer votre propre classe dérivée `BodyWriter` pour décrire les corps de message de manière personnalisée.</span><span class="sxs-lookup"><span data-stu-id="7f128-152">You can create your own `BodyWriter` derived class to describe message bodies in a custom way.</span></span> <span data-ttu-id="7f128-153">Vous devez substituer la méthode `BodyWriter.OnWriteBodyContents` qui prend un <xref:System.Xml.XmlDictionaryWriter> ; cette méthode est responsable de l'écriture du corps.</span><span class="sxs-lookup"><span data-stu-id="7f128-153">You must override the `BodyWriter.OnWriteBodyContents` method that takes an <xref:System.Xml.XmlDictionaryWriter>; this method is responsible for writing out the body.</span></span>  
  
 <span data-ttu-id="7f128-154">Les enregistreurs de corps peuvent être mis en mémoire tampon ou transmis en continu.</span><span class="sxs-lookup"><span data-stu-id="7f128-154">Body writers can be buffered or non-buffered (streamed).</span></span> <span data-ttu-id="7f128-155">Les enregistreurs de corps mis en mémoire tampon peuvent écrire leur contenu un nombre de fois quelconque, tandis que les enregistreurs transmis en continu peuvent écrire leur contenu une seule fois.</span><span class="sxs-lookup"><span data-stu-id="7f128-155">Buffered body writers can write out their contents any number of times, while streamed ones can write out their contents only once.</span></span> <span data-ttu-id="7f128-156">La propriété `IsBuffered` indique si un enregistreur de corps est mis en mémoire tampon ou non.</span><span class="sxs-lookup"><span data-stu-id="7f128-156">The `IsBuffered` property indicates whether a body writer is buffered or not.</span></span> <span data-ttu-id="7f128-157">Vous pouvez définir cette propriété pour votre enregistreur de corps en appelant le constructeur `BodyWriter` protégé qui prend un paramètre booléen `isBuffered`.</span><span class="sxs-lookup"><span data-stu-id="7f128-157">You can set this for your body writer by calling the protected `BodyWriter` constructor that takes an `isBuffered` boolean parameter.</span></span> <span data-ttu-id="7f128-158">Les enregistreurs de corps prennent en charge la création d'un enregistreur de corps mis en mémoire tampon à partir d'un enregistreur de corps non mis en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="7f128-158">Body writers support creating a buffered body writer from a non-buffered body writer.</span></span> <span data-ttu-id="7f128-159">Vous pouvez substituer la méthode `OnCreateBufferedCopy` pour personnaliser ce processus.</span><span class="sxs-lookup"><span data-stu-id="7f128-159">You can override the `OnCreateBufferedCopy` method to customize this process.</span></span> <span data-ttu-id="7f128-160">Par défaut, un tampon en mémoire qui contient le XML retourné par `OnWriteBodyContents` est utilisé.</span><span class="sxs-lookup"><span data-stu-id="7f128-160">By default, an in-memory buffer that contains the XML returned by `OnWriteBodyContents` is used.</span></span> <span data-ttu-id="7f128-161">`OnCreateBufferedCopy` prend un paramètre entier `maxBufferSize` ; si vous substituez cette méthode, vous ne devez pas créer de mémoire tampon de taille supérieure à cette taille maximale.</span><span class="sxs-lookup"><span data-stu-id="7f128-161">`OnCreateBufferedCopy` takes a `maxBufferSize` integer parameter; if you override this method, you must not create buffers larger than this maximum size.</span></span>  
  
 <span data-ttu-id="7f128-162">La classe `BodyWriter` fournit les méthodes `WriteBodyContents` et `CreateBufferedCopy`, qui sont essentiellement des wrappers minces autour des méthodes `OnWriteBodyContents` et `OnCreateBufferedCopy`, respectivement.</span><span class="sxs-lookup"><span data-stu-id="7f128-162">The `BodyWriter` class provides the `WriteBodyContents` and `CreateBufferedCopy` methods, which are essentially thin wrappers around `OnWriteBodyContents` and `OnCreateBufferedCopy` methods, respectively.</span></span> <span data-ttu-id="7f128-163">Ces méthodes effectuent un contrôle d'état afin de s'assurer que les utilisateurs n'accèdent pas à un enregistreur de corps non mis en mémoire tampon plus d'une fois.</span><span class="sxs-lookup"><span data-stu-id="7f128-163">These methods perform state checking to ensure that a non-buffered body writer is not accessed more than once.</span></span> <span data-ttu-id="7f128-164">Ces méthodes sont appelées directement uniquement lors de la création de classes dérivées `Message` personnalisées selon les `BodyWriters`.</span><span class="sxs-lookup"><span data-stu-id="7f128-164">These methods are called directly only when creating custom `Message` derived classes based on `BodyWriters`.</span></span>  
  
## <a name="creating-fault-messages"></a><span data-ttu-id="7f128-165">Création de messages d'erreur</span><span class="sxs-lookup"><span data-stu-id="7f128-165">Creating Fault Messages</span></span>  
 <span data-ttu-id="7f128-166">Vous pouvez utiliser certaines surcharges `CreateMessage` pour créer des messages d'erreur SOAP.</span><span class="sxs-lookup"><span data-stu-id="7f128-166">You can use certain `CreateMessage` overloads to create SOAP fault messages.</span></span> <span data-ttu-id="7f128-167">Le plus simple d'entre eux prend un objet <xref:System.ServiceModel.Channels.MessageFault> qui décrit l'erreur.</span><span class="sxs-lookup"><span data-stu-id="7f128-167">The most basic of these takes a <xref:System.ServiceModel.Channels.MessageFault> object that describes the fault.</span></span> <span data-ttu-id="7f128-168">D'autres surcharges sont fournies à des fins de commodité.</span><span class="sxs-lookup"><span data-stu-id="7f128-168">Other overloads are provided for convenience.</span></span> <span data-ttu-id="7f128-169">La première de ces surcharges prend un `FaultCode` et une chaîne de raison et crée un `MessageFault` à l'aide de `MessageFault.CreateFault` avec ces informations.</span><span class="sxs-lookup"><span data-stu-id="7f128-169">The first such overload takes a `FaultCode` and a reason string and creates a `MessageFault` using `MessageFault.CreateFault` using this information.</span></span> <span data-ttu-id="7f128-170">L'autre surcharge prend un objet de détail et le passe également à `CreateFault` avec le code d'erreur et la raison.</span><span class="sxs-lookup"><span data-stu-id="7f128-170">The other overload takes a detail object and also passes it to `CreateFault` together with the fault code and the reason.</span></span> <span data-ttu-id="7f128-171">Par exemple, l'opération suivante retourne une erreur.</span><span class="sxs-lookup"><span data-stu-id="7f128-171">For example, the following operation returns a fault.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#4)]
 [!code-vb[C_UsingTheMessageClass#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#4)]  
  
## <a name="extracting-message-body-data"></a><span data-ttu-id="7f128-172">Extraction de données de corps de message</span><span class="sxs-lookup"><span data-stu-id="7f128-172">Extracting Message Body Data</span></span>  
 <span data-ttu-id="7f128-173">La classe `Message` prend en charge plusieurs façons d'extraire des informations de son corps.</span><span class="sxs-lookup"><span data-stu-id="7f128-173">The `Message` class supports multiple ways of extracting information from its body.</span></span> <span data-ttu-id="7f128-174">Celles-ci peuvent être classifiées en plusieurs catégories :</span><span class="sxs-lookup"><span data-stu-id="7f128-174">These can be classified into the following categories:</span></span>  
  
- <span data-ttu-id="7f128-175">Faire en sorte que l'intégralité du corps de message soit écrit immédiatement dans un enregistreur XML.</span><span class="sxs-lookup"><span data-stu-id="7f128-175">Getting the entire message body written out at once to an XML writer.</span></span> <span data-ttu-id="7f128-176">C’est ce que l’on appelle *écrire un message*.</span><span class="sxs-lookup"><span data-stu-id="7f128-176">This is referred to as *writing a message*.</span></span>  
  
- <span data-ttu-id="7f128-177">Placer un lecteur XML sur le corps du message.</span><span class="sxs-lookup"><span data-stu-id="7f128-177">Getting an XML reader over the message body.</span></span> <span data-ttu-id="7f128-178">Cela vous permet d'accéder ultérieurement au corps du message élément par élément selon vos besoins.</span><span class="sxs-lookup"><span data-stu-id="7f128-178">This enables you to later access the message body piece-by-piece as required.</span></span> <span data-ttu-id="7f128-179">C’est ce que l’on appelle *la lecture d’un message*.</span><span class="sxs-lookup"><span data-stu-id="7f128-179">This is referred to as *reading a message*.</span></span>  
  
- <span data-ttu-id="7f128-180">L'intégralité du message, y compris son corps, peut être copiée vers un tampon en mémoire du type <xref:System.ServiceModel.Channels.MessageBuffer>.</span><span class="sxs-lookup"><span data-stu-id="7f128-180">The entire message, including its body, can be copied to an in-memory buffer of the <xref:System.ServiceModel.Channels.MessageBuffer> type.</span></span> <span data-ttu-id="7f128-181">On parle alors de *copie d’un message*.</span><span class="sxs-lookup"><span data-stu-id="7f128-181">This is referred to as *copying a message*.</span></span>  
  
 <span data-ttu-id="7f128-182">Vous pouvez accéder au corps d'un `Message` une seule fois, indépendamment du mode d'accès.</span><span class="sxs-lookup"><span data-stu-id="7f128-182">You can access the body of a `Message` only once, regardless of how it is accessed.</span></span> <span data-ttu-id="7f128-183">Un objet de message possède une propriété `State`, qui a initialement la valeur Créé.</span><span class="sxs-lookup"><span data-stu-id="7f128-183">A message object has a `State` property, which is initially set to Created.</span></span> <span data-ttu-id="7f128-184">Les trois méthodes d'accès décrites dans la liste précédente définissent respectivement l'état à Écrit, Lu et Copié.</span><span class="sxs-lookup"><span data-stu-id="7f128-184">The three access methods described in the preceding list set the state to Written, Read, and Copied, respectively.</span></span> <span data-ttu-id="7f128-185">En outre, une méthode `Close` peut définir l'état à Fermé lorsque le contenu du corps de message n'est plus nécessaire.</span><span class="sxs-lookup"><span data-stu-id="7f128-185">Additionally, a `Close` method can set the state to Closed when the message body contents are no longer required.</span></span> <span data-ttu-id="7f128-186">Le corps du message est accessible uniquement à l'état Créé et il n'existe aucun moyen de revenir à l'état Créé après que l'état a changé.</span><span class="sxs-lookup"><span data-stu-id="7f128-186">The message body can be accessed only in the Created state, and there is no way to go back to the Created state after the state has changed.</span></span>  
  
## <a name="writing-messages"></a><span data-ttu-id="7f128-187">Écriture de messages</span><span class="sxs-lookup"><span data-stu-id="7f128-187">Writing Messages</span></span>  
 <span data-ttu-id="7f128-188">La méthode <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> écrit le contenu du corps d'une instance `Message` donnée dans un enregistreur XML donné.</span><span class="sxs-lookup"><span data-stu-id="7f128-188">The <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method writes out the body contents of a given `Message` instance to a given XML writer.</span></span> <span data-ttu-id="7f128-189">La <xref:System.ServiceModel.Channels.Message.WriteBody%2A> méthode fait de même, mais elle englobe le contenu du corps dans l’élément wrapper approprié (par exemple, <`soap:body`>).</span><span class="sxs-lookup"><span data-stu-id="7f128-189">The <xref:System.ServiceModel.Channels.Message.WriteBody%2A> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, <`soap:body`>).</span></span> <span data-ttu-id="7f128-190">Pour finir, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> écrit le message entier, y compris l'enveloppe SOAP et les en-têtes.</span><span class="sxs-lookup"><span data-stu-id="7f128-190">Finally, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> writes out the entire message, including the wrapping SOAP envelope and the headers.</span></span> <span data-ttu-id="7f128-191">Si SOAP est désactivé ( <xref:System.ServiceModel.Channels.Message.Version> a <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> la valeur), les trois méthodes font la même chose : elles écrivent le contenu du corps du message.</span><span class="sxs-lookup"><span data-stu-id="7f128-191">If SOAP is turned off (<xref:System.ServiceModel.Channels.Message.Version> is <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>), all three methods do the same thing: they write out the message body contents.</span></span>  
  
 <span data-ttu-id="7f128-192">Par exemple, le code suivant écrit le corps d'un message entrant dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="7f128-192">For example, the following code writes out the body of an incoming message to a file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#5)]
 [!code-vb[C_UsingTheMessageClass#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#5)]  
  
 <span data-ttu-id="7f128-193">Deux méthodes d’assistance supplémentaires écrivent certaines étiquettes d’élément de début SOAP.</span><span class="sxs-lookup"><span data-stu-id="7f128-193">Two additional helper methods write out certain SOAP start element tags.</span></span> <span data-ttu-id="7f128-194">Ces méthodes n'accèdent pas au corps du message ; elles ne modifient donc pas l'état du message.</span><span class="sxs-lookup"><span data-stu-id="7f128-194">These methods do not access the message body and so they do not change the message state.</span></span> <span data-ttu-id="7f128-195">notamment :</span><span class="sxs-lookup"><span data-stu-id="7f128-195">These include:</span></span>  
  
- <span data-ttu-id="7f128-196"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> écrit l'élément de corps de début, par exemple `<soap:Body>`.</span><span class="sxs-lookup"><span data-stu-id="7f128-196"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> writes the start body element, for example, `<soap:Body>`.</span></span>  
  
- <span data-ttu-id="7f128-197"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> écrit l'élément d'enveloppe de début, par exemple `<soap:Envelope>`.</span><span class="sxs-lookup"><span data-stu-id="7f128-197"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> writes the start envelope element, for example, `<soap:Envelope>`.</span></span>  
  
 <span data-ttu-id="7f128-198">Pour écrire les balises d'élément de fin correspondantes, appelez `WriteEndElement` sur l'enregistreur XML correspondant.</span><span class="sxs-lookup"><span data-stu-id="7f128-198">To write the corresponding end element tags, call `WriteEndElement` on the corresponding XML writer.</span></span> <span data-ttu-id="7f128-199">Ces méthodes sont rarement appelées directement.</span><span class="sxs-lookup"><span data-stu-id="7f128-199">These methods are rarely called directly.</span></span>  
  
## <a name="reading-messages"></a><span data-ttu-id="7f128-200">Lecture de messages</span><span class="sxs-lookup"><span data-stu-id="7f128-200">Reading Messages</span></span>  
 <span data-ttu-id="7f128-201">La principale manière de lire un corps de message consiste à appeler <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f128-201">The primary way to read a message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>.</span></span> <span data-ttu-id="7f128-202">Vous récupérez un <xref:System.Xml.XmlDictionaryReader> que vous pouvez utiliser pour lire le corps du message.</span><span class="sxs-lookup"><span data-stu-id="7f128-202">You get back an <xref:System.Xml.XmlDictionaryReader> that you can use to read the message body.</span></span> <span data-ttu-id="7f128-203">Notez que le <xref:System.ServiceModel.Channels.Message> bascule à l'état Lu dès que <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> est appelée, et non lorsque vous utilisez le lecteur XML retourné.</span><span class="sxs-lookup"><span data-stu-id="7f128-203">Note that the <xref:System.ServiceModel.Channels.Message> transitions to the Read state as soon as <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> is called, and not when you use the returned XML reader.</span></span>  
  
 <span data-ttu-id="7f128-204">La méthode <xref:System.ServiceModel.Channels.Message.GetBody%2A> vous permet également d'accéder au corps du message en tant qu'objet typé.</span><span class="sxs-lookup"><span data-stu-id="7f128-204">The <xref:System.ServiceModel.Channels.Message.GetBody%2A> method also enables you to access the message body as a typed object.</span></span> <span data-ttu-id="7f128-205">En interne, cette méthode utilise `GetReaderAtBodyContents` et fait donc également basculer le message à l'état <xref:System.ServiceModel.Channels.MessageState.Read> (consultez la propriété <xref:System.ServiceModel.Channels.Message.State%2A>).</span><span class="sxs-lookup"><span data-stu-id="7f128-205">Internally, this method uses `GetReaderAtBodyContents`, and so it also transitions the message state to the <xref:System.ServiceModel.Channels.MessageState.Read> state (see the <xref:System.ServiceModel.Channels.Message.State%2A> property).</span></span>  
  
 <span data-ttu-id="7f128-206">Il est conseillé de vérifier la propriété <xref:System.ServiceModel.Channels.Message.IsEmpty%2A>, auquel cas le corps du message est vide et <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> lève une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="7f128-206">It is good practice to check the <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property, in which case the message body is empty and <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="7f128-207">En outre, s'il s'agit d'un message reçu (par exemple, la réponse), vous souhaiterez peut-être également vérifier <xref:System.ServiceModel.Channels.Message.IsFault%2A>, qui indique si le message contient une erreur.</span><span class="sxs-lookup"><span data-stu-id="7f128-207">Also, if it is a received message (for example, the reply), you may also want to check <xref:System.ServiceModel.Channels.Message.IsFault%2A>, which indicates whether the message contains a fault.</span></span>  
  
 <span data-ttu-id="7f128-208">La surcharge la plus simple de <xref:System.ServiceModel.Channels.Message.GetBody%2A> désérialise le corps du message dans une instance d'un type (indiqué par le paramètre générique) à l'aide d'un <xref:System.Runtime.Serialization.DataContractSerializer> configuré avec les paramètres par défaut et avec le quota <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> désactivé.</span><span class="sxs-lookup"><span data-stu-id="7f128-208">The most basic overload of <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <xref:System.Runtime.Serialization.DataContractSerializer> configured with the default settings and with the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> quota disabled.</span></span> <span data-ttu-id="7f128-209">Si vous souhaitez utiliser un moteur de sérialisation différent ou configurer le `DataContractSerializer` de manière personnalisée, utilisez la surcharge <xref:System.ServiceModel.Channels.Message.GetBody%2A> qui prend un <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span><span class="sxs-lookup"><span data-stu-id="7f128-209">If you want to use a different serialization engine, or configure the `DataContractSerializer` in a non-default way, use the <xref:System.ServiceModel.Channels.Message.GetBody%2A> overload that takes an <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
 <span data-ttu-id="7f128-210">Par exemple, le code suivant extrait des données d'un corps de message qui contient un objet `Person` sérialisé et imprime le nom de la personne.</span><span class="sxs-lookup"><span data-stu-id="7f128-210">For example, the following code extracts data from a message body that contains a serialized `Person` object and prints out the person’s name.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#6)]
 [!code-vb[C_UsingTheMessageClass#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#6)]  
  
## <a name="copying-a-message-into-a-buffer"></a><span data-ttu-id="7f128-211">Copie d'un message dans une mémoire tampon</span><span class="sxs-lookup"><span data-stu-id="7f128-211">Copying a Message into a Buffer</span></span>  
 <span data-ttu-id="7f128-212">Il est parfois nécessaire d'accéder au corps de message à plusieurs reprises, par exemple pour transférer le même message vers plusieurs destinations dans le cadre d'un système éditeur-abonné.</span><span class="sxs-lookup"><span data-stu-id="7f128-212">Sometimes it is necessary to access the message body more than once, for example, to forward the same message to multiple destinations as part of a publisher-subscriber system.</span></span> <span data-ttu-id="7f128-213">Dans ce cas, il est nécessaire de mettre en mémoire tampon l'intégralité du message (y compris le corps).</span><span class="sxs-lookup"><span data-stu-id="7f128-213">In this case, it is necessary to buffer the entire message (including the body) in memory.</span></span> <span data-ttu-id="7f128-214">Vous pouvez pour cela appeler <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>.</span><span class="sxs-lookup"><span data-stu-id="7f128-214">You can do this by calling <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>.</span></span> <span data-ttu-id="7f128-215">Cette méthode prend un paramètre entier qui représente la taille maximale de la mémoire tampon et crée une mémoire tampon inférieure à cette taille.</span><span class="sxs-lookup"><span data-stu-id="7f128-215">This method takes an integer parameter that represents the maximum buffer size, and creates a buffer not larger than this size.</span></span> <span data-ttu-id="7f128-216">Il est important d'affecter à ce paramètre une valeur sûre si le message provient d'une source non fiable.</span><span class="sxs-lookup"><span data-stu-id="7f128-216">It is important to set this to a safe value if the message is coming from an untrusted source.</span></span>  
  
 <span data-ttu-id="7f128-217">Le tampon est retourné en tant qu'instance <xref:System.ServiceModel.Channels.MessageBuffer>.</span><span class="sxs-lookup"><span data-stu-id="7f128-217">The buffer is returned as a <xref:System.ServiceModel.Channels.MessageBuffer> instance.</span></span> <span data-ttu-id="7f128-218">Vous pouvez accéder aux données de la mémoire tampon de plusieurs manières.</span><span class="sxs-lookup"><span data-stu-id="7f128-218">You can access data in the buffer in several ways.</span></span> <span data-ttu-id="7f128-219">La principale consiste à appeler <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> pour créer des instances `Message` à partir de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="7f128-219">The primary way is to call <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> to create `Message` instances from the buffer.</span></span>  
  
 <span data-ttu-id="7f128-220">Une autre manière d'accéder aux données dans la mémoire tampon consiste à implémenter l'interface <xref:System.Xml.XPath.IXPathNavigable> que la classe <xref:System.ServiceModel.Channels.MessageBuffer> implémente pour accéder directement au XML sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="7f128-220">Another way to access the data in the buffer is to implement the <xref:System.Xml.XPath.IXPathNavigable> interface that the <xref:System.ServiceModel.Channels.MessageBuffer> class implements to access the underlying XML directly.</span></span> <span data-ttu-id="7f128-221">Certaines surcharges <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> vous permettent de créer des navigateurs <xref:System.Xml.XPath> protégés par un quota de nœud, qui limite le nombre de nœuds XML qui peuvent être visités.</span><span class="sxs-lookup"><span data-stu-id="7f128-221">Some <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> overloads allow you to create <xref:System.Xml.XPath> navigators protected by a node quota, limiting the number of XML nodes that can be visited.</span></span> <span data-ttu-id="7f128-222">Cela aide à empêcher les attaques par déni de service basées sur les durées de traitement prolongées.</span><span class="sxs-lookup"><span data-stu-id="7f128-222">This helps prevent denial of service attacks based on lengthy processing time.</span></span> <span data-ttu-id="7f128-223">Ce quota est désactivé par défaut.</span><span class="sxs-lookup"><span data-stu-id="7f128-223">This quote is disabled by default.</span></span> <span data-ttu-id="7f128-224">Certaines surcharges `CreateNavigator` vous permettent de spécifier la façon dont les caractères d'espace doivent être gérés dans le XML à l'aide de l'énumération <xref:System.Xml.XmlSpace>, la valeur par défaut étant `XmlSpace.None`.</span><span class="sxs-lookup"><span data-stu-id="7f128-224">Some `CreateNavigator` overloads allow you to specify how white space should be handled in the XML using the <xref:System.Xml.XmlSpace> enumeration, with the default being `XmlSpace.None`.</span></span>  
  
 <span data-ttu-id="7f128-225">La dernière manière d'accéder au contenu d'un tampon de messages consiste à écrire son contenu dans un flux à l'aide de <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f128-225">A final way to access the contents of a message buffer is to write out its contents to a stream using <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.</span></span>  
  
 <span data-ttu-id="7f128-226">L'exemple suivant illustre le processus d'utilisation d'un `MessageBuffer` : un message entrant est transféré à plusieurs destinataires, puis enregistré dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="7f128-226">The following example demonstrates the process of working with a `MessageBuffer`: an incoming message is forwarded to multiple recipients, and then logged to a file.</span></span> <span data-ttu-id="7f128-227">Sans mise en mémoire tampon cela est impossible, car le corps du message est alors accessible une seule fois.</span><span class="sxs-lookup"><span data-stu-id="7f128-227">Without buffering, this is not possible, because the message body can then be accessed only once.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#7)]
 [!code-vb[C_UsingTheMessageClass#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#7)]  
  
 <span data-ttu-id="7f128-228">La classe `MessageBuffer` a d'autres membres dont il convient de parler.</span><span class="sxs-lookup"><span data-stu-id="7f128-228">The `MessageBuffer` class has other members worth noting.</span></span> <span data-ttu-id="7f128-229">La méthode <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> peut être appelée pour libérer des ressources lorsque le contenu de la mémoire tampon n'est plus nécessaire.</span><span class="sxs-lookup"><span data-stu-id="7f128-229">The <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> method can be called to free resources when the buffer contents are no longer required.</span></span> <span data-ttu-id="7f128-230">La propriété <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> retourne la taille de la mémoire tampon allouée.</span><span class="sxs-lookup"><span data-stu-id="7f128-230">The <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> property returns the size of the allocated buffer.</span></span> <span data-ttu-id="7f128-231">La propriété <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> retourne le type de contenu MIME du message.</span><span class="sxs-lookup"><span data-stu-id="7f128-231">The <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> property returns the MIME content type of the message.</span></span>  
  
## <a name="accessing-the-message-body-for-debugging"></a><span data-ttu-id="7f128-232">Accès au corps de message à des fins de débogage</span><span class="sxs-lookup"><span data-stu-id="7f128-232">Accessing the Message Body for Debugging</span></span>  
 <span data-ttu-id="7f128-233">À des fins de débogage, vous pouvez appeler la méthode <xref:System.ServiceModel.Channels.Message.ToString%2A> pour obtenir une représentation du message sous forme de chaîne.</span><span class="sxs-lookup"><span data-stu-id="7f128-233">For debugging purposes, you can call the <xref:System.ServiceModel.Channels.Message.ToString%2A> method to get a representation of the message as a string.</span></span> <span data-ttu-id="7f128-234">Cette représentation correspond généralement à l'aspect qu'aurait un message sur le câble s'il était encodé avec l'encodeur de texte, mais le XML est mis en forme pour une meilleure lisibilité.</span><span class="sxs-lookup"><span data-stu-id="7f128-234">This representation generally matches the way a message would look on the wire if it were encoded with the text encoder, except that the XML would be better formatted for human readability.</span></span> <span data-ttu-id="7f128-235">L'unique exception concerne le corps du message.</span><span class="sxs-lookup"><span data-stu-id="7f128-235">The one exception to this is the message body.</span></span> <span data-ttu-id="7f128-236">Le corps ne peut être lu qu'une seule fois et `ToString` ne modifie pas l'état du message.</span><span class="sxs-lookup"><span data-stu-id="7f128-236">The body can be read only once, and `ToString` does not change the message state.</span></span> <span data-ttu-id="7f128-237">Par conséquent, la `ToString` méthode peut ne pas être en mesure d’accéder au corps et peut substituer un espace réservé (par exemple, « ... » ou trois points) au lieu du corps du message.</span><span class="sxs-lookup"><span data-stu-id="7f128-237">Therefore, the `ToString` method might not be able to access the body and might substitute a placeholder (for example, "…" or three dots) instead of the message body.</span></span> <span data-ttu-id="7f128-238">Par conséquent, vous ne devez pas utiliser `ToString` pour enregistrer des messages si le contenu du corps des messages est important.</span><span class="sxs-lookup"><span data-stu-id="7f128-238">Therefore, do not use `ToString` to log messages if the body content of the messages is important.</span></span>  
  
## <a name="accessing-other-message-parts"></a><span data-ttu-id="7f128-239">Accès à d'autres parties de message</span><span class="sxs-lookup"><span data-stu-id="7f128-239">Accessing Other Message Parts</span></span>  
 <span data-ttu-id="7f128-240">Différentes propriétés sont fournies pour accéder aux informations relatives au message autres que le contenu de son corps.</span><span class="sxs-lookup"><span data-stu-id="7f128-240">Various properties are provided to access information about the message other than its body contents.</span></span> <span data-ttu-id="7f128-241">Toutefois, celles-ci ne peuvent pas être appelées une fois que le message a été fermé :</span><span class="sxs-lookup"><span data-stu-id="7f128-241">However, these cannot be called once the message has been closed:</span></span>  
  
- <span data-ttu-id="7f128-242">La propriété <xref:System.ServiceModel.Channels.Message.Headers%2A> représente les en-têtes de messages.</span><span class="sxs-lookup"><span data-stu-id="7f128-242">The <xref:System.ServiceModel.Channels.Message.Headers%2A> property represents the message headers.</span></span> <span data-ttu-id="7f128-243">Consultez la section « utilisation des en-têtes » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="7f128-243">See the section on "Working with Headers" later in this topic.</span></span>  
  
- <span data-ttu-id="7f128-244">La propriété <xref:System.ServiceModel.Channels.Message.Properties%2A> représente les propriétés du message, qui sont des éléments de données nommées joints au message qui ne sont généralement pas émis lorsque le message est envoyé.</span><span class="sxs-lookup"><span data-stu-id="7f128-244">The <xref:System.ServiceModel.Channels.Message.Properties%2A> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent.</span></span> <span data-ttu-id="7f128-245">Consultez la section « Utilisation des propriétés » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="7f128-245">See the section on "Working with Properties" later in this topic.</span></span>  
  
- <span data-ttu-id="7f128-246">La propriété <xref:System.ServiceModel.Channels.Message.Version%2A> indique la version SOAP et WS-Addressing associée au message, ou `None` si SOAP est désactivé.</span><span class="sxs-lookup"><span data-stu-id="7f128-246">The <xref:System.ServiceModel.Channels.Message.Version%2A> property indicates the SOAP and WS-Addressing version associated with the message, or `None` if SOAP is disabled.</span></span>  
  
- <span data-ttu-id="7f128-247">La propriété <xref:System.ServiceModel.Channels.Message.IsFault%2A> retourne la valeur `true` si le message est un message d'erreur SOAP.</span><span class="sxs-lookup"><span data-stu-id="7f128-247">The <xref:System.ServiceModel.Channels.Message.IsFault%2A> property returns `true` if the message is a SOAP fault message.</span></span>  
  
- <span data-ttu-id="7f128-248">La propriété <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> retourne `true` si le message est vide.</span><span class="sxs-lookup"><span data-stu-id="7f128-248">The <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property returns `true` if the message is empty.</span></span>  
  
 <span data-ttu-id="7f128-249">Vous pouvez utiliser la méthode <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> pour accéder à un attribut particulier sur l'élément wrapper de corps (par exemple, `<soap:Body>`) identifié par un nom et un espace de noms particuliers.</span><span class="sxs-lookup"><span data-stu-id="7f128-249">You can use the <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> method to access a particular attribute on the body wrapper element (for example, `<soap:Body>`) identified by a particular name and namespace.</span></span> <span data-ttu-id="7f128-250">Si ce type d'attribut est introuvable, `null` est retourné.</span><span class="sxs-lookup"><span data-stu-id="7f128-250">If such an attribute is not found, `null` is returned.</span></span> <span data-ttu-id="7f128-251">Cette méthode peut être appelée uniquement lorsque le `Message` est à l'état Créé (lorsque le corps du message n'a pas encore été accédé).</span><span class="sxs-lookup"><span data-stu-id="7f128-251">This method can be called only when the `Message` is in the Created state (when the message body has not yet been accessed).</span></span>  
  
## <a name="working-with-headers"></a><span data-ttu-id="7f128-252">Utilisation des en-têtes</span><span class="sxs-lookup"><span data-stu-id="7f128-252">Working with Headers</span></span>  
 <span data-ttu-id="7f128-253">Un `Message` peut contenir un nombre quelconque de fragments XML nommés, appelés *en-têtes*.</span><span class="sxs-lookup"><span data-stu-id="7f128-253">A `Message` can contain any number of named XML fragments, called *headers*.</span></span> <span data-ttu-id="7f128-254">Chaque fragment est normalement mappé à un en-tête SOAP.</span><span class="sxs-lookup"><span data-stu-id="7f128-254">Each fragment normally maps to a SOAP header.</span></span> <span data-ttu-id="7f128-255">Les en-têtes sont accessibles via la propriété `Headers` de type <xref:System.ServiceModel.Channels.MessageHeaders>.</span><span class="sxs-lookup"><span data-stu-id="7f128-255">Headers are accessed through the `Headers` property of type <xref:System.ServiceModel.Channels.MessageHeaders>.</span></span> <span data-ttu-id="7f128-256"><xref:System.ServiceModel.Channels.MessageHeaders> est une collection d'objets <xref:System.ServiceModel.Channels.MessageHeaderInfo>, et des en-têtes sont accessibles via son interface <xref:System.Collections.IEnumerable> ou via son indexeur.</span><span class="sxs-lookup"><span data-stu-id="7f128-256"><xref:System.ServiceModel.Channels.MessageHeaders> is a collection of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects, and individual headers can be accessed through its <xref:System.Collections.IEnumerable> interface or through its indexer.</span></span> <span data-ttu-id="7f128-257">Par exemple, le code suivant répertorie les noms de tous les en-têtes dans un `Message`.</span><span class="sxs-lookup"><span data-stu-id="7f128-257">For example, the following code lists the names of all the headers in a `Message`.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#8)]
 [!code-vb[C_UsingTheMessageClass#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#8)]  
  
#### <a name="adding-removing-finding-headers"></a><span data-ttu-id="7f128-258">Ajout, suppression et recherche d'en-têtes</span><span class="sxs-lookup"><span data-stu-id="7f128-258">Adding, Removing, Finding Headers</span></span>  
 <span data-ttu-id="7f128-259">Vous pouvez ajouter un nouvel en-tête à la fin de tous les en-têtes existants à l'aide de la méthode <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f128-259">You can add a new header at the end of all existing headers using the <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> method.</span></span> <span data-ttu-id="7f128-260">Vous pouvez utiliser la méthode <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> pour insérer un en-tête à un index particulier.</span><span class="sxs-lookup"><span data-stu-id="7f128-260">You can use the <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> method to insert a header at a particular index.</span></span> <span data-ttu-id="7f128-261">Les en-têtes existants sont décalés pour faire place à l'élément inséré.</span><span class="sxs-lookup"><span data-stu-id="7f128-261">Existing headers are shifted for the inserted item.</span></span> <span data-ttu-id="7f128-262">Les en-têtes sont ordonnés en fonction de leur index, le premier index disponible étant 0.</span><span class="sxs-lookup"><span data-stu-id="7f128-262">Headers are ordered according to their index, and the first available index is 0.</span></span> <span data-ttu-id="7f128-263">Vous pouvez utiliser les différentes surcharges de méthodes <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> pour ajouter des en-têtes à partir d'une instance `Message` ou `MessageHeaders` différente.</span><span class="sxs-lookup"><span data-stu-id="7f128-263">You can use the various <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> method overloads to add headers from a different `Message` or `MessageHeaders` instance.</span></span> <span data-ttu-id="7f128-264">Certaines surcharges copient un en-tête individuel, tandis que d'autres les copient tous.</span><span class="sxs-lookup"><span data-stu-id="7f128-264">Some overloads copy one individual header, while others copy all of them.</span></span> <span data-ttu-id="7f128-265">La méthode <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> supprime tous les en-têtes.</span><span class="sxs-lookup"><span data-stu-id="7f128-265">The <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> method removes all headers.</span></span> <span data-ttu-id="7f128-266">La méthode <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> supprime un en-tête à un index particulier (et décale tous les en-têtes situés après lui).</span><span class="sxs-lookup"><span data-stu-id="7f128-266">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> method removes a header at a particular index (shifting all headers after it).</span></span> <span data-ttu-id="7f128-267">La méthode <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> supprime tous les en-têtes avec un nom et un espace de noms particuliers.</span><span class="sxs-lookup"><span data-stu-id="7f128-267">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> method removes all headers with a particular name and namespace.</span></span>  
  
 <span data-ttu-id="7f128-268">Vous pouvez récupérer un en-tête particulier à l'aide de la méthode <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f128-268">Retrieve a particular header using the <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> method.</span></span> <span data-ttu-id="7f128-269">Cette méthode prend le nom et l'espace de noms de l'en-tête à rechercher et retourne son index.</span><span class="sxs-lookup"><span data-stu-id="7f128-269">This method takes the name and namespace of the header to find, and returns its index.</span></span> <span data-ttu-id="7f128-270">Si l'en-tête est présent plus d'une fois, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="7f128-270">If the header occurs more than once, an exception is thrown.</span></span> <span data-ttu-id="7f128-271">Si l'en-tête est introuvable, la méthode retourne la valeur -1.</span><span class="sxs-lookup"><span data-stu-id="7f128-271">If the header is not found, it returns -1.</span></span>  
  
 <span data-ttu-id="7f128-272">Dans le modèle d'en-tête SOAP, les en-têtes peuvent avoir une valeur `Actor` qui spécifie le destinataire prévu de l'en-tête.</span><span class="sxs-lookup"><span data-stu-id="7f128-272">In the SOAP header model, headers can have an `Actor` value that specifies the intended recipient of the header.</span></span> <span data-ttu-id="7f128-273">La surcharge `FindHeader` la plus simple recherche uniquement les en-têtes destinés au destinataire final du message.</span><span class="sxs-lookup"><span data-stu-id="7f128-273">The most basic `FindHeader` overload searches only headers intended for the ultimate receiver of the message.</span></span> <span data-ttu-id="7f128-274">Toutefois, une autre surcharge vous permet de spécifier les valeurs `Actor` qui sont incluses dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="7f128-274">However, another overload enables you to specify which `Actor` values are included in the search.</span></span> <span data-ttu-id="7f128-275">Pour plus d’informations, consultez la spécification SOAP.</span><span class="sxs-lookup"><span data-stu-id="7f128-275">For more information, see the SOAP specification.</span></span>  
  
 <span data-ttu-id="7f128-276">Une méthode <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> est fournie pour copier des en-têtes depuis une collection <xref:System.ServiceModel.Channels.MessageHeaders> vers un tableau d’objets <xref:System.ServiceModel.Channels.MessageHeaderInfo>.</span><span class="sxs-lookup"><span data-stu-id="7f128-276">A <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> method is provided to copy headers from a <xref:System.ServiceModel.Channels.MessageHeaders> collection to an array of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects.</span></span>  
  
 <span data-ttu-id="7f128-277">Pour accéder aux données XML dans un en-tête, vous pouvez appeler <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> et retourner un lecteur XML pour l'index d'en-tête spécifique.</span><span class="sxs-lookup"><span data-stu-id="7f128-277">To access the XML data in a header, you can call <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> and return an XML reader for the specific header index.</span></span> <span data-ttu-id="7f128-278">Si vous souhaitez désérialiser le contenu d'en-tête dans un objet, utilisez <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> ou l'une des autres surcharges.</span><span class="sxs-lookup"><span data-stu-id="7f128-278">If you want to deserialize the header contents into an object, use <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> or one of the other overloads.</span></span> <span data-ttu-id="7f128-279">Les surcharges les plus simples désérialisent les en-têtes à l'aide du <xref:System.Runtime.Serialization.DataContractSerializer> configuré de la manière par défaut.</span><span class="sxs-lookup"><span data-stu-id="7f128-279">The most basic overloads deserialize headers using the <xref:System.Runtime.Serialization.DataContractSerializer> configured in the default way.</span></span> <span data-ttu-id="7f128-280">Si vous souhaitez utiliser un sérialiseur différent ou une configuration différente du `DataContractSerializer`, utilisez l'une des surcharges qui prennent un `XmlObjectSerializer`.</span><span class="sxs-lookup"><span data-stu-id="7f128-280">If you want to use a different serializer or a different configuration of the `DataContractSerializer`, use one of the overloads that take an `XmlObjectSerializer`.</span></span> <span data-ttu-id="7f128-281">Il existe également des surcharges qui prennent le nom d'en-tête, l'espace de noms et éventuellement une liste de valeurs `Actor` au lieu d'un index ; il s'agit d'une combinaison de `FindHeader` et `GetHeader`.</span><span class="sxs-lookup"><span data-stu-id="7f128-281">There are also overloads that take the header name, namespace, and optionally a list of `Actor` values instead of an index; this is a combination of `FindHeader` and `GetHeader`.</span></span>  
  
## <a name="working-with-properties"></a><span data-ttu-id="7f128-282">Utilisation des propriétés</span><span class="sxs-lookup"><span data-stu-id="7f128-282">Working with Properties</span></span>  
 <span data-ttu-id="7f128-283">Une instance de `Message` peut contenir un nombre arbitraire d'objets nommés de types arbitraires.</span><span class="sxs-lookup"><span data-stu-id="7f128-283">A `Message` instance can contain an arbitrary number of named objects of arbitrary types.</span></span> <span data-ttu-id="7f128-284">Cette collection est accessible par le biais de la propriété `Properties` de type `MessageProperties`.</span><span class="sxs-lookup"><span data-stu-id="7f128-284">This collection is accessed through the `Properties` property of type `MessageProperties`.</span></span> <span data-ttu-id="7f128-285">La collection implémente l'interface <xref:System.Collections.Generic.IDictionary%602> et agit comme mappage de <xref:System.String> à <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="7f128-285">The collection implements the <xref:System.Collections.Generic.IDictionary%602> interface and acts as a mapping from <xref:System.String> to <xref:System.Object>.</span></span> <span data-ttu-id="7f128-286">Normalement, les valeurs de propriété ne correspondent pas directement à une partie du message sur le câble, mais fournissent plutôt des indications de traitement de message aux différents canaux de la pile de canaux WCF ou à l' <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> infrastructure de service.</span><span class="sxs-lookup"><span data-stu-id="7f128-286">Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the WCF channel stack or to the <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> service framework.</span></span> <span data-ttu-id="7f128-287">Pour obtenir un exemple, consultez [transfert de données vue d’ensemble](data-transfer-architectural-overview.md)de l’architecture.</span><span class="sxs-lookup"><span data-stu-id="7f128-287">For an example, see [Data Transfer Architectural Overview](data-transfer-architectural-overview.md).</span></span>  
  
## <a name="inheriting-from-the-message-class"></a><span data-ttu-id="7f128-288">Héritage de la classe Message</span><span class="sxs-lookup"><span data-stu-id="7f128-288">Inheriting from the Message Class</span></span>  
 <span data-ttu-id="7f128-289">Si les types de messages intégrés créés à l'aide de `CreateMessage` ne répondent pas à vos spécifications, créez une classe qui dérive de la classe `Message`.</span><span class="sxs-lookup"><span data-stu-id="7f128-289">If the built-in message types created using `CreateMessage` do not meet your requirements, create a class that derives from the `Message` class.</span></span>  
  
### <a name="defining-the-message-body-contents"></a><span data-ttu-id="7f128-290">Définition du contenu du corps de message</span><span class="sxs-lookup"><span data-stu-id="7f128-290">Defining the Message Body Contents</span></span>  
 <span data-ttu-id="7f128-291">Il existe trois techniques principales d'accès aux données dans un corps de message : écriture, lecture et copie des données vers une mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="7f128-291">Three primary techniques exist for accessing data within a message body: writing, reading, and copying it to a buffer.</span></span> <span data-ttu-id="7f128-292">Ces opérations entraînent en fin de compte l'appel respectif des méthodes <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A> et <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> sur votre classe dérivée de `Message`.</span><span class="sxs-lookup"><span data-stu-id="7f128-292">These operations ultimately result in the <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods being called, respectively, on your derived class of `Message`.</span></span> <span data-ttu-id="7f128-293">La classe `Message` de base garantit qu'une seule de ces méthodes est appelée pour chaque instance `Message` et qu'elle n'est pas appelée plus d'une fois.</span><span class="sxs-lookup"><span data-stu-id="7f128-293">The base `Message` class guarantees that only one of these methods is called for each `Message` instance, and that it is not called more than once.</span></span> <span data-ttu-id="7f128-294">La classe de base garantit également que les méthodes ne sont pas appelées sur un message fermé.</span><span class="sxs-lookup"><span data-stu-id="7f128-294">The base class also ensures that the methods are not called on a closed message.</span></span> <span data-ttu-id="7f128-295">Il n'est pas nécessaire d'effectuer le suivi de l'état du message dans votre implémentation.</span><span class="sxs-lookup"><span data-stu-id="7f128-295">There is no need to track the message state in your implementation.</span></span>  
  
 <span data-ttu-id="7f128-296"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> est une méthode abstraite qui doit être implémentée.</span><span class="sxs-lookup"><span data-stu-id="7f128-296"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> is an abstract method and must be implemented.</span></span> <span data-ttu-id="7f128-297">La façon la plus simple de définir le contenu du corps de votre message consiste à écrire à l'aide de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="7f128-297">The most basic way to define the body contents of your message is to write using this method.</span></span> <span data-ttu-id="7f128-298">Par exemple, le message suivant contient 100 000 nombres aléatoires compris entre 1 et 20.</span><span class="sxs-lookup"><span data-stu-id="7f128-298">For example, the following message contains 100,000 random numbers from 1 to 20.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#9)]
 [!code-vb[C_UsingTheMessageClass#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#9)]  
  
 <span data-ttu-id="7f128-299">Les méthodes <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> et <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> ont des implémentations par défaut qui fonctionnent dans la plupart des cas.</span><span class="sxs-lookup"><span data-stu-id="7f128-299">The <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods have default implementations that work for most cases.</span></span> <span data-ttu-id="7f128-300">Les implémentations par défaut appellent <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, mettent en mémoire tampon les résultats et utilisent le tampon résultant.</span><span class="sxs-lookup"><span data-stu-id="7f128-300">The default implementations call <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, buffer the results, and work with the resulting buffer.</span></span> <span data-ttu-id="7f128-301">Toutefois, dans certains cas cela peut ne pas être suffisant.</span><span class="sxs-lookup"><span data-stu-id="7f128-301">However, in some cases this may not be enough.</span></span> <span data-ttu-id="7f128-302">Dans l'exemple précédent, la lecture du message provoque la mise en mémoire tampon de 100 000 éléments XML, ce qui peut être indésirable.</span><span class="sxs-lookup"><span data-stu-id="7f128-302">In the preceding example, reading the message results in 100,000 XML elements being buffered, which might not be desirable.</span></span> <span data-ttu-id="7f128-303">Vous souhaiterez peut-être substituer <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> pour retourner une classe dérivée <xref:System.Xml.XmlDictionaryReader> personnalisée qui sert des nombres aléatoires.</span><span class="sxs-lookup"><span data-stu-id="7f128-303">You might want to override <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> to return a custom <xref:System.Xml.XmlDictionaryReader> derived class that serves up random numbers.</span></span> <span data-ttu-id="7f128-304">Vous pouvez ensuite substituer <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> pour utiliser le lecteur retourné par la <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> méthode, comme indiqué dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="7f128-304">You can then override <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> to use the reader that the <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> method returns, as shown in the following example.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#10)]
 [!code-vb[C_UsingTheMessageClass#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#10)]  
  
 <span data-ttu-id="7f128-305">De même, vous souhaiterez peut-être substituer `OnCreateBufferedCopy` pour retourner votre propre classe dérivée `MessageBuffer`.</span><span class="sxs-lookup"><span data-stu-id="7f128-305">Similarly, you might want to override `OnCreateBufferedCopy` to return your own `MessageBuffer` derived class.</span></span>  
  
 <span data-ttu-id="7f128-306">En plus de fournir le contenu du corps de message, votre classe de message dérivée doit également substituer les propriétés `Version`, `Headers` et `Properties`.</span><span class="sxs-lookup"><span data-stu-id="7f128-306">In addition to providing message body contents, your message derived class must also override the `Version`, `Headers`, and `Properties` properties.</span></span>  
  
 <span data-ttu-id="7f128-307">Notez que si vous créez une copie d'un message, la copie utilise les en-têtes de messages de l'original.</span><span class="sxs-lookup"><span data-stu-id="7f128-307">Note that if you create a copy of a message, the copy uses the message headers from the original.</span></span>  
  
### <a name="other-members-that-can-be-overridden"></a><span data-ttu-id="7f128-308">Autres membres qui peuvent être substitués</span><span class="sxs-lookup"><span data-stu-id="7f128-308">Other Members that Can Be Overridden</span></span>  
 <span data-ttu-id="7f128-309">Vous pouvez substituer les <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A> <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> méthodes, et <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> pour spécifier le mode d’écriture de l’enveloppe SOAP, des en-têtes SOAP et des balises de début d’élément de corps SOAP. Celles-ci correspondent normalement à `<soap:Envelope>` , `<soap:Header>` et `<soap:Body>` .</span><span class="sxs-lookup"><span data-stu-id="7f128-309">You can override the <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to `<soap:Envelope>`, `<soap:Header>`, and `<soap:Body>`.</span></span> <span data-ttu-id="7f128-310">Ces méthodes ne doivent normalement rien écrire si la propriété <xref:System.ServiceModel.Channels.Message.Version> retourne <xref:System.ServiceModel.Channels.MessageVersion.None>.</span><span class="sxs-lookup"><span data-stu-id="7f128-310">These methods should normally not write anything out if the <xref:System.ServiceModel.Channels.Message.Version> property returns <xref:System.ServiceModel.Channels.MessageVersion.None>.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7f128-311">L'implémentation par défaut de `OnGetReaderAtBodyContents` appelle `OnWriteStartEnvelope` et `OnWriteStartBody` avant d'appeler `OnWriteBodyContents` et de mettre les résultats en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="7f128-311">The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results.</span></span> <span data-ttu-id="7f128-312">Les en-têtes ne sont pas écrits.</span><span class="sxs-lookup"><span data-stu-id="7f128-312">Headers are not written out.</span></span>  
  
 <span data-ttu-id="7f128-313">Substituez la méthode <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> pour modifier la façon dont le message entier est construit à partir de ses différents éléments.</span><span class="sxs-lookup"><span data-stu-id="7f128-313">Override the <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> method to change the way the entire message is constructed from its various pieces.</span></span> <span data-ttu-id="7f128-314">La méthode `OnWriteMessage` est appelée à partir de <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> et de l'implémentation <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> par défaut.</span><span class="sxs-lookup"><span data-stu-id="7f128-314">The `OnWriteMessage` method is called from <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> and from the default <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementation.</span></span> <span data-ttu-id="7f128-315">Notez que la substitution de <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> n'est pas recommandée.</span><span class="sxs-lookup"><span data-stu-id="7f128-315">Note that overriding <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> is not a best practice.</span></span> <span data-ttu-id="7f128-316">Il est préférable de substituer les méthodes `On` appropriées (par exemple, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> et <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f128-316">It is better to override the appropriate `On` methods (for example, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>.</span></span>  
  
 <span data-ttu-id="7f128-317">Substituez <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> afin de substituer la façon dont votre corps de message est représenté durant le débogage.</span><span class="sxs-lookup"><span data-stu-id="7f128-317">Override <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> to override how your message body is represented during debugging.</span></span> <span data-ttu-id="7f128-318">Le paramètre par défaut consiste à le représenter sous la forme de trois points (« … »).</span><span class="sxs-lookup"><span data-stu-id="7f128-318">The default is to represent it as three dots ("…").</span></span> <span data-ttu-id="7f128-319">Notez que cette méthode peut être appelée plusieurs fois lorsque l'état du message est autre que Fermé.</span><span class="sxs-lookup"><span data-stu-id="7f128-319">Note that this method can be called multiple times when the message state is anything other than Closed.</span></span> <span data-ttu-id="7f128-320">Une implémentation de cette méthode ne doit jamais provoquer d'action qui doit être exécutée une seule fois (telle que la lecture d'un flux avant uniquement).</span><span class="sxs-lookup"><span data-stu-id="7f128-320">An implementation of this method should never cause any action that must be performed only once (such as reading from a forward-only stream).</span></span>  
  
 <span data-ttu-id="7f128-321">Substituez la méthode <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> pour autoriser l'accès aux attributs sur l'élément de corps SOAP.</span><span class="sxs-lookup"><span data-stu-id="7f128-321">Override the <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> method to allow access to attributes on the SOAP body element.</span></span> <span data-ttu-id="7f128-322">Cette méthode peut être appelée un nombre de fois quelconque, mais le type de base `Message` garantit son appel uniquement lorsque le message est à l'état Créé.</span><span class="sxs-lookup"><span data-stu-id="7f128-322">This method can be called any number of times, but the `Message` base type guarantees that it is only called when the message is in the Created state.</span></span> <span data-ttu-id="7f128-323">Il n'est pas nécessaire de vérifier l'état dans une implémentation.</span><span class="sxs-lookup"><span data-stu-id="7f128-323">It is not required to check the state in an implementation.</span></span> <span data-ttu-id="7f128-324">L'implémentation par défaut retourne toujours `null`, ce qui indique qu'il n'y a pas d'attributs sur l'élément de corps.</span><span class="sxs-lookup"><span data-stu-id="7f128-324">The default implementation always returns `null`, which indicates that there are no attributes on the body element.</span></span>  
  
 <span data-ttu-id="7f128-325">Si votre objet `Message` doit effectuer un nettoyage spécial lorsque le corps du message n'est plus nécessaire, vous pouvez substituer <xref:System.ServiceModel.Channels.Message.OnClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f128-325">If your `Message` object must do any special cleanup when the message body is no longer required, you can override <xref:System.ServiceModel.Channels.Message.OnClose%2A>.</span></span> <span data-ttu-id="7f128-326">L'implémentation par défaut n'exécute aucune opération.</span><span class="sxs-lookup"><span data-stu-id="7f128-326">The default implementation does nothing.</span></span>  
  
 <span data-ttu-id="7f128-327">Les propriétés `IsEmpty` et `IsFault` peuvent être substituées.</span><span class="sxs-lookup"><span data-stu-id="7f128-327">The `IsEmpty` and `IsFault` properties can be overridden.</span></span> <span data-ttu-id="7f128-328">Par défaut, toutes deux retournent la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="7f128-328">By default, both return `false`.</span></span>
