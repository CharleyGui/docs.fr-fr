---
title: Gestion des messages incohérents
ms.date: 03/30/2017
ms.assetid: 8d1c5e5a-7928-4a80-95ed-d8da211b8595
ms.openlocfilehash: ff1eaec99308b06250722b290b7005ac21731570
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337643"
---
# <a name="poison-message-handling"></a><span data-ttu-id="ae870-102">Gestion des messages incohérents</span><span class="sxs-lookup"><span data-stu-id="ae870-102">Poison Message Handling</span></span>
<span data-ttu-id="ae870-103">Un *message incohérent* est un message qui a dépassé le nombre maximal de tentatives de remise à l’application.</span><span class="sxs-lookup"><span data-stu-id="ae870-103">A *poison message* is a message that has exceeded the maximum number of delivery attempts to the application.</span></span> <span data-ttu-id="ae870-104">Cette situation peut survenir lorsqu'une application basée sur file d'attente ne peut pas traiter un message car des erreurs se sont produites.</span><span class="sxs-lookup"><span data-stu-id="ae870-104">This situation can arise when a queue-based application cannot process a message because of errors.</span></span> <span data-ttu-id="ae870-105">Pour faire face aux demandes de fiabilité, une application en file d’attente reçoit des messages sous une transaction.</span><span class="sxs-lookup"><span data-stu-id="ae870-105">To meet reliability demands, a queued application receives messages under a transaction.</span></span> <span data-ttu-id="ae870-106">L’abandon de la transaction dans laquelle un message en file d’attente a été reçu laisse le message dans la file d’attente afin qu’une nouvelle tentative de remise puisse être effectuée sous une nouvelle transaction.</span><span class="sxs-lookup"><span data-stu-id="ae870-106">Aborting the transaction in which a queued message was received leaves the message in the queue so that the message is retried under a new transaction.</span></span> <span data-ttu-id="ae870-107">Si le problème qui a provoqué l'abandon de la transaction n'est pas résolu, l'application réceptrice peut être bloquée dans une réception et un abandon en boucle du même message jusqu'à ce que le nombre maximal de tentatives de remise soit dépassé et qu'un message incohérent soit généré.</span><span class="sxs-lookup"><span data-stu-id="ae870-107">If the problem that caused the transaction to abort is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until the maximum number of delivery attempts has been exceeded and a poison message results.</span></span>  
  
 <span data-ttu-id="ae870-108">Un message peut devenir incohérent pour de nombreuses raisons.</span><span class="sxs-lookup"><span data-stu-id="ae870-108">A message can become a poison message for many reasons.</span></span> <span data-ttu-id="ae870-109">Les raisons les plus courantes sont spécifiques à l'application.</span><span class="sxs-lookup"><span data-stu-id="ae870-109">The most common reasons are application specific.</span></span> <span data-ttu-id="ae870-110">Par exemple, si une application lit un message à partir d'une file d'attente et exécute un traitement de base de données, il est possible qu'elle ne parvienne pas à obtenir un verrou sur la base de données, provoquant ainsi l'abandon de la transaction.</span><span class="sxs-lookup"><span data-stu-id="ae870-110">For example, if an application reads a message from a queue and performs some database processing, the application may fail to get a lock on the database, causing it to abort the transaction.</span></span> <span data-ttu-id="ae870-111">Parce que la transaction de base de données a été abandonnée, le message reste dans la file d'attente, ce qui conduit l'application à relire le message une deuxième fois et à tenter de nouveau d'acquérir un verrou sur la base de données.</span><span class="sxs-lookup"><span data-stu-id="ae870-111">Because the database transaction was aborted, the message remains in the queue, which causes the application to reread the message a second time and make another attempt to acquire a lock on the database.</span></span> <span data-ttu-id="ae870-112">Les messages peuvent également devenir incohérents s'ils contiennent des informations non valides.</span><span class="sxs-lookup"><span data-stu-id="ae870-112">Messages can also become poison if they contain invalid information.</span></span> <span data-ttu-id="ae870-113">Par exemple, une commande fournisseur peut contenir un numéro de client non valide.</span><span class="sxs-lookup"><span data-stu-id="ae870-113">For example, a purchase order may contain an invalid customer number.</span></span> <span data-ttu-id="ae870-114">Dans ces cas-là, l’application peut abandonner volontairement la transaction et forcer le message à devenir un message incohérent.</span><span class="sxs-lookup"><span data-stu-id="ae870-114">In these cases, the application may voluntarily abort the transaction and force the message to become a poison message.</span></span>  
  
 <span data-ttu-id="ae870-115">Dans de rares occasions, des messages peuvent ne pas être distribués à l'application.</span><span class="sxs-lookup"><span data-stu-id="ae870-115">On rare occasions, messages can fail to get dispatched to the application.</span></span> <span data-ttu-id="ae870-116">La couche Windows Communication Foundation (WCF) peut détecter un problème avec le message, par exemple si le message contient une trame incorrecte, des informations d’identification de message non valides qui lui sont associées ou un en-tête d’action non valide.</span><span class="sxs-lookup"><span data-stu-id="ae870-116">The Windows Communication Foundation (WCF) layer may find a problem with the message, such as if the message has the wrong frame, invalid message credentials attached to it, or an invalid action header.</span></span> <span data-ttu-id="ae870-117">Dans ces cas-là, l'application ne reçoit jamais le message ; toutefois, ce dernier peut encore devenir un message incohérent et être traité manuellement.</span><span class="sxs-lookup"><span data-stu-id="ae870-117">In these cases, the application never receives the message; however, the message can still become a poison message and be processed manually.</span></span>  
  
## <a name="handling-poison-messages"></a><span data-ttu-id="ae870-118">Gestion des messages incohérents</span><span class="sxs-lookup"><span data-stu-id="ae870-118">Handling Poison Messages</span></span>  
 <span data-ttu-id="ae870-119">Dans WCF, la gestion des messages incohérents fournit un mécanisme permettant à une application réceptrice de traiter les messages qui ne peuvent pas être distribués à l’application, ou les messages qui sont envoyés à l’application, mais qui ne peuvent pas être traités en raison de la spécificité de l’application. principales.</span><span class="sxs-lookup"><span data-stu-id="ae870-119">In WCF, poison message handling provides a mechanism for a receiving application to deal with messages that cannot be dispatched to the application, or messages that are dispatched to the application but which fail to be processed because of application-specific reasons.</span></span> <span data-ttu-id="ae870-120">La gestion des messages incohérents est configurée par les propriétés suivantes dans chacune des liaisons en file d’attente disponibles :</span><span class="sxs-lookup"><span data-stu-id="ae870-120">Poison message handling is configured by the following properties in each of the available queued bindings:</span></span>  
  
- <span data-ttu-id="ae870-121">`ReceiveRetryCount`.</span><span class="sxs-lookup"><span data-stu-id="ae870-121">`ReceiveRetryCount`.</span></span> <span data-ttu-id="ae870-122">Valeur entière qui indique le nombre maximal de nouvelles tentatives de remise d'un message à partir de la file d'attente d'application à l'application.</span><span class="sxs-lookup"><span data-stu-id="ae870-122">An integer value that indicates the maximum number of times to retry delivery of a message from the application queue to the application.</span></span> <span data-ttu-id="ae870-123">La valeur par défaut est 5.</span><span class="sxs-lookup"><span data-stu-id="ae870-123">The default value is 5.</span></span> <span data-ttu-id="ae870-124">Elle est suffisante dans les cas où une nouvelle tentative immédiate résout le problème (par exemple, en cas d'interblocage temporaire sur une base de données).</span><span class="sxs-lookup"><span data-stu-id="ae870-124">This is sufficient in cases where an immediate retry fixes the problem, such as with a temporary deadlock on a database.</span></span>  
  
- <span data-ttu-id="ae870-125">`MaxRetryCycles`.</span><span class="sxs-lookup"><span data-stu-id="ae870-125">`MaxRetryCycles`.</span></span> <span data-ttu-id="ae870-126">Valeur entière qui indique le nombre maximal de cycles de nouvelle tentative.</span><span class="sxs-lookup"><span data-stu-id="ae870-126">An integer value that indicates the maximum number of retry cycles.</span></span> <span data-ttu-id="ae870-127">Un cycle de nouvelle tentative implique le transfert d'un message de la file d'attente d'application vers la sous-file d'attente de nouvel essai et, après un délai configurable, de la sous-file d'attente de nouvel essai vers la file d'attente d'application afin de retenter la remise.</span><span class="sxs-lookup"><span data-stu-id="ae870-127">A retry cycle consists of transferring a message from the application queue to the retry subqueue and, after a configurable delay, from the retry subqueue back into the application queue to reattempt delivery.</span></span> <span data-ttu-id="ae870-128">La valeur par défaut est 2.</span><span class="sxs-lookup"><span data-stu-id="ae870-128">The default value is 2.</span></span> <span data-ttu-id="ae870-129">Sur Windows Vista, le message est essayé au maximum (`ReceiveRetryCount` + 1) \* (`MaxRetryCycles` + 1) fois.</span><span class="sxs-lookup"><span data-stu-id="ae870-129">On Windows Vista, the message is tried a maximum of (`ReceiveRetryCount` +1) \* (`MaxRetryCycles` + 1) times.</span></span> <span data-ttu-id="ae870-130">`MaxRetryCycles` est ignorée sur Windows Server 2003 et [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ae870-130">`MaxRetryCycles` is ignored on Windows Server 2003 and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
- <span data-ttu-id="ae870-131">`RetryCycleDelay`.</span><span class="sxs-lookup"><span data-stu-id="ae870-131">`RetryCycleDelay`.</span></span> <span data-ttu-id="ae870-132">Délai entre les cycles de nouvelle tentative.</span><span class="sxs-lookup"><span data-stu-id="ae870-132">The time delay between retry cycles.</span></span> <span data-ttu-id="ae870-133">La valeur par défaut est de 30 minutes.</span><span class="sxs-lookup"><span data-stu-id="ae870-133">The default value is 30 minutes.</span></span> <span data-ttu-id="ae870-134">`MaxRetryCycles` et `RetryCycleDelay` fournissent ensemble un mécanisme permettant de gérer un problème qui peut être résolu en cas de nouvelle tentative après un délai périodique.</span><span class="sxs-lookup"><span data-stu-id="ae870-134">`MaxRetryCycles` and `RetryCycleDelay` together provide a mechanism to address the problem where a retry after a periodic delay fixes the problem.</span></span> <span data-ttu-id="ae870-135">Par exemple, cela permet de gérer le verrouillage d’un ensemble de lignes dans la validation de transaction en attente SQL Server.</span><span class="sxs-lookup"><span data-stu-id="ae870-135">For example, this handles a locked row set in SQL Server pending transaction commit.</span></span>  
  
- <span data-ttu-id="ae870-136">`ReceiveErrorHandling`.</span><span class="sxs-lookup"><span data-stu-id="ae870-136">`ReceiveErrorHandling`.</span></span> <span data-ttu-id="ae870-137">Énumération qui indique l'action à effectuer pour un message qui n'a pas pu être remis une fois le nombre maximal de tentatives effectué.</span><span class="sxs-lookup"><span data-stu-id="ae870-137">An enumeration that indicates the action to take for a message that has failed delivery after the maximum number of retries has been attempted.</span></span> <span data-ttu-id="ae870-138">Les valeurs peuvent être Fault, Drop, Reject et Move.</span><span class="sxs-lookup"><span data-stu-id="ae870-138">The values can be Fault, Drop, Reject, and Move.</span></span> <span data-ttu-id="ae870-139">L'option par défaut est Fault.</span><span class="sxs-lookup"><span data-stu-id="ae870-139">The default option is Fault.</span></span>  
  
- <span data-ttu-id="ae870-140">Fault.</span><span class="sxs-lookup"><span data-stu-id="ae870-140">Fault.</span></span> <span data-ttu-id="ae870-141">Cette option envoie une erreur à l'écouteur qui a provoqué l'échec du `ServiceHost`.</span><span class="sxs-lookup"><span data-stu-id="ae870-141">This option sends a fault to the listener that caused the `ServiceHost` to fault.</span></span> <span data-ttu-id="ae870-142">Le message doit être supprimé de la file d'attente d'application par un mécanisme externe pour que l'application puisse continuer à traiter les messages de la file d'attente.</span><span class="sxs-lookup"><span data-stu-id="ae870-142">The message must be removed from the application queue by some external mechanism before the application can continue to process messages from the queue.</span></span>  
  
- <span data-ttu-id="ae870-143">Supprimer.</span><span class="sxs-lookup"><span data-stu-id="ae870-143">Drop.</span></span> <span data-ttu-id="ae870-144">Cette option supprime le message empoisonné ; celui-ci n'est jamais remis à l'application.</span><span class="sxs-lookup"><span data-stu-id="ae870-144">This option drops the poison message and the message is never delivered to the application.</span></span> <span data-ttu-id="ae870-145">Si la propriété `TimeToLive` du message a expiré à ce stade, le message peut apparaître dans la file d'attente de lettres mortes de l'expéditeur.</span><span class="sxs-lookup"><span data-stu-id="ae870-145">If the message's `TimeToLive` property has expired at this point, then the message may appear in the sender's dead-letter queue.</span></span> <span data-ttu-id="ae870-146">Sinon, il n'apparaît nulle part.</span><span class="sxs-lookup"><span data-stu-id="ae870-146">If not, the message does not appear anywhere.</span></span> <span data-ttu-id="ae870-147">Cette option indique que l'utilisateur n'a pas spécifié quoi faire en cas de perte du message.</span><span class="sxs-lookup"><span data-stu-id="ae870-147">This option indicates that the user has not specified what to do if the message is lost.</span></span>  
  
- <span data-ttu-id="ae870-148">Reject.</span><span class="sxs-lookup"><span data-stu-id="ae870-148">Reject.</span></span> <span data-ttu-id="ae870-149">Cette option est disponible uniquement sur Windows Vista.</span><span class="sxs-lookup"><span data-stu-id="ae870-149">This option is available only on Windows Vista.</span></span> <span data-ttu-id="ae870-150">Elle fait en sorte que Message Queuing (MSMQ) renvoie un accusé de réception négatif au gestionnaire de files d'attente émetteur, signalant que l'application ne peut pas recevoir le message.</span><span class="sxs-lookup"><span data-stu-id="ae870-150">This instructs Message Queuing (MSMQ) to send a negative acknowledgement back to the sending queue manager that the application cannot receive the message.</span></span> <span data-ttu-id="ae870-151">Le message est placé dans la file d'attente de lettres mortes du gestionnaire de files d'attente émetteur.</span><span class="sxs-lookup"><span data-stu-id="ae870-151">The message is placed in the sending queue manager's dead-letter queue.</span></span>  
  
- <span data-ttu-id="ae870-152">Move.</span><span class="sxs-lookup"><span data-stu-id="ae870-152">Move.</span></span> <span data-ttu-id="ae870-153">Cette option est disponible uniquement sur Windows Vista.</span><span class="sxs-lookup"><span data-stu-id="ae870-153">This option is available only on Windows Vista.</span></span> <span data-ttu-id="ae870-154">Elle déplace le message incohérent vers une file d'attente de messages incohérents pour un traitement ultérieur par une application de gestion de messages incohérents.</span><span class="sxs-lookup"><span data-stu-id="ae870-154">This moves the poison message to a poison-message queue for later processing by a poison-message handling application.</span></span> <span data-ttu-id="ae870-155">La file d'attente de messages incohérents est une sous-file d'attente de la file d'attente d'application.</span><span class="sxs-lookup"><span data-stu-id="ae870-155">The poison-message queue is a subqueue of the application queue.</span></span> <span data-ttu-id="ae870-156">Une application de gestion des messages incohérents peut être un service WCF qui lit les messages en dehors de la file d’attente de messages incohérents.</span><span class="sxs-lookup"><span data-stu-id="ae870-156">A poison-message handling application can be a WCF service that reads messages out of the poison queue.</span></span> <span data-ttu-id="ae870-157">La file d’attente de messages incohérents est une sous-file d’attente de la file d’attente de l’application. elle peut être adressée comme net. msmq://\<*nom-machine*>/*applicationQueue*;p oison, où *machine-name* est le nom de l’ordinateur sur lequel la file d’attente réside et *applicationQueue* est le nom de la file d’attente spécifique à l’application.</span><span class="sxs-lookup"><span data-stu-id="ae870-157">The poison queue is a subqueue of the application queue and can be addressed as net.msmq://\<*machine-name*>/*applicationQueue*;poison, where *machine-name* is the name of the computer on which the queue resides and the *applicationQueue* is the name of the application-specific queue.</span></span>  
  
 <span data-ttu-id="ae870-158">Voici le nombre maximal de tentatives de remise effectuées pour un message :</span><span class="sxs-lookup"><span data-stu-id="ae870-158">The following are the maximum number of delivery attempts made for a message:</span></span>  
  
- <span data-ttu-id="ae870-159">((ReceiveRetryCount + 1) \* (MaxRetryCycles + 1)) sur Windows Vista.</span><span class="sxs-lookup"><span data-stu-id="ae870-159">((ReceiveRetryCount+1) \* (MaxRetryCycles + 1)) on Windows Vista.</span></span>  
  
- <span data-ttu-id="ae870-160">(ReceiveRetryCount + 1) sur Windows Server 2003 et [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ae870-160">(ReceiveRetryCount + 1) on Windows Server 2003 and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ae870-161">Aucune nouvelle tentative n'est effectuée pour un message remis avec succès.</span><span class="sxs-lookup"><span data-stu-id="ae870-161">No retries are made for a message that is delivered successfully.</span></span>  
  
 <span data-ttu-id="ae870-162">Pour effectuer le suivi du nombre de tentatives de lecture d’un message, Windows Vista gère une propriété de message durable qui compte le nombre d’abandons et une propriété de nombre de déplacements qui compte le nombre de déplacements du message entre la file d’attente de l’application et les sous-files d’attente.</span><span class="sxs-lookup"><span data-stu-id="ae870-162">To keep track of the number of times a message read is attempted, Windows Vista maintains a durable message property that counts the number of aborts and a move count property that counts the number of times the message moves between the application queue and subqueues.</span></span> <span data-ttu-id="ae870-163">Le canal WCF les utilise pour calculer le nombre de nouvelles tentatives de réception et le nombre de cycles de nouvelle tentative.</span><span class="sxs-lookup"><span data-stu-id="ae870-163">The WCF channel uses these to compute the receive retry count and the retry cycles count.</span></span> <span data-ttu-id="ae870-164">Sur Windows Server 2003 et [!INCLUDE[wxp](../../../../includes/wxp-md.md)], le nombre d’abandons est conservé en mémoire par le canal WCF et est réinitialisé en cas d’échec de l’application.</span><span class="sxs-lookup"><span data-stu-id="ae870-164">On Windows Server 2003 and [!INCLUDE[wxp](../../../../includes/wxp-md.md)], the abort count is maintained in memory by the WCF channel and is reset if the application fails.</span></span> <span data-ttu-id="ae870-165">En outre, le canal WCF peut contenir le nombre d’abandons pour un maximum de 256 messages en mémoire à tout moment.</span><span class="sxs-lookup"><span data-stu-id="ae870-165">Also, the WCF channel can hold the abort counts for up to 256 messages in memory at any time.</span></span> <span data-ttu-id="ae870-166">Si un 257ème message est lu, le nombre d'abandons du message le plus ancien est réinitialisé.</span><span class="sxs-lookup"><span data-stu-id="ae870-166">If a 257th message is read, then the oldest message's abort count is reset.</span></span>  
  
 <span data-ttu-id="ae870-167">Les propriétés de nombre d'abandons et de nombre déplacements sont accessibles à l'opération de service par le biais du contexte d'opération.</span><span class="sxs-lookup"><span data-stu-id="ae870-167">The abort count and move count properties are available to the service operation through the operation context.</span></span> <span data-ttu-id="ae870-168">L'exemple de code suivant montre comment y accéder.</span><span class="sxs-lookup"><span data-stu-id="ae870-168">The following code example shows how to access them.</span></span>  
  
 [!code-csharp[S_UE_MSMQ_Poison#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/service.cs#1)]  
  
 <span data-ttu-id="ae870-169">WCF fournit deux liaisons mises en file d’attente standard :</span><span class="sxs-lookup"><span data-stu-id="ae870-169">WCF provides two standard queued bindings:</span></span>  
  
- <span data-ttu-id="ae870-170"><xref:System.ServiceModel.NetMsmqBinding>.</span><span class="sxs-lookup"><span data-stu-id="ae870-170"><xref:System.ServiceModel.NetMsmqBinding>.</span></span> <span data-ttu-id="ae870-171">Une .NET Framework liaison adaptée à l’exécution d’une communication basée sur une file d’attente avec d’autres points de terminaison WCF.</span><span class="sxs-lookup"><span data-stu-id="ae870-171">A .NET Framework binding suitable for performing queue-based communication with other WCF endpoints.</span></span>  
  
- <span data-ttu-id="ae870-172"><xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="ae870-172"><xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span></span> <span data-ttu-id="ae870-173">Une liaison adaptée à la communication avec des applications Message Queuing existantes.</span><span class="sxs-lookup"><span data-stu-id="ae870-173">A binding suitable for communicating with existing Message Queuing applications.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ae870-174">Vous pouvez modifier les propriétés de ces liaisons en fonction des spécifications de votre service WCF.</span><span class="sxs-lookup"><span data-stu-id="ae870-174">You can alter properties in these bindings based on the requirements of your WCF service.</span></span> <span data-ttu-id="ae870-175">L'ensemble du mécanisme de gestion de messages incohérents est local à l'application de réception.</span><span class="sxs-lookup"><span data-stu-id="ae870-175">The entire poison message handling mechanism is local to the receiving application.</span></span> <span data-ttu-id="ae870-176">Le processus est invisible à l'application émettrice, à moins que l'application de réception ne s'arrête finalement et ne renvoie un accusé de réception négatif à l'expéditeur.</span><span class="sxs-lookup"><span data-stu-id="ae870-176">The process is invisible to the sending application unless the receiving application ultimately stops and sends a negative acknowledgment back to the sender.</span></span> <span data-ttu-id="ae870-177">Dans ce cas, le message est déplacé vers la file d'attente de lettres mortes de l'expéditeur.</span><span class="sxs-lookup"><span data-stu-id="ae870-177">In that case, the message is moved to the sender's dead-letter queue.</span></span>  
  
## <a name="best-practice-handling-msmqpoisonmessageexception"></a><span data-ttu-id="ae870-178">Recommandation : Gestion de MsmqPoisonMessageException</span><span class="sxs-lookup"><span data-stu-id="ae870-178">Best Practice: Handling MsmqPoisonMessageException</span></span>  
 <span data-ttu-id="ae870-179">Lorsque le service détermine qu'un message est incohérent, le transport de mise en file d'attente lève une <xref:System.ServiceModel.MsmqPoisonMessageException> qui contient le `LookupId` du message incohérent.</span><span class="sxs-lookup"><span data-stu-id="ae870-179">When the service determines that a message is poison, the queued transport throws a <xref:System.ServiceModel.MsmqPoisonMessageException> that contains the `LookupId` of the poison message.</span></span>  
  
 <span data-ttu-id="ae870-180">Une application de réception peut implémenter l'interface <xref:System.ServiceModel.Dispatcher.IErrorHandler> pour gérer toute erreur requise par l'application.</span><span class="sxs-lookup"><span data-stu-id="ae870-180">A receiving application can implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler> interface to handle any errors that the application requires.</span></span> <span data-ttu-id="ae870-181">Pour plus d’informations, consultez [extension du contrôle sur la gestion des erreurs et la création de rapports](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md).</span><span class="sxs-lookup"><span data-stu-id="ae870-181">For more information, see [Extending Control Over Error Handling and Reporting](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md).</span></span>  
  
 <span data-ttu-id="ae870-182">Il est possible que l'application requière un système de gestion automatisée des messages empoisonnés qui déplace ceux-ci vers une file d'attente de messages empoisonnés afin que le service puisse accéder au reste des messages dans la file d'attente.</span><span class="sxs-lookup"><span data-stu-id="ae870-182">The application may require some kind of automated handling of poison messages that moves the poison messages to a poison message queue so that the service can access the rest of the messages in the queue.</span></span> <span data-ttu-id="ae870-183">Le seul scénario dans lequel on utilise le mécanisme de gestionnaire d'erreurs pour écouter les exceptions de message incohérent est lorsque le paramètre <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> a la valeur <xref:System.ServiceModel.ReceiveErrorHandling.Fault>.</span><span class="sxs-lookup"><span data-stu-id="ae870-183">The only scenario for using the error-handler mechanism to listen for poison-message exceptions is when the <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> setting is set to <xref:System.ServiceModel.ReceiveErrorHandling.Fault>.</span></span> <span data-ttu-id="ae870-184">L'exemple de message empoisonné pour Message Queuing 3.0 illustre ce comportement.</span><span class="sxs-lookup"><span data-stu-id="ae870-184">The poison-message sample for Message Queuing 3.0 demonstrates this behavior.</span></span> <span data-ttu-id="ae870-185">La section suivante décrit les étapes à suivre pour gérer des messages incohérents et fournit quelques recommandations :</span><span class="sxs-lookup"><span data-stu-id="ae870-185">The following outlines the steps to take to handle poison messages, including best practices:</span></span>  
  
1. <span data-ttu-id="ae870-186">Assurez-vous que vos paramètres de messages empoisonnés reflètent les besoins de votre application.</span><span class="sxs-lookup"><span data-stu-id="ae870-186">Ensure your poison settings reflect the requirements of your application.</span></span> <span data-ttu-id="ae870-187">Lorsque vous utilisez les paramètres, assurez-vous de bien comprendre les différences entre les fonctionnalités de Message Queuing sur Windows Vista, Windows Server 2003 et [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ae870-187">When working with the settings, ensure that you understand the differences between the capabilities of Message Queuing on Windows Vista, Windows Server 2003, and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
2. <span data-ttu-id="ae870-188">Si nécessaire, implémentez le `IErrorHandler` pour gérer les erreurs de message incohérent.</span><span class="sxs-lookup"><span data-stu-id="ae870-188">If required, implement the `IErrorHandler` to handle poison-message errors.</span></span> <span data-ttu-id="ae870-189">Étant donné que l'affectation de la valeur `ReceiveErrorHandling` à `Fault` nécessite un mécanisme manuel pour déplacer le message empoisonné hors de la file d'attente ou pour corriger un problème dépendant externe, l'utilisation typique consiste à implémenter `IErrorHandler` lorsque `ReceiveErrorHandling` a la valeur `Fault`, comme illustré dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="ae870-189">Because setting `ReceiveErrorHandling` to `Fault` requires a manual mechanism to move the poison message out of the queue or to correct an external dependent issue, the typical usage is to implement `IErrorHandler` when `ReceiveErrorHandling` is set to `Fault`, as shown in the following code.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonerrorhandler.cs#2)]  
  
3. <span data-ttu-id="ae870-190">Créez un `PoisonBehaviorAttribute` que le comportement de service peut utiliser.</span><span class="sxs-lookup"><span data-stu-id="ae870-190">Create a `PoisonBehaviorAttribute` that the service behavior can use.</span></span> <span data-ttu-id="ae870-191">Le comportement installe le `IErrorHandler` sur le répartiteur.</span><span class="sxs-lookup"><span data-stu-id="ae870-191">The behavior installs the `IErrorHandler` on the dispatcher.</span></span> <span data-ttu-id="ae870-192">Voir l'exemple de code suivant.</span><span class="sxs-lookup"><span data-stu-id="ae870-192">See the following code example.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonbehaviorattribute.cs#3)]  
  
4. <span data-ttu-id="ae870-193">Assurez-vous que votre service est annoté avec l’attribut de comportement d’incohérence.</span><span class="sxs-lookup"><span data-stu-id="ae870-193">Ensure that your service is annotated with the poison behavior attribute.</span></span>  

 <span data-ttu-id="ae870-194">De plus, si `ReceiveErrorHandling` a la valeur `Fault`, `ServiceHost` renverra une erreur s'il rencontre le message empoisonné.</span><span class="sxs-lookup"><span data-stu-id="ae870-194">In addition, if the `ReceiveErrorHandling` is set to `Fault`, the `ServiceHost` faults when encountering the poison message.</span></span> <span data-ttu-id="ae870-195">Vous pouvez vous raccorder à l’événement d’erreur et arrêter le service, appliquer des actions correctives, puis redémarrer.</span><span class="sxs-lookup"><span data-stu-id="ae870-195">You can hook up to the faulted event and shut down the service, take corrective actions, and restart.</span></span> <span data-ttu-id="ae870-196">Par exemple, `LookupId` dans le <xref:System.ServiceModel.MsmqPoisonMessageException> propagé au `IErrorHandler` peut être noté, et lorsque l'hôte de service renvoie une erreur, vous pouvez utiliser l'API `System.Messaging` pour recevoir le message de la file d'attente à l'aide de `LookupId`, supprimer le message de la file d'attente, puis stocker le message dans un magasin externe ou une autre file d'attente.</span><span class="sxs-lookup"><span data-stu-id="ae870-196">For example, the `LookupId` in the <xref:System.ServiceModel.MsmqPoisonMessageException> propagated to the `IErrorHandler` can be noted and when the service host faults, you could use the `System.Messaging` API to receive the message from the queue using the `LookupId` to remove the message from the queue and store the message in some external store or another queue.</span></span> <span data-ttu-id="ae870-197">Vous pouvez ensuite redémarrer `ServiceHost` pour continuer le traitement normal.</span><span class="sxs-lookup"><span data-stu-id="ae870-197">You can then restart `ServiceHost` to resume normal processing.</span></span> <span data-ttu-id="ae870-198">La [gestion des messages incohérents dans MSMQ 4,0](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md) illustre ce comportement.</span><span class="sxs-lookup"><span data-stu-id="ae870-198">The [Poison Message Handling in MSMQ 4.0](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md) demonstrates this behavior.</span></span>  
  
## <a name="transaction-time-out-and-poison-messages"></a><span data-ttu-id="ae870-199">Délai d'expiration de transaction et messages incohérents</span><span class="sxs-lookup"><span data-stu-id="ae870-199">Transaction Time-Out and Poison Messages</span></span>  
 <span data-ttu-id="ae870-200">Une classe d'erreurs peut se produire entre le canal de transport de mise en file d'attente et le code utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ae870-200">A class of errors can occur between the queued transport channel and the user code.</span></span> <span data-ttu-id="ae870-201">Ces erreurs peuvent être détectées par des couches intermédiaires, telles que la couche de sécurité de message ou la logique de distribution de service.</span><span class="sxs-lookup"><span data-stu-id="ae870-201">These errors can be detected by layers in-between, such as the message security layer or the service dispatching logic.</span></span> <span data-ttu-id="ae870-202">Par exemple, un certificat X.509 manquant détecté dans la couche de sécurité SOAP et une action manquante sont des cas où le message est distribué à l'application.</span><span class="sxs-lookup"><span data-stu-id="ae870-202">For example, a missing X.509 certificate detected in the SOAP security layer and a missing action are cases where the message does get dispatched to the application.</span></span> <span data-ttu-id="ae870-203">Lorsque cela se produit, le modèle de service dépose le message.</span><span class="sxs-lookup"><span data-stu-id="ae870-203">When this happens, the service model drops the message.</span></span> <span data-ttu-id="ae870-204">Étant donné que le message est lu dans une transaction et qu’aucun résultat pour cette transaction ne peut être fourni, le délai d’attente de transaction finit par expirer, la transaction est abandonnée et le message est remis dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="ae870-204">Because the message is read in a transaction and an outcome for that transaction cannot be provided, the transaction eventually times out, aborts, and the message is put back into the queue.</span></span> <span data-ttu-id="ae870-205">En d’autres termes, pour une certaine classe d’erreurs, la transaction n’abandonne pas immédiatement mais attend jusqu’à ce que la transaction expire. Vous pouvez modifier le délai d’expiration de la transaction pour un service à l’aide de <xref:System.ServiceModel.ServiceBehaviorAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ae870-205">In other words, for a certain class of errors, the transaction does not immediately abort but waits until the transaction times out. You can modify the transaction time-out for a service using <xref:System.ServiceModel.ServiceBehaviorAttribute>.</span></span>  
  
 <span data-ttu-id="ae870-206">Pour modifier le délai d’expiration de la transaction à l’échelle de l’ordinateur, modifiez le fichier machine. config et définissez le délai d’expiration de la transaction approprié. Il est important de noter que, en fonction du délai d’expiration défini dans la transaction, la transaction finit par abandonner et revenir à la file d’attente et son compteur d’abandons est incrémenté.</span><span class="sxs-lookup"><span data-stu-id="ae870-206">To change the transaction time-out on a computer-wide basis, modify the machine.config file and set the appropriate transaction time-out. It is important to note that, depending on the time-out set in the transaction, the transaction eventually aborts and goes back to the queue and its abort count is incremented.</span></span> <span data-ttu-id="ae870-207">Pour finir, le message devient empoisonné et la disposition correcte est effectuée conformément aux paramètres utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ae870-207">Eventually, the message becomes poison and the right disposition is made according to the user settings.</span></span>  
  
## <a name="sessions-and-poison-messages"></a><span data-ttu-id="ae870-208">Sessions et messages incohérents</span><span class="sxs-lookup"><span data-stu-id="ae870-208">Sessions and Poison Messages</span></span>  
 <span data-ttu-id="ae870-209">Une session subit les mêmes procédures de nouvelle tentative et de gestion des messages incohérents qu'un simple message.</span><span class="sxs-lookup"><span data-stu-id="ae870-209">A session undergoes the same retry and poison-message handling procedures as a single message.</span></span> <span data-ttu-id="ae870-210">Les propriétés indiquées précédemment pour les messages empoisonnés s'appliquent à la session entière.</span><span class="sxs-lookup"><span data-stu-id="ae870-210">The properties previously listed for poison messages apply to the entire session.</span></span> <span data-ttu-id="ae870-211">En d'autres termes, la session entière est soumise à une nouvelle tentative et finit dans une ultime file d'attente de messages empoisonnés ou dans la file d'attente de lettres mortes de l'expéditeur si le message est refusé.</span><span class="sxs-lookup"><span data-stu-id="ae870-211">This means that the entire session is retried and goes to a final poison-message queue or the sender’s dead-letter queue if the message is rejected.</span></span>  
  
## <a name="batching-and-poison-messages"></a><span data-ttu-id="ae870-212">Traitement par lot et messages incohérents</span><span class="sxs-lookup"><span data-stu-id="ae870-212">Batching and Poison Messages</span></span>  
 <span data-ttu-id="ae870-213">Si un message faisant partie d'un lot devient un message incohérent, le lot entier est annulé et le canal recommence à lire un message à la fois.</span><span class="sxs-lookup"><span data-stu-id="ae870-213">If a message becomes a poison message and is part of a batch, then the entire batch is rolled back and the channel returns to reading one message at a time.</span></span> <span data-ttu-id="ae870-214">Pour plus d’informations sur le traitement par lots, consultez [traitement par lot des messages dans une transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md) .</span><span class="sxs-lookup"><span data-stu-id="ae870-214">For more information about batching, see [Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</span></span>  
  
## <a name="poison-message-handling-for-messages-in-a-poison-queue"></a><span data-ttu-id="ae870-215">Gestion des messages incohérents pour les messages dans une file d'attente de messages incohérents</span><span class="sxs-lookup"><span data-stu-id="ae870-215">Poison-message Handling for Messages in a Poison Queue</span></span>  
 <span data-ttu-id="ae870-216">La gestion des messages incohérents ne se termine pas lorsqu'un message est placé dans la file d'attente de messages incohérents.</span><span class="sxs-lookup"><span data-stu-id="ae870-216">Poison-message handling does not end when a message is placed in the poison-message queue.</span></span> <span data-ttu-id="ae870-217">Les messages dans la file d'attente de messages incohérents doivent encore être lus et gérés.</span><span class="sxs-lookup"><span data-stu-id="ae870-217">Messages in the poison-message queue must still be read and handled.</span></span> <span data-ttu-id="ae870-218">Vous pouvez utiliser un sous-ensemble des paramètres de gestion de messages incohérents lors de la lecture des messages à partir de l'ultime sous-file d'attente de messages incohérents.</span><span class="sxs-lookup"><span data-stu-id="ae870-218">You can use a subset of the poison-message handling settings when reading messages from the final poison subqueue.</span></span> <span data-ttu-id="ae870-219">Les paramètres applicables sont `ReceiveRetryCount` et `ReceiveErrorHandling`.</span><span class="sxs-lookup"><span data-stu-id="ae870-219">The applicable settings are `ReceiveRetryCount` and `ReceiveErrorHandling`.</span></span> <span data-ttu-id="ae870-220">Vous pouvez affecter la valeur Drop, Reject ou Fault à `ReceiveErrorHandling`.</span><span class="sxs-lookup"><span data-stu-id="ae870-220">You can set `ReceiveErrorHandling` to Drop, Reject, or Fault.</span></span> <span data-ttu-id="ae870-221">`MaxRetryCycles` est ignoré et une exception est levée si `ReceiveErrorHandling` a la valeur Move.</span><span class="sxs-lookup"><span data-stu-id="ae870-221">`MaxRetryCycles` is ignored and an exception is thrown if `ReceiveErrorHandling` is set to Move.</span></span>  
  
## <a name="windows-vista-windows-server-2003-and-windows-xp-differences"></a><span data-ttu-id="ae870-222">Différences entre Windows Vista, Windows Server 2003 et Windows XP</span><span class="sxs-lookup"><span data-stu-id="ae870-222">Windows Vista, Windows Server 2003, and Windows XP Differences</span></span>  
 <span data-ttu-id="ae870-223">Comme indiqué précédemment, tous les paramètres de gestion des messages incohérents ne s’appliquent pas à Windows Server 2003 et [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ae870-223">As noted earlier, not all poison-message handling settings apply to Windows Server 2003 and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span> <span data-ttu-id="ae870-224">Les principales différences entre Message Queuing sur Windows Server 2003, [!INCLUDE[wxp](../../../../includes/wxp-md.md)]et Windows Vista sont relatives à la gestion des messages incohérents :</span><span class="sxs-lookup"><span data-stu-id="ae870-224">The following key differences between Message Queuing on Windows Server 2003, [!INCLUDE[wxp](../../../../includes/wxp-md.md)], and Windows Vista are relevant to poison-message handling:</span></span>  
  
- <span data-ttu-id="ae870-225">Message Queuing dans Windows Vista prend en charge les sous-files d’attente, tandis que Windows Server 2003 et [!INCLUDE[wxp](../../../../includes/wxp-md.md)] ne prennent pas en charge les sous-files d’attente.</span><span class="sxs-lookup"><span data-stu-id="ae870-225">Message Queuing in Windows Vista supports subqueues, while Windows Server 2003 and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not support subqueues.</span></span> <span data-ttu-id="ae870-226">Les sous-files d'attente sont utilisées dans la gestion des messages incohérents.</span><span class="sxs-lookup"><span data-stu-id="ae870-226">Subqueues are used in poison-message handling.</span></span> <span data-ttu-id="ae870-227">Les files d'attente de nouvel essai et la file d'attente de messages incohérents sont des sous-files d'attente de la file d'attente de l'application créée en fonction des paramètres de gestion des messages incohérents.</span><span class="sxs-lookup"><span data-stu-id="ae870-227">The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.</span></span> <span data-ttu-id="ae870-228">`MaxRetryCycles` définit le nombre de sous-files de nouvel essai à créer.</span><span class="sxs-lookup"><span data-stu-id="ae870-228">The `MaxRetryCycles` dictates how many retry subqueues to create.</span></span> <span data-ttu-id="ae870-229">Par conséquent, lors de l’exécution sur Windows Server 2003 ou [!INCLUDE[wxp](../../../../includes/wxp-md.md)], `MaxRetryCycles` sont ignorés et `ReceiveErrorHandling.Move` n’est pas autorisé.</span><span class="sxs-lookup"><span data-stu-id="ae870-229">Therefore, when running on Windows Server 2003 or [!INCLUDE[wxp](../../../../includes/wxp-md.md)], `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.</span></span>  
  
- <span data-ttu-id="ae870-230">Message Queuing dans Windows Vista prend en charge l’accusé de réception négatif, contrairement à Windows Server 2003 et [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ae870-230">Message Queuing in Windows Vista supports negative acknowledgment, while Windows Server 2003 and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not.</span></span> <span data-ttu-id="ae870-231">Un accusé de réception négatif provenant du gestionnaire de files d'attente de destination provoque le placement du message rejeté dans la file d'attente de lettres mortes par le gestionnaire de files d'attente source.</span><span class="sxs-lookup"><span data-stu-id="ae870-231">A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.</span></span> <span data-ttu-id="ae870-232">Par conséquent, `ReceiveErrorHandling.Reject` n’est pas autorisé avec Windows Server 2003 et [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ae870-232">As such, `ReceiveErrorHandling.Reject` is not allowed with Windows Server 2003 and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
- <span data-ttu-id="ae870-233">Message Queuing dans Windows Vista prend en charge une propriété de message qui indique le nombre de tentatives de remise de messages.</span><span class="sxs-lookup"><span data-stu-id="ae870-233">Message Queuing in Windows Vista supports a message property that keeps count of the number of times message delivery is attempted.</span></span> <span data-ttu-id="ae870-234">Cette propriété du nombre d’abandons n’est pas disponible sur Windows Server 2003 et [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ae870-234">This abort count property is not available on Windows Server 2003 and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span> <span data-ttu-id="ae870-235">Comme WCF gère le nombre d’abandons en mémoire, il est possible que cette propriété ne contienne pas une valeur exacte lorsque le même message est lu par plusieurs services WCF dans une batterie de serveurs.</span><span class="sxs-lookup"><span data-stu-id="ae870-235">WCF maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one WCF service in a farm.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ae870-236">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="ae870-236">See also</span></span>

- [<span data-ttu-id="ae870-237">Vue d’ensemble des files d’attente</span><span class="sxs-lookup"><span data-stu-id="ae870-237">Queues Overview</span></span>](../../../../docs/framework/wcf/feature-details/queues-overview.md)
- [<span data-ttu-id="ae870-238">Différences entre les fonctionnalités de mise en file d’attente dans Windows Vista, Windows Server 2003 et Windows XP</span><span class="sxs-lookup"><span data-stu-id="ae870-238">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)
- [<span data-ttu-id="ae870-239">Spécification et gestion des erreurs dans les contrats et les services</span><span class="sxs-lookup"><span data-stu-id="ae870-239">Specifying and Handling Faults in Contracts and Services</span></span>](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)
