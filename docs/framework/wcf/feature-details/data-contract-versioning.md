---
title: Contrôle de version des contrats de données
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- versioning [WCF], data contracts
- versioning [WCF]
- data contracts [WCF], versioning
ms.assetid: 4a0700cb-5f5f-4137-8705-3a3ecf06461f
ms.openlocfilehash: 493efab41e2c6763eb95df8662e6254d9e0df2f2
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84593501"
---
# <a name="data-contract-versioning"></a><span data-ttu-id="6a4fe-102">Contrôle de version des contrats de données</span><span class="sxs-lookup"><span data-stu-id="6a4fe-102">Data Contract Versioning</span></span>
<span data-ttu-id="6a4fe-103">À mesure que les applications évoluent, il peut s'avérer nécessaire de modifier les contrats de données utilisés par les services.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-103">As applications evolve, you may also have to change the data contracts the services use.</span></span> <span data-ttu-id="6a4fe-104">Cette rubrique explique comment assigner des versions aux contrats de données.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-104">This topic explains how to version data contracts.</span></span> <span data-ttu-id="6a4fe-105">Cette rubrique décrit les mécanismes de contrôle de version des contrats de données.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-105">This topic describes the data contract versioning mechanisms.</span></span> <span data-ttu-id="6a4fe-106">Pour obtenir une vue d’ensemble complète et des instructions de contrôle de version normatives, consultez [meilleures pratiques :](../best-practices-data-contract-versioning.md)contrôle de version des contrats de données.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-106">For a complete overview and prescriptive versioning guidance, see [Best Practices: Data Contract Versioning](../best-practices-data-contract-versioning.md).</span></span>  
  
## <a name="breaking-vs-nonbreaking-changes"></a><span data-ttu-id="6a4fe-107">Modifications avec et sans rupture</span><span class="sxs-lookup"><span data-stu-id="6a4fe-107">Breaking vs. Nonbreaking Changes</span></span>  
 <span data-ttu-id="6a4fe-108">Les modifications apportées à un contrat de données peuvent être avec ou sans rupture.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-108">Changes to a data contract can be breaking or nonbreaking.</span></span> <span data-ttu-id="6a4fe-109">Lorsqu'un contrat de données est modifié sans rupture, une application utilisant l'ancienne version du contrat peut communiquer avec une application utilisant la version plus récente, et vice versa.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-109">When a data contract is changed in a nonbreaking way, an application using the older version of the contract can communicate with an application using the newer version, and an application using the newer version of the contract can communicate with an application using the older version.</span></span> <span data-ttu-id="6a4fe-110">D'autre part, une modification avec rupture empêche la communication dans une ou les deux directions.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-110">On the other hand, a breaking change prevents communication in one or both directions.</span></span>  
  
 <span data-ttu-id="6a4fe-111">Les modifications apportées à un type qui n'affectent pas la façon dont il est transmis sont dites « sans rupture ».</span><span class="sxs-lookup"><span data-stu-id="6a4fe-111">Any changes to a type that do not affect how it is transmitted and received are nonbreaking.</span></span> <span data-ttu-id="6a4fe-112">Les modifications de ce type n'affectent pas le contrat de données, mais uniquement le type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-112">Such changes do not change the data contract, only the underlying type.</span></span> <span data-ttu-id="6a4fe-113">Par exemple, vous pouvez modifier le nom d'un champ sans rupture si vous affectez ensuite le nom de l'ancienne version à la propriété <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A> de <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-113">For example, you can change the name of a field in a nonbreaking way if you then set the <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to the older version name.</span></span> <span data-ttu-id="6a4fe-114">Le code suivant présente la version 1 d'un contrat de données.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-114">The following code shows version 1 of a data contract.</span></span>  
  
 [!code-csharp[C_DataContractVersioning#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_datacontractversioning/cs/source.cs#1)]
 [!code-vb[C_DataContractVersioning#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractversioning/vb/source.vb#1)]  
  
 <span data-ttu-id="6a4fe-115">Le code suivant présente une modification sans rupture.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-115">The following code shows a nonbreaking change.</span></span>  
  
 [!code-csharp[C_DataContractVersioning#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_datacontractversioning/cs/source.cs#2)]
 [!code-vb[C_DataContractVersioning#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractversioning/vb/source.vb#2)]  
  
 <span data-ttu-id="6a4fe-116">Certaines modifications affectent les données transmises, mais peuvent être avec ou sans rupture.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-116">Some changes do modify the transmitted data, but may or may not be breaking.</span></span> <span data-ttu-id="6a4fe-117">Les modifications suivantes sont toujours avec rupture :</span><span class="sxs-lookup"><span data-stu-id="6a4fe-117">The following changes are always breaking:</span></span>  
  
- <span data-ttu-id="6a4fe-118">Modification de la valeur <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> ou <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> d'un contrat de données.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-118">Changing the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> or <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> value of a data contract.</span></span>  
  
- <span data-ttu-id="6a4fe-119">Modification de l'ordre de membres de données à l'aide de la propriété <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> de <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-119">Changing the order of data members by using the <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>  
  
- <span data-ttu-id="6a4fe-120">Attribution d'un nouveau nom à un membre de données.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-120">Renaming a data member.</span></span>  
  
- <span data-ttu-id="6a4fe-121">Modification du contrat de données d'un membre de données.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-121">Changing the data contract of a data member.</span></span> <span data-ttu-id="6a4fe-122">Par exemple, modification du type de membre de données d'un entier en une chaîne, ou d'un type avec un contrat de données « Customer » en un type avec un contrat de données « Person ».</span><span class="sxs-lookup"><span data-stu-id="6a4fe-122">For example, changing the type of data member from an integer to a string, or from a type with a data contract named "Customer" to a type with a data contract named "Person".</span></span>  
  
 <span data-ttu-id="6a4fe-123">Les modifications suivantes sont également possibles :</span><span class="sxs-lookup"><span data-stu-id="6a4fe-123">The following changes are also possible.</span></span>  
  
## <a name="adding-and-removing-data-members"></a><span data-ttu-id="6a4fe-124">Ajout et suppression de membres de données</span><span class="sxs-lookup"><span data-stu-id="6a4fe-124">Adding and Removing Data Members</span></span>  
 <span data-ttu-id="6a4fe-125">Dans la plupart des cas, l'ajout ou la suppression d'un membre de données n'est pas une modification avec rupture, sauf si vous exigez la validité stricte du schéma (nouvelles instances qui valident l'ancien schéma).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-125">In most cases, adding or removing a data member is not a breaking change, unless you require strict schema validity (new instances validating against the old schema).</span></span>  
  
 <span data-ttu-id="6a4fe-126">Lorsqu'un type avec un champ supplémentaire est désérialisé dans un type avec un champ manquant, les informations supplémentaires sont ignorées.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-126">When a type with an extra field is deserialized into a type with a missing field, the extra information is ignored.</span></span> <span data-ttu-id="6a4fe-127">(Elles peuvent également être stockées à des fins d’aller-retour ; pour plus d’informations, consultez [contrats de données à compatibilité ascendante](forward-compatible-data-contracts.md)).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-127">(It may also be stored for round-tripping purposes; for more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md)).</span></span>  
  
 <span data-ttu-id="6a4fe-128">Lorsqu'un type avec un champ manquant est désérialisé dans un type avec un champ supplémentaire, le champ supplémentaire conserve sa valeur par défaut, généralement zéro ou `null`.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-128">When a type with a missing field is deserialized into a type with an extra field, the extra field is left at its default value, usually zero or `null`.</span></span> <span data-ttu-id="6a4fe-129">(La valeur par défaut peut être modifiée. pour plus d’informations, consultez [rappels de sérialisation avec tolérance de version](version-tolerant-serialization-callbacks.md).)</span><span class="sxs-lookup"><span data-stu-id="6a4fe-129">(The default value may be changed; for more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).)</span></span>  
  
 <span data-ttu-id="6a4fe-130">Par exemple, vous pouvez utiliser la classe `CarV1` sur un client et la classe `CarV2` sur un service, ou la classe `CarV1` sur un service et la classe `CarV2` sur un client.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-130">For example, you can use the `CarV1` class on a client and the `CarV2` class on a service, or you can use the `CarV1` class on a service and the `CarV2` class on a client.</span></span>  
  
 [!code-csharp[C_DataContractVersioning#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_datacontractversioning/cs/source.cs#3)]
 [!code-vb[C_DataContractVersioning#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractversioning/vb/source.vb#3)]  
  
 <span data-ttu-id="6a4fe-131">Le point de terminaison version 2 peut envoyer des données au point de terminaison version 1.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-131">The version 2 endpoint can successfully send data to the version 1 endpoint.</span></span> <span data-ttu-id="6a4fe-132">La sérialisation de la version 2 du contrat de données `Car` génère du code XML semblable au code suivant.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-132">Serializing version 2 of the `Car` data contract yields XML similar to the following.</span></span>  
  
```xml  
<Car>  
    <Model>Porsche</Model>  
    <HorsePower>300</HorsePower>  
</Car>  
```  
  
 <span data-ttu-id="6a4fe-133">Le moteur de désérialisation sur la version 1 ne trouve pas de membre de données correspondant pour le champ `HorsePower` et ignore ces données.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-133">The deserialization engine on V1 does not find a matching data member for the `HorsePower` field, and discards that data.</span></span>  
  
 <span data-ttu-id="6a4fe-134">En outre, le point de terminaison version 1 peut envoyer des données au point de terminaison version 2.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-134">Also, the version 1 endpoint can send data to the version 2 endpoint.</span></span> <span data-ttu-id="6a4fe-135">La sérialisation de la version 1 du contrat de données `Car` génère du XML semblable au code suivant.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-135">Serializing version 1 of the `Car` data contract yields XML similar to the following.</span></span>  
  
```xml  
<Car>  
    <Model>Porsche</Model>  
</Car>  
```  
  
 <span data-ttu-id="6a4fe-136">Le désérialiseur version 2 ne sait pas quelle valeur affecter au champ `HorsePower`, car il n'y a pas de données correspondantes dans le XML entrant.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-136">The version 2 deserializer does not know what to set the `HorsePower` field to, because there is no matching data in the incoming XML.</span></span> <span data-ttu-id="6a4fe-137">À la place, le champ prend la valeur par défaut 0.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-137">Instead, the field is set to the default value of 0.</span></span>  
  
## <a name="required-data-members"></a><span data-ttu-id="6a4fe-138">Membres de données requis</span><span class="sxs-lookup"><span data-stu-id="6a4fe-138">Required Data Members</span></span>  
 <span data-ttu-id="6a4fe-139">Un membre de données peut être marqué comme étant requis en affectant <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> à la propriété <xref:System.Runtime.Serialization.DataMemberAttribute> de `true`.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-139">A data member may be marked as being required by setting the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to `true`.</span></span> <span data-ttu-id="6a4fe-140">Si des données requises sont manquantes lors de la désérialisation, une exception est levée au lieu que le membre de données soit défini à sa valeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-140">If required data is missing while deserializing, an exception is thrown instead of setting the data member to its default value.</span></span>  
  
 <span data-ttu-id="6a4fe-141">L'ajout d'un membre de données requis est une modification avec rupture.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-141">Adding a required data member is a breaking change.</span></span> <span data-ttu-id="6a4fe-142">En d'autres termes, le type le plus récent peut toujours être envoyé aux points de terminaison avec le type le plus ancien, mais pas l'inverse.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-142">That is, the newer type can still be sent to endpoints with the older type, but not the other way around.</span></span> <span data-ttu-id="6a4fe-143">La suppression d'un membre de données marqué comme étant requis dans les versions antérieures est également une modification avec rupture.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-143">Removing a data member that was marked as required in any prior version is also a breaking change.</span></span>  
  
 <span data-ttu-id="6a4fe-144">La modification de la valeur de la propriété <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> de `true` en `false` est sans rupture, mais sa modification de `false` en `true` peut être avec rupture si les versions antérieures du type n'ont pas le membre de données en question.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-144">Changing the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property value from `true` to `false` is not breaking, but changing it from `false` to `true` may be breaking if any prior versions of the type do not have the data member in question.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6a4fe-145">Même si la propriété <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> a la valeur `true`, les données entrantes peuvent être null ou zéro, et un type doit être préparé à gérer cette éventualité.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-145">Although the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property is set to `true`, the incoming data may be null or zero, and a type must be prepared to handle this possibility.</span></span> <span data-ttu-id="6a4fe-146">N'utilisez pas <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> comme mécanisme de sécurité pour vous protéger contre les données entrantes incorrectes.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-146">Do not use <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> as a security mechanism to protect against bad incoming data.</span></span>  
  
## <a name="omitted-default-values"></a><span data-ttu-id="6a4fe-147">Valeurs par défaut omises</span><span class="sxs-lookup"><span data-stu-id="6a4fe-147">Omitted Default Values</span></span>  
 <span data-ttu-id="6a4fe-148">Il est possible (bien que cela ne soit pas recommandé) d’affecter la valeur `EmitDefaultValue` à la propriété de l’attribut DataMemberAttribute `false` , comme décrit dans [valeurs par défaut des données membres](data-member-default-values.md).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-148">It is possible (although not recommended) to set the `EmitDefaultValue` property on the DataMemberAttribute attribute to `false`, as described in [Data Member Default Values](data-member-default-values.md).</span></span> <span data-ttu-id="6a4fe-149">Si ce paramètre est `false`, le membre de données ne sera pas émis s'il est défini à sa valeur par défaut (généralement null ou zéro).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-149">If this setting is `false`, the data member will not be emitted if it is set to its default value (usually null or zero).</span></span> <span data-ttu-id="6a4fe-150">Cela n'est pas compatible avec les membres de données requis dans les différentes versions à deux niveaux :</span><span class="sxs-lookup"><span data-stu-id="6a4fe-150">This is not compatible with required data members in different versions in two ways:</span></span>  
  
- <span data-ttu-id="6a4fe-151">Un contrat de données avec un membre de données requis dans une version ne peut pas recevoir de données par défaut (null ou zéro) d'une autre version dans laquelle le membre de données a `EmitDefaultValue` à la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-151">A data contract with a data member that is required in one version cannot receive default (null or zero) data from a different version in which the data member has `EmitDefaultValue` set to `false`.</span></span>  
  
- <span data-ttu-id="6a4fe-152">Un membre de données requis qui a `EmitDefaultValue` à la valeur `false` ne peut pas être utilisé pour sérialiser sa valeur par défaut (null ou zéro), mais peut recevoir une valeur de ce type lors de la désérialisation.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-152">A required data member that has `EmitDefaultValue` set to `false` cannot be used to serialize its default (null or zero) value, but can receive such a value on deserialization.</span></span> <span data-ttu-id="6a4fe-153">Cela crée un problème d'aller-retour (les données peuvent être lues mais ne peuvent pas être ensuite écrites).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-153">This creates a round-tripping problem (data can be read in but the same data cannot then be written out).</span></span> <span data-ttu-id="6a4fe-154">Par conséquent, si `IsRequired` a la valeur `true` et `EmitDefaultValue` a la valeur `false` dans une version, la même combinaison doit s'appliquer à toutes les autres versions de sorte qu'aucune version du contrat de données ne puisse générer de valeur qui ne se traduise pas par un aller-retour.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-154">Therefore, if `IsRequired` is `true` and `EmitDefaultValue` is `false` in one version, the same combination should apply to all other versions such that no version of the data contract would be able to produce a value that does not result in a round trip.</span></span>  
  
## <a name="schema-considerations"></a><span data-ttu-id="6a4fe-155">Considérations sur le schéma</span><span class="sxs-lookup"><span data-stu-id="6a4fe-155">Schema Considerations</span></span>  
 <span data-ttu-id="6a4fe-156">Pour obtenir une explication sur le schéma produit pour les types de contrat de données, consultez [Référence du schéma de contrat de données](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-156">For an explanation of what schema is produced for data contract types, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="6a4fe-157">Le schéma que WCF génère pour les types de contrat de données n’apporte aucune provision pour le contrôle de version.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-157">The schema WCF produces for data contract types makes no provisions for versioning.</span></span> <span data-ttu-id="6a4fe-158">En d'autres termes, le schéma exporté à partir d'une version spécifique d'un type contient uniquement les membres de données présents dans cette version.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-158">That is, the schema exported from a certain version of a type contains only those data members present in that version.</span></span> <span data-ttu-id="6a4fe-159">L'implémentation de l'interface <xref:System.Runtime.Serialization.IExtensibleDataObject> ne modifie pas le schéma pour un type.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-159">Implementing the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface does not change the schema for a type.</span></span>  
  
 <span data-ttu-id="6a4fe-160">Les membres de données sont par défaut exportés dans le schéma en tant qu'éléments facultatifs.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-160">Data members are exported to the schema as optional elements by default.</span></span> <span data-ttu-id="6a4fe-161">En d'autres termes, 0 est affecté à la valeur `minOccurs` (attribut XML).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-161">That is, the `minOccurs` (XML attribute) value is set to 0.</span></span> <span data-ttu-id="6a4fe-162">Les membres de données requis sont exportés, avec 1 étant affecté à `minOccurs`.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-162">Required data members are exported with `minOccurs` set to 1.</span></span>  
  
 <span data-ttu-id="6a4fe-163">Un grand nombre des modifications considérées comme étant sans rupture sont en fait avec rupture si une adhésion stricte au schéma est requise.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-163">Many of the changes considered to be nonbreaking are actually breaking if strict adherence to the schema is required.</span></span> <span data-ttu-id="6a4fe-164">Dans l'exemple précédent, une instance `CarV1` avec l'élément `Model` uniquement validerait par rapport au schéma `CarV2` (lequel a `Model` et `Horsepower`, mais les deux sont facultatifs).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-164">In the preceding example, a `CarV1` instance with just the `Model` element would validate against the `CarV2` schema (which has both `Model` and `Horsepower`, but both are optional).</span></span> <span data-ttu-id="6a4fe-165">Cependant, l'inverse n'est pas vrai : une instance `CarV2` échouerait la validation par rapport au schéma `CarV1`.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-165">However, the reverse is not true: a `CarV2` instance would fail validation against the `CarV1` schema.</span></span>  
  
 <span data-ttu-id="6a4fe-166">L'aller-retour implique également des considérations supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-166">Round-tripping also entails some additional considerations.</span></span> <span data-ttu-id="6a4fe-167">Pour plus d’informations, consultez la section « Considérations relatives au schéma » dans les [contrats de données à compatibilité ascendante](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-167">For more information, see the "Schema Considerations" section in [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>  
  
### <a name="other-permitted-changes"></a><span data-ttu-id="6a4fe-168">Autres modifications autorisées</span><span class="sxs-lookup"><span data-stu-id="6a4fe-168">Other Permitted Changes</span></span>  
 <span data-ttu-id="6a4fe-169">L'implémentation de l'interface <xref:System.Runtime.Serialization.IExtensibleDataObject> est une modification sans rupture.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-169">Implementing the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface is a nonbreaking change.</span></span> <span data-ttu-id="6a4fe-170">Toutefois, la prise en charge de l'aller-retour n'existe pas pour les versions du type antérieures à celle dans laquelle <xref:System.Runtime.Serialization.IExtensibleDataObject> a été implémenté.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-170">However, round-tripping support does not exist for versions of the type prior to the version in which <xref:System.Runtime.Serialization.IExtensibleDataObject> was implemented.</span></span> <span data-ttu-id="6a4fe-171">Pour plus d’informations, consultez [Contrats de données compatibles avec des versions ultérieures](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-171">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="6a4fe-172">Énumérations</span><span class="sxs-lookup"><span data-stu-id="6a4fe-172">Enumerations</span></span>  
 <span data-ttu-id="6a4fe-173">L'ajout ou la suppression d'un membre d'énumération est une modification avec rupture.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-173">Adding or removing an enumeration member is a breaking change.</span></span> <span data-ttu-id="6a4fe-174">La modification du nom d'un membre d'énumération est avec rupture, sauf si son nom de contrat est conservé en utilisant l'attribut `EnumMemberAttribute`.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-174">Changing the name of an enumeration member is breaking, unless its contract name is kept the same as in the old version by using the `EnumMemberAttribute` attribute.</span></span> <span data-ttu-id="6a4fe-175">Pour plus d’informations, consultez [types énumération dans les contrats de données](enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-175">For more information, see [Enumeration Types in Data Contracts](enumeration-types-in-data-contracts.md).</span></span>  
  
## <a name="collections"></a><span data-ttu-id="6a4fe-176">Collections</span><span class="sxs-lookup"><span data-stu-id="6a4fe-176">Collections</span></span>  
 <span data-ttu-id="6a4fe-177">La plupart des modifications de collection sont sans rupture car la plupart des types de collections sont interchangeables les uns avec les autres dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-177">Most collection changes are nonbreaking because most collection types are interchangeable with each other in the data contract model.</span></span> <span data-ttu-id="6a4fe-178">Toutefois, la personnalisation d'une collection non personnalisée, ou vice versa, est une modification avec rupture.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-178">However, making a noncustomized collection customized or vice versa is a breaking change.</span></span> <span data-ttu-id="6a4fe-179">De plus, la modification des paramètres de personnalisation de la collection est une modification avec rupture ; en d'autres termes, la modification de l'espace de noms et du nom de contrat de données, du nom d'élément répétitif, du nom d'élément clé et du nom d'élément de valeur.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-179">Also, changing the collection's customization settings is a breaking change; that is, changing its data contract name and namespace, repeating element name, key element name, and value element name.</span></span> <span data-ttu-id="6a4fe-180">Pour plus d’informations sur la personnalisation des collections, consultez [types de collections dans les contrats de données](collection-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6a4fe-180">For more information about collection customization, see [Collection Types in Data Contracts](collection-types-in-data-contracts.md).</span></span>  
<span data-ttu-id="6a4fe-181">Naturellement, la modification du contrat de données de contenu d’une collection (par exemple, la modification d’une liste d’entiers en une liste de chaînes) est une modification avec rupture.</span><span class="sxs-lookup"><span data-stu-id="6a4fe-181">Naturally, changing the data contract of contents of a collection (for example, changing from a list of integers to a list of strings) is a breaking change.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6a4fe-182">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="6a4fe-182">See also</span></span>

- <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.SerializationException>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- [<span data-ttu-id="6a4fe-183">Rappels de sérialisation avec tolérance de version</span><span class="sxs-lookup"><span data-stu-id="6a4fe-183">Version-Tolerant Serialization Callbacks</span></span>](version-tolerant-serialization-callbacks.md)
- [<span data-ttu-id="6a4fe-184">Meilleures pratiques : contrôle de version des contrats de données</span><span class="sxs-lookup"><span data-stu-id="6a4fe-184">Best Practices: Data Contract Versioning</span></span>](../best-practices-data-contract-versioning.md)
- [<span data-ttu-id="6a4fe-185">Using Data Contracts</span><span class="sxs-lookup"><span data-stu-id="6a4fe-185">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="6a4fe-186">Data Contract Equivalence</span><span class="sxs-lookup"><span data-stu-id="6a4fe-186">Data Contract Equivalence</span></span>](data-contract-equivalence.md)
- [<span data-ttu-id="6a4fe-187">Contrats de données à compatibilité ascendante</span><span class="sxs-lookup"><span data-stu-id="6a4fe-187">Forward-Compatible Data Contracts</span></span>](forward-compatible-data-contracts.md)
