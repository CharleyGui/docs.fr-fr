---
title: Utilisation de la classe XmlSerializer
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: 966c3c17c3c42e20ad55681e1c17b13d3f466fa3
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/22/2019
ms.locfileid: "69967817"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="4f5b4-102">Utilisation de la classe XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="4f5b4-102">Using the XmlSerializer Class</span></span>
<span data-ttu-id="4f5b4-103">Windows Communication Foundation (WCF) peut utiliser deux technologies de sérialisation différentes pour transformer les données de votre application en XML transmises entre les clients et les services, un processus appelé sérialisation.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-103">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>  
  
## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="4f5b4-104">DataContractSerializer comme classe par défaut</span><span class="sxs-lookup"><span data-stu-id="4f5b4-104">DataContractSerializer as the Default</span></span>  
 <span data-ttu-id="4f5b4-105">Par défaut, WCF utilise <xref:System.Runtime.Serialization.DataContractSerializer> la classe pour sérialiser les types de données.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-105">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="4f5b4-106">Ce sérialiseur prend en charge les types suivants :</span><span class="sxs-lookup"><span data-stu-id="4f5b4-106">This serializer supports the following types:</span></span>  
  
- <span data-ttu-id="4f5b4-107">Types primitifs (par exemple, entiers, chaînes et tableaux d'octets), ainsi que quelques types spéciaux, tels que <xref:System.Xml.XmlElement> et <xref:System.DateTime>, traités comme des types primitifs.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-107">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>  
  
- <span data-ttu-id="4f5b4-108">Types de contrat de données (types marqués avec l'attribut <xref:System.Runtime.Serialization.DataContractAttribute>).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-108">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>  
  
- <span data-ttu-id="4f5b4-109">Types marqués avec l'attribut <xref:System.SerializableAttribute>, qui comprennent les types implémentant l'interface <xref:System.Runtime.Serialization.ISerializable>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-109">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
- <span data-ttu-id="4f5b4-110">Types qui implémentent l'interface <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-110">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
- <span data-ttu-id="4f5b4-111">Nombreux types de collections courants, notamment de nombreux types de collections génériques.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-111">Many common collection types, which include many generic collection types.</span></span>  
  
 <span data-ttu-id="4f5b4-112">De nombreux types de .NET Framework appartiennent aux deux dernières catégories et sont donc sérialisables.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-112">Many .NET Framework types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="4f5b4-113">Les tableaux de types sérialisables sont également sérialisables.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-113">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="4f5b4-114">Pour obtenir une liste complète, consultez [spécification de transfert de données dans les contrats de service](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-114">For a complete list, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
 <span data-ttu-id="4f5b4-115">, <xref:System.Runtime.Serialization.DataContractSerializer>Utilisé avec les types de contrat de données, est la méthode recommandée pour écrire de nouveaux services WCF.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-115">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="4f5b4-116">Pour plus d’informations, consultez [utilisation de contrats de données](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-116">For more information, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="4f5b4-117">Quand utiliser la classe XmlSerializer ?</span><span class="sxs-lookup"><span data-stu-id="4f5b4-117">When to Use the XmlSerializer Class</span></span>  
 <span data-ttu-id="4f5b4-118">WCF prend également en <xref:System.Xml.Serialization.XmlSerializer> charge la classe.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-118">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="4f5b4-119">La <xref:System.Xml.Serialization.XmlSerializer> classe n’est pas propre à WCF.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-119">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="4f5b4-120">Il s’agit du même moteur de sérialisation que celui utilisé par les services Web ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-120">It is the same serialization engine that ASP.NET Web services use.</span></span> <span data-ttu-id="4f5b4-121">La classe <xref:System.Xml.Serialization.XmlSerializer> prend en charge un ensemble de types beaucoup plus restreint que la classe <xref:System.Runtime.Serialization.DataContractSerializer>, mais elle permet un meilleur contrôle sur le code XML résultant et prend en charge une plus grande partie de la norme XSD (XML Schema Definition).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-121">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="4f5b4-122">En outre, elle ne requiert aucun attribut déclaratif sur les types sérialisables.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-122">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="4f5b4-123">Pour plus d’informations, consultez la rubrique relative à la sérialisation XML dans la documentation de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-123">For more information, see the XML Serialization topic in the .NET Framework documentation.</span></span> <span data-ttu-id="4f5b4-124">La classe <xref:System.Xml.Serialization.XmlSerializer> ne prend pas en charge les types de contrats de données.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-124">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>  
  
 <span data-ttu-id="4f5b4-125">Lors de l’utilisation de Svcutil. exe ou de la fonctionnalité **Ajouter une référence de service** dans Visual Studio pour générer le code client pour un service tiers, ou pour accéder à un schéma tiers, un sérialiseur approprié est automatiquement sélectionné pour vous.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-125">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="4f5b4-126">Si le schéma est incompatible avec le <xref:System.Runtime.Serialization.DataContractSerializer>, le <xref:System.Xml.Serialization.XmlSerializer> est sélectionné.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-126">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>  
  
## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="4f5b4-127">Basculement manuel vers le XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="4f5b4-127">Manually Switching to the XmlSerializer</span></span>  
 <span data-ttu-id="4f5b4-128">Il peut arriver parfois que vous deviez basculer manuellement vers le <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-128">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="4f5b4-129">Cela peut arriver, par exemple, dans les cas suivants :</span><span class="sxs-lookup"><span data-stu-id="4f5b4-129">This happens, for example, in the following cases:</span></span>  
  
- <span data-ttu-id="4f5b4-130">Lors de la migration d’une application à partir de services Web ASP.net vers WCF, vous souhaiterez peut <xref:System.Xml.Serialization.XmlSerializer>-être réutiliser les types existants compatibles existants au lieu de créer de nouveaux types de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-130">When migrating an application from ASP.NET Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>  
  
- <span data-ttu-id="4f5b4-131">Lorsqu'il est important de contrôler de manière précise le code XML qui apparaît dans les messages, mais qu'aucun document WSDL (Web Services Description Language) n'est disponible, par exemple lors de la création d'un service avec des types qui doivent se conformer à un certain schéma publié standardisé qui n'est pas compatible avec le DataContractSerializer.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-131">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>  
  
- <span data-ttu-id="4f5b4-132">Lors de la création de services qui respectent la norme d'encodage SOAP héritée.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-132">When creating services that follow the legacy SOAP Encoding standard.</span></span>  
  
 <span data-ttu-id="4f5b4-133">Dans les cas évoqués mais aussi dans d'autres cas, vous pouvez basculer manuellement vers la classe <xref:System.Xml.Serialization.XmlSerializer> en appliquant l'attribut `XmlSerializerFormatAttribute` à votre service, comme illustré dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-133">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
 [!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]  
  
## <a name="security-considerations"></a><span data-ttu-id="4f5b4-134">Considérations relatives à la sécurité</span><span class="sxs-lookup"><span data-stu-id="4f5b4-134">Security Considerations</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4f5b4-135">Il est important d'être prudent lorsque vous basculez d'un moteur de sérialisation à un autre.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-135">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="4f5b4-136">Le même type peut sérialiser en XML différemment selon le sérialiseur utilisé.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-136">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="4f5b4-137">Si vous utilisez par inadvertance le mauvais sérialiseur, vous risquez de divulguer des informations sur le type que vous ne souhaitiez pas divulguer.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-137">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>  
  
 <span data-ttu-id="4f5b4-138">Par exemple, la classe <xref:System.Runtime.Serialization.DataContractSerializer> sérialise uniquement les membres marqués avec l'attribut <xref:System.Runtime.Serialization.DataMemberAttribute> lors de la sérialisation de types de contrats de données.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-138">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="4f5b4-139">La classe <xref:System.Xml.Serialization.XmlSerializer> sérialise tout membre public.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-139">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="4f5b4-140">Examinez le type dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-140">See the type in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
 [!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]  
  
 <span data-ttu-id="4f5b4-141">Si le type est utilisé par inadvertance dans un contrat de service où la classe <xref:System.Xml.Serialization.XmlSerializer> est sélectionnée, le membre `creditCardNumber` est sérialisé, ce qui n'est sans doute pas voulu.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-141">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>  
  
 <span data-ttu-id="4f5b4-142">Bien que la classe <xref:System.Runtime.Serialization.DataContractSerializer> soit la classe par défaut, vous pouvez la sélectionner explicitement pour votre service (bien que cela ne doive jamais être requis) en appliquant l'attribut <xref:System.ServiceModel.DataContractFormatAttribute> au type de contrat de service.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-142">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>  
  
 <span data-ttu-id="4f5b4-143">Le sérialiseur utilisé pour le service est une partie intégrante du contrat et ne peut pas être changé en sélectionnant une liaison différente ou en modifiant d'autres paramètres de configuration.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-143">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>  
  
 <span data-ttu-id="4f5b4-144">D'autres considérations importantes relatives à la sécurité s'appliquent à la classe <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-144">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="4f5b4-145">Tout d’abord, il est fortement recommandé que toute application WCF qui <xref:System.Xml.Serialization.XmlSerializer> utilise la classe soit signée avec une clé qui est préservée de la divulgation.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-145">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="4f5b4-146">Cette recommandation s'applique à la fois lorsqu'un basculement manuel vers le <xref:System.Xml.Serialization.XmlSerializer> est exécuté et lorsqu'un basculement automatique est exécuté (par Svcutil.exe, la fonctionnalité Ajouter une référence de service ou un outil semblable).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-146">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="4f5b4-147">Cela est dû au <xref:System.Xml.Serialization.XmlSerializer> fait que le moteur de sérialisation prend en charge le chargement d' *assemblys de sérialisation* prégénérés tant qu’ils sont signés avec la même clé que l’application.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-147">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="4f5b4-148">Une application non signée n’est pas du tout protégée contre le risque qu’un assembly nuisible correspondant au nom attendu de l’assembly de sérialisation prégénéré soit placé dans le dossier d’application ou le cache GAC (Global Assembly Cache).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-148">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="4f5b4-149">Bien entendu, un intrus doit tout d'abord accéder en écriture à l'un de ces deux emplacements pour tenter cette action.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-149">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>  
  
 <span data-ttu-id="4f5b4-150">Une autre menace qui existe lorsque vous utilisez <xref:System.Xml.Serialization.XmlSerializer> concerne l'accès en écriture au dossier système temporaire.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-150">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="4f5b4-151">Le <xref:System.Xml.Serialization.XmlSerializer> moteur de sérialisation crée et utilise des *assemblys de sérialisation* temporaires dans ce dossier.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-151">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="4f5b4-152">Vous devez savoir que tout processus ayant un accès en écriture au dossier temporaire peut remplacer ces assemblys de sérialisation par du code malveillant.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-152">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>  
  
## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="4f5b4-153">Règles pour la prise en charge de XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="4f5b4-153">Rules for XmlSerializer support</span></span>  
 <span data-ttu-id="4f5b4-154">Vous ne pouvez pas appliquer directement des attributs compatibles avec <xref:System.Xml.Serialization.XmlSerializer> à des paramètres d'opération de contrat ou des valeurs de retour.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-154">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="4f5b4-155">Toutefois, ils peuvent être appliqués à des messages typés (parties du corps du contrat de message), comme illustré dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-155">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
 [!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="4f5b4-156">En cas d'application à des membres de messages typés, ces attributs substituent les propriétés qui sont en conflit sur les attributs de messages typés.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-156">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="4f5b4-157">Par exemple, dans le code suivant, `ElementName` substitue `Name`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-157">For example, in the following code, `ElementName` overrides `Name`.</span></span>  
  
 [!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
 [!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]  
  
 <span data-ttu-id="4f5b4-158">L'attribut <xref:System.ServiceModel.MessageHeaderArrayAttribute> n'est pas pris en charge lors de l'utilisation du <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-158">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4f5b4-159">Dans ce cas, le <xref:System.Xml.Serialization.XmlSerializer> lève l’exception suivante, qui est publiée avant WCF: «Un élément déclaré au niveau supérieur d’un schéma ne peut pas `maxOccurs` avoir > 1.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-159">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="4f5b4-160">Fournissez un élément wrapper pour « more » en utilisant `XmlArray` ou `XmlArrayItem` à la place de `XmlElementAttribute` ou en utilisant le style de paramètre Wrapped. ».</span><span class="sxs-lookup"><span data-stu-id="4f5b4-160">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>  
>   
>  <span data-ttu-id="4f5b4-161">Si vous recevez une telle exception, vérifiez si cette situation s'applique.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-161">If you receive such an exception, investigate whether this situation applies.</span></span>  
  
 <span data-ttu-id="4f5b4-162">WCF ne prend pas en <xref:System.Xml.Serialization.SoapIncludeAttribute> charge <xref:System.Xml.Serialization.XmlIncludeAttribute> les attributs et dans les contrats de message et les <xref:System.Runtime.Serialization.KnownTypeAttribute> contrats d’opération; utilisez l’attribut à la place.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-162">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>  
  
## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="4f5b4-163">Types qui implémentent l'interface IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="4f5b4-163">Types that Implement the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="4f5b4-164">Les types qui implémentent l'interface `IXmlSerializable` sont pleinement pris en charge par le `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-164">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="4f5b4-165">L'attribut <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> doit toujours être appliqué à ces types pour contrôler leur schéma.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-165">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="4f5b4-166">Si vous sérialisez des types polymorphes, vous devez appliquer le <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> au type pour vous assurer que le type correct est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-166">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>  
  
 <span data-ttu-id="4f5b4-167">Trois variétés de types implémentent `IXmlSerializable` : les types représentant le contenu arbitraire, les types représentant un élément unique et les types <xref:System.Data.DataSet> hérités.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-167">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
- <span data-ttu-id="4f5b4-168">Les types de contenu utilisent une méthode du fournisseur de schéma spécifiée par l'attribut `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-168">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="4f5b4-169">La méthode ne retourne pas `null`, et la propriété <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> sur l'attribut conserve sa valeur par défaut `false`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-169">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="4f5b4-170">Il s'agit de l'utilisation la plus courante des types `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-170">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
- <span data-ttu-id="4f5b4-171">Les types d'élément sont utilisés lorsqu'un type `IXmlSerializable` doit contrôler son propre nom d'élément racine.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-171">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="4f5b4-172">Pour marquer un type comme type élément, affectez à la propriété <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> sur l'attribut <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> la valeur `true` ou retournez `null` à partir de la méthode du fournisseur de schéma.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-172">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="4f5b4-173">L'utilisation d'une méthode du fournisseur de schéma est facultative pour les types d'élément. Vous pouvez spécifier `null` au lieu du nom de méthode dans `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-173">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="4f5b4-174">Toutefois, si `IsAny` a la valeur `true` et qu'une méthode du fournisseur de schéma est spécifiée, la méthode doit retourner `null`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-174">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>  
  
- <span data-ttu-id="4f5b4-175">Les types <xref:System.Data.DataSet> hérités sont des types `IXmlSerializable` qui ne sont pas marqués avec l'attribut `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-175">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="4f5b4-176">À la place, ils comptent sur la méthode <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> pour la génération de schéma.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-176">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="4f5b4-177">Ce modèle est utilisé pour le type `DataSet` et son groupe de données typés dérive une classe dans les versions antérieures du .NET Framework, mais il est désormais obsolète et pris en charge uniquement pour des raisons d'héritage.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-177">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="4f5b4-178">Ne vous fiez pas à ce modèle et appliquez toujours `XmlSchemaProviderAttribute` à vos types `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-178">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="4f5b4-179">Types de contenu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="4f5b4-179">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="4f5b4-180">Lors de la sérialisation d'un membre de données d'un type qui implémente `IXmlSerializable` et qui est un type de contenu défini précédemment, le sérialiseur écrit l'élément wrapper pour le membre de données et transmet le contrôle à la méthode <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-180">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="4f5b4-181">L'implémentation <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> peut écrire n'importe quel code XML, y compris ajouter des attributs à l'élément wrapper.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-181">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="4f5b4-182">Au terme de l'écriture de `WriteXml`, le sérialiseur ferme l'élément.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-182">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="4f5b4-183">Lors de la désérialisation d'un membre de données d'un type qui implémente `IXmlSerializable` et qui est un type de contenu défini précédemment, le désérialiseur positionne le lecteur XML sur l'élément wrapper du membre de données et transmet le contrôle à la méthode <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-183">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="4f5b4-184">La méthode doit lire l'élément en entier, y compris les balises de début et de fin.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-184">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="4f5b4-185">Assurez-vous que votre code `ReadXml` gère le cas où l'élément est vide.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-185">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="4f5b4-186">En outre, votre implémentation `ReadXml` ne doit pas dépendre d'un nom particulier qui affecterait l'élément wrapper.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-186">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="4f5b4-187">Le nom est choisi par le sérialiseur et peut varier.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-187">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="4f5b4-188">Il est possible d'assigner de manière polymorphe des types de contenu `IXmlSerializable` par exemple aux membres de données de type <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-188">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="4f5b4-189">Les instances de types peuvent aussi être Null.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-189">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="4f5b4-190">Enfin, il est possible d'utiliser des types `IXmlSerializable` avec la conservation des graphiques d'objet activée et avec <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-190">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="4f5b4-191">Toutes ces fonctionnalités nécessitent que le sérialiseur WCF joigne certains attributs dans l’élément wrapper («Nil» et «type» dans l’espace de noms de l’instance du schéma XML et «ID», «ref», «type» et «assembly» dans un espace de noms spécifique à WCF).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-191">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="4f5b4-192">Attributs à ignorer lors de l'implémentation de ReadXml</span><span class="sxs-lookup"><span data-stu-id="4f5b4-192">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="4f5b4-193">Avant de passer le contrôle à votre code `ReadXml`, le désérialiseur examine l'élément XML, détecte les attributs XML spéciaux et effectue des actions sur ceux-ci.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-193">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="4f5b4-194">Par exemple, si « nil » est `true`, une valeur Null sera désérialisée et `ReadXml` n'est pas appelée.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-194">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="4f5b4-195">Si le polymorphisme est détecté, le contenu de l'élément est désérialisé comme s'il s'agissait d'un type différent.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-195">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="4f5b4-196">L'implémentation de `ReadXml` du type assigné de manière polymorphe est appelée.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-196">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="4f5b4-197">Dans tous les cas, une implémentation `ReadXml` doit ignorer les attributs spéciaux puisqu'ils sont contrôlés par le désérialiseur.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-197">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="4f5b4-198">Considérations sur le schéma pour les types de contenu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="4f5b4-198">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="4f5b4-199">Lors de l'exportation du schéma et d'un type de contenu `IXmlSerializable`, la méthode du fournisseur de schéma est appelée.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-199">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="4f5b4-200">Un <xref:System.Xml.Schema.XmlSchemaSet> est passé à la méthode du fournisseur de schéma.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-200">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="4f5b4-201">La méthode peut ajouter un schéma valide au jeu de schémas.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-201">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="4f5b4-202">Le jeu de schémas contient le schéma déjà connu au moment où se produit l'exportation de schéma.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-202">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="4f5b4-203">Lorsque la méthode du fournisseur de schéma doit ajouter un élément au jeu de schémas, elle doit déterminer si un <xref:System.Xml.Schema.XmlSchema> avec l'espace de noms approprié existe déjà dans le jeu.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-203">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="4f5b4-204">Si tel est le cas, la méthode du fournisseur de schéma doit ajouter le nouvel élément au `XmlSchema` existant.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-204">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="4f5b4-205">Sinon, il doit créer une nouvelle instance `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-205">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="4f5b4-206">Cette opération est importante si les tableaux de types `IXmlSerializable` sont utilisés.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-206">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="4f5b4-207">Par exemple, si vous avez un type `IXmlSerializable` exporté comme type « A » dans l'espace de noms « B », il est possible qu'au moment où la méthode du fournisseur de schéma est appelée, le jeu de schémas contienne déjà le schéma pour que « B » contienne le type « ArrayOfA ».</span><span class="sxs-lookup"><span data-stu-id="4f5b4-207">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="4f5b4-208">En plus d'ajouter des types à <xref:System.Xml.Schema.XmlSchemaSet>, la méthode du fournisseur de schéma pour les types de contenu doit retourner une valeur non NULL.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-208">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="4f5b4-209">Elle peut retourner un <xref:System.Xml.XmlQualifiedName> qui spécifie le nom du type de schéma à utiliser pour le type `IXmlSerializable` donné.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-209">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="4f5b4-210">Ce nom qualifié sert également comme nom et espace de noms de contrat de données pour le type.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-210">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="4f5b4-211">Il est possible de retourner un type qui n'existe pas immédiatement dans le jeu de schémas lorsque la méthode du fournisseur de schéma est retournée.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-211">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="4f5b4-212">Toutefois, au moment de l'exportation de tous les types connexes (la méthode <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> est appelée pour tous les types pertinents sur <xref:System.Runtime.Serialization.XsdDataContractExporter> et la propriété <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> est accessible), le type est dans le jeu de schémas.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-212">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="4f5b4-213">Accéder à la propriété `Schemas` avant d'effectuer tous les appels `Export` pertinents peut provoquer une <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-213">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="4f5b4-214">Pour plus d’informations sur le processus d’exportation, consultez [exportation de schémas à partir de classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-214">For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="4f5b4-215">La méthode du fournisseur de schéma peut aussi retourner le <xref:System.Xml.Schema.XmlSchemaType> à utiliser.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-215">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="4f5b4-216">Le type peut ou ne peut pas être anonyme.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-216">The type may or may not be anonymous.</span></span> <span data-ttu-id="4f5b4-217">S'il est anonyme, le schéma du type `IXmlSerializable` est exporté sous la forme d'un type anonyme à chaque fois que le type `IXmlSerializable` est utilisé comme un membre de données.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-217">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="4f5b4-218">Le type `IXmlSerializable` a encore un nom et un espace de noms de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-218">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="4f5b4-219">(Cela est déterminé comme décrit dans [noms des contrats de données](../../../../docs/framework/wcf/feature-details/data-contract-names.md) , <xref:System.Runtime.Serialization.DataContractAttribute> sauf que l’attribut ne peut pas être utilisé pour personnaliser le nom.) S'il n'est pas anonyme, il doit être l'un des types dans le `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-219">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="4f5b4-220">Ce cas revient à retourner le `XmlQualifiedName` du type.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-220">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="4f5b4-221">En outre, une déclaration d'élément globale est exportée pour le type.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-221">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="4f5b4-222">Si l'attribut <xref:System.Xml.Serialization.XmlRootAttribute> n'est pas appliqué au type, l'élément a le même nom et espace de noms que le contrat de données, et sa propriété « nillable » a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-222">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="4f5b4-223">La seule exception est l’espace de noms du schéma`http://www.w3.org/2001/XMLSchema`(): si le contrat de données du type se trouve dans cet espace de noms, l’élément global correspondant se trouve dans l’espace de noms vide, car il est interdit d’ajouter de nouveaux éléments à l’espace de noms du schéma.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-223">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="4f5b4-224">Si l'attribut `XmlRootAttribute` s'applique au type, la déclaration d'élément globale est exportée à l'aide des propriétés suivantes : <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> et <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-224">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="4f5b4-225">Les valeurs par défaut appliquées avec `XmlRootAttribute` sont le nom de contrat de données, un espace de noms vide et « nillable » ayant pour valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-225">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>  
  
 <span data-ttu-id="4f5b4-226">Les mêmes règles de déclaration d'élément globale s'appliquent aux types de groupes de données hérités.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-226">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="4f5b4-227">Notez que `XmlRootAttribute` ne peut pas substituer de déclarations d'élément globales ajoutées par l'intermédiaire du code personnalisé, ajoutées soit à `XmlSchemaSet` à l'aide de la méthode du fournisseur de schéma, soit à l'aide de `GetSchema` pour les types de groupes de données hérités.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-227">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="4f5b4-228">Types d'élément IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="4f5b4-228">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="4f5b4-229">La propriété `IXmlSerializable` des types d'élément `IsAny` a la valeur `true` ou leur méthode du fournisseur de schéma retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-229">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="4f5b4-230">La sérialisation et la désérialisation d'un type d'élément est très semblable à la sérialisation et la désérialisation d'un type de contenu.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-230">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="4f5b4-231">Toutefois, il y a des différences importantes :</span><span class="sxs-lookup"><span data-stu-id="4f5b4-231">However, there are some important differences:</span></span>  
  
- <span data-ttu-id="4f5b4-232">L'implémentation `WriteXml` est censée écrire exactement un élément (qui peut contenir évidemment plusieurs éléments enfants).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-232">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="4f5b4-233">Elle ne doit pas écrire d'attributs en dehors de cet élément unique, plusieurs éléments frères ou de contenu mixte.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-233">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="4f5b4-234">L'élément peut être vide.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-234">The element may be empty.</span></span>  
  
- <span data-ttu-id="4f5b4-235">L'implémentation `ReadXml` ne doit pas lire l'élément wrapper.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-235">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="4f5b4-236">Elle est censée lire l'élément unique produit par `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-236">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
- <span data-ttu-id="4f5b4-237">Lors de la sérialisation régulière d'un type d'élément (par exemple, comme membre de données dans un contrat de données), le sérialiseur produit un élément wrapper avant d'appeler `WriteXml`, comme avec les types de contenu.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-237">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="4f5b4-238">Cependant, lors de la sérialisation d'un type d'élément au niveau supérieur, le sérialiseur ne produit normalement pas un élément wrapper autour de l'élément écrit par `WriteXml`, sauf si un nom racine et l'espace de noms sont spécifiés explicitement lors de l'élaboration du sérialiseur dans les constructeurs `DataContractSerializer` ou `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-238">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="4f5b4-239">Pour plus d’informations, consultez [sérialisation et désérialisation](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-239">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
- <span data-ttu-id="4f5b4-240">Si vous sérialisez un type d'élément au niveau supérieur sans spécifier le nom racine et l'espace de noms au moment de la construction, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> et <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> n'effectuent essentiellement aucune tâche et <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> appelle `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-240">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="4f5b4-241">Dans ce mode, l'objet qui est sérialisé ne peut être `null` et ne peut pas être assigné d'une manière polymorphe.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-241">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="4f5b4-242">La conservation des graphiques d'objet ne peut pas non plus être activée et le `NetDataContractSerializer` ne peut pas être utilisé.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-242">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
- <span data-ttu-id="4f5b4-243">Si vous désérialisez un type d'élément au niveau supérieur sans spécifier le nom racine et l'espace de noms au moment de la construction, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> retourne `true` s'il trouve le début d'un élément.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-243">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="4f5b4-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A>, avec le paramètre `verifyObjectName` ayant la valeur `true`, se comporte de la même façon que `IsStartObject` avant de lire l'objet.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="4f5b4-245">`ReadObject` passe ensuite le contrôle à la méthode `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-245">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="4f5b4-246">Le schéma exporté pour les types d'élément est le même que pour le type `XmlElement` décrit dans une section antérieure, sauf que la méthode du fournisseur de schéma peut ajouter tout schéma supplémentaire au <xref:System.Xml.Schema.XmlSchemaSet> comme avec les types de contenu.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-246">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="4f5b4-247">L'utilisation de l'attribut `XmlRootAttribute` avec les types d'élément n'est pas autorisé, et les déclarations d'élément globales ne sont jamais émises pour ces types.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-247">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="4f5b4-248">Différences par rapport au XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="4f5b4-248">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="4f5b4-249">L'interface `IXmlSerializable` et les attributs `XmlSchemaProviderAttribute` et `XmlRootAttribute` sont également compris par le <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-249">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="4f5b4-250">Cependant, il existe des différences dans la manière dont ils sont traités dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-250">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="4f5b4-251">Ces différences importantes sont répertoriées dans la liste suivante :</span><span class="sxs-lookup"><span data-stu-id="4f5b4-251">The important differences are summarized in the following list:</span></span>  
  
- <span data-ttu-id="4f5b4-252">La méthode du fournisseur de schéma doit être publique pour être utilisée dans le `XmlSerializer`, mais ne doit pas être nécessairement publique pour être utilisée dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-252">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>  
  
- <span data-ttu-id="4f5b4-253">La méthode du fournisseur de schéma est appelée lorsque `IsAny` a la valeur `true` dans le modèle de contrat de données mais pas avec le `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-253">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="4f5b4-254">Lorsque l'attribut `XmlRootAttribute` n'est pas présent pour les types de contenu ou de groupes de données hérités, le `XmlSerializer` exporte une déclaration d'élément globale dans l'espace de noms vide.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-254">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="4f5b4-255">Dans le modèle de contrat de données, l'espace de noms utilisé est normalement l'espace de noms de contrat de données décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-255">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="4f5b4-256">Gardez ces différences à l'esprit lors de la création des types qui sont utilisés avec les deux technologies de sérialisation.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-256">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="4f5b4-257">Importation du schéma IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="4f5b4-257">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="4f5b4-258">Lorsque vous importez un schéma généré à partir des types `IXmlSerializable`, plusieurs possibilités sont offertes :</span><span class="sxs-lookup"><span data-stu-id="4f5b4-258">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
- <span data-ttu-id="4f5b4-259">Le schéma généré peut être un schéma de contrat de données valide, comme décrit dans [référence de schéma de contrat de données](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-259">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="4f5b4-260">Dans ce cas, le schéma peut être importé comme d'habitude et les types de contrat de données normaux sont générés.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-260">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
- <span data-ttu-id="4f5b4-261">Le schéma généré peut ne pas être un schéma de contrat de données valide.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-261">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="4f5b4-262">Par exemple, votre méthode du fournisseur de schéma peut générer un schéma qui implique des attributs XML qui ne sont pas pris en charge dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-262">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="4f5b4-263">Dans ce cas, vous pouvez importer le schéma comme des types `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-263">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="4f5b4-264">Ce mode d’importation n’est pas activé par défaut, mais peut être facilement activé, par exemple `/importXmlTypes` avec le commutateur de ligne de commande de l' [outil ServiceModel Metadata Utility (Svcutil. exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-264">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="4f5b4-265">Cela est décrit en détail dans le [schéma d’importation pour générer des classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="4f5b4-265">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="4f5b4-266">Notez que vous devez utiliser directement le XML pour vos instances de type.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-266">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="4f5b4-267">Vous pouvez envisager d'utiliser également une technologie de sérialisation différente qui prend en charge une plage de schéma plus large. Consultez la rubrique sur l'utilisation du `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-267">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="4f5b4-268">Vous pouvez réutiliser vos types `IXmlSerializable` existants dans le proxy au lieu d'en générer de nouveaux.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-268">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="4f5b4-269">Dans ce cas, la fonctionnalité des types référencés décrite dans la rubrique « Importation du schéma pour générer des types » peut être utilisée pour indiquer le type à réutiliser.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-269">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="4f5b4-270">Cela revient à utiliser le commutateur `/reference` sur svcutil.exe qui spécifie l'assembly qui contient les types à réutiliser.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-270">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="4f5b4-271">Comportement hérité de XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="4f5b4-271">XmlSerializer Legacy Behavior</span></span>  
 <span data-ttu-id="4f5b4-272">Dans le .NET Framework 4.0 et versions antérieures, le XmlSerializer a généré les assemblys de sérialisation temporaires en écrivant le code C# dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-272">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="4f5b4-273">Le fichier a ensuite été compilé dans un assembly.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-273">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="4f5b4-274">Ce comportement a eu certaines conséquences indésirables, comme ralentir le temps de démarrage du sérialiseur.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-274">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="4f5b4-275">Dans le .NET Framework 4.5, ce comportement a été modifié pour générer des assemblys sans exiger l'utilisation du compilateur.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-275">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="4f5b4-276">Certains développeurs peuvent souhaiter consulter le code C# généré.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-276">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="4f5b4-277">Vous pouvez spécifier d'utiliser ce comportement hérité par la configuration suivante :</span><span class="sxs-lookup"><span data-stu-id="4f5b4-277">You can specify to use this legacy behavior by the following configuration:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
  <system.xml.serialization>  
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />  
  </system.xml.serialization>  
  <system.diagnostics>  
    <switches>  
      <add name="XmlSerialization.Compilation" value="1" />  
    </switches>  
  </system.diagnostics>  
</configuration>  
```  
  
 <span data-ttu-id="4f5b4-278">Si vous rencontrez des problèmes de compatibilité, tels que `XmlSerializer` l’échec de la sérialisation d’une classe dérivée avec un nouveau remplacement non public, vous pouvez revenir `XMLSerializer` au comportement hérité à l’aide de la configuration suivante:</span><span class="sxs-lookup"><span data-stu-id="4f5b4-278">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>  
  
```xml  
<configuration>  
<appSettings>   
<add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />  
               </appSettings>  
</configuration>  
```  
  
 <span data-ttu-id="4f5b4-279">En guise d’alternative à la configuration ci-dessus, vous pouvez utiliser la configuration suivante sur un ordinateur exécutant .NET Framework 4,5 ou version ultérieure:</span><span class="sxs-lookup"><span data-stu-id="4f5b4-279">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>  
  
```xml  
<configuration>  
<system.xml.serialization>  
<xmlSerializer useLegacySerializerGeneration="true"/>  
</system.xml.serialization>  
</configuration>  
```  
  
> [!NOTE]
> <span data-ttu-id="4f5b4-280">Le `<xmlSerializer useLegacySerializerGeneration="true"/>` commutateur fonctionne uniquement sur un ordinateur exécutant .NET Framework 4,5 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-280">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="4f5b4-281">L’approche `appSettings` ci-dessus fonctionne sur toutes les versions de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4f5b4-281">The above `appSettings` approach works on all .NET Framework versions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4f5b4-282">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="4f5b4-282">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="4f5b4-283">Spécification du transfert de données dans des contrats de service</span><span class="sxs-lookup"><span data-stu-id="4f5b4-283">Specifying Data Transfer in Service Contracts</span></span>](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="4f5b4-284">Utilisation de contrats de données</span><span class="sxs-lookup"><span data-stu-id="4f5b4-284">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)
- [<span data-ttu-id="4f5b4-285">Guide pratique pour Améliorer le temps de démarrage des applications clientes WCF à l’aide de XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="4f5b4-285">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](../../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
