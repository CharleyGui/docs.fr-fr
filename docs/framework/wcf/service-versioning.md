---
title: Contrôle des versions du service
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: f3cb01531c594df5262963567438b47cbbed58a2
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/22/2019
ms.locfileid: "69923013"
---
# <a name="service-versioning"></a><span data-ttu-id="0d55a-102">Contrôle des versions du service</span><span class="sxs-lookup"><span data-stu-id="0d55a-102">Service Versioning</span></span>
<span data-ttu-id="0d55a-103">Après leur déploiement initial, et potentiellement plusieurs fois pendant leur durée de vie, il peut s’avérer nécessaire de modifier les services (et les points de terminaison qu’ils exposent) pour diverses raisons, telles que l’évolution des besoins de l’entreprise, des exigences informatiques, ou pour résoudre d’autres problèmes.</span><span class="sxs-lookup"><span data-stu-id="0d55a-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="0d55a-104">Chaque modification introduit une nouvelle version du service.</span><span class="sxs-lookup"><span data-stu-id="0d55a-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="0d55a-105">Cette rubrique explique comment prendre en compte le contrôle de version dans Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="0d55a-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="0d55a-106">Quatre catégories de modifications de service</span><span class="sxs-lookup"><span data-stu-id="0d55a-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="0d55a-107">Les modifications apportées aux services qui peuvent s'avérer nécessaires peuvent être classées en quatre catégories :</span><span class="sxs-lookup"><span data-stu-id="0d55a-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="0d55a-108">Modifications du contrat: Par exemple, une opération peut être ajoutée ou un élément de données d’un message peut être ajouté ou modifié.</span><span class="sxs-lookup"><span data-stu-id="0d55a-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="0d55a-109">Modifications de l’adresse: Par exemple, un service se déplace vers un autre emplacement où les points de terminaison ont de nouvelles adresses.</span><span class="sxs-lookup"><span data-stu-id="0d55a-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="0d55a-110">Modifications de liaison: Par exemple, un mécanisme de sécurité change ou ses paramètres changent.</span><span class="sxs-lookup"><span data-stu-id="0d55a-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="0d55a-111">Modifications de l’implémentation: Par exemple, lorsqu’une implémentation de méthode interne change.</span><span class="sxs-lookup"><span data-stu-id="0d55a-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="0d55a-112">Certaines de ces modifications sont dites « avec rupture » et d'autres « sans rupture ».</span><span class="sxs-lookup"><span data-stu-id="0d55a-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="0d55a-113">Une modification est sans *rupture* si tous les messages qui auraient été traités avec succès dans la version précédente sont traités avec succès dans la nouvelle version.</span><span class="sxs-lookup"><span data-stu-id="0d55a-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="0d55a-114">Toute modification qui ne répond pas à ce critère est une modification avec *rupture* .</span><span class="sxs-lookup"><span data-stu-id="0d55a-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="0d55a-115">Contrôle de version et orientation de service</span><span class="sxs-lookup"><span data-stu-id="0d55a-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="0d55a-116">L'une des doctrines de l'orientation de service est que les services et les clients sont autonomes (ou indépendants).</span><span class="sxs-lookup"><span data-stu-id="0d55a-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="0d55a-117">Cela implique notamment que les développeurs de service ne peuvent pas présumer contrôler, voire même connaître, l'ensemble des clients de service.</span><span class="sxs-lookup"><span data-stu-id="0d55a-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="0d55a-118">Cela élimine l'option de régénération et de redéploiement de l'ensemble des clients lorsqu'un service modifie des versions.</span><span class="sxs-lookup"><span data-stu-id="0d55a-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="0d55a-119">Cette rubrique suppose que le service adhère à cette doctrine et qu'il doit par conséquent être modifié ou « associé à une version » indépendamment de ses clients.</span><span class="sxs-lookup"><span data-stu-id="0d55a-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="0d55a-120">Dans les cas où une modification avec rupture est inattendue et ne peut pas être évitée, une application peut choisir d'ignorer cette doctrine et requérir que les clients soient régénérés et redéployés avec une nouvelle version du service.</span><span class="sxs-lookup"><span data-stu-id="0d55a-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="0d55a-121">Contrôle de version des contrats</span><span class="sxs-lookup"><span data-stu-id="0d55a-121">Contract Versioning</span></span>  
 <span data-ttu-id="0d55a-122">Il n'est pas nécessaire que les contrats utilisés par un client soient les mêmes que celui utilisé par le service ; ils doivent seulement être compatibles.</span><span class="sxs-lookup"><span data-stu-id="0d55a-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="0d55a-123">Pour les contrats de service, la compatibilité signifie que les nouvelles opérations exposées par le service peuvent être ajoutées, mais que les opérations existantes ne peuvent pas être supprimées ou modifiées sémantiquement.</span><span class="sxs-lookup"><span data-stu-id="0d55a-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="0d55a-124">Pour les contrats de données, la compatibilité signifie que les nouvelles définitions de type de schéma peuvent être ajoutées, mais que les définitions de type de schéma existantes ne peuvent pas être modifiées avec rupture.</span><span class="sxs-lookup"><span data-stu-id="0d55a-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="0d55a-125">Les modifications avec rupture peuvent inclure la suppression de membres de données ou la modification de leur type de données de manière incompatible.</span><span class="sxs-lookup"><span data-stu-id="0d55a-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="0d55a-126">Cette fonctionnalité offre une certaine latitude au service pour modifier la version de ses contrats sans interruption des clients.</span><span class="sxs-lookup"><span data-stu-id="0d55a-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="0d55a-127">Les deux sections suivantes expliquent les modifications sans rupture et avec rupture qui peuvent être apportées aux contrats de service et de données WCF.</span><span class="sxs-lookup"><span data-stu-id="0d55a-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="0d55a-128">Contrôle de version des contrats de données</span><span class="sxs-lookup"><span data-stu-id="0d55a-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="0d55a-129">Cette section traite du contrôle de version des données lors de l'utilisation des classes <xref:System.Runtime.Serialization.DataContractSerializer> et <xref:System.Runtime.Serialization.DataContractAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0d55a-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="0d55a-130">Contrôle de version strict</span><span class="sxs-lookup"><span data-stu-id="0d55a-130">Strict Versioning</span></span>  
 <span data-ttu-id="0d55a-131">Dans de nombreux scénarios où la modification des versions pose un problème, le développeur de service n'a pas de contrôle sur les clients et ne peut donc pas faire d'hypothèses quant à la manière dont ils pourraient réagir aux modifications apportées dans le message XML ou le schéma.</span><span class="sxs-lookup"><span data-stu-id="0d55a-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="0d55a-132">Dans ce cas, vous devez garantir que les nouveaux messages effectueront une validation par rapport à l'ancien schéma, pour deux raisons :</span><span class="sxs-lookup"><span data-stu-id="0d55a-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="0d55a-133">Les anciens clients ont été développés dans l'hypothèse que le schéma ne changera pas.</span><span class="sxs-lookup"><span data-stu-id="0d55a-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="0d55a-134">Il se peut qu'ils échouent à traiter des messages pour lesquels ils n'ont jamais été conçus.</span><span class="sxs-lookup"><span data-stu-id="0d55a-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="0d55a-135">Les anciens clients peuvent effectuer la validation de schéma réelle par rapport à l’ancien schéma avant même d’essayer de traiter les messages.</span><span class="sxs-lookup"><span data-stu-id="0d55a-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="0d55a-136">L'approche recommandée dans les scénarios de ce type consiste à traiter les contrats de données existants comme immuables et à en créer de nouveaux avec des noms complets XML uniques.</span><span class="sxs-lookup"><span data-stu-id="0d55a-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="0d55a-137">Le développeur de service dispose alors de deux options : ajouter de nouvelles méthodes à un contrat de service existant ou créer un contrat de service avec des méthodes qui utilisent le nouveau contrat de données.</span><span class="sxs-lookup"><span data-stu-id="0d55a-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="0d55a-138">Bien souvent, le développeur de service doit écrire la logique métier qui doit s'exécuter dans toutes les versions d'un contrat de données ainsi que le code métier spécifique à la version pour chaque version du contrat de données.</span><span class="sxs-lookup"><span data-stu-id="0d55a-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="0d55a-139">L'annexe à la fin de cette rubrique explique comment utiliser les interfaces pour répondre à ce besoin.</span><span class="sxs-lookup"><span data-stu-id="0d55a-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="0d55a-140">Contrôle de version souple</span><span class="sxs-lookup"><span data-stu-id="0d55a-140">Lax Versioning</span></span>  
 <span data-ttu-id="0d55a-141">Dans de nombreux autres scénarios, le développeur de service peut partir de l'hypothèse que l'ajout d'un nouveau membre facultatif au contrat de données n'interrompra pas les clients existants.</span><span class="sxs-lookup"><span data-stu-id="0d55a-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="0d55a-142">Cela implique que le développeur de service étudie si les clients existants n’exécutent pas de validation de schéma et s’ils ignorent des membres de données inconnus.</span><span class="sxs-lookup"><span data-stu-id="0d55a-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="0d55a-143">Dans ces scénarios, il est possible de tirer parti des fonctionnalités de contrat de données permettant d'ajouter de nouveaux membres sans rupture.</span><span class="sxs-lookup"><span data-stu-id="0d55a-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="0d55a-144">Le développeur de service peut partir sans problème de cette hypothèse si les fonctionnalités de contrat de données permettant le contrôle de version ont déjà été utilisées pour la première version du service.</span><span class="sxs-lookup"><span data-stu-id="0d55a-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="0d55a-145">WCF, les services Web ASP.NET et beaucoup d’autres piles de services Web prennent en charge le contrôle de version de type *Lax*: autrement dit, ils ne lèvent pas d’exceptions pour les nouveaux membres de données inconnus dans les données reçues.</span><span class="sxs-lookup"><span data-stu-id="0d55a-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="0d55a-146">On peut facilement croire à tort que l'ajout d'un nouveau membre n'interrompra pas les clients existants.</span><span class="sxs-lookup"><span data-stu-id="0d55a-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="0d55a-147">Si vous n'êtes pas certain que tous les clients peuvent gérer le contrôle de version souple, nous vous recommandons de vous conformer aux instructions sur le contrôle de version strict et de traiter les contrats de données comme immuables.</span><span class="sxs-lookup"><span data-stu-id="0d55a-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="0d55a-148">Pour obtenir des instructions détaillées sur le contrôle de version de type Lax et strict [des contrats de données, consultez meilleures pratiques: Contrôle de version](../../../docs/framework/wcf/best-practices-data-contract-versioning.md)des contrats de données.</span><span class="sxs-lookup"><span data-stu-id="0d55a-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="0d55a-149">Distinction entre le contrat de données et les types .NET</span><span class="sxs-lookup"><span data-stu-id="0d55a-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="0d55a-150">Une structure ou classe .NET peut être projetée comme contrat de données en appliquant l'attribut <xref:System.Runtime.Serialization.DataContractAttribute> à la classe.</span><span class="sxs-lookup"><span data-stu-id="0d55a-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="0d55a-151">Le type .NET et ses projections de contrat de données sont deux aspects distincts.</span><span class="sxs-lookup"><span data-stu-id="0d55a-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="0d55a-152">Il est possible d'avoir plusieurs types .NET avec la même projection de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="0d55a-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="0d55a-153">Cette distinction est particulièrement utile en ce sens qu'elle vous permet de modifier le type .NET tout en conservant le contrat de données projeté, et de conserver ainsi la compatibilité avec les clients existants, et ce même au sens strict du terme.</span><span class="sxs-lookup"><span data-stu-id="0d55a-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="0d55a-154">Pour conserver cette distinction entre le type .NET et le contrat de données, vous devez systématiquement effectuer les deux procédures suivantes :</span><span class="sxs-lookup"><span data-stu-id="0d55a-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="0d55a-155">Spécifiez <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> et <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="0d55a-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="0d55a-156">Vous devez systématiquement spécifier le nom et l'espace de noms de votre contrat de données afin d'empêcher ceux de votre type .NET d'être exposés dans le contrat.</span><span class="sxs-lookup"><span data-stu-id="0d55a-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="0d55a-157">De cette façon, si vous décidez ultérieurement de modifier le nom du type ou l'espace de noms .NET, votre contrat de données restera identique.</span><span class="sxs-lookup"><span data-stu-id="0d55a-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="0d55a-158">Spécifiez <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="0d55a-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="0d55a-159">Vous devez systématiquement spécifier le nom de vos membres de données afin d'empêcher le nom de votre membre .NET d'être exposé dans le contrat.</span><span class="sxs-lookup"><span data-stu-id="0d55a-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="0d55a-160">De cette façon, si vous décidez ultérieurement de modifier le nom .NET du membre, votre contrat de données restera identique.</span><span class="sxs-lookup"><span data-stu-id="0d55a-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="0d55a-161">Modification ou suppression de membres</span><span class="sxs-lookup"><span data-stu-id="0d55a-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="0d55a-162">La modification du nom ou du type de données d'un membre, ou la suppression des membres de données, est une modification avec rupture si le contrôle de version souple est autorisé.</span><span class="sxs-lookup"><span data-stu-id="0d55a-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="0d55a-163">Créez un contrat de données si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="0d55a-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="0d55a-164">Si la compatibilité de service est importante, vous pouvez envisager d'ignorer les membres de données non utilisés dans votre code et les laisser en place.</span><span class="sxs-lookup"><span data-stu-id="0d55a-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="0d55a-165">Si vous fractionnez un membre de données en plusieurs, vous pouvez envisager de laisser le membre existant en place en tant que propriété pouvant exécuter le fractionnement et la réagrégation requis pour les clients de niveau inférieur (clients qui ne sont pas mis à niveau à la dernière version).</span><span class="sxs-lookup"><span data-stu-id="0d55a-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="0d55a-166">De la même façon, les modifications apportées à l'espace de noms ou au nom du contrat de données sont des modifications avec rupture.</span><span class="sxs-lookup"><span data-stu-id="0d55a-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="0d55a-167">Allers-retours de données inconnues</span><span class="sxs-lookup"><span data-stu-id="0d55a-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="0d55a-168">Dans certains scénarios, il est nécessaire d'effectuer un « aller-retour » des données inconnues qui proviennent de membres ajoutées dans une nouvelle version.</span><span class="sxs-lookup"><span data-stu-id="0d55a-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="0d55a-169">Par exemple, un service « NouvelleVersion » envoie des données avec des membres récemment ajoutés à un client « AncienneVersion ».</span><span class="sxs-lookup"><span data-stu-id="0d55a-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="0d55a-170">Le client ignore les membres récemment ajoutés lors du traitement du message, mais il renvoie ces mêmes données, y compris les membres récemment ajoutés, au service NouvelleVersion.</span><span class="sxs-lookup"><span data-stu-id="0d55a-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="0d55a-171">Le scénario classique dans ce cas est la mise à jour des données dans le cadre de laquelle les données sont récupérées à partir du service, modifiées et retournées.</span><span class="sxs-lookup"><span data-stu-id="0d55a-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="0d55a-172">Pour activer l'aller-retour pour un type spécifique, ce dernier doit implémenter l'interface <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="0d55a-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="0d55a-173">L'interface contient la propriété <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> qui retourne le type <xref:System.Runtime.Serialization.ExtensionDataObject>.</span><span class="sxs-lookup"><span data-stu-id="0d55a-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="0d55a-174">Cette propriété permet de stocker les données des futures versions du contrat de données qui est inconnu de la version actuelle.</span><span class="sxs-lookup"><span data-stu-id="0d55a-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="0d55a-175">Ces données sont opaques pour le client, mais lorsque l'instance est sérialisée, le contenu de la propriété <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> est écrit avec le reste des données des membres de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="0d55a-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="0d55a-176">Il est recommandé que tous vos types implémentent cette interface afin de prendre en charge les membres nouveaux et inconnus.</span><span class="sxs-lookup"><span data-stu-id="0d55a-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="0d55a-177">Bibliothèques de contrats de données</span><span class="sxs-lookup"><span data-stu-id="0d55a-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="0d55a-178">Il peut y avoir des bibliothèques de contrats de données dans lesquelles un contrat est publié sur un référentiel central, et des implémenteurs de type et de service qui implémentent et exposent des contrats de données à partir de ce référentiel.</span><span class="sxs-lookup"><span data-stu-id="0d55a-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="0d55a-179">Dans ce cas, lorsque vous publiez un contrat de données sur le référentiel, vous n'avez aucun contrôle sur l'élément qui crée les types qui l'implémentent.</span><span class="sxs-lookup"><span data-stu-id="0d55a-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="0d55a-180">Par conséquent, vous ne pouvez pas modifier le contrat une fois celui-ci publié, et le rendre ainsi immuable.</span><span class="sxs-lookup"><span data-stu-id="0d55a-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="0d55a-181">Lors de l'utilisation de XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="0d55a-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="0d55a-182">Les mêmes principes de contrôle de version s'appliquent lors de l'utilisation de la classe <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="0d55a-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="0d55a-183">Lorsque le contrôle de version strict est requis, traitez des contrats de données comme immuables et créez des contrats de données avec noms complets uniques pour les nouvelles versions.</span><span class="sxs-lookup"><span data-stu-id="0d55a-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="0d55a-184">Si vous êtes certain de pouvoir utiliser le contrôle de version souple, vous pouvez ajouter de nouveaux membres sérialisables dans les nouvelles versions, mais vous ne pouvez pas modifier ou supprimer les membres existants.</span><span class="sxs-lookup"><span data-stu-id="0d55a-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0d55a-185"><xref:System.Xml.Serialization.XmlSerializer> utilise les attributs <xref:System.Xml.Serialization.XmlAnyElementAttribute> et <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> pour prendre en charge l'aller-retour des données inconnues.</span><span class="sxs-lookup"><span data-stu-id="0d55a-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="0d55a-186">Contrôle de version des contrats de message</span><span class="sxs-lookup"><span data-stu-id="0d55a-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="0d55a-187">Les instructions relatives au contrôle de version des contrats de message sont très semblables à celles du contrôle de version des contrats de données.</span><span class="sxs-lookup"><span data-stu-id="0d55a-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="0d55a-188">Si le contrôle de version strict est requis, vous ne devez pas modifier le corps de votre message, mais créer à la place un contrat de message avec un nom complet unique.</span><span class="sxs-lookup"><span data-stu-id="0d55a-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="0d55a-189">Si vous êtes certain de pouvoir utiliser le contrôle de version souple, vous pouvez ajouter de nouvelles parties de corps de message, mais vous ne pouvez pas modifier ou supprimer des parties existantes.</span><span class="sxs-lookup"><span data-stu-id="0d55a-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="0d55a-190">Cette instruction s'applique à la fois aux contrats de message encapsulé et nu.</span><span class="sxs-lookup"><span data-stu-id="0d55a-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="0d55a-191">Des en-têtes de message peuvent toujours être ajoutés, même si le contrôle de version strict est utilisé.</span><span class="sxs-lookup"><span data-stu-id="0d55a-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="0d55a-192">L'indicateur MustUnderstand peut affecter le contrôle de version.</span><span class="sxs-lookup"><span data-stu-id="0d55a-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="0d55a-193">En général, le modèle de contrôle de version pour les en-têtes dans WCF est décrit dans la spécification SOAP.</span><span class="sxs-lookup"><span data-stu-id="0d55a-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="0d55a-194">Contrôle de version des contrats de service</span><span class="sxs-lookup"><span data-stu-id="0d55a-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="0d55a-195">À l'instar du contrôle de version des contrats de données, celui concernant les contrats de service implique également des opérations d'ajout, de modification et de suppression.</span><span class="sxs-lookup"><span data-stu-id="0d55a-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="0d55a-196">Spécification du nom, de l'espace de noms et de l'action</span><span class="sxs-lookup"><span data-stu-id="0d55a-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="0d55a-197">Par défaut, le nom d'un contrat de service correspond à celui de l'interface.</span><span class="sxs-lookup"><span data-stu-id="0d55a-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="0d55a-198">Son espace de noms par http://tempuri.org défaut est «», et l’action de http://tempuri.org/contractname/methodname chaque opération est «».</span><span class="sxs-lookup"><span data-stu-id="0d55a-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="0d55a-199">Il est recommandé de spécifier explicitement un nom et un espace de noms pour le contrat de service, ainsi qu’une action pour chaque opération http://tempuri.org afin d’éviter d’utiliser «» et d’empêcher l’exposition des noms d’interface et de méthode dans le contrat du service.</span><span class="sxs-lookup"><span data-stu-id="0d55a-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="0d55a-200">Ajout de paramètres et d'opérations</span><span class="sxs-lookup"><span data-stu-id="0d55a-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="0d55a-201">L'ajout des opérations de service exposées par le service est une modification sans rupture car les clients existants n'ont pas à se soucier de ces nouvelles opérations.</span><span class="sxs-lookup"><span data-stu-id="0d55a-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0d55a-202">L'ajout des opérations à un contrat de rappel duplex est une modification avec rupture.</span><span class="sxs-lookup"><span data-stu-id="0d55a-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="0d55a-203">Modification des types de retours ou de paramètres d'opération</span><span class="sxs-lookup"><span data-stu-id="0d55a-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="0d55a-204">La modification des types de retours ou de paramètres est généralement une modification avec rupture, sauf si le nouveau type implémente le même contrat de données implémenté par l'ancien type.</span><span class="sxs-lookup"><span data-stu-id="0d55a-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="0d55a-205">Pour apporter une modification de ce type, ajoutez une nouvelle opération au contrat de service ou définissez un nouveau contrat de service.</span><span class="sxs-lookup"><span data-stu-id="0d55a-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="0d55a-206">Suppression d'opérations</span><span class="sxs-lookup"><span data-stu-id="0d55a-206">Removing Operations</span></span>  
 <span data-ttu-id="0d55a-207">La suppression d'opérations est également une modification avec rupture.</span><span class="sxs-lookup"><span data-stu-id="0d55a-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="0d55a-208">Pour apporter une modification de ce type, définissez un nouveau contrat de service et exposez-le sur un nouveau point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="0d55a-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="0d55a-209">Contrats d'erreur</span><span class="sxs-lookup"><span data-stu-id="0d55a-209">Fault Contracts</span></span>  
 <span data-ttu-id="0d55a-210">L'attribut <xref:System.ServiceModel.FaultContractAttribute> permet à un développeur de contrat de service de spécifier des informations sur les erreurs qui peuvent être retournées par les opérations du contrat.</span><span class="sxs-lookup"><span data-stu-id="0d55a-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="0d55a-211">La liste d'erreurs décrite dans le contrat d'un service n'est pas considérée comme exhaustive.</span><span class="sxs-lookup"><span data-stu-id="0d55a-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="0d55a-212">À tout moment, une opération peut retourner des erreurs qui ne sont pas décrites dans son contrat.</span><span class="sxs-lookup"><span data-stu-id="0d55a-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="0d55a-213">Par conséquent, la modification du jeu d'erreurs décrit dans le contrat n'est pas considérée comme une modification avec rupture.</span><span class="sxs-lookup"><span data-stu-id="0d55a-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="0d55a-214">Par exemple, ajouter une nouvelle erreur au contrat à l'aide de <xref:System.ServiceModel.FaultContractAttribute> ou supprimer une erreur existante du contrat.</span><span class="sxs-lookup"><span data-stu-id="0d55a-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="0d55a-215">Bibliothèques de contrats de service</span><span class="sxs-lookup"><span data-stu-id="0d55a-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="0d55a-216">Les entreprises peuvent avoir des bibliothèques de contrats dans lesquelles un contrat est publié sur un référentiel central, et des implémenteurs de service qui implémentent des contrats à partir de ce référentiel.</span><span class="sxs-lookup"><span data-stu-id="0d55a-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="0d55a-217">Dans ce cas, lorsque vous publiez un contrat de service sur le référentiel, vous n'avez aucun contrôle sur l'élément qui crée les services qui l'implémentent.</span><span class="sxs-lookup"><span data-stu-id="0d55a-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="0d55a-218">Par conséquent, vous ne pouvez pas modifier le contrat de service une fois celui-ci publié, et le rendre ainsi immuable.</span><span class="sxs-lookup"><span data-stu-id="0d55a-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="0d55a-219">WCF prend en charge l’héritage de contrat, qui peut être utilisé pour créer un contrat qui étend les contrats existants.</span><span class="sxs-lookup"><span data-stu-id="0d55a-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="0d55a-220">Pour utiliser cette fonctionnalité, définissez une nouvelle interface de contrat de service qui hérite de l'ancienne interface de contrat de service, puis ajoutez-lui des méthodes.</span><span class="sxs-lookup"><span data-stu-id="0d55a-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="0d55a-221">Modifiez ensuite le service qui implémente l'ancien contrat pour implémenter le nouveau contrat et modifier la définition de point de terminaison de l'« AncienneVersion » afin d'utiliser le nouveau contrat.</span><span class="sxs-lookup"><span data-stu-id="0d55a-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="0d55a-222">Pour les clients de l'« AncienneVersion », le point de terminaison continuera d'exposer le contrat de l'« AncienneVersion » ; pour les clients de la « NouvelleVersion », le point de terminaison exposera le contrat de la « NouvelleVersion ».</span><span class="sxs-lookup"><span data-stu-id="0d55a-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="0d55a-223">Contrôle de version des adresses et liaisons</span><span class="sxs-lookup"><span data-stu-id="0d55a-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="0d55a-224">Les modifications apportées à la liaison et à l'adresse de point de terminaison sont des modifications avec rupture, sauf si les clients sont capables de découvrir dynamiquement la nouvelle liaison ou adresse de point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="0d55a-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="0d55a-225">L’un des mécanismes permettant d’implémenter cette fonctionnalité consiste à utiliser un registre UDDI (Universal Discovery Description and Integration) et le modèle d’appel UDDI lorsqu’un client tente de communiquer avec un point de terminaison et, qu’après échec, il interroge un registre UDDI connu pour les métadonnées de point de terminaison actuelles.</span><span class="sxs-lookup"><span data-stu-id="0d55a-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="0d55a-226">Le client utilise ensuite l'adresse et la liaison à partir de ces métadonnées pour communiquer avec le point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="0d55a-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="0d55a-227">Si cette communication réussit, le client met en cache les informations d'adresse et de liaison pour un usage ultérieur.</span><span class="sxs-lookup"><span data-stu-id="0d55a-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="0d55a-228">Contrôle de version et service de routage</span><span class="sxs-lookup"><span data-stu-id="0d55a-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="0d55a-229">Si les modifications apportées à un service sont des modifications avec rupture et vous n'avez pas besoin de plusieurs versions différentes d'un service exécutées simultanément, vous pouvez utiliser le Service de routage WCF pour acheminer les messages vers l'instance de service appropriée.</span><span class="sxs-lookup"><span data-stu-id="0d55a-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="0d55a-230">Le Service de routage WCF utilise le routage basé sur le contenu, c'est-à-dire qu'il utilise les informations contenues dans le message pour déterminer la destination du message.</span><span class="sxs-lookup"><span data-stu-id="0d55a-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="0d55a-231">Pour plus d’informations sur le service de routage WCF, consultez [service de routage](../../../docs/framework/wcf/feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="0d55a-231">For more information about the WCF Routing Service see [Routing Service](../../../docs/framework/wcf/feature-details/routing-service.md).</span></span> <span data-ttu-id="0d55a-232">Pour obtenir un exemple d’utilisation du service de routage WCF pour le contrôle de version [du service, consultez Procédure: Contrôle de version](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md)du service.</span><span class="sxs-lookup"><span data-stu-id="0d55a-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="0d55a-233">Annexe</span><span class="sxs-lookup"><span data-stu-id="0d55a-233">Appendix</span></span>  
 <span data-ttu-id="0d55a-234">Les instructions relatives au contrôle de version des contrats de données lorsque le contrôle de version strict est requis permettent de traiter des contrats de données comme immuables et d'en créer de nouveaux lorsque des modifications sont requises.</span><span class="sxs-lookup"><span data-stu-id="0d55a-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="0d55a-235">Une nouvelle classe devant être créée pour chaque nouveau contrat de données, un mécanisme est donc nécessaire pour éviter d'avoir à utiliser le code existant qui a été écrit par rapport à l'ancienne classe de contrat de données et à le réécrire par rapport à la nouvelle.</span><span class="sxs-lookup"><span data-stu-id="0d55a-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="0d55a-236">Un mécanisme de ce type permet d'utiliser des interfaces pour définir les membres de chaque contrat de données et écrire le code d'implémentation interne par rapport aux interfaces plutôt que par rapport aux classes de contrat de données qui implémentent les interfaces.</span><span class="sxs-lookup"><span data-stu-id="0d55a-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="0d55a-237">Le code suivant de la version 1 d'un service présente une interface `IPurchaseOrderV1` et `PurchaseOrderV1` :</span><span class="sxs-lookup"><span data-stu-id="0d55a-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="0d55a-238">Alors que les opérations du contrat de service sont écrites par rapport à `PurchaseOrderV1`, la logique métier réelle est écrite par rapport à `IPurchaseOrderV1`.</span><span class="sxs-lookup"><span data-stu-id="0d55a-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="0d55a-239">Puis, dans la version 2, il y aurait une nouvelle interface `IPurchaseOrderV2` et une nouvelle classe `PurchaseOrderV2`, tel qu'indiqué dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="0d55a-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```  
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(   
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="0d55a-240">Le contrat de service est mis à jour afin d'inclure les nouvelles opérations écrites par rapport à `PurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="0d55a-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="0d55a-241">La logique métier existante écrite par rapport à `IPurchaseOrderV1` continue à fonctionner pour `PurchaseOrderV2`, et la nouvelle logique métier qui nécessite la propriété `OrderDate` est écrite par rapport à `IPurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="0d55a-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0d55a-242">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="0d55a-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="0d55a-243">Équivalence des contrats de données</span><span class="sxs-lookup"><span data-stu-id="0d55a-243">Data Contract Equivalence</span></span>](../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="0d55a-244">Rappels de sérialisation avec tolérance de version</span><span class="sxs-lookup"><span data-stu-id="0d55a-244">Version-Tolerant Serialization Callbacks</span></span>](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)
