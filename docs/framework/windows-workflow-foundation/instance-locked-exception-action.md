---
title: Action d'exception verrouillée d'instance
ms.date: 03/30/2017
ms.assetid: 164a5419-315c-4987-ad72-54cbdb88d402
ms.openlocfilehash: 3554975589bb6d55cef3611320d25687d1ee9ba6
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96279855"
---
# <a name="instance-locked-exception-action"></a><span data-ttu-id="fa453-102">Action d'exception verrouillée d'instance</span><span class="sxs-lookup"><span data-stu-id="fa453-102">Instance Locked Exception Action</span></span>

<span data-ttu-id="fa453-103">La propriété <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> du Magasin d'instances de workflow SQL vous permet de spécifier quelle mesure le fournisseur de persistance SQL doit prendre lorsqu'il reçoit une <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span><span class="sxs-lookup"><span data-stu-id="fa453-103">The <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> property of the SQL Workflow Instance Store lets you specify what action the SQL persistence provider should take when it receives an <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span> <span data-ttu-id="fa453-104">Le fournisseur de persistance reçoit cette exception lorsqu'il essaye de verrouiller une instance de service de workflow actuellement verrouillée par un autre hôte de service.</span><span class="sxs-lookup"><span data-stu-id="fa453-104">The persistence provider receives this exception when it tries to lock a workflow service instance that is currently locked by another service host.</span></span> <span data-ttu-id="fa453-105">Les valeurs possibles pour cette propriété sont : <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>, <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> et <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span><span class="sxs-lookup"><span data-stu-id="fa453-105">The values for this property are <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>, <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>, and <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span></span> <span data-ttu-id="fa453-106">La valeur par défaut est <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span><span class="sxs-lookup"><span data-stu-id="fa453-106">The default value is <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span> <span data-ttu-id="fa453-107">La liste suivante décrit ces trois options :</span><span class="sxs-lookup"><span data-stu-id="fa453-107">The following list describes the three options:</span></span>  
  
- <span data-ttu-id="fa453-108"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span><span class="sxs-lookup"><span data-stu-id="fa453-108"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span> <span data-ttu-id="fa453-109">L’hôte de service n’essaie pas de verrouiller l’instance de service de workflow et passe le <xref:System.Runtime.DurableInstancing.InstanceLockedException> à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="fa453-109">The service host does not attempt to lock the workflow service instance and passes the <xref:System.Runtime.DurableInstancing.InstanceLockedException> to the caller.</span></span>  <span data-ttu-id="fa453-110">Si votre flux de travail reste en mémoire pendant une période supérieure à 60 secondes, utilisez <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry> comme nouvelle tentative.</span><span class="sxs-lookup"><span data-stu-id="fa453-110">If your workflow stays in memory for a period exceeding 60 seconds, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry> as the retry.</span></span> <span data-ttu-id="fa453-111">La valeur par défaut est <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span><span class="sxs-lookup"><span data-stu-id="fa453-111">The default value is <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span>  
  
- <span data-ttu-id="fa453-112"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>.</span><span class="sxs-lookup"><span data-stu-id="fa453-112"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>.</span></span> <span data-ttu-id="fa453-113">L'hôte de service réessaie de verrouiller l'instance de service de workflow avec un intervalle de tentative linéaire et passe <xref:System.Runtime.DurableInstancing.InstanceLockedException> à l'appelant à la fin de la séquence.</span><span class="sxs-lookup"><span data-stu-id="fa453-113">The service host reattempts to lock the workflow service instance with a linear interval between retry attempts and passes the <xref:System.Runtime.DurableInstancing.InstanceLockedException> to the caller at the end of the sequence.</span></span> <span data-ttu-id="fa453-114">Si votre flux de travail reste dans la mémoire approximativement entre 5 et 60 secondes, et les messages arrivent par lot là où il est plus probable qu'ils soient envoyés à la même instance sur le même hôte pour traiter tous les messages avant de décharger le flux de travail, utilisez <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> pour obtenir la meilleure latence sans gaspiller de ressources.</span><span class="sxs-lookup"><span data-stu-id="fa453-114">If you workflow stays in memory approximately between 5-60 seconds, and messages arrive in batches where it is more likely for messages being sent to the same instance on the same host to process all messages before unloading the workflow, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> to achieve the best latency without wasting resources.</span></span>  
  
- <span data-ttu-id="fa453-115"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span><span class="sxs-lookup"><span data-stu-id="fa453-115"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span></span> <span data-ttu-id="fa453-116">L'hôte de service réessaie de verrouiller l'instance de service de workflow avec un intervalle de tentative de réduction de puissance exponentiel et passe l'exception à l'appelant à la fin de la séquence.</span><span class="sxs-lookup"><span data-stu-id="fa453-116">The service host reattempts to lock the workflow service instance with an exponential backoff interval between retry attempts, and passes the exception to the caller at the end of the sequence.</span></span> <span data-ttu-id="fa453-117">Si votre flux de travail reste en mémoire pendant une durée très courte (inférieure à 5 secondes), ou une batterie de serveurs Web a une grande taille et la probabilité qu'un autre message soit remis au même hôte n'est pas très élevée, utilisez <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry> pour obtenir la meilleure latence.</span><span class="sxs-lookup"><span data-stu-id="fa453-117">If your workflow stays in memory for a very short time (less than 5 seconds), or a Web farm is large and the chance of another message being delivered to the same host is not very high, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry> to achieve the best latency.</span></span>  
  
 <span data-ttu-id="fa453-118">La fonctionnalité Action d'exception verrouillée d'instance prend en charge les scénarios ci-après.</span><span class="sxs-lookup"><span data-stu-id="fa453-118">The Instance Locked Exception Action feature supports the following scenarios.</span></span> <span data-ttu-id="fa453-119">Dans tous les scénarios, si la propriété instanceLockedExceptionAction du SqlWorkflowInstanceStore a la valeur <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> ou <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>, l'hôte réessaye de façon transparente d'acquérir régulièrement le verrou sur les instances.</span><span class="sxs-lookup"><span data-stu-id="fa453-119">In all scenarios, if the instanceLockedExceptionAction property of the SqlWorkflowInstanceStore is set to <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> or <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>, the host transparently retries to acquire the lock on instances periodically.</span></span>  
  
1. <span data-ttu-id="fa453-120">**Activation de l'arrêt approprié et du recyclage avec chevauchement des domaines d'application.**</span><span class="sxs-lookup"><span data-stu-id="fa453-120">**Enabling graceful shutdown and overlapped recycling of application domains.**</span></span> <span data-ttu-id="fa453-121">Supposons qu’un **AppDomain** avec un hôte de service exécutant des instances de service de workflow est en cours de recyclage et qu’un nouveau **AppDomain** soit mis en place pour gérer les nouvelles demandes en parallèle pendant que l’ancien **AppDomain** est arrêté correctement.</span><span class="sxs-lookup"><span data-stu-id="fa453-121">Suppose an **AppDomain** with a service host running workflow service instances is being recycled and a new **AppDomain** is brought up to handle new requests in parallel while the old **AppDomain** is brought down gracefully.</span></span> <span data-ttu-id="fa453-122">L'arrêt attend jusqu'à ce que les instances de service de workflow soient inactives, puis il les rend persistantes et les décharge.</span><span class="sxs-lookup"><span data-stu-id="fa453-122">The shutdown waits until workflow service instances are idle, and then persists and unloads the instances.</span></span> <span data-ttu-id="fa453-123">Toute tentative de verrouillage d’une instance par les hôtes dans le nouvel **AppDomain** entraîne un <xref:System.Runtime.DurableInstancing.InstanceLockedException> .</span><span class="sxs-lookup"><span data-stu-id="fa453-123">Any attempts by hosts in the new **AppDomain** to lock an instance will cause an <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span>  
  
2. <span data-ttu-id="fa453-124">**Mise à l’échelle horizontale des flux de travail durables sur une batterie de serveurs homogène.**</span><span class="sxs-lookup"><span data-stu-id="fa453-124">**Horizontally scaling durable workflows across a homogeneous farm of servers.**</span></span> <span data-ttu-id="fa453-125">Imaginez qu'un nœud d'une batterie de serveurs sur laquelle une instance de workflow s'exécute tombe en panne et que l'hôte de workflow ne peut pas supprimer les verrous sur l'instance qu'il exécute.</span><span class="sxs-lookup"><span data-stu-id="fa453-125">Suppose a node of a server farm on which a workflow instance is running crashes and the workflow host cannot remove locks on the instance it is running.</span></span> <span data-ttu-id="fa453-126">Lorsqu'un hôte de service s'exécutant sur un autre nœud de la batterie reçoit un message pour cette instance de workflow, il essaye d'acquérir des verrous sur ces instances et reçoit l'<xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span><span class="sxs-lookup"><span data-stu-id="fa453-126">When a service host running on another node of the farm receives a message for that workflow instance, it tries to acquire locks on these instances it will receive the <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span> <span data-ttu-id="fa453-127">Les verrous expirent après un certain temps, car l'hôte qui était censé renouveler le verrou n'existe plus.</span><span class="sxs-lookup"><span data-stu-id="fa453-127">The locks will expire after some time because the host that was supposed to renew the lock no longer exists.</span></span>  
  
     <span data-ttu-id="fa453-128">**Mise à l’échelle horizontale des flux de travail durables sur une batterie de serveurs homogène.**</span><span class="sxs-lookup"><span data-stu-id="fa453-128">**Horizontally scaling durable workflows across a homogeneous farm of servers.**</span></span>  <span data-ttu-id="fa453-129"> Imaginez que vous souhaitez mettre à l'échelle horizontalement un flux de travail durable à l'aide de plusieurs hôtes derrière un NLB (équilibrage de charge réseau). Le flux de travail hôte s'exécutant sur un nœud de la batterie charge une instance de workflow et traite un message. Le message suivant destiné à l'instance est acheminé vers l'hôte qui s'exécute sur un autre nœud, car le NLB n'a pas d'algorithme de routage pour remettre des messages à l'hôte qui exécute déjà l'instance.</span><span class="sxs-lookup"><span data-stu-id="fa453-129">Suppose you want to horizontally scale a durable workflow using multiple hosts behind a NLB (Network Load Balancer), the workflow host running on one node of the farm loads a workflow instance and is processing a message, and the next message to the instance is routed to the host that is running on another node because the NLB does not have routing algorithm to deliver messages to the host that is already running the instance.</span></span> <span data-ttu-id="fa453-130">À la réception du message, le second hôte essaye de charger l'instance de workflow et reçoit l'objet <xref:System.Runtime.DurableInstancing.InstanceLockedException>, car le premier hôte a un verrou sur l'instance.</span><span class="sxs-lookup"><span data-stu-id="fa453-130">Upon receiving the message, the second host attempts to load the workflow instance and receives the <xref:System.Runtime.DurableInstancing.InstanceLockedException> because the first host has a lock on the instance.</span></span> <span data-ttu-id="fa453-131">Le premier hôte déverrouille l'instance lorsqu'il a terminé de traiter le premier message et le second hôte acquiert le verrou lorsqu'il réessaye une nouvelle fois. Il charge alors l'instance et traite le second message.</span><span class="sxs-lookup"><span data-stu-id="fa453-131">The first host unlocks the instance when it is finished with processing the first message and the second host acquires the lock when it retries the next time, loads the instance, and processes the second message.</span></span>
