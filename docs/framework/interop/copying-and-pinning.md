---
title: copie et épinglage
description: Examinez comment le marshaleur d’interopérabilité peut copier ou épingler des données qui sont marshalées. La copie de données place une copie des données d’un emplacement de mémoire à un autre emplacement.
ms.date: 03/30/2017
helpviewer_keywords:
- pinning, interop marshaling
- copying, interop marshaling
- interop marshaling, copying
- interop marshaling, pinning
ms.assetid: 0059f576-e460-4e70-b257-668870e420b8
ms.openlocfilehash: b7931813cd5254375eda81515f388c85c78fa284
ms.sourcegitcommit: e02d17b2cf9c1258dadda4810a5e6072a0089aee
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/01/2020
ms.locfileid: "85618777"
---
# <a name="copying-and-pinning"></a><span data-ttu-id="b4e66-104">copie et épinglage</span><span class="sxs-lookup"><span data-stu-id="b4e66-104">Copying and Pinning</span></span>

<span data-ttu-id="b4e66-105">Lors du marshaling des données, le marshaleur d’interopérabilité peut copier ou épingler les données qui sont marshalées.</span><span class="sxs-lookup"><span data-stu-id="b4e66-105">When marshaling data, the interop marshaler can copy or pin the data being marshaled.</span></span> <span data-ttu-id="b4e66-106">La copie des données déplace une copie des données d’un emplacement de mémoire vers un autre emplacement de mémoire.</span><span class="sxs-lookup"><span data-stu-id="b4e66-106">Copying the data places a copy of data from one memory location in another memory location.</span></span> <span data-ttu-id="b4e66-107">L’illustration suivante montre les différences entre la copie d’un type valeur et la copie d’un type passé par référence à partir de la mémoire managée vers la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="b4e66-107">The following illustration shows the differences between copying a value type and copying a type passed by reference from managed to unmanaged memory.</span></span>

![Diagramme illustrant la façon dont sont copiés les types référence et valeur.](./media/copying-and-pinning/interop-marshal-copy.gif)

<span data-ttu-id="b4e66-109">Des arguments de méthode passés par valeur sont marshalés vers le code non managé en tant que valeurs sur la pile.</span><span class="sxs-lookup"><span data-stu-id="b4e66-109">Method arguments passed by value are marshaled to unmanaged code as values on the stack.</span></span> <span data-ttu-id="b4e66-110">Le processus de copie est direct.</span><span class="sxs-lookup"><span data-stu-id="b4e66-110">The copying process is direct.</span></span> <span data-ttu-id="b4e66-111">Les arguments passés par référence sont passés comme pointeurs sur la pile.</span><span class="sxs-lookup"><span data-stu-id="b4e66-111">Arguments passed by reference are passed as pointers on the stack.</span></span> <span data-ttu-id="b4e66-112">Les types référence sont également passés par valeur et par référence.</span><span class="sxs-lookup"><span data-stu-id="b4e66-112">Reference types are also passed by value and by reference.</span></span> <span data-ttu-id="b4e66-113">Comme le montre l’illustration suivante, les types référence passés en valeur sont soit copiés, soit épinglés :</span><span class="sxs-lookup"><span data-stu-id="b4e66-113">As the following illustration shows, reference types passed by value are either copied or pinned:</span></span>

![Diagramme illustrant des types référence passés en valeur et en référence.](./media/copying-and-pinning/interop-marshal-reference-pin.gif)

<span data-ttu-id="b4e66-115">L’épinglage verrouille temporairement les données dans leur emplacement de mémoire actuel, évitant ainsi qu’elles ne soient déplacées par le garbage collector du common language runtime.</span><span class="sxs-lookup"><span data-stu-id="b4e66-115">Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime's garbage collector.</span></span> <span data-ttu-id="b4e66-116">Le marshaleur épingle des données pour réduire la charge mémoire imposée par la copie et pour améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="b4e66-116">The marshaler pins data to reduce the overhead of copying and enhance performance.</span></span> <span data-ttu-id="b4e66-117">Le type des données détermine si celles-ci sont copiées ou épinglées lors du processus de marshaling.</span><span class="sxs-lookup"><span data-stu-id="b4e66-117">The type of the data determines whether it is copied or pinned during the marshaling process.</span></span>  <span data-ttu-id="b4e66-118">L’épinglage se fait automatiquement pendant le marshaling pour les objets tels que <xref:System.String>. Cependant, vous pouvez également épingler manuellement la mémoire à l’aide de la classe <xref:System.Runtime.InteropServices.GCHandle>.</span><span class="sxs-lookup"><span data-stu-id="b4e66-118">Pinning is automatically performed during marshaling for objects such as <xref:System.String>, however you can also manually pin memory using the <xref:System.Runtime.InteropServices.GCHandle> class.</span></span>

## <a name="formatted-blittable-classes"></a><span data-ttu-id="b4e66-119">Classes blittables mises en forme</span><span class="sxs-lookup"><span data-stu-id="b4e66-119">Formatted Blittable Classes</span></span>

<span data-ttu-id="b4e66-120">Les classes [blittables](blittable-and-non-blittable-types.md) mises en forme ont une disposition fixe (mise en forme) et une représentation commune des données en mémoire managée et non managée.</span><span class="sxs-lookup"><span data-stu-id="b4e66-120">Formatted [blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) and common data representation in both managed and unmanaged memory.</span></span> <span data-ttu-id="b4e66-121">Quand ces types nécessitent d’être marshalés, un pointeur vers l’objet dans le tas est passé directement à l’appelé.</span><span class="sxs-lookup"><span data-stu-id="b4e66-121">When these types require marshaling, a pointer to the object in the heap is passed to the callee directly.</span></span> <span data-ttu-id="b4e66-122">L’appelé peut changer le contenu de l’emplacement de mémoire référencé par le pointeur.</span><span class="sxs-lookup"><span data-stu-id="b4e66-122">The callee can change the contents of the memory location being referenced by the pointer.</span></span>

> [!NOTE]
> <span data-ttu-id="b4e66-123">L’appelé peut changer le contenu de la mémoire si le paramètre est marqué ou en sortie/sortie. En revanche, l’appelé doit éviter de modifier le contenu lorsque le paramètre a la valeur marshaler comme dans, ce qui correspond à la valeur par défaut pour les types blittables mis en forme.</span><span class="sxs-lookup"><span data-stu-id="b4e66-123">The callee can change the memory contents if the parameter is marked Out or In/Out. In contrast, the callee should avoid changing the contents when the parameter is set to marshal as In, which is the default for formatted blittable types.</span></span> <span data-ttu-id="b4e66-124">La modification d’un objet en entrée génère des problèmes quand la même classe est exportée vers une bibliothèque de types et utilisée pour effectuer des appels entre cloisonnements.</span><span class="sxs-lookup"><span data-stu-id="b4e66-124">Modifying an In object generates problems when the same class is exported to a type library and used to make cross-apartment calls.</span></span>

## <a name="formatted-non-blittable-classes"></a><span data-ttu-id="b4e66-125">Classes non blittables mises en forme</span><span class="sxs-lookup"><span data-stu-id="b4e66-125">Formatted Non-Blittable Classes</span></span>

<span data-ttu-id="b4e66-126">Les classes [non blittables](blittable-and-non-blittable-types.md) mises en forme ont une disposition fixe (mise en forme), mais la représentation des données est différente en mémoire managée et non managée.</span><span class="sxs-lookup"><span data-stu-id="b4e66-126">Formatted [non-blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) but the data representation is different in managed and unmanaged memory.</span></span> <span data-ttu-id="b4e66-127">Les données peuvent nécessiter des transformations dans les situations suivantes :</span><span class="sxs-lookup"><span data-stu-id="b4e66-127">The data can require transformation under the following conditions:</span></span>

- <span data-ttu-id="b4e66-128">Si une classe non blittable est marshalée par valeur, l’appelé reçoit un pointeur vers une copie de la structure de données.</span><span class="sxs-lookup"><span data-stu-id="b4e66-128">If a non-blittable class is marshaled by value, the callee receives a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="b4e66-129">Si une classe non blittable est marshalée par référence, l’appelé reçoit un pointeur vers un pointeur vers une copie de la structure de données.</span><span class="sxs-lookup"><span data-stu-id="b4e66-129">If a non-blittable class is marshaled by reference, the callee receives a pointer to a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="b4e66-130">Si l’attribut <xref:System.Runtime.InteropServices.InAttribute> est défini, cette copie est toujours initialisée avec l’état de l’instance, en marshalant si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="b4e66-130">If the <xref:System.Runtime.InteropServices.InAttribute> attribute is set, this copy is always initialized with the instance's state, marshaling as necessary.</span></span>

- <span data-ttu-id="b4e66-131">Si l’attribut <xref:System.Runtime.InteropServices.OutAttribute> est défini, l’état est toujours recopié dans l’instance au retour, en marshalant si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="b4e66-131">If the <xref:System.Runtime.InteropServices.OutAttribute> attribute is set, the state is always copied back to the instance on return, marshaling as necessary.</span></span>

- <span data-ttu-id="b4e66-132">Si les deux attributs **InAttribute** et **OutAttribute** sont définis, les deux copies sont requises.</span><span class="sxs-lookup"><span data-stu-id="b4e66-132">If both **InAttribute** and **OutAttribute** are set, both copies are required.</span></span> <span data-ttu-id="b4e66-133">Si l’un des attributs est omis, le marshaleur peut optimiser en éliminant l’une des copies.</span><span class="sxs-lookup"><span data-stu-id="b4e66-133">If either attribute is omitted, the marshaler can optimize by eliminating either copy.</span></span>

## <a name="reference-types"></a><span data-ttu-id="b4e66-134">Types référence</span><span class="sxs-lookup"><span data-stu-id="b4e66-134">Reference Types</span></span>

<span data-ttu-id="b4e66-135">Les types référence peuvent être passés par valeur ou par référence.</span><span class="sxs-lookup"><span data-stu-id="b4e66-135">Reference types can be passed by value or by reference.</span></span> <span data-ttu-id="b4e66-136">Quand ils sont passés par valeur, un pointeur vers le type est passé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="b4e66-136">When they are passed by value, a pointer to the type is passed on the stack.</span></span> <span data-ttu-id="b4e66-137">Quand ils sont passés par référence, un pointeur vers un pointeur vers le type est passé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="b4e66-137">When passed by reference, a pointer to a pointer to the type is passed on the stack.</span></span>

<span data-ttu-id="b4e66-138">Les types référence possèdent le comportement conditionnel suivant :</span><span class="sxs-lookup"><span data-stu-id="b4e66-138">Reference types have the following conditional behavior:</span></span>

- <span data-ttu-id="b4e66-139">Si un type référence est passé par valeur et possède des membres de types non blittables, les types sont convertis deux fois :</span><span class="sxs-lookup"><span data-stu-id="b4e66-139">If a reference type is passed by value and it has members of non-blittable types, the types are converted twice:</span></span>

  - <span data-ttu-id="b4e66-140">Quand un argument est passé vers le côté non managé.</span><span class="sxs-lookup"><span data-stu-id="b4e66-140">When an argument is passed to the unmanaged side.</span></span>

  - <span data-ttu-id="b4e66-141">Lors du retour de l’appel.</span><span class="sxs-lookup"><span data-stu-id="b4e66-141">On return from the call.</span></span>

  <span data-ttu-id="b4e66-142">Pour éviter copie et conversion inutiles, ces types sont marshalés en tant que paramètres en entrée.</span><span class="sxs-lookup"><span data-stu-id="b4e66-142">To avoid unnecessarily copying and conversion, these types are marshaled as In parameters.</span></span> <span data-ttu-id="b4e66-143">Vous devez appliquer explicitement les attributs **InAttribute** et **OutAttribute** à un argument pour que l’appelant voie les changements effectués par l’appelé.</span><span class="sxs-lookup"><span data-stu-id="b4e66-143">You must explicitly apply the **InAttribute** and **OutAttribute** attributes to an argument for the caller to see changes made by the callee.</span></span>

- <span data-ttu-id="b4e66-144">Si un type référence est passé par valeur et ne possède que des membres de types blittables, ce type peut être épinglé lors du marshaling et tout changement apporté par l’appelé aux membres du type est vu par l’appelant.</span><span class="sxs-lookup"><span data-stu-id="b4e66-144">If a reference type is passed by value and it has only members of blittable types, it can be pinned during marshaling and any changes made to the members of the type by the callee are seen by the caller.</span></span> <span data-ttu-id="b4e66-145">Appliquez les attributs **InAttribute** et **OutAttribute** explicitement si vous voulez ce comportement.</span><span class="sxs-lookup"><span data-stu-id="b4e66-145">Apply **InAttribute** and **OutAttribute** explicitly if you want this behavior.</span></span> <span data-ttu-id="b4e66-146">Sans ces attributs directionnels, le marshaleur d’interopérabilité n’exporte pas d’informations directionnelles vers la bibliothèque de types (il exporte en entrée, ce qui est le paramètre par défaut). Cela peut poser des problèmes lors du marshaling entre cloisonnements COM.</span><span class="sxs-lookup"><span data-stu-id="b4e66-146">Without these directional attributes, the interop marshaler does not export directional information to the type library (it exports as In, which is the default) and this can cause problems with COM cross-apartment marshaling.</span></span>

- <span data-ttu-id="b4e66-147">Si un type référence est passé par référence, il est marshalé en entrée/sortie par défaut.</span><span class="sxs-lookup"><span data-stu-id="b4e66-147">If a reference type is passed by reference, it will be marshaled as In/Out by default.</span></span>

## <a name="systemstring-and-systemtextstringbuilder"></a><span data-ttu-id="b4e66-148">System.String et System.Text.StringBuilder</span><span class="sxs-lookup"><span data-stu-id="b4e66-148">System.String and System.Text.StringBuilder</span></span>

<span data-ttu-id="b4e66-149">Quand des données sont marshalées vers du code non managé par valeur ou par référence, le marshaleur copie généralement les données vers une mémoire tampon secondaire (en convertissant éventuellement des jeux de caractères lors de la copie) et passe une référence à la mémoire tampon à l’appelé.</span><span class="sxs-lookup"><span data-stu-id="b4e66-149">When data is marshaled to unmanaged code by value or by reference, the marshaler typically copies the data to a secondary buffer (possibly converting character sets during the copy) and passes a reference to the buffer to the callee.</span></span> <span data-ttu-id="b4e66-150">Sauf si la référence est un **BSTR** alloué avec **SysAllocString**, la référence est toujours allouée avec **CoTaskMemAlloc**.</span><span class="sxs-lookup"><span data-stu-id="b4e66-150">Unless the reference is a **BSTR** allocated with **SysAllocString**, the reference is always allocated with **CoTaskMemAlloc**.</span></span>

<span data-ttu-id="b4e66-151">Par souci d’optimisation quand l’un ou l’autre type de chaîne est marshalé par valeur (notamment comme chaîne de caractères Unicode), le marshaleur passe à l’appelé un pointeur direct vers des chaînes managées dans la mémoire tampon Unicode interne au lieu de le copier dans une nouvelle mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="b4e66-151">As an optimization when either string type is marshaled by value (such as a Unicode character string), the marshaler passes the callee a direct pointer to managed strings in the internal Unicode buffer instead of copying it to a new buffer.</span></span>

> [!CAUTION]
> <span data-ttu-id="b4e66-152">Quand une chaîne est passée par valeur, l’appelé ne doit jamais changer la référence passée par le marshaleur.</span><span class="sxs-lookup"><span data-stu-id="b4e66-152">When a string is passed by value, the callee must never alter the reference passed by the marshaler.</span></span> <span data-ttu-id="b4e66-153">Sinon, il risque d’endommager le tas managé.</span><span class="sxs-lookup"><span data-stu-id="b4e66-153">Doing so can corrupt the managed heap.</span></span>

<span data-ttu-id="b4e66-154">Quand <xref:System.String?displayProperty=nameWithType> est passé par référence, le marshaleur copie le contenu de la chaîne dans une mémoire tampon secondaire avant d’effectuer l’appel.</span><span class="sxs-lookup"><span data-stu-id="b4e66-154">When a <xref:System.String?displayProperty=nameWithType> is passed by reference, the marshaler copies the contents the string to a secondary buffer before making the call.</span></span> <span data-ttu-id="b4e66-155">Il copie ensuite le contenu de la mémoire tampon dans une nouvelle chaîne au retour de l’appel.</span><span class="sxs-lookup"><span data-stu-id="b4e66-155">It then copies the contents of the buffer into a new string on return from the call.</span></span> <span data-ttu-id="b4e66-156">Cette technique garantit que la chaîne managée non modifiable demeure inchangée.</span><span class="sxs-lookup"><span data-stu-id="b4e66-156">This technique ensures that the immutable managed string remains unaltered.</span></span>

<span data-ttu-id="b4e66-157">Quand <xref:System.Text.StringBuilder?displayProperty=nameWithType> est passé par valeur, le marshaleur passe une référence à la mémoire tampon interne de **StringBuilder** directement à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="b4e66-157">When a <xref:System.Text.StringBuilder?displayProperty=nameWithType> is passed by value, the marshaler passes a reference to the internal buffer of the **StringBuilder** directly to the caller.</span></span> <span data-ttu-id="b4e66-158">L’appelant et l’appelé doivent s’entendre sur la taille de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="b4e66-158">The caller and callee must agree on the size of the buffer.</span></span> <span data-ttu-id="b4e66-159">L’appelant est chargé de créer un **StringBuilder** de longueur adéquate.</span><span class="sxs-lookup"><span data-stu-id="b4e66-159">The caller is responsible for creating a **StringBuilder** of adequate length.</span></span> <span data-ttu-id="b4e66-160">L’appelé doit prendre les précautions nécessaires pour garantir le non-débordement de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="b4e66-160">The callee must take the necessary precautions to ensure that the buffer is not overrun.</span></span> <span data-ttu-id="b4e66-161">**StringBuilder** fait exception à la règle qui veut que les types référence passés par valeur sont passés comme paramètres en entrée par défaut.</span><span class="sxs-lookup"><span data-stu-id="b4e66-161">**StringBuilder** is an exception to the rule that reference types passed by value are passed as In parameters by default.</span></span> <span data-ttu-id="b4e66-162">Il est toujours passé comme paramètre en entrée/sortie.</span><span class="sxs-lookup"><span data-stu-id="b4e66-162">It is always passed as In/Out.</span></span>

## <a name="see-also"></a><span data-ttu-id="b4e66-163">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="b4e66-163">See also</span></span>

- [<span data-ttu-id="b4e66-164">comportement de marshaling par défaut</span><span class="sxs-lookup"><span data-stu-id="b4e66-164">Default Marshaling Behavior</span></span>](default-marshaling-behavior.md)
- <span data-ttu-id="b4e66-165">[Attributs directionnels](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="b4e66-165">[Directional Attributes](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span></span>
- [<span data-ttu-id="b4e66-166">Marshaling d’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="b4e66-166">Interop Marshaling</span></span>](interop-marshaling.md)
