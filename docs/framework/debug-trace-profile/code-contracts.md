---
title: Contrats de code
description: Explorez les contrats de code, qui fournissent un moyen de spécifier des conditions préalables, des post-conditions et des invariants d’objet dans votre code .NET.
ms.date: 09/05/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
ms.openlocfilehash: 60f794373af75bd3f745c224e0a8c7a84192e4c4
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904141"
---
# <a name="code-contracts"></a><span data-ttu-id="1f1cb-103">Contrats de code</span><span class="sxs-lookup"><span data-stu-id="1f1cb-103">Code Contracts</span></span>

<span data-ttu-id="1f1cb-104">Les contrats de code offrent un moyen de spécifier des conditions préalables, des post-conditions et des invariants d'objet dans votre code.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-104">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="1f1cb-105">Les conditions préalables sont des exigences qui doivent être satisfaites à l'entrée d'une méthode ou d'une propriété.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-105">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="1f1cb-106">Les post-conditions décrivent les attentes à la sortie de la méthode ou de la propriété.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-106">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="1f1cb-107">Les invariants d'objet décrivent l'état attendu pour une classe présentant un état correct.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-107">Object invariants describe the expected state for a class that is in a good state.</span></span>

<span data-ttu-id="1f1cb-108">Les contrats de code incluent des classes pour le marquage de votre code, un analyseur statique pour l'analyse au moment de la compilation, ainsi qu'un analyseur au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-108">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="1f1cb-109">Les classes des contrats de code se trouvent dans l'espace de noms <xref:System.Diagnostics.Contracts>.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-109">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>

<span data-ttu-id="1f1cb-110">Les contrats de code offrent les avantages suivants :</span><span class="sxs-lookup"><span data-stu-id="1f1cb-110">The benefits of code contracts include the following:</span></span>

- <span data-ttu-id="1f1cb-111">Tests améliorés : les contrats de code permettent la vérification de contrat statique, la vérification au moment de l'exécution et la génération de documentation.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-111">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>

- <span data-ttu-id="1f1cb-112">Outils de test automatique : vous pouvez utiliser les contrats de code pour générer des tests unitaires plus explicites en filtrant les arguments de test sans signification qui ne remplissent pas les conditions préalables.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-112">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>

- <span data-ttu-id="1f1cb-113">Vérification statique : le vérificateur statique peut déterminer s'il existe des violations de contrat sans exécuter le programme.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-113">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="1f1cb-114">Il recherche des contrats implicites, tels que des déréférencements et des limites de tableau null, ainsi que des contrats explicites.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-114">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>

- <span data-ttu-id="1f1cb-115">Documentation de référence : le générateur de documentation complète les fichiers de documentation XML existants avec des informations de contrat.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-115">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="1f1cb-116">Des feuilles de style peuvent également être utilisées avec [Sandcastle](https://github.com/EWSoftware/SHFB) pour ajouter des sections de contrat dans les pages de documentation générées.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-116">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>

<span data-ttu-id="1f1cb-117">Tous les langages .NET Framework peuvent directement utiliser les contrats, sans que vous ayez besoin de développer un analyseur ou compilateur spécial.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-117">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="1f1cb-118">Un complément Visual Studio vous permet de spécifier le niveau d'analyse de contrats de code à effectuer.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-118">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="1f1cb-119">Les analyseurs peuvent vérifier que les contrats sont correctement écrits (contrôle de type et résolution de noms), et créer un formulaire compilé des contrats au format MSIL (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="1f1cb-119">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="1f1cb-120">La création de contrats dans Visual Studio vous permet de tirer parti de la fonctionnalité IntelliSense standard fournie par l'outil.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-120">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>

<span data-ttu-id="1f1cb-121">La plupart des méthodes dans la classe de contrat sont compilées de façon conditionnelle, à savoir que le compilateur effectue des appels à ces méthodes uniquement si vous définissez le symbole spécial CONTRACTS_FULL à l'aide de la directive `#define`.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-121">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="1f1cb-122">Avec CONTRACTS_FULL, vous pouvez écrire des contrats dans votre code sans utiliser de directives `#ifdef`, et générer ainsi différentes builds, avec et sans contrats.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-122">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>

<span data-ttu-id="1f1cb-123">Pour obtenir des outils et des instructions détaillées sur l’utilisation des contrats de code, consultez [contrats de code](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) sur le site Visual Studio Marketplace.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-123">For tools and detailed instructions for using code contracts, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio marketplace site.</span></span>

## <a name="preconditions"></a><span data-ttu-id="1f1cb-124">Preconditions</span><span class="sxs-lookup"><span data-stu-id="1f1cb-124">Preconditions</span></span>

<span data-ttu-id="1f1cb-125">Vous pouvez spécifier des conditions préalables à l'aide de la méthode <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-125">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1f1cb-126">Les conditions préalables définissent l'état à l'appel d'une méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-126">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="1f1cb-127">Elles sont généralement utilisées pour indiquer des valeurs de paramètre valides.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-127">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="1f1cb-128">Tous les membres spécifiés dans les conditions préalables doivent être au moins aussi accessibles que la méthode elle-même. Autrement, la condition préalable risque de ne pas être comprise par tous les appelants de la méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-128">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="1f1cb-129">La condition ne doit pas avoir d'effets secondaires.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-129">The condition must have no side-effects.</span></span> <span data-ttu-id="1f1cb-130">Le comportement au moment de l'exécution des conditions préalables non réussies est déterminé par l'analyseur au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-130">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="1f1cb-131">Par exemple, la condition préalable suivante spécifie que le paramètre `x` ne doit pas être null.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-131">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>

```csharp
Contract.Requires(x != null);
```

<span data-ttu-id="1f1cb-132">Si votre code doit lever une exception particulière en cas d'échec d'une condition préalable, utilisez la surcharge générique de <xref:System.Diagnostics.Contracts.Contract.Requires%2A> comme suit.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-132">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>

```csharp
Contract.Requires<ArgumentNullException>(x != null, "x");
```

### <a name="legacy-requires-statements"></a><span data-ttu-id="1f1cb-133">Instructions Requires héritées</span><span class="sxs-lookup"><span data-stu-id="1f1cb-133">Legacy Requires Statements</span></span>

<span data-ttu-id="1f1cb-134">Dans la plupart des cas, le code contient du code de validation de paramètres sous la forme d’instructions `if`-`then`-`throw`.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-134">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="1f1cb-135">Les outils de contrat reconnaissent ces instructions comme étant des conditions préalables dans les cas suivants :</span><span class="sxs-lookup"><span data-stu-id="1f1cb-135">The contract tools recognize these statements as preconditions in the following cases:</span></span>

- <span data-ttu-id="1f1cb-136">Ces instructions sont placées avant toutes les autres instructions dans une méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-136">The statements appear before any other statements in a method.</span></span>

- <span data-ttu-id="1f1cb-137">L'ensemble de ces instructions est suivi d'un appel de méthode <xref:System.Diagnostics.Contracts.Contract> explicite, tel qu'un appel à la méthode <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A> ou <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-137">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>

<span data-ttu-id="1f1cb-138">Quand les instructions `if`-`then`-`throw` apparaissent sous cette forme, les outils les reconnaissent en tant qu’instructions `requires` héritées.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-138">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="1f1cb-139">Si aucun autre contrat ne suit la séquence `if`-`then`-`throw`, terminez le code par la méthode <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-139">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>

```csharp
if (x == null) throw new ...
Contract.EndContractBlock(); // All previous "if" checks are preconditions
```

<span data-ttu-id="1f1cb-140">Notez que la condition du test précédent est une condition préalable négative</span><span class="sxs-lookup"><span data-stu-id="1f1cb-140">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="1f1cb-141">(La condition préalable réelle est `x != null` .) Une condition préalable négative est très restreinte : elle doit être écrite comme indiqué dans l’exemple précédent. autrement dit, il ne doit pas contenir `else` de clauses, et le corps de la `then` clause doit être une `throw` instruction unique.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-141">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="1f1cb-142">Le test `if` est soumis aux règles de pureté et à celles de visibilité (voir [Indications relatives à l’utilisation](#usage_guidelines)), mais l’expression `throw` est soumise uniquement aux règles de pureté.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-142">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="1f1cb-143">Toutefois, le type de l'exception levée doit être aussi visible que la méthode dans laquelle le contrat se produit.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-143">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>

## <a name="postconditions"></a><span data-ttu-id="1f1cb-144">Postconditions</span><span class="sxs-lookup"><span data-stu-id="1f1cb-144">Postconditions</span></span>

<span data-ttu-id="1f1cb-145">Les post-conditions sont des contrats relatifs à l'état d'une méthode qui se termine.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-145">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="1f1cb-146">La post-condition est vérifiée juste avant la sortie de la méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-146">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="1f1cb-147">Le comportement au moment de l'exécution des post-conditions non réussies est déterminé par l'analyseur au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-147">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="1f1cb-148">Contrairement aux conditions préalables, les post-conditions peuvent référencer des membres ayant moins de visibilité.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-148">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="1f1cb-149">Il est possible qu'un client ne puisse pas comprendre ou utiliser certaines des informations spécifiées par une post-condition avec un état privé, mais cela n'empêche pas le client d'utiliser la méthode correctement.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-149">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>

### <a name="standard-postconditions"></a><span data-ttu-id="1f1cb-150">Post-conditions standard</span><span class="sxs-lookup"><span data-stu-id="1f1cb-150">Standard Postconditions</span></span>

<span data-ttu-id="1f1cb-151">Vous pouvez spécifier les post-conditions standard à l'aide de la méthode <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-151">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="1f1cb-152">Les post-conditions expriment une condition qui doit être `true` à l'arrêt normal de la méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-152">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>

```csharp
Contract.Ensures(this.F > 0);
```

### <a name="exceptional-postconditions"></a><span data-ttu-id="1f1cb-153">Post-conditions exceptionnelles</span><span class="sxs-lookup"><span data-stu-id="1f1cb-153">Exceptional Postconditions</span></span>

<span data-ttu-id="1f1cb-154">Les post-conditions exceptionnelles sont des post-conditions qui doivent être `true` quand une exception particulière est levée par une méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-154">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="1f1cb-155">Vous pouvez les spécifier à l'aide de la méthode <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType>, comme le montre l'exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-155">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>

```csharp
Contract.EnsuresOnThrow<T>(this.F > 0);
```

<span data-ttu-id="1f1cb-156">L’argument est la condition qui doit être `true` chaque fois qu’une exception qui est un sous-type de `T` est levée.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-156">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>

<span data-ttu-id="1f1cb-157">Certains types d'exception sont difficiles à utiliser dans une post-condition exceptionnelle.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-157">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="1f1cb-158">Par exemple, l'utilisation du type <xref:System.Exception> pour `T` nécessite que la méthode garantisse la condition indépendamment du type d'exception levée, même s'il s'agit d'un dépassement de capacité de la pile ou d'une autre exception impossible à contrôler.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-158">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="1f1cb-159">Utilisez les post-conditions exceptionnelles uniquement pour des exceptions spécifiques qui peuvent être levées après l'appel d'un membre, par exemple, quand une exception <xref:System.InvalidTimeZoneException> est levée pour un appel de méthode <xref:System.TimeZoneInfo>.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-159">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>

### <a name="special-postconditions"></a><span data-ttu-id="1f1cb-160">Post-conditions spéciales</span><span class="sxs-lookup"><span data-stu-id="1f1cb-160">Special Postconditions</span></span>

<span data-ttu-id="1f1cb-161">Les méthodes suivantes peuvent être utilisées uniquement au sein de post-conditions :</span><span class="sxs-lookup"><span data-stu-id="1f1cb-161">The following methods may be used only within postconditions:</span></span>

- <span data-ttu-id="1f1cb-162">Vous pouvez faire référence aux valeurs de retour de la méthode dans les post-conditions à l'aide de l'expression `Contract.Result<T>()`, où `T` est remplacé par le type de retour de la méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-162">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="1f1cb-163">Si le compilateur ne peut pas déduire le type, vous devez le fournir explicitement.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-163">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="1f1cb-164">Par exemple, le compilateur C# ne peut pas déduire les types des méthodes qui ne prennent pas d'arguments. Il nécessite donc la post-condition suivante : `Contract.Ensures(0 <Contract.Result<int>())`. Les méthodes possédant le type de retour `void` ne peuvent pas faire référence à `Contract.Result<T>()` dans leurs post-conditions.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-164">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>

- <span data-ttu-id="1f1cb-165">Une valeur de « pré-état » dans une post-condition fait référence à la valeur d'une expression au début d'une méthode ou d'une propriété.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-165">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="1f1cb-166">Elle utilise l'expression `Contract.OldValue<T>(e)`, où `T` est le type de `e`.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-166">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="1f1cb-167">Vous pouvez omettre l'argument de type générique chaque fois que le compilateur est en mesure de déduire son type</span><span class="sxs-lookup"><span data-stu-id="1f1cb-167">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="1f1cb-168">(Par exemple, le compilateur C# déduit toujours le type, car il accepte un argument.) Il existe plusieurs restrictions sur ce qui peut se produire dans `e` et les contextes dans lesquels une expression ancienne peut apparaître.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-168">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="1f1cb-169">Une expression ancienne ne peut pas contenir une autre expression ancienne.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-169">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="1f1cb-170">Encore plus important, une expression ancienne doit faire référence à une valeur qui a existé dans l'état de condition préalable de la méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-170">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="1f1cb-171">En d'autres termes, il doit s'agir d'une expression qui peut être évaluée tant que la condition préalable de la méthode est `true`.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-171">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="1f1cb-172">Voici plusieurs instances de cette règle :</span><span class="sxs-lookup"><span data-stu-id="1f1cb-172">Here are several instances of that rule.</span></span>

  - <span data-ttu-id="1f1cb-173">La valeur doit exister dans l'état de condition préalable de la méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-173">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="1f1cb-174">Pour pouvoir référencer un champ sur un objet, les conditions préalables doivent garantir que l’objet est toujours non null.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-174">In order to reference a field on an object, the preconditions must guarantee that the object is always non-null.</span></span>

  - <span data-ttu-id="1f1cb-175">Vous ne pouvez pas faire référence à la valeur de retour de la méthode dans une expression ancienne :</span><span class="sxs-lookup"><span data-stu-id="1f1cb-175">You cannot refer to the method's return value in an old expression:</span></span>

      ```csharp
      Contract.OldValue(Contract.Result<int>() + x) // ERROR
      ```

  - <span data-ttu-id="1f1cb-176">Vous ne pouvez pas faire référence aux paramètres `out` dans une expression ancienne.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-176">You cannot refer to `out` parameters in an old expression.</span></span>

  - <span data-ttu-id="1f1cb-177">Une expression ancienne ne peut pas dépendre de la variable liée d'un quantificateur si la plage du quantificateur dépend de la valeur de retour de la méthode :</span><span class="sxs-lookup"><span data-stu-id="1f1cb-177">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>

      ```csharp
      Contract.ForAll(0, Contract.Result<int>(), i => Contract.OldValue(xs[i]) > 3); // ERROR
      ```

  - <span data-ttu-id="1f1cb-178">Une expression ancienne ne peut pas faire référence au paramètre du délégué anonyme dans un appel <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> ou <xref:System.Diagnostics.Contracts.Contract.Exists%2A>, sauf si elle est utilisée en tant qu’indexeur ou argument pour un appel de méthode :</span><span class="sxs-lookup"><span data-stu-id="1f1cb-178">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>

      ```csharp
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(xs[i]) > 3); // OK
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(i) > 3); // ERROR
      ```

  - <span data-ttu-id="1f1cb-179">Une expression ancienne ne peut pas s'utiliser dans le corps d'un délégué anonyme si la valeur de l'expression ancienne dépend de l'un des paramètres du délégué anonyme, à moins que le délégué anonyme ne soit un argument de la méthode <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> ou <xref:System.Diagnostics.Contracts.Contract.Exists%2A> :</span><span class="sxs-lookup"><span data-stu-id="1f1cb-179">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>

      ```csharp
      Method(... (T t) => Contract.OldValue(... t ...) ...); // ERROR
      ```

  - <span data-ttu-id="1f1cb-180">Les paramètres `Out` posent un problème, car les contrats sont placés avant le corps de la méthode, et la plupart des compilateurs n'autorisent pas les références aux paramètres `out` dans les post-conditions.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-180">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="1f1cb-181">Pour résoudre ce problème, la classe <xref:System.Diagnostics.Contracts.Contract> fournit la méthode <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A>, qui permet d'utiliser une post-condition basée sur un paramètre `out`.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-181">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>

      ```csharp
      public void OutParam(out int x)
      {
          Contract.Ensures(Contract.ValueAtReturn(out x) == 3);
          x = 3;
      }
      ```

      <span data-ttu-id="1f1cb-182">Comme avec la méthode <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>, vous pouvez omettre le paramètre de type générique chaque fois que le compilateur est en mesure de déduire son type.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-182">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="1f1cb-183">Le module de réécriture de contrat remplace l'appel de méthode par la valeur du paramètre `out`.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-183">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="1f1cb-184">La méthode <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> peut apparaître uniquement dans des post-conditions.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-184">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="1f1cb-185">L’argument de la méthode doit être un paramètre `out` ou un champ d’un paramètre `out` de structure.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-185">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="1f1cb-186">Ce dernier est également utile pour faire référence aux champs dans la post-condition d'un constructeur de structure.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-186">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>

      > [!NOTE]
      > <span data-ttu-id="1f1cb-187">Actuellement, les outils d'analyse de contrat de code ne vérifient pas si les paramètres `out` sont correctement initialisés et ignorent leur mention dans la post-condition.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-187">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="1f1cb-188">Si, dans l'exemple précédent, la ligne après le contrat avait utilisé la valeur de `x` au lieu de lui assigner un nombre entier, un compilateur n'aurait donc pas généré l'erreur correspondante.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-188">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="1f1cb-189">Toutefois, dans une build où le symbole de préprocesseur CONTRACTS_FULL n’est pas défini (telle qu’une build de mise en production), le compilateur génère une erreur.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-189">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>

## <a name="invariants"></a><span data-ttu-id="1f1cb-190">Invariants</span><span class="sxs-lookup"><span data-stu-id="1f1cb-190">Invariants</span></span>

<span data-ttu-id="1f1cb-191">Les invariants d'objet sont des conditions qui doivent être remplies (true) pour chaque instance d'une classe dès que cet objet est visible par un client.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-191">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="1f1cb-192">Ils spécifient les conditions sous lesquelles l'objet est considéré comme étant correct.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-192">They express the conditions under which the object is considered to be correct.</span></span>

<span data-ttu-id="1f1cb-193">Les méthodes invariantes sont identifiées par l'attribut <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-193">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="1f1cb-194">Elles ne doivent contenir aucun code à l'exception d'une séquence d'appels à la méthode <xref:System.Diagnostics.Contracts.Contract.Invariant%2A>, chacun spécifiant un invariant individuel, comme indiqué dans l'exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-194">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>

```csharp
[ContractInvariantMethod]
protected void ObjectInvariant ()
{
    Contract.Invariant(this.y >= 0);
    Contract.Invariant(this.x > this.y);
    ...
}
```

<span data-ttu-id="1f1cb-195">Les invariants sont définis de façon conditionnelle par le symbole de préprocesseur CONTRACTS_FULL.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-195">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="1f1cb-196">Ils sont vérifiés au moment de l'exécution à la fin de chaque méthode publique.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-196">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="1f1cb-197">Si un invariant spécifie une méthode publique dans la même classe, la vérification d'invariant prévue normalement à la fin de cette méthode publique est désactivée.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-197">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="1f1cb-198">À la place, la vérification se produit uniquement à la fin de l'appel de méthode le plus à l'extérieur de cette classe.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-198">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="1f1cb-199">Cela se produit également si la classe est à nouveau entrée à cause d'un appel à une méthode sur une autre classe.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-199">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="1f1cb-200">Les invariants ne sont pas vérifiés pour un finaliseur d’objet et une <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-200">Invariants are not checked for an object finalizer and an <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>

<a name="usage_guidelines"></a>

## <a name="usage-guidelines"></a><span data-ttu-id="1f1cb-201">Instructions d’utilisation</span><span class="sxs-lookup"><span data-stu-id="1f1cb-201">Usage Guidelines</span></span>

### <a name="contract-ordering"></a><span data-ttu-id="1f1cb-202">Classement de contrat</span><span class="sxs-lookup"><span data-stu-id="1f1cb-202">Contract Ordering</span></span>

<span data-ttu-id="1f1cb-203">Le tableau suivant indique l'ordre des éléments à utiliser quand vous écrivez des contrats de méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-203">The following table shows the order of elements you should use when you write method contracts.</span></span>

|`If-then-throw statements`|<span data-ttu-id="1f1cb-204">Conditions préalables publiques à compatibilité descendante</span><span class="sxs-lookup"><span data-stu-id="1f1cb-204">Backward-compatible public preconditions</span></span>|
|-|-|
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="1f1cb-205">Toutes les conditions préalables publiques</span><span class="sxs-lookup"><span data-stu-id="1f1cb-205">All public preconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="1f1cb-206">Toutes les post-conditions standard publiques</span><span class="sxs-lookup"><span data-stu-id="1f1cb-206">All public (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="1f1cb-207">Toutes les post-conditions exceptionnelles publiques</span><span class="sxs-lookup"><span data-stu-id="1f1cb-207">All public exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="1f1cb-208">Toutes les post-conditions standard privées/internes</span><span class="sxs-lookup"><span data-stu-id="1f1cb-208">All private/internal (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="1f1cb-209">Toutes les post-conditions exceptionnelles privées/internes</span><span class="sxs-lookup"><span data-stu-id="1f1cb-209">All private/internal exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="1f1cb-210">Si vous utilisez des conditions préalables de style `if`-`then`-`throw` sans autres contrats, ajoutez un appel à <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> pour indiquer que toutes les vérifications if précédentes sont des conditions préalables.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-210">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|

<a name="purity"></a>

### <a name="purity"></a><span data-ttu-id="1f1cb-211">Pureté</span><span class="sxs-lookup"><span data-stu-id="1f1cb-211">Purity</span></span>

<span data-ttu-id="1f1cb-212">Toutes les méthodes appelées dans un contrat doivent être pures, c'est-à-dire qu'elles ne doivent pas mettre à jour un état préexistant.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-212">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="1f1cb-213">Une méthode pure peut modifier des objets qui ont été créés après l'entrée dans la méthode pure.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-213">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>

<span data-ttu-id="1f1cb-214">Les outils de contrat de code considèrent actuellement que les éléments de code suivants sont purs :</span><span class="sxs-lookup"><span data-stu-id="1f1cb-214">Code contract tools currently assume that the following code elements are pure:</span></span>

- <span data-ttu-id="1f1cb-215">Méthodes marquées avec l'attribut <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-215">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>

- <span data-ttu-id="1f1cb-216">Types marqués avec l'attribut <xref:System.Diagnostics.Contracts.PureAttribute> (cet attribut s'applique à toutes les méthodes du type).</span><span class="sxs-lookup"><span data-stu-id="1f1cb-216">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>

- <span data-ttu-id="1f1cb-217">Accesseurs get de propriété.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-217">Property get accessors.</span></span>

- <span data-ttu-id="1f1cb-218">Opérateurs (méthodes statiques dont le nom commence par « op », qui comportent un ou deux paramètres et dont le type de retour n’est pas void).</span><span class="sxs-lookup"><span data-stu-id="1f1cb-218">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>

- <span data-ttu-id="1f1cb-219">Méthodes dont le nom qualifié complet commence par « System.Diagnostics.Contracts.Contract », « System.String », « System.IO.Path » ou « System.Type ».</span><span class="sxs-lookup"><span data-stu-id="1f1cb-219">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>

- <span data-ttu-id="1f1cb-220">Les délégués appelés, à condition que le type délégué lui-même soit attribué avec l'attribut <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-220">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="1f1cb-221">Les types délégués <xref:System.Predicate%601?displayProperty=nameWithType> et <xref:System.Comparison%601?displayProperty=nameWithType> sont considérés comme purs.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-221">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>

<a name="visibility"></a>

### <a name="visibility"></a><span data-ttu-id="1f1cb-222">Visibilité</span><span class="sxs-lookup"><span data-stu-id="1f1cb-222">Visibility</span></span>

<span data-ttu-id="1f1cb-223">Tous les membres indiqués dans un contrat doivent être au moins aussi visibles que la méthode dans laquelle ils apparaissent.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-223">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="1f1cb-224">Par exemple, un champ privé ne peut pas être spécifié dans une condition préalable pour une méthode publique, car les clients ne peuvent pas valider un tel contrat avant d'appeler la méthode.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-224">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="1f1cb-225">Cependant, si le champ est marqué avec l'attribut <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, il est exempté de ces règles.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-225">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>

## <a name="example"></a><span data-ttu-id="1f1cb-226">Exemple</span><span class="sxs-lookup"><span data-stu-id="1f1cb-226">Example</span></span>

<span data-ttu-id="1f1cb-227">L'exemple suivant illustre l'utilisation des contrats de code.</span><span class="sxs-lookup"><span data-stu-id="1f1cb-227">The following example shows the use of code contracts.</span></span>

[!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
[!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
