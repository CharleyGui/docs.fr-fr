---
title: releaseHandleFailed (MDA)
ms.date: 03/30/2017
helpviewer_keywords:
- managed debugging assistants (MDAs), handles
- release handle failed
- CriticalHandle class, run-time errors
- releaseHandleFailed MDA
- ReleaseHandle method
- SafeHandle class, run-time errors
- MDAs (managed debugging assistants), handles
ms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51
author: mairaw
ms.author: mairaw
ms.openlocfilehash: ad580ecace07d3d6fdf206ff660dc4bac4bceb09
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64614292"
---
# <a name="releasehandlefailed-mda"></a><span data-ttu-id="77e0c-102">releaseHandleFailed (MDA)</span><span class="sxs-lookup"><span data-stu-id="77e0c-102">releaseHandleFailed MDA</span></span>
<span data-ttu-id="77e0c-103">L'Assistant Débogage managé (MDA) `releaseHandleFailed` est activé pour avertir les développeurs que la méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> d'une classe dérivée de <xref:System.Runtime.InteropServices.SafeHandle> ou de <xref:System.Runtime.InteropServices.CriticalHandle> retourne la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="77e0c-103">The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="77e0c-104">Symptômes</span><span class="sxs-lookup"><span data-stu-id="77e0c-104">Symptoms</span></span>  
 <span data-ttu-id="77e0c-105">Fuites de ressources ou de mémoire.</span><span class="sxs-lookup"><span data-stu-id="77e0c-105">Resource or memory leaks.</span></span>  <span data-ttu-id="77e0c-106">Si la méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> de la classe dérivée de <xref:System.Runtime.InteropServices.SafeHandle> ou de <xref:System.Runtime.InteropServices.CriticalHandle> échoue, il est possible que la ressource encapsulée par la classe n'ait pas pu être libérée ou nettoyée.</span><span class="sxs-lookup"><span data-stu-id="77e0c-106">If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="77e0c-107">Cause</span><span class="sxs-lookup"><span data-stu-id="77e0c-107">Cause</span></span>  
 <span data-ttu-id="77e0c-108">Les utilisateurs doivent fournir l'implémentation de la méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> s'ils créent des classes qui dérivent de <xref:System.Runtime.InteropServices.SafeHandle> ou de <xref:System.Runtime.InteropServices.CriticalHandle>. Les circonstances sont donc spécifiques à chaque ressource.</span><span class="sxs-lookup"><span data-stu-id="77e0c-108">Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource.</span></span> <span data-ttu-id="77e0c-109">Toutefois, il existe certaines exigences :</span><span class="sxs-lookup"><span data-stu-id="77e0c-109">However, the requirements are as follows:</span></span>  
  
- <span data-ttu-id="77e0c-110">Les types <xref:System.Runtime.InteropServices.SafeHandle> et <xref:System.Runtime.InteropServices.CriticalHandle> représentent des wrappers autour de ressources de processus essentielles.</span><span class="sxs-lookup"><span data-stu-id="77e0c-110"><xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources.</span></span> <span data-ttu-id="77e0c-111">Une fuite de mémoire finirait par rendre le processus inutilisable.</span><span class="sxs-lookup"><span data-stu-id="77e0c-111">A memory leak would make the process unusable over time.</span></span>  
  
- <span data-ttu-id="77e0c-112">La méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> ne doit pas échouer dans l'exécution de sa fonction.</span><span class="sxs-lookup"><span data-stu-id="77e0c-112">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function.</span></span> <span data-ttu-id="77e0c-113">Une ressource acquise par le processus ne peut être libérée qu’avec la méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="77e0c-113">Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it.</span></span> <span data-ttu-id="77e0c-114">C'est pourquoi un échec de la méthode entraîne une fuite de ressource.</span><span class="sxs-lookup"><span data-stu-id="77e0c-114">Therefore, failure implies resource leaks.</span></span>  
  
- <span data-ttu-id="77e0c-115">Un échec survenant pendant l’exécution de la méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> empêche la libération de la ressource, et constitue un bogue dans l’implémentation de la méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> elle-même.</span><span class="sxs-lookup"><span data-stu-id="77e0c-115">Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself.</span></span> <span data-ttu-id="77e0c-116">C'est au programmeur qu'il revient de s'assurer que le contrat est respecté, même si ce code appelle du code créé par un autre utilisateur pour exécuter sa fonction.</span><span class="sxs-lookup"><span data-stu-id="77e0c-116">It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="77e0c-117">Résolution</span><span class="sxs-lookup"><span data-stu-id="77e0c-117">Resolution</span></span>  
 <span data-ttu-id="77e0c-118">Passez en revue le code utilisant le type <xref:System.Runtime.InteropServices.SafeHandle> (ou <xref:System.Runtime.InteropServices.CriticalHandle>) spécifique qui a déclenché la notification de l’Assistant Débogage managé et recherchez les endroits où la valeur du handle brut est extraite de <xref:System.Runtime.InteropServices.SafeHandle> et copiée ailleurs.</span><span class="sxs-lookup"><span data-stu-id="77e0c-118">The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere.</span></span> <span data-ttu-id="77e0c-119">C'est la cause de la plupart des échecs dans les implémentations de <xref:System.Runtime.InteropServices.SafeHandle> ou de <xref:System.Runtime.InteropServices.CriticalHandle>, car le runtime n'effectue plus de suivi de l'utilisation de la valeur du handle brut.</span><span class="sxs-lookup"><span data-stu-id="77e0c-119">This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.</span></span> <span data-ttu-id="77e0c-120">Si la copie du handle brut est fermée par la suite, cela peut provoquer l'échec d'un appel ultérieur à <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, car c'est le même handle, désormais non valide, qui fait l'objet d'une tentative de fermeture.</span><span class="sxs-lookup"><span data-stu-id="77e0c-120">If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.</span></span>  
  
 <span data-ttu-id="77e0c-121">Une duplication de handle incorrecte peut se produire dans plusieurs cas :</span><span class="sxs-lookup"><span data-stu-id="77e0c-121">There are a number of ways in which incorrect handle duplication can occur:</span></span>  
  
- <span data-ttu-id="77e0c-122">Recherchez d'éventuels appels à la méthode <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="77e0c-122">Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.</span></span> <span data-ttu-id="77e0c-123">Les appels à cette méthode doivent être extrêmement rares et, s'il y en a, ils doivent être entourés d'appels aux méthodes <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> et <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span><span class="sxs-lookup"><span data-stu-id="77e0c-123">Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods.</span></span> <span data-ttu-id="77e0c-124">Ces dernières spécifient la partie du code où la valeur du handle brut peut être utilisée en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="77e0c-124">These latter methods specify the region of code in which the raw handle value may be safely used.</span></span> <span data-ttu-id="77e0c-125">En dehors de cette partie, ou si le nombre de références n'est jamais incrémenté initialement, la valeur du handle peut être invalidée à tout moment par un appel à <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> sur un autre thread.</span><span class="sxs-lookup"><span data-stu-id="77e0c-125">Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread.</span></span> <span data-ttu-id="77e0c-126">Dès que toutes les utilisations de <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> ont été localisées, vous devez suivre le chemin d’accès emprunté par le handle brut pour vous assurer qu’il n’est pas remis à un composant quelconque qui finira par appeler `CloseHandle` ou une autre méthode native de niveau inférieur qui libérera le handle.</span><span class="sxs-lookup"><span data-stu-id="77e0c-126">Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.</span></span>  
  
- <span data-ttu-id="77e0c-127">Assurez-vous que le code utilisé pour initialiser <xref:System.Runtime.InteropServices.SafeHandle> avec une valeur de handle brut valide est propriétaire du handle.</span><span class="sxs-lookup"><span data-stu-id="77e0c-127">Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle.</span></span> <span data-ttu-id="77e0c-128">Si vous formez <xref:System.Runtime.InteropServices.SafeHandle> autour d'un handle non détenu par votre code sans affecter au paramètre `ownsHandle` la valeur `false` dans le constructeur de base, alors <xref:System.Runtime.InteropServices.SafeHandle> et le véritable propriétaire du handle peuvent tenter de fermer le handle, ce qui se traduit par une erreur dans <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> si <xref:System.Runtime.InteropServices.SafeHandle> n'y accède pas en premier.</span><span class="sxs-lookup"><span data-stu-id="77e0c-128">If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.</span></span>  
  
- <span data-ttu-id="77e0c-129">Si <xref:System.Runtime.InteropServices.SafeHandle> est marshalé entre des domaines d’application, vérifiez si la dérivation de <xref:System.Runtime.InteropServices.SafeHandle> utilisée a été marquée comme étant sérialisable.</span><span class="sxs-lookup"><span data-stu-id="77e0c-129">When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable.</span></span> <span data-ttu-id="77e0c-130">Dans les rares cas où une classe dérivée de <xref:System.Runtime.InteropServices.SafeHandle> est devenue sérialisable, elle doit implémenter l’interface <xref:System.Runtime.Serialization.ISerializable> ou utiliser l’une des autres techniques permettant de contrôler manuellement le processus de sérialisation et de désérialisation.</span><span class="sxs-lookup"><span data-stu-id="77e0c-130">In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually.</span></span> <span data-ttu-id="77e0c-131">C'est indispensable dans la mesure où l'action de sérialisation par défaut consiste à créer un clone de bits de la valeur du handle brut incluse et se traduit donc par la présence de deux instances de <xref:System.Runtime.InteropServices.SafeHandle> qui se considèrent toutes deux propriétaires du même handle.</span><span class="sxs-lookup"><span data-stu-id="77e0c-131">This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle.</span></span> <span data-ttu-id="77e0c-132">Ces deux instances tenteront d'appeler <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> sur le même handle à un moment donné.</span><span class="sxs-lookup"><span data-stu-id="77e0c-132">Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point.</span></span> <span data-ttu-id="77e0c-133">Le deuxième <xref:System.Runtime.InteropServices.SafeHandle> à le faire échouera.</span><span class="sxs-lookup"><span data-stu-id="77e0c-133">The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail.</span></span> <span data-ttu-id="77e0c-134">Quand vous sérialisez <xref:System.Runtime.InteropServices.SafeHandle>, la solution appropriée consiste à appeler la fonction `DuplicateHandle` ou une fonction similaire pour votre type de handle natif pour effectuer une copie de handle légale distincte.</span><span class="sxs-lookup"><span data-stu-id="77e0c-134">The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy.</span></span> <span data-ttu-id="77e0c-135">Si votre type de handle ne prend pas en charge cette opération, le type <xref:System.Runtime.InteropServices.SafeHandle> qui l'encapsule ne peut pas devenir sérialisable.</span><span class="sxs-lookup"><span data-stu-id="77e0c-135">If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.</span></span>  
  
- <span data-ttu-id="77e0c-136">Il est parfois possible d’identifier la partie où un handle est fermé de façon anticipée (ce qui se traduit par un échec quand la méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> est finalement appelée). Pour cela, vous devez placer un point d’arrêt de débogueur sur la routine native utilisée pour libérer le handle, par exemple la fonction `CloseHandle`.</span><span class="sxs-lookup"><span data-stu-id="77e0c-136">It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function.</span></span> <span data-ttu-id="77e0c-137">Ce n'est pas toujours possible dans les scénarios de tests de contraintes, voire dans les tests fonctionnels de taille moyenne, en raison du trafic important généralement associé à de telles routines.</span><span class="sxs-lookup"><span data-stu-id="77e0c-137">This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.</span></span> <span data-ttu-id="77e0c-138">Il peut être utile d’instrumenter le code qui appelle la méthode de libération native, afin de capturer l’identité de l’appelant, ou éventuellement une trace de la pile complète, ainsi que la valeur du handle libéré.</span><span class="sxs-lookup"><span data-stu-id="77e0c-138">It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.</span></span>  <span data-ttu-id="77e0c-139">La valeur du handle peut être comparée à la valeur transmise par cet Assistant Débogage managé.</span><span class="sxs-lookup"><span data-stu-id="77e0c-139">The handle value can be compared with the value reported by this MDA.</span></span>  
  
- <span data-ttu-id="77e0c-140">Notez que certains types de handle natifs, et notamment tous les handles Win32 qui peuvent être libérés via la fonction `CloseHandle`, partagent le même espace de noms de handles.</span><span class="sxs-lookup"><span data-stu-id="77e0c-140">Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace.</span></span> <span data-ttu-id="77e0c-141">Une mise en production incorrecte d’un type de handle peut provoquer des problèmes avec un autre.</span><span class="sxs-lookup"><span data-stu-id="77e0c-141">An erroneous release of one handle type can cause problems with another.</span></span> <span data-ttu-id="77e0c-142">Par exemple, fermer accidentellement deux fois un handle d'événement Win32 peut provoquer la fermeture prématurée d'un handle de fichier apparemment non lié.</span><span class="sxs-lookup"><span data-stu-id="77e0c-142">For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.</span></span> <span data-ttu-id="77e0c-143">Cela se produit quand le handle est libéré et que la valeur du handle redevient disponible pour le suivi d’une autre ressource, parfois d’un autre type.</span><span class="sxs-lookup"><span data-stu-id="77e0c-143">This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.</span></span> <span data-ttu-id="77e0c-144">Si cette libération est suivie d'une deuxième libération erronée, le handle d'un thread non lié risque d'être invalidé.</span><span class="sxs-lookup"><span data-stu-id="77e0c-144">If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="77e0c-145">Effet sur le runtime</span><span class="sxs-lookup"><span data-stu-id="77e0c-145">Effect on the Runtime</span></span>  
 <span data-ttu-id="77e0c-146">Cet Assistant Débogage managé n'a aucun effet sur le CLR.</span><span class="sxs-lookup"><span data-stu-id="77e0c-146">This MDA has no effect on the CLR.</span></span>  
  
## <a name="output"></a><span data-ttu-id="77e0c-147">Sortie</span><span class="sxs-lookup"><span data-stu-id="77e0c-147">Output</span></span>  
 <span data-ttu-id="77e0c-148">Message indiquant qu’un <xref:System.Runtime.InteropServices.SafeHandle> ou un <xref:System.Runtime.InteropServices.CriticalHandle> n’a pas réussi à libérer correctement le handle.</span><span class="sxs-lookup"><span data-stu-id="77e0c-148">A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle.</span></span> <span data-ttu-id="77e0c-149">Exemple :</span><span class="sxs-lookup"><span data-stu-id="77e0c-149">For example:</span></span>  
  
```  
"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'   
failed to properly release the handle with value 0x0000BEEF. This   
usually indicates that the handle was released incorrectly via   
another means (such as extracting the handle using DangerousGetHandle   
and closing it directly or building another SafeHandle around it."  
```  
  
## <a name="configuration"></a><span data-ttu-id="77e0c-150">Configuration</span><span class="sxs-lookup"><span data-stu-id="77e0c-150">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <releaseHandleFailed/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="example"></a><span data-ttu-id="77e0c-151">Exemple</span><span class="sxs-lookup"><span data-stu-id="77e0c-151">Example</span></span>  
 <span data-ttu-id="77e0c-152">L'exemple de code suivant peut activer l'Assistant Débogage managé `releaseHandleFailed`.</span><span class="sxs-lookup"><span data-stu-id="77e0c-152">The following is a code example that can activate the `releaseHandleFailed` MDA.</span></span>  
  
```csharp
bool ReleaseHandle()  
{  
    // Calling the Win32 CloseHandle function to release the   
    // native handle wrapped by this SafeHandle. This method returns   
    // false on failure, but should only fail if the input is invalid   
    // (which should not happen here). The method specifically must not   
    // fail simply because of lack of resources or other transient   
    // failures beyond the user’s control. That would make it unacceptable   
    // to call CloseHandle as part of the implementation of this method.  
    return CloseHandle(handle);  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="77e0c-153">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="77e0c-153">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="77e0c-154">Diagnostic d’erreurs avec les Assistants Débogage managé</span><span class="sxs-lookup"><span data-stu-id="77e0c-154">Diagnosing Errors with Managed Debugging Assistants</span></span>](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)
- [<span data-ttu-id="77e0c-155">Marshaling d'interopérabilité</span><span class="sxs-lookup"><span data-stu-id="77e0c-155">Interop Marshaling</span></span>](../../../docs/framework/interop/interop-marshaling.md)
