---
title: Remplissage d'un DataSet à partir d'un DataAdapter
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3fa0ac7d-e266-4954-bfac-3fbe2f913153
ms.openlocfilehash: 88905f0ef735aef742c0279ac86b640d8a9b9b0e
ms.sourcegitcommit: c4e9d05644c9cb89de5ce6002723de107ea2e2c4
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/19/2019
ms.locfileid: "65877361"
---
# <a name="populating-a-dataset-from-a-dataadapter"></a><span data-ttu-id="ddcf3-102">Remplissage d'un DataSet à partir d'un DataAdapter</span><span class="sxs-lookup"><span data-stu-id="ddcf3-102">Populating a DataSet from a DataAdapter</span></span>
<span data-ttu-id="ddcf3-103">ADO.NET <xref:System.Data.DataSet> est une représentation résidente en mémoire de données qui fournit un modèle de programmation relationnel cohérent indépendant de la source de données.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-103">The ADO.NET <xref:System.Data.DataSet> is a memory-resident representation of data that provides a consistent relational programming model independent of the data source.</span></span> <span data-ttu-id="ddcf3-104">Le `DataSet` représente un jeu de données complet qui comprend des tables, des contraintes et des relations entre les tables.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-104">The `DataSet` represents a complete set of data that includes tables, constraints, and relationships among the tables.</span></span> <span data-ttu-id="ddcf3-105">Étant donné que le `DataSet` est indépendant de la source de données, le `DataSet` peut inclure des données locales par rapport à l'application ainsi que des données provenant de plusieurs sources.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-105">Because the `DataSet` is independent of the data source, a `DataSet` can include data local to the application, and data from multiple data sources.</span></span> <span data-ttu-id="ddcf3-106">L'interaction avec les sources de données existantes est contrôlée par le `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-106">Interaction with existing data sources is controlled through the `DataAdapter`.</span></span>  
  
 <span data-ttu-id="ddcf3-107">La propriété `SelectCommand` du `DataAdapter` est un objet `Command` qui extrait les données de la source de données.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-107">The `SelectCommand` property of the `DataAdapter` is a `Command` object that retrieves data from the data source.</span></span> <span data-ttu-id="ddcf3-108">Les propriétés `InsertCommand`, `UpdateCommand`et `DeleteCommand` du `DataAdapter` sont des objets `Command` qui gèrent les mises à jour des données dans la source de données conformément aux modifications apportées dans le `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-108">The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties of the `DataAdapter` are `Command` objects that manage updates to the data in the data source according to modifications made to the data in the `DataSet`.</span></span> <span data-ttu-id="ddcf3-109">Ces propriétés sont abordées plus en détail dans [la mise à jour des Sources de données avec des DataAdapters](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span><span class="sxs-lookup"><span data-stu-id="ddcf3-109">These properties are covered in more detail in [Updating Data Sources with DataAdapters](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="ddcf3-110">La méthode `Fill` du `DataAdapter` sert à remplir un `DataSet` avec les résultats de la `SelectCommand` du `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-110">The `Fill` method of the `DataAdapter` is used to populate a `DataSet` with the results of the `SelectCommand` of the `DataAdapter`.</span></span> <span data-ttu-id="ddcf3-111">La méthode`Fill` prend comme arguments un `DataSet` à remplir, ainsi qu'un objet `DataTable` , ou le nom du `DataTable` à remplir avec les lignes retournées par `SelectCommand`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-111">`Fill` takes as its arguments a `DataSet` to be populated, and a `DataTable` object, or the name of the `DataTable` to be filled with the rows returned from the `SelectCommand`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ddcf3-112">L'utilisation du `DataAdapter` pour extraire une table dans son intégralité prend du temps, particulièrement si la table contient de nombreuses lignes.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-112">Using the `DataAdapter` to retrieve all of a table takes time, especially if there are many rows in the table.</span></span> <span data-ttu-id="ddcf3-113">Cela vient du fait qu'accéder à la base de données, localiser et traiter les données, puis transférer les données au client prend du temps.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-113">This is because accessing the database, locating and processing the data, and then transferring the data to the client is time-consuming.</span></span> <span data-ttu-id="ddcf3-114">L'extraction de l'intégralité de la table vers le client verrouille également toutes les lignes sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-114">Pulling all of the table to the client also locks all of the rows on the server.</span></span> <span data-ttu-id="ddcf3-115">Pour améliorer les performances, vous pouvez utiliser la clause `WHERE` pour réduire drastiquement le nombre de lignes retournées au client.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-115">To improve performance, you can use the `WHERE` clause to greatly reduce the number of rows returned to the client.</span></span> <span data-ttu-id="ddcf3-116">Vous pouvez également réduire la quantité de données retournées au client en répertoriant de façon explicite uniquement les colonnes requises dans l'instruction `SELECT` .</span><span class="sxs-lookup"><span data-stu-id="ddcf3-116">You can also reduce the amount of data returned to the client by only explicitly listing required columns in the `SELECT` statement.</span></span> <span data-ttu-id="ddcf3-117">Une autre solution de contournement efficace consiste à extraire les lignes par lots, par exemple plusieurs centaines de lignes à la fois, et à extraire le lot suivant uniquement lorsque le client a terminé le traitement du lot actuel.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-117">Another good workaround is to retrieve the rows in batches (such as several hundred rows at a time) and only retrieve the next batch when the client is finished with the current batch.</span></span>  
  
 <span data-ttu-id="ddcf3-118">La méthode `Fill` utilise l'objet `DataReader` de manière implicite pour retourner les noms et les types de colonnes utilisés pour créer les tables du `DataSet`ainsi que les données pour remplir les lignes des tables du `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-118">The `Fill` method uses the `DataReader` object implicitly to return the column names and types that are used to create the tables in the `DataSet`, and the data to populate the rows of the tables in the `DataSet`.</span></span> <span data-ttu-id="ddcf3-119">Les tables et les colonnes ne sont créées que si elles n'existent pas encore ; sinon `Fill` utilise le schéma `DataSet` existant.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-119">Tables and columns are only created if they do not already exist; otherwise `Fill` uses the existing `DataSet` schema.</span></span> <span data-ttu-id="ddcf3-120">Types de colonnes sont créées en tant que types .NET Framework en fonction des tableaux dans [mappages de Type de données dans ADO.NET](../../../../docs/framework/data/adonet/data-type-mappings-in-ado-net.md).</span><span class="sxs-lookup"><span data-stu-id="ddcf3-120">Column types are created as .NET Framework types according to the tables in [Data Type Mappings in ADO.NET](../../../../docs/framework/data/adonet/data-type-mappings-in-ado-net.md).</span></span> <span data-ttu-id="ddcf3-121">Les clés primaires ne sont pas créées, sauf si elles existent dans la source de données et que `DataAdapter`**.**`MissingSchemaAction`</span><span class="sxs-lookup"><span data-stu-id="ddcf3-121">Primary keys are not created unless they exist in the data source and `DataAdapter`**.**`MissingSchemaAction`</span></span> <span data-ttu-id="ddcf3-122">a la valeur `MissingSchemaAction`**.**`AddWithKey`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-122">is set to `MissingSchemaAction`**.**`AddWithKey`.</span></span> <span data-ttu-id="ddcf3-123">Si `Fill` détecte qu'il existe une clé primaire pour une table, elle remplace les données du `DataSet` par celles de la source de données pour les lignes dont les valeurs de colonne de clé primaire correspondent à celles de la ligne retournée par la source de données.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-123">If `Fill` finds that a primary key exists for a table, it will overwrite data in the `DataSet` with data from the data source for rows where the primary key column values match those of the row returned from the data source.</span></span> <span data-ttu-id="ddcf3-124">Si aucune clé primaire n'est trouvée, les données sont ajoutées à la table dans le `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-124">If no primary key is found, the data is appended to the tables in the `DataSet`.</span></span> <span data-ttu-id="ddcf3-125">`Fill` utilise tous les mappages qui peuvent exister lorsque vous renseignez la `DataSet` (consultez [DataAdapter mappages DataTable et DataColumn](../../../../docs/framework/data/adonet/dataadapter-datatable-and-datacolumn-mappings.md)).</span><span class="sxs-lookup"><span data-stu-id="ddcf3-125">`Fill` uses any mappings that may exist when you populate the `DataSet` (see [DataAdapter DataTable and DataColumn Mappings](../../../../docs/framework/data/adonet/dataadapter-datatable-and-datacolumn-mappings.md)).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ddcf3-126">Si `SelectCommand` retourne les résultats d'une jointure externe, le `DataAdapter` ne définit pas de valeur `PrimaryKey` pour le `DataTable`obtenu.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-126">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a `PrimaryKey` value for the resulting `DataTable`.</span></span> <span data-ttu-id="ddcf3-127">Vous devez définir vous-même la `PrimaryKey` pour garantir une résolution correcte des lignes dupliquées.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-127">You must define the `PrimaryKey` yourself to make sure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="ddcf3-128">Pour plus d’informations, consultez [définition des clés primaires](../../../../docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span><span class="sxs-lookup"><span data-stu-id="ddcf3-128">For more information, see [Defining Primary Keys](../../../../docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
 <span data-ttu-id="ddcf3-129">L'exemple de code suivant crée une instance d'un objet <xref:System.Data.SqlClient.SqlDataAdapter> qui utilise un objet <xref:System.Data.SqlClient.SqlConnection> sur la base de données `Northwind` Microsoft SQL Server et remplit un objet <xref:System.Data.DataTable> dans un `DataSet` avec la liste des clients.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-129">The following code example creates an instance of a <xref:System.Data.SqlClient.SqlDataAdapter> that uses a <xref:System.Data.SqlClient.SqlConnection> to the Microsoft SQL Server `Northwind` database and populates a <xref:System.Data.DataTable> in a `DataSet` with the list of customers.</span></span> <span data-ttu-id="ddcf3-130">L'instruction SQL et les arguments <xref:System.Data.SqlClient.SqlConnection> passés au constructeur <xref:System.Data.SqlClient.SqlDataAdapter> sont utilisés pour créer la propriété <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> de l'objet <xref:System.Data.SqlClient.SqlDataAdapter>.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-130">The SQL statement and <xref:System.Data.SqlClient.SqlConnection> arguments passed to the <xref:System.Data.SqlClient.SqlDataAdapter> constructor are used to create the <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter>.</span></span>  
  
## <a name="example"></a><span data-ttu-id="ddcf3-131">Exemple</span><span class="sxs-lookup"><span data-stu-id="ddcf3-131">Example</span></span>  
  
```vb  
' Assumes that connection is a valid SqlConnection object.  
Dim queryString As String = _  
  "SELECT CustomerID, CompanyName FROM dbo.Customers"  
Dim adapter As SqlDataAdapter = New SqlDataAdapter( _  
  queryString, connection)  
  
Dim customers As DataSet = New DataSet  
adapter.Fill(customers, "Customers")  
```  
  
```csharp  
// Assumes that connection is a valid SqlConnection object.  
string queryString =   
  "SELECT CustomerID, CompanyName FROM dbo.Customers";  
SqlDataAdapter adapter = new SqlDataAdapter(queryString, connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
```  
  
> [!NOTE]
>  <span data-ttu-id="ddcf3-132">Ce code n'ouvre pas et ne ferme pas la `Connection`de manière explicite.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-132">The code shown in this example does not explicitly open and close the `Connection`.</span></span> <span data-ttu-id="ddcf3-133">La méthode `Fill` ouvre implicitement la `Connection` que le `DataAdapter` utilise si la connexion n'est pas déjà ouverte.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-133">The `Fill` method implicitly opens the `Connection` that the `DataAdapter` is using if it finds that the connection is not already open.</span></span> <span data-ttu-id="ddcf3-134">Si `Fill` a ouvert la connexion, `Fill` la ferme aussi lorsque son exécution est terminée.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-134">If `Fill` opened the connection, it also closes the connection when `Fill` is finished.</span></span> <span data-ttu-id="ddcf3-135">Cela peut simplifier votre code lorsque vous ne traitez qu'une seule opération comme `Fill` ou `Update`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-135">This can simplify your code when you deal with a single operation such as a `Fill` or an `Update`.</span></span> <span data-ttu-id="ddcf3-136">Cependant, si vous effectuez plusieurs opérations qui nécessitent une connexion ouverte, vous pouvez améliorer les performances de votre application en appelant de manière explicite la méthode `Open` de `Connection`, en effectuant les opérations sur la source de données, puis en appelant la méthode `Close` de `Connection`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-136">However, if you are performing multiple operations that require an open connection, you can improve the performance of your application by explicitly calling the `Open` method of the `Connection`, performing the operations against the data source, and then calling the `Close` method of the `Connection`.</span></span> <span data-ttu-id="ddcf3-137">Vous devez tenter de réduire autant que possible le temps d'ouverture des connexions à la source de données pour libérer des ressources afin que d'autres applications clientes puissent les utiliser.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-137">You should try to keep connections to the data source open as briefly as possible to free resources for use by other client applications.</span></span>  
  
## <a name="multiple-result-sets"></a><span data-ttu-id="ddcf3-138">Jeux de résultats multiples</span><span class="sxs-lookup"><span data-stu-id="ddcf3-138">Multiple Result Sets</span></span>  
 <span data-ttu-id="ddcf3-139">Si le `DataAdapter` détecte plusieurs jeux de résultats, il crée plusieurs tables dans le `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-139">If the `DataAdapter` encounters multiple result sets, it creates multiple tables in the `DataSet`.</span></span> <span data-ttu-id="ddcf3-140">Les tables reçoivent un nom incrémentiel par défaut de Table*N*, commençant par « Table » pour Table0.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-140">The tables are given an incremental default name of Table*N*, starting with "Table" for Table0.</span></span> <span data-ttu-id="ddcf3-141">Si un nom de table est passé comme argument à la méthode `Fill` , les tables reçoivent le nom incrémentiel par défaut TableName*N*, commençant par « TableName » pour TableName0.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-141">If a table name is passed as an argument to the `Fill` method, the tables are given an incremental default name of TableName*N*, starting with "TableName" for TableName0.</span></span>  
  
## <a name="populating-a-dataset-from-multiple-dataadapters"></a><span data-ttu-id="ddcf3-142">Remplissage d'un DataSet à partir de plusieurs DataAdapters</span><span class="sxs-lookup"><span data-stu-id="ddcf3-142">Populating a DataSet from Multiple DataAdapters</span></span>  
 <span data-ttu-id="ddcf3-143">Un nombre quelconque de `DataAdapter` objets peuvent être utilisés avec un `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-143">Any number of `DataAdapter` objects can be used with a `DataSet`.</span></span> <span data-ttu-id="ddcf3-144">Chaque `DataAdapter` peut être utilisé pour remplir un ou plusieurs objets `DataTable` et répercuter les mises à jour dans la source de données concernée.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-144">Each `DataAdapter` can be used to fill one or more `DataTable` objects and resolve updates back to the relevant data source.</span></span> <span data-ttu-id="ddcf3-145">Les objets`DataRelation` et `Constraint` peuvent être ajoutés localement au `DataSet` , ce qui vous permet de relier des données provenant de sources de données hétérogènes.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-145">`DataRelation` and `Constraint` objects can be added to the `DataSet` locally, which enables you to relate data from dissimilar data sources.</span></span> <span data-ttu-id="ddcf3-146">Par exemple, un `DataSet` peut contenir des données provenant d'une base de données Microsoft SQL Server, d'une base de données IBM DB2 exposée via OLE DB et d'une source de données qui diffuse le XML en continu.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-146">For example, a `DataSet` can contain data from a Microsoft SQL Server database, an IBM DB2 database exposed through OLE DB, and a data source that streams XML.</span></span> <span data-ttu-id="ddcf3-147">Un ou plusieurs objets `DataAdapter` peuvent gérer la communication vers chaque source de données.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-147">One or more `DataAdapter` objects can handle communication to each data source.</span></span>  
  
### <a name="example"></a><span data-ttu-id="ddcf3-148">Exemple</span><span class="sxs-lookup"><span data-stu-id="ddcf3-148">Example</span></span>  
 <span data-ttu-id="ddcf3-149">L'exemple de code suivant remplit une liste de clients provenant de la base de données `Northwind` sur Microsoft SQL Server, ainsi qu'une liste de commandes provenant de la base de données `Northwind` stockée dans Microsoft Access 2000.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-149">The following code example populates a list of customers from the `Northwind` database on Microsoft SQL Server, and a list of orders from the `Northwind` database stored in Microsoft Access 2000.</span></span> <span data-ttu-id="ddcf3-150">Les tables remplies sont reliées par un `DataRelation`et la liste des clients est ensuite affichée avec les commandes du client concerné.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-150">The filled tables are related with a `DataRelation`, and the list of customers is then displayed with the orders for that customer.</span></span> <span data-ttu-id="ddcf3-151">Pour plus d’informations sur `DataRelation` , consultez [Ajout de DataRelations](../../../../docs/framework/data/adonet/dataset-datatable-dataview/adding-datarelations.md) et [DataRelations accédant](../../../../docs/framework/data/adonet/dataset-datatable-dataview/navigating-datarelations.md).</span><span class="sxs-lookup"><span data-stu-id="ddcf3-151">For more information about `DataRelation` objects, see [Adding DataRelations](../../../../docs/framework/data/adonet/dataset-datatable-dataview/adding-datarelations.md) and [Navigating DataRelations](../../../../docs/framework/data/adonet/dataset-datatable-dataview/navigating-datarelations.md).</span></span>  
  
```vb  
' Assumes that customerConnection is a valid SqlConnection object.  
' Assumes that orderConnection is a valid OleDbConnection object.  
Dim custAdapter As SqlDataAdapter = New SqlDataAdapter( _  
  "SELECT * FROM dbo.Customers", customerConnection)  
  
Dim ordAdapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SELECT * FROM Orders", orderConnection)  
  
Dim customerOrders As DataSet = New DataSet()  
custAdapter.Fill(customerOrders, "Customers")  
ordAdapter.Fill(customerOrders, "Orders")  
  
Dim relation As DataRelation = _  
  customerOrders.Relations.Add("CustOrders", _  
  customerOrders.Tables("Customers").Columns("CustomerID"), _   
  customerOrders.Tables("Orders").Columns("CustomerID"))  
  
Dim pRow, cRow As DataRow  
For Each pRow In customerOrders.Tables("Customers").Rows  
  Console.WriteLine(pRow("CustomerID").ToString())  
  
  For Each cRow In pRow.GetChildRows(relation)  
    Console.WriteLine(vbTab & cRow("OrderID").ToString())  
  Next  
Next  
```  
  
```csharp  
// Assumes that customerConnection is a valid SqlConnection object.  
// Assumes that orderConnection is a valid OleDbConnection object.  
SqlDataAdapter custAdapter = new SqlDataAdapter(  
  "SELECT * FROM dbo.Customers", customerConnection);  
OleDbDataAdapter ordAdapter = new OleDbDataAdapter(  
  "SELECT * FROM Orders", orderConnection);  
  
DataSet customerOrders = new DataSet();  
  
custAdapter.Fill(customerOrders, "Customers");  
ordAdapter.Fill(customerOrders, "Orders");  
  
DataRelation relation = customerOrders.Relations.Add("CustOrders",  
  customerOrders.Tables["Customers"].Columns["CustomerID"],  
  customerOrders.Tables["Orders"].Columns["CustomerID"]);  
  
foreach (DataRow pRow in customerOrders.Tables["Customers"].Rows)  
{  
  Console.WriteLine(pRow["CustomerID"]);  
   foreach (DataRow cRow in pRow.GetChildRows(relation))  
    Console.WriteLine("\t" + cRow["OrderID"]);  
}  
```  
  
## <a name="sql-server-decimal-type"></a><span data-ttu-id="ddcf3-152">Type décimal SQL Server</span><span class="sxs-lookup"><span data-stu-id="ddcf3-152">SQL Server Decimal Type</span></span>  
 <span data-ttu-id="ddcf3-153">Par défaut, le `DataSet` stocke les données à l’aide des types de données .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-153">By default, the `DataSet` stores data by using .NET Framework data types.</span></span> <span data-ttu-id="ddcf3-154">Pour la plupart des applications, ils fournissent une représentation pratique des informations de la source de données.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-154">For most applications, these provide a convenient representation of data source information.</span></span> <span data-ttu-id="ddcf3-155">Cette représentation peut néanmoins poser un problème lorsque le type de données dans la source de données est un decimal SQL Server ou un type de données numérique.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-155">However, this representation may cause a problem when the data type in the data source is a SQL Server decimal or numeric data type.</span></span> <span data-ttu-id="ddcf3-156">Le .NET Framework `decimal` type de données autorise un maximum de 28 chiffres significatifs, tandis que le serveur SQL Server `decimal` type de données autorise 38 chiffres significatifs.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-156">The .NET Framework `decimal` data type allows a maximum of 28 significant digits, whereas the SQL Server `decimal` data type allows 38 significant digits.</span></span> <span data-ttu-id="ddcf3-157">Si `SqlDataAdapter` détermine pendant une opération `Fill` que la précision d'un champ `decimal` SQL Server est supérieure à 28 caractères, la ligne actuelle n'est pas ajoutée au `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-157">If the `SqlDataAdapter` determines during a `Fill` operation that the precision of a SQL Server `decimal` field is larger than 28 characters, the current row is not added to the `DataTable`.</span></span> <span data-ttu-id="ddcf3-158">Au lieu de cela, l'événement `FillError` se produit, ce qui vous permet de déterminer une éventuelle perte de précision et de répondre de manière appropriée.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-158">Instead the `FillError` event occurs, which enables you to determine whether a loss of precision will occur, and respond appropriately.</span></span> <span data-ttu-id="ddcf3-159">Pour plus d’informations sur la `FillError` événement, consultez [gestion des événements DataAdapter](../../../../docs/framework/data/adonet/handling-dataadapter-events.md).</span><span class="sxs-lookup"><span data-stu-id="ddcf3-159">For more information about the `FillError` event, see [Handling DataAdapter Events](../../../../docs/framework/data/adonet/handling-dataadapter-events.md).</span></span> <span data-ttu-id="ddcf3-160">Pour obtenir la valeur `decimal` SQL Server, vous pouvez également utiliser un objet <xref:System.Data.SqlClient.SqlDataReader> et appeler la méthode <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> .</span><span class="sxs-lookup"><span data-stu-id="ddcf3-160">To get the SQL Server `decimal` value, you can also use a <xref:System.Data.SqlClient.SqlDataReader> object and call the <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> method.</span></span>  
  
 <span data-ttu-id="ddcf3-161">ADO.NET 2.0 a introduit meilleure prise en charge <xref:System.Data.SqlTypes> dans le `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-161">ADO.NET 2.0 introduced enhanced support for <xref:System.Data.SqlTypes> in the `DataSet`.</span></span> <span data-ttu-id="ddcf3-162">Pour plus d'informations, consultez [SqlTypes and the DataSet](../../../../docs/framework/data/adonet/sql/sqltypes-and-the-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="ddcf3-162">For more information, see [SqlTypes and the DataSet](../../../../docs/framework/data/adonet/sql/sqltypes-and-the-dataset.md).</span></span>  
  
## <a name="ole-db-chapters"></a><span data-ttu-id="ddcf3-163">Chapitres OLE DB</span><span class="sxs-lookup"><span data-stu-id="ddcf3-163">OLE DB Chapters</span></span>  
 <span data-ttu-id="ddcf3-164">Les jeux de lignes hiérarchiques ou chapitres (`DBTYPE_HCHAPTER` de type OLE DB, `adChapter` de type ADO) peuvent être utilisés pour remplir le contenu d'un `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-164">Hierarchical rowsets, or chapters (OLE DB type `DBTYPE_HCHAPTER`, ADO type `adChapter`) can be used to fill the contents of a `DataSet`.</span></span> <span data-ttu-id="ddcf3-165">Lorsque l'objet <xref:System.Data.OleDb.OleDbDataAdapter> rencontre une colonne chapitre pendant une opération `Fill` , un `DataTable` est créé pour cette colonne et la table correspondante est remplie avec les colonnes et les lignes provenant du chapitre.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-165">When the <xref:System.Data.OleDb.OleDbDataAdapter> encounters a chaptered column during a `Fill` operation, a `DataTable` is created for the chaptered column, and that table is filled with the columns and rows from the chapter.</span></span> <span data-ttu-id="ddcf3-166">La table créée pour la colonne chapitre est nommée à l'aide des noms de la table parente et de la colonne chapitre sous la forme «*ParentTableNameChapteredColumnName*».</span><span class="sxs-lookup"><span data-stu-id="ddcf3-166">The table created for the chaptered column is named by using both the parent table name and the chaptered column name in the form "*ParentTableNameChapteredColumnName*".</span></span> <span data-ttu-id="ddcf3-167">Si une table correspondant au nom de la colonne chapitre existe déjà dans le `DataSet` , la table actuelle est remplie avec les données du chapitre.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-167">If a table already exists in the `DataSet` that matches the name of the chaptered column, the current table is filled with the chapter data.</span></span> <span data-ttu-id="ddcf3-168">S'il n'y a pas de colonne, dans une table existante, qui corresponde à une colonne trouvée dans le chapitre, une nouvelle colonne est ajoutée.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-168">If there is no column in an existing table that matches a column found in the chapter, a new column is added.</span></span>  
  
 <span data-ttu-id="ddcf3-169">Avant que les tables du `DataSet` ne soient remplies avec les données des colonnes chapitres, une relation est créée entre les tables parent et enfant du jeu de lignes hiérarchique par l'ajout d'une colonne d'entiers aux deux tables, la définition de l'incrémentation automatique de la colonne parente et la création d'un `DataRelation` à l'aide des colonnes ajoutées des deux tables.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-169">Before the tables in the `DataSet` are filled with the data in the chaptered columns, a relation is created between the parent and child tables of the hierarchical rowset by adding an integer column to both the parent and child table, setting the parent column to auto-increment, and creating a `DataRelation` using the added columns from both tables.</span></span> <span data-ttu-id="ddcf3-170">La relation ajoutée est nommée à l'aide des noms de table parente et de colonne chapitre sous la forme «*ParentTableNameChapterColumnName*».</span><span class="sxs-lookup"><span data-stu-id="ddcf3-170">The added relation is named by using the parent table and chapter column names in the form "*ParentTableNameChapterColumnName*".</span></span>  
  
 <span data-ttu-id="ddcf3-171">Notez que la colonne associée n'existe que dans le `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-171">Note that the related column only exists in the `DataSet`.</span></span> <span data-ttu-id="ddcf3-172">Les remplissages suivants à partir de la source de données peuvent engendrer l'ajout de nouvelles lignes aux tables plutôt que la fusion des modifications dans les lignes existantes.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-172">Subsequent fills from the data source can cause new rows to be added to the tables instead of changes being merged into existing rows.</span></span>  
  
 <span data-ttu-id="ddcf3-173">Notez par ailleurs que si vous utilisez la surcharge `DataAdapter.Fill` qui prend un `DataTable`, seule cette table sera remplie.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-173">Note also that, if you use the `DataAdapter.Fill` overload that takes a `DataTable`, only that table will be filled.</span></span> <span data-ttu-id="ddcf3-174">Une colonne entier auto-incrémentée sera toujours ajoutée à la table mais aucune table enfant ne sera créée ni remplie et aucune relation ne sera créée.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-174">An auto-incrementing integer column will still be added to the table, but no child table will be created or filled, and no relation will be created.</span></span>  
  
 <span data-ttu-id="ddcf3-175">L'exemple suivant utilise le fournisseur MSDataShape pour générer une colonne chapitre de commandes pour chaque client d'une liste de clients.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-175">The following example uses the MSDataShape Provider to generate a chapter column of orders for each customer in a list of customers.</span></span> <span data-ttu-id="ddcf3-176">Un `DataSet` est alors rempli avec les données.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-176">A `DataSet` is then filled with the data.</span></span>  
  
```vb  
Using connection As OleDbConnection = New OleDbConnection( _  
  "Provider=MSDataShape;Data Provider=SQLOLEDB;" & _  
  "Data Source=(local);Integrated " & _  
  "Security=SSPI;Initial Catalog=northwind")  
  
Dim adapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SHAPE {SELECT CustomerID, CompanyName FROM Customers} " & _  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " & _  
  "RELATE CustomerID TO CustomerID)", connection)  
  
Dim customers As DataSet = New DataSet()  
  
adapter.Fill(customers, "Customers")  
End Using  
```  
  
```csharp  
using (OleDbConnection connection = new OleDbConnection("Provider=MSDataShape;Data Provider=SQLOLEDB;" +  
  "Data Source=(local);Integrated Security=SSPI;Initial Catalog=northwind"))  
{  
OleDbDataAdapter adapter = new OleDbDataAdapter("SHAPE {SELECT CustomerID, CompanyName FROM Customers} " +  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " +  
  "RELATE CustomerID TO CustomerID)", connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
}  
```  
  
 <span data-ttu-id="ddcf3-177">Une fois l'opération `Fill` terminée, le `DataSet` contient deux tables : `Customers` et `CustomersOrders`, où `CustomersOrders` représente la colonne chapitre.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-177">When the `Fill` operation is complete, the `DataSet` contains two tables: `Customers` and `CustomersOrders`, where `CustomersOrders` represents the chaptered column.</span></span> <span data-ttu-id="ddcf3-178">Une colonne supplémentaire nommée `Orders` est ajoutée à la table `Customers` et une colonne supplémentaire nommée `CustomersOrders` est ajoutée à la table `CustomersOrders` .</span><span class="sxs-lookup"><span data-stu-id="ddcf3-178">An additional column named `Orders` is added to the `Customers` table, and an additional column named `CustomersOrders` is added to the `CustomersOrders` table.</span></span> <span data-ttu-id="ddcf3-179">L'incrémentation automatique de la colonne `Orders` dans la table `Customers` est définie.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-179">The `Orders` column in the `Customers` table is set to auto-increment.</span></span> <span data-ttu-id="ddcf3-180">Un `DataRelation`, `CustomersOrders`, est créé avec les colonnes ajoutées aux tables, `Customers` étant la table parente.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-180">A `DataRelation`, `CustomersOrders`, is created by using the columns that were added to the tables with `Customers` as the parent table.</span></span> <span data-ttu-id="ddcf3-181">Les tableaux suivants présentent certains résultats de l'exemple.</span><span class="sxs-lookup"><span data-stu-id="ddcf3-181">The following tables show some sample results.</span></span>  
  
### <a name="tablename-customers"></a><span data-ttu-id="ddcf3-182">TableName : Customers</span><span class="sxs-lookup"><span data-stu-id="ddcf3-182">TableName: Customers</span></span>  
  
|<span data-ttu-id="ddcf3-183">CustomerID</span><span class="sxs-lookup"><span data-stu-id="ddcf3-183">CustomerID</span></span>|<span data-ttu-id="ddcf3-184">CompanyName</span><span class="sxs-lookup"><span data-stu-id="ddcf3-184">CompanyName</span></span>|<span data-ttu-id="ddcf3-185">Orders</span><span class="sxs-lookup"><span data-stu-id="ddcf3-185">Orders</span></span>|  
|----------------|-----------------|------------|  
|<span data-ttu-id="ddcf3-186">ALFKI</span><span class="sxs-lookup"><span data-stu-id="ddcf3-186">ALFKI</span></span>|<span data-ttu-id="ddcf3-187">Alfreds Futterkiste</span><span class="sxs-lookup"><span data-stu-id="ddcf3-187">Alfreds Futterkiste</span></span>|<span data-ttu-id="ddcf3-188">0</span><span class="sxs-lookup"><span data-stu-id="ddcf3-188">0</span></span>|  
|<span data-ttu-id="ddcf3-189">ANATR</span><span class="sxs-lookup"><span data-stu-id="ddcf3-189">ANATR</span></span>|<span data-ttu-id="ddcf3-190">Ana Trujillo Emparedados y helados</span><span class="sxs-lookup"><span data-stu-id="ddcf3-190">Ana Trujillo Emparedados y helados</span></span>|<span data-ttu-id="ddcf3-191">1</span><span class="sxs-lookup"><span data-stu-id="ddcf3-191">1</span></span>|  
  
### <a name="tablename-customersorders"></a><span data-ttu-id="ddcf3-192">TableName : CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="ddcf3-192">TableName: CustomersOrders</span></span>  
  
|<span data-ttu-id="ddcf3-193">CustomerID</span><span class="sxs-lookup"><span data-stu-id="ddcf3-193">CustomerID</span></span>|<span data-ttu-id="ddcf3-194">OrderID</span><span class="sxs-lookup"><span data-stu-id="ddcf3-194">OrderID</span></span>|<span data-ttu-id="ddcf3-195">CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="ddcf3-195">CustomersOrders</span></span>|  
|----------------|-------------|---------------------|  
|<span data-ttu-id="ddcf3-196">ALFKI</span><span class="sxs-lookup"><span data-stu-id="ddcf3-196">ALFKI</span></span>|<span data-ttu-id="ddcf3-197">10643</span><span class="sxs-lookup"><span data-stu-id="ddcf3-197">10643</span></span>|<span data-ttu-id="ddcf3-198">0</span><span class="sxs-lookup"><span data-stu-id="ddcf3-198">0</span></span>|  
|<span data-ttu-id="ddcf3-199">ALFKI</span><span class="sxs-lookup"><span data-stu-id="ddcf3-199">ALFKI</span></span>|<span data-ttu-id="ddcf3-200">10692</span><span class="sxs-lookup"><span data-stu-id="ddcf3-200">10692</span></span>|<span data-ttu-id="ddcf3-201">0</span><span class="sxs-lookup"><span data-stu-id="ddcf3-201">0</span></span>|  
|<span data-ttu-id="ddcf3-202">ANATR</span><span class="sxs-lookup"><span data-stu-id="ddcf3-202">ANATR</span></span>|<span data-ttu-id="ddcf3-203">10308</span><span class="sxs-lookup"><span data-stu-id="ddcf3-203">10308</span></span>|<span data-ttu-id="ddcf3-204">1</span><span class="sxs-lookup"><span data-stu-id="ddcf3-204">1</span></span>|  
|<span data-ttu-id="ddcf3-205">ANATR</span><span class="sxs-lookup"><span data-stu-id="ddcf3-205">ANATR</span></span>|<span data-ttu-id="ddcf3-206">10625</span><span class="sxs-lookup"><span data-stu-id="ddcf3-206">10625</span></span>|<span data-ttu-id="ddcf3-207">1</span><span class="sxs-lookup"><span data-stu-id="ddcf3-207">1</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="ddcf3-208">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="ddcf3-208">See also</span></span>

- [<span data-ttu-id="ddcf3-209">DataAdapters et DataReaders</span><span class="sxs-lookup"><span data-stu-id="ddcf3-209">DataAdapters and DataReaders</span></span>](../../../../docs/framework/data/adonet/dataadapters-and-datareaders.md)
- [<span data-ttu-id="ddcf3-210">Mappages de types de données dans ADO.NET</span><span class="sxs-lookup"><span data-stu-id="ddcf3-210">Data Type Mappings in ADO.NET</span></span>](../../../../docs/framework/data/adonet/data-type-mappings-in-ado-net.md)
- [<span data-ttu-id="ddcf3-211">Modification des données avec un DbDataAdapter</span><span class="sxs-lookup"><span data-stu-id="ddcf3-211">Modifying Data with a DbDataAdapter</span></span>](../../../../docs/framework/data/adonet/modifying-data-with-a-dbdataadapter.md)
- [<span data-ttu-id="ddcf3-212">MARS (Multiple Active Result Sets)</span><span class="sxs-lookup"><span data-stu-id="ddcf3-212">Multiple Active Result Sets (MARS)</span></span>](../../../../docs/framework/data/adonet/sql/multiple-active-result-sets-mars.md)
- [<span data-ttu-id="ddcf3-213">Fournisseurs managés ADO.NET et centre de développement DataSet</span><span class="sxs-lookup"><span data-stu-id="ddcf3-213">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)
