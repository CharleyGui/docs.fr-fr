---
title: Remarques sur les performances (Entity Framework)
description: En savoir plus sur les caractéristiques de performances de l’Entity Framework ADO.NET et des considérations pour améliorer les performances des applications Entity Framework.
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 2bdf088309dd178c1eef4cfb0b7e093b1f6be606
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90557461"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="df14b-103">Remarques sur les performances (Entity Framework)</span><span class="sxs-lookup"><span data-stu-id="df14b-103">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="df14b-104">Cette rubrique décrit les caractéristiques de performance d'ADO.NET Entity Framework et fournit des points à prendre en considération pour vous aider à améliorer les performances des applications Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="df14b-104">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="df14b-105">Étapes de l'exécution des requêtes</span><span class="sxs-lookup"><span data-stu-id="df14b-105">Stages of Query Execution</span></span>  
 <span data-ttu-id="df14b-106">Pour mieux comprendre les performances des requêtes dans Entity Framework, il est utile de comprendre les opérations qui se produisent lorsqu’une requête s’exécute sur un modèle conceptuel et retourne des données sous la forme d’objets.</span><span class="sxs-lookup"><span data-stu-id="df14b-106">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="df14b-107">Le tableau ci-dessous décrit cette série d'opérations.</span><span class="sxs-lookup"><span data-stu-id="df14b-107">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="df14b-108">Opération</span><span class="sxs-lookup"><span data-stu-id="df14b-108">Operation</span></span>|<span data-ttu-id="df14b-109">Coût relatif</span><span class="sxs-lookup"><span data-stu-id="df14b-109">Relative Cost</span></span>|<span data-ttu-id="df14b-110">Fréquence</span><span class="sxs-lookup"><span data-stu-id="df14b-110">Frequency</span></span>|<span data-ttu-id="df14b-111">Commentaires</span><span class="sxs-lookup"><span data-stu-id="df14b-111">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="df14b-112">Chargement des métadonnées</span><span class="sxs-lookup"><span data-stu-id="df14b-112">Loading metadata</span></span>|<span data-ttu-id="df14b-113">Modéré</span><span class="sxs-lookup"><span data-stu-id="df14b-113">Moderate</span></span>|<span data-ttu-id="df14b-114">Une fois dans chaque domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="df14b-114">Once in each application domain.</span></span>|<span data-ttu-id="df14b-115">Les métadonnées de modèle et de mappage utilisées par Entity Framework sont chargées dans un <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span><span class="sxs-lookup"><span data-stu-id="df14b-115">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="df14b-116">Ces métadonnées sont mises en cache globalement et sont disponibles pour d'autres instances d'<xref:System.Data.Objects.ObjectContext> dans le même domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="df14b-116">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="df14b-117">Ouverture de la connexion de base de données</span><span class="sxs-lookup"><span data-stu-id="df14b-117">Opening the database connection</span></span>|<span data-ttu-id="df14b-118">Modéré<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="df14b-118">Moderate<sup>1</sup></span></span>|<span data-ttu-id="df14b-119">Autant que nécessaire.</span><span class="sxs-lookup"><span data-stu-id="df14b-119">As needed.</span></span>|<span data-ttu-id="df14b-120">Étant donné qu’une connexion ouverte à la base de données consomme une ressource précieuse, le Entity Framework s’ouvre et ferme la connexion à la base de données uniquement si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="df14b-120">Because an open connection to the database consumes a valuable resource, the Entity Framework opens and closes the database connection only as needed.</span></span> <span data-ttu-id="df14b-121">Vous pouvez également ouvrir explicitement la connexion.</span><span class="sxs-lookup"><span data-stu-id="df14b-121">You can also explicitly open the connection.</span></span> <span data-ttu-id="df14b-122">Pour plus d’informations, consultez [gestion des connexions et des transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-122">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="df14b-123">Génération d'affichages</span><span class="sxs-lookup"><span data-stu-id="df14b-123">Generating views</span></span>|<span data-ttu-id="df14b-124">Élevé</span><span class="sxs-lookup"><span data-stu-id="df14b-124">High</span></span>|<span data-ttu-id="df14b-125">Une fois dans chaque domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="df14b-125">Once in each application domain.</span></span> <span data-ttu-id="df14b-126">(Ils peuvent être prégénérés.)</span><span class="sxs-lookup"><span data-stu-id="df14b-126">(Can be pre-generated.)</span></span>|<span data-ttu-id="df14b-127">Avant qu’Entity Framework puisse exécuter une requête sur un modèle conceptuel ou enregistrer des modifications apportées à la source de données, il doit générer un ensemble d’affichages des requêtes locaux pour accéder à la base de données.</span><span class="sxs-lookup"><span data-stu-id="df14b-127">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="df14b-128">En raison du coût élevé de la génération de ces affichages, vous pouvez prégénérer les affichages et les ajouter au projet au moment du design.</span><span class="sxs-lookup"><span data-stu-id="df14b-128">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="df14b-129">Pour plus d’informations, consultez [procédure : prégénérer des vues pour améliorer les performances des requêtes](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-129">For more information, see [How to: Pre-Generate Views to Improve Query Performance](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="df14b-130">Préparation de la requête</span><span class="sxs-lookup"><span data-stu-id="df14b-130">Preparing the query</span></span>|<span data-ttu-id="df14b-131">Modéré<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="df14b-131">Moderate<sup>2</sup></span></span>|<span data-ttu-id="df14b-132">Une fois pour chaque requête individuelle.</span><span class="sxs-lookup"><span data-stu-id="df14b-132">Once for each unique query.</span></span>|<span data-ttu-id="df14b-133">Inclut les coûts relatifs à la composition de la commande de requête, à la génération d’une arborescence de commandes basée sur les métadonnées de modèle et de mappage et à la définition de la forme des données retournées.</span><span class="sxs-lookup"><span data-stu-id="df14b-133">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="df14b-134">Comme les commandes de requête Entity SQL et LINQ sont à présent mises en cache, il est possible d'exécuter ultérieurement une même requête pour économiser du temps.</span><span class="sxs-lookup"><span data-stu-id="df14b-134">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="df14b-135">Vous pouvez toujours utiliser des requêtes LINQ compilées pour réduire ce coût dans les exécutions ultérieures et les requêtes compilées peuvent être plus efficaces que les requêtes LINQ qui sont automatiquement mises en cache.</span><span class="sxs-lookup"><span data-stu-id="df14b-135">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="df14b-136">Pour plus d’informations, consultez [requêtes compilées (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="df14b-136">For more information, see [Compiled Queries  (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="df14b-137">Pour obtenir des informations générales sur l’exécution des requêtes LINQ, consultez [LINQ to Entities](./language-reference/linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="df14b-137">For general information about LINQ query execution, see [LINQ to Entities](./language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="df14b-138">**Remarque :**  LINQ to Entities les requêtes qui appliquent l' `Enumerable.Contains` opérateur aux collections en mémoire ne sont pas automatiquement mises en cache.</span><span class="sxs-lookup"><span data-stu-id="df14b-138">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="df14b-139">Le paramétrage des collections en mémoire dans les requêtes LINQ compilées n’est pas autorisé.</span><span class="sxs-lookup"><span data-stu-id="df14b-139">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="df14b-140">Exécution de la requête</span><span class="sxs-lookup"><span data-stu-id="df14b-140">Executing the query</span></span>|<span data-ttu-id="df14b-141">Faible<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="df14b-141">Low<sup>2</sup></span></span>|<span data-ttu-id="df14b-142">Une fois pour chaque requête.</span><span class="sxs-lookup"><span data-stu-id="df14b-142">Once for each query.</span></span>|<span data-ttu-id="df14b-143">Coût de l'exécution de la commande sur la source de données à l'aide du fournisseur de données ADO.NET.</span><span class="sxs-lookup"><span data-stu-id="df14b-143">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="df14b-144">Comme la plupart des sources de données mettent en cache les plans de requête, les exécutions ultérieures des mêmes requêtes permettent d'économiser du temps.</span><span class="sxs-lookup"><span data-stu-id="df14b-144">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="df14b-145">Chargement et validation de types</span><span class="sxs-lookup"><span data-stu-id="df14b-145">Loading and validating types</span></span>|<span data-ttu-id="df14b-146">Faible<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="df14b-146">Low<sup>3</sup></span></span>|<span data-ttu-id="df14b-147">Une fois pour chaque instance <xref:System.Data.Objects.ObjectContext>.</span><span class="sxs-lookup"><span data-stu-id="df14b-147">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="df14b-148">Les types sont chargés et validés par rapport aux types que le modèle conceptuel définit.</span><span class="sxs-lookup"><span data-stu-id="df14b-148">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="df14b-149">Suivi</span><span class="sxs-lookup"><span data-stu-id="df14b-149">Tracking</span></span>|<span data-ttu-id="df14b-150">Faible<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="df14b-150">Low<sup>3</sup></span></span>|<span data-ttu-id="df14b-151">Une fois pour chaque objet retourné par une requête.</span><span class="sxs-lookup"><span data-stu-id="df14b-151">Once for each object that a query returns.</span></span> <span data-ttu-id="df14b-152"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="df14b-152"><sup>4</sup></span></span>|<span data-ttu-id="df14b-153">Si une requête utilise l’option de fusion <xref:System.Data.Objects.MergeOption.NoTracking>, cette étape n’affecte pas les performances.</span><span class="sxs-lookup"><span data-stu-id="df14b-153">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="df14b-154">Si la requête utilise l’option de fusion <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges> ou <xref:System.Data.Objects.MergeOption.OverwriteChanges>, les résultats de la requête sont suivis dans le <xref:System.Data.Objects.ObjectStateManager>.</span><span class="sxs-lookup"><span data-stu-id="df14b-154">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="df14b-155">Une clé <xref:System.Data.EntityKey> est générée pour chaque objet de suivi que la requête retourne et est utilisée pour créer une entrée <xref:System.Data.Objects.ObjectStateEntry> dans le <xref:System.Data.Objects.ObjectStateManager>.</span><span class="sxs-lookup"><span data-stu-id="df14b-155">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="df14b-156">Si un <xref:System.Data.Objects.ObjectStateEntry> existant est trouvé pour <xref:System.Data.EntityKey>, l'objet existant est retourné.</span><span class="sxs-lookup"><span data-stu-id="df14b-156">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="df14b-157">Si l'option <xref:System.Data.Objects.MergeOption.PreserveChanges> ou <xref:System.Data.Objects.MergeOption.OverwriteChanges> est utilisée, l'objet est mis à jour avant d'être retourné.</span><span class="sxs-lookup"><span data-stu-id="df14b-157">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="df14b-158">Pour plus d’informations, consultez [résolution d’identité, gestion d’État et change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-158">For more information, see [Identity Resolution, State Management, and Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="df14b-159">Matérialisation des objets</span><span class="sxs-lookup"><span data-stu-id="df14b-159">Materializing the objects</span></span>|<span data-ttu-id="df14b-160">Modéré à<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="df14b-160">Moderate<sup>3</sup></span></span>|<span data-ttu-id="df14b-161">Une fois pour chaque objet retourné par une requête.</span><span class="sxs-lookup"><span data-stu-id="df14b-161">Once for each object that a query returns.</span></span> <span data-ttu-id="df14b-162"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="df14b-162"><sup>4</sup></span></span>|<span data-ttu-id="df14b-163">Processus de lecture de l'objet <xref:System.Data.Common.DbDataReader> retourné, de création d'objets et de définition des valeurs de propriété basées sur les valeurs dans chaque instance de la classe <xref:System.Data.Common.DbDataRecord>.</span><span class="sxs-lookup"><span data-stu-id="df14b-163">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="df14b-164">Si l’objet existe déjà dans <xref:System.Data.Objects.ObjectContext> et que la requête utilise les options de fusion <xref:System.Data.Objects.MergeOption.AppendOnly> ou <xref:System.Data.Objects.MergeOption.PreserveChanges>, cette étape n’affecte pas les performances.</span><span class="sxs-lookup"><span data-stu-id="df14b-164">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="df14b-165">Pour plus d’informations, consultez [résolution d’identité, gestion d’État et change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-165">For more information, see [Identity Resolution, State Management, and Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="df14b-166"><sup>1</sup> lorsqu’un fournisseur de sources de données implémente le regroupement de connexions, le coût de l’ouverture d’une connexion est réparti dans le pool.</span><span class="sxs-lookup"><span data-stu-id="df14b-166"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="df14b-167">Le fournisseur .NET pour SQL Server prend en charge le regroupement de connexions.</span><span class="sxs-lookup"><span data-stu-id="df14b-167">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="df14b-168"><sup>2</sup> augmentation des coûts avec une complexité accrue des requêtes.</span><span class="sxs-lookup"><span data-stu-id="df14b-168"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="df14b-169"><sup>3</sup> le coût total augmente proportionnellement au nombre d’objets retournés par la requête.</span><span class="sxs-lookup"><span data-stu-id="df14b-169"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="df14b-170"><sup>4</sup> cette surcharge n’est pas requise pour les requêtes EntityClient, car les requêtes EntityClient retournent un <xref:System.Data.EntityClient.EntityDataReader> objet au lieu d’objets.</span><span class="sxs-lookup"><span data-stu-id="df14b-170"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="df14b-171">Pour plus d’informations, consultez la page [Fournisseur EntityClient pour Entity Framework](entityclient-provider-for-the-entity-framework.md).</span><span class="sxs-lookup"><span data-stu-id="df14b-171">For more information, see [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="df14b-172">Considérations supplémentaires</span><span class="sxs-lookup"><span data-stu-id="df14b-172">Additional Considerations</span></span>  
 <span data-ttu-id="df14b-173">D’autres considérations pouvant affecter les performances des applications Entity Framework sont exposées ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="df14b-173">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="df14b-174">Exécution des requêtes</span><span class="sxs-lookup"><span data-stu-id="df14b-174">Query Execution</span></span>  
 <span data-ttu-id="df14b-175">Comme les requêtes peuvent consommer beaucoup de ressources, considérez à quel point dans votre code et sur quel ordinateur une requête est exécutée.</span><span class="sxs-lookup"><span data-stu-id="df14b-175">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="df14b-176">Exécution différée / exécution immédiate</span><span class="sxs-lookup"><span data-stu-id="df14b-176">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="df14b-177">Lorsque vous créez une requête <xref:System.Data.Objects.ObjectQuery%601> ou LINQ, la requête peut ne pas être exécutée immédiatement.</span><span class="sxs-lookup"><span data-stu-id="df14b-177">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="df14b-178">L’exécution de la requête est différée jusqu’à ce que les résultats soient requis, comme par exemple lors d’une énumération `foreach` (C#) ou `For Each` (Visual Basic) ou lorsqu’elle est affectée pour remplir une collection <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="df14b-178">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="df14b-179">L'exécution de la requête commence immédiatement lorsque vous appelez la méthode <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> sur un <xref:System.Data.Objects.ObjectQuery%601> ou lorsque vous appelez une méthode LINQ qui retourne une requête singleton, telle que <xref:System.Linq.Enumerable.First%2A> ou <xref:System.Linq.Enumerable.Any%2A>.</span><span class="sxs-lookup"><span data-stu-id="df14b-179">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="df14b-180">Pour plus d’informations, consultez [requêtes d’objet](/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) et exécution de [requêtes (LINQ to Entities)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="df14b-180">For more information, see [Object Queries](/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="df14b-181">Exécution côté client de requêtes LINQ</span><span class="sxs-lookup"><span data-stu-id="df14b-181">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="df14b-182">Bien que l'exécution d'une requête LINQ se produise sur l'ordinateur qui héberge la source de données, certaines parties d'une requête LINQ peuvent être évaluées sur l'ordinateur client.</span><span class="sxs-lookup"><span data-stu-id="df14b-182">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="df14b-183">Pour plus d’informations, consultez la section relative à l’exécution d’une requête dans le magasin d’exécution [(LINQ to Entities)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="df14b-183">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="df14b-184">Complexité des requêtes et du mappage</span><span class="sxs-lookup"><span data-stu-id="df14b-184">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="df14b-185">La complexité des requêtes individuelles et du mappage dans le modèle d'entité aura un effet significatif sur les performances des requêtes.</span><span class="sxs-lookup"><span data-stu-id="df14b-185">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="df14b-186">Complexité du mappage</span><span class="sxs-lookup"><span data-stu-id="df14b-186">Mapping complexity</span></span>  
 <span data-ttu-id="df14b-187">Les modèles qui sont plus complexes qu'un mappage un-à-un simple entre des entités dans le modèle conceptuel et des tables dans le modèle de stockage génèrent des commandes plus complexes que les modèles qui ont un mappage un-à-un.</span><span class="sxs-lookup"><span data-stu-id="df14b-187">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="df14b-188">Complexité des requêtes</span><span class="sxs-lookup"><span data-stu-id="df14b-188">Query complexity</span></span>  
 <span data-ttu-id="df14b-189">Les requêtes qui requièrent un grand nombre de jointures dans les commandes exécutées sur la source de données ou qui retournent une grande quantité de données peuvent affecter les performances des façons suivantes :</span><span class="sxs-lookup"><span data-stu-id="df14b-189">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="df14b-190">Des requêtes sur un modèle conceptuel qui paraissent simples peuvent provoquer l'exécution de requêtes plus complexes sur la source de données.</span><span class="sxs-lookup"><span data-stu-id="df14b-190">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="df14b-191">Cela peut se produire parce qu’Entity Framework traduit une requête sur un modèle conceptuel en une requête équivalente sur la source de données.</span><span class="sxs-lookup"><span data-stu-id="df14b-191">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="df14b-192">Lorsqu'un jeu d'entités individuel dans le modèle conceptuel est mappé à plusieurs tables dans la source de données ou lorsqu'une relation entre des entités est mappée à une table de jointures, la commande de requête exécutée sur la requête de source de données peut requérir une ou plusieurs jointures.</span><span class="sxs-lookup"><span data-stu-id="df14b-192">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="df14b-193">Utilisez la méthode <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> des classes <xref:System.Data.Objects.ObjectQuery%601> ou <xref:System.Data.EntityClient.EntityCommand> pour consulter les commandes exécutées sur la source de données pour une requête donnée.</span><span class="sxs-lookup"><span data-stu-id="df14b-193">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="df14b-194">Pour plus d’informations, consultez [Comment : afficher les commandes du Windows Store](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-194">For more information, see [How to: View the Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="df14b-195">Les requêtes Entity SQL imbriquées peuvent créer des jointures sur le serveur et peuvent retourner un grand nombre de lignes.</span><span class="sxs-lookup"><span data-stu-id="df14b-195">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="df14b-196">Vous trouverez ci-dessous un exemple de requête imbriquée dans une clause de projection :</span><span class="sxs-lookup"><span data-stu-id="df14b-196">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="df14b-197">En outre, de telles requêtes provoquent la création par le pipeline de requête d'une requête individuelle avec la duplication d'objets sur l'ensemble des requêtes imbriquées.</span><span class="sxs-lookup"><span data-stu-id="df14b-197">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="df14b-198">En raison de cela, une colonne individuelle peut être dupliquée plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="df14b-198">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="df14b-199">Sur certaines bases de données, notamment SQL Server, cela peut provoquer une augmentation très importante de la taille de la table TempDB, ce qui peut réduire les performances du serveur.</span><span class="sxs-lookup"><span data-stu-id="df14b-199">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="df14b-200">Vous devez faire très attention lorsque vous exécutez des requêtes imbriquées.</span><span class="sxs-lookup"><span data-stu-id="df14b-200">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="df14b-201">Toutes les requêtes qui retournent une grande quantité de données peuvent provoquer une diminution des performances si le client effectue des opérations qui consomment des ressources d'une façon proportionnelle à la taille du jeu de résultats.</span><span class="sxs-lookup"><span data-stu-id="df14b-201">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="df14b-202">Dans de tels cas, vous devez envisager de limiter la quantité de données retournées par la requête.</span><span class="sxs-lookup"><span data-stu-id="df14b-202">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="df14b-203">Pour plus d’informations, consultez [Comment : paginer à travers les résultats de la requête](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-203">For more information, see [How to: Page Through Query Results](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="df14b-204">Toutes les commandes générées automatiquement par Entity Framework peuvent être plus complexes que des commandes semblables écrites explicitement par un développeur de base de données.</span><span class="sxs-lookup"><span data-stu-id="df14b-204">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="df14b-205">Si vous avez besoin d'un contrôle explicite sur les commandes exécutées sur votre source de données, envisagez de définir un mappage à une fonction table ou à une procédure stockée.</span><span class="sxs-lookup"><span data-stu-id="df14b-205">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="df14b-206">Relations</span><span class="sxs-lookup"><span data-stu-id="df14b-206">Relationships</span></span>  
 <span data-ttu-id="df14b-207">Pour obtenir des performances de requête optimales, vous devez définir des relations entre les entités en tant qu'associations dans le modèle d'entité et entant que relations logiques dans la source de données.</span><span class="sxs-lookup"><span data-stu-id="df14b-207">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="df14b-208">Chemins d’accès des requêtes</span><span class="sxs-lookup"><span data-stu-id="df14b-208">Query Paths</span></span>  
 <span data-ttu-id="df14b-209">Par défaut, lorsque vous exécutez une requête <xref:System.Data.Objects.ObjectQuery%601>, les objets connexes ne sont pas retournés (bien que les objets qui représentent les relations elles-mêmes le soient).</span><span class="sxs-lookup"><span data-stu-id="df14b-209">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="df14b-210">Vous pouvez charger les objets connexes de l'une des trois manières suivantes :</span><span class="sxs-lookup"><span data-stu-id="df14b-210">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="df14b-211">Définissez le chemin d’accès de la requête <xref:System.Data.Objects.ObjectQuery%601> avant qu’elle soit exécutée.</span><span class="sxs-lookup"><span data-stu-id="df14b-211">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="df14b-212">Appelez la méthode `Load` au niveau de la propriété de navigation exposée par l'objet.</span><span class="sxs-lookup"><span data-stu-id="df14b-212">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="df14b-213">Affectez à l'option <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> de l'objet <xref:System.Data.Objects.ObjectContext> la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="df14b-213">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="df14b-214">Notez que cette opération est effectuée automatiquement lorsque vous générez le code de couche objet avec le [Concepteur de Entity Data Model](/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-214">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="df14b-215">Pour plus d’informations, consultez [vue d’ensemble du code généré](/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-215">For more information see [Generated Code Overview](/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="df14b-216">Au moment de choisir l'option à utiliser, sachez qu'il y a une corrélation entre le nombre de demandes adressées à la base de données et la quantité de données retournées dans une requête individuelle.</span><span class="sxs-lookup"><span data-stu-id="df14b-216">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="df14b-217">Pour plus d’informations, consultez [chargement d’objets connexes](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-217">For more information, see [Loading Related Objects](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="df14b-218">Utilisation des chemins d’accès de requête</span><span class="sxs-lookup"><span data-stu-id="df14b-218">Using query paths</span></span>  
 <span data-ttu-id="df14b-219">Les chemins d'accès de requête définissent le graphique des objets qu'une requête retourne.</span><span class="sxs-lookup"><span data-stu-id="df14b-219">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="df14b-220">Lorsque vous définissez un chemin d’accès de requête, il suffit d’adresser une demande unique à la base de données pour que tous les objets définis par le chemin d’accès soient retournés.</span><span class="sxs-lookup"><span data-stu-id="df14b-220">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="df14b-221">L’utilisation de chemins d’accès de requête peut se traduire par l’exécution de commandes complexes sur la source de données à partir de requêtes d’objet d’apparence simple.</span><span class="sxs-lookup"><span data-stu-id="df14b-221">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="df14b-222">Cela s'explique par le fait qu'une ou plusieurs jointures sont nécessaires pour qu'une même requête retourne des objets connexes.</span><span class="sxs-lookup"><span data-stu-id="df14b-222">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="df14b-223">Cette complexité est plus prononcée dans le cas de requêtes exécutées sur un modèle d’entité complexe, par exemple, une entité avec héritage ou un chemin d’accès qui inclut des relations plusieurs-à-plusieurs.</span><span class="sxs-lookup"><span data-stu-id="df14b-223">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="df14b-224">Utilisez la méthode <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> pour voir la commande qui sera générée par un <xref:System.Data.Objects.ObjectQuery%601>.</span><span class="sxs-lookup"><span data-stu-id="df14b-224">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="df14b-225">Pour plus d’informations, consultez [Comment : afficher les commandes du Windows Store](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-225">For more information, see [How to: View the Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="df14b-226">Lorsqu’un chemin d’accès de requête comprend un trop grand nombre d’objets connexes ou que les objets contiennent une trop grande quantité de données de ligne, la source de données peut ne pas être en mesure de faire aboutir la requête.</span><span class="sxs-lookup"><span data-stu-id="df14b-226">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="df14b-227">Cela se produit si la requête a besoin d'un stockage temporaire intermédiaire qui dépasse les capacités de la source de données.</span><span class="sxs-lookup"><span data-stu-id="df14b-227">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="df14b-228">En pareil cas, vous pouvez réduire la complexité de la requête de source de données en chargeant explicitement les objets connexes.</span><span class="sxs-lookup"><span data-stu-id="df14b-228">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="df14b-229">Chargement explicite d'objets connexes</span><span class="sxs-lookup"><span data-stu-id="df14b-229">Explicitly loading related objects</span></span>  
 <span data-ttu-id="df14b-230">Vous pouvez charger explicitement des objets connexes en appelant la méthode `Load` sur une propriété de navigation qui retourne <xref:System.Data.Objects.DataClasses.EntityCollection%601> ou <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span><span class="sxs-lookup"><span data-stu-id="df14b-230">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="df14b-231">Le chargement explicite d'objets requiert un aller-retour à la base de données chaque fois que la méthode `Load` est appelée.</span><span class="sxs-lookup"><span data-stu-id="df14b-231">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="df14b-232">Si vous appelez `Load` tout en effectuant une boucle sur une collection d’objets retournés, comme par exemple lorsque vous utilisez l’instruction `foreach` (`For Each` en Visual Basic), le fournisseur spécifique à la source de données doit prendre en charge plusieurs jeux de résultats actifs sur une même connexion.</span><span class="sxs-lookup"><span data-stu-id="df14b-232">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="df14b-233">Pour une base de données SQL Server, vous devez spécifier la valeur `MultipleActiveResultSets = true` dans la chaîne de connexion du fournisseur.</span><span class="sxs-lookup"><span data-stu-id="df14b-233">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="df14b-234">Vous pouvez également utiliser la méthode <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> en l'absence de propriétés <xref:System.Data.Objects.DataClasses.EntityCollection%601> ou <xref:System.Data.Objects.DataClasses.EntityReference%601> sur les entités.</span><span class="sxs-lookup"><span data-stu-id="df14b-234">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="df14b-235">Cela peut s'avérer utile lorsque vous utilisez des entités POCO.</span><span class="sxs-lookup"><span data-stu-id="df14b-235">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="df14b-236">Bien que le chargement explicite d'objets connexes réduise le nombre de jointures ainsi que la quantité de données redondantes, la méthode `Load` requiert des connexions répétées à la base de données, ce qui peut devenir coûteux lors du chargement explicite d'un grand nombre d'objets.</span><span class="sxs-lookup"><span data-stu-id="df14b-236">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="df14b-237">Enregistrement des modifications</span><span class="sxs-lookup"><span data-stu-id="df14b-237">Saving Changes</span></span>  
 <span data-ttu-id="df14b-238">Lorsque vous appelez la méthode <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> sur <xref:System.Data.Objects.ObjectContext>, une commande distincte de création, mise à jour ou suppression est générée pour chaque objet ajouté, mis à jour ou supprimé dans le contexte.</span><span class="sxs-lookup"><span data-stu-id="df14b-238">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="df14b-239">Ces commandes sont exécutées sur la source de données dans une transaction unique.</span><span class="sxs-lookup"><span data-stu-id="df14b-239">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="df14b-240">Comme avec les requêtes, les performances des opérations de création, mise à jour et suppression dépendent de la complexité du mappage dans le modèle conceptuel.</span><span class="sxs-lookup"><span data-stu-id="df14b-240">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="df14b-241">Transactions distribuées</span><span class="sxs-lookup"><span data-stu-id="df14b-241">Distributed Transactions</span></span>  
 <span data-ttu-id="df14b-242">Des opérations dans une transaction explicite qui requièrent des ressources gérées par DTC (Distributed Transaction Coordinator) seront beaucoup plus coûteuses qu’une opération semblable qui ne requiert pas DTC.</span><span class="sxs-lookup"><span data-stu-id="df14b-242">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="df14b-243">La promotion DTC se produira dans les situations suivantes :</span><span class="sxs-lookup"><span data-stu-id="df14b-243">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="df14b-244">Transaction explicite avec une opération sur une base de données SQL Server 2000 ou une autre source de données qui effectue toujours une promotion DTC des transactions explicites.</span><span class="sxs-lookup"><span data-stu-id="df14b-244">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="df14b-245">Transaction explicite avec une opération sur SQL Server 2005 lorsque la connexion est gérée par le Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="df14b-245">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the Entity Framework.</span></span> <span data-ttu-id="df14b-246">Cela est dû au fait que SQL Server 2005 promeut à un DTC chaque fois qu’une connexion est fermée et rouverte dans une transaction unique, ce qui correspond au comportement par défaut du Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="df14b-246">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the Entity Framework.</span></span> <span data-ttu-id="df14b-247">Cette promotion DTC n'a pas lieu lors de l'utilisation de SQL Server 2008.</span><span class="sxs-lookup"><span data-stu-id="df14b-247">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="df14b-248">Pour éviter cette promotion lors de l'utilisation de SQL Server 2005, vous devez ouvrir et fermer explicitement la connexion dans la transaction.</span><span class="sxs-lookup"><span data-stu-id="df14b-248">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="df14b-249">Pour plus d’informations, consultez [gestion des connexions et des transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-249">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="df14b-250">Une transaction explicite est utilisée lorsqu'une ou plusieurs opérations sont exécutées au sein d'une transaction <xref:System.Transactions>.</span><span class="sxs-lookup"><span data-stu-id="df14b-250">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="df14b-251">Pour plus d’informations, consultez [gestion des connexions et des transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-251">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="df14b-252">Stratégies pour l'amélioration des performances</span><span class="sxs-lookup"><span data-stu-id="df14b-252">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="df14b-253">Vous pouvez améliorer les performances globales des requêtes dans Entity Framework en utilisant les stratégies ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="df14b-253">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="df14b-254">Prégénérer des affichages</span><span class="sxs-lookup"><span data-stu-id="df14b-254">Pre-generate views</span></span>  
 <span data-ttu-id="df14b-255">La génération d'affichages basés sur un modèle d'entité représente un coût significatif la première fois qu'une application exécute une requête.</span><span class="sxs-lookup"><span data-stu-id="df14b-255">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="df14b-256">Utilisez l'utilitaire EdmGen.exe pour prégénérer des affichages sous la forme d'un fichier de code Visual Basic ou C# qui peut être ajouté au projet pendant la conception.</span><span class="sxs-lookup"><span data-stu-id="df14b-256">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="df14b-257">Vous pouvez aussi utiliser un modèle Text Template Transformation Toolk pour générer des vues précompilées.</span><span class="sxs-lookup"><span data-stu-id="df14b-257">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="df14b-258">Les vues prégénérées sont validées au moment de l'exécution pour garantir qu'elles sont cohérentes avec la version actuelle du modèle d'entité spécifié.</span><span class="sxs-lookup"><span data-stu-id="df14b-258">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="df14b-259">Pour plus d’informations, consultez [procédure : prégénérer des vues pour améliorer les performances des requêtes](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-259">For more information, see [How to: Pre-Generate Views to Improve Query Performance](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="df14b-260">Tenez compte des éléments suivants lors de l'utilisation de très grands modèles :</span><span class="sxs-lookup"><span data-stu-id="df14b-260">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="df14b-261">Le format des métadonnées .NET limite le nombre de caractères de la chaîne utilisateur dans un binaire donné à 16,777,215 (0xFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="df14b-261">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="df14b-262">Si vous générez des vues pour un modèle très volumineux et que le fichier de vue atteint cette limite de taille, vous obtiendrez le « pas d’espace logique restant pour la création de chaînes utilisateur supplémentaires ».</span><span class="sxs-lookup"><span data-stu-id="df14b-262">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="df14b-263">erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="df14b-263">compile error.</span></span> <span data-ttu-id="df14b-264">Cette limitation s'applique à tous les binaires gérés.</span><span class="sxs-lookup"><span data-stu-id="df14b-264">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="df14b-265">Pour plus d’informations, consultez le [blog](/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) qui montre comment éviter l’erreur lors de l’utilisation de modèles volumineux et complexes.</span><span class="sxs-lookup"><span data-stu-id="df14b-265">For more information see the [blog](/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="df14b-266">Envisager d’utiliser l’option de fusion NoTracking pour les requêtes</span><span class="sxs-lookup"><span data-stu-id="df14b-266">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="df14b-267">Effectuer le suivi des objets retournés dans le contexte de l'objet a un coût obligatoire.</span><span class="sxs-lookup"><span data-stu-id="df14b-267">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="df14b-268">Les objets doivent être joints à une instance <xref:System.Data.Objects.ObjectContext> pour que les modifications apportées aux objets soient détectées et pour garantir que plusieurs demandes pour la même entité logique retournent la même instance de l'objet.</span><span class="sxs-lookup"><span data-stu-id="df14b-268">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="df14b-269">Si vous n’envisagez pas de mettre à jour ou de supprimer des objets et que vous n’avez pas besoin de la gestion des identités, envisagez d’utiliser les <xref:System.Data.Objects.MergeOption.NoTracking> options de fusion lorsque vous exécutez des requêtes.</span><span class="sxs-lookup"><span data-stu-id="df14b-269">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="df14b-270">Retourner la quantité appropriée de données</span><span class="sxs-lookup"><span data-stu-id="df14b-270">Return the correct amount of data</span></span>  
 <span data-ttu-id="df14b-271">Dans certains scénarios, il est beaucoup plus rapide de spécifier un chemin d'accès de requête à l'aide de la méthode <xref:System.Data.Objects.ObjectQuery%601.Include%2A> car cela requiert moins d'allers-retours à la base de données.</span><span class="sxs-lookup"><span data-stu-id="df14b-271">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="df14b-272">Toutefois, dans d'autres scénarios, des allers-retours supplémentaires à la base de données pour charger des objets connexes peuvent être plus rapides, car des requêtes plus simples avec moins de jointures entraînent une redondance de données moins importante.</span><span class="sxs-lookup"><span data-stu-id="df14b-272">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="df14b-273">De ce fait, nous vous recommandons de tester les performances des différentes méthodes de récupération des objets connexes.</span><span class="sxs-lookup"><span data-stu-id="df14b-273">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="df14b-274">Pour plus d’informations, consultez [chargement d’objets connexes](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-274">For more information, see [Loading Related Objects](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="df14b-275">Pour éviter de retourner trop de données dans une même requête, envisagez de paginer les résultats de la requête en groupes plus maniables.</span><span class="sxs-lookup"><span data-stu-id="df14b-275">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="df14b-276">Pour plus d’informations, consultez [Comment : paginer à travers les résultats de la requête](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-276">For more information, see [How to: Page Through Query Results](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="df14b-277">Limiter l'étendue d'ObjectContext</span><span class="sxs-lookup"><span data-stu-id="df14b-277">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="df14b-278">Dans la plupart des cas, vous devez créer une instance <xref:System.Data.Objects.ObjectContext> dans une instruction `using` (`Using…End Using` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="df14b-278">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="df14b-279">Cela peut augmenter les performances en garantissant la suppression automatique des ressources associées au contexte de l'objet à la fin de l'exécution d'un bloc d'instructions.</span><span class="sxs-lookup"><span data-stu-id="df14b-279">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="df14b-280">Toutefois, lorsque des contrôles sont liés aux objets gérés par le contexte de l'objet, l'instance <xref:System.Data.Objects.ObjectContext> doit être conservée aussi longtemps que la liaison est requise, puis supprimée manuellement.</span><span class="sxs-lookup"><span data-stu-id="df14b-280">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="df14b-281">Pour plus d’informations, consultez [gestion des connexions et des transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-281">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="df14b-282">Envisager d'ouvrir la connexion de base de données manuellement</span><span class="sxs-lookup"><span data-stu-id="df14b-282">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="df14b-283">Lorsque votre application exécute une série de requêtes d’objet ou appelle fréquemment <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> pour conserver les opérations de création, de mise à jour et de suppression dans la source de données, le Entity Framework doit ouvrir et fermer continuellement la connexion à la source de données.</span><span class="sxs-lookup"><span data-stu-id="df14b-283">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the Entity Framework must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="df14b-284">En pareils cas, envisagez d'ouvrir manuellement la connexion au démarrage de ces opérations et de fermer ou supprimer la connexion une fois les opérations terminées.</span><span class="sxs-lookup"><span data-stu-id="df14b-284">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="df14b-285">Pour plus d’informations, consultez [gestion des connexions et des transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="df14b-285">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="df14b-286">Données de performance</span><span class="sxs-lookup"><span data-stu-id="df14b-286">Performance Data</span></span>  
 <span data-ttu-id="df14b-287">Certaines données de performances de la Entity Framework sont publiées dans les publications suivantes sur le blog de l' [équipe ADO.net](/archive/blogs/adonet/):</span><span class="sxs-lookup"><span data-stu-id="df14b-287">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](/archive/blogs/adonet/):</span></span>  
  
- [<span data-ttu-id="df14b-288">Exploration des performances d'ADO.NET Entity Framework – partie 1</span><span class="sxs-lookup"><span data-stu-id="df14b-288">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [<span data-ttu-id="df14b-289">Exploration des performances d'ADO.NET Entity Framework – partie 2</span><span class="sxs-lookup"><span data-stu-id="df14b-289">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [<span data-ttu-id="df14b-290">Comparaison des performances d'ADO.NET Entity Framework</span><span class="sxs-lookup"><span data-stu-id="df14b-290">ADO.NET Entity Framework Performance Comparison</span></span>](/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a><span data-ttu-id="df14b-291">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="df14b-291">See also</span></span>

- [<span data-ttu-id="df14b-292">Points à prendre en considération pour le développement et le déploiement</span><span class="sxs-lookup"><span data-stu-id="df14b-292">Development and Deployment Considerations</span></span>](development-and-deployment-considerations.md)
