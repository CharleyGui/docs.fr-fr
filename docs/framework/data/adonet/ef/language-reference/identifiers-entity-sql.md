---
title: Identificateurs (Entity SQL)
ms.date: 03/30/2017
ms.assetid: d58a5edd-7b5c-48e1-b5d7-a326ff426aa4
ms.openlocfilehash: b467a42ed0a0083b9e72037f437dd70aa6b46390
ms.sourcegitcommit: 8a0fe8a2227af612f8b8941bdb8b19d6268748e7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/03/2019
ms.locfileid: "71833706"
---
# <a name="identifiers-entity-sql"></a><span data-ttu-id="579c5-102">Identificateurs (Entity SQL)</span><span class="sxs-lookup"><span data-stu-id="579c5-102">Identifiers (Entity SQL)</span></span>
<span data-ttu-id="579c5-103">Les identificateurs sont utilisés dans [!INCLUDE[esql](../../../../../../includes/esql-md.md)] pour représenter des alias d'expression de requête, des références de variables, des propriétés d'objets, des fonctions, etc.</span><span class="sxs-lookup"><span data-stu-id="579c5-103">Identifiers are used in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] to represent query expression aliases, variable references, properties of objects, functions, and so on.</span></span> [!INCLUDE[esql](../../../../../../includes/esql-md.md)] <span data-ttu-id="579c5-104">fournit deux types d’identificateurs : les identificateurs simples et les identificateurs entre guillemets.</span><span class="sxs-lookup"><span data-stu-id="579c5-104">provides two kinds of identifiers: simple identifiers and quoted identifiers.</span></span>  
  
## <a name="simple-identifiers"></a><span data-ttu-id="579c5-105">Identificateurs simples</span><span class="sxs-lookup"><span data-stu-id="579c5-105">Simple Identifiers</span></span>  
 <span data-ttu-id="579c5-106">Un identificateur simple dans [!INCLUDE[esql](../../../../../../includes/esql-md.md)] est une séquence de caractères alphanumériques et de traits de soulignement.</span><span class="sxs-lookup"><span data-stu-id="579c5-106">A simple identifier in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] is a sequence of alphanumeric and underscore characters.</span></span> <span data-ttu-id="579c5-107">Le premier caractère de l'identificateur doit être un caractère alphabétique (a-z ou A-Z).</span><span class="sxs-lookup"><span data-stu-id="579c5-107">The first character of the identifier must be an alphabetical character (a-z or A-Z).</span></span>  
  
## <a name="quoted-identifiers"></a><span data-ttu-id="579c5-108">Identificateurs entre guillemets</span><span class="sxs-lookup"><span data-stu-id="579c5-108">Quoted Identifiers</span></span>  
 <span data-ttu-id="579c5-109">Un identificateur entre guillemets est une séquence quelconque de caractères entre crochets ([]).</span><span class="sxs-lookup"><span data-stu-id="579c5-109">A quoted identifier is any sequence of characters enclosed in square brackets ([]).</span></span> <span data-ttu-id="579c5-110">Les identificateurs entre guillemets vous permettent de spécifier des identificateurs avec des caractères qui ne sont pas valides dans des identificateurs.</span><span class="sxs-lookup"><span data-stu-id="579c5-110">Quoted identifiers let you specify identifiers with characters that are not valid in identifiers.</span></span> <span data-ttu-id="579c5-111">Tous les caractères entre les crochets deviennent partie intégrante de l’identificateur, y compris tous les espaces blancs.</span><span class="sxs-lookup"><span data-stu-id="579c5-111">All characters between the square brackets become part of the identifier, including all white space.</span></span>  
  
 <span data-ttu-id="579c5-112">Un identificateur entre guillemets ne peut pas inclure les caractères suivants :</span><span class="sxs-lookup"><span data-stu-id="579c5-112">A quoted identifier cannot include the following characters:</span></span>  
  
- <span data-ttu-id="579c5-113">Saut de ligne</span><span class="sxs-lookup"><span data-stu-id="579c5-113">Newline.</span></span>  
  
- <span data-ttu-id="579c5-114">Retours chariot</span><span class="sxs-lookup"><span data-stu-id="579c5-114">Carriage returns.</span></span>  
  
- <span data-ttu-id="579c5-115">Tabulations</span><span class="sxs-lookup"><span data-stu-id="579c5-115">Tabs.</span></span>  
  
- <span data-ttu-id="579c5-116">Retour arrière</span><span class="sxs-lookup"><span data-stu-id="579c5-116">Backspace.</span></span>  
  
- <span data-ttu-id="579c5-117">Crochets supplémentaires (c'est-à-dire des crochets situés entre les crochets qui délimitent l'identificateur)</span><span class="sxs-lookup"><span data-stu-id="579c5-117">Additional square brackets (that is, square brackets within the square brackets that delineate the identifier).</span></span>  
  
 <span data-ttu-id="579c5-118">Un identificateur entre guillemets peut inclure des caractères Unicode.</span><span class="sxs-lookup"><span data-stu-id="579c5-118">A quoted-identifier can include Unicode characters.</span></span>  
  
 <span data-ttu-id="579c5-119">Les identificateurs entre guillemets vous permettent de créer des caractères de nom de propriété qui ne sont pas valides dans les identificateurs, comme l'illustre l'exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="579c5-119">Quoted identifiers enable you to create property name characters that are not valid in identifiers, as illustrated in the following example:</span></span>  
  
 `SELECT c.ContactName AS [Contact Name] FROM customers AS c`  
  
 <span data-ttu-id="579c5-120">Vous pouvez également utiliser des identificateurs entre guillemets pour spécifier un identificateur qui est un mot clé réservé [!INCLUDE[esql](../../../../../../includes/esql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="579c5-120">You can also use quoted identifiers to specify an identifier that is a reserved keyword of [!INCLUDE[esql](../../../../../../includes/esql-md.md)].</span></span> <span data-ttu-id="579c5-121">Par exemple, si le type `Email` a une propriété nommée "From", vous pouvez éliminer l'ambiguïté liée au mot clé réservé FROM en utilisant des crochets, comme suit :</span><span class="sxs-lookup"><span data-stu-id="579c5-121">For example, if the type `Email` has a property named "From", you can disambiguate it from the reserved keyword FROM by using square brackets, as follows:</span></span>  
  
 `SELECT e.[From] FROM emails AS e`  
  
 <span data-ttu-id="579c5-122">Vous pouvez utiliser un identificateur entre guillemets à droite d'un opérateur point (.).</span><span class="sxs-lookup"><span data-stu-id="579c5-122">You can use a quoted identifier on the right side of a dot (.) operator.</span></span>  
  
 `SELECT t FROM ts as t WHERE t.[property] == 2`  
  
 <span data-ttu-id="579c5-123">Pour utiliser le crochet dans un identificateur, ajoutez un crochet supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="579c5-123">To use the square bracket in an identifier, add an extra square bracket.</span></span> <span data-ttu-id="579c5-124">Dans l'exemple suivant, « `abc]` » est l'identificateur :</span><span class="sxs-lookup"><span data-stu-id="579c5-124">In the following example "`abc]`" is the identifier:</span></span>  
  
 `SELECT t from ts as t WHERE t.[abc]]] == 2`  
  
 <span data-ttu-id="579c5-125">Pour la sémantique de comparaison des identificateurs entre guillemets, consultez [jeu de caractères d’entrée](input-character-set-entity-sql.md).</span><span class="sxs-lookup"><span data-stu-id="579c5-125">For quoted identifier comparison semantics, see [Input Character Set](input-character-set-entity-sql.md).</span></span>  
  
## <a name="aliasing-rules"></a><span data-ttu-id="579c5-126">Règles d'alias</span><span class="sxs-lookup"><span data-stu-id="579c5-126">Aliasing Rules</span></span>  
 <span data-ttu-id="579c5-127">Nous vous recommandons de spécifier des alias dans des requêtes [!INCLUDE[esql](../../../../../../includes/esql-md.md)] chaque fois que nécessaire, y compris les constructions [!INCLUDE[esql](../../../../../../includes/esql-md.md)] suivantes :</span><span class="sxs-lookup"><span data-stu-id="579c5-127">We recommend specifying aliases in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] queries whenever needed, including the following [!INCLUDE[esql](../../../../../../includes/esql-md.md)] constructs:</span></span>  
  
- <span data-ttu-id="579c5-128">Champs d'un constructeur de ligne</span><span class="sxs-lookup"><span data-stu-id="579c5-128">Fields of a row constructor.</span></span>  
  
- <span data-ttu-id="579c5-129">Éléments dans la clause FROM d'une expression de requête</span><span class="sxs-lookup"><span data-stu-id="579c5-129">Items in the FROM clause of a query expression.</span></span>  
  
- <span data-ttu-id="579c5-130">Éléments dans la clause SELECT d'une expression de requête</span><span class="sxs-lookup"><span data-stu-id="579c5-130">Items in the SELECT clause of a query expression.</span></span>  
  
- <span data-ttu-id="579c5-131">Éléments dans la clause GROUP BY d'une expression de requête</span><span class="sxs-lookup"><span data-stu-id="579c5-131">Items in the GROUP BY clause of a query expression.</span></span>  
  
### <a name="valid-aliases"></a><span data-ttu-id="579c5-132">Alias valides</span><span class="sxs-lookup"><span data-stu-id="579c5-132">Valid Aliases</span></span>  
 <span data-ttu-id="579c5-133">Les alias valides dans [!INCLUDE[esql](../../../../../../includes/esql-md.md)] sont des identificateurs simples ou des identificateurs entre guillemets.</span><span class="sxs-lookup"><span data-stu-id="579c5-133">Valid aliases in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] are any simple identifier or quoted identifier.</span></span>  
  
### <a name="alias-generation"></a><span data-ttu-id="579c5-134">Génération d'alias</span><span class="sxs-lookup"><span data-stu-id="579c5-134">Alias Generation</span></span>  
 <span data-ttu-id="579c5-135">Si aucun alias n’est spécifié dans une expression de requête [!INCLUDE[esql](../../../../../../includes/esql-md.md)], [!INCLUDE[esql](../../../../../../includes/esql-md.md)] tente de générer un alias en fonction des règles simples suivantes :</span><span class="sxs-lookup"><span data-stu-id="579c5-135">If no alias is specified in an [!INCLUDE[esql](../../../../../../includes/esql-md.md)] query expression, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] tries to generate an alias based on the following simple rules:</span></span>  
  
- <span data-ttu-id="579c5-136">Si l'expression de requête (pour laquelle l'alias n'est pas spécifié) est un identificateur simple ou entre guillemets, cet identificateur est utilisé comme alias.</span><span class="sxs-lookup"><span data-stu-id="579c5-136">If the query expression (for which the alias is unspecified) is a simple or quoted identifier, that identifier is used as the alias.</span></span> <span data-ttu-id="579c5-137">Par exemple, `ROW(a, [b])` devient `ROW(a AS a, [b] AS [b])` ;</span><span class="sxs-lookup"><span data-stu-id="579c5-137">For example, `ROW(a, [b])` becomes `ROW(a AS a, [b] AS [b])`.</span></span>  
  
- <span data-ttu-id="579c5-138">Si l'expression de requête est une expression plus complexe, mais que le dernier composant de cette expression de requête est un identificateur simple, cet identificateur est utilisé comme alias.</span><span class="sxs-lookup"><span data-stu-id="579c5-138">If the query expression is a more complex expression, but the last component of that query expression is a simple identifier, then that identifier is used as the alias.</span></span> <span data-ttu-id="579c5-139">Par exemple, `ROW(a.a1, b.[b1])` devient `ROW(a.a1 AS a1, b.[b1] AS [b1])` ;</span><span class="sxs-lookup"><span data-stu-id="579c5-139">For example, `ROW(a.a1, b.[b1])` becomes `ROW(a.a1 AS a1, b.[b1] AS [b1])`.</span></span>  
  
 <span data-ttu-id="579c5-140">Nous vous recommandons de ne pas utiliser d'alias implicite si vous souhaitez utiliser le nom d'alias ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="579c5-140">We recommend that you do not use implicit aliasing if you want to use the alias name later.</span></span> <span data-ttu-id="579c5-141">Chaque fois que des alias (implicites ou explicites) sont en conflit ou sont répétés dans la même étendue, il se produit une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="579c5-141">Anytime aliases (implicit or explicit) conflict or are repeated in the same scope, there will be a compile error.</span></span> <span data-ttu-id="579c5-142">Un alias implicite passera la compilation même s'il existe un alias explicite ou implicite du même nom.</span><span class="sxs-lookup"><span data-stu-id="579c5-142">An implicit alias will pass compilation even if there is an explicit or implicit alias of the same name.</span></span>  
  
 <span data-ttu-id="579c5-143">Des alias implicites sont générés automatiquement en fonction de l'entrée d'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="579c5-143">Implicit aliases are autogenerated based on user input.</span></span> <span data-ttu-id="579c5-144">Par exemple, la ligne de code ci-dessous générera NAME comme alias pour les deux colonnes et générera ainsi un conflit.</span><span class="sxs-lookup"><span data-stu-id="579c5-144">For example, the following line of code will generate NAME as an alias for both columns and therefore will conflict.</span></span>  
  
```sql  
SELECT product.NAME, person.NAME  
```  
  
 <span data-ttu-id="579c5-145">La ligne de code ci-dessous, qui utilise des alias explicites, échouera également.</span><span class="sxs-lookup"><span data-stu-id="579c5-145">The following line of code, which uses explicit aliases, will also fail.</span></span> <span data-ttu-id="579c5-146">Toutefois, l'échec sera plus apparent en lisant le code.</span><span class="sxs-lookup"><span data-stu-id="579c5-146">However, the failure will be more apparent by reading the code.</span></span>  
  
```sql  
SELECT 1 AS X, 2 AS X …  
```  
  
## <a name="scoping-rules"></a><span data-ttu-id="579c5-147">Règles de portée</span><span class="sxs-lookup"><span data-stu-id="579c5-147">Scoping Rules</span></span>  
 [!INCLUDE[esql](../../../../../../includes/esql-md.md)] <span data-ttu-id="579c5-148">définit des règles de portée qui déterminent quand des variables particulières sont visibles dans le langage de requête.</span><span class="sxs-lookup"><span data-stu-id="579c5-148">defines scoping rules that determine when particular variables are visible in the query language.</span></span> <span data-ttu-id="579c5-149">Certaines expressions ou instructions introduisent de nouveaux noms.</span><span class="sxs-lookup"><span data-stu-id="579c5-149">Some expressions or statements introduce new names.</span></span> <span data-ttu-id="579c5-150">Les règles de portée déterminent où ces noms peuvent être utilisés, ainsi que quand et où une nouvelle déclaration du même nom qu'une autre peut masquer son prédécesseur.</span><span class="sxs-lookup"><span data-stu-id="579c5-150">The scoping rules determine where those names can be used, and when or where a new declaration with the same name as another can hide its predecessor.</span></span>  
  
 <span data-ttu-id="579c5-151">Lorsque des noms sont définis dans une requête [!INCLUDE[esql](../../../../../../includes/esql-md.md)], on dit qu’ils sont définis dans une étendue.</span><span class="sxs-lookup"><span data-stu-id="579c5-151">When names are defined in an [!INCLUDE[esql](../../../../../../includes/esql-md.md)] query, they are said to be defined within a scope.</span></span> <span data-ttu-id="579c5-152">Une étendue couvre une région entière de la requête.</span><span class="sxs-lookup"><span data-stu-id="579c5-152">A scope covers an entire region of the query.</span></span> <span data-ttu-id="579c5-153">Toutes les expressions ou les références de nom dans une certaine étendue peuvent voir les noms définis dans cette étendue.</span><span class="sxs-lookup"><span data-stu-id="579c5-153">All expressions or name references within a certain scope can see names that are defined within that scope.</span></span> <span data-ttu-id="579c5-154">Avant le début d'une étendue et après sa fin, il n'est pas possible de référencer les noms définis dans l'étendue.</span><span class="sxs-lookup"><span data-stu-id="579c5-154">Before a scope begins and after it ends, names that are defined within the scope cannot be referenced.</span></span>  
  
 <span data-ttu-id="579c5-155">Les étendues peuvent être imbriquées.</span><span class="sxs-lookup"><span data-stu-id="579c5-155">Scopes can be nested.</span></span> <span data-ttu-id="579c5-156">Les parties de [!INCLUDE[esql](../../../../../../includes/esql-md.md)] introduisent de nouvelles étendues qui couvrent des régions entières, et ces régions peuvent contenir d’autres expressions [!INCLUDE[esql](../../../../../../includes/esql-md.md)] qui introduisent également des étendues.</span><span class="sxs-lookup"><span data-stu-id="579c5-156">Parts of [!INCLUDE[esql](../../../../../../includes/esql-md.md)] introduce new scopes that cover entire regions, and these regions can contain other [!INCLUDE[esql](../../../../../../includes/esql-md.md)] expressions that also introduce scopes.</span></span> <span data-ttu-id="579c5-157">Lorsque des étendues sont imbriquées, des références peuvent être faites aux noms définis dans l'étendue la plus intérieure, qui contient la référence.</span><span class="sxs-lookup"><span data-stu-id="579c5-157">When scopes are nested, references can be made to names that are defined in the innermost scope, which contains the reference.</span></span> <span data-ttu-id="579c5-158">Des références peuvent également être faites à tous les noms définis dans toutes les étendues extérieures.</span><span class="sxs-lookup"><span data-stu-id="579c5-158">References can also be made to any names that are defined in any outer scopes.</span></span> <span data-ttu-id="579c5-159">Deux étendues quelconques définies dans une même étendue sont considérées comme des étendues sœurs.</span><span class="sxs-lookup"><span data-stu-id="579c5-159">Any two scopes defined within the same scope are considered sibling scopes.</span></span> <span data-ttu-id="579c5-160">Il n'est pas possible d'effectuer des références à des noms définis dans des étendues sœurs.</span><span class="sxs-lookup"><span data-stu-id="579c5-160">References cannot be made to names that are defined within sibling scopes.</span></span>  
  
 <span data-ttu-id="579c5-161">Si un nom déclaré dans une étendue intérieure correspond à un nom déclaré dans une étendue extérieure, les références dans l'étendue intérieure ou dans les étendues déclarées dans cette étendue font référence uniquement au nom nouvellement déclaré.</span><span class="sxs-lookup"><span data-stu-id="579c5-161">If a name declared in an inner scope matches a name declared in an outer scope, references within the inner scope or within scopes declared within that scope refer only to the newly declared name.</span></span> <span data-ttu-id="579c5-162">Le nom dans l'étendue extérieure est masqué.</span><span class="sxs-lookup"><span data-stu-id="579c5-162">The name in the outer scope is hidden.</span></span>  
  
 <span data-ttu-id="579c5-163">Même dans une même étendue, les noms ne peuvent pas être référencés avant d'être définis.</span><span class="sxs-lookup"><span data-stu-id="579c5-163">Even within the same scope, names cannot be referenced before they are defined.</span></span>  
  
 <span data-ttu-id="579c5-164">Des noms globaux peuvent exister dans le cadre de l'environnement d'exécution.</span><span class="sxs-lookup"><span data-stu-id="579c5-164">Global names can exist as part of the execution environment.</span></span> <span data-ttu-id="579c5-165">Cela peut inclure les noms de collections ou de variables d'environnement persistantes.</span><span class="sxs-lookup"><span data-stu-id="579c5-165">This can include names of persistent collections or environment variables.</span></span> <span data-ttu-id="579c5-166">Pour qu'un nom soit global, il doit être déclaré dans l'étendue la plus extérieure.</span><span class="sxs-lookup"><span data-stu-id="579c5-166">For a name to be global, it must be declared in the outermost scope.</span></span>  
  
 <span data-ttu-id="579c5-167">Les paramètres ne sont pas inclus dans une étendue.</span><span class="sxs-lookup"><span data-stu-id="579c5-167">Parameters are not in a scope.</span></span> <span data-ttu-id="579c5-168">Comme les références aux paramètres incluent une syntaxe spéciale, les noms des paramètres n'entrent jamais en collision avec d'autres noms dans la requête.</span><span class="sxs-lookup"><span data-stu-id="579c5-168">Because references to parameters include special syntax, names of parameters will never collide with other names in the query.</span></span>  
  
### <a name="query-expressions"></a><span data-ttu-id="579c5-169">Expressions de requête</span><span class="sxs-lookup"><span data-stu-id="579c5-169">Query Expressions</span></span>  
 <span data-ttu-id="579c5-170">Une expression de requête [!INCLUDE[esql](../../../../../../includes/esql-md.md)] introduit une nouvelle étendue.</span><span class="sxs-lookup"><span data-stu-id="579c5-170">An [!INCLUDE[esql](../../../../../../includes/esql-md.md)] query expression introduces a new scope.</span></span> <span data-ttu-id="579c5-171">Les noms définis dans la clause FROM sont introduits dans l'étendue from dans l'ordre de leur apparition, de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="579c5-171">Names that are defined in the FROM clause are introduced into the from scope in order of appearance, left to right.</span></span> <span data-ttu-id="579c5-172">Dans la liste de jointure, les expressions peuvent faire référence aux noms définis précédemment dans la liste.</span><span class="sxs-lookup"><span data-stu-id="579c5-172">In the join list, expressions can refer to names that were defined earlier in the list.</span></span> <span data-ttu-id="579c5-173">Les propriétés publiques (champs, etc.) des éléments identifiés dans la clause FROM ne sont pas ajoutées à l'étendue from.</span><span class="sxs-lookup"><span data-stu-id="579c5-173">Public properties (fields and so on) of elements identified in the FROM clause are not added to the from-scope.</span></span> <span data-ttu-id="579c5-174">Elles doivent toujours être référencées par le nom qualifié par un alias.</span><span class="sxs-lookup"><span data-stu-id="579c5-174">They must be always referenced by the alias-qualified name.</span></span> <span data-ttu-id="579c5-175">En général, toutes les parties de l'expression SELECT sont considérées dans l'étendue from.</span><span class="sxs-lookup"><span data-stu-id="579c5-175">Typically, all parts of the SELECT expression are considered within the from-scope.</span></span>  
  
 <span data-ttu-id="579c5-176">La clause GROUP BY introduit également une nouvelle étendue sœur.</span><span class="sxs-lookup"><span data-stu-id="579c5-176">The GROUP BY clause also introduces a new sibling scope.</span></span> <span data-ttu-id="579c5-177">Chaque groupe peut avoir un nom de groupe qui fait référence à la collection d’éléments dans le groupe.</span><span class="sxs-lookup"><span data-stu-id="579c5-177">Each group can have a group name that refers to the collection of elements in the group.</span></span> <span data-ttu-id="579c5-178">Chaque expression de regroupement introduira également un nouveau nom dans l'étendue de groupe.</span><span class="sxs-lookup"><span data-stu-id="579c5-178">Each grouping expression will also introduce a new name into the group-scope.</span></span> <span data-ttu-id="579c5-179">De plus, l'agrégat d'imbrication (ou le groupe nommé) est également ajouté à l'étendue.</span><span class="sxs-lookup"><span data-stu-id="579c5-179">Additionally, the nest aggregate (or the named group) is also added to the scope.</span></span> <span data-ttu-id="579c5-180">Les expressions de regroupement elles-mêmes sont incluses dans l'étendue from.</span><span class="sxs-lookup"><span data-stu-id="579c5-180">The grouping expressions themselves are within the from-scope.</span></span> <span data-ttu-id="579c5-181">Toutefois, lorsqu'une clause GROUP BY est utilisée, la liste de sélection (projection), la clause HAVING et la clause ORDER BY sont considérées incluses dans l'étendue de groupe et non dans l'étendue from.</span><span class="sxs-lookup"><span data-stu-id="579c5-181">However, when a GROUP BY clause is used, the select-list (projection), HAVING clause, and ORDER BY clause are considered to be within the group-scope, and not the from-scope.</span></span> <span data-ttu-id="579c5-182">Les agrégats reçoivent un traitement spécial, tel que cela est décrit dans la liste à puce ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="579c5-182">Aggregates receive special treatment, as described in the following bulleted list.</span></span>  
  
 <span data-ttu-id="579c5-183">Remarques supplémentaires sur les étendues :</span><span class="sxs-lookup"><span data-stu-id="579c5-183">The following are additional notes about scopes:</span></span>  
  
- <span data-ttu-id="579c5-184">La liste de sélection peut introduire de nouveaux noms dans l'étendue, dans l'ordre.</span><span class="sxs-lookup"><span data-stu-id="579c5-184">The select-list can introduce new names into the scope, in order.</span></span> <span data-ttu-id="579c5-185">Les expressions de projection de droite peuvent faire référence aux noms projetés de gauche.</span><span class="sxs-lookup"><span data-stu-id="579c5-185">Projection expressions to the right might refer to names projected on the left.</span></span>  
  
- <span data-ttu-id="579c5-186">La clause ORDER BY peut faire référence aux noms (alias) spécifiés dans la liste de sélection.</span><span class="sxs-lookup"><span data-stu-id="579c5-186">The ORDER BY clause can refer to names (aliases) specified in the select list.</span></span>  
  
- <span data-ttu-id="579c5-187">L'ordre d'évaluation des clauses au sein de l'expression SELECT détermine l'ordre dans lequel les noms sont introduits dans l'étendue.</span><span class="sxs-lookup"><span data-stu-id="579c5-187">The order of evaluation of clauses within the SELECT expression determines the order that names are introduced into the scope.</span></span> <span data-ttu-id="579c5-188">La clause FROM est évaluée en premier, suivie de la clause WHERE, de la clause GROUP BY, de la clause HAVING, de la clause SELECT et enfin de la clause ORDER BY.</span><span class="sxs-lookup"><span data-stu-id="579c5-188">The FROM clause is evaluated first, followed by the WHERE clause, GROUP BY clause, HAVING clause, SELECT clause, and finally the ORDER BY clause.</span></span>  
  
### <a name="aggregate-handling"></a><span data-ttu-id="579c5-189">Gestion des agrégats</span><span class="sxs-lookup"><span data-stu-id="579c5-189">Aggregate Handling</span></span>  
 [!INCLUDE[esql](../../../../../../includes/esql-md.md)] <span data-ttu-id="579c5-190">prend en charge deux formes d’agrégats : les agrégats basés sur des collections et les agrégats basés sur des groupes.</span><span class="sxs-lookup"><span data-stu-id="579c5-190">supports two forms of aggregates: collection-based aggregates and group-based aggregates.</span></span> <span data-ttu-id="579c5-191">Les agrégats basés sur les collections correspondent à la construction privilégiée dans [!INCLUDE[esql](../../../../../../includes/esql-md.md)], alors que les agrégats basés sur les groupes sont pris en charge pour la compatibilité avec SQL.</span><span class="sxs-lookup"><span data-stu-id="579c5-191">Collection-based aggregates are the preferred construct in [!INCLUDE[esql](../../../../../../includes/esql-md.md)], and group-based aggregates are supported for SQL compatibility.</span></span>  
  
 <span data-ttu-id="579c5-192">Lors de la résolution d’un agrégat, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] essaie d’abord de le traiter comme un agrégat basé sur une collection.</span><span class="sxs-lookup"><span data-stu-id="579c5-192">When resolving an aggregate, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] first tries to treat it as a collection-based aggregate.</span></span> <span data-ttu-id="579c5-193">En cas d’échec, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] transforme l’entrée d’agrégation en une référence à l’agrégat d’imbrication et tente de résoudre cette nouvelle expression, comme illustré dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="579c5-193">If that fails, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] transforms the aggregate input into a reference to the nest aggregate and tries to resolve this new expression, as illustrated in the following example.</span></span>  
  
 `AVG(t.c) becomes AVG(group..(t.c))`  
  
## <a name="see-also"></a><span data-ttu-id="579c5-194">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="579c5-194">See also</span></span>

- [<span data-ttu-id="579c5-195">Référence Entity SQL</span><span class="sxs-lookup"><span data-stu-id="579c5-195">Entity SQL Reference</span></span>](entity-sql-reference.md)
- [<span data-ttu-id="579c5-196">Vue d’ensemble d’Entity SQL</span><span class="sxs-lookup"><span data-stu-id="579c5-196">Entity SQL Overview</span></span>](entity-sql-overview.md)
- [<span data-ttu-id="579c5-197">Jeu de caractères en entrée</span><span class="sxs-lookup"><span data-stu-id="579c5-197">Input Character Set</span></span>](input-character-set-entity-sql.md)
