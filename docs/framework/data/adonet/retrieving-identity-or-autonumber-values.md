---
title: Extraction de l'identité ou de valeurs à numérotation automatique
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d6b7f9cb-81be-44e1-bb94-56137954876d
ms.openlocfilehash: 1387dad1f588770384422bf579ed547271b30c0a
ms.sourcegitcommit: d2e1dfa7ef2d4e9ffae3d431cf6a4ffd9c8d378f
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/07/2019
ms.locfileid: "70794551"
---
# <a name="retrieving-identity-or-autonumber-values"></a><span data-ttu-id="516e8-102">Extraction de l'identité ou de valeurs à numérotation automatique</span><span class="sxs-lookup"><span data-stu-id="516e8-102">Retrieving Identity or Autonumber Values</span></span>

<span data-ttu-id="516e8-103">Dans une base de données relationnelle, une clé primaire est une colonne ou une combinaison de colonnes qui contient toujours des valeurs uniques.</span><span class="sxs-lookup"><span data-stu-id="516e8-103">A primary key in a relational database is a column or combination of columns that always contain unique values.</span></span> <span data-ttu-id="516e8-104">Si vous connaissez la valeur d'une clé primaire, vous pouvez rechercher la ligne qui la contient.</span><span class="sxs-lookup"><span data-stu-id="516e8-104">Knowing the primary key value allows you to locate the row that contains it.</span></span> <span data-ttu-id="516e8-105">Les moteurs de base de données relationnelle, comme SQL Server, Oracle et Microsoft Access/Jet prennent en charge la création de colonnes à incrémentation automatique qui peuvent être désignées comme clés primaires.</span><span class="sxs-lookup"><span data-stu-id="516e8-105">Relational database engines, such as SQL Server, Oracle, and Microsoft Access/Jet support the creation of automatically incrementing columns that can be designated as primary keys.</span></span> <span data-ttu-id="516e8-106">Ces valeurs sont générées par le serveur lorsque des lignes sont ajoutées à une table.</span><span class="sxs-lookup"><span data-stu-id="516e8-106">These values are generated by the server as rows are added to a table.</span></span> <span data-ttu-id="516e8-107">Dans SQL Server, vous définissez la propriété d'identité d'une colonne, dans Oracle vous créez une séquence et dans Microsoft Access vous créez une colonne NuméroAuto.</span><span class="sxs-lookup"><span data-stu-id="516e8-107">In SQL Server, you set the identity property of a column, in Oracle you create a Sequence, and in Microsoft Access you create an AutoNumber column.</span></span>

<span data-ttu-id="516e8-108">Un objet <xref:System.Data.DataColumn> peut également être utilisé pour générer des valeurs d'auto-incrémentation en affectant la valeur true à <xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="516e8-108">A <xref:System.Data.DataColumn> can also be used to generate automatically incrementing values by setting the <xref:System.Data.DataColumn.AutoIncrement%2A> property to true.</span></span> <span data-ttu-id="516e8-109">Cependant, vous risquez de vous retrouver avec des valeurs dupliquées dans des instances distinctes d'un objet <xref:System.Data.DataTable>, si plusieurs applications clientes génèrent chacune de leur côté des valeurs d'auto-incrémentation.</span><span class="sxs-lookup"><span data-stu-id="516e8-109">However, you might end up with duplicate values in separate instances of a <xref:System.Data.DataTable>, if multiple client applications are independently generating automatically incrementing values.</span></span> <span data-ttu-id="516e8-110">Le fait de laisser le serveur générer des valeurs d'auto-incrémentation supprime les conflits potentiels en permettant à chaque utilisateur de récupérer la valeur générée pour chaque ligne insérée.</span><span class="sxs-lookup"><span data-stu-id="516e8-110">Having the server generate automatically incrementing values eliminates potential conflicts by allowing each user to retrieve the generated value for each inserted row.</span></span>

<span data-ttu-id="516e8-111">Au cours d'un appel de la méthode `Update` d'un objet `DataAdapter`, la base de données peut renvoyer des données à votre application ADO.NET sous la forme de paramètres de sortie ou de premier enregistrement retourné du jeu de résultats d'une instruction SELECT exécutée dans le même lot que l'instruction INSERT.</span><span class="sxs-lookup"><span data-stu-id="516e8-111">During a call to the `Update` method of a `DataAdapter`, the database can send data back to your ADO.NET application as output parameters or as the first returned record of the result set of a SELECT statement executed in the same batch as the INSERT statement.</span></span> <span data-ttu-id="516e8-112">ADO.NET peut récupérer ces valeurs et mettre à jour les colonnes correspondantes dans l'objet <xref:System.Data.DataRow> en cours de mise à jour.</span><span class="sxs-lookup"><span data-stu-id="516e8-112">ADO.NET can retrieve these values and update the corresponding columns in the <xref:System.Data.DataRow> being updated.</span></span>

<span data-ttu-id="516e8-113">Certains moteurs de base de données, comme Microsoft Access Jet, ne prennent pas en charge les paramètres de sortie et ne peuvent pas traiter plusieurs instructions dans un même lot.</span><span class="sxs-lookup"><span data-stu-id="516e8-113">Some database engines, such as the Microsoft Access Jet database engine, do not support output parameters and cannot process multiple statements in a single batch.</span></span> <span data-ttu-id="516e8-114">Avec le moteur de base de données Jet, vous pouvez récupérer la nouvelle valeur NuméroAuto générée pour une ligne insérée en exécutant une commande SELECT distincte dans un gestionnaire d'événements pour l'événement `RowUpdated` de l'objet `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="516e8-114">When working with the Jet database engine, you can retrieve the new AutoNumber value generated for an inserted row by executing a separate SELECT command in an event handler for the `RowUpdated` event of the `DataAdapter`.</span></span>

> [!NOTE]
> <span data-ttu-id="516e8-115">Plutôt que d'utiliser une valeur d'auto-incrémentation, vous pouvez utiliser la méthode <xref:System.Guid.NewGuid%2A> d'un objet <xref:System.Guid> pour générer un GUID, ou identificateur global unique, sur l'ordinateur client qui peut être copié sur le serveur dès qu'une nouvelle ligne est insérée.</span><span class="sxs-lookup"><span data-stu-id="516e8-115">An alternative to using an auto incrementing value is to use the <xref:System.Guid.NewGuid%2A> method of a <xref:System.Guid> object to generate a GUID, or globally unique identifier, on the client computer that can be copied to the server as each new row is inserted.</span></span> <span data-ttu-id="516e8-116">La méthode `NewGuid` génère une valeur binaire encodée sur 16 octets créée à l'aide d'un algorithme qui offre une forte probabilité qu'aucun valeur ne sera dupliquée.</span><span class="sxs-lookup"><span data-stu-id="516e8-116">The `NewGuid` method generates a 16-byte binary value that is created using an algorithm that provides a high probability that no value will be duplicated.</span></span> <span data-ttu-id="516e8-117">Dans une base de données SQL Server, un GUID est stocké dans une colonne `uniqueidentifier` qui peut être générée automatiquement par SQL Server à l'aide de la fonction `NEWID()` Transact-SQL.</span><span class="sxs-lookup"><span data-stu-id="516e8-117">In a SQL Server database, a GUID is stored in a `uniqueidentifier` column which SQL Server can automatically generate using the Transact-SQL `NEWID()` function.</span></span> <span data-ttu-id="516e8-118">L'utilisation d'un GUID comme clé primaire peut nuire aux performances.</span><span class="sxs-lookup"><span data-stu-id="516e8-118">Using a GUID as a primary key can adversely affect performance.</span></span> <span data-ttu-id="516e8-119">SQL Server prend en charge la `NEWSEQUENTIALID()` fonction, qui génère un GUID séquentiel dont l’unicité globale n’est pas garantie, mais qui peut être indexé de manière plus efficace.</span><span class="sxs-lookup"><span data-stu-id="516e8-119">SQL Server provides support for the `NEWSEQUENTIALID()` function, which generates a sequential GUID that is not guaranteed to be globally unique but that can be indexed more efficiently.</span></span>

## <a name="retrieving-sql-server-identity-column-values"></a><span data-ttu-id="516e8-120">Extraction de valeurs de colonne d'identité SQL Server</span><span class="sxs-lookup"><span data-stu-id="516e8-120">Retrieving SQL Server Identity Column Values</span></span>

<span data-ttu-id="516e8-121">Avec Microsoft SQL Server, vous pouvez créer une procédure stockée contenant un paramètre de sortie qui permet de retourner la valeur d'identité d'une ligne insérée.</span><span class="sxs-lookup"><span data-stu-id="516e8-121">When working with Microsoft SQL Server, you can create a stored procedure with an output parameter to return the identity value for an inserted row.</span></span> <span data-ttu-id="516e8-122">Le tableau suivant décrit les trois fonctions Transact-SQL disponibles dans SQL Server qui peuvent être utilisées pour récupérer la valeur des colonnes d'identité.</span><span class="sxs-lookup"><span data-stu-id="516e8-122">The following table describes the three Transact-SQL functions in SQL Server that can be used to retrieve identity column values.</span></span>

|<span data-ttu-id="516e8-123">Fonction</span><span class="sxs-lookup"><span data-stu-id="516e8-123">Function</span></span>|<span data-ttu-id="516e8-124">Description</span><span class="sxs-lookup"><span data-stu-id="516e8-124">Description</span></span>|
|--------------|-----------------|
|<span data-ttu-id="516e8-125">SCOPE_IDENTITY</span><span class="sxs-lookup"><span data-stu-id="516e8-125">SCOPE_IDENTITY</span></span>|<span data-ttu-id="516e8-126">Retourne la dernière valeur d'identité de la portée d'exécution actuelle.</span><span class="sxs-lookup"><span data-stu-id="516e8-126">Returns the last identity value within the current execution scope.</span></span> <span data-ttu-id="516e8-127">La fonction SCOPE_IDENTITY est recommandée dans la plupart des scénarios.</span><span class="sxs-lookup"><span data-stu-id="516e8-127">SCOPE_IDENTITY is recommended for most scenarios.</span></span>|
|<span data-ttu-id="516e8-128">@@IDENTITY</span><span class="sxs-lookup"><span data-stu-id="516e8-128">@@IDENTITY</span></span>|<span data-ttu-id="516e8-129">Contient la dernière valeur d'identité générée dans toute table de la session active.</span><span class="sxs-lookup"><span data-stu-id="516e8-129">Contains the last identity value generated in any table in the current session.</span></span> <span data-ttu-id="516e8-130">@@IDENTITY peut être affecté par les déclencheurs et peut ne pas retourner la valeur d’identité que vous attendez.</span><span class="sxs-lookup"><span data-stu-id="516e8-130">@@IDENTITY can be affected by triggers and may not return the identity value that you expect.</span></span>|
|<span data-ttu-id="516e8-131">IDENT_CURRENT</span><span class="sxs-lookup"><span data-stu-id="516e8-131">IDENT_CURRENT</span></span>|<span data-ttu-id="516e8-132">Retourne la dernière valeur d'identité générée pour une table spécifique dans toute session et portée.</span><span class="sxs-lookup"><span data-stu-id="516e8-132">Returns the last identity value generated for a specific table in any session and any scope.</span></span>|

 <span data-ttu-id="516e8-133">La procédure stockée suivante montre comment insérer une ligne dans la table **categories** et utiliser un paramètre de sortie pour retourner la nouvelle valeur d’identité générée par la fonction SCOPE_IDENTITY () de Transact-SQL.</span><span class="sxs-lookup"><span data-stu-id="516e8-133">The following stored procedure demonstrates how to insert a row into the **Categories** table and use an output parameter to return the new identity value generated by the Transact-SQL SCOPE_IDENTITY() function.</span></span>

```sql
CREATE PROCEDURE dbo.InsertCategory
  @CategoryName nvarchar(15),
  @Identity int OUT
AS
INSERT INTO Categories (CategoryName) VALUES(@CategoryName)
SET @Identity = SCOPE_IDENTITY()
```

<span data-ttu-id="516e8-134">La procédure stockée peut ensuite être spécifiée comme source de la propriété <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> d'un objet <xref:System.Data.SqlClient.SqlDataAdapter>.</span><span class="sxs-lookup"><span data-stu-id="516e8-134">The stored procedure can then be specified as the source of the <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> of a <xref:System.Data.SqlClient.SqlDataAdapter> object.</span></span> <span data-ttu-id="516e8-135">La propriété <xref:System.Data.SqlClient.SqlCommand.CommandType%2A> de la propriété <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> doit avoir la valeur <xref:System.Data.CommandType.StoredProcedure>.</span><span class="sxs-lookup"><span data-stu-id="516e8-135">The <xref:System.Data.SqlClient.SqlCommand.CommandType%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> must be set to <xref:System.Data.CommandType.StoredProcedure>.</span></span> <span data-ttu-id="516e8-136">La sortie d'identité est récupérée en créant un objet <xref:System.Data.SqlClient.SqlParameter> dont un objet <xref:System.Data.ParameterDirection> a la valeur <xref:System.Data.ParameterDirection.Output>.</span><span class="sxs-lookup"><span data-stu-id="516e8-136">The identity output is retrieved by creating a <xref:System.Data.SqlClient.SqlParameter> that has a <xref:System.Data.ParameterDirection> of <xref:System.Data.ParameterDirection.Output>.</span></span> <span data-ttu-id="516e8-137">Lorsque le `InsertCommand` est traité, la valeur d’identité auto-incrémentée est retournée et placée dans la colonne **CategoryID** de la ligne actuelle si vous <xref:System.Data.SqlClient.SqlCommand.UpdatedRowSource%2A> affectez à la propriété de `UpdateRowSource.OutputParameters` la commande `UpdateRowSource.Both`Insert la valeur ou à.</span><span class="sxs-lookup"><span data-stu-id="516e8-137">When the `InsertCommand` is processed, the auto-incremented identity value is returned and placed in the **CategoryID** column of the current row if you set the <xref:System.Data.SqlClient.SqlCommand.UpdatedRowSource%2A> property of the insert command to `UpdateRowSource.OutputParameters` or to `UpdateRowSource.Both`.</span></span>

<span data-ttu-id="516e8-138">Si la commande d'insertion exécute un lot qui comprend à la fois une instruction INSERT et une instruction SELECT qui retourne la nouvelle valeur d'identité, vous pouvez alors récupérer la nouvelle valeur en affectant la valeur `UpdatedRowSource` à la propriété `UpdateRowSource.FirstReturnedRecord`.</span><span class="sxs-lookup"><span data-stu-id="516e8-138">If your insert command executes a batch that includes both an INSERT statement and a SELECT statement that returns the new identity value, then you can retrieve the new value by setting the `UpdatedRowSource` property of the insert command to `UpdateRowSource.FirstReturnedRecord`.</span></span>

[!code-csharp[DataWorks SqlClient.RetrieveIdentityStoredProcedure#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.RetrieveIdentityStoredProcedure/CS/source.cs#1)]
[!code-vb[DataWorks SqlClient.RetrieveIdentityStoredProcedure#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.RetrieveIdentityStoredProcedure/VB/source.vb#1)]

## <a name="merging-new-identity-values"></a><span data-ttu-id="516e8-139">Fusion des nouvelles valeurs d'identité</span><span class="sxs-lookup"><span data-stu-id="516e8-139">Merging New Identity Values</span></span>

<span data-ttu-id="516e8-140">Un scénario courant consiste à appeler la méthode `GetChanges` d'un objet `DataTable` pour créer une copie qui contient uniquement les lignes modifiées et pour utiliser une nouvelle copie lors de l'appel de la méthode `Update` d'un objet `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="516e8-140">A common scenario is to call the `GetChanges` method of a `DataTable` to create a copy that contains only changed rows, and to use the new copy when calling the `Update` method of a `DataAdapter`.</span></span> <span data-ttu-id="516e8-141">Ceci s'avère très utile lorsque vous avez besoin de marshaler les lignes modifiées dans un autre composant qui effectue la mise à jour.</span><span class="sxs-lookup"><span data-stu-id="516e8-141">This is especially useful when you need to marshal the changed rows to a separate component that performs the update.</span></span> <span data-ttu-id="516e8-142">Après la mise à jour, la copie peut contenir les nouvelles valeurs d'identité qui doivent ensuite être de nouveau fusionnées dans l'objet `DataTable` d'origine.</span><span class="sxs-lookup"><span data-stu-id="516e8-142">Following the update, the copy can contain new identity values that must then be merged back into the original `DataTable`.</span></span> <span data-ttu-id="516e8-143">Il est probable que les nouvelles valeurs d'identité soient différentes des valeurs d'origine de l'objet `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="516e8-143">The new identity values are likely to be different from the original values in the `DataTable`.</span></span> <span data-ttu-id="516e8-144">Pour effectuer la fusion, les valeurs d’origine des colonnes **AutoIncrement** de la copie doivent être conservées, afin de pouvoir Rechercher et mettre à jour les lignes existantes dans le `DataTable`d’origine, au lieu d’ajouter de nouvelles lignes contenant les nouvelles valeurs d’identité. .</span><span class="sxs-lookup"><span data-stu-id="516e8-144">To accomplish the merge, the original values of the **AutoIncrement** columns in the copy must be preserved, in order to be able to locate and update existing rows in the original `DataTable`, rather than appending new rows containing the new identity values.</span></span> <span data-ttu-id="516e8-145">Pourtant, par défaut ces valeurs d'origine sont perdues après un appel de la méthode `Update` d'un objet `DataAdapter`, car la méthode `AcceptChanges` est appelée implicitement pour chaque objet `DataRow` mis à jour.</span><span class="sxs-lookup"><span data-stu-id="516e8-145">However, by default those original values are lost after a call to the `Update` method of a `DataAdapter`, because `AcceptChanges` is implicitly called for each updated `DataRow`.</span></span>

<span data-ttu-id="516e8-146">Il existe deux façons de conserver les valeurs d'origine d'un objet `DataColumn` dans un objet `DataRow` pendant la mise à jour d'un objet `DataAdapter` :</span><span class="sxs-lookup"><span data-stu-id="516e8-146">There are two ways to preserve the original values of a `DataColumn` in a `DataRow` during a `DataAdapter` update:</span></span>

- <span data-ttu-id="516e8-147">La première méthode de conservation des valeurs d'origine consiste à affecter la valeur `AcceptChangesDuringUpdate` à la propriété `DataAdapter` de l'objet `false`.</span><span class="sxs-lookup"><span data-stu-id="516e8-147">The first method of preserving the original values is to set the `AcceptChangesDuringUpdate` property of the `DataAdapter` to `false`.</span></span> <span data-ttu-id="516e8-148">Cela affecte tous les objets `DataRow` de l'objet `DataTable` en cours de mise à jour.</span><span class="sxs-lookup"><span data-stu-id="516e8-148">This affects every `DataRow` in the `DataTable` being updated.</span></span> <span data-ttu-id="516e8-149">Pour obtenir des informations supplémentaires ainsi qu'un exemple de code, consultez <xref:System.Data.Common.DataAdapter.AcceptChangesDuringUpdate%2A>.</span><span class="sxs-lookup"><span data-stu-id="516e8-149">For more information and a code example, see <xref:System.Data.Common.DataAdapter.AcceptChangesDuringUpdate%2A>.</span></span>

- <span data-ttu-id="516e8-150">La seconde méthode consiste à écrire du code dans le gestionnaire d'événements `RowUpdated` de l'objet `DataAdapter` de manière à affecter la valeur <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> à la propriété <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span><span class="sxs-lookup"><span data-stu-id="516e8-150">The second method is to write code in the `RowUpdated` event handler of the `DataAdapter` to set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> to <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span></span> <span data-ttu-id="516e8-151">L'objet `DataRow` est mis à jour mais la valeur d'origine de chaque objet `DataColumn` est conservée.</span><span class="sxs-lookup"><span data-stu-id="516e8-151">The `DataRow` is updated but the original value of each `DataColumn` is preserved.</span></span> <span data-ttu-id="516e8-152">Cette méthode permet de conserver la valeur d'origine de certaines lignes et pas d'autres.</span><span class="sxs-lookup"><span data-stu-id="516e8-152">This method enables you to preserve the original values for some rows and not for others.</span></span> <span data-ttu-id="516e8-153">Votre code peut par exemple conserver les valeurs d'origine des lignes ajoutées, mais pas des lignes modifiées ou supprimées en vérifiant tout d'abord la propriété <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A>, puis en affectant la valeur <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> à la propriété <xref:System.Data.UpdateStatus.SkipCurrentRow> uniquement pour les lignes dont `StatementType` a la valeur `Insert`.</span><span class="sxs-lookup"><span data-stu-id="516e8-153">For example, your code can preserve the original values for added rows and not for edited or deleted rows by first checking the <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> and then setting <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> to <xref:System.Data.UpdateStatus.SkipCurrentRow> only for rows with a `StatementType` of `Insert`.</span></span>

<span data-ttu-id="516e8-154">Si l'une de ces méthodes est utilisée pour conserver les valeurs d'origine dans un objet `DataRow` au cours de la mise à jour d'un objet `DataAdapter`, ADO.NET effectue une série d'actions afin d'affecter à l'objet `DataRow` les nouvelles valeurs retournées par des paramètres de sortie ou par la première ligne retournée d'un jeu de résultats, tout en continuant de conserver la valeur d'origine dans chaque objet `DataColumn`.</span><span class="sxs-lookup"><span data-stu-id="516e8-154">When either of these methods is used to preserve original values in a `DataRow` during a `DataAdapter` update, ADO.NET performs a series of actions to set the current values of the `DataRow` to new values returned by output parameters or by the first returned row of a result set, while still preserving the original value in each `DataColumn`.</span></span> <span data-ttu-id="516e8-155">Dans un premier temps, la méthode `AcceptChanges` de l'objet `DataRow` est appelée pour conserver les valeurs actuelles comme valeurs d'origine, puis les nouvelles valeurs sont assignées.</span><span class="sxs-lookup"><span data-stu-id="516e8-155">First, the `AcceptChanges` method of the `DataRow` is called to preserve the current values as original values, and then the new values are assigned.</span></span> <span data-ttu-id="516e8-156">Suite à cela, les objets `DataRows` dont la propriété <xref:System.Data.DataRow.RowState%2A> avait la valeur <xref:System.Data.DataRowState.Added> verront leur propriété `RowState` remplacée par <xref:System.Data.DataRowState.Modified>, ce qui peut être inattendu.</span><span class="sxs-lookup"><span data-stu-id="516e8-156">Following these actions, `DataRows` that had their <xref:System.Data.DataRow.RowState%2A> property set to <xref:System.Data.DataRowState.Added> will have their `RowState` property set to <xref:System.Data.DataRowState.Modified>, which may be unexpected.</span></span>

<span data-ttu-id="516e8-157">La manière dont les résultats de la commande sont appliqués à chaque objet <xref:System.Data.DataRow> en cours de mise à jour est déterminé par la propriété <xref:System.Data.Common.DbCommand.UpdatedRowSource%2A> de chaque <xref:System.Data.Common.DbCommand>.</span><span class="sxs-lookup"><span data-stu-id="516e8-157">How the command results are applied to each <xref:System.Data.DataRow> being updated is determined by the <xref:System.Data.Common.DbCommand.UpdatedRowSource%2A> property of each <xref:System.Data.Common.DbCommand>.</span></span> <span data-ttu-id="516e8-158">Une valeur de l'énumération `UpdateRowSource` est affectée à cette propriété.</span><span class="sxs-lookup"><span data-stu-id="516e8-158">This property is set to a value from the `UpdateRowSource` enumeration.</span></span>

<span data-ttu-id="516e8-159">Le tableau suivant décrit comment les valeurs de l'énumération `UpdateRowSource` affectent la propriété <xref:System.Data.DataRow.RowState%2A> des lignes mises à jour.</span><span class="sxs-lookup"><span data-stu-id="516e8-159">The following table describes how the `UpdateRowSource` enumeration values affect the <xref:System.Data.DataRow.RowState%2A> property of updated rows.</span></span>

|<span data-ttu-id="516e8-160">Nom de membre</span><span class="sxs-lookup"><span data-stu-id="516e8-160">Member name</span></span>|<span data-ttu-id="516e8-161">Description</span><span class="sxs-lookup"><span data-stu-id="516e8-161">Description</span></span>|
|-----------------|-----------------|
|<xref:System.Data.UpdateRowSource.Both>|<span data-ttu-id="516e8-162">La méthode `AcceptChanges` est appelée et les valeurs des deux paramètres de sortie et/ou les valeurs de la première ligne de tout jeu de résultats retourné sont placées dans l'objet `DataRow` en cours de mise à jour.</span><span class="sxs-lookup"><span data-stu-id="516e8-162">`AcceptChanges` is called and both output parameter values and/or the values in the first row of any returned result set are placed in the `DataRow` being updated.</span></span> <span data-ttu-id="516e8-163">S'il n'y a aucune valeur à appliquer, l'objet `RowState` aura la valeur <xref:System.Data.DataRowState.Unchanged>.</span><span class="sxs-lookup"><span data-stu-id="516e8-163">If there are no values to apply, the `RowState` will be <xref:System.Data.DataRowState.Unchanged>.</span></span>|
|<xref:System.Data.UpdateRowSource.FirstReturnedRecord>|<span data-ttu-id="516e8-164">Si une ligne a été retournée, la méthode `AcceptChanges` est appelée et la ligne est mappée à la ligne modifiée dans l'objet `DataTable`, ce qui affecte la valeur `RowState` à `Modified`.</span><span class="sxs-lookup"><span data-stu-id="516e8-164">If a row was returned, `AcceptChanges` is called and the row is mapped to the changed row in the `DataTable`, setting the `RowState` to `Modified`.</span></span> <span data-ttu-id="516e8-165">Si aucune ligne n'est retournée, la méthode `AcceptChanges` n'est pas appelée et l'objet `RowState` conserve la valeur `Added`.</span><span class="sxs-lookup"><span data-stu-id="516e8-165">If no row is returned, then `AcceptChanges` is not called and the `RowState` remains `Added`.</span></span>|
|<xref:System.Data.UpdateRowSource.None>|<span data-ttu-id="516e8-166">Tous les paramètres et toutes les lignes retournés sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="516e8-166">Any returned parameters or rows are ignored.</span></span> <span data-ttu-id="516e8-167">La méthode `AcceptChanges` n'est pas appelée et `RowState` conserve la valeur `Added`.</span><span class="sxs-lookup"><span data-stu-id="516e8-167">There is no call to `AcceptChanges` and the `RowState` remains `Added`.</span></span>|
|<xref:System.Data.UpdateRowSource.OutputParameters>|<span data-ttu-id="516e8-168">La méthode `AcceptChanges` est appelée et tout paramètre de sortie est mappé à la ligne modifiée dans l'objet `DataTable`, ce qui affecte la valeur `RowState` à l'objet `Modified`.</span><span class="sxs-lookup"><span data-stu-id="516e8-168">`AcceptChanges` is called and any output parameters are mapped to the changed row in the `DataTable`, setting the `RowState` to `Modified`.</span></span> <span data-ttu-id="516e8-169">S'il n'existe aucun paramètres de sortie, l'objet `RowState` aura la valeur `Unchanged`.</span><span class="sxs-lookup"><span data-stu-id="516e8-169">If there are no output parameters, the `RowState` will be `Unchanged`.</span></span>|

### <a name="example"></a><span data-ttu-id="516e8-170">Exemple</span><span class="sxs-lookup"><span data-stu-id="516e8-170">Example</span></span>

<span data-ttu-id="516e8-171">Cet exemple illustre l'extraction des lignes modifiées d'un objet `DataTable` et l'utilisation d'un objet <xref:System.Data.SqlClient.SqlDataAdapter> pour mettre à jour la source de données et récupérer une nouvelle valeur de colonne d'identité.</span><span class="sxs-lookup"><span data-stu-id="516e8-171">This example demonstrates extracting changed rows from a `DataTable` and using a <xref:System.Data.SqlClient.SqlDataAdapter> to update the data source and retrieve a new identity column value.</span></span> <span data-ttu-id="516e8-172">La propriété <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> exécute deux instructions Transact-SQL (INSERT et SELECT) qui utilisent la fonction SCOPE_IDENTITY pour récupérer la valeur d'identité.</span><span class="sxs-lookup"><span data-stu-id="516e8-172">The <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> executes two Transact-SQL statements; the first one is the INSERT statement, and the second one is a SELECT statement that uses the SCOPE_IDENTITY function to retrieve the identity value.</span></span>

```sql
INSERT INTO dbo.Shippers (CompanyName)
VALUES (@CompanyName);
SELECT ShipperID, CompanyName FROM dbo.Shippers
WHERE ShipperID = SCOPE_IDENTITY();
```

<span data-ttu-id="516e8-173">La propriété `UpdatedRowSource` de la commande d'insertion a la valeur `UpdateRowSource.FirstReturnedRow` et la propriété <xref:System.Data.MissingSchemaAction> de l'objet `DataAdapter` a la valeur `MissingSchemaAction.AddWithKey`.</span><span class="sxs-lookup"><span data-stu-id="516e8-173">The `UpdatedRowSource` property of the insert command is set to `UpdateRowSource.FirstReturnedRow` and the <xref:System.Data.MissingSchemaAction> property of the `DataAdapter` is set to `MissingSchemaAction.AddWithKey`.</span></span> <span data-ttu-id="516e8-174">L'objet `DataTable` est rempli et le code ajoute une nouvelle ligne à l'objet `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="516e8-174">The `DataTable` is filled and the code adds a new row to the `DataTable`.</span></span> <span data-ttu-id="516e8-175">Les lignes modifiées sont ensuite extraites dans un nouvel objet `DataTable`, qui est passé à l'objet `DataAdapter`, qui met ensuite à jour le serveur.</span><span class="sxs-lookup"><span data-stu-id="516e8-175">The changed rows are then extracted into a new `DataTable`, which is passed to the `DataAdapter`, which then updates the server.</span></span>

[!code-csharp[DataWorks SqlClient.MergeIdentity#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/CS/source.cs#1)]
[!code-vb[DataWorks SqlClient.MergeIdentity#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/VB/source.vb#1)]

<span data-ttu-id="516e8-176">Le gestionnaire d'événements `OnRowUpdated` vérifie la propriété <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> de l'objet <xref:System.Data.SqlClient.SqlRowUpdatedEventArgs> de manière à déterminer si la ligne est une insertion.</span><span class="sxs-lookup"><span data-stu-id="516e8-176">The `OnRowUpdated` event handler checks the <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> of the <xref:System.Data.SqlClient.SqlRowUpdatedEventArgs> to determine if the row is an insert.</span></span> <span data-ttu-id="516e8-177">S'il s'agit d'une insertion, la propriété <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> a la valeur <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span><span class="sxs-lookup"><span data-stu-id="516e8-177">If it is, then the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property is set to <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span></span> <span data-ttu-id="516e8-178">La ligne est mise à jour, mais ses valeurs d'origine sont conservées.</span><span class="sxs-lookup"><span data-stu-id="516e8-178">The row is updated, but the original values in the row are preserved.</span></span> <span data-ttu-id="516e8-179">Dans le corps principal de la procédure, la méthode <xref:System.Data.DataSet.Merge%2A> est appelée pour fusionner la nouvelle valeur d'identité dans l'objet `DataTable` d'origine et pour finir la méthode `AcceptChanges` est appelée.</span><span class="sxs-lookup"><span data-stu-id="516e8-179">In the main body of the procedure, the <xref:System.Data.DataSet.Merge%2A> method is called to merge the new identity value into the original `DataTable`, and finally `AcceptChanges` is called.</span></span>

[!code-csharp[DataWorks SqlClient.MergeIdentity#2](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/CS/source.cs#2)]
[!code-vb[DataWorks SqlClient.MergeIdentity#2](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/VB/source.vb#2)]

## <a name="retrieving-microsoft-access-autonumber-values"></a><span data-ttu-id="516e8-180">Extraction des valeurs de champs NuméroAuto de Microsoft Access</span><span class="sxs-lookup"><span data-stu-id="516e8-180">Retrieving Microsoft Access Autonumber Values</span></span>

<span data-ttu-id="516e8-181">Cette section comprend un exemple qui montre comment récupérer des valeurs `Autonumber` dans une base de données Jet 4.0.</span><span class="sxs-lookup"><span data-stu-id="516e8-181">This section includes a sample that shows how to retrieve `Autonumber` values from a Jet 4.0 database.</span></span> <span data-ttu-id="516e8-182">Le moteur de base de données Jet ne prend pas en charge l'exécution de plusieurs instructions dans un lot ni l'utilisation de paramètres de sortie. Il n'est donc pas possible d'utiliser l'une ou l'autre de ces techniques pour retourner la nouvelle valeur `Autonumber` assignée à la ligne insérée.</span><span class="sxs-lookup"><span data-stu-id="516e8-182">The Jet database engine does not support the execution of multiple statements in a batch or the use of output parameters, so it is not possible to use either of these techniques to return the new `Autonumber` value assigned to an inserted row.</span></span> <span data-ttu-id="516e8-183">Toutefois, vous pouvez ajouter du code au `RowUpdated` gestionnaire d’événements qui exécute une instruction SELECT @@IDENTITY distincte pour récupérer la nouvelle `Autonumber` valeur.</span><span class="sxs-lookup"><span data-stu-id="516e8-183">However, you can add code to the `RowUpdated` event handler that executes a separate SELECT @@IDENTITY statement to retrieve the new `Autonumber` value.</span></span>

### <a name="example"></a><span data-ttu-id="516e8-184">Exemple</span><span class="sxs-lookup"><span data-stu-id="516e8-184">Example</span></span>

<span data-ttu-id="516e8-185">Plutôt que d'ajouter des informations de schéma à l'aide de `MissingSchemaAction.AddWithKey`, cet exemple configure un objet `DataTable` avec le schéma correct avant d'appeler l'objet <xref:System.Data.OleDb.OleDbDataAdapter> pour remplir l'objet `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="516e8-185">Instead of adding schema information using `MissingSchemaAction.AddWithKey`, this example configures a `DataTable` with the correct schema prior to calling the <xref:System.Data.OleDb.OleDbDataAdapter> to fill the `DataTable`.</span></span> <span data-ttu-id="516e8-186">Dans ce cas, la **colonne CategoryID** est configurée de façon à décrémenter la valeur assignée à chaque ligne insérée à <xref:System.Data.DataColumn.AutoIncrementSeed%2A> partir de zéro, <xref:System.Data.DataColumn.AutoIncrementStep%2A> en affectant <xref:System.Data.DataColumn.AutoIncrement%2A> `true`à la valeur, la valeur 0 à et la valeur-1 à.</span><span class="sxs-lookup"><span data-stu-id="516e8-186">In this case, the **CategoryID** column is configured to decrement the value assigned each inserted row starting from zero, by setting <xref:System.Data.DataColumn.AutoIncrement%2A> to `true`, <xref:System.Data.DataColumn.AutoIncrementSeed%2A> to 0, and <xref:System.Data.DataColumn.AutoIncrementStep%2A> to -1.</span></span> <span data-ttu-id="516e8-187">Le code ajoute ensuite deux nouvelles lignes et utilise `GetChanges` pour ajouter les lignes modifiées à un nouvel objet `DataTable` qui est passé à la méthode `Update`.</span><span class="sxs-lookup"><span data-stu-id="516e8-187">The code then adds two new rows and uses `GetChanges` to add the changed rows to a new `DataTable` that is passed to the `Update` method.</span></span>

[!code-csharp[DataWorks OleDb.JetAutonumberMerge#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/CS/source.cs#1)]
[!code-vb[DataWorks OleDb.JetAutonumberMerge#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/VB/source.vb#1)]

<span data-ttu-id="516e8-188">Le gestionnaire d'événements `RowUpdated` utilise le même objet <xref:System.Data.OleDb.OleDbConnection> ouvert que l'instruction `Update` de l'objet `OleDbDataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="516e8-188">The `RowUpdated` event handler uses the same open <xref:System.Data.OleDb.OleDbConnection> as the `Update` statement of the `OleDbDataAdapter`.</span></span> <span data-ttu-id="516e8-189">Il vérifie le `StatementType` de l'objet <xref:System.Data.OleDb.OleDbRowUpdatedEventArgs> pour les lignes insérées.</span><span class="sxs-lookup"><span data-stu-id="516e8-189">It checks the `StatementType` of the <xref:System.Data.OleDb.OleDbRowUpdatedEventArgs> for inserted rows.</span></span> <span data-ttu-id="516e8-190">Pour chaque ligne insérée, <xref:System.Data.OleDb.OleDbCommand> une nouvelle est créée pour exécuter l'@IDENTITY instruction SELECT @ sur la connexion, en `Autonumber` retournant la nouvelle valeur, qui `DataRow`est placée dans la colonne CategoryID de.</span><span class="sxs-lookup"><span data-stu-id="516e8-190">For each inserted row a new <xref:System.Data.OleDb.OleDbCommand> is created to execute the SELECT @@IDENTITY statement on the connection, returning the new `Autonumber` value, which is placed in the **CategoryID** column of the `DataRow`.</span></span> <span data-ttu-id="516e8-191">La valeur `Status` est ensuite affectée à la propriété `UpdateStatus.SkipCurrentRow` pour supprimer l'appel masqué à la méthode `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="516e8-191">The `Status` property is then set to `UpdateStatus.SkipCurrentRow` to suppress the hidden call to `AcceptChanges`.</span></span> <span data-ttu-id="516e8-192">Dans le corps principal de la procédure, la méthode `Merge` est appelée pour fusionner les deux objets `DataTable` et pour finir la méthode `AcceptChanges` est appelée.</span><span class="sxs-lookup"><span data-stu-id="516e8-192">In the main body of the procedure, the `Merge` method is called to merge the two `DataTable` objects, and finally `AcceptChanges` is called.</span></span>

[!code-csharp[DataWorks OleDb.JetAutonumberMerge#2](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/CS/source.cs#2)]
[!code-vb[DataWorks OleDb.JetAutonumberMerge#2](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/VB/source.vb#2)]

### <a name="retrieving-identity-values"></a><span data-ttu-id="516e8-193">Récupération de valeurs d'identité</span><span class="sxs-lookup"><span data-stu-id="516e8-193">Retrieving Identity Values</span></span>

<span data-ttu-id="516e8-194">Nous définissons souvent la colonne en tant qu'identité lorsque les valeurs de la colonne doivent être uniques.</span><span class="sxs-lookup"><span data-stu-id="516e8-194">We often set the column as identity when the values in the column must be unique.</span></span> <span data-ttu-id="516e8-195">Et nous avons parfois besoin de la valeur d'identité de nouvelles données.</span><span class="sxs-lookup"><span data-stu-id="516e8-195">And sometimes we need the identity value of new data.</span></span> <span data-ttu-id="516e8-196">Cet exemple montre comment récupérer des valeurs d'identité :</span><span class="sxs-lookup"><span data-stu-id="516e8-196">This sample demonstrates how to retrieve identity values:</span></span>

- <span data-ttu-id="516e8-197">Il crée une procédure stockée pour insérer des données et retourner une valeur d'identité.</span><span class="sxs-lookup"><span data-stu-id="516e8-197">Creates a stored procedure to insert data and return an identity value.</span></span>

- <span data-ttu-id="516e8-198">Il exécute une commande pour insérer les nouvelles données et afficher le résultat.</span><span class="sxs-lookup"><span data-stu-id="516e8-198">Executes a command to insert the new data and display the result.</span></span>

- <span data-ttu-id="516e8-199">Il utilise <xref:System.Data.SqlClient.SqlDataAdapter> pour insérer de nouvelles données et afficher le résultat.</span><span class="sxs-lookup"><span data-stu-id="516e8-199">Uses <xref:System.Data.SqlClient.SqlDataAdapter> to insert new data and display the result.</span></span>

<span data-ttu-id="516e8-200">Avant de compiler et d'exécuter l'exemple, vous devez créer l'exemple de base de données, à l'aide du script suivant :</span><span class="sxs-lookup"><span data-stu-id="516e8-200">Before you compile and run the sample, you must create the sample database, using the following script:</span></span>

```sql
USE [master]
GO

CREATE DATABASE [MySchool]
GO

USE [MySchool]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [dbo].[CourseExtInfo] @CourseId int
as
select c.CourseID,c.Title,c.Credits,d.Name as DepartmentName
from Course as c left outer join Department as d on c.DepartmentID=d.DepartmentID
where c.CourseID=@CourseId

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create procedure [dbo].[DepartmentInfo] @DepartmentId int,@CourseCount int output
as
select @CourseCount=Count(c.CourseID)
from course as c
where c.DepartmentID=@DepartmentId

select d.DepartmentID,d.Name,d.Budget,d.StartDate,d.Administrator
from Department as d
where d.DepartmentID=@DepartmentId

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
Create PROCEDURE [dbo].[GetDepartmentsOfSpecifiedYear]
@Year int,@BudgetSum money output
AS
BEGIN
        SELECT @BudgetSum=SUM([Budget])
  FROM [MySchool].[dbo].[Department]
  Where YEAR([StartDate])=@Year

SELECT [DepartmentID]
      ,[Name]
      ,[Budget]
      ,[StartDate]
      ,[Administrator]
  FROM [MySchool].[dbo].[Department]
  Where YEAR([StartDate])=@Year

END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[GradeOfStudent]
-- Add the parameters for the stored procedure here
@CourseTitle nvarchar(100),@FirstName nvarchar(50),
@LastName nvarchar(50),@Grade decimal(3,2) output
AS
BEGIN
select @Grade=Max(Grade)
from [dbo].[StudentGrade] as s join [dbo].[Course] as c on
s.CourseID=c.CourseID join [dbo].[Person] as p on s.StudentID=p.PersonID
where c.Title=@CourseTitle and p.FirstName=@FirstName
and p.LastName= @LastName
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[InsertPerson]
-- Add the parameters for the stored procedure here
@FirstName nvarchar(50),@LastName nvarchar(50),
@PersonID int output
AS
BEGIN
    insert [dbo].[Person](LastName,FirstName) Values(@LastName,@FirstName)

    set @PersonID=SCOPE_IDENTITY()
END
Go

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,
[Year] [smallint] NOT NULL,
[Title] [nvarchar](100) NOT NULL,
[Credits] [int] NOT NULL,
[DepartmentID] [int] NOT NULL,
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED
(
[CourseID] ASC,
[Year] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,
[Name] [nvarchar](50) NOT NULL,
[Budget] [money] NOT NULL,
[StartDate] [datetime] NOT NULL,
[Administrator] [int] NULL,
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED
(
[DepartmentID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[Person]([PersonID] [int] IDENTITY(1,1) NOT NULL,
[LastName] [nvarchar](50) NOT NULL,
[FirstName] [nvarchar](50) NOT NULL,
[HireDate] [datetime] NULL,
[EnrollmentDate] [datetime] NULL,
[Picture] [varbinary](max) NULL,
 CONSTRAINT [PK_School.Student] PRIMARY KEY CLUSTERED
(
[PersonID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[StudentGrade]([EnrollmentID] [int] IDENTITY(1,1) NOT NULL,
[CourseID] [nvarchar](10) NOT NULL,
[StudentID] [int] NOT NULL,
[Grade] [decimal](3, 2) NOT NULL,
 CONSTRAINT [PK_StudentGrade] PRIMARY KEY CLUSTERED
(
[EnrollmentID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create view [dbo].[EnglishCourse]
as
select c.CourseID,c.Title,c.Credits,c.DepartmentID
from Course as c join Department as d on c.DepartmentID=d.DepartmentID
where d.Name=N'English'

GO
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)
SET IDENTITY_INSERT [dbo].[Department] ON

INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)
SET IDENTITY_INSERT [dbo].[Department] OFF
SET IDENTITY_INSERT [dbo].[Person] ON

INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (1, N'Hu', N'Nan', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (2, N'Norman', N'Laura', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (3, N'Olivotto', N'Nino', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (4, N'Anand', N'Arturo', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (5, N'Jai', N'Damien', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (6, N'Holt', N'Roger', CAST(0x000097F100000000 AS DateTime), NULL)
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (7, N'Martin', N'Randall', CAST(0x00008B1A00000000 AS DateTime), NULL)
SET IDENTITY_INSERT [dbo].[Person] OFF
SET IDENTITY_INSERT [dbo].[StudentGrade] ON

INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (1, N'C1045', 1, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (2, N'C1045', 2, CAST(3.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (3, N'C1045', 3, CAST(2.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (4, N'C1045', 4, CAST(4.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (5, N'C1045', 5, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (6, N'C1061', 1, CAST(4.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (7, N'C1061', 3, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (8, N'C1061', 4, CAST(2.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (9, N'C1061', 5, CAST(1.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (10, N'C2021', 1, CAST(2.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (11, N'C2021', 2, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (12, N'C2021', 4, CAST(3.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (13, N'C2021', 5, CAST(3.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (14, N'C2042', 1, CAST(2.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (15, N'C2042', 2, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (16, N'C2042', 3, CAST(4.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (17, N'C2042', 5, CAST(3.00 AS Decimal(3, 2)))
SET IDENTITY_INSERT [dbo].[StudentGrade] OFF
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])
REFERENCES [dbo].[Department] ([DepartmentID])
GO
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]
GO
ALTER TABLE [dbo].[StudentGrade]  WITH CHECK ADD  CONSTRAINT [FK_StudentGrade_Student] FOREIGN KEY([StudentID])
REFERENCES [dbo].[Person] ([PersonID])
GO
ALTER TABLE [dbo].[StudentGrade] CHECK CONSTRAINT [FK_StudentGrade_Student]
GO
```

<span data-ttu-id="516e8-201">Voici le code complet :</span><span class="sxs-lookup"><span data-stu-id="516e8-201">The code listing follows:</span></span>

> [!TIP]
> <span data-ttu-id="516e8-202">Le code complet fait référence à un fichier de base de données Access appelé MySchool.mdb.</span><span class="sxs-lookup"><span data-stu-id="516e8-202">The code listing refers to an Access database file called MySchool.mdb.</span></span> <span data-ttu-id="516e8-203">Vous pouvez télécharger MySchool. mdb (dans le cadre de l' C# exemple de projet complet ou Visual Basic) à partir de [code.msdn.Microsoft.com](https://code.msdn.microsoft.com/How-to-Retrieve-the-511acece).</span><span class="sxs-lookup"><span data-stu-id="516e8-203">You can download MySchool.mdb (as part of the full C# or Visual Basic sample project) from [code.msdn.microsoft.com](https://code.msdn.microsoft.com/How-to-Retrieve-the-511acece).</span></span>

```csharp
using System;
using System.Data;
using System.Data.OleDb;
using System.Data.SqlClient;

class Program {
   static void Main(string[] args) {
      String SqlDbConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True;Asynchronous Processing=true;";

      InsertPerson(SqlDbConnectionString, "Janice", "Galvin");
      Console.WriteLine();

      InsertPersonInAdapter(SqlDbConnectionString, "Peter", "Krebs");
      Console.WriteLine();

      String oledbConnectionString = "Provider=Microsoft.Jet.OLEDB.4.0; Data Source=Database\\MySchool.mdb";
      InsertPersonInJet4Database(oledbConnectionString, "Janice", "Galvin");
      Console.WriteLine();

      Console.WriteLine("Please press any key to exit.....");
      Console.ReadKey();
   }

   // Using stored procedure to insert a new row and retrieve the identity value
   static void InsertPerson(String connectionString, String firstName, String lastName) {
      String commandText = "dbo.InsertPerson";

      using (SqlConnection conn = new SqlConnection(connectionString)) {
         using (SqlCommand cmd = new SqlCommand(commandText, conn)) {
            cmd.CommandType = CommandType.StoredProcedure;

            cmd.Parameters.Add(new SqlParameter("@FirstName", firstName));
            cmd.Parameters.Add(new SqlParameter("@LastName", lastName));
            SqlParameter personId = new SqlParameter("@PersonID", SqlDbType.Int);
            personId.Direction = ParameterDirection.Output;
            cmd.Parameters.Add(personId);

            conn.Open();
            cmd.ExecuteNonQuery();

            Console.WriteLine("Person Id of new person:{0}", personId.Value);
         }
      }
   }

   // Using stored procedure in adapter to insert new rows and update the identity value.
   static void InsertPersonInAdapter(String connectionString, String firstName, String lastName) {
      String commandText = "dbo.InsertPerson";
      using (SqlConnection conn = new SqlConnection(connectionString)) {
         SqlDataAdapter mySchool = new SqlDataAdapter("Select PersonID,FirstName,LastName from [dbo].[Person]", conn);

         mySchool.InsertCommand = new SqlCommand(commandText, conn);
         mySchool.InsertCommand.CommandType = CommandType.StoredProcedure;

         mySchool.InsertCommand.Parameters.Add(
             new SqlParameter("@FirstName", SqlDbType.NVarChar, 50, "FirstName"));
         mySchool.InsertCommand.Parameters.Add(
             new SqlParameter("@LastName", SqlDbType.NVarChar, 50, "LastName"));

         SqlParameter personId = mySchool.InsertCommand.Parameters.Add(new SqlParameter("@PersonID", SqlDbType.Int, 0, "PersonID"));
         personId.Direction = ParameterDirection.Output;

         DataTable persons = new DataTable();
         mySchool.Fill(persons);

         DataRow newPerson = persons.NewRow();
         newPerson["FirstName"] = firstName;
         newPerson["LastName"] = lastName;
         persons.Rows.Add(newPerson);

         mySchool.Update(persons);
         Console.WriteLine("Show all persons:");
         ShowDataTable(persons, 14);
      }
   }

   /// For a Jet 4.0 database, we need use the single statement and event handler to insert new rows and retrieve the identity value.
   static void InsertPersonInJet4Database(String connectionString, String firstName, String lastName) {
      String commandText = "Insert into Person(FirstName,LastName) Values(?,?)";
      using (OleDbConnection conn = new OleDbConnection(connectionString)) {
         OleDbDataAdapter mySchool = new OleDbDataAdapter("Select PersonID,FirstName,LastName from Person", conn);

         // Create Insert Command
         mySchool.InsertCommand = new OleDbCommand(commandText, conn);
         mySchool.InsertCommand.CommandType = CommandType.Text;

         mySchool.InsertCommand.Parameters.Add(new OleDbParameter("@FirstName", OleDbType.VarChar, 50, "FirstName"));
         mySchool.InsertCommand.Parameters.Add(new OleDbParameter("@LastName", OleDbType.VarChar, 50, "LastName"));
         mySchool.InsertCommand.UpdatedRowSource = UpdateRowSource.Both;

         DataTable persons = CreatePersonsTable();

         mySchool.Fill(persons);

         DataRow newPerson = persons.NewRow();
         newPerson["FirstName"] = firstName;
         newPerson["LastName"] = lastName;
         persons.Rows.Add(newPerson);

         DataTable dataChanges = persons.GetChanges();

         mySchool.RowUpdated += OnRowUpdated;

         mySchool.Update(dataChanges);

         Console.WriteLine("Data before merging:");
         ShowDataTable(persons, 14);
         Console.WriteLine();

         persons.Merge(dataChanges);
         persons.AcceptChanges();

         Console.WriteLine("Data after merging");
         ShowDataTable(persons, 14);
      }
   }

   static void OnRowUpdated(object sender, OleDbRowUpdatedEventArgs e) {
      if (e.StatementType == StatementType.Insert) {
         // Retrieve the identity value
         OleDbCommand cmdNewId = new OleDbCommand("Select @@IDENTITY", e.Command.Connection);
         e.Row["PersonID"] = (Int32)cmdNewId.ExecuteScalar();

         // After the status is changed, the original values in the row are preserved. And the
         // Merge method will be called to merge the new identity value into the original DataTable.
         e.Status = UpdateStatus.SkipCurrentRow;
      }
   }

   // Create the Persons table before filling.
   private static DataTable CreatePersonsTable() {
      DataTable persons = new DataTable();

      DataColumn personId = new DataColumn();
      personId.DataType = Type.GetType("System.Int32");
      personId.ColumnName = "PersonID";
      personId.AutoIncrement = true;
      personId.AutoIncrementSeed = 0;
      personId.AutoIncrementStep = -1;
      persons.Columns.Add(personId);

      DataColumn firstName = new DataColumn();
      firstName.DataType = Type.GetType("System.String");
      firstName.ColumnName = "FirstName";
      persons.Columns.Add(firstName);

      DataColumn lastName = new DataColumn();
      lastName.DataType = Type.GetType("System.String");
      lastName.ColumnName = "LastName";
      persons.Columns.Add(lastName);

      DataColumn[] pkey = { personId };
      persons.PrimaryKey = pkey;

      return persons;
   }

   private static void ShowDataTable(DataTable table, Int32 length) {
      foreach (DataColumn col in table.Columns) {
         Console.Write("{0,-" + length + "}", col.ColumnName);
      }
      Console.WriteLine();

      foreach (DataRow row in table.Rows) {
         foreach (DataColumn col in table.Columns) {
            if (col.DataType.Equals(typeof(DateTime)))
               Console.Write("{0,-" + length + ":d}", row[col]);
            else if (col.DataType.Equals(typeof(Decimal)))
               Console.Write("{0,-" + length + ":C}", row[col]);
            else
               Console.Write("{0,-" + length + "}", row[col]);
         }

         Console.WriteLine();
      }
   }
}
```

## <a name="see-also"></a><span data-ttu-id="516e8-204">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="516e8-204">See also</span></span>

- [<span data-ttu-id="516e8-205">Extraction et modification de données dans ADO.NET</span><span class="sxs-lookup"><span data-stu-id="516e8-205">Retrieving and Modifying Data in ADO.NET</span></span>](retrieving-and-modifying-data.md)
- [<span data-ttu-id="516e8-206">DataAdapters et DataReaders</span><span class="sxs-lookup"><span data-stu-id="516e8-206">DataAdapters and DataReaders</span></span>](dataadapters-and-datareaders.md)
- [<span data-ttu-id="516e8-207">États des lignes et versions des lignes</span><span class="sxs-lookup"><span data-stu-id="516e8-207">Row States and Row Versions</span></span>](./dataset-datatable-dataview/row-states-and-row-versions.md)
- [<span data-ttu-id="516e8-208">AcceptChanges et RejectChanges</span><span class="sxs-lookup"><span data-stu-id="516e8-208">AcceptChanges and RejectChanges</span></span>](./dataset-datatable-dataview/acceptchanges-and-rejectchanges.md)
- [<span data-ttu-id="516e8-209">Fusion de contenu de DataSet</span><span class="sxs-lookup"><span data-stu-id="516e8-209">Merging DataSet Contents</span></span>](./dataset-datatable-dataview/merging-dataset-contents.md)
- [<span data-ttu-id="516e8-210">Mise à jour de sources de données avec des DataAdapters</span><span class="sxs-lookup"><span data-stu-id="516e8-210">Updating Data Sources with DataAdapters</span></span>](updating-data-sources-with-dataadapters.md)
- [<span data-ttu-id="516e8-211">Vue d’ensemble d’ADO.NET</span><span class="sxs-lookup"><span data-stu-id="516e8-211">ADO.NET Overview</span></span>](ado-net-overview.md)
