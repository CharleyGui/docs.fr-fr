---
title: Requêtes d'analyse unique (LINQ to DataSet)
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 0b74bcf8-3f87-449f-bff7-6bcb0d69d212
ms.openlocfilehash: 17a2fcf54cae64d9443b0cc0e8a37e1002bbd394
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91175354"
---
# <a name="single-table-queries-linq-to-dataset"></a><span data-ttu-id="213e4-102">Requêtes d'analyse unique (LINQ to DataSet)</span><span class="sxs-lookup"><span data-stu-id="213e4-102">Single-Table Queries (LINQ to DataSet)</span></span>

<span data-ttu-id="213e4-103">Les requêtes LINQ (Language-Integrated Query) fonctionnent sur les sources de données qui implémentent l' <xref:System.Collections.Generic.IEnumerable%601> interface ou l' <xref:System.Linq.IQueryable%601> interface.</span><span class="sxs-lookup"><span data-stu-id="213e4-103">Language-Integrated Query (LINQ) queries work on data sources that implement the <xref:System.Collections.Generic.IEnumerable%601> interface or the <xref:System.Linq.IQueryable%601> interface.</span></span> <span data-ttu-id="213e4-104">La <xref:System.Data.DataTable> classe n’implémentant aucune interface, vous devez appeler la <xref:System.Data.DataTableExtensions.AsEnumerable%2A> méthode si vous souhaitez utiliser <xref:System.Data.DataTable> en tant que source dans la `From` clause d’une requête LINQ.</span><span class="sxs-lookup"><span data-stu-id="213e4-104">The <xref:System.Data.DataTable> class does not implement either interface, so you must call the <xref:System.Data.DataTableExtensions.AsEnumerable%2A> method if you want to use the <xref:System.Data.DataTable> as a source in the `From` clause of a LINQ query.</span></span>  
  
 <span data-ttu-id="213e4-105">L'exemple ci-dessous obtient toutes les commandes en ligne de la table SalesOrderHeader et affiche l'ID de commande, la date de commande et le numéro de commande sur la console.</span><span class="sxs-lookup"><span data-stu-id="213e4-105">The following example gets all the online orders from the SalesOrderHeader table and outputs the order ID, order date, and order number to the console.</span></span>  
  
 [!code-csharp[DP LINQ to DataSet Examples#Where1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DP LINQ to DataSet Examples/CS/Program.cs#where1)]  
 [!code-vb[DP LINQ to DataSet Examples#Where1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DP LINQ to DataSet Examples/VB/Module1.vb#where1)]
  
 <span data-ttu-id="213e4-106">La requête de variable locale est initialisée avec une expression de requête qui s’exécute sur une ou plusieurs sources d’informations en appliquant un ou plusieurs opérateurs de requête à partir des opérateurs de requête standard ou, dans le cas de LINQ to DataSet, des opérateurs spécifiques à la <xref:System.Data.DataSet> classe.</span><span class="sxs-lookup"><span data-stu-id="213e4-106">The local variable query is initialized with a query expression, which operates on one or more information sources by applying one or more query operators from either the standard query operators or, in the case of LINQ to DataSet, operators specific to the <xref:System.Data.DataSet> class.</span></span> <span data-ttu-id="213e4-107">L'expression de requête de l'exemple précédent utilise deux des opérateurs de requête standard : `Where` et `Select`.</span><span class="sxs-lookup"><span data-stu-id="213e4-107">The query expression in the previous example uses two of the standard query operators: `Where` and `Select`.</span></span>  
  
 <span data-ttu-id="213e4-108">La clause `Where` filtre la séquence en fonction d'une condition : dans ce cas, que l'indicateur `OnlineOrderFlag` soit défini sur `true`.</span><span class="sxs-lookup"><span data-stu-id="213e4-108">The `Where` clause filters the sequence based on a condition, in this case that the `OnlineOrderFlag` is set to `true`.</span></span> <span data-ttu-id="213e4-109">L'opérateur `Select` alloue et retourne un objet énumérable qui capture les arguments transmis à l'opérateur.</span><span class="sxs-lookup"><span data-stu-id="213e4-109">The `Select` operator allocates and returns an enumerable object that captures the arguments passed to the operator.</span></span> <span data-ttu-id="213e4-110">Dans l'exemple ci-dessus, un type anonyme est créé avec trois propriétés : `SalesOrderID`, `OrderDate` et `SalesOrderNumber`.</span><span class="sxs-lookup"><span data-stu-id="213e4-110">In this above example, an anonymous type is created with three properties: `SalesOrderID`, `OrderDate`, and `SalesOrderNumber`.</span></span> <span data-ttu-id="213e4-111">Les valeurs de ces trois propriétés sont définies selon les valeurs des colonnes `SalesOrderID`, `OrderDate` et `SalesOrderNumber` de la table `SalesOrderHeader`.</span><span class="sxs-lookup"><span data-stu-id="213e4-111">The values of these three properties are set to the values of the `SalesOrderID`, `OrderDate`, and `SalesOrderNumber` columns from the `SalesOrderHeader` table.</span></span>  
  
 <span data-ttu-id="213e4-112">La boucle `foreach` énumère ensuite l'objet énumérable retourné par `Select` puis génère les résultats de la requête.</span><span class="sxs-lookup"><span data-stu-id="213e4-112">The `foreach` loop then enumerates the enumerable object returned by `Select` and yields the query results.</span></span> <span data-ttu-id="213e4-113">Parce que la requête est du type <xref:System.Linq.Enumerable>, qui implémente <xref:System.Collections.Generic.IEnumerable%601>, l'évaluation de la requête est différée jusqu'à ce que la variable de requête soit itérée au sein de la boucle `foreach`.</span><span class="sxs-lookup"><span data-stu-id="213e4-113">Because query is an <xref:System.Linq.Enumerable> type, which implements <xref:System.Collections.Generic.IEnumerable%601>, the evaluation of the query is deferred until the query variable is iterated over using the `foreach` loop.</span></span> <span data-ttu-id="213e4-114">L'évaluation de requête différée permet de conserver les requêtes en tant que valeurs qui peuvent être évaluées plusieurs fois, produisant chaque fois des résultats potentiellement différents.</span><span class="sxs-lookup"><span data-stu-id="213e4-114">Deferred query evaluation allows queries to be kept as values that can be evaluated multiple times, each time yielding potentially different results.</span></span>  
  
 <span data-ttu-id="213e4-115">La méthode <xref:System.Data.DataRowExtensions.Field%2A> fournit l'accès aux valeurs de colonne d'un <xref:System.Data.DataRow> et le <xref:System.Data.DataRowExtensions.SetField%2A> (non illustré dans l'exemple précédent) définit les valeurs de colonne dans un <xref:System.Data.DataRow>.</span><span class="sxs-lookup"><span data-stu-id="213e4-115">The <xref:System.Data.DataRowExtensions.Field%2A> method provides access to the column values of a <xref:System.Data.DataRow> and the <xref:System.Data.DataRowExtensions.SetField%2A> (not shown in the previous example) sets column values in a <xref:System.Data.DataRow>.</span></span> <span data-ttu-id="213e4-116">La <xref:System.Data.DataRowExtensions.Field%2A> méthode et la <xref:System.Data.DataRowExtensions.SetField%2A> méthode gèrent les types valeur Nullable, donc vous n’avez pas à vérifier explicitement les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="213e4-116">Both the <xref:System.Data.DataRowExtensions.Field%2A> method and <xref:System.Data.DataRowExtensions.SetField%2A> method handle nullable value types, so you do not have to explicitly check for null values.</span></span> <span data-ttu-id="213e4-117">Les deux méthodes sont également des méthodes génériques, ce qui veut dire que vous n’avez pas à effectuer un cast du type de retour.</span><span class="sxs-lookup"><span data-stu-id="213e4-117">Both methods are generic methods, also, which means you do not have to cast the return type.</span></span> <span data-ttu-id="213e4-118">Vous pourriez utiliser l’accesseur de colonne existant dans <xref:System.Data.DataRow> (par exemple, `o["OrderDate"]`), mais il vous faudrait alors effectuer un cast de l’objet de retour vers le type approprié.</span><span class="sxs-lookup"><span data-stu-id="213e4-118">You could use the pre-existing column accessor in <xref:System.Data.DataRow> (for example, `o["OrderDate"]`), but doing so would require you to cast the return object to the appropriate type.</span></span>  <span data-ttu-id="213e4-119">Si la colonne est un type valeur Nullable, vous devez vérifier si la valeur est null à l’aide de la <xref:System.Data.DataRow.IsNull%2A> méthode.</span><span class="sxs-lookup"><span data-stu-id="213e4-119">If the column is a nullable value type you have to check if the value is null by using the <xref:System.Data.DataRow.IsNull%2A> method.</span></span> <span data-ttu-id="213e4-120">Pour plus d’informations, consultez [méthodes génériques Field et SetField](generic-field-and-setfield-methods-linq-to-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="213e4-120">For more information, see [Generic Field and SetField Methods](generic-field-and-setfield-methods-linq-to-dataset.md).</span></span>  
  
 <span data-ttu-id="213e4-121">Notez que le type de données spécifié dans le paramètre générique `T` de la méthode <xref:System.Data.DataRowExtensions.Field%2A> et de la méthode <xref:System.Data.DataRowExtensions.SetField%2A> doit correspondre au type de la valeur sous-jacente, sinon une <xref:System.InvalidCastException> est levée.</span><span class="sxs-lookup"><span data-stu-id="213e4-121">Note that the data type specified in the generic parameter `T` of the <xref:System.Data.DataRowExtensions.Field%2A> method and <xref:System.Data.DataRowExtensions.SetField%2A> method must match the type of the underlying value or an <xref:System.InvalidCastException> will be thrown.</span></span> <span data-ttu-id="213e4-122">Le nom de la colonne spécifiée doit également correspondre à celui de la colonne dans le <xref:System.Data.DataSet>, sinon une <xref:System.ArgumentException> est levée.</span><span class="sxs-lookup"><span data-stu-id="213e4-122">The specified column name must also match the name of a column in the <xref:System.Data.DataSet> or an <xref:System.ArgumentException> will be thrown.</span></span> <span data-ttu-id="213e4-123">Dans les deux cas, l'exception est levée au moment de l'exécution de l'énumération des données lorsque la requête est exécutée.</span><span class="sxs-lookup"><span data-stu-id="213e4-123">In both cases, the exception is thrown at run time data enumeration when the query is executed.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="213e4-124">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="213e4-124">See also</span></span>

- [<span data-ttu-id="213e4-125">Requêtes de table croisée</span><span class="sxs-lookup"><span data-stu-id="213e4-125">Cross-Table Queries</span></span>](cross-table-queries-linq-to-dataset.md)
- [<span data-ttu-id="213e4-126">Interrogation de DataSets typés</span><span class="sxs-lookup"><span data-stu-id="213e4-126">Querying Typed DataSets</span></span>](querying-typed-datasets.md)
- [<span data-ttu-id="213e4-127">Méthodes génériques Field et SetField</span><span class="sxs-lookup"><span data-stu-id="213e4-127">Generic Field and SetField Methods</span></span>](generic-field-and-setfield-methods-linq-to-dataset.md)
