---
title: Requêtes d'analyse unique (LINQ to DataSet)
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 0b74bcf8-3f87-449f-bff7-6bcb0d69d212
ms.openlocfilehash: 89c90fd217285fac449aba40682aa947fcfb3a07
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249088"
---
# <a name="single-table-queries-linq-to-dataset"></a><span data-ttu-id="480fa-102">Requêtes d'analyse unique (LINQ to DataSet)</span><span class="sxs-lookup"><span data-stu-id="480fa-102">Single-Table Queries (LINQ to DataSet)</span></span>
<span data-ttu-id="480fa-103">Les requêtes en langue intégrées (LINQ) fonctionnent <xref:System.Collections.Generic.IEnumerable%601> sur <xref:System.Linq.IQueryable%601> les sources de données qui implémenter l’interface ou l’interface.</span><span class="sxs-lookup"><span data-stu-id="480fa-103">Language-Integrated Query (LINQ) queries work on data sources that implement the <xref:System.Collections.Generic.IEnumerable%601> interface or the <xref:System.Linq.IQueryable%601> interface.</span></span> <span data-ttu-id="480fa-104">La <xref:System.Data.DataTable> classe ne met pas en œuvre l’une ou l’autre interface, donc vous devez appeler la <xref:System.Data.DataTableExtensions.AsEnumerable%2A> méthode si vous voulez utiliser la <xref:System.Data.DataTable> source dans la `From` clause d’une requête LINQ.</span><span class="sxs-lookup"><span data-stu-id="480fa-104">The <xref:System.Data.DataTable> class does not implement either interface, so you must call the <xref:System.Data.DataTableExtensions.AsEnumerable%2A> method if you want to use the <xref:System.Data.DataTable> as a source in the `From` clause of a LINQ query.</span></span>  
  
 <span data-ttu-id="480fa-105">L'exemple ci-dessous obtient toutes les commandes en ligne de la table SalesOrderHeader et affiche l'ID de commande, la date de commande et le numéro de commande sur la console.</span><span class="sxs-lookup"><span data-stu-id="480fa-105">The following example gets all the online orders from the SalesOrderHeader table and outputs the order ID, order date, and order number to the console.</span></span>  
  
 [!code-csharp[DP LINQ to DataSet Examples#Where1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DP LINQ to DataSet Examples/CS/Program.cs#where1)]  
 [!code-vb[DP LINQ to DataSet Examples#Where1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DP LINQ to DataSet Examples/VB/Module1.vb#where1)]
  
 <span data-ttu-id="480fa-106">La requête variable locale est paraspérée par une expression de requête, qui fonctionne sur une ou plusieurs sources d’information en appliquant un ou <xref:System.Data.DataSet> plusieurs opérateurs de requêtes des opérateurs de requête standard ou, dans le cas de LINQ à DataSet, des opérateurs spécifiques à la catégorie.</span><span class="sxs-lookup"><span data-stu-id="480fa-106">The local variable query is initialized with a query expression, which operates on one or more information sources by applying one or more query operators from either the standard query operators or, in the case of LINQ to DataSet, operators specific to the <xref:System.Data.DataSet> class.</span></span> <span data-ttu-id="480fa-107">L'expression de requête de l'exemple précédent utilise deux des opérateurs de requête standard : `Where` et `Select`.</span><span class="sxs-lookup"><span data-stu-id="480fa-107">The query expression in the previous example uses two of the standard query operators: `Where` and `Select`.</span></span>  
  
 <span data-ttu-id="480fa-108">La clause `Where` filtre la séquence en fonction d'une condition : dans ce cas, que l'indicateur `OnlineOrderFlag` soit défini sur `true`.</span><span class="sxs-lookup"><span data-stu-id="480fa-108">The `Where` clause filters the sequence based on a condition, in this case that the `OnlineOrderFlag` is set to `true`.</span></span> <span data-ttu-id="480fa-109">L'opérateur `Select` alloue et retourne un objet énumérable qui capture les arguments transmis à l'opérateur.</span><span class="sxs-lookup"><span data-stu-id="480fa-109">The `Select` operator allocates and returns an enumerable object that captures the arguments passed to the operator.</span></span> <span data-ttu-id="480fa-110">Dans l'exemple ci-dessus, un type anonyme est créé avec trois propriétés : `SalesOrderID`, `OrderDate` et `SalesOrderNumber`.</span><span class="sxs-lookup"><span data-stu-id="480fa-110">In this above example, an anonymous type is created with three properties: `SalesOrderID`, `OrderDate`, and `SalesOrderNumber`.</span></span> <span data-ttu-id="480fa-111">Les valeurs de ces trois propriétés sont définies selon les valeurs des colonnes `SalesOrderID`, `OrderDate` et `SalesOrderNumber` de la table `SalesOrderHeader`.</span><span class="sxs-lookup"><span data-stu-id="480fa-111">The values of these three properties are set to the values of the `SalesOrderID`, `OrderDate`, and `SalesOrderNumber` columns from the `SalesOrderHeader` table.</span></span>  
  
 <span data-ttu-id="480fa-112">La boucle `foreach` énumère ensuite l'objet énumérable retourné par `Select` puis génère les résultats de la requête.</span><span class="sxs-lookup"><span data-stu-id="480fa-112">The `foreach` loop then enumerates the enumerable object returned by `Select` and yields the query results.</span></span> <span data-ttu-id="480fa-113">Parce que la requête est du type <xref:System.Linq.Enumerable>, qui implémente <xref:System.Collections.Generic.IEnumerable%601>, l'évaluation de la requête est différée jusqu'à ce que la variable de requête soit itérée au sein de la boucle `foreach`.</span><span class="sxs-lookup"><span data-stu-id="480fa-113">Because query is an <xref:System.Linq.Enumerable> type, which implements <xref:System.Collections.Generic.IEnumerable%601>, the evaluation of the query is deferred until the query variable is iterated over using the `foreach` loop.</span></span> <span data-ttu-id="480fa-114">L'évaluation de requête différée permet de conserver les requêtes en tant que valeurs qui peuvent être évaluées plusieurs fois, produisant chaque fois des résultats potentiellement différents.</span><span class="sxs-lookup"><span data-stu-id="480fa-114">Deferred query evaluation allows queries to be kept as values that can be evaluated multiple times, each time yielding potentially different results.</span></span>  
  
 <span data-ttu-id="480fa-115">La méthode <xref:System.Data.DataRowExtensions.Field%2A> fournit l'accès aux valeurs de colonne d'un <xref:System.Data.DataRow> et le <xref:System.Data.DataRowExtensions.SetField%2A> (non illustré dans l'exemple précédent) définit les valeurs de colonne dans un <xref:System.Data.DataRow>.</span><span class="sxs-lookup"><span data-stu-id="480fa-115">The <xref:System.Data.DataRowExtensions.Field%2A> method provides access to the column values of a <xref:System.Data.DataRow> and the <xref:System.Data.DataRowExtensions.SetField%2A> (not shown in the previous example) sets column values in a <xref:System.Data.DataRow>.</span></span> <span data-ttu-id="480fa-116">La <xref:System.Data.DataRowExtensions.Field%2A> méthode <xref:System.Data.DataRowExtensions.SetField%2A> et la méthode traitent les types de valeur nul, de sorte que vous n’avez pas à vérifier explicitement les valeurs nulles.</span><span class="sxs-lookup"><span data-stu-id="480fa-116">Both the <xref:System.Data.DataRowExtensions.Field%2A> method and <xref:System.Data.DataRowExtensions.SetField%2A> method handle nullable value types, so you do not have to explicitly check for null values.</span></span> <span data-ttu-id="480fa-117">Les deux méthodes sont également des méthodes génériques, ce qui veut dire que vous n’avez pas à effectuer un cast du type de retour.</span><span class="sxs-lookup"><span data-stu-id="480fa-117">Both methods are generic methods, also, which means you do not have to cast the return type.</span></span> <span data-ttu-id="480fa-118">Vous pourriez utiliser l’accesseur de colonne existant dans <xref:System.Data.DataRow> (par exemple, `o["OrderDate"]`), mais il vous faudrait alors effectuer un cast de l’objet de retour vers le type approprié.</span><span class="sxs-lookup"><span data-stu-id="480fa-118">You could use the pre-existing column accessor in <xref:System.Data.DataRow> (for example, `o["OrderDate"]`), but doing so would require you to cast the return object to the appropriate type.</span></span>  <span data-ttu-id="480fa-119">Si la colonne est un type de valeur nul, vous <xref:System.Data.DataRow.IsNull%2A> devez vérifier si la valeur est nulle en utilisant la méthode.</span><span class="sxs-lookup"><span data-stu-id="480fa-119">If the column is a nullable value type you have to check if the value is null by using the <xref:System.Data.DataRow.IsNull%2A> method.</span></span> <span data-ttu-id="480fa-120">Pour plus d’informations, voir [Generic Field et SetField Methods](generic-field-and-setfield-methods-linq-to-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="480fa-120">For more information, see [Generic Field and SetField Methods](generic-field-and-setfield-methods-linq-to-dataset.md).</span></span>  
  
 <span data-ttu-id="480fa-121">Notez que le type de données spécifié dans le paramètre générique `T` de la méthode <xref:System.Data.DataRowExtensions.Field%2A> et de la méthode <xref:System.Data.DataRowExtensions.SetField%2A> doit correspondre au type de la valeur sous-jacente, sinon une <xref:System.InvalidCastException> est levée.</span><span class="sxs-lookup"><span data-stu-id="480fa-121">Note that the data type specified in the generic parameter `T` of the <xref:System.Data.DataRowExtensions.Field%2A> method and <xref:System.Data.DataRowExtensions.SetField%2A> method must match the type of the underlying value or an <xref:System.InvalidCastException> will be thrown.</span></span> <span data-ttu-id="480fa-122">Le nom de la colonne spécifiée doit également correspondre à celui de la colonne dans le <xref:System.Data.DataSet>, sinon une <xref:System.ArgumentException> est levée.</span><span class="sxs-lookup"><span data-stu-id="480fa-122">The specified column name must also match the name of a column in the <xref:System.Data.DataSet> or an <xref:System.ArgumentException> will be thrown.</span></span> <span data-ttu-id="480fa-123">Dans les deux cas, l'exception est levée au moment de l'exécution de l'énumération des données lorsque la requête est exécutée.</span><span class="sxs-lookup"><span data-stu-id="480fa-123">In both cases, the exception is thrown at run time data enumeration when the query is executed.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="480fa-124">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="480fa-124">See also</span></span>

- [<span data-ttu-id="480fa-125">Requêtes de table croisée</span><span class="sxs-lookup"><span data-stu-id="480fa-125">Cross-Table Queries</span></span>](cross-table-queries-linq-to-dataset.md)
- [<span data-ttu-id="480fa-126">Interrogation de DataSets typés</span><span class="sxs-lookup"><span data-stu-id="480fa-126">Querying Typed DataSets</span></span>](querying-typed-datasets.md)
- [<span data-ttu-id="480fa-127">Méthodes génériques Field et SetField</span><span class="sxs-lookup"><span data-stu-id="480fa-127">Generic Field and SetField Methods</span></span>](generic-field-and-setfield-methods-linq-to-dataset.md)
