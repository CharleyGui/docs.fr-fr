---
title: Gérer le contexte du service de données (WCF Data Services)
ms.date: 03/30/2017
ms.assetid: 15b19d09-7de7-4638-9556-6ef396cc45ec
ms.openlocfilehash: e67f7280bc85c7577f960707659890f59470e535
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91194295"
---
# <a name="managing-the-data-service-context-wcf-data-services"></a>Gérer le contexte du service de données (WCF Data Services)

La classe <xref:System.Data.Services.Client.DataServiceContext> encapsule des opérations prises en charge sur un service de données spécifié. Bien que les services OData soient sans État, le contexte ne l’est pas. Par conséquent, vous pouvez utiliser la <xref:System.Data.Services.Client.DataServiceContext> classe pour conserver l’État sur le client entre les interactions avec le service de données afin de prendre en charge des fonctionnalités telles que la gestion des modifications. Cette classe gère également des identités et suit les modifications.  
  
## <a name="merge-options-and-identity-resolution"></a>Options de fusion et résolution d’identité  

 Lorsqu'un objet <xref:System.Data.Services.Client.DataServiceQuery%601> est exécuté, les entités du flux de réponse sont matérialisées en objets. Pour plus d’informations, consultez [matérialisation d’objets](object-materialization-wcf-data-services.md). La façon dont les entrées d'un message de réponse sont matérialisées en objets dépend de la résolution d'identité et de l'option de fusion sous laquelle la requête a été exécutée. Lorsque plusieurs requêtes ou requêtes de chargement sont exécutées dans l’étendue d’un unique <xref:System.Data.Services.Client.DataServiceContext> , le client WCF Data Services effectue uniquement le suivi d’une seule instance d’un objet qui a une valeur de clé spécifique. Cette clé, utilisée pour effectuer la résolution d'identité, identifie une entité de façon unique.  
  
 Par défaut, le client ne matérialise qu'une seule entrée du flux de réponse en un objet pour les entités qui ne sont pas déjà suivies par l'objet <xref:System.Data.Services.Client.DataServiceContext>. Cela signifie que les modifications apportées à des objets déjà dans le cache ne sont pas remplacées. Ce comportement est contrôlé en spécifiant une valeur <xref:System.Data.Services.Client.MergeOption> pour les requêtes et les opérations de chargement. Cette option est spécifiée en définissant la propriété <xref:System.Data.Services.Client.DataServiceContext.MergeOption%2A> sur l'objet <xref:System.Data.Services.Client.DataServiceContext>. La valeur de l’option de fusion par défaut est <xref:System.Data.Services.Client.MergeOption.AppendOnly>. Cela ne matérialise les objets que pour les entités qui ne sont pas déjà suivies, ce qui signifie que les objets existants ne sont pas remplacés. Il existe un autre moyen d'empêcher que les modifications apportées aux objets sur le client ne soient remplacées par les mises à jour provenant du service de données. Il consiste à spécifier <xref:System.Data.Services.Client.MergeOption.PreserveChanges>. Lorsque vous spécifiez <xref:System.Data.Services.Client.MergeOption.OverwriteChanges>, les valeurs des objets sur le client sont remplacées par les valeurs les plus récentes à partir des entrées du flux de réponse, même si les modifications ont déjà été apportées à ces objets. Lorsqu'une option de fusion <xref:System.Data.Services.Client.MergeOption.NoTracking> est utilisée, l'objet <xref:System.Data.Services.Client.DataServiceContext> ne peut pas transmettre au service de données les modifications apportées aux objets clients. Avec cette option, les modifications sont toujours remplacées par les valeurs du service de données.  
  
## <a name="managing-concurrency"></a>Gestion de l’accès concurrentiel  

 OData prend en charge l’accès concurrentiel optimiste qui permet au service de données de détecter les conflits de mise à jour. Le fournisseur de services de données peut être configuré de telle façon que le service de données recherche les modifications apportées aux entités à l'aide d'un jeton d'accès concurrentiel. Ce jeton comprend une ou plusieurs propriétés d'un type d'entité qui sont validées par le service de données afin de déterminer si une ressource a changé. Les jetons d’accès concurrentiel, qui sont inclus dans l’en-tête eTag des demandes et des réponses du service de données, sont gérés pour vous par le client WCF Data Services. Pour plus d’informations, consultez [mise à jour du service de données](updating-the-data-service-wcf-data-services.md).  
  
 L'objet <xref:System.Data.Services.Client.DataServiceContext> suit les modifications apportées aux objets signalées manuellement à l'aide des méthodes <xref:System.Data.Services.Client.DataServiceContext.AddObject%2A>, <xref:System.Data.Services.Client.DataServiceContext.UpdateObject%2A> et <xref:System.Data.Services.Client.DataServiceContext.DeleteObject%2A>, ou à l'aide d'un objet <xref:System.Data.Services.Client.DataServiceCollection%601>. Lorsque la méthode <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A> est appelée, le client renvoie les modifications au service de données. La méthode <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A> peut échouer lorsque les modifications apportées aux données dans le client entrent en conflit avec les modifications du service de données. Lorsque cela se produit, vous devez redemander la ressource de l'entité pour recevoir les données de mise à jour. Pour supprimer les modifications du service de données, exécutez cette requête à l'aide de l'option de fusion <xref:System.Data.Services.Client.MergeOption.PreserveChanges>. Lorsque vous rappelez la méthode<xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A>, les modifications conservées sur le client sont rendues persistantes sur le service de données à condition que d'autres modifications n'aient pas déjà été apportées à la ressource dans le service de données.  
  
## <a name="saving-changes"></a>Enregistrement des modifications  

 Les modifications sont suivies dans l'instance <xref:System.Data.Services.Client.DataServiceContext> mais ne sont pas envoyées au serveur immédiatement. Une fois que vous avez terminé d'effectuer les modifications requises pour une activité spécifiée, appelez <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A> afin de soumettre toutes les modifications au service de données. Un objet <xref:System.Data.Services.Client.DataServiceResponse> est retourné au terme de l'opération <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A>. L'objet <xref:System.Data.Services.Client.DataServiceResponse> inclut une séquence d'objets <xref:System.Data.Services.Client.OperationResponse> qui, à leur tour, contiennent une séquence d'instances <xref:System.Data.Services.Client.EntityDescriptor> ou <xref:System.Data.Services.Client.LinkDescriptor> représentant les modifications qui ont été tentées ou rendues persistantes. Lorsqu'une entité est créée ou modifiée dans le service de données, <xref:System.Data.Services.Client.EntityDescriptor> inclut une référence à l'entité mise à jour, notamment les valeurs de propriété générées par le serveur, telles que la valeur `ProductID` générée dans l'exemple précédent. La bibliothèque cliente met automatiquement à jour l'objet .NET Framework pour disposer de ces nouvelles valeurs.  
  
 Pour les opérations d’insertion et de mise à jour qui ont abouti, la propriété d’état de l’objet <xref:System.Data.Services.Client.EntityDescriptor> ou <xref:System.Data.Services.Client.LinkDescriptor> associé à l’opération aura la valeur <xref:System.Data.Services.Client.EntityStates.Unchanged> et les nouvelles valeurs seront fusionnées à l’aide de <xref:System.Data.Services.Client.MergeOption.OverwriteChanges>. Lorsqu'une opération d'insertion, de mise à jour ou de suppression échoue dans le service de données, l'entité conserve l'état qui était le sien avant l'appel de <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A> et la propriété <xref:System.Data.Services.Client.OperationResponse.Error%2A> de l'objet <xref:System.Data.Services.Client.OperationResponse> prend la valeur <xref:System.Data.Services.Client.DataServiceRequestException> qui contient les informations relatives à l'erreur. Pour plus d’informations, consultez [mise à jour du service de données](updating-the-data-service-wcf-data-services.md).  
  
### <a name="setting-the-http-method-for-updates"></a>Définition de la méthode HTTP pour les mises à jour  

 Par défaut, la bibliothèque cliente .NET Framework envoie des mises à jour aux entités existantes sous forme de demandes MERGE. Une demande MERGE met à jour les propriétés sélectionnées de l’entité ; toutefois, le client inclut systématiquement toutes les propriétés dans la demande MERGE, même celles qui n’ont pas changé. Le protocole OData prend également en charge l’envoi de demandes PUT pour mettre à jour des entités. Dans une demande PUT, une entité existante est essentiellement remplacée par une nouvelle instance de l'entité avec les valeurs de propriété du client. Pour utiliser les demandes PUT, définissez l'indicateur <xref:System.Data.Services.Client.SaveChangesOptions.ReplaceOnUpdate> sur l'énumération <xref:System.Data.Services.Client.SaveChangesOptions> lors de l'appel de <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A>.  
  
> [!NOTE]
> Une demande PUT va se comporter différemment d’une demande MERGE lorsque le client ne connaît pas toutes les propriétés de l’entité. Cela peut se produire lors de la projection d'un type d'entité dans un nouveau type, sur le client. C'est également le cas lorsque de nouvelles propriétés ont été ajoutées à l'entité dans le modèle de données du service et la propriété <xref:System.Data.Services.Client.DataServiceContext.IgnoreMissingProperties%2A> sur le <xref:System.Data.Services.Client.DataServiceContext> est définie sur `true` pour ignorer ces erreurs de mappage du client. Dans ces cas, une demande PUT va réinitialiser toutes les propriétés inconnues sur le client selon leurs valeurs par défaut.  
  
### <a name="post-tunneling"></a>Tunnel de publication  

 Par défaut, la bibliothèque cliente envoie des demandes de création, lecture, mise à jour et suppression à un service OData à l’aide des méthodes HTTP correspondantes de l’opération de publication, d’extraction, de mise en place/fusion/correction et de suppression. Cela confirme les principes de base de REST (Representational State Transfer). Toutefois, toutes les implémentations de serveur web ne prennent pas en charge la totalité des méthodes HTTP. Dans certains cas, les méthodes prises en charge peuvent être limitées à GET et POST. Cela peut se produire lorsqu'un intermédiaire, comme un pare-feu, bloque les demandes par certaines méthodes. Étant donné que les méthodes d’extraction et de publication sont le plus souvent prises en charge, OData recommande d’exécuter toutes les méthodes HTTP non prises en charge à l’aide d’une requête de publication. Connu sous le nom de *tunneling de méthode* ou de *publication de tunnel*, permet à un client d’envoyer une demande de publication avec la méthode réelle spécifiée dans l' `X-HTTP-Method` en-tête personnalisé. Pour activer le tunneling de publication pour les demandes, définissez la propriété <xref:System.Data.Services.Client.DataServiceContext.UsePostTunneling%2A> sur l'instance <xref:System.Data.Services.Client.DataServiceContext> sur `true`.  
  
## <a name="see-also"></a>Voir aussi

- [Bibliothèque client services de données WCF](wcf-data-services-client-library.md)
- [Mise à jour du service de données](updating-the-data-service-wcf-data-services.md)
- [Opérations asynchrones](asynchronous-operations-wcf-data-services.md)
- [Opérations de traitement par lots](batching-operations-wcf-data-services.md)
