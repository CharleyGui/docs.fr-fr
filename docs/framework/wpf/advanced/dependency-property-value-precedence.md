---
title: Priorité de la valeur de propriété de dépendance
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: 1d7c644c7f7581a96ffff1a0fe1fcf2adfe071e0
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186144"
---
# <a name="dependency-property-value-precedence"></a>Priorité de la valeur de propriété de dépendance
<a name="introduction"></a> Cette rubrique explique comment le fonctionnement du système de propriétés [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] peut affecter la valeur d’une propriété de dépendance, et décrit la priorité selon laquelle les aspects du système de propriétés s’appliquent à la valeur effective d’une propriété.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Conditions préalables requises  
 Cette rubrique part du principe que vous savez ce que sont les propriétés de dépendance du point de vue d’un consommateur de propriétés de dépendance existantes sur les classes [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], et que vous avez lu la [Vue d’ensemble des propriétés de dépendance](dependency-properties-overview.md). Pour pouvoir suivre les exemples de cette rubrique, vous devez également comprendre [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] et savoir comment écrire des applications [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="intro"></a>
## <a name="the-wpf-property-system"></a>Le système de propriétés WPF  
 Le système de propriétés [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] offre un moyen puissant pour faire en sorte que la valeur des propriétés de dépendance soit déterminée par différents facteurs. Il permet de bénéficier de fonctionnalités telles que la validation des propriétés en temps réel et les liaisons tardives, et notifie les propriétés connexes des changements apportés aux valeurs d’autres propriétés. L’ordre et la logique exacts utilisés pour déterminer les valeurs des propriétés de dépendance sont relativement complexes. Connaître cet ordre vous aidera à éviter les paramètres de propriétés inutiles, et peut également éliminer toute confusion quant aux raisons pour lesquelles une tentative visant à influencer ou à anticiper une valeur de propriété de dépendance n’a pas généré la valeur attendue.  
  
<a name="multiple_sets"></a>
## <a name="dependency-properties-might-be-set-in-multiple-places"></a>Les propriétés de dépendance peuvent être « définies » à plusieurs emplacements  
 Voici un [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] exemple où<xref:System.Windows.Controls.Control.Background%2A>la même propriété () a trois opérations différentes "ensemble" qui pourraient influencer la valeur.  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 Ici, quelle sera la couleur appliquée selon vous ? Le rouge, le vert ou le bleu ?  
  
 À l’exception des valeurs animées et du forçage, les jeux de propriétés locaux sont définis à la priorité la plus élevée. Si vous définissez une valeur localement, vous pouvez vous attendre à ce qu’elle soit honorée, même au-delà des styles ou des modèles de contrôle. Ici, dans <xref:System.Windows.Controls.Control.Background%2A> l’exemple, est fixé à Rouge localement. Par conséquent, le style défini dans cette portée, même s’il s’agit d’un style implicite qui s’appliquerait autrement à tous les éléments de ce type dans cette portée, n’est pas la plus haute préséance pour donner à la <xref:System.Windows.Controls.Control.Background%2A> propriété sa valeur.  Si vous supprimiez la valeur locale Red de cette instance de Button, le style aurait la priorité et le bouton obtiendrait la valeur Background à partir du style.  Dans le style, les déclencheurs sont prioritaires. Le bouton sera donc bleu si la souris est sur lui, et vert dans le cas contraire.  
  
<a name="listing"></a>
## <a name="dependency-property-setting-precedence-list"></a>Liste de priorité de définition de propriété de dépendance  
 Voici l’ordre définitif suivi par le système de propriétés lors de l’affectation des valeurs d’exécution des propriétés de dépendance. La priorité la plus élevée est répertoriée en premier. Cette liste étend certaines des généralisations présentées dans la [Vue d’ensemble des propriétés de dépendance](dependency-properties-overview.md).  
  
1. **Forçage du système de propriétés.** Pour plus d’informations sur le forçage, consultez [Forçage, animation et valeur de base](#animations) plus loin dans cette rubrique.  
  
2. **Animations actives ou animations avec un comportement de blocage.** Pour avoir un effet pratique, une animation d’une propriété doit pouvoir être prioritaire par rapport à la valeur de base (non animée), même si cette valeur a été définie localement. Pour plus d’informations, consultez [Forçage, animation et valeur de base](#animations) plus loin dans cette rubrique.  
  
3. **Valeur locale.** Une valeur locale peut être définie par la commodité de la propriété « wrapper », [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]ce qui équivaut <xref:System.Windows.DependencyObject.SetValue%2A> également à l’établissement en tant qu’attribut ou élément de propriété dans , ou par un appel à l’API en utilisant une propriété d’une instance spécifique. Si vous définissez une valeur locale à l’aide d’une liaison ou d’une ressource, celles-ci se comportent chacune en termes de priorité comme si une valeur directe avait été définie.  
  
4. **Propriétés de modèle TemplatedParent.** Un élément <xref:System.Windows.FrameworkElement.TemplatedParent%2A> a un s’il a été <xref:System.Windows.Controls.ControlTemplate> <xref:System.Windows.DataTemplate>créé dans le cadre d’un modèle (a ou ). Pour plus d’informations sur les cas où ceci est applicable, consultez [TemplatedParent](#templatedparent) plus loin dans cette rubrique. Dans le modèle, la priorité suivante s’applique :  
  
    1. Déclencheurs à <xref:System.Windows.FrameworkElement.TemplatedParent%2A> partir du modèle.  
  
    2. Ensembles de [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] propriété (généralement <xref:System.Windows.FrameworkElement.TemplatedParent%2A> par des attributs) dans le modèle.  
  
5. **Style implicite.** S’applique uniquement à la propriété `Style`. La propriété `Style` est renseignée par toute ressource de style avec une clé qui correspond au type de cet élément. Cette ressource de style doit exister dans la page ou dans l’application ; la recherche d’une ressource de style implicite ne se poursuit pas dans les thèmes.  
  
6. **Déclencheurs de styles.** Déclencheurs dans les styles de page ou d’application (ces styles peuvent être explicites ou implicites, mais pas issus des styles par défaut, qui ont une priorité inférieure).  
  
7. **Déclencheurs de modèles.** Tout déclencheur d’un modèle dans un style, ou un modèle appliqué directement.  
  
8. **Style Setters.** Valeurs d’un <xref:System.Windows.Setter> dans les styles de page ou d’application.  
  
9. **Style (de thème) par défaut.** Pour plus d’informations sur les cas où ceci est applicable, et sur la relation entre les styles de thème et les modèles dans les styles de thème, consultez [Style (de thème) par défaut](#themestyles) plus loin dans cette rubrique. Dans un style par défaut, l’ordre de priorité suivant s’applique :  
  
    1. Déclencheurs actifs dans le style de thème.  
  
    2. Méthodes setter dans le style de thème.  
  
10. **Héritage.** Quelques propriétés de dépendance héritent de leurs valeurs d’élément parent à éléments enfants, et n’ont donc pas besoin d’être définies spécifiquement sur chaque élément dans une application. Pour plus de détails voir [l’héritage de valeur de propriété](property-value-inheritance.md).  
  
11. **Valeur par défaut issue des métadonnées de propriété de dépendance.** Toute propriété de dépendance peut avoir une valeur par défaut établie par l’inscription de cette propriété particulière dans le système de propriétés. En outre, les classes dérivées qui héritent d’une propriété de dépendance peuvent substituer ces métadonnées (notamment la valeur par défaut) pour chaque type. Pour plus d’informations, consultez [Métadonnées de propriété de dépendance](dependency-property-metadata.md). Étant donné que l’héritage est vérifié avant la valeur par défaut, pour une propriété héritée une valeur par défaut d’élément parent est prioritaire par rapport à un élément enfant.  Par conséquent, si une propriété pouvant être héritée n’est définie nulle part, la valeur par défaut spécifiée pour la racine ou le parent est utilisée au lieu de la valeur par défaut de l’élément enfant.  
  
<a name="templatedparent"></a>
## <a name="templatedparent"></a>TemplatedParent  
 TemplatedParent en tant qu’élément de priorité ne s’applique pas à une propriété d’un élément que vous déclarez directement dans le balisage d’application standard. Le concept de TemplatedParent existe uniquement pour les éléments enfants dans une arborescence visuelle qui sont créés par l’intermédiaire de l’application du modèle. Lorsque le système <xref:System.Windows.FrameworkElement.TemplatedParent%2A> de propriété recherche le modèle pour obtenir une valeur, il recherche le modèle qui a créé cet élément. Les valeurs de <xref:System.Windows.FrameworkElement.TemplatedParent%2A> propriété du modèle agissent généralement comme si elles étaient définies comme une valeur locale sur l’élément enfant, mais cette priorité moindre par rapport à la valeur locale existe parce que les modèles sont potentiellement partagés. Pour plus d'informations, consultez <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
<a name="style_property"></a>
## <a name="the-style-property"></a>Propriété Style  
 L’ordre de recherche décrit plus tôt s’applique <xref:System.Windows.FrameworkElement.Style%2A> à toutes les propriétés de dépendance possibles, sauf une: la propriété. La <xref:System.Windows.FrameworkElement.Style%2A> propriété est unique en ce qu’elle ne peut pas elle-même être stylée, de sorte que les éléments de préséance 5 à 8 ne s’appliquent pas. En outre, l’animation <xref:System.Windows.FrameworkElement.Style%2A> ou la coercition n’est pas recommandée (et l’animation <xref:System.Windows.FrameworkElement.Style%2A> nécessiterait un cours d’animation personnalisé). Cela laisse trois <xref:System.Windows.FrameworkElement.Style%2A> façons que la propriété pourrait être définie:  
  
- **Style explicite.** La <xref:System.Windows.FrameworkElement.Style%2A> propriété est définie directement. Dans la plupart des scénarios, le style n’est pas défini inline. Il est plutôt référencé en tant que ressource, par clé explicite. Dans ce cas, la propriété Style proprement dite se comporte comme s’il s’agissait d’une valeur locale (élément de priorité 3).  
  
- **Style implicite.** La <xref:System.Windows.FrameworkElement.Style%2A> propriété n’est pas définie directement. Cependant, <xref:System.Windows.FrameworkElement.Style%2A> il existe à un certain niveau dans la séquence de recherche de ressources (page, application) et est saisi à l’aide d’une clé de ressources qui correspond au type auquel le style doit être appliqué. Dans ce cas, la <xref:System.Windows.FrameworkElement.Style%2A> propriété elle-même agit par une préséance identifiée dans la séquence comme l’élément 5. Cette condition peut être <xref:System.Windows.DependencyPropertyHelper> détectée <xref:System.Windows.FrameworkElement.Style%2A> en utilisant <xref:System.Windows.BaseValueSource.ImplicitStyleReference> contre la propriété et en recherchant dans les résultats.  
  
- **Style par défaut**, également appelé **style de thème.** La <xref:System.Windows.FrameworkElement.Style%2A> propriété n’est pas définie directement, et en fait sera lu comme `null` jusqu’à l’heure d’exécution. Dans ce cas, le style provient de l’évaluation du thème d’exécution qui fait partie du moteur de présentation [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
 Pour les styles implicites pas dans les `MyButton` `Button`thèmes, le type doit correspondre `Button`exactement - une classe dérivée n’utilisera pas implicitement un style pour .  
  
<a name="themestyles"></a>
## <a name="default-theme-styles"></a>Style (de thème) par défaut  
 Chaque contrôle fourni avec [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] a un style par défaut. Ce style par défaut peut varier en fonction du thème. C’est pourquoi on le nomme parfois « style de thème ».  
  
 L’information la plus importante qui se trouve dans un style par défaut pour un contrôle <xref:System.Windows.Controls.Control.Template%2A> est son modèle de contrôle, qui existe dans le style de thème comme un setter pour sa propriété. S’il n’y avait aucun modèle issu des styles par défaut, un contrôle sans modèle personnalisé dans le cadre d’un style personnalisé n’aurait aucune apparence visuelle. Le modèle du style par défaut donne une structure de base à l’apparence visuelle de chaque contrôle, et définit également les connexions entre les propriétés définies dans l’arborescence visuelle du modèle et la classe de contrôle correspondante. Chaque contrôle expose un ensemble de propriétés qui peuvent influencer l’apparence visuelle du contrôle sans remplacer complètement le modèle. Par exemple, considérez l’apparence visuelle par défaut <xref:System.Windows.Controls.Primitives.Thumb> <xref:System.Windows.Controls.Primitives.ScrollBar>d’un contrôle, qui est un composant d’un .  
  
 A <xref:System.Windows.Controls.Primitives.Thumb> a certaines propriétés personnalisables. Le modèle par <xref:System.Windows.Controls.Primitives.Thumb> défaut d’un crée une <xref:System.Windows.Controls.Border> structure de base / arbre visuel avec plusieurs composants imbriqués pour créer un regard biseauté. Si une propriété qui fait partie du modèle est destinée <xref:System.Windows.Controls.Primitives.Thumb> à être exposée pour la personnalisation par la classe, alors cette propriété doit être exposée par un [TemplateBinding](templatebinding-markup-extension.md), dans le modèle. Dans le <xref:System.Windows.Controls.Primitives.Thumb>cas de , diverses propriétés de ces <xref:System.Windows.Controls.Border.Background%2A> <xref:System.Windows.Controls.Border.BorderThickness%2A>frontières partagent un modèle de liaison à des propriétés telles que ou . En revanche, certaines autres propriétés ou dispositions visuelles sont codées en dur dans le modèle de contrôle ou sont liées à des valeurs qui proviennent directement du thème, et ne peuvent pas être changées à moins de remplacer le modèle entier. En règle générale, si une propriété provient d’un parent basé sur un modèle et n’est pas exposée par une liaison de modèle, elle ne peut pas être ajustée par des styles car il n’existe aucun moyen simple de la cibler. Mais cette propriété peut toujours être influencée par l’héritage de valeur de propriété dans le modèle appliqué, ou par la valeur par défaut.  
  
 Les styles de thème utilisent un type comme clé dans leurs définitions. Toutefois, lorsque les thèmes sont appliqués à une instance d’élément <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> donnée, la recherche des thèmes pour ce type est effectuée en vérifiant la propriété sur un contrôle. Ce comportement est à contraster avec l’utilisation du littéral Type (par les styles implicites). La valeur <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> de hériterait de classes dérivées même si l’implémenteur ne l’a pas modifié (la façon prévue de changer la propriété n’est pas de le remplacer au niveau de la propriété, mais plutôt de changer sa valeur par défaut dans les métadonnées de propriété). Cette indirection permet aux classes de base de définir les styles de thème pour les éléments dérivés qui ne disposent pas de style (ou, plus important encore, qui n’ont pas de modèle dans ce style et n’auraient donc aucune apparence visuelle par défaut). Ainsi, vous `MyButton` pouvez <xref:System.Windows.Controls.Button> dériver et <xref:System.Windows.Controls.Button> obtiendrez toujours le modèle par défaut. Si vous étiez l’auteur de contrôle de `MyButton` et vous vouliez un comportement <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> `MyButton` différent, vous pourriez passer outre les métadonnées de propriété de dépendance pour retourner une clé différente, puis définir les styles de thème pertinents, y compris le modèle pour `MyButton` que vous devez emballer avec votre `MyButton` contrôle. Pour plus d’informations sur les thèmes, les styles et la création de contrôles, consultez [Vue d’ensemble de la création de contrôles](../controls/control-authoring-overview.md).  
  
<a name="resources"></a>
## <a name="dynamic-resource-references-and-binding"></a>Références de ressources dynamiques et liaison  
 Les opérations de liaison et les références de ressources dynamiques respectent la priorité de l’emplacement auquel elles sont définies. Par exemple, une ressource dynamique appliquée à une valeur locale agit conformément à l’élément de priorité 3, une liaison pour une méthode setter de propriété dans un style de thème s’applique à l’élément de priorité 9, et ainsi de suite. Étant donné que les références de ressources dynamiques et la liaison doivent pouvoir obtenir des valeurs à partir de l’état d’exécution de l’application, cela implique que le processus de détermination de la priorité de valeur de propriété pour une propriété donnée s’étend également au moment de l’exécution.  
  
 Les références de ressources dynamiques ne font pas à proprement parler partie du système de propriétés, mais elles ont leur propre ordre de recherche qui interagit avec la séquence indiquée ci-dessus. Cette priorité est documentée plus en détail dans les [Ressources XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md). Il s’agit en gros de la priorité suivante : élément à racine de la page, application, thème, système.  
  
 Les ressources dynamiques et les liaisons ont la priorité de l’emplacement où elles ont été définies, mais la valeur est différée. L’une des conséquences de cela est que si vous affectez une valeur locale à une ressource dynamique ou une liaison, tout changement apporté à la valeur locale remplace entièrement la ressource dynamique ou la liaison. Même si vous <xref:System.Windows.DependencyObject.ClearValue%2A> appelez la méthode pour effacer la valeur définie localement, la ressource dynamique ou la liaison ne sera pas restaurée. En fait, si <xref:System.Windows.DependencyObject.ClearValue%2A> vous faites appel à une propriété qui a une ressource dynamique ou <xref:System.Windows.DependencyObject.ClearValue%2A> une liaison en place (sans valeur locale littérale), ils sont effacés par l’appel aussi.  
  
<a name="setcurrentvalue"></a>
## <a name="setcurrentvalue"></a>SetCurrentValue  
 La <xref:System.Windows.DependencyObject.SetCurrentValue%2A> méthode est une autre façon de définir une propriété, mais elle n’est pas dans l’ordre de la priorité. Au <xref:System.Windows.DependencyObject.SetCurrentValue%2A> lieu de cela, vous permet de changer la valeur d’une propriété sans surécrire la source d’une valeur précédente. Vous pouvez <xref:System.Windows.DependencyObject.SetCurrentValue%2A> utiliser n’importe quel moment que vous voulez définir une valeur sans donner à cette valeur la priorité d’une valeur locale. Par exemple, si une propriété est définie par <xref:System.Windows.DependencyObject.SetCurrentValue%2A>un déclencheur et puis assigné une autre valeur via , le système de propriété respecte toujours le déclencheur et la propriété changera si l’action du déclencheur se produit. <xref:System.Windows.DependencyObject.SetCurrentValue%2A>vous permet de changer la valeur de la propriété sans lui donner une source avec une priorité plus élevée. De même, <xref:System.Windows.DependencyObject.SetCurrentValue%2A> vous pouvez utiliser pour changer la valeur d’une propriété sans surécrire une liaison.  
  
<a name="animations"></a>
## <a name="coercion-animations-and-base-value"></a>Forçage, animations et valeur de base  
 La coercition et l’animation agissent toutes deux sur une valeur que l’on appelle la « valeur de base » tout au long de ce SDK. La valeur de base est donc toute valeur déterminée par l’intermédiaire d’une évaluation vers le haut parmi les éléments jusqu’à ce que l’élément 2 soit atteint.  
  
 Pour une animation, la valeur de base peut avoir un effet sur la valeur animée, si cette animation ne spécifie pas à la fois « From » et « To » pour certains comportements, ou si l’animation rétablit délibérément la valeur de base une fois terminé. Pour voir cela en pratique, exécutez l’[Exemple de valeurs cibles d’animation From, To et By](https://github.com/Microsoft/WPF-Samples/tree/master/Animation/TargetValues). Essayez de définir les valeurs locales de la hauteur du rectangle dans l’exemple, telles que la valeur locale initiale soit différente de toute valeur « From » dans l’animation. Vous noterez que les animations démarrent immédiatement en utilisant les valeurs « From », et qu’elles remplacent la valeur de base une fois qu’elles ont commencé. L’animation peut spécifier pour revenir à la valeur <xref:System.Windows.Media.Animation.FillBehavior>trouvée avant l’animation une fois qu’il est terminé en spécifiant l’arrêt . Par la suite, la priorité normale est utilisée pour déterminer la valeur de base.  
  
 Plusieurs animations peuvent être appliquées à une même propriété, chacune de ces animations ayant éventuellement été définie à partir de points différents dans la priorité de la valeur. Toutefois, ces animations créeront peut-être une valeur composite à partir de leurs valeurs, plutôt que d’appliquer simplement l’animation à partir de la priorité la plus élevée. Cela dépend de la manière exacte dont les animations sont définies et du type de la valeur qui est animée. Pour plus d’informations sur l’animation de propriétés, consultez [Vue d’ensemble de l’animation](../graphics-multimedia/animation-overview.md).  
  
 Le forçage s’applique au niveau le plus élevé. Même une animation en cours d’exécution est sujette au forçage de valeur. Certaines propriétés de dépendance existantes dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ont un forçage intégré. Pour une propriété de dépendance personnalisée, vous définissez le <xref:System.Windows.CoerceValueCallback> comportement de coercition pour une propriété de dépendance personnalisée en écrivant un et en passant le rappel dans le cadre des métadonnées lorsque vous créez la propriété. Vous pouvez également substituer le comportement de forçage d’une propriété existante en substituant les métadonnées de cette propriété dans une classe dérivée. Le forçage interagit avec la valeur de base de telle façon que les contraintes du forçage soient appliquées telles qu’elles existent à ce moment précis, mais la valeur de base est quand même conservée. Par conséquent, si des contraintes du forçage sont par la suite levées, le forçage retourne la valeur la plus proche possible de cette valeur de base, et l’influence du forçage sur une propriété peut cesser dès que toutes les contraintes sont levées. Pour plus d’informations sur le comportement de forçage, consultez [Validation et rappels de propriétés de dépendance](dependency-property-callbacks-and-validation.md).  
  
<a name="triggers"></a>
## <a name="trigger-behaviors"></a>Comportements des déclencheurs  
 Les contrôles définissent souvent les comportements des déclencheurs dans le cadre de leur style par défaut dans les thèmes. La définition de propriétés locales sur des contrôles peut empêcher les déclencheurs de répondre à des événements pilotés par l’utilisateur visuellement ou par comportement. L’utilisation la plus courante d’un déclencheur <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>de propriété est pour le contrôle ou les propriétés d’état telles que . Par exemple, par <xref:System.Windows.Controls.Button> défaut, lorsqu’un `false`est <xref:System.Windows.Controls.Control.Foreground%2A> désactivé (déclencheur pour <xref:System.Windows.UIElement.IsEnabled%2A> est) alors la valeur dans le style de thème est ce qui provoque le contrôle d’apparaître "grisé". Mais si vous avez <xref:System.Windows.Controls.Control.Foreground%2A> établi une valeur locale, cette couleur grise normale sera annulée en préséance par votre ensemble de propriété locale, même dans ce scénario déclenché par la propriété. Soyez prudent quand vous définissez des valeurs pour des propriétés qui ont des comportements de déclenchement au niveau du thème, et vérifiez que vous n’interférez pas indûment avec l’expérience utilisateur prévue pour ce contrôle.  
  
<a name="clearvalue"></a>
## <a name="clearvalue-and-value-precedence"></a>ClearValue et priorité de valeur  
 La <xref:System.Windows.DependencyObject.ClearValue%2A> méthode fournit un moyen opportun pour effacer toute valeur appliquée localement à partir d’une propriété de dépendance qui est fixé sur un élément. Toutefois, <xref:System.Windows.DependencyObject.ClearValue%2A> l’appel n’est pas une garantie que le défaut tel qu’établi dans les métadonnées lors de l’enregistrement des biens est la nouvelle valeur effective. Tous les autres participants à la séquence de priorité de valeur sont toujours actifs. Seule la valeur définie localement a été supprimée de la séquence de priorité. Par exemple, si <xref:System.Windows.DependencyObject.ClearValue%2A> vous faites appel à une propriété où cette propriété est également définie par un style thématique, alors la valeur thème est appliquée comme la nouvelle valeur plutôt que le défaut basé sur les métadonnées. Si vous voulez retirer tous les participants de la valeur de la propriété du processus et définir la valeur à la valeur par défaut des métadonnées enregistrées, vous pouvez <xref:System.Windows.DependencyObject.SetValue%2A>obtenir cette valeur par défaut définitivement en interrogeant les métadonnées de propriété de dépendance, et puis vous pouvez utiliser la valeur par défaut pour définir localement la propriété avec un appel à .  
  
## <a name="see-also"></a>Voir aussi

- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- [Aperçu des propriétés de dépendance](dependency-properties-overview.md)
- [Propriétés de dépendance personnalisées](custom-dependency-properties.md)
- [Validation et rappels de propriétés de dépendance](dependency-property-callbacks-and-validation.md)
