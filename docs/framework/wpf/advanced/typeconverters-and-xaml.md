---
title: TypeConverters et XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 6b8b58228e94ed12557e97406e55cc4165753076
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/09/2020
ms.locfileid: "77095084"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="226aa-102">TypeConverters et XAML</span><span class="sxs-lookup"><span data-stu-id="226aa-102">TypeConverters and XAML</span></span>
<span data-ttu-id="226aa-103">Cette rubrique présente l’objectif de la conversion de types de chaîne comme une fonctionnalité générale du langage XAML.</span><span class="sxs-lookup"><span data-stu-id="226aa-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="226aa-104">Dans le .NET Framework, la classe <xref:System.ComponentModel.TypeConverter> sert à un objectif particulier dans le cadre de l’implémentation d’une classe personnalisée managée qui peut être utilisée comme valeur de propriété dans l’utilisation d’attributs XAML.</span><span class="sxs-lookup"><span data-stu-id="226aa-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="226aa-105">Si vous écrivez une classe personnalisée et souhaitez que des instances de votre classe soient utilisables en tant que valeurs d’attribut définissables XAML, vous devrez peut-être appliquer un <xref:System.ComponentModel.TypeConverterAttribute> à votre classe, écrire une classe <xref:System.ComponentModel.TypeConverter> personnalisée, ou les deux.</span><span class="sxs-lookup"><span data-stu-id="226aa-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="226aa-106">Concepts de conversion de type</span><span class="sxs-lookup"><span data-stu-id="226aa-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="226aa-107">XAML et valeurs de chaîne</span><span class="sxs-lookup"><span data-stu-id="226aa-107">XAML and String Values</span></span>  
 <span data-ttu-id="226aa-108">Quand vous définissez une valeur d’attribut dans un fichier XAML, le type initial de cette valeur est une chaîne en texte pur.</span><span class="sxs-lookup"><span data-stu-id="226aa-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="226aa-109">Même les autres primitives telles que <xref:System.Double> sont initialement des chaînes de texte pour un processeur XAML.</span><span class="sxs-lookup"><span data-stu-id="226aa-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="226aa-110">Un processeur XAML a besoin de deux types d’informations pour pouvoir traiter une valeur d’attribut.</span><span class="sxs-lookup"><span data-stu-id="226aa-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="226aa-111">Le premier élément d'information est le type valeur de la propriété à définir.</span><span class="sxs-lookup"><span data-stu-id="226aa-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="226aa-112">N'importe quelle chaîne qui définit une valeur d'attribut et qui est traitée en XAML doit au final être convertie ou résolue en une valeur de ce type.</span><span class="sxs-lookup"><span data-stu-id="226aa-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="226aa-113">Si la valeur est une primitive comprise par l'analyseur XAML (telle qu'une valeur numérique), une conversion directe de la chaîne est tentée.</span><span class="sxs-lookup"><span data-stu-id="226aa-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="226aa-114">Si la valeur est une énumération, la chaîne est utilisée pour rechercher une correspondance de nom à une constante nommée dans cette énumération.</span><span class="sxs-lookup"><span data-stu-id="226aa-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="226aa-115">Si la valeur n’est ni une primitive comprise par l’analyseur, ni une énumération, le type en question doit pouvoir fournir une instance du type ou une valeur, en fonction d’une chaîne convertie.</span><span class="sxs-lookup"><span data-stu-id="226aa-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="226aa-116">Pour cela, vous devez indiquer une classe de convertisseur de type.</span><span class="sxs-lookup"><span data-stu-id="226aa-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="226aa-117">Le convertisseur de type est une classe d’assistance qui sert à fournir des valeurs d’une autre classe, pour le scénario XAML et éventuellement pour les appels de code dans le code .NET.</span><span class="sxs-lookup"><span data-stu-id="226aa-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="226aa-118">Utilisation du comportement de conversion de types existant en XAML</span><span class="sxs-lookup"><span data-stu-id="226aa-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="226aa-119">En fonction de votre connaissance des concepts XAML sous-jacents, il se peut que vous utilisiez déjà un comportement de conversion de types dans des applications XAML de base sans vous en rendre compte.</span><span class="sxs-lookup"><span data-stu-id="226aa-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="226aa-120">Par exemple, WPF définit littéralement des centaines de propriétés qui prennent une valeur de type <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="226aa-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="226aa-121">Une <xref:System.Windows.Point> est une valeur qui décrit une coordonnée dans un espace de coordonnées à deux dimensions, et il a en fait simplement deux propriétés importantes : <xref:System.Windows.Point.X%2A> et <xref:System.Windows.Point.Y%2A>.</span><span class="sxs-lookup"><span data-stu-id="226aa-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="226aa-122">Lorsque vous spécifiez un point en XAML, vous le spécifiez sous la forme d’une chaîne avec un séparateur (généralement une virgule) entre le <xref:System.Windows.Point.X%2A> et <xref:System.Windows.Point.Y%2A> valeurs que vous fournissez.</span><span class="sxs-lookup"><span data-stu-id="226aa-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="226aa-123">Par exemple : `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span><span class="sxs-lookup"><span data-stu-id="226aa-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="226aa-124">Même ce type simple d' <xref:System.Windows.Point> et son utilisation simple en XAML impliquent un convertisseur de type.</span><span class="sxs-lookup"><span data-stu-id="226aa-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="226aa-125">Dans ce cas, il s’agit de la classe <xref:System.Windows.PointConverter>.</span><span class="sxs-lookup"><span data-stu-id="226aa-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="226aa-126">Le convertisseur de type pour <xref:System.Windows.Point> défini au niveau de la classe simplifie les utilisations de balisage de toutes les propriétés qui acceptent des <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="226aa-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="226aa-127">Sans un convertisseur de type ici, vous auriez besoin de la balise suivante beaucoup plus détaillée pour l’exemple indiqué précédemment :</span><span class="sxs-lookup"><span data-stu-id="226aa-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="226aa-128">L’utilisation d’une chaîne de conversion de type ou d’une syntaxe équivalente plus détaillée est une question de style de codage.</span><span class="sxs-lookup"><span data-stu-id="226aa-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="226aa-129">Votre workflow d’outils XAML peut également influencer la définition des valeurs.</span><span class="sxs-lookup"><span data-stu-id="226aa-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="226aa-130">Certains outils XAML ont tendance à émettre la forme la plus détaillée du balisage, car il est plus facile de parcourir les vues du concepteur ou son propre mécanisme de sérialisation.</span><span class="sxs-lookup"><span data-stu-id="226aa-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="226aa-131">Les convertisseurs de type existants peuvent généralement être découverts sur les types WPF et .NET Framework en vérifiant une classe (ou propriété) pour la présence d’une <xref:System.ComponentModel.TypeConverterAttribute>appliquée.</span><span class="sxs-lookup"><span data-stu-id="226aa-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="226aa-132">Cet attribut nomme la classe qui est le convertisseur de type de prise en charge pour les valeurs de ce type, pour les besoins XAML et éventuellement d’autres usages.</span><span class="sxs-lookup"><span data-stu-id="226aa-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="226aa-133">Convertisseurs de type et extensions de balisage</span><span class="sxs-lookup"><span data-stu-id="226aa-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="226aa-134">Les extensions de balisage et les convertisseurs de types remplissent des rôles orthogonaux quant au comportement du processeur XAML et aux scénarios auxquels ils s’appliquent.</span><span class="sxs-lookup"><span data-stu-id="226aa-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="226aa-135">Bien que le contexte soit disponible pour les extensions de balisage, le comportement de la conversion de type des propriétés où une extension de balisage fournit une valeur n’est généralement pas vérifié dans les implémentations d’extension de balisage.</span><span class="sxs-lookup"><span data-stu-id="226aa-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="226aa-136">En d’autres termes, même si une extension de balisage retourne une chaîne de texte comme sortie `ProvideValue`, le comportement de conversion de type associé à cette chaîne tel qu’il est appliqué à une propriété ou un type de valeur de propriété spécifique n’est pas appelé. En général, la fonction d’une extension de balisage consiste à traiter une chaîne et retourner un objet sans faire appel à un convertisseur de type.</span><span class="sxs-lookup"><span data-stu-id="226aa-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="226aa-137">Dans le cadre de la création d’une référence à un objet existant, il est courant d’utiliser une extension de balisage à la place d’un convertisseur de type.</span><span class="sxs-lookup"><span data-stu-id="226aa-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="226aa-138">Au mieux, un convertisseur de type sans état générerait uniquement une nouvelle instance, ce qui peut ne pas être souhaitable.</span><span class="sxs-lookup"><span data-stu-id="226aa-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="226aa-139">Pour plus d’informations sur les extensions de balisage, consultez [Extensions de balisage et XAML WPF](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="226aa-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="226aa-140">Convertisseurs de type natif</span><span class="sxs-lookup"><span data-stu-id="226aa-140">Native Type Converters</span></span>  
 <span data-ttu-id="226aa-141">Dans une implémentation WPF et .NET Framework de l’analyseur XAML, certains types gèrent nativement la conversion de type ; cependant, ces types ne sont pas traditionnellement considérés comme des primitives.</span><span class="sxs-lookup"><span data-stu-id="226aa-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="226aa-142">Un exemple d'un tel type est <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="226aa-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="226aa-143">La raison est basée sur le fonctionnement de l’architecture .NET Framework : le type <xref:System.DateTime> est défini dans mscorlib, la bibliothèque la plus basique dans .NET.</span><span class="sxs-lookup"><span data-stu-id="226aa-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="226aa-144"><xref:System.DateTime> n’est pas autorisé à être attribué avec un attribut qui provient d’un autre assembly qui introduit une dépendance (<xref:System.ComponentModel.TypeConverterAttribute> provient du système), le mécanisme de découverte du convertisseur de type habituel par attribution ne peut pas être pris en charge.</span><span class="sxs-lookup"><span data-stu-id="226aa-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="226aa-145">À la place, l’analyseur XAML dispose d’une liste des types qui doivent faire l’objet d’un traitement natif et traite ces types de la même façon que les véritables primitives.</span><span class="sxs-lookup"><span data-stu-id="226aa-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="226aa-146">(Dans le cas de <xref:System.DateTime> cela implique un appel à <xref:System.DateTime.Parse%2A>.)</span><span class="sxs-lookup"><span data-stu-id="226aa-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="226aa-147">Implémentation d'un convertisseur de type</span><span class="sxs-lookup"><span data-stu-id="226aa-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="226aa-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="226aa-148">TypeConverter</span></span>  
 <span data-ttu-id="226aa-149">Dans l’exemple <xref:System.Windows.Point> donné précédemment, la classe <xref:System.Windows.PointConverter> a été mentionnée.</span><span class="sxs-lookup"><span data-stu-id="226aa-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="226aa-150">Pour les implémentations .NET de XAML, tous les convertisseurs de type utilisés pour le XAML sont des classes qui dérivent de la classe de base <xref:System.ComponentModel.TypeConverter>.</span><span class="sxs-lookup"><span data-stu-id="226aa-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="226aa-151">La classe <xref:System.ComponentModel.TypeConverter> existait dans les versions de .NET Framework qui précèdent l’existence de XAML ; l’une de ses utilisations d’origine consistait à fournir une conversion de chaîne pour les boîtes de dialogue de propriétés dans les concepteurs visuels.</span><span class="sxs-lookup"><span data-stu-id="226aa-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="226aa-152">Pour XAML, le rôle de <xref:System.ComponentModel.TypeConverter> est développé pour inclure la classe de base pour les conversions à chaîne et à partir de chaînes qui permettent d’analyser une valeur d’attribut de chaîne et, éventuellement, de traiter une valeur d’exécution d’une propriété d’objet particulière dans une chaîne pour la sérialisation en tant qu’attribut.</span><span class="sxs-lookup"><span data-stu-id="226aa-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="226aa-153"><xref:System.ComponentModel.TypeConverter> définit quatre membres qui sont pertinents pour la conversion vers et à partir de chaînes à des fins de traitement XAML :</span><span class="sxs-lookup"><span data-stu-id="226aa-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="226aa-154">Parmi celles-ci, la méthode la plus importante est <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="226aa-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="226aa-155">Cette méthode convertit la chaîne d’entrée en type d’objet exigé.</span><span class="sxs-lookup"><span data-stu-id="226aa-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="226aa-156">À proprement parler, la méthode <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> pourrait être implémentée pour convertir un plus grand nombre de types dans le type de destination prévu du convertisseur et, par conséquent, servir des objectifs qui s’étendent au-delà du XAML, tels que la prise en charge des conversions au moment de l’exécution, mais pour le XAML, il s’agit uniquement du chemin de code qui peut traiter <xref:System.String> une entrée</span><span class="sxs-lookup"><span data-stu-id="226aa-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="226aa-157">La méthode la plus importante suivante est <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="226aa-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="226aa-158">Si une application est convertie en représentation de balisage (par exemple, si elle est enregistrée en XAML sous forme de fichier), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> est responsable de la production d’une représentation de balisage.</span><span class="sxs-lookup"><span data-stu-id="226aa-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="226aa-159">Dans ce cas, le chemin de code qui est important pour XAML est lorsque vous transmettez une `destinationType` de <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="226aa-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="226aa-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> et <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> sont des méthodes de support utilisées lorsqu'un service interroge les fonctions de l'implémentation <xref:System.ComponentModel.TypeConverter> .</span><span class="sxs-lookup"><span data-stu-id="226aa-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="226aa-161">Vous devez implémenter ces méthodes pour retourner `true` dans des cas spécifiques au type pris en charge par les méthodes de conversion correspondantes de votre convertisseur.</span><span class="sxs-lookup"><span data-stu-id="226aa-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="226aa-162">Pour le langage XAML, cela correspond généralement au type <xref:System.String> .</span><span class="sxs-lookup"><span data-stu-id="226aa-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="226aa-163">Informations de culture et convertisseurs de type pour XAML</span><span class="sxs-lookup"><span data-stu-id="226aa-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="226aa-164">Chaque implémentation de <xref:System.ComponentModel.TypeConverter> peut avoir sa propre interprétation de ce qui constitue une chaîne valide pour une conversion, et peut également utiliser ou ignorer la description de type passée en tant que paramètres.</span><span class="sxs-lookup"><span data-stu-id="226aa-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="226aa-165">Vous devez tenir compte d’un élément fondamental en ce qui concerne la culture et la conversion de type XAML.</span><span class="sxs-lookup"><span data-stu-id="226aa-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="226aa-166">L’utilisation de chaînes localisables comme valeurs d’attribut est intégralement prise en charge par XAML.</span><span class="sxs-lookup"><span data-stu-id="226aa-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="226aa-167">Mais l’utilisation de cette chaîne localisable comme entrée de convertisseur de type avec des spécifications de culture spécifiques n’est pas prise en charge, car les convertisseurs de types pour les valeurs d’attribut XAML impliquent un comportement d’analyse de langage fixe, à l’aide de la culture `en-US`.</span><span class="sxs-lookup"><span data-stu-id="226aa-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="226aa-168">Pour plus d’informations sur les raisons de conception de cette restriction, consultez la spécification du langage XAML ([\[MS-xaml\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span><span class="sxs-lookup"><span data-stu-id="226aa-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="226aa-169">Par exemple, certaines cultures utilisent une virgule comme séparateur décimal pour les nombres, ce qui peut être un problème.</span><span class="sxs-lookup"><span data-stu-id="226aa-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="226aa-170">Cela crée un conflit avec de nombreux convertisseurs de types XAML WPF qui utilisent une virgule comme séparateur (pour des raisons historiques : forme X,Y courante ou listes délimitées par des virgules).</span><span class="sxs-lookup"><span data-stu-id="226aa-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="226aa-171">Même le passage d’une culture dans le XAML voisin (affectation à `Language` ou `xml:lang` de la culture `sl-SI`, un exemple de culture utilisant une virgule comme séparateur décimal) ne résout pas le problème.</span><span class="sxs-lookup"><span data-stu-id="226aa-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="226aa-172">Implémentation de ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="226aa-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="226aa-173">Pour être utilisable en tant qu'implémentation <xref:System.ComponentModel.TypeConverter> qui prend en charge le code XAML, la méthode <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> du convertisseur doit accepter une chaîne comme paramètre `value` .</span><span class="sxs-lookup"><span data-stu-id="226aa-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="226aa-174">Si la chaîne a un format valide et qu’elle peut être convertie par l’implémentation <xref:System.ComponentModel.TypeConverter>, l’objet retourné doit prendre en charge un cast vers le type attendu par la propriété.</span><span class="sxs-lookup"><span data-stu-id="226aa-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="226aa-175">Sinon, l'implémentation <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> doit retourner `null`.</span><span class="sxs-lookup"><span data-stu-id="226aa-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="226aa-176">Chaque implémentation de <xref:System.ComponentModel.TypeConverter> peut avoir sa propre interprétation de ce qui constitue une chaîne valide pour une conversion, et peut également utiliser ou ignorer la description de type ou les contextes de culture passés comme paramètres.</span><span class="sxs-lookup"><span data-stu-id="226aa-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="226aa-177">Cependant, le traitement XAML WPF peut ne pas passer de valeurs au contexte de description de type dans tous les cas, et également ne pas passer la culture en fonction de `xml:lang`.</span><span class="sxs-lookup"><span data-stu-id="226aa-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="226aa-178">N’utilisez pas les accolades, en particulier {, comme élément possible de format de chaîne.</span><span class="sxs-lookup"><span data-stu-id="226aa-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="226aa-179">Ces caractères sont réservés comme entrée et sortie d'une séquence d'extension de balisage.</span><span class="sxs-lookup"><span data-stu-id="226aa-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="226aa-180">Implémentation de ConvertTo</span><span class="sxs-lookup"><span data-stu-id="226aa-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="226aa-181">La méthode<xref:System.ComponentModel.TypeConverter.ConvertTo%2A> peut être utilisée pour assurer la prise en charge de la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="226aa-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="226aa-182">La prise en charge de la sérialisation via <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> pour votre type personnalisé et son convertisseur de type n'est pas une spécification absolue.</span><span class="sxs-lookup"><span data-stu-id="226aa-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="226aa-183">Toutefois, si vous implémentez un contrôle ou que vous utilisez la sérialisation dans le cadre des fonctionnalités ou de la conception de la classe, vous devez implémenter <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="226aa-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="226aa-184">Pour être utilisable en tant qu’implémentation de <xref:System.ComponentModel.TypeConverter> qui prend en charge XAML, la méthode <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> pour ce convertisseur doit accepter une instance du type (ou une valeur) prise en charge en tant que paramètre `value`.</span><span class="sxs-lookup"><span data-stu-id="226aa-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="226aa-185">Lorsque le paramètre `destinationType` est le type <xref:System.String>, l’objet retourné doit pouvoir être casté en <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="226aa-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="226aa-186">La chaîne retournée doit représenter une valeur sérialisée de `value`.</span><span class="sxs-lookup"><span data-stu-id="226aa-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="226aa-187">Idéalement, le format de sérialisation que vous choisissez doit pouvoir générer la même valeur si cette chaîne était passée à l’implémentation <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> du même convertisseur, sans perte significative d’informations.</span><span class="sxs-lookup"><span data-stu-id="226aa-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="226aa-188">Si la valeur ne peut pas être sérialisée ou que le convertisseur ne prend pas en charge la sérialisation, l’implémentation de <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> doit retourner `null`et est autorisé à lever une exception dans ce cas.</span><span class="sxs-lookup"><span data-stu-id="226aa-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="226aa-189">Toutefois, si vous levez des exceptions, vous devez signaler l’impossibilité d’utiliser cette conversion dans le cadre de votre implémentation de <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>, afin que la meilleure pratique qui consiste à vérifier avec <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> en premier pour éviter les exceptions soit prise en charge.</span><span class="sxs-lookup"><span data-stu-id="226aa-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="226aa-190">Si `destinationType` paramètre n’est pas de type <xref:System.String>, vous pouvez choisir votre propre gestion de convertisseur.</span><span class="sxs-lookup"><span data-stu-id="226aa-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="226aa-191">En général, vous revenez au traitement de l’implémentation de base, qui, dans avec <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>, lève une exception spécifique.</span><span class="sxs-lookup"><span data-stu-id="226aa-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="226aa-192">Implémentation de CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="226aa-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="226aa-193">Votre implémentation de <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> doit retourner la valeur `true` pour `destinationType` de type <xref:System.String>, et sinon déférer à l'implémentation de base.</span><span class="sxs-lookup"><span data-stu-id="226aa-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="226aa-194">Implémentation de CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="226aa-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="226aa-195">Votre implémentation de <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> doit retourner la valeur `true` pour `sourceType` de type <xref:System.String>, et sinon déférer à l'implémentation de base.</span><span class="sxs-lookup"><span data-stu-id="226aa-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="226aa-196">Application de TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="226aa-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="226aa-197">Pour que votre convertisseur de type personnalisé soit utilisé comme convertisseur de type agissant pour une classe personnalisée par un processeur XAML, vous devez appliquer la <xref:System.ComponentModel.TypeConverterAttribute> à votre définition de classe.</span><span class="sxs-lookup"><span data-stu-id="226aa-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="226aa-198">La propriété <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> que vous spécifiez via l'attribut doit être le nom de type du convertisseur de type personnalisé.</span><span class="sxs-lookup"><span data-stu-id="226aa-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="226aa-199">Une fois cet attribut appliqué, quand un processeur XAML gère des valeurs où le type de propriété utilise votre type de classe personnalisée, il peut entrer des chaînes et retourner des instances d’objet.</span><span class="sxs-lookup"><span data-stu-id="226aa-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="226aa-200">Vous pouvez également fournir un convertisseur de type en fonction de la propriété.</span><span class="sxs-lookup"><span data-stu-id="226aa-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="226aa-201">Au lieu d’appliquer un <xref:System.ComponentModel.TypeConverterAttribute> à la définition de classe, appliquez-le à une définition de propriété (la définition principale, et non à la `get`/`set` implémentations qu’il contient).</span><span class="sxs-lookup"><span data-stu-id="226aa-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="226aa-202">Le type de la propriété doit correspondre au type traité par votre convertisseur de type personnalisé.</span><span class="sxs-lookup"><span data-stu-id="226aa-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="226aa-203">Avec cet attribut appliqué, lorsqu'un processeur XAML gère des valeurs de cette propriété, il peut traiter des chaînes d'entrée et retourner des instances d'objet.</span><span class="sxs-lookup"><span data-stu-id="226aa-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="226aa-204">La technique de conversion de type par propriété est particulièrement utile si vous choisissez d’utiliser un type de propriété à partir de Microsoft .NET Framework ou d’une autre bibliothèque où vous ne pouvez pas contrôler la définition de classe et ne pouvez pas appliquer un <xref:System.ComponentModel.TypeConverterAttribute> à cet endroit.</span><span class="sxs-lookup"><span data-stu-id="226aa-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="226aa-205">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="226aa-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="226aa-206">Vue d’ensemble du langage XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="226aa-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="226aa-207">Extensions de balisage et XAML WPF</span><span class="sxs-lookup"><span data-stu-id="226aa-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="226aa-208">Syntaxe XAML en détail</span><span class="sxs-lookup"><span data-stu-id="226aa-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
