---
title: Portées de code XAML
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: 4383492157191f61cf04a2fdd6ce27e9183bda8b
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/24/2020
ms.locfileid: "76744419"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="7d72a-102">Portées de nom XAML WPF</span><span class="sxs-lookup"><span data-stu-id="7d72a-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="7d72a-103">Les portées de nom XAML correspondent à un concept qui identifie des objets définis en XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="7d72a-104">Les noms dans une portée de nom XAML peuvent être utilisés pour établir des relations entre les noms définis en XAML des objets et leurs instances équivalentes dans une arborescence d’objets.</span><span class="sxs-lookup"><span data-stu-id="7d72a-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="7d72a-105">En règle générale, les portées de nom XAML dans du code managé [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sont créées lors du chargement des racines d’une page XAML spécifique pour une application XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="7d72a-106">Les portées de code XAML en tant qu’objet de programmation sont définies par l’interface <xref:System.Windows.Markup.INameScope> et sont également implémentées par la classe pratique <xref:System.Windows.NameScope>.</span><span class="sxs-lookup"><span data-stu-id="7d72a-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="7d72a-107">Portées de nom dans les applications XAML chargées</span><span class="sxs-lookup"><span data-stu-id="7d72a-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="7d72a-108">Dans un contexte plus large de programmation ou d’informatique, les concepts de programmation incluent souvent le principe d’un identificateur ou d’un nom unique, qui peut être utilisé pour accéder à un objet.</span><span class="sxs-lookup"><span data-stu-id="7d72a-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="7d72a-109">Pour les systèmes qui utilisent des identificateurs ou des noms, la portée de nom définit les limites à l’intérieur desquelles un processus ou une technique recherche si un objet de ce nom est demandé, ou les limites dans lesquelles l’unicité des noms qui identifient est appliquée.</span><span class="sxs-lookup"><span data-stu-id="7d72a-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="7d72a-110">Ces principes généraux sont vrais pour les portées de nom XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="7d72a-111">Dans WPF, les portées de nom XAML sont créées sur l’élément racine d’une page XAML quand la page est chargée.</span><span class="sxs-lookup"><span data-stu-id="7d72a-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="7d72a-112">Chaque nom spécifié dans la page XAML en commençant à la racine de la page est ajouté à une portée de nom XAML pertinente.</span><span class="sxs-lookup"><span data-stu-id="7d72a-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="7d72a-113">Dans le XAML WPF, les éléments qui sont des éléments racines courants (tels que <xref:System.Windows.Controls.Page>et <xref:System.Windows.Window>) contrôlent toujours une portée de code XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="7d72a-114">Si un élément tel que <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement> est l’élément racine de la page dans le balisage, un processeur [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] ajoute implicitement une racine de <xref:System.Windows.Controls.Page> afin que le <xref:System.Windows.Controls.Page> puisse fournir une portée de code XAML opérationnelle.</span><span class="sxs-lookup"><span data-stu-id="7d72a-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7d72a-115">Les actions de génération WPF créent une portée de nom XAML pour une production XAML même si aucun attribut `Name` ou `x:Name` n’est défini sur les éléments dans la balisage [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="7d72a-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="7d72a-116">Si vous essayez d’utiliser deux fois le même nom dans une portée de nom XAML, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="7d72a-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="7d72a-117">Pour du XAML WPF qui a du code-behind et qui fait partie d’une application compilée, l’exception est levée au moment de la génération par les actions de génération WPF, lors de la création de la classe générée pour la page pendant la compilation initiale du balisage.</span><span class="sxs-lookup"><span data-stu-id="7d72a-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="7d72a-118">Pour le XAML qui n’est compilé par balisage par aucune action de génération, des exceptions liées aux problèmes de portée de nom XAML peuvent être déclenchées lors du chargement du XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="7d72a-119">Les concepteurs XAML peuvent également anticiper les problèmes de portée de nom XAML au moment du design.</span><span class="sxs-lookup"><span data-stu-id="7d72a-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="7d72a-120">Ajout d’objets à des arborescences d’objets d’exécution</span><span class="sxs-lookup"><span data-stu-id="7d72a-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="7d72a-121">Le moment où le XAML est analysé correspond au moment une portée de nom XAML WPF est créée et définie.</span><span class="sxs-lookup"><span data-stu-id="7d72a-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="7d72a-122">Si vous ajoutez un objet à une arborescence d’objets après l’analyse du code XAML ayant généré cette arborescence, une valeur `Name` ou `x:Name` sur le nouvel objet ne met pas automatiquement à jour les informations contenues dans une portée de nom XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="7d72a-123">Pour ajouter un nom pour un objet dans une portée de nom XAML WPF après le chargement du code XAML, vous devez appeler l’implémentation appropriée de <xref:System.Windows.Markup.INameScope.RegisterName%2A> sur l’objet qui définit la portée de nom XAML, qui est généralement la racine de la page XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="7d72a-124">Si le nom n’est pas inscrit, l’objet ajouté ne peut pas être référencé par nom via des méthodes telles que <xref:System.Windows.FrameworkElement.FindName%2A>, et vous ne pouvez pas utiliser ce nom pour le ciblage d’animation.</span><span class="sxs-lookup"><span data-stu-id="7d72a-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="7d72a-125">Le scénario le plus courant pour les développeurs d’applications est que vous utilisez <xref:System.Windows.FrameworkElement.RegisterName%2A> pour inscrire des noms dans la portée de nom XAML à la racine actuelle de la page.</span><span class="sxs-lookup"><span data-stu-id="7d72a-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="7d72a-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> fait partie d’un scénario important pour les storyboards qui ciblent des objets pour les animations.</span><span class="sxs-lookup"><span data-stu-id="7d72a-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="7d72a-127">Pour plus d’informations, consultez [Vue d’ensemble des plans conceptuels](../graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="7d72a-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="7d72a-128">Si vous appelez <xref:System.Windows.FrameworkElement.RegisterName%2A> sur un objet autre que l’objet qui définit la portée de nom XAML, le nom est toujours inscrit dans la portée de nom XAML dans laquelle l’objet appelant est stocké, comme si vous aviez appelé <xref:System.Windows.FrameworkElement.RegisterName%2A> sur l’objet qui définit la portée de nom XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="7d72a-129">Portées de nom XAML dans du code</span><span class="sxs-lookup"><span data-stu-id="7d72a-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="7d72a-130">Vous pouvez créer et ensuite utiliser des portées de nom XAML dans du code.</span><span class="sxs-lookup"><span data-stu-id="7d72a-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="7d72a-131">Les API et les concepts impliqués dans la création de portée de nom XAML sont les mêmes, même pour une utilisation du code pure, car le processeur XAML pour [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] utilise ces API et concepts quand il traite le XAML lui-même.</span><span class="sxs-lookup"><span data-stu-id="7d72a-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="7d72a-132">Les concepts et l’API existent principalement pour pouvoir rechercher des objets par nom dans une arborescence d’objets définie partiellement ou entièrement en XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="7d72a-133">Pour les applications créées par programme et non à partir du XAML chargé, l’objet qui définit une portée de code XAML doit implémenter <xref:System.Windows.Markup.INameScope>ou être une <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement> classe dérivée, afin de prendre en charge la création d’une portée de code XAML sur ses instances.</span><span class="sxs-lookup"><span data-stu-id="7d72a-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="7d72a-134">De même, pour tout élément qui n’est pas chargé et traité par un processeur XAML, la portée de nom XAML pour l’objet n’est pas créée ou initialisée par défaut.</span><span class="sxs-lookup"><span data-stu-id="7d72a-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="7d72a-135">Vous devez créer explicitement une nouvelle portée de nom XAML pour tout objet dans lequel vous prévoyez d’inscrire des noms par la suite.</span><span class="sxs-lookup"><span data-stu-id="7d72a-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="7d72a-136">Pour créer une portée de code XAML, vous appelez la méthode statique <xref:System.Windows.NameScope.SetNameScope%2A>.</span><span class="sxs-lookup"><span data-stu-id="7d72a-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="7d72a-137">Spécifiez l’objet qui en sera le propriétaire comme paramètre `dependencyObject` et un nouvel appel de constructeur <xref:System.Windows.NameScope.%23ctor%2A> comme paramètre `value`.</span><span class="sxs-lookup"><span data-stu-id="7d72a-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="7d72a-138">Si l’objet fourni comme `dependencyObject` pour <xref:System.Windows.NameScope.SetNameScope%2A> n’est pas une implémentation <xref:System.Windows.Markup.INameScope>, <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>, l’appel de <xref:System.Windows.FrameworkElement.RegisterName%2A> sur tous les éléments enfants n’aura aucun effet.</span><span class="sxs-lookup"><span data-stu-id="7d72a-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="7d72a-139">Si vous ne parvenez pas à créer la nouvelle portée de code XAML explicitement, les appels à <xref:System.Windows.FrameworkElement.RegisterName%2A> lèveront une exception.</span><span class="sxs-lookup"><span data-stu-id="7d72a-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="7d72a-140">Pour obtenir un exemple d’utilisation des API de portée de nom XAML dans du code, consultez [Définir une portée de nom](../graphics-multimedia/how-to-define-a-name-scope.md).</span><span class="sxs-lookup"><span data-stu-id="7d72a-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="7d72a-141">Portées de nom XAML dans les styles et les modèles</span><span class="sxs-lookup"><span data-stu-id="7d72a-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="7d72a-142">Les styles et les modèles dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] permettent de réutiliser et de réappliquer le contenu d’une manière simple.</span><span class="sxs-lookup"><span data-stu-id="7d72a-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="7d72a-143">Toutefois, les styles et les modèles peuvent également inclure des éléments avec des noms XAML définis au niveau d’un modèle.</span><span class="sxs-lookup"><span data-stu-id="7d72a-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="7d72a-144">Ce même modèle peut être utilisé plusieurs fois dans une page.</span><span class="sxs-lookup"><span data-stu-id="7d72a-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="7d72a-145">Pour cette raison, les styles et les modèles définissent tous deux leurs propres portées de nom XAML, indépendamment de l’emplacement où le style ou le modèle est appliqué dans une arborescence d’objets.</span><span class="sxs-lookup"><span data-stu-id="7d72a-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="7d72a-146">Prenons l'exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="7d72a-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="7d72a-147">Ici, le même modèle est appliqué à deux boutons différents.</span><span class="sxs-lookup"><span data-stu-id="7d72a-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="7d72a-148">Si les modèles n’avaient pas de portées de nom XAML discrètes, le nom `TheBorder` utilisé dans le modèle provoquerait un conflit de noms dans la portée de nom XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="7d72a-149">Chaque instanciation du modèle a sa propre portée de nom XAML. Ainsi, dans cet exemple, la portée de nom XAML de chaque modèle instancié contient un et un seul nom.</span><span class="sxs-lookup"><span data-stu-id="7d72a-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="7d72a-150">Les styles définissent également leur propre portée de nom XAML, principalement pour que des noms particuliers puissent être affectés aux différentes parties des plans conceptuels.</span><span class="sxs-lookup"><span data-stu-id="7d72a-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="7d72a-151">Ces noms activent des comportements spécifiques des contrôles qui ciblent les éléments de ce nom, même si le modèle a été redéfini dans le cadre de la personnalisation du contrôle.</span><span class="sxs-lookup"><span data-stu-id="7d72a-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="7d72a-152">En raison des portées de nom XAML distinctes, rechercher des éléments nommés dans un modèle est plus difficile que rechercher dans une page un élément nommé non basé sur un modèle.</span><span class="sxs-lookup"><span data-stu-id="7d72a-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="7d72a-153">Vous devez d’abord déterminer le modèle appliqué, en obtenant la valeur de propriété <xref:System.Windows.Controls.Control.Template%2A> du contrôle où le modèle est appliqué.</span><span class="sxs-lookup"><span data-stu-id="7d72a-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="7d72a-154">Ensuite, vous appelez la version de modèle de <xref:System.Windows.FrameworkTemplate.FindName%2A>, en passant le contrôle où le modèle a été appliqué comme deuxième paramètre.</span><span class="sxs-lookup"><span data-stu-id="7d72a-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="7d72a-155">Si vous êtes un auteur de contrôle et que vous générez une Convention où un élément nommé particulier dans un modèle appliqué est la cible d’un comportement défini par le contrôle lui-même, vous pouvez utiliser la méthode <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> à partir du code d’implémentation de votre contrôle.</span><span class="sxs-lookup"><span data-stu-id="7d72a-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="7d72a-156">La méthode <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> est protégée, donc seul l’auteur du contrôle y a accès.</span><span class="sxs-lookup"><span data-stu-id="7d72a-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="7d72a-157">Si vous travaillez à partir d’un modèle et que vous devez accéder à la portée de code XAML où le modèle est appliqué, récupérez la valeur de <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, puis appelez <xref:System.Windows.FrameworkElement.FindName%2A> ici.</span><span class="sxs-lookup"><span data-stu-id="7d72a-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="7d72a-158">Un exemple de travail à l’intérieur du modèle est l’écriture de l’implémentation du gestionnaire d’événements là où l’événement est déclenché à partir d’un élément dans un modèle appliqué.</span><span class="sxs-lookup"><span data-stu-id="7d72a-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="7d72a-159">Portées de nom XAML et API relatives aux noms</span><span class="sxs-lookup"><span data-stu-id="7d72a-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="7d72a-160"><xref:System.Windows.FrameworkElement> a des méthodes <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> et <xref:System.Windows.FrameworkElement.UnregisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="7d72a-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="7d72a-161">Si l’objet sur lequel vous appelez ces méthodes a une portée de nom XAML, les méthodes font les appels au sein des méthodes de la portée de nom XAML appropriée.</span><span class="sxs-lookup"><span data-stu-id="7d72a-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="7d72a-162">Sinon, l’élément parent est vérifié pour voir s’il détient une portée de nom XAML, et ce processus continue de manière récursive jusqu’à ce qu’une portée de nom XAML soit trouvée (en raison du comportement du processeur XAML, la présence d’une portée de nom XAML à la racine est garantie).</span><span class="sxs-lookup"><span data-stu-id="7d72a-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="7d72a-163"><xref:System.Windows.FrameworkContentElement> a des comportements analogues, à l’exception du fait qu’aucune <xref:System.Windows.FrameworkContentElement> ne possèdera jamais une portée de code XAML.</span><span class="sxs-lookup"><span data-stu-id="7d72a-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="7d72a-164">Les méthodes existent sur <xref:System.Windows.FrameworkContentElement> afin que les appels puissent être transférés finalement à un élément parent <xref:System.Windows.FrameworkElement>.</span><span class="sxs-lookup"><span data-stu-id="7d72a-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="7d72a-165"><xref:System.Windows.NameScope.SetNameScope%2A> est utilisé pour mapper une nouvelle portée de code XAML à un objet existant.</span><span class="sxs-lookup"><span data-stu-id="7d72a-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="7d72a-166">Vous pouvez appeler <xref:System.Windows.NameScope.SetNameScope%2A> plusieurs fois pour réinitialiser ou effacer la portée de code XAML, mais cela n’est pas une utilisation courante.</span><span class="sxs-lookup"><span data-stu-id="7d72a-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="7d72a-167">En outre, <xref:System.Windows.NameScope.GetNameScope%2A> n’est généralement pas utilisé à partir du code.</span><span class="sxs-lookup"><span data-stu-id="7d72a-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="7d72a-168">Implémentations de portée de nom XAML</span><span class="sxs-lookup"><span data-stu-id="7d72a-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="7d72a-169">Les classes suivantes implémentent <xref:System.Windows.Markup.INameScope> directement :</span><span class="sxs-lookup"><span data-stu-id="7d72a-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="7d72a-170"><xref:System.Windows.ResourceDictionary> n’utilise pas de noms ou de portées de nom XAML ; elle utilise à la place des clés, car il s’agit d’une implémentation de dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="7d72a-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="7d72a-171">La seule raison pour laquelle <xref:System.Windows.ResourceDictionary> implémente <xref:System.Windows.Markup.INameScope> est donc qu’elle peut lever des exceptions au code utilisateur pour clarifier la distinction entre une véritable portée de code XAML et la façon dont un <xref:System.Windows.ResourceDictionary> gère les clés, ainsi que pour s’assurer que les portées de port XAML ne sont pas appliquées à une <xref:System.Windows.ResourceDictionary> par les éléments parents.</span><span class="sxs-lookup"><span data-stu-id="7d72a-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="7d72a-172"><xref:System.Windows.FrameworkTemplate> et <xref:System.Windows.Style> implémentent <xref:System.Windows.Markup.INameScope> via des définitions d’interface explicites.</span><span class="sxs-lookup"><span data-stu-id="7d72a-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="7d72a-173">Les implémentations explicites permettent à ces portées de code XAML de se comporter de façon conventionnelle quand elles sont accessibles par le biais de l’interface <xref:System.Windows.Markup.INameScope>, ce qui explique comment les portées de code XAML sont communiquées par [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processus internes.</span><span class="sxs-lookup"><span data-stu-id="7d72a-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="7d72a-174">Toutefois, les définitions d’interface explicites ne font pas partie de la surface d’API conventionnelle de <xref:System.Windows.FrameworkTemplate> et <xref:System.Windows.Style>, car il est rarement nécessaire d’appeler les méthodes <xref:System.Windows.Markup.INameScope> sur <xref:System.Windows.FrameworkTemplate> et <xref:System.Windows.Style> directement, et d’utiliser à la place une autre API comme <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span><span class="sxs-lookup"><span data-stu-id="7d72a-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="7d72a-175">Les classes suivantes définissent leur propre portée de code XAML, en utilisant la classe d’assistance <xref:System.Windows.NameScope?displayProperty=nameWithType> et en se connectant à son implémentation de portée de code XAML via la propriété jointe <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="7d72a-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="7d72a-176">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="7d72a-176">See also</span></span>

- [<span data-ttu-id="7d72a-177">Espaces de noms XAML et mappage d'espace de noms pour XAML WPF</span><span class="sxs-lookup"><span data-stu-id="7d72a-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="7d72a-178">x:Name, directive</span><span class="sxs-lookup"><span data-stu-id="7d72a-178">x:Name Directive</span></span>](../../../desktop-wpf/xaml-services/xname-directive.md)
