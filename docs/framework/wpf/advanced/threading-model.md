---
title: Modèle de thread
description: En savoir plus sur les situations où vous pouvez avoir besoin de plusieurs threads dans votre application Windows Presentation Foundation. Les solutions à thread unique sont préférées.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 9b67b6ea2896e9e6fec57dee8d1013d54fab03fc
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/24/2020
ms.locfileid: "87166377"
---
# <a name="threading-model"></a><span data-ttu-id="89cc9-104">Modèle de thread</span><span class="sxs-lookup"><span data-stu-id="89cc9-104">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="89cc9-105">est conçu pour épargner aux développeurs les difficultés d’utilisation des threads.</span><span class="sxs-lookup"><span data-stu-id="89cc9-105">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="89cc9-106">Par conséquent, la majorité des [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] développeurs n’auront pas à écrire une interface qui utilise plus d’un thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-106">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="89cc9-107">Comme les programmes multithreads sont complexes et difficiles à déboguer, il est préférable de les éviter quand des solutions à thread unique existent.</span><span class="sxs-lookup"><span data-stu-id="89cc9-107">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="89cc9-108">Quelle que soit la façon dont l’architecture est bien conçue, aucune [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] infrastructure ne pourra jamais fournir une solution à thread unique pour chaque type de problème.</span><span class="sxs-lookup"><span data-stu-id="89cc9-108">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="89cc9-109">est proche, mais il existe toujours des situations où plusieurs threads améliorent la [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] réactivité ou les performances de l’application.</span><span class="sxs-lookup"><span data-stu-id="89cc9-109">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="89cc9-110">Après avoir présenté des informations d’ordre général, ce document explore certaines de ces situations puis se termine par une présentation de certaines informations de bas niveau.</span><span class="sxs-lookup"><span data-stu-id="89cc9-110">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="89cc9-111">Cette rubrique décrit le Threading à l’aide <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> de la méthode pour les appels asynchrones.</span><span class="sxs-lookup"><span data-stu-id="89cc9-111">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="89cc9-112">Vous pouvez également effectuer des appels asynchrones en appelant la <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> méthode, qui prend un <xref:System.Action> ou <xref:System.Func%601> comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="89cc9-112">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="89cc9-113">La <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> méthode retourne un <xref:System.Windows.Threading.DispatcherOperation> ou <xref:System.Windows.Threading.DispatcherOperation%601> , qui a une <xref:System.Windows.Threading.DispatcherOperation.Task%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="89cc9-113">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="89cc9-114">Vous pouvez utiliser le `await` mot clé avec le <xref:System.Windows.Threading.DispatcherOperation> ou le associé <xref:System.Threading.Tasks.Task> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-114">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="89cc9-115">Si vous devez attendre de façon synchrone le <xref:System.Threading.Tasks.Task> retourné par un <xref:System.Windows.Threading.DispatcherOperation> ou <xref:System.Windows.Threading.DispatcherOperation%601> , appelez la <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> méthode d’extension.</span><span class="sxs-lookup"><span data-stu-id="89cc9-115">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="89cc9-116"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>L’appel de provoque un interblocage.</span><span class="sxs-lookup"><span data-stu-id="89cc9-116">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="89cc9-117">Pour plus d’informations sur l’utilisation <xref:System.Threading.Tasks.Task> d’un pour effectuer des opérations asynchrones, consultez Parallélisme des tâches.</span><span class="sxs-lookup"><span data-stu-id="89cc9-117">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="89cc9-118">La <xref:System.Windows.Threading.Dispatcher.Invoke%2A> méthode a également des surcharges qui prennent un <xref:System.Action> ou <xref:System.Func%601> comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="89cc9-118">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="89cc9-119">Vous pouvez utiliser la <xref:System.Windows.Threading.Dispatcher.Invoke%2A> méthode pour effectuer des appels synchrones en passant un délégué, <xref:System.Action> ou <xref:System.Func%601> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-119">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="89cc9-120">Vue d’ensemble du répartiteur</span><span class="sxs-lookup"><span data-stu-id="89cc9-120">Overview and the Dispatcher</span></span>
 <span data-ttu-id="89cc9-121">En règle générale, les [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications démarrent avec deux threads : une pour gérer le rendu et une autre pour gérer le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="89cc9-121">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="89cc9-122">Le thread de rendu s’exécute efficacement en arrière-plan pendant que le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread reçoit l’entrée, gère les événements, peint l’écran et exécute le code de l’application.</span><span class="sxs-lookup"><span data-stu-id="89cc9-122">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="89cc9-123">La plupart des applications utilisent un seul [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, bien que dans certaines situations, il est préférable d’en utiliser plusieurs.</span><span class="sxs-lookup"><span data-stu-id="89cc9-123">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="89cc9-124">Nous traitons de cet aspect plus loin avec un exemple.</span><span class="sxs-lookup"><span data-stu-id="89cc9-124">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="89cc9-125">Le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread met en file d’attente des éléments de travail à l’intérieur d’un objet appelé <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-125">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="89cc9-126">Le <xref:System.Windows.Threading.Dispatcher> sélectionne des éléments de travail en fonction de l'ordre de priorité et exécute chacun d'eux jusqu'à leur achèvement.</span><span class="sxs-lookup"><span data-stu-id="89cc9-126">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="89cc9-127">Chaque [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread doit avoir au moins un <xref:System.Windows.Threading.Dispatcher> , et chaque thread <xref:System.Windows.Threading.Dispatcher> peut exécuter des éléments de travail dans un seul thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-127">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="89cc9-128">L’astuce pour créer des applications réactives et conviviales est d’optimiser le <xref:System.Windows.Threading.Dispatcher> débit en réduisant la taille des éléments de travail.</span><span class="sxs-lookup"><span data-stu-id="89cc9-128">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="89cc9-129">De cette façon, les éléments ne sont jamais périmés dans la <xref:System.Windows.Threading.Dispatcher> file d’attente de traitement.</span><span class="sxs-lookup"><span data-stu-id="89cc9-129">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="89cc9-130">Tout délai perceptible entre une entrée et sa réponse peut frustrer un utilisateur.</span><span class="sxs-lookup"><span data-stu-id="89cc9-130">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="89cc9-131">Comment les applications sont-elles [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] censées gérer des opérations volumineuses ?</span><span class="sxs-lookup"><span data-stu-id="89cc9-131">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="89cc9-132">Que se passe-t-il si votre code implique un grand calcul ou doit interroger une base de données sur un serveur distant ?</span><span class="sxs-lookup"><span data-stu-id="89cc9-132">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="89cc9-133">En règle générale, la réponse consiste à gérer la grande opération dans un thread distinct, ce qui laisse le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread libre de faire face aux éléments de la <xref:System.Windows.Threading.Dispatcher> file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89cc9-133">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="89cc9-134">Lorsque la grande opération est terminée, elle peut signaler son résultat au [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread pour l’affichage.</span><span class="sxs-lookup"><span data-stu-id="89cc9-134">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="89cc9-135">Historiquement, Windows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] n’autorise l’accès aux éléments que par le thread qui les a créés.</span><span class="sxs-lookup"><span data-stu-id="89cc9-135">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="89cc9-136">Cela signifie qu’un thread d’arrière-plan chargé des tâches d’exécution longue ne peut pas mettre à jour une zone de texte quand il est terminé.</span><span class="sxs-lookup"><span data-stu-id="89cc9-136">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="89cc9-137">Windows effectue cela pour garantir l’intégrité des [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] composants.</span><span class="sxs-lookup"><span data-stu-id="89cc9-137">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="89cc9-138">Une zone de liste pourrait sembler étrange si son contenu était mis à jour par un thread d’arrière-plan pendant la phase de dessin.</span><span class="sxs-lookup"><span data-stu-id="89cc9-138">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="89cc9-139">a un mécanisme d’exclusion mutuelle intégré qui applique cette coordination.</span><span class="sxs-lookup"><span data-stu-id="89cc9-139">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="89cc9-140">La plupart des classes dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dérivent de <xref:System.Windows.Threading.DispatcherObject> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-140">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="89cc9-141">Lors de la construction, un <xref:System.Windows.Threading.DispatcherObject> stocke une référence au <xref:System.Windows.Threading.Dispatcher> thread en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="89cc9-141">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="89cc9-142">En effet, le <xref:System.Windows.Threading.DispatcherObject> associe au thread qui le crée.</span><span class="sxs-lookup"><span data-stu-id="89cc9-142">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="89cc9-143">Pendant l’exécution du programme, un <xref:System.Windows.Threading.DispatcherObject> peut appeler sa <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> méthode publique.</span><span class="sxs-lookup"><span data-stu-id="89cc9-143">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="89cc9-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>examine le <xref:System.Windows.Threading.Dispatcher> associé au thread actuel et le compare à la <xref:System.Windows.Threading.Dispatcher> référence stockée pendant la construction.</span><span class="sxs-lookup"><span data-stu-id="89cc9-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="89cc9-145">Si elles ne correspondent pas, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> lève une exception.</span><span class="sxs-lookup"><span data-stu-id="89cc9-145">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="89cc9-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>est destiné à être appelé au début de chaque méthode appartenant à un <xref:System.Windows.Threading.DispatcherObject> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="89cc9-147">Si un seul thread peut modifier le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] , comment les threads d’arrière-plan interagissent-ils avec l’utilisateur ?</span><span class="sxs-lookup"><span data-stu-id="89cc9-147">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="89cc9-148">Un thread d’arrière-plan peut demander au [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread d’effectuer une opération en son nom.</span><span class="sxs-lookup"><span data-stu-id="89cc9-148">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="89cc9-149">Pour ce faire, il inscrit un élément de travail avec le <xref:System.Windows.Threading.Dispatcher> du [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-149">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="89cc9-150">La <xref:System.Windows.Threading.Dispatcher> classe fournit deux méthodes pour l’enregistrement des éléments de travail : <xref:System.Windows.Threading.Dispatcher.Invoke%2A> et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-150">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="89cc9-151">Ces deux méthodes planifient un délégué pour l’exécution.</span><span class="sxs-lookup"><span data-stu-id="89cc9-151">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="89cc9-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>est un appel synchrone, autrement dit, il ne retourne pas tant que le thread n’a pas [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] fini d’exécuter le délégué.</span><span class="sxs-lookup"><span data-stu-id="89cc9-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="89cc9-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>est asynchrone et est retourné immédiatement.</span><span class="sxs-lookup"><span data-stu-id="89cc9-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="89cc9-154"><xref:System.Windows.Threading.Dispatcher>Trie les éléments dans sa file d’attente par priorité.</span><span class="sxs-lookup"><span data-stu-id="89cc9-154">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="89cc9-155">Dix niveaux peuvent être spécifiés lors de l’ajout d’un élément à la <xref:System.Windows.Threading.Dispatcher> file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89cc9-155">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="89cc9-156">Ces priorités sont conservées dans l' <xref:System.Windows.Threading.DispatcherPriority> énumération.</span><span class="sxs-lookup"><span data-stu-id="89cc9-156">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="89cc9-157">Vous trouverez des informations détaillées sur <xref:System.Windows.Threading.DispatcherPriority> les niveaux dans la documentation SDK Windows.</span><span class="sxs-lookup"><span data-stu-id="89cc9-157">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="89cc9-158">Threads en action : les exemples</span><span class="sxs-lookup"><span data-stu-id="89cc9-158">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="89cc9-159">Une application à thread unique avec un calcul de longue durée</span><span class="sxs-lookup"><span data-stu-id="89cc9-159">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="89cc9-160">La plupart des interfaces utilisateur graphiques (GUI) passent une grande partie de leur temps d’inactivité lors de l’attente des événements qui sont générés en réponse aux interactions de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="89cc9-160">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="89cc9-161">Avec une programmation minutieuse, cette durée d’inactivité peut être utilisée de façon constructive, sans affecter la réactivité de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="89cc9-161">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="89cc9-162">Le [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] modèle de thread ne permet pas à l’entrée d’interrompre une opération qui se produit dans le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-162">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="89cc9-163">Cela signifie que vous devez être certain de revenir à <xref:System.Windows.Threading.Dispatcher> régulièrement pour traiter les événements d’entrée en attente avant qu’ils ne soient obsolètes.</span><span class="sxs-lookup"><span data-stu-id="89cc9-163">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="89cc9-164">Prenons l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="89cc9-164">Consider the following example:</span></span>

 ![Capture d’écran montrant le Threading des nombres premiers.](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="89cc9-166">Cette application simple compte à partir de trois de façon croissante, en recherchant les nombres premiers.</span><span class="sxs-lookup"><span data-stu-id="89cc9-166">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="89cc9-167">Lorsque l’utilisateur clique sur le bouton **Démarrer** , la recherche commence.</span><span class="sxs-lookup"><span data-stu-id="89cc9-167">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="89cc9-168">Quand le programme trouve un nombre premier, il met à jour l’interface utilisateur avec sa découverte.</span><span class="sxs-lookup"><span data-stu-id="89cc9-168">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="89cc9-169">À tout moment, l’utilisateur peut arrêter la recherche.</span><span class="sxs-lookup"><span data-stu-id="89cc9-169">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="89cc9-170">Bien qu’assez simple, la recherche des nombres premiers peut être illimitée dans le temps, ce qui présente quelques difficultés.</span><span class="sxs-lookup"><span data-stu-id="89cc9-170">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="89cc9-171">Si nous avons géré l’intégralité de la recherche à l’intérieur du gestionnaire d’événements Click du bouton, nous ne donnerions jamais [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] à ce thread la possibilité de gérer d’autres événements.</span><span class="sxs-lookup"><span data-stu-id="89cc9-171">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="89cc9-172">Le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] n’est pas en mesure de répondre aux messages d’entrée ou de traitement.</span><span class="sxs-lookup"><span data-stu-id="89cc9-172">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="89cc9-173">Elle ne redessinerait jamais l’interface et ne répondrait jamais aux clics sur le bouton.</span><span class="sxs-lookup"><span data-stu-id="89cc9-173">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="89cc9-174">Nous aurions pu effectuer la recherche des nombres premiers dans un thread distinct, mais nous devrions alors faire face à des problèmes de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="89cc9-174">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="89cc9-175">Avec une approche à thread unique, nous pouvons directement mettre à jour le libellé qui indique le plus grand nombre premier trouvé.</span><span class="sxs-lookup"><span data-stu-id="89cc9-175">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="89cc9-176">Si nous divisons la tâche de calcul en segments gérables, nous pouvons retourner périodiquement au <xref:System.Windows.Threading.Dispatcher> et traiter les événements.</span><span class="sxs-lookup"><span data-stu-id="89cc9-176">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="89cc9-177">Nous pouvons offrir la [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] possibilité de redessiner et de traiter l’entrée.</span><span class="sxs-lookup"><span data-stu-id="89cc9-177">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="89cc9-178">La meilleure façon de fractionner le temps de traitement entre le calcul et la gestion des événements consiste à gérer le calcul à partir du <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-178">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="89cc9-179">À l’aide de la <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> méthode, nous pouvons planifier des vérifications de nombres premiers dans la même file d’attente que celle [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] à partir de laquelle les événements sont dessinés.</span><span class="sxs-lookup"><span data-stu-id="89cc9-179">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="89cc9-180">Dans notre exemple, nous planifions une seule vérification de nombre premier à la fois.</span><span class="sxs-lookup"><span data-stu-id="89cc9-180">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="89cc9-181">Une fois la vérification de nombre premier terminée, nous planifions immédiatement la vérification suivante.</span><span class="sxs-lookup"><span data-stu-id="89cc9-181">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="89cc9-182">Cette vérification se poursuit uniquement après la [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] gestion des événements en attente.</span><span class="sxs-lookup"><span data-stu-id="89cc9-182">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![Capture d’écran montrant la file d’attente du répartiteur.](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="89cc9-184">Microsoft Word effectue une vérification orthographique à l’aide de ce mécanisme.</span><span class="sxs-lookup"><span data-stu-id="89cc9-184">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="89cc9-185">La vérification orthographique est effectuée en arrière-plan à l’aide de la durée d’inactivité du [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-185">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="89cc9-186">Regardons ce code.</span><span class="sxs-lookup"><span data-stu-id="89cc9-186">Let's take a look at the code.</span></span>

 <span data-ttu-id="89cc9-187">L’exemple suivant montre le code XAML qui crée l’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="89cc9-187">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="89cc9-188">L’exemple suivant montre le code-behind.</span><span class="sxs-lookup"><span data-stu-id="89cc9-188">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="89cc9-189">L’exemple suivant montre le gestionnaire d’événements pour le <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-189">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="89cc9-190">Outre la mise à jour du texte sur le <xref:System.Windows.Controls.Button> , ce gestionnaire est chargé de planifier la première vérification du nombre premier en ajoutant un délégué à la <xref:System.Windows.Threading.Dispatcher> file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89cc9-190">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="89cc9-191">Quelque temps après que ce gestionnaire d’événements a terminé son travail, le <xref:System.Windows.Threading.Dispatcher> sélectionne ce délégué pour l’exécution.</span><span class="sxs-lookup"><span data-stu-id="89cc9-191">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="89cc9-192">Comme nous l’avons mentionné précédemment, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est le <xref:System.Windows.Threading.Dispatcher> membre utilisé pour planifier l’exécution d’un délégué.</span><span class="sxs-lookup"><span data-stu-id="89cc9-192">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="89cc9-193">Dans ce cas, nous choisissons la <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priorité.</span><span class="sxs-lookup"><span data-stu-id="89cc9-193">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="89cc9-194">Le <xref:System.Windows.Threading.Dispatcher> exécute ce délégué uniquement lorsqu’il n’y a pas d’événements importants à traiter.</span><span class="sxs-lookup"><span data-stu-id="89cc9-194">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> <span data-ttu-id="89cc9-195">La réactivité de l’[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] est plus importante que la vérification des nombres.</span><span class="sxs-lookup"><span data-stu-id="89cc9-195">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] responsiveness is more important than number checking.</span></span> <span data-ttu-id="89cc9-196">Nous passons également un nouveau délégué qui représente la routine de vérification des nombres.</span><span class="sxs-lookup"><span data-stu-id="89cc9-196">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="89cc9-197">Cette méthode vérifie si le nombre impair suivant est un nombre premier.</span><span class="sxs-lookup"><span data-stu-id="89cc9-197">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="89cc9-198">S’il s’agit d’un premier, la méthode met à jour directement `bigPrime` <xref:System.Windows.Controls.TextBlock> pour refléter sa découverte.</span><span class="sxs-lookup"><span data-stu-id="89cc9-198">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="89cc9-199">Nous pouvons procéder ainsi, car le calcul est effectué dans le même thread que celui utilisé pour créer le composant.</span><span class="sxs-lookup"><span data-stu-id="89cc9-199">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="89cc9-200">Si nous avions choisi d’utiliser un thread distinct pour le calcul, nous devrions utiliser un mécanisme de synchronisation plus complexe et exécuter la mise à jour dans le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-200">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="89cc9-201">Nous montrerons cette situation plus loin.</span><span class="sxs-lookup"><span data-stu-id="89cc9-201">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="89cc9-202">Pour obtenir le code source complet de cet exemple, consultez l' [exemple application à thread unique avec calcul de longue durée](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication) .</span><span class="sxs-lookup"><span data-stu-id="89cc9-202">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="89cc9-203">Gestion d’une opération bloquante avec un thread d’arrière-plan</span><span class="sxs-lookup"><span data-stu-id="89cc9-203">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="89cc9-204">La gestion des opérations bloquantes dans une application graphique peuvent être difficile.</span><span class="sxs-lookup"><span data-stu-id="89cc9-204">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="89cc9-205">Nous ne voulons pas appeler des méthodes bloquantes à partir de gestionnaires d’événements, car l’application apparaîtra figée.</span><span class="sxs-lookup"><span data-stu-id="89cc9-205">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="89cc9-206">Nous pouvons utiliser un thread distinct pour gérer ces opérations, mais quand nous avons terminé, nous devons effectuer une synchronisation avec le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, car nous ne pouvons pas directement modifier l’interface graphique utilisateur à partir de notre thread de travail.</span><span class="sxs-lookup"><span data-stu-id="89cc9-206">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="89cc9-207">Nous pouvons utiliser <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> pour insérer des délégués dans le <xref:System.Windows.Threading.Dispatcher> du [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-207">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="89cc9-208">Finalement, ces délégués seront exécutés avec l’autorisation de modifier les [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] éléments.</span><span class="sxs-lookup"><span data-stu-id="89cc9-208">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="89cc9-209">Dans cet exemple, nous simulons un appel de procédure distante qui récupère une prévision météorologique.</span><span class="sxs-lookup"><span data-stu-id="89cc9-209">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="89cc9-210">Nous utilisons un thread de travail distinct pour exécuter cet appel et nous planifions une méthode de mise à jour dans le <xref:System.Windows.Threading.Dispatcher> du [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread lorsque nous aurons terminé.</span><span class="sxs-lookup"><span data-stu-id="89cc9-210">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![Capture d’écran montrant l’interface utilisateur météo.](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="89cc9-212">Voici quelques-uns des détails à noter.</span><span class="sxs-lookup"><span data-stu-id="89cc9-212">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="89cc9-213">Création du gestionnaire de bouton</span><span class="sxs-lookup"><span data-stu-id="89cc9-213">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="89cc9-214">Quand l’utilisateur clique sur le bouton, nous affichons le dessin de l’horloge et nous commençons son animation.</span><span class="sxs-lookup"><span data-stu-id="89cc9-214">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="89cc9-215">Nous désactivons le bouton.</span><span class="sxs-lookup"><span data-stu-id="89cc9-215">We disable the button.</span></span> <span data-ttu-id="89cc9-216">Nous invoquons la `FetchWeatherFromServer` méthode dans un nouveau thread, puis nous retournons, ce qui permet au <xref:System.Windows.Threading.Dispatcher> de traiter les événements pendant que nous attendons la collecte des prévisions météorologiques.</span><span class="sxs-lookup"><span data-stu-id="89cc9-216">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="89cc9-217">Récupération de la météo</span><span class="sxs-lookup"><span data-stu-id="89cc9-217">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="89cc9-218">Pour simplifier les choses, nous n’ajoutons pas de code pour la mise en réseau dans cet exemple.</span><span class="sxs-lookup"><span data-stu-id="89cc9-218">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="89cc9-219">Au lieu de cela, nous simulons le délai d’accès réseau en plaçant notre nouveau thread en veille pendant quatre secondes.</span><span class="sxs-lookup"><span data-stu-id="89cc9-219">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="89cc9-220">Dans ce temps, le thread d’origine [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] est toujours en cours d’exécution et répond aux événements.</span><span class="sxs-lookup"><span data-stu-id="89cc9-220">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="89cc9-221">Pour illustrer ceci, nous avons laissé une animation en cours d’exécution, et les boutons pour réduire et pour agrandir continuent également de fonctionner.</span><span class="sxs-lookup"><span data-stu-id="89cc9-221">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="89cc9-222">Une fois le délai terminé, et que nous avons sélectionné de manière aléatoire nos prévisions météorologiques, il est temps de le signaler au [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-222">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="89cc9-223">Pour ce faire, nous planifions un appel à `UpdateUserInterface` dans le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread à l’aide de ce thread <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-223">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="89cc9-224">Nous passons une chaîne décrivant la météo à cet appel de méthode planifié.</span><span class="sxs-lookup"><span data-stu-id="89cc9-224">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="89cc9-225">Mise à jour de la[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="89cc9-225">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="89cc9-226">Quand le du <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a le temps, il exécute l’appel planifié à `UpdateUserInterface` .</span><span class="sxs-lookup"><span data-stu-id="89cc9-226">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="89cc9-227">Cette méthode arrête l’animation de l’horloge et choisit une image pour décrire le temps.</span><span class="sxs-lookup"><span data-stu-id="89cc9-227">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="89cc9-228">Il affiche cette image et restaure le bouton de récupération des prévisions météo (« fetch forecast »).</span><span class="sxs-lookup"><span data-stu-id="89cc9-228">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="89cc9-229">Plusieurs fenêtres, plusieurs threads</span><span class="sxs-lookup"><span data-stu-id="89cc9-229">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="89cc9-230">Certaines [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications requièrent plusieurs fenêtres de niveau supérieur.</span><span class="sxs-lookup"><span data-stu-id="89cc9-230">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="89cc9-231">Il est tout à fait acceptable pour un thread/une <xref:System.Windows.Threading.Dispatcher> combinaison de gérer plusieurs fenêtres, mais parfois, plusieurs threads font un meilleur travail.</span><span class="sxs-lookup"><span data-stu-id="89cc9-231">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="89cc9-232">Ceci est particulièrement vrai s’il y a un risque que l’une des fenêtres monopolise le thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-232">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="89cc9-233">L’Explorateur Windows fonctionne de cette façon.</span><span class="sxs-lookup"><span data-stu-id="89cc9-233">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="89cc9-234">Chaque nouvelle fenêtre de l’Explorateur appartient au processus d’origine, mais elle est créée sous le contrôle d’un thread indépendant.</span><span class="sxs-lookup"><span data-stu-id="89cc9-234">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="89cc9-235">À l’aide d’un [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame> contrôle, nous pouvons afficher des pages Web.</span><span class="sxs-lookup"><span data-stu-id="89cc9-235">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="89cc9-236">Nous pouvons facilement créer un substitut simple d’Internet Explorer.</span><span class="sxs-lookup"><span data-stu-id="89cc9-236">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="89cc9-237">Nous commençons par une fonctionnalité importante : la possibilité d’ouvrir une nouvelle fenêtre d’explorateur.</span><span class="sxs-lookup"><span data-stu-id="89cc9-237">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="89cc9-238">Quand l’utilisateur clique sur le bouton « new window » (nouvelle fenêtre), nous lançons une copie de notre fenêtre dans un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="89cc9-238">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="89cc9-239">De cette façon, les opérations longues ou bloquantes dans une des fenêtres ne verrouillent pas toutes les autres fenêtres.</span><span class="sxs-lookup"><span data-stu-id="89cc9-239">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="89cc9-240">En réalité, le modèle de navigateur web a son propre modèle de thread complexe.</span><span class="sxs-lookup"><span data-stu-id="89cc9-240">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="89cc9-241">Nous l’avons choisi, car la plupart des lecteurs le connaissent probablement bien.</span><span class="sxs-lookup"><span data-stu-id="89cc9-241">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="89cc9-242">L’exemple suivant montre le code.</span><span class="sxs-lookup"><span data-stu-id="89cc9-242">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="89cc9-243">Les segments suivants relatifs à la mise en œuvre des threads dans ce code sont les plus intéressants pour nous dans ce contexte :</span><span class="sxs-lookup"><span data-stu-id="89cc9-243">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="89cc9-244">Cette méthode est appelée quand l’utilisateur clique sur le bouton « new window ».</span><span class="sxs-lookup"><span data-stu-id="89cc9-244">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="89cc9-245">Elle crée un nouveau thread et le démarre de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="89cc9-245">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="89cc9-246">Cette méthode est le point de départ pour le nouveau thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-246">This method is the starting point for the new thread.</span></span> <span data-ttu-id="89cc9-247">Nous créons une nouvelle fenêtre sous le contrôle de ce thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-247">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="89cc9-248">crée automatiquement un nouveau <xref:System.Windows.Threading.Dispatcher> pour gérer le nouveau thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-248">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="89cc9-249">Tout ce que nous devons faire pour rendre la fenêtre fonctionnelle est de démarrer <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-249">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="89cc9-250">Détails techniques et difficultés</span><span class="sxs-lookup"><span data-stu-id="89cc9-250">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="89cc9-251">Écriture de composants avec des threads</span><span class="sxs-lookup"><span data-stu-id="89cc9-251">Writing Components Using Threading</span></span>
 <span data-ttu-id="89cc9-252">Le Guide du développeur Microsoft .NET Framework décrit un modèle de la façon dont un composant peut exposer le comportement asynchrone à ses clients (consultez [vue d’ensemble du modèle asynchrone basé sur les événements](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="89cc9-252">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="89cc9-253">Par exemple, supposons que nous souhaitions empaqueter la `FetchWeatherFromServer` méthode dans un composant réutilisable, qui n’est pas graphique.</span><span class="sxs-lookup"><span data-stu-id="89cc9-253">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="89cc9-254">À la suite du modèle standard Microsoft .NET Framework, cela ressemble à ce qui suit.</span><span class="sxs-lookup"><span data-stu-id="89cc9-254">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="89cc9-255">`GetWeatherAsync` utiliserait une des techniques décrites précédemment, comme la création d’un thread d’arrière-plan, pour faire le travail de façon asynchrone, sans bloquer le thread appelant.</span><span class="sxs-lookup"><span data-stu-id="89cc9-255">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="89cc9-256">L’une des parties les plus importantes de ce modèle est l’appel de la méthode *MethodName* `Completed` sur le thread qui a appelé la méthode *MethodName* `Async` pour commencer.</span><span class="sxs-lookup"><span data-stu-id="89cc9-256">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="89cc9-257">Vous pouvez le faire en utilisant [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] assez facilement, en stockant, <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> mais le composant non graphique ne peut être utilisé que dans les [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, pas dans les programmes Windows Forms ou ASP.net.</span><span class="sxs-lookup"><span data-stu-id="89cc9-257">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in Windows Forms or ASP.NET programs.</span></span>

 <span data-ttu-id="89cc9-258">La <xref:System.Windows.Threading.DispatcherSynchronizationContext> classe répond à ce besoin : considérez-la comme une version simplifiée de <xref:System.Windows.Threading.Dispatcher> qui fonctionne également avec d’autres [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks.</span><span class="sxs-lookup"><span data-stu-id="89cc9-258">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="89cc9-259">Pompage imbriqué</span><span class="sxs-lookup"><span data-stu-id="89cc9-259">Nested Pumping</span></span>
 <span data-ttu-id="89cc9-260">Parfois, il n’est pas possible de verrouiller complètement le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-260">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="89cc9-261">Examinons la <xref:System.Windows.MessageBox.Show%2A> méthode de la <xref:System.Windows.MessageBox> classe.</span><span class="sxs-lookup"><span data-stu-id="89cc9-261">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="89cc9-262"><xref:System.Windows.MessageBox.Show%2A>ne retourne pas tant que l’utilisateur n’a pas cliqué sur le bouton OK.</span><span class="sxs-lookup"><span data-stu-id="89cc9-262"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="89cc9-263">Il peut cependant créer une fenêtre qui doit avoir une boucle de messages pour être interactive.</span><span class="sxs-lookup"><span data-stu-id="89cc9-263">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="89cc9-264">Pendant que nous attendons que l’utilisateur clique sur OK, la fenêtre d’application d’origine ne répond pas aux entrées utilisateur.</span><span class="sxs-lookup"><span data-stu-id="89cc9-264">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="89cc9-265">Elle continue cependant de traiter les messages concernant le dessin.</span><span class="sxs-lookup"><span data-stu-id="89cc9-265">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="89cc9-266">La fenêtre d’origine se redessine elle-même quand elle est couverte et découverte.</span><span class="sxs-lookup"><span data-stu-id="89cc9-266">The original window redraws itself when covered and revealed.</span></span>

 ![Capture d’écran montrant un MessageBox avec un bouton OK](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="89cc9-268">Un thread doit être chargé de la fenêtre de la boîte de message.</span><span class="sxs-lookup"><span data-stu-id="89cc9-268">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="89cc9-269">pourrait créer un thread seulement pour la fenêtre de la boîte de message, mais ce thread ne pourrait pas dessiner les éléments désactivés dans la fenêtre d’origine (rappelez-vous de ce qui a été indiqué plus haut sur l’exclusion mutuelle).</span><span class="sxs-lookup"><span data-stu-id="89cc9-269">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="89cc9-270">Au lieu [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] de cela, utilise un système de traitement des messages imbriqué.</span><span class="sxs-lookup"><span data-stu-id="89cc9-270">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="89cc9-271">La <xref:System.Windows.Threading.Dispatcher> classe comprend une méthode spéciale appelée <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> , qui stocke le point d’exécution actuel d’une application, puis commence une nouvelle boucle de message.</span><span class="sxs-lookup"><span data-stu-id="89cc9-271">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="89cc9-272">Lorsque la boucle de messages imbriquée se termine, l’exécution reprend après l’appel d’origine <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-272">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="89cc9-273">Dans ce cas, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> conserve le contexte du programme lors de l’appel à <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType> et démarre une nouvelle boucle de messages pour repeindre la fenêtre d’arrière-plan et gérer l’entrée dans la fenêtre de la boîte de message.</span><span class="sxs-lookup"><span data-stu-id="89cc9-273">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="89cc9-274">Quand l’utilisateur clique sur OK et efface la fenêtre indépendante, la boucle imbriquée s’arrête et le contrôle reprend après l’appel à <xref:System.Windows.MessageBox.Show%2A> .</span><span class="sxs-lookup"><span data-stu-id="89cc9-274">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="89cc9-275">Événements routés périmés</span><span class="sxs-lookup"><span data-stu-id="89cc9-275">Stale Routed Events</span></span>
 <span data-ttu-id="89cc9-276">Le système d’événements routés de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifie les arborescences entières lorsque des événements sont déclenchés.</span><span class="sxs-lookup"><span data-stu-id="89cc9-276">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="89cc9-277">Lorsque le bouton gauche de la souris est enfoncé sur l’ellipse, `handler2` est exécuté.</span><span class="sxs-lookup"><span data-stu-id="89cc9-277">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="89cc9-278">Une fois `handler2` terminé, l’événement est passé à l' <xref:System.Windows.Controls.Canvas> objet, qui utilise `handler1` pour le traiter.</span><span class="sxs-lookup"><span data-stu-id="89cc9-278">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="89cc9-279">Cela se produit uniquement si `handler2` ne marque pas explicitement l’objet d’événement comme géré.</span><span class="sxs-lookup"><span data-stu-id="89cc9-279">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="89cc9-280">Cela peut `handler2` prendre beaucoup de temps pour traiter cet événement.</span><span class="sxs-lookup"><span data-stu-id="89cc9-280">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="89cc9-281">`handler2`peut utiliser <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> pour commencer une boucle de messages imbriquée qui ne retourne pas pendant des heures.</span><span class="sxs-lookup"><span data-stu-id="89cc9-281">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="89cc9-282">Si `handler2` ne marque pas l’événement comme géré lorsque cette boucle de messages est terminée, l’événement est passé en haut de l’arborescence même s’il est très ancien.</span><span class="sxs-lookup"><span data-stu-id="89cc9-282">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="89cc9-283">Réentrance et verrouillage</span><span class="sxs-lookup"><span data-stu-id="89cc9-283">Reentrancy and Locking</span></span>
 <span data-ttu-id="89cc9-284">Le mécanisme de verrouillage du common language runtime (CLR) ne se comporte pas exactement comme vous pourriez l’imaginer. On peut s’attendre à ce qu’un thread arrête complètement l’opération lors de la demande d’un verrou.</span><span class="sxs-lookup"><span data-stu-id="89cc9-284">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="89cc9-285">En fait, le thread continue à recevoir et à traiter les messages de priorité élevée.</span><span class="sxs-lookup"><span data-stu-id="89cc9-285">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="89cc9-286">Ceci permet d’éviter les blocages et de rendre les interfaces un minimum réactives, mais introduit la possibilité de bogues subtils.</span><span class="sxs-lookup"><span data-stu-id="89cc9-286">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="89cc9-287">La grande majorité du temps, vous n’avez pas besoin de connaître quoi que ce soit à ce sujet, mais dans de rares circonstances (impliquant généralement des messages de fenêtre Win32 ou des composants COM STA), cela peut être utile.</span><span class="sxs-lookup"><span data-stu-id="89cc9-287">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving Win32 window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="89cc9-288">La plupart des interfaces ne sont pas générées avec la sécurité des threads à l’esprit, car les développeurs travaillent en partant du principe qu’un [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] n’est jamais accessible par plus d’un thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-288">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="89cc9-289">Dans ce cas, ce thread unique peut apporter des modifications environnementales à des moments inattendus, ce qui entraîne des effets négatifs que le <xref:System.Windows.Threading.DispatcherObject> mécanisme d’exclusion mutuelle est supposé résoudre.</span><span class="sxs-lookup"><span data-stu-id="89cc9-289">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="89cc9-290">Considérez le pseudocode suivant :</span><span class="sxs-lookup"><span data-stu-id="89cc9-290">Consider the following pseudocode:</span></span>

 <span data-ttu-id="89cc9-291">![Diagramme qui illustre la réentrance des threads.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="89cc9-291">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="89cc9-292">La plupart du temps, c’est la bonne chose, mais dans certains cas, une [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] telle réentrance inattendue peut vraiment causer des problèmes.</span><span class="sxs-lookup"><span data-stu-id="89cc9-292">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="89cc9-293">Ainsi, à certains moments clés, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] appelle <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> , qui modifie l’instruction de verrouillage pour que ce thread utilise le [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] verrou de réentrance sans réentrance, au lieu du verrou CLR habituel.</span><span class="sxs-lookup"><span data-stu-id="89cc9-293">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="89cc9-294">Pourquoi l’équipe CLR a-t-elle choisi ce comportement ?</span><span class="sxs-lookup"><span data-stu-id="89cc9-294">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="89cc9-295">Elle devait tenir compte des objets STA COM et du thread de finalisation.</span><span class="sxs-lookup"><span data-stu-id="89cc9-295">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="89cc9-296">Lorsqu’un objet est récupéré par le garbage collector, sa `Finalize` méthode est exécutée sur le thread finaliseur dédié, et non sur le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-296">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="89cc9-297">Et c’est là que se trouve le problème, car un objet COM STA qui a été créé sur le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread ne peut être supprimé que sur le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="89cc9-297">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="89cc9-298">Le CLR est l’équivalent d’un <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (dans ce cas, en utilisant Win32 `SendMessage` ).</span><span class="sxs-lookup"><span data-stu-id="89cc9-298">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="89cc9-299">Toutefois, si le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread est occupé, le thread finaliseur est bloqué et l’objet com STA ne peut pas être supprimé, ce qui entraîne une fuite de mémoire sérieuse.</span><span class="sxs-lookup"><span data-stu-id="89cc9-299">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="89cc9-300">L’équipe CLR a donc fait l’appel difficile pour faire fonctionner les verrous comme c’est le cas.</span><span class="sxs-lookup"><span data-stu-id="89cc9-300">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="89cc9-301">La tâche pour [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] est d’éviter la réentrance inattendue sans réintroduire la fuite de mémoire, c’est pourquoi nous ne bloquons pas la réentrance partout.</span><span class="sxs-lookup"><span data-stu-id="89cc9-301">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="89cc9-302">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="89cc9-302">See also</span></span>

- [<span data-ttu-id="89cc9-303">Application à thread unique avec un exemple de calcul de longue durée</span><span class="sxs-lookup"><span data-stu-id="89cc9-303">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)
