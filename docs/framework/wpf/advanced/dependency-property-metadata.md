---
title: Métadonnées de propriété de dépendance
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: a4b2edce76bc5ab97e644ec8dbdf045931e87786
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64663429"
---
# <a name="dependency-property-metadata"></a>Métadonnées de propriété de dépendance
Le système de propriétés [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] inclut un système de création de rapport de métadonnées allant au-delà de ce qui peut être signalé à propos d’une propriété par réflexion ou par les caractéristiques générales du [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]. Les métadonnées d’une propriété de dépendance peuvent également être affectées de manière unique par la classe qui définit une propriété de dépendance, peuvent être changées quand la propriété de dépendance est ajoutée à une autre classe, et peuvent être substituées de manière spécifique par toutes les classes dérivées qui héritent de la propriété de dépendance de la classe de base de définition.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Prérequis  
 Cette rubrique part du principe que vous savez ce que sont les propriétés de dépendance du point de vue d’un consommateur de propriétés de dépendance existantes sur les classes [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] et que vous avez lu [Vue d’ensemble des propriétés de dépendance](dependency-properties-overview.md). Pour pouvoir suivre les exemples de cette rubrique, vous devez également comprendre [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] et savoir comment écrire des applications [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="dp_metadata_contents"></a>   
## <a name="how-dependency-property-metadata-is-used"></a>Utilisation des métadonnées de propriété de dépendance  
 Les métadonnées de propriété de dépendance existent en tant qu’objet qui peut être interrogé pour examiner les caractéristiques d’une propriété de dépendance. Ces métadonnées sont également souvent sollicitées par le système de propriétés quand il traite des propriétés de dépendance. L’objet de métadonnées pour une propriété de dépendance peut contenir les types d’informations suivants :  
  
- Valeur par défaut de la propriété de dépendance, si aucune autre valeur ne peut être déterminée pour la propriété de dépendance d’après la valeur locale, le style, l’héritage, etc. Pour obtenir une discussion détaillée de la façon dont les valeurs par défaut participent à la priorité utilisée par le système de propriétés lors de l’affectation de valeurs aux propriétés de dépendance, consultez [Priorité de la valeur de propriété de dépendance](dependency-property-value-precedence.md).  
  
- Références aux implémentations de rappels qui affectent les comportements de forçage ou de notification de modification en fonction du type de propriétaire. Notez que ces rappels sont souvent définis avec un niveau d’accès non public. Ainsi, il n’est généralement pas possible d’obtenir les références réelles à partir des métadonnées, sauf si les références sont dans votre étendue d’accès autorisée. Pour plus d’informations sur les rappels de propriété de dépendance, consultez [Validation et rappels de propriétés de dépendance](dependency-property-callbacks-and-validation.md).  
  
- Si la propriété de dépendance en question est considérée comme une propriété de niveau framework WPF, les métadonnées peuvent contenir des caractéristiques de propriété de dépendance de niveau framework WPF qui fournissent des informations et indiquent l’état de services tels que le moteur de disposition de niveau framework WPF et la logique d’héritage de propriété. Pour plus d’informations sur cet aspect des métadonnées de propriété de dépendance, consultez [Métadonnées de propriété de framework](framework-property-metadata.md).  
  
<a name="APIs"></a>   
## <a name="metadata-apis"></a>API de métadonnées  
 Le type qui signale la plupart des informations de métadonnées utilisées par le système de propriétés est la <xref:System.Windows.PropertyMetadata> classe. Des instances de métadonnées sont éventuellement spécifiées quand les propriétés de dépendance sont inscrites auprès du système de propriétés, et peuvent également être spécifiées pour d’autres types qui s’ajoutent comme propriétaires ou remplacent les métadonnées dont ils héritent à partir de la définition de propriété de dépendance de la classe de base. (Pour les cas où une inscription de propriété ne spécifie pas de métadonnées, une valeur par défaut <xref:System.Windows.PropertyMetadata> est créé avec les valeurs par défaut pour cette classe.) Les métadonnées inscrites sont retournées en tant que <xref:System.Windows.PropertyMetadata> lorsque vous appelez les différentes <xref:System.Windows.DependencyProperty.GetMetadata%2A> surcharges qui obtiennent les métadonnées d’une propriété de dépendance sur un <xref:System.Windows.DependencyObject> instance.  
  
 Le <xref:System.Windows.PropertyMetadata> classe est ensuite dérivée pour fournir des métadonnées plus spécifiques pour les divisions architecturales, telles que les classes de niveau infrastructure WPF. <xref:System.Windows.UIPropertyMetadata> Ajoute des rapports d’animation, et <xref:System.Windows.FrameworkPropertyMetadata> fournit les propriétés de niveau infrastructure WPF mentionnées dans la section précédente. Lorsque les propriétés de dépendance sont enregistrées, elles peuvent être inscrites avec ces <xref:System.Windows.PropertyMetadata> classes dérivées. Lorsque les métadonnées sont examinées, la base de <xref:System.Windows.PropertyMetadata> type peut être casté aux classes dérivées afin que vous puissiez examiner les propriétés plus spécifiques.  
  
> [!NOTE]
>  Les caractéristiques de propriété qui peuvent être spécifiées dans <xref:System.Windows.FrameworkPropertyMetadata> sont parfois appelées dans cette documentation « indicateurs ». Lorsque vous créez des instances de métadonnées pour une utilisation dans la dépendance inscriptions de propriétés ou des substitutions de métadonnées, vous spécifiez ces valeurs à l’aide de l’énumération d’indicateurs <xref:System.Windows.FrameworkPropertyMetadataOptions> et vous fournir des valeurs éventuellement concaténées de l’énumération à la <xref:System.Windows.FrameworkPropertyMetadata> constructeur. Toutefois, une fois construites, ces caractéristiques d’option sont exposées dans un <xref:System.Windows.FrameworkPropertyMetadata> comme une série de propriétés booléennes plutôt que la valeur d’énumération construction. Les propriétés booléennes vous permettent de vérifier chaque condition, plutôt que d’avoir à appliquer un masque à une valeur d’énumération d’indicateurs pour obtenir les informations qui vous intéressent. Le constructeur utilise concaténés <xref:System.Windows.FrameworkPropertyMetadataOptions> pour limiter la longueur de la signature de constructeur raisonnable, alors que les métadonnées construites exposent les propriétés discrètes pour rendre l’interrogation des métadonnées plus intuitive.  
  
<a name="override_or_subclass"></a>   
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Quand substituer des métadonnées, quand dériver une classe ?  
 Le système de propriétés [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] offre des fonctionnalités établies pour changer certaines caractéristiques des propriétés de dépendance sans nécessiter leur réimplémentation totale. Pour cela, vous devez construire une instance différente des métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur un type particulier. Notez que la plupart des propriétés de dépendance existantes ne sont pas des propriétés virtuelles. Ainsi, à proprement parler, vous ne pouvez les « réimplémenter » sur des classes héritées qu’en occultant le membre existant.  
  
 Si le scénario que vous tentez d’activer pour une propriété de dépendance sur un type ne peut pas être obtenu en changeant les caractéristiques des propriétés de dépendance existantes, il peut être nécessaire de créer une classe dérivée, puis de déclarer une propriété de dépendance personnalisée sur votre classe dérivée. Une propriété de dépendance personnalisée se comporte exactement comme les propriétés de dépendance définies par les [!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Pour plus d’informations sur les propriétés de dépendance personnalisées, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md).  
  
 L’une des caractéristiques principales d’une propriété de dépendance que vous ne pouvez pas substituer est son type de valeur. Si vous héritez d’une propriété de dépendance qui a le comportement approximatif souhaité, mais que vous avez besoin pour elle d’un type différent, vous devrez implémenter une propriété de dépendance personnalisée et peut-être lier les propriétés par l’intermédiaire de la conversion de type ou autre implémentation sur votre classe personnalisée. En outre, vous ne pouvez pas remplacer une existante <xref:System.Windows.ValidateValueCallback>, car ce rappel existe dans le champ d’inscription lui-même et non dans ses métadonnées.  
  
<a name="scenarios"></a>   
## <a name="scenarios-for-changing-existing-metadata"></a>Scénarios de changement des métadonnées existantes  
 Si vous travaillez avec des métadonnées d’une propriété de dépendance existante, un scénario courant de changement des métadonnées de propriété de dépendance consiste à modifier la valeur par défaut. Le changement ou l’ajout de rappels du système de propriétés est un scénario plus avancé. Vous souhaiterez peut-être le faire si votre implémentation d’une classe dérivée a des corrélations différentes entre des propriétés de dépendance. L’une des conditions pour disposer d’un modèle de programmation qui prend en charge à la fois le code et l’utilisation déclarative est que les propriétés doivent pouvoir être définies dans n’importe quel ordre. Par conséquent, toutes les propriétés dépendantes doivent être définies juste-à-temps sans contexte et ne peuvent pas reposer sur la connaissance d’un ordre de définition tel que celui que l’on pourrait trouver dans un constructeur. Pour plus d’informations sur cet aspect du système de propriétés, consultez [Validation et rappels de propriétés de dépendance](dependency-property-callbacks-and-validation.md). Notez que les rappels de validation ne font pas partie des métadonnées ; ils font partie de l’identificateur de propriété de dépendance. Ainsi, vous ne pouvez pas changer les rappels de validation en substituant les métadonnées.  
  
 Dans certains cas, vous souhaiterez peut-être modifier les options de métadonnées de propriété de niveau framework WPF sur des propriétés de dépendance existantes. Ces options communiquent certaines conditions connues sur les propriétés de niveau framework WPF à d’autres processus de niveau framework WPF tels que le système de disposition.  Définition des options s’effectue en général uniquement lors de l’inscription d’une nouvelle propriété de dépendance, mais il est également possible de modifier les métadonnées de propriété de niveau framework WPF dans le cadre d’un <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> ou <xref:System.Windows.DependencyProperty.AddOwner%2A> appeler. Pour connaître les valeurs spécifiques à utiliser et pour plus d’informations, consultez [Métadonnées de propriété de framework](framework-property-metadata.md). Pour plus d’informations sur la façon dont ces options doivent être définies pour une propriété de dépendance récemment inscrite, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>   
### <a name="overriding-metadata"></a>Substitution de métadonnées  
 La substitution de métadonnées a pour objectif principal de vous permettre de changer les différents comportements dérivés des métadonnées qui sont appliqués à la propriété de dépendance telle qu’elle existe sur votre type. Les raisons sont expliquées plus en détail dans la section [Métadonnées](#dp_metadata_contents). Pour plus d’informations et pour obtenir des exemples de code, consultez [Substituer les métadonnées d’une propriété de dépendance](how-to-override-metadata-for-a-dependency-property.md).  
  
 Métadonnées de propriété peuvent être fournies pour une propriété de dépendance pendant l’appel d’inscription (<xref:System.Windows.DependencyProperty.Register%2A>). Toutefois, dans de nombreux cas, vous souhaiterez peut-être fournir des métadonnées propres au type pour votre classe quand elle hérite de cette propriété de dépendance. Vous pouvez le faire en appelant le <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> (méthode).  Par exemple, dans le [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], le <xref:System.Windows.FrameworkElement> classe est le type qui enregistre tout d’abord le <xref:System.Windows.UIElement.Focusable%2A> propriété de dépendance. Mais le <xref:System.Windows.Controls.Control> classe substitue les métadonnées pour la propriété de dépendance fournir sa propre valeur par défaut initiale, sa modification de `false` à `true`et réutilise l’original <xref:System.Windows.UIElement.Focusable%2A> implémentation.  
  
 Quand vous substituez des métadonnées, les différentes caractéristiques des métadonnées sont fusionnées ou remplacées.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> est fusionné. Si vous ajoutez un nouveau <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, ce rappel est stocké dans les métadonnées. Si vous ne spécifiez pas un <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> dans la substitution, la valeur de <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> est promue en tant que référence à partir de l’ancêtre le plus proche qui l’a spécifiée dans les métadonnées.  
  
- Le comportement réel propriétés système pour <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> est que les implémentations pour tous les propriétaires de métadonnées dans la hiérarchie sont conservées et ajoutées à une table, avec l’ordre d’exécution par le système de propriétés étant que les rappels de la classe la plus dérivée sont effectués en premier.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A> est remplacé. Si vous ne spécifiez pas un <xref:System.Windows.PropertyMetadata.DefaultValue%2A> dans la substitution, la valeur de <xref:System.Windows.PropertyMetadata.DefaultValue%2A> provient de l’ancêtre le plus proche qui l’a spécifiée dans les métadonnées.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> les implémentations sont remplacées. Si vous ajoutez un nouveau <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, ce rappel est stocké dans les métadonnées. Si vous ne spécifiez pas un <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> dans la substitution, la valeur de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> est promue en tant que référence à partir de l’ancêtre le plus proche qui l’a spécifiée dans les métadonnées.  
  
- Le comportement de système de propriétés est que seules les <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> dans les métadonnées immédiates est appelé. Aucune référence à d’autres <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implémentations dans la hiérarchie sont conservées.  
  
 Ce comportement est implémenté par <xref:System.Windows.PropertyMetadata.Merge%2A>et peut être substitué sur des classes de métadonnées dérivées.  
  
#### <a name="overriding-attached-property-metadata"></a>Substitution de métadonnées de propriété jointe  
 Dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], les propriétés jointes sont implémentées en tant que propriétés de dépendance. Cela signifie qu’elles ont également des métadonnées de propriété, que les différentes classes peuvent substituer. Les considérations d’étendue pour une propriété jointe dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sont généralement que les <xref:System.Windows.DependencyObject> peut avoir une propriété jointe définie sur ces derniers. Par conséquent, tout <xref:System.Windows.DependencyObject> classe dérivée peut substituer les métadonnées de toute propriété attachée, puisqu’elle peut être définie sur une instance de la classe. Vous pouvez substituer les valeurs par défaut, les rappels ou les propriétés de rapport de caractéristiques de niveau framework WPF. Si la propriété jointe est définie sur une instance de votre classe, ces caractéristiques de métadonnées de propriété de substitution s’appliquent. Par exemple, vous pouvez substituer la valeur par défaut de telle sorte que votre valeur de remplacement soit signalée comme valeur de la propriété jointe sur des instances de votre classe chaque fois que la propriété n’est pas définie autrement.  
  
> [!NOTE]
>  Le <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propriété n’est pas pertinente pour les propriétés jointes.  
  
<a name="dp_add_owner"></a>   
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Ajout d’une classe en tant que propriétaire d’une propriété de dépendance existante  
 Une classe peut s’ajouter comme propriétaire d’une propriété de dépendance qui a déjà été inscrite, à l’aide de la <xref:System.Windows.DependencyProperty.AddOwner%2A> (méthode). Cela permet à la classe d’utiliser une propriété de dépendance initialement inscrite pour un autre type. La classe d’ajout n’est généralement pas une classe dérivée du type ayant inscrit initialement cette propriété de dépendance comme propriétaire. En pratique, cela permet à votre classe et à ses classes dérivées d’« hériter » d’une implémentation de propriété de dépendance sans que la classe propriétaire d’origine et la classe d’ajout ne soient dans la même vraie hiérarchie de classes. En outre, la classe d’ajout (et aussi toutes les classes dérivées) peuvent ensuite fournir des métadonnées propres au type pour la propriété de dépendance d’origine.  
  
 En plus de s’ajouter comme propriétaire par l’intermédiaire des méthodes utilitaires du système de propriétés, la classe d’ajout doit déclarer des membres publics supplémentaires sur elle-même pour que la propriété de dépendance participe totalement au système de propriétés avec exposition à la fois au code et au balisage. Une classe qui ajoute une propriété de dépendance existante a les mêmes responsabilités, en ce qui concerne l’exposition du modèle objet pour cette propriété de dépendance, qu’une classe qui définit une nouvelle propriété de dépendance personnalisée. Le premier membre de ce genre à exposer est un champ identificateur de propriété de dépendance. Ce champ doit être un `public static readonly` champ de type <xref:System.Windows.DependencyProperty>, qui est assignée à la valeur de retour de la <xref:System.Windows.DependencyProperty.AddOwner%2A> appeler. Le deuxième membre à définir est la propriété « wrapper » [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]. Le wrapper rend beaucoup plus pratique de manipuler votre propriété de dépendance dans le code (vous évitez les appels à <xref:System.Windows.DependencyObject.SetValue%2A> chaque fois, que vous pouvez effectuer cet appel une seule fois dans le wrapper proprement dit). Le wrapper est implémenté exactement comment il le serait si vous inscriviez une propriété de dépendance personnalisée. Pour plus d’informations sur l’implémentation d’une propriété de dépendance, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md) et [Ajouter un type propriétaire d’une propriété de dépendance](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner et les propriétés jointes  
 Vous pouvez appeler <xref:System.Windows.DependencyProperty.AddOwner%2A> pour une propriété de dépendance qui est définie comme propriété jointe par la classe propriétaire. En général, ceci a pour but d’exposer la propriété précédemment jointe en tant que propriété de dépendance non jointe. Vous exposerez ensuite la <xref:System.Windows.DependencyProperty.AddOwner%2A> retourner de valeur comme un `public static readonly` champ pour une utilisation en tant que l’identificateur de propriété de dépendance et définir des propriétés « wrapper » appropriées pour que la propriété apparaisse dans la table des membres et prend en charge une propriété non jointes utilisation dans votre classe.  
  
## <a name="see-also"></a>Voir aussi

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Vue d’ensemble des propriétés de dépendance](dependency-properties-overview.md)
- [Métadonnées de propriété de framework](framework-property-metadata.md)
