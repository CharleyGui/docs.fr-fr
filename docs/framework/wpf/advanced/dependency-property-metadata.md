---
title: Métadonnées de propriété de dépendance
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 154a2543c62de545e8b2df711d6ad51989d0689d
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/22/2019
ms.locfileid: "69964848"
---
# <a name="dependency-property-metadata"></a>Métadonnées de propriété de dépendance
Le [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] système de propriétés comprend un système de création de rapports de métadonnées qui va au-delà de ce qui peut être signalé sur une propriété par réflexion ou caractéristiques générales du Common Language Runtime (CLR). Les métadonnées d’une propriété de dépendance peuvent également être affectées de manière unique par la classe qui définit une propriété de dépendance, peuvent être changées quand la propriété de dépendance est ajoutée à une autre classe, et peuvent être substituées de manière spécifique par toutes les classes dérivées qui héritent de la propriété de dépendance de la classe de base de définition.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Prérequis  
 Cette rubrique part du principe que vous savez ce que sont les propriétés de dépendance du point de vue d’un consommateur de propriétés de dépendance existantes sur les classes [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] et que vous avez lu [Vue d’ensemble des propriétés de dépendance](dependency-properties-overview.md). Pour pouvoir suivre les exemples de cette rubrique, vous devez également comprendre [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] et savoir comment écrire des applications [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="dp_metadata_contents"></a>   
## <a name="how-dependency-property-metadata-is-used"></a>Utilisation des métadonnées de propriété de dépendance  
 Les métadonnées de propriété de dépendance existent en tant qu’objet qui peut être interrogé pour examiner les caractéristiques d’une propriété de dépendance. Ces métadonnées sont également souvent sollicitées par le système de propriétés quand il traite des propriétés de dépendance. L’objet de métadonnées pour une propriété de dépendance peut contenir les types d’informations suivants :  
  
- Valeur par défaut de la propriété de dépendance, si aucune autre valeur ne peut être déterminée pour la propriété de dépendance d’après la valeur locale, le style, l’héritage, etc. Pour obtenir une discussion détaillée de la façon dont les valeurs par défaut participent à la priorité utilisée par le système de propriétés lors de l’affectation de valeurs aux propriétés de dépendance, consultez [Priorité de la valeur de propriété de dépendance](dependency-property-value-precedence.md).  
  
- Références aux implémentations de rappels qui affectent les comportements de forçage ou de notification de modification en fonction du type de propriétaire. Notez que ces rappels sont souvent définis avec un niveau d’accès non public. Ainsi, il n’est généralement pas possible d’obtenir les références réelles à partir des métadonnées, sauf si les références sont dans votre étendue d’accès autorisée. Pour plus d’informations sur les rappels de propriété de dépendance, consultez [Validation et rappels de propriétés de dépendance](dependency-property-callbacks-and-validation.md).  
  
- Si la propriété de dépendance en question est considérée comme une propriété de niveau framework WPF, les métadonnées peuvent contenir des caractéristiques de propriété de dépendance de niveau framework WPF qui fournissent des informations et indiquent l’état de services tels que le moteur de disposition de niveau framework WPF et la logique d’héritage de propriété. Pour plus d’informations sur cet aspect des métadonnées de propriété de dépendance, consultez [Métadonnées de propriété de framework](framework-property-metadata.md).  
  
<a name="APIs"></a>   
## <a name="metadata-apis"></a>API de métadonnées  
 Le type qui signale la plupart des informations de métadonnées utilisées par le système <xref:System.Windows.PropertyMetadata> de propriétés est la classe. Des instances de métadonnées sont éventuellement spécifiées quand les propriétés de dépendance sont inscrites auprès du système de propriétés, et peuvent également être spécifiées pour d’autres types qui s’ajoutent comme propriétaires ou remplacent les métadonnées dont ils héritent à partir de la définition de propriété de dépendance de la classe de base. (Dans les cas où l’inscription d’une propriété ne spécifie pas <xref:System.Windows.PropertyMetadata> de métadonnées, une valeur par défaut est créée avec les valeurs par défaut de cette classe.) Les métadonnées inscrites sont <xref:System.Windows.PropertyMetadata> retournées comme lorsque <xref:System.Windows.DependencyProperty.GetMetadata%2A> vous appelez les différentes surcharges qui obtiennent des métadonnées <xref:System.Windows.DependencyObject> d’une propriété de dépendance sur une instance.  
  
 La <xref:System.Windows.PropertyMetadata> classe est ensuite dérivée de pour fournir des métadonnées plus spécifiques pour les divisions architecturales, telles que les classes de niveau Framework WPF. <xref:System.Windows.UIPropertyMetadata>Ajoute des rapports d’animation <xref:System.Windows.FrameworkPropertyMetadata> et fournit les propriétés au niveau de l’infrastructure WPF mentionnées dans la section précédente. Lorsque les propriétés de dépendance sont inscrites, elles peuvent être <xref:System.Windows.PropertyMetadata> inscrites auprès de ces classes dérivées. Lorsque les métadonnées sont examinées, <xref:System.Windows.PropertyMetadata> le type de base peut potentiellement être casté en classes dérivées afin que vous puissiez examiner les propriétés plus spécifiques.  
  
> [!NOTE]
> Les caractéristiques de propriété qui peuvent être spécifiées dans <xref:System.Windows.FrameworkPropertyMetadata> sont parfois appelées «indicateurs» dans cette documentation. Quand vous créez des instances de métadonnées à utiliser dans des inscriptions de propriété de dépendance ou des substitutions de métadonnées, vous spécifiez ces valeurs à l’aide de l’énumération <xref:System.Windows.FrameworkPropertyMetadataOptions> des indicateurs, puis vous fournissez des valeurs éventuellement concaténées de l’énumération à la <xref:System.Windows.FrameworkPropertyMetadata> constructeur. Toutefois, une fois construites, ces caractéristiques d’option sont <xref:System.Windows.FrameworkPropertyMetadata> exposées dans un sous la forme d’une série de propriétés booléennes plutôt que de la valeur d’énumération de construction. Les propriétés booléennes vous permettent de vérifier chaque condition, plutôt que d’avoir à appliquer un masque à une valeur d’énumération d’indicateurs pour obtenir les informations qui vous intéressent. Le constructeur utilise le concaténé <xref:System.Windows.FrameworkPropertyMetadataOptions> pour que la longueur de la signature de constructeur reste raisonnable, alors que les métadonnées construites réelles exposent les propriétés discrètes pour rendre l’interrogation des métadonnées plus intuitive.  
  
<a name="override_or_subclass"></a>   
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Quand substituer des métadonnées, quand dériver une classe ?  
 Le système de propriétés [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] offre des fonctionnalités établies pour changer certaines caractéristiques des propriétés de dépendance sans nécessiter leur réimplémentation totale. Pour cela, vous devez construire une instance différente des métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur un type particulier. Notez que la plupart des propriétés de dépendance existantes ne sont pas des propriétés virtuelles. Ainsi, à proprement parler, vous ne pouvez les « réimplémenter » sur des classes héritées qu’en occultant le membre existant.  
  
 Si le scénario que vous tentez d’activer pour une propriété de dépendance sur un type ne peut pas être obtenu en changeant les caractéristiques des propriétés de dépendance existantes, il peut être nécessaire de créer une classe dérivée, puis de déclarer une propriété de dépendance personnalisée sur votre classe dérivée. Une propriété de dépendance personnalisée se comporte de la même façon que les propriétés de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dépendance définies par les API. Pour plus d’informations sur les propriétés de dépendance personnalisées, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md).  
  
 L’une des caractéristiques principales d’une propriété de dépendance que vous ne pouvez pas substituer est son type de valeur. Si vous héritez d’une propriété de dépendance qui a le comportement approximatif souhaité, mais que vous avez besoin pour elle d’un type différent, vous devrez implémenter une propriété de dépendance personnalisée et peut-être lier les propriétés par l’intermédiaire de la conversion de type ou autre implémentation sur votre classe personnalisée. En outre, vous ne pouvez pas <xref:System.Windows.ValidateValueCallback>remplacer un existant, car ce rappel existe dans le champ d’inscription lui-même et non dans ses métadonnées.  
  
<a name="scenarios"></a>   
## <a name="scenarios-for-changing-existing-metadata"></a>Scénarios de changement des métadonnées existantes  
 Si vous travaillez avec des métadonnées d’une propriété de dépendance existante, un scénario courant de changement des métadonnées de propriété de dépendance consiste à modifier la valeur par défaut. Le changement ou l’ajout de rappels du système de propriétés est un scénario plus avancé. Vous souhaiterez peut-être le faire si votre implémentation d’une classe dérivée a des corrélations différentes entre des propriétés de dépendance. L’une des conditions pour disposer d’un modèle de programmation qui prend en charge à la fois le code et l’utilisation déclarative est que les propriétés doivent pouvoir être définies dans n’importe quel ordre. Par conséquent, toutes les propriétés dépendantes doivent être définies juste-à-temps sans contexte et ne peuvent pas reposer sur la connaissance d’un ordre de définition tel que celui que l’on pourrait trouver dans un constructeur. Pour plus d’informations sur cet aspect du système de propriétés, consultez [Validation et rappels de propriétés de dépendance](dependency-property-callbacks-and-validation.md). Notez que les rappels de validation ne font pas partie des métadonnées ; ils font partie de l’identificateur de propriété de dépendance. Ainsi, vous ne pouvez pas changer les rappels de validation en substituant les métadonnées.  
  
 Dans certains cas, vous souhaiterez peut-être modifier les options de métadonnées de propriété de niveau framework WPF sur des propriétés de dépendance existantes. Ces options communiquent certaines conditions connues sur les propriétés de niveau framework WPF à d’autres processus de niveau framework WPF tels que le système de disposition.  La définition des options est généralement effectuée uniquement lors de l’inscription d’une nouvelle propriété de dépendance, mais il est également possible de modifier les métadonnées de propriété de <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> niveau <xref:System.Windows.DependencyProperty.AddOwner%2A> Framework WPF dans le cadre d’un appel ou. Pour connaître les valeurs spécifiques à utiliser et pour plus d’informations, consultez [Métadonnées de propriété de framework](framework-property-metadata.md). Pour plus d’informations sur la façon dont ces options doivent être définies pour une propriété de dépendance récemment inscrite, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>   
### <a name="overriding-metadata"></a>Substitution de métadonnées  
 La substitution de métadonnées a pour objectif principal de vous permettre de changer les différents comportements dérivés des métadonnées qui sont appliqués à la propriété de dépendance telle qu’elle existe sur votre type. Les raisons sont expliquées plus en détail dans la section [Métadonnées](#dp_metadata_contents). Pour plus d’informations et pour obtenir des exemples de code, consultez [Substituer les métadonnées d’une propriété de dépendance](how-to-override-metadata-for-a-dependency-property.md).  
  
 Les métadonnées de propriété peuvent être fournies pour une propriété de dépendance lors<xref:System.Windows.DependencyProperty.Register%2A>de l’appel d’inscription (). Toutefois, dans de nombreux cas, vous souhaiterez peut-être fournir des métadonnées propres au type pour votre classe quand elle hérite de cette propriété de dépendance. Pour ce faire, appelez la <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> méthode.  Pour obtenir un exemple des [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API, la <xref:System.Windows.FrameworkElement> classe est le type qui enregistre en premier la <xref:System.Windows.UIElement.Focusable%2A> propriété de dépendance. Mais la <xref:System.Windows.Controls.Control> classe substitue les métadonnées de la propriété de dépendance pour fournir sa propre valeur par défaut initiale, `false` en `true`la remplaçant par, et réutilise dans <xref:System.Windows.UIElement.Focusable%2A> le cas contraire l’implémentation d’origine.  
  
 Quand vous substituez des métadonnées, les différentes caractéristiques des métadonnées sont fusionnées ou remplacées.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>est fusionné. Si vous ajoutez un nouveau <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, ce rappel est stocké dans les métadonnées. Si vous ne spécifiez <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> pas de dans la substitution, la valeur de <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> est promue en tant que référence à partir de l’ancêtre le plus proche qui l’a spécifiée dans les métadonnées.  
  
- Le comportement réel du système de <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> propriétés pour est que les implémentations pour tous les propriétaires de métadonnées dans la hiérarchie sont conservées et ajoutées à une table, avec un ordre d’exécution par le système de propriétés qui est appelé en premier les rappels de la classe la plus dérivée.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A>est remplacé. Si vous ne spécifiez pas <xref:System.Windows.PropertyMetadata.DefaultValue%2A> de dans la substitution, la valeur de <xref:System.Windows.PropertyMetadata.DefaultValue%2A> provient de l’ancêtre le plus proche qui l’a spécifiée dans les métadonnées.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>les implémentations sont remplacées. Si vous ajoutez un nouveau <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, ce rappel est stocké dans les métadonnées. Si vous ne spécifiez <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> pas de dans la substitution, la valeur de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> est promue en tant que référence à partir de l’ancêtre le plus proche qui l’a spécifiée dans les métadonnées.  
  
- Le comportement du système de propriétés est que <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> seul le dans les métadonnées immédiates est appelé. Aucune référence à d' <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> autres implémentations dans la hiérarchie n’est conservée.  
  
 Ce comportement est implémenté par <xref:System.Windows.PropertyMetadata.Merge%2A>et peut être substitué sur les classes de métadonnées dérivées.  
  
#### <a name="overriding-attached-property-metadata"></a>Substitution de métadonnées de propriété jointe  
 Dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], les propriétés jointes sont implémentées en tant que propriétés de dépendance. Cela signifie qu’elles ont également des métadonnées de propriété, que les différentes classes peuvent substituer. Les considérations relatives à la portée d’une [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] propriété jointe dans <xref:System.Windows.DependencyObject> sont généralement définies par une propriété jointe. Par conséquent, <xref:System.Windows.DependencyObject> toute classe dérivée peut substituer les métadonnées d’une propriété jointe, car elle peut être définie sur une instance de la classe. Vous pouvez substituer les valeurs par défaut, les rappels ou les propriétés de rapport de caractéristiques de niveau framework WPF. Si la propriété jointe est définie sur une instance de votre classe, ces caractéristiques de métadonnées de propriété de substitution s’appliquent. Par exemple, vous pouvez substituer la valeur par défaut de telle sorte que votre valeur de remplacement soit signalée comme valeur de la propriété jointe sur des instances de votre classe chaque fois que la propriété n’est pas définie autrement.  
  
> [!NOTE]
> La <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propriété n’est pas pertinente pour les propriétés jointes.  
  
<a name="dp_add_owner"></a>   
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Ajout d’une classe en tant que propriétaire d’une propriété de dépendance existante  
 Une classe peut s’ajouter elle-même en tant que propriétaire d’une propriété de dépendance qui a déjà été <xref:System.Windows.DependencyProperty.AddOwner%2A> inscrite, à l’aide de la méthode. Cela permet à la classe d’utiliser une propriété de dépendance initialement inscrite pour un autre type. La classe d’ajout n’est généralement pas une classe dérivée du type ayant inscrit initialement cette propriété de dépendance comme propriétaire. En pratique, cela permet à votre classe et à ses classes dérivées d’« hériter » d’une implémentation de propriété de dépendance sans que la classe propriétaire d’origine et la classe d’ajout ne soient dans la même vraie hiérarchie de classes. En outre, la classe d’ajout (et aussi toutes les classes dérivées) peuvent ensuite fournir des métadonnées propres au type pour la propriété de dépendance d’origine.  
  
 En plus de s’ajouter comme propriétaire par l’intermédiaire des méthodes utilitaires du système de propriétés, la classe d’ajout doit déclarer des membres publics supplémentaires sur elle-même pour que la propriété de dépendance participe totalement au système de propriétés avec exposition à la fois au code et au balisage. Une classe qui ajoute une propriété de dépendance existante a les mêmes responsabilités, en ce qui concerne l’exposition du modèle objet pour cette propriété de dépendance, qu’une classe qui définit une nouvelle propriété de dépendance personnalisée. Le premier membre de ce genre à exposer est un champ identificateur de propriété de dépendance. Ce champ doit être un `public static readonly` champ de type <xref:System.Windows.DependencyProperty>, qui est assigné à la valeur de retour de <xref:System.Windows.DependencyProperty.AddOwner%2A> l’appel. Le deuxième membre à définir est la propriété «wrapper» du common language runtime (CLR). Le wrapper rend plus pratique la manipulation de votre propriété de dépendance dans le code (vous évitez les <xref:System.Windows.DependencyObject.SetValue%2A> appels à chaque fois, et ne peut effectuer cet appel qu’une seule fois dans le wrapper lui-même). Le wrapper est implémenté exactement comment il le serait si vous inscriviez une propriété de dépendance personnalisée. Pour plus d’informations sur l’implémentation d’une propriété de dépendance, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md) et [Ajouter un type propriétaire d’une propriété de dépendance](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner et les propriétés jointes  
 Vous pouvez appeler <xref:System.Windows.DependencyProperty.AddOwner%2A> pour une propriété de dépendance qui est définie en tant que propriété jointe par la classe owner. En général, ceci a pour but d’exposer la propriété précédemment jointe en tant que propriété de dépendance non jointe. Vous exposerez ensuite <xref:System.Windows.DependencyProperty.AddOwner%2A> la valeur de retour `public static readonly` en tant que champ pour une utilisation en tant qu’identificateur de propriété de dépendance, et définirez les propriétés de «wrapper» appropriées afin que la propriété apparaisse dans la table des membres et prenne en charge une propriété non attachée utilisation dans votre classe.  
  
## <a name="see-also"></a>Voir aussi

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Vue d’ensemble des propriétés de dépendance](dependency-properties-overview.md)
- [Métadonnées de propriété de framework](framework-property-metadata.md)
