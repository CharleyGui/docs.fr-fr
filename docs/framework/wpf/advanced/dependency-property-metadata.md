---
title: Métadonnées de propriété de dépendance
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 3d84510fce69e81929cbe9b6088e12aaf3409769
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186368"
---
# <a name="dependency-property-metadata"></a>Métadonnées de propriété de dépendance
Le [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] système de propriété comprend un système de déclaration des métadonnées qui va au-delà de ce qui peut être rapporté au sujet d’une propriété par la réflexion ou les caractéristiques générales de l’heure courante de langue commune (CLR). Les métadonnées d’une propriété de dépendance peuvent également être affectées de manière unique par la classe qui définit une propriété de dépendance, peuvent être changées quand la propriété de dépendance est ajoutée à une autre classe, et peuvent être substituées de manière spécifique par toutes les classes dérivées qui héritent de la propriété de dépendance de la classe de base de définition.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Conditions préalables requises  
 Cette rubrique part du principe que vous savez ce que sont les propriétés de dépendance du point de vue d’un consommateur de propriétés de dépendance existantes sur les classes [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] et que vous avez lu [Vue d’ensemble des propriétés de dépendance](dependency-properties-overview.md). Pour pouvoir suivre les exemples de cette rubrique, vous devez également comprendre [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] et savoir comment écrire des applications [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="dp_metadata_contents"></a>
## <a name="how-dependency-property-metadata-is-used"></a>Utilisation des métadonnées de propriété de dépendance  
 Les métadonnées de propriété de dépendance existent en tant qu’objet qui peut être interrogé pour examiner les caractéristiques d’une propriété de dépendance. Ces métadonnées sont également souvent sollicitées par le système de propriétés quand il traite des propriétés de dépendance. L’objet de métadonnées pour une propriété de dépendance peut contenir les types d’informations suivants :  
  
- Valeur par défaut pour la propriété de dépendance, si aucune autre valeur ne peut être déterminée pour la propriété de dépendance par la valeur locale, le modèle, l’héritage, etc. Pour une discussion approfondie de la façon dont les valeurs par défaut participent à la préséance utilisée par le système immobilier lors de l’attribution de valeurs pour les propriétés de dépendance, voir [Dépendance Valeur de la propriété Precedence](dependency-property-value-precedence.md).  
  
- Références aux implémentations de rappels qui affectent les comportements de forçage ou de notification de modification en fonction du type de propriétaire. Notez que ces rappels sont souvent définis avec un niveau d’accès non public. Ainsi, il n’est généralement pas possible d’obtenir les références réelles à partir des métadonnées, sauf si les références sont dans votre étendue d’accès autorisée. Pour plus d’informations sur les rappels de propriété de dépendance, consultez [Validation et rappels de propriétés de dépendance](dependency-property-callbacks-and-validation.md).  
  
- Si la propriété de dépendance en question est considérée comme une propriété de niveau framework WPF, les métadonnées peuvent contenir des caractéristiques de propriété de dépendance de niveau framework WPF qui fournissent des informations et indiquent l’état de services tels que le moteur de disposition de niveau framework WPF et la logique d’héritage de propriété. Pour plus d’informations sur cet aspect des métadonnées de propriété de dépendance, consultez [Métadonnées de propriété de framework](framework-property-metadata.md).  
  
<a name="APIs"></a>
## <a name="metadata-apis"></a>API de métadonnées  
 Le type qui rapporte la plupart des informations sur <xref:System.Windows.PropertyMetadata> les métadonnées utilisées par le système de propriété est la classe. Des instances de métadonnées sont éventuellement spécifiées quand les propriétés de dépendance sont inscrites auprès du système de propriétés, et peuvent également être spécifiées pour d’autres types qui s’ajoutent comme propriétaires ou remplacent les métadonnées dont ils héritent à partir de la définition de propriété de dépendance de la classe de base. (Pour les cas où l’enregistrement d’une propriété ne précise pas les métadonnées, un défaut <xref:System.Windows.PropertyMetadata> est créé avec des valeurs par défaut pour cette classe.) Les métadonnées enregistrées sont retournées comme <xref:System.Windows.PropertyMetadata> lorsque vous appelez les différentes <xref:System.Windows.DependencyProperty.GetMetadata%2A> <xref:System.Windows.DependencyObject> surcharges qui obtiennent des métadonnées d’une propriété de dépendance sur une instance.  
  
 La <xref:System.Windows.PropertyMetadata> classe est ensuite dérivée pour fournir des métadonnées plus spécifiques pour les divisions architecturales telles que les classes de niveau cadre WPF. <xref:System.Windows.UIPropertyMetadata>ajoute des rapports <xref:System.Windows.FrameworkPropertyMetadata> d’animation et fournit les propriétés de niveau cadre WPF mentionnées dans la section précédente. Lorsque les propriétés de dépendance sont <xref:System.Windows.PropertyMetadata> enregistrées, elles peuvent être enregistrées auprès de ces classes dérivées. Lorsque les métadonnées sont <xref:System.Windows.PropertyMetadata> examinées, le type de base peut potentiellement être jeté aux classes dérivées afin que vous puissiez examiner les propriétés plus spécifiques.  
  
> [!NOTE]
> Les caractéristiques de propriété <xref:System.Windows.FrameworkPropertyMetadata> qui peuvent être spécifiées dans sont parfois appelées dans cette documentation des « drapeaux ». Lorsque vous créez de nouvelles métadonnées pour une utilisation dans les enregistrements de propriétés de <xref:System.Windows.FrameworkPropertyMetadataOptions> dépendance ou les remplacements de métadonnées, <xref:System.Windows.FrameworkPropertyMetadata> vous spécifiez ces valeurs en utilisant le recensement du signal et ensuite vous fournissez des valeurs éventuellement concatenées de l’énumération au constructeur. Cependant, une fois construites, ces <xref:System.Windows.FrameworkPropertyMetadata> caractéristiques d’option sont exposées dans une série de propriétés Boolean plutôt que la valeur de recensement de construction. Les propriétés booléennes vous permettent de vérifier chaque condition, plutôt que d’avoir à appliquer un masque à une valeur d’énumération d’indicateurs pour obtenir les informations qui vous intéressent. Le constructeur utilise le concatenated <xref:System.Windows.FrameworkPropertyMetadataOptions> afin de garder la longueur de la signature du constructeur raisonnable, tandis que les métadonnées construites réelles expose les propriétés discrètes pour rendre la requête des métadonnées plus intuitive.  
  
<a name="override_or_subclass"></a>
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Quand substituer des métadonnées, quand dériver une classe ?  
 Le système de propriétés [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] offre des fonctionnalités établies pour changer certaines caractéristiques des propriétés de dépendance sans nécessiter leur réimplémentation totale. Pour cela, vous devez construire une instance différente des métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur un type particulier. Notez que la plupart des propriétés de dépendance existantes ne sont pas des propriétés virtuelles. Ainsi, à proprement parler, vous ne pouvez les « réimplémenter » sur des classes héritées qu’en occultant le membre existant.  
  
 Si le scénario que vous tentez d’activer pour une propriété de dépendance sur un type ne peut pas être obtenu en changeant les caractéristiques des propriétés de dépendance existantes, il peut être nécessaire de créer une classe dérivée, puis de déclarer une propriété de dépendance personnalisée sur votre classe dérivée. Une propriété de dépendance personnalisée se comporte [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] de la même façon que les propriétés de dépendance définies par les API. Pour plus d’informations sur les propriétés de dépendance personnalisées, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md).  
  
 L’une des caractéristiques principales d’une propriété de dépendance que vous ne pouvez pas substituer est son type de valeur. Si vous héritez d’une propriété de dépendance qui a le comportement approximatif souhaité, mais que vous avez besoin pour elle d’un type différent, vous devrez implémenter une propriété de dépendance personnalisée et peut-être lier les propriétés par l’intermédiaire de la conversion de type ou autre implémentation sur votre classe personnalisée. En outre, vous <xref:System.Windows.ValidateValueCallback>ne pouvez pas remplacer un existant , parce que ce rappel existe dans le domaine d’enregistrement lui-même et non pas dans ses métadonnées.  
  
<a name="scenarios"></a>
## <a name="scenarios-for-changing-existing-metadata"></a>Scénarios de changement des métadonnées existantes  
 Si vous travaillez avec des métadonnées d’une propriété de dépendance existante, un scénario courant de changement des métadonnées de propriété de dépendance consiste à modifier la valeur par défaut. Le changement ou l’ajout de rappels du système de propriétés est un scénario plus avancé. Vous souhaiterez peut-être le faire si votre implémentation d’une classe dérivée a des corrélations différentes entre des propriétés de dépendance. L’une des conditions pour disposer d’un modèle de programmation qui prend en charge à la fois le code et l’utilisation déclarative est que les propriétés doivent pouvoir être définies dans n’importe quel ordre. Par conséquent, toutes les propriétés dépendantes doivent être définies juste-à-temps sans contexte et ne peuvent pas reposer sur la connaissance d’un ordre de définition tel que celui que l’on pourrait trouver dans un constructeur. Pour plus d’informations sur cet aspect du système de propriétés, consultez [Validation et rappels de propriétés de dépendance](dependency-property-callbacks-and-validation.md). Notez que les rappels de validation ne font pas partie des métadonnées ; ils font partie de l’identificateur de propriété de dépendance. Ainsi, vous ne pouvez pas changer les rappels de validation en substituant les métadonnées.  
  
 Dans certains cas, vous souhaiterez peut-être modifier les options de métadonnées de propriété de niveau framework WPF sur des propriétés de dépendance existantes. Ces options communiquent certaines conditions connues sur les propriétés de niveau framework WPF à d’autres processus de niveau framework WPF tels que le système de disposition.  La définition des options n’est généralement effectuée que lors de l’enregistrement d’une nouvelle propriété de <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> dépendance, mais il est également possible de modifier les métadonnées de propriété au niveau du cadre WPF dans le cadre d’un ou <xref:System.Windows.DependencyProperty.AddOwner%2A> d’un appel. Pour connaître les valeurs spécifiques à utiliser et pour plus d’informations, consultez [Métadonnées de propriété de framework](framework-property-metadata.md). Pour plus d’informations sur la façon dont ces options doivent être définies pour une propriété de dépendance récemment inscrite, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>
### <a name="overriding-metadata"></a>Substitution de métadonnées  
 La substitution de métadonnées a pour objectif principal de vous permettre de changer les différents comportements dérivés des métadonnées qui sont appliqués à la propriété de dépendance telle qu’elle existe sur votre type. Les raisons sont expliquées plus en détail dans la section [Métadonnées](#dp_metadata_contents). Pour plus d’informations et pour obtenir des exemples de code, consultez [Substituer les métadonnées d’une propriété de dépendance](how-to-override-metadata-for-a-dependency-property.md).  
  
 Des métadonnées de propriété peuvent être fournies<xref:System.Windows.DependencyProperty.Register%2A>pour une propriété de dépendance pendant l’appel d’enregistrement ( ). Toutefois, dans de nombreux cas, vous souhaiterez peut-être fournir des métadonnées propres au type pour votre classe quand elle hérite de cette propriété de dépendance. Vous pouvez le faire <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> en appelant la méthode.  Par exemple, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] à partir <xref:System.Windows.FrameworkElement> des API, la classe <xref:System.Windows.UIElement.Focusable%2A> est le type qui enregistre d’abord la propriété de dépendance. Mais <xref:System.Windows.Controls.Control> la classe l’emporte sur les métadonnées pour la propriété `false` `true`de dépendance pour fournir <xref:System.Windows.UIElement.Focusable%2A> sa propre valeur par défaut initiale, la changeant de , et autrement réutiliser la mise en œuvre originale.  
  
 Quand vous substituez des métadonnées, les différentes caractéristiques des métadonnées sont fusionnées ou remplacées.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>est fusionnée. Si vous ajoutez <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>un nouveau , ce rappel est stocké dans les métadonnées. Si vous ne <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> spécifiez pas <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> un dans le remplacement, la valeur de est promu comme une référence de l’ancêtre le plus proche qui l’a spécifié dans les métadonnées.  
  
- Le comportement réel <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> du système de propriété est que les implémentations pour tous les propriétaires de métadonnées dans la hiérarchie sont conservés et ajoutés à un tableau, avec l’ordre d’exécution par le système de propriété étant que les rappels de la classe la plus dérivée sont invoqués en premier.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A>est remplacé. Si vous ne <xref:System.Windows.PropertyMetadata.DefaultValue%2A> spécifiez pas <xref:System.Windows.PropertyMetadata.DefaultValue%2A> un dans le remplacement, la valeur de vient de l’ancêtre le plus proche qui l’a spécifié dans les métadonnées.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>les implémentations sont remplacées. Si vous ajoutez <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>un nouveau , ce rappel est stocké dans les métadonnées. Si vous ne <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> spécifiez pas <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> un dans le remplacement, la valeur de est promu comme une référence de l’ancêtre le plus proche qui l’a spécifié dans les métadonnées.  
  
- Le comportement du système <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> de propriété est que seules les métadonnées immédiates sont invoquées. Aucune référence <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> à d’autres implémentations dans la hiérarchie n’est conservée.  
  
 Ce comportement est <xref:System.Windows.PropertyMetadata.Merge%2A>mis en œuvre par , et peut être remplacé sur les classes de métadonnées dérivées.  
  
#### <a name="overriding-attached-property-metadata"></a>Substitution de métadonnées de propriété jointe  
 Dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], les propriétés jointes sont implémentées en tant que propriétés de dépendance. Cela signifie qu’elles ont également des métadonnées de propriété, que les différentes classes peuvent substituer. Les considérations de portée pour [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] une propriété <xref:System.Windows.DependencyObject> attachée sont généralement que n’importe quel peut avoir une propriété attachée fixée sur eux. Par conséquent, toute <xref:System.Windows.DependencyObject> classe dérivée peut remplacer les métadonnées pour toute propriété jointe, car elle pourrait être fixée sur un cas de la classe. Vous pouvez substituer les valeurs par défaut, les rappels ou les propriétés de rapport de caractéristiques de niveau framework WPF. Si la propriété jointe est définie sur une instance de votre classe, ces caractéristiques de métadonnées de propriété de substitution s’appliquent. Par exemple, vous pouvez substituer la valeur par défaut de telle sorte que votre valeur de remplacement soit signalée comme valeur de la propriété jointe sur des instances de votre classe chaque fois que la propriété n’est pas définie autrement.  
  
> [!NOTE]
> La <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propriété n’est pas pertinente pour les propriétés attachées.  
  
<a name="dp_add_owner"></a>
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Ajout d’une classe en tant que propriétaire d’une propriété de dépendance existante  
 Une classe peut s’ajouter en tant que propriétaire d’une <xref:System.Windows.DependencyProperty.AddOwner%2A> propriété de dépendance qui a déjà été enregistrée, en utilisant la méthode. Cela permet à la classe d’utiliser une propriété de dépendance initialement inscrite pour un autre type. La classe d’ajout n’est généralement pas une classe dérivée du type ayant inscrit initialement cette propriété de dépendance comme propriétaire. En pratique, cela permet à votre classe et à ses classes dérivées d’« hériter » d’une implémentation de propriété de dépendance sans que la classe propriétaire d’origine et la classe d’ajout ne soient dans la même vraie hiérarchie de classes. En outre, la classe d’ajout (et aussi toutes les classes dérivées) peuvent ensuite fournir des métadonnées propres au type pour la propriété de dépendance d’origine.  
  
 En plus de s’ajouter comme propriétaire par l’intermédiaire des méthodes utilitaires du système de propriétés, la classe d’ajout doit déclarer des membres publics supplémentaires sur elle-même pour que la propriété de dépendance participe totalement au système de propriétés avec exposition à la fois au code et au balisage. Une classe qui ajoute une propriété de dépendance existante a les mêmes responsabilités, en ce qui concerne l’exposition du modèle objet pour cette propriété de dépendance, qu’une classe qui définit une nouvelle propriété de dépendance personnalisée. Le premier membre de ce genre à exposer est un champ identificateur de propriété de dépendance. Ce champ doit `public static readonly` être <xref:System.Windows.DependencyProperty>un champ de type , <xref:System.Windows.DependencyProperty.AddOwner%2A> qui est attribué à la valeur de retour de l’appel. Le deuxième membre à définir est la propriété « emballage » de l’heure courante de l’exécution de la langue (CLR). L’emballage le rend beaucoup plus pratique de manipuler votre <xref:System.Windows.DependencyObject.SetValue%2A> propriété de dépendance dans le code (vous évitez les appels à chaque fois, et pouvez faire cet appel qu’une seule fois dans l’emballage lui-même). Le wrapper est implémenté exactement comment il le serait si vous inscriviez une propriété de dépendance personnalisée. Pour plus d’informations sur l’implémentation d’une propriété de dépendance, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md) et [Ajouter un type propriétaire d’une propriété de dépendance](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner et les propriétés jointes  
 Vous pouvez <xref:System.Windows.DependencyProperty.AddOwner%2A> demander une propriété de dépendance qui est définie comme une propriété attachée par la classe propriétaire. En général, ceci a pour but d’exposer la propriété précédemment jointe en tant que propriété de dépendance non jointe. Vous exposerez <xref:System.Windows.DependencyProperty.AddOwner%2A> ensuite la `public static readonly` valeur de retour comme un champ pour une utilisation comme identifiant de propriété de dépendance, et définirez les propriétés appropriées d'« emballage » de sorte que la propriété apparaît dans la table des membres et prend en charge une utilisation non attachée de propriété dans votre classe.  
  
## <a name="see-also"></a>Voir aussi

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Aperçu des propriétés de dépendance](dependency-properties-overview.md)
- [Métadonnées de propriété de framework](framework-property-metadata.md)
