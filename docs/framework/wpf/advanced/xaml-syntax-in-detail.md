---
title: Syntaxe XAML en détail
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 5f8bb862ce443fd7397036b10f69cda65a6960bc
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646143"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="d5d4f-102">Syntaxe XAML en détail</span><span class="sxs-lookup"><span data-stu-id="d5d4f-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="d5d4f-103">Ce sujet définit les termes qui sont utilisés pour décrire les éléments de la syntaxe XAML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="d5d4f-104">Ces termes sont fréquemment utilisés tout au long du reste de cette documentation, à la fois pour la documentation WPF spécifiquement et pour les autres cadres qui utilisent XAML ou les concepts XAML de base activés par le support linguistique XAML au niveau System.Xaml.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="d5d4f-105">Ce sujet s’étend sur la terminologie de base introduite dans le sujet [XAML Aperçu (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>
## <a name="the-xaml-language-specification"></a><span data-ttu-id="d5d4f-106">La spécification linguistique XAML</span><span class="sxs-lookup"><span data-stu-id="d5d4f-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="d5d4f-107">La terminologie syntaxe XAML définie ici est également définie ou référencée dans la spécification de la langue XAML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="d5d4f-108">XAML est une langue basée sur XML et suit ou élargit les règles structurelles XML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="d5d4f-109">Une partie de la terminologie est partagée à partir ou est basée sur la terminologie couramment utilisée lors de la description de la langue XML ou le modèle d’objet de document XML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="d5d4f-110">Pour plus d’informations sur les spécifications linguistiques XAML, téléchargez [ \[MS-XAML\] ](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) à partir du Microsoft Download Center.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>
## <a name="xaml-and-clr"></a><span data-ttu-id="d5d4f-111">XAML et CLR</span><span class="sxs-lookup"><span data-stu-id="d5d4f-111">XAML and CLR</span></span>  
 <span data-ttu-id="d5d4f-112">XAML est un langage de balisage.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-112">XAML is a markup language.</span></span> <span data-ttu-id="d5d4f-113">L’heure courante de l’exécution de langue (CLR), comme l’implique son nom, permet l’exécution de l’exécution de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-113">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="d5d4f-114">XAML n’est pas en soi l’une des langues communes qui est directement consommée par le temps d’exécution CLR.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="d5d4f-115">Au lieu de cela, vous pouvez penser à XAML comme soutenant son propre système de type.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="d5d4f-116">Le système d’analyse XAML particulier qui est utilisé par WPF est construit sur le CLR et le système de type CLR.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="d5d4f-117">Les types XAML sont cartographiés sur les types CLR pour instantanér une représentation du temps d’exécution lorsque le XAML pour WPF est analysé.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="d5d4f-118">Pour cette raison, le reste de la discussion de la syntaxe dans ce document comprendra des références au système de type CLR, même si les discussions linguistiques équivalentes dans la spécification linguistique XAML ne le font pas.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="d5d4f-119">(Selon le niveau de spécification de langue XAML, les types XAML pourraient être cartographiés à tout autre système de type, qui n’a pas besoin d’être le CLR, mais qui nécessiterait la création et l’utilisation d’un analyseur XAML différent.)</span><span class="sxs-lookup"><span data-stu-id="d5d4f-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="d5d4f-120">Membres de Types et De l’Héritage de classe</span><span class="sxs-lookup"><span data-stu-id="d5d4f-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="d5d4f-121">Propriétés et événements tels qu’ils [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] apparaissent en tant que membres XAML d’un type sont souvent hérités des types de base.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="d5d4f-122">Par exemple, considérez `<Button Background="Blue" .../>`cet exemple: .</span><span class="sxs-lookup"><span data-stu-id="d5d4f-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="d5d4f-123">La <xref:System.Windows.Controls.Control.Background%2A> propriété n’est pas <xref:System.Windows.Controls.Button> une propriété immédiatement déclarée sur la classe, si vous devait examiner la définition de classe, les résultats de réflexion, ou la documentation.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="d5d4f-124">Au <xref:System.Windows.Controls.Control.Background%2A> lieu de cela, est hérité de la classe de base. <xref:System.Windows.Controls.Control></span><span class="sxs-lookup"><span data-stu-id="d5d4f-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="d5d4f-125">Le comportement d’héritage de classe des [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] éléments XAML est un écart significatif d’une interprétation schéma-forcée de la balisage XML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="d5d4f-126">L’héritage de classe peut devenir complexe, en particulier lorsque les classes intermédiaires de base sont abstraites, ou lorsque des interfaces sont impliquées.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="d5d4f-127">C’est l’une des raisons pour lesquelles l’ensemble d’éléments XAML et leurs attributs autorisés est difficile à représenter avec précision et complètement en utilisant les types de schémas qui sont généralement utilisés pour la programmation XML, tels que le format DTD ou XSD.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="d5d4f-128">Une autre raison est que l’extéabilité et les caractéristiques de cartographie de type de la langue XAML elle-même empêchent l’exhaustivité de toute représentation fixe des types et des membres autorisés.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>
## <a name="object-element-syntax"></a><span data-ttu-id="d5d4f-129">Syntaxe de l’élément objet</span><span class="sxs-lookup"><span data-stu-id="d5d4f-129">Object Element Syntax</span></span>  
 <span data-ttu-id="d5d4f-130">*La syntaxe d’élément d’objet* est la syntaxe de balisage XAML qui instantanéise une classe ou une structure CLR en déclarant un élément XML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="d5d4f-131">Cette syntaxe ressemble à l’élément syntaxe d’autres langages de balisage tels que HTML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="d5d4f-132">La syntaxe d’élément d’objet commence par un support d’angle gauche (),\<suivi immédiatement du nom de type de la classe ou de la structure en cours d’instantané.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="d5d4f-133">Zéro ou plusieurs espaces peuvent suivre le nom de type, et zéro ou plusieurs attributs peuvent également être déclarés sur l’élément objet, avec un ou plusieurs espaces séparant chaque nom d’attribut "valeur" paire.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="d5d4f-134">Enfin, l’un des éléments suivants doit être vrai :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-134">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="d5d4f-135">L’élément et l’étiquette doivent être fermés par une barre oblique avant (/) suivie immédiatement d’un support d’angle droit (>).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="d5d4f-136">L’étiquette d’ouverture doit être complétée par un support d’angle droit (>).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="d5d4f-137">D’autres éléments d’objets, éléments de propriété ou texte intérieur peuvent suivre l’étiquette d’ouverture.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="d5d4f-138">Exactement ce que le contenu peut être contenu ici est généralement limité par le modèle d’objet de l’élément.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="d5d4f-139">L’étiquette de fermeture équivalente pour l’élément objet doit également exister, dans la nidification et l’équilibre appropriés avec d’autres paires d’étiquettes d’ouverture et de fermeture.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="d5d4f-140">XAML tel qu’implémenté par .NET a un ensemble de règles qui cartographient les éléments d’objets en types, attributs en propriétés ou événements, et XAML namespaces aux espaces de noms CLR plus l’assemblage.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="d5d4f-141">Pour WPF et .NET, les éléments d’objets XAML sont cartographiques pour les types .NET tels que définis dans les assemblages référencés, et la carte des attributs aux membres de ces types.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-141">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="d5d4f-142">Lorsque vous faites référence à un type CLR dans XAML, vous avez également accès aux membres hérités de ce type.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="d5d4f-143">Par exemple, l’exemple suivant est la syntaxe d’élément objet qui instantanéise une nouvelle instance de la <xref:System.Windows.Controls.Button> classe, et précise également un <xref:System.Windows.FrameworkElement.Name%2A> attribut et une valeur pour cet attribut :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="d5d4f-144">L’exemple suivant est la syntaxe d’élément d’objet qui inclut également la syntaxe de propriété de contenu XAML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="d5d4f-145">Le texte intérieur contenu dans sera <xref:System.Windows.Controls.TextBox> utilisé pour définir <xref:System.Windows.Controls.TextBox.Text%2A>la propriété de contenu XAML, .</span><span class="sxs-lookup"><span data-stu-id="d5d4f-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="d5d4f-146">Modèles de contenu</span><span class="sxs-lookup"><span data-stu-id="d5d4f-146">Content Models</span></span>  
 <span data-ttu-id="d5d4f-147">Une classe peut prendre en charge une utilisation en tant qu’élément d’objet XAML en termes de syntaxe, mais cet élément ne fonctionnera correctement dans une application ou une page lorsqu’il est placé dans une position prévue d’un modèle de contenu global ou d’un arbre d’élément.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="d5d4f-148">Par exemple, <xref:System.Windows.Controls.MenuItem> un ne devrait généralement être <xref:System.Windows.Controls.Primitives.MenuBase> placé que <xref:System.Windows.Controls.Menu>comme un enfant d’une classe dérivée comme .</span><span class="sxs-lookup"><span data-stu-id="d5d4f-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="d5d4f-149">Les modèles de contenu pour des éléments spécifiques sont documentés [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dans le cadre des remarques sur les pages de classe pour les contrôles et autres classes qui peuvent être utilisés comme éléments XAML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>
## <a name="properties-of-object-elements"></a><span data-ttu-id="d5d4f-150">Propriétés des éléments d’objet</span><span class="sxs-lookup"><span data-stu-id="d5d4f-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="d5d4f-151">Les propriétés de XAML sont définies par une variété de syntaxes possibles.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="d5d4f-152">Quelle syntaxe peut être utilisée pour une propriété particulière variera, en fonction des caractéristiques du système de type sous-jacent de la propriété que vous définissez.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="d5d4f-153">En définissant des valeurs de propriétés, vous ajoutez des fonctionnalités ou des caractéristiques aux objets tels qu’ils existent dans le graphique de l’objet temporel.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="d5d4f-154">L’état initial de l’objet créé à partir d’un élément d’objet est basé sur le comportement du constructeur sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-154">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="d5d4f-155">En règle générale, votre application utilisera autre chose qu’une instance par défaut complète de n’importe quel objet donné.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>
## <a name="attribute-syntax-properties"></a><span data-ttu-id="d5d4f-156">Syntaxe d’attribut (Propriétés)</span><span class="sxs-lookup"><span data-stu-id="d5d4f-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="d5d4f-157">La syntaxe d’attribut est la syntaxe de balisage XAML qui établit une valeur pour une propriété en déclarant un attribut sur un élément d’objet existant.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="d5d4f-158">Le nom d’attribut doit correspondre au nom du membre CLR de la propriété de la classe qui soutient l’élément objet pertinent.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="d5d4f-159">Le nom d’attribut est suivi par un opérateur d’affectation (MD).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="d5d4f-160">La valeur d’attribut doit être une chaîne jointe dans les devis.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d5d4f-161">Vous pouvez utiliser des citations alternées pour placer une marque de citation littérale dans un attribut.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="d5d4f-162">Par exemple, vous pouvez utiliser des citations simples comme un moyen de déclarer une chaîne qui contient un caractère de double devis en son sein.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="d5d4f-163">Que vous utilisiez des devis simples ou doubles, vous devez utiliser une paire assortie pour ouvrir et fermer la chaîne de valeur d’attribut.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="d5d4f-164">Il existe également des séquences d’évasion ou d’autres techniques disponibles pour travailler autour des restrictions de caractère imposées par une syntaxe XAML particulière.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="d5d4f-165">Voir [XML Character Entities et XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-165">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="d5d4f-166">Pour être définie par la syntaxe d’attribut, une propriété doit être publique et doit être écrivante.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="d5d4f-167">La valeur de la propriété dans le système de type support doit être un type de valeur, ou doit être un type de référence qui peut être instantanée ou référencée par un processeur XAML lors de l’accès au type de sauvegarde pertinent.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="d5d4f-168">Pour les événements WPF XAML, l’événement qui est référencé comme le nom d’attribut doit être public et avoir un délégué public.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="d5d4f-169">La propriété ou l’événement doit être un membre de la classe ou de la structure qui est instantanée par l’élément d’objet contenant.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="d5d4f-170">Traitement des valeurs d’attributs</span><span class="sxs-lookup"><span data-stu-id="d5d4f-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="d5d4f-171">La valeur de chaîne contenue dans les guillemets d’ouverture et de clôture est traitée par un processeur XAML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="d5d4f-172">Pour les propriétés, le comportement de traitement par défaut est déterminé par le type de propriété SOUS-jacente CLR.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="d5d4f-173">La valeur d’attribut est remplie par l’un des éléments suivants, en utilisant cet ordre de traitement :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="d5d4f-174">Si le processeur XAML rencontre une accolade bouclée, <xref:System.Windows.Markup.MarkupExtension>ou un élément d’objet qui dérive de , puis l’extension de balisage référencée est évaluée d’abord plutôt que de traiter la valeur comme une chaîne, et l’objet retourné par l’extension de balisage est utilisé comme la valeur.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="d5d4f-175">Dans de nombreux cas, l’objet retourné par une extension de balisage sera une référence à un objet existant, ou une expression qui reporte l’évaluation jusqu’au moment de l’exécution, et n’est pas un objet nouvellement instantané.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="d5d4f-176">Si la propriété est <xref:System.ComponentModel.TypeConverter>déclarée avec un attribut, ou le <xref:System.ComponentModel.TypeConverter>type de valeur de cette propriété est déclaré avec un attribué , la valeur de chaîne de l’attribut est soumise au convertisseur de type comme entrée de conversion, et le convertisseur retournera une nouvelle instance d’objet.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="d5d4f-177">S’il <xref:System.ComponentModel.TypeConverter>n’y a pas, une conversion directe au type de propriété est tentée.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="d5d4f-178">Ce niveau final est une conversion directe à la valeur parser-native entre les types primitifs de langue XAML, ou un contrôle pour les noms des constantes nommées dans un énumération (le parseur accède alors aux valeurs correspondantes).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="d5d4f-179">Valeurs d’attribut d’énumération</span><span class="sxs-lookup"><span data-stu-id="d5d4f-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="d5d4f-180">Les énumérations dans XAML sont traitées intrinsèquement par des analyseurs XAML, et les membres d’un recensement doivent être spécifiés en spécifiant le nom de chaîne de l’une des constantes nommées de l’énumération.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="d5d4f-181">Pour les valeurs d’énumération non-flag, le comportement natif est de traiter la chaîne d’une valeur d’attribut et de la résoudre à l’une des valeurs d’énumération.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="d5d4f-182">Vous ne spécifiez pas l’énumération dans le format *Énumération*. *Valeur*, comme vous le faites dans le code.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="d5d4f-183">Au lieu de cela, vous spécifiez seulement *la valeur*, et *l’énumération* est déduite par le type de propriété que vous définissez.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="d5d4f-184">Si vous spécifiez un attribut dans *l’énumération*. Forme de *valeur,* il ne résoudra pas correctement.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="d5d4f-185">Pour les énumérations dans le sens <xref:System.Enum.Parse%2A?displayProperty=nameWithType> du signal, le comportement est basé sur la méthode.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d5d4f-186">Vous pouvez spécifier plusieurs valeurs pour un recensement du drapeau en séparant chaque valeur par une virgule.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="d5d4f-187">Cependant, vous ne pouvez pas combiner des valeurs d’énumération qui ne sont pas dans le sens du signalement.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="d5d4f-188">Par exemple, vous ne pouvez pas utiliser la <xref:System.Windows.Trigger> syntaxe virgule pour tenter de créer un qui agit sur de multiples conditions d’un recensement non enflammé :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="d5d4f-189">Les énumérations flagwise qui prennent en charge les attributs qui sont définis dans XAML sont rares dans WPF.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="d5d4f-190">Cependant, l’un de <xref:System.Windows.Media.StyleSimulations>ces énumérations est .</span><span class="sxs-lookup"><span data-stu-id="d5d4f-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="d5d4f-191">Vous pouvez, par exemple, utiliser la syntaxe d’attribut signalaire délimitée <xref:System.Windows.Documents.Glyphs> pour modifier l’exemple fourni dans les Remarques pour la classe; `StyleSimulations = "BoldSimulation"` pourrait `StyleSimulations = "BoldSimulation,ItalicSimulation"`devenir .</span><span class="sxs-lookup"><span data-stu-id="d5d4f-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="d5d4f-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>est une autre propriété où plus d’une valeur d’énumération peut être spécifiée.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="d5d4f-193">Cependant, cette propriété se trouve être <xref:System.Windows.Input.ModifierKeys> un cas spécial, parce que le recensement prend en charge son propre convertisseur de type.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="d5d4f-194">Le convertisseur de type pour modificateurs utilise un signe plus (en) comme délimitateur plutôt qu’une virgule (,).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="d5d4f-195">Cette conversion prend en charge la syntaxe plus traditionnelle pour représenter les combinaisons clés de la programmation Microsoft Windows, telles que "Ctrl-Alt".</span><span class="sxs-lookup"><span data-stu-id="d5d4f-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="d5d4f-196">Références de nom des propriétés et des membres de l’événement</span><span class="sxs-lookup"><span data-stu-id="d5d4f-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="d5d4f-197">Lorsque vous spécifiez un attribut, vous pouvez faire référence à toute propriété ou événement qui existe en tant que membre du type CLR que vous avez instantané pour l’élément objet contenant.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="d5d4f-198">Ou, vous pouvez faire référence à une propriété jointe ou à un événement joint, indépendamment de l’élément objet contenant.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="d5d4f-199">(Les propriétés ci-jointes sont discutées dans une section à venir.)</span><span class="sxs-lookup"><span data-stu-id="d5d4f-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="d5d4f-200">Vous pouvez également nommer n’importe quel événement à partir de n’importe quel objet qui est accessible par l’espace nom par défaut en utilisant un *typeName*. nom partiellement qualifié de *l’événement;* cette syntaxe prend en charge l’attachement des gestionnaires pour les événements acheminés où le gestionnaire est destiné à gérer les événements de routage à partir d’éléments enfant, mais l’élément parent n’a pas aussi cet événement dans sa table des membres.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="d5d4f-201">Cette syntaxe ressemble à une syntaxe événement ci-jointe, mais l’événement ici n’est pas un véritable événement ci-joint.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="d5d4f-202">Au lieu de cela, vous faites référence à un événement avec un nom qualifié.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="d5d4f-203">Pour plus d’informations, voir [Aperçu des événements acheminés](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-203">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="d5d4f-204">Pour certains scénarios, les noms de propriété sont parfois fournis comme la valeur d’un attribut, plutôt que le nom d’attribut.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="d5d4f-205">Ce nom de propriété peut également inclure des qualificatifs, tels que la propriété spécifiée dans le propriétaire de *formeType*. *dépendancePropertyName*.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="d5d4f-206">Ce scénario est courant lors de l’écriture de styles ou de modèles dans XAML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="d5d4f-207">Les règles de traitement des noms de propriété fournies comme valeur d’attribut sont différentes, et sont régies par le type de propriété étant définie ou par les comportements de sous-systèmes WPF particuliers.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="d5d4f-208">Pour plus de détails, voir [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-208">For details, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>  
  
 <span data-ttu-id="d5d4f-209">Une autre utilisation pour les noms de propriété est quand une valeur d’attribut décrit une relation propriété-propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="d5d4f-210">Cette fonctionnalité est utilisée pour la liaison de données <xref:System.Windows.PropertyPath> et pour les cibles storyboard, et est activée par la classe et son convertisseur de type.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="d5d4f-211">Pour une description plus complète de la sémantique de recherche, voir [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>
## <a name="property-element-syntax"></a><span data-ttu-id="d5d4f-212">Syntaxe des éléments de propriété</span><span class="sxs-lookup"><span data-stu-id="d5d4f-212">Property Element Syntax</span></span>  
 <span data-ttu-id="d5d4f-213">*La syntaxe d’élément de propriété* est une syntaxe qui diverge quelque peu des règles de base de syntaxe XML pour les éléments.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="d5d4f-214">Dans XML, la valeur d’un attribut est une chaîne de facto, la seule variante possible étant le format d’encodage des cordes qui est utilisé.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="d5d4f-215">Dans XAML, vous pouvez attribuer d’autres éléments d’objet pour être la valeur d’une propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="d5d4f-216">Cette capacité est activée par la syntaxe de l’élément de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="d5d4f-217">Au lieu que la propriété soit spécifiée comme attribut dans l’étiquette d’élément, la propriété est spécifiée à l’aide d’une étiquette d’élément d’ouverture dans *elementTypeName*. *formulaire de propriétéName,* la valeur de la propriété est spécifiée à l’intérieur, puis l’élément de propriété est fermé.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="d5d4f-218">Plus précisément, la syntaxe commence\<par un support d’angle gauche (), suivi immédiatement par le nom de type de la classe ou de la structure que la syntaxe d’élément de propriété est contenue dans.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="d5d4f-219">Elle est immédiatement suivie d’un seul point (.), puis du nom d’une propriété, puis d’un support d’angle droit (>).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="d5d4f-220">Comme pour la syntaxe d’attribut, cette propriété doit exister au sein des membres publics déclarés du type spécifié.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="d5d4f-221">La valeur à attribuer à la propriété est contenue dans l’élément propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="d5d4f-222">Typiquement, la valeur est donnée comme un ou plusieurs éléments d’objet, parce que spécifier des objets comme valeurs est le scénario que la syntaxe d’élément de propriété est destinée à traiter.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="d5d4f-223">Enfin, une balise de clôture équivalente spécifiant le même *élémentTypeName*. *propriété La* combinaison de noms de propriété doit être fournie, dans la nidification et l’équilibre appropriés avec d’autres étiquettes d’élément.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="d5d4f-224">Par exemple, ce qui suit est <xref:System.Windows.FrameworkElement.ContextMenu%2A> la <xref:System.Windows.Controls.Button>syntaxe d’élément de propriété pour la propriété d’un .</span><span class="sxs-lookup"><span data-stu-id="d5d4f-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="d5d4f-225">La valeur dans un élément de propriété peut également être donnée comme texte intérieur, dans <xref:System.String>les cas où le type de propriété spécifié est un type de valeur primitive, tel que, ou un recensement où un nom est spécifié.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="d5d4f-226">Ces deux utilisations sont quelque peu rares, parce que chacun de ces cas pourrait également utiliser une syntaxe d’attribut plus simple.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="d5d4f-227">Un scénario pour remplir un élément de propriété avec une chaîne est pour les propriétés qui ne sont pas la propriété de contenu XAML, mais sont toujours utilisés pour la représentation du texte de l’interface utilisateur, et certains éléments de l’espace blanc tels que les filoires sont tenus d’apparaître dans ce texte d’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="d5d4f-228">La syntaxe d’attribut ne peut pas préserver les filoires, mais la syntaxe d’élément de propriété peut, tant que la conservation significative de l’espace blanc est active (pour plus de détails, voir [traitement de l’espace blanc dans XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="d5d4f-229">Un autre scénario est de sorte que [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) peut être appliquée à l’élément de propriété et ainsi marquer la valeur à l’intérieur comme une valeur qui devrait être localisée dans la sortie WPF BAML ou par d’autres techniques.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="d5d4f-230">Un élément de propriété n’est pas représenté dans l’arbre logique WPF.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="d5d4f-231">Un élément de propriété est juste une syntaxe particulière pour fixer une propriété, et n’est pas un élément qui a une instance ou un objet le soutenant.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="d5d4f-232">(Pour plus de détails sur le concept d’arbre logique, voir [Arbres dans WPF](trees-in-wpf.md).)</span><span class="sxs-lookup"><span data-stu-id="d5d4f-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="d5d4f-233">Pour les propriétés où la syntaxe d’attribut et d’élément de propriété sont soutenues, les deux syntaxes ont généralement le même résultat, bien que les subtilités telles que la manipulation de l’espace blanc puissent varier légèrement entre les syntaxes.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>
## <a name="collection-syntax"></a><span data-ttu-id="d5d4f-234">Syntaxe des collections</span><span class="sxs-lookup"><span data-stu-id="d5d4f-234">Collection Syntax</span></span>  
 <span data-ttu-id="d5d4f-235">La spécification XAML nécessite des implémentations de processeurS XAML pour identifier les propriétés où le type de valeur est une collection.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="d5d4f-236">La mise en œuvre générale du processeur XAML en .NET est basée sur le code géré et le CLR, et il identifie les types de collecte à travers l’un des éléments suivants:</span><span class="sxs-lookup"><span data-stu-id="d5d4f-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="d5d4f-237">Types d’outils <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="d5d4f-238">Types d’outils <xref:System.Collections.IDictionary>.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="d5d4f-239">Type dérive <xref:System.Array> de (pour plus d’informations sur les tableaux dans XAML, voir [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="d5d4f-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="d5d4f-240">Si le type de propriété est une collection, alors le type de collecte déduit n’a pas besoin d’être spécifié dans la majoration comme un élément d’objet.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="d5d4f-241">Au lieu de cela, les éléments qui sont destinés à devenir les éléments de la collection sont spécifiés comme un ou plusieurs éléments enfant de l’élément de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="d5d4f-242">Chaque élément de ce type est évalué à un objet `Add` pendant le chargement et ajouté à la collection en appelant la méthode de la collection implicite.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="d5d4f-243">Par exemple, <xref:System.Windows.Style.Triggers%2A> la <xref:System.Windows.Style> propriété de <xref:System.Windows.TriggerCollection>prend le <xref:System.Collections.IList>type de collecte spécialisée , qui met en œuvre .</span><span class="sxs-lookup"><span data-stu-id="d5d4f-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="d5d4f-244">Il n’est pas nécessaire <xref:System.Windows.TriggerCollection> d’instantanér un élément d’objet dans la balisage.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="d5d4f-245">Au lieu de cela, vous spécifiez un ou <xref:System.Windows.Trigger> plusieurs éléments comme éléments dans `Style.Triggers` l’élément de propriété, où <xref:System.Windows.Trigger> (ou une classe dérivée) est le type attendu comme le type d’élément pour le fortement tapé et implicite <xref:System.Windows.TriggerCollection>.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="d5d4f-246">Une propriété peut être à la fois un type de collection et la propriété de contenu XAML pour ce type et les types dérivés, qui est discuté dans la section suivante de ce sujet.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="d5d4f-247">Un élément de collecte implicite crée un membre dans la représentation logique des arbres, même s’il n’apparaît pas dans la majoration comme un élément.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="d5d4f-248">Habituellement, le constructeur du type parent effectue l’instantanéisation de la collection qui est l’une de ses propriétés, et la collection initialement vide devient une partie de l’arbre objet.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d5d4f-249">La liste générique et<xref:System.Collections.Generic.IList%601> les <xref:System.Collections.Generic.IDictionary%602>interfaces de dictionnaire ( et ) ne sont pas prises en charge pour la détection de la collecte.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="d5d4f-250">Cependant, vous pouvez <xref:System.Collections.Generic.List%601> utiliser la classe comme une <xref:System.Collections.IList> classe <xref:System.Collections.Generic.Dictionary%602> de base, parce qu’elle implémente directement, ou comme classe de base, parce qu’elle implémente <xref:System.Collections.IDictionary> directement.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="d5d4f-251">Dans les pages de référence .NET pour les types de collecte, cette syntaxe avec l’omission délibérée de l’élément objet pour une collection est parfois notée dans les sections syntaxe XAML comme Syntax de collection implicite.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="d5d4f-252">À l’exception de l’élément racine, chaque élément d’objet dans un fichier XAML qui est imbriqué comme un élément enfant d’un autre élément est vraiment un élément qui est l’un ou les deux cas suivants: un membre d’une propriété de collecte implicite de son élément parent, ou un élément qui spécifie la valeur de la propriété de contenu XAML pour l’élément parent (propriétés de contenu XAML sera discuté dans une section à venir).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="d5d4f-253">En d’autres termes, la relation entre les éléments parentaux et les éléments de l’enfant dans une page de balisage est en réalité un seul objet à la racine, et chaque élément d’objet sous la racine est soit une seule instance qui fournit une valeur de propriété du parent, soit l’un des éléments d’une collection qui est aussi une valeur de propriété de type collection du parent.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="d5d4f-254">Ce concept à racine unique est commun avec XML, et est souvent renforcé <xref:System.Windows.Markup.XamlReader.Load%2A>dans le comportement des API qui chargent XAML tels que .</span><span class="sxs-lookup"><span data-stu-id="d5d4f-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="d5d4f-255">L’exemple suivant est une syntaxe avec<xref:System.Windows.Media.GradientStopCollection>l’élément objet pour une collection ( ) spécifiée explicitement.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="d5d4f-256">Notez qu’il n’est pas toujours possible de déclarer explicitement la collection.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="d5d4f-257">Par exemple, tenter <xref:System.Windows.TriggerCollection> de déclarer <xref:System.Windows.Style.Triggers%2A> explicitement dans l’exemple précédemment montré échouerait.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="d5d4f-258">Déclarer explicitement la collection exige que la classe de collecte <xref:System.Windows.TriggerCollection> doit prendre en charge un constructeur sans paramètres, et n’a pas de constructeur sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>
## <a name="xaml-content-properties"></a><span data-ttu-id="d5d4f-259">Propriétés de contenu XAML</span><span class="sxs-lookup"><span data-stu-id="d5d4f-259">XAML Content Properties</span></span>  
 <span data-ttu-id="d5d4f-260">La syntaxe de contenu XAML est une syntaxe qui n’est activée que sur les classes qui spécifient le dans le <xref:System.Windows.Markup.ContentPropertyAttribute> cadre de leur déclaration de classe.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="d5d4f-261">Les <xref:System.Windows.Markup.ContentPropertyAttribute> références au nom de propriété qui est la propriété de contenu pour ce type d’élément (y compris les classes dérivées).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="d5d4f-262">Lorsqu’il est traité par un processeur XAML, tous les éléments pour enfants ou le texte intérieur qui se trouvent entre les balises d’ouverture et de fermeture de l’élément objet seront attribués pour être la valeur de la propriété de contenu XAML pour cet objet.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="d5d4f-263">Vous êtes autorisé à spécifier des éléments de propriété explicites pour la propriété de contenu, mais cette utilisation n’est généralement pas indiquée dans les sections syntaxes XAML dans la référence .NET.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="d5d4f-264">La technique explicite/verbeuse a une valeur occasionnelle pour la clarté de balisage ou comme une question de style de balisage, mais généralement l’intention d’une propriété de contenu est de rationaliser le balisage de sorte que les éléments qui sont intuitivement liés comme parent-enfant peuvent être imbriqués directement.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="d5d4f-265">Les étiquettes d’élément de propriété pour d’autres propriétés d’un élément ne sont pas assignées comme « contenu » par définition de langue XAML stricte ; ils sont traités précédemment dans l’ordonnance de traitement du parser XAML et ne sont pas considérés comme des « contenus ».</span><span class="sxs-lookup"><span data-stu-id="d5d4f-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="d5d4f-266">XAML Content Propriété Valeurs doivent être contigus</span><span class="sxs-lookup"><span data-stu-id="d5d4f-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="d5d4f-267">La valeur d’une propriété de contenu XAML doit être donnée soit entièrement avant ou entièrement après tout autre élément de propriété sur cet élément d’objet.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="d5d4f-268">Cela est vrai si la valeur d’une propriété de contenu XAML est spécifiée comme une chaîne, ou comme un ou plusieurs objets.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="d5d4f-269">Par exemple, la majoration suivante n’analyse pas :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="d5d4f-270">Ceci est illégal essentiellement parce que si cette syntaxe ont été rendues explicites en utilisant la syntaxe d’élément de propriété pour la propriété de contenu, alors la propriété de contenu serait réglée deux fois :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="d5d4f-271">Un exemple tout aussi illégal est celui où la propriété de contenu est une collection, et les éléments pour enfants sont entrecoupés d’éléments de propriété :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="d5d4f-272">Combinaison des propriétés de contenu et de la syntaxe des collections</span><span class="sxs-lookup"><span data-stu-id="d5d4f-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="d5d4f-273">Afin d’accepter plus d’un seul élément d’objet comme contenu, le type de propriété de contenu doit être spécifiquement un type de collection.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="d5d4f-274">Semblable à la syntaxe d’élément de propriété pour les types de collection, un processeur XAML doit identifier les types qui sont des types de collecte.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="d5d4f-275">Si un élément a une propriété de contenu XAML et le type de la propriété de contenu XAML est une collection, alors le type de collecte implicite n’a pas besoin d’être spécifié dans la balisage comme un élément d’objet et la propriété de contenu XAML n’a pas besoin d’être spécifié comme un élément de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="d5d4f-276">Par conséquent, le modèle de contenu apparent dans la balisage peut maintenant avoir plus d’un élément enfant attribué comme le contenu.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="d5d4f-277">Ce qui suit est <xref:System.Windows.Controls.Panel> la syntaxe de contenu pour une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="d5d4f-278">Toutes <xref:System.Windows.Controls.Panel> les classes dérivées établissent la <xref:System.Windows.Controls.Panel.Children%2A>propriété de contenu <xref:System.Windows.Controls.UIElementCollection>XAML à être , ce qui nécessite une valeur de type .</span><span class="sxs-lookup"><span data-stu-id="d5d4f-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="d5d4f-279">Notez que ni <xref:System.Windows.Controls.Panel.Children%2A> l’élément de <xref:System.Windows.Controls.UIElementCollection> propriété ni l’élément pour le n’est requis dans la majoration.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="d5d4f-280">Il s’agit d’une caractéristique de conception de XAML de sorte que les éléments contenus de façon récursive qui définissent un [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] sont plus intuitivement représentés comme un arbre d’éléments imbriqués avec des relations immédiates élément parent-enfant, sans intervenir étiquettes élément de propriété ou objets de collecte.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="d5d4f-281">En fait, <xref:System.Windows.Controls.UIElementCollection> ne peut pas être spécifié explicitement dans la balisage comme un élément d’objet, par conception.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="d5d4f-282">Parce que sa seule utilisation prévue <xref:System.Windows.Controls.UIElementCollection> est comme une collection implicite, n’expose pas un constructeur public sans paramètres et ne peut donc pas être instantanée comme un élément d’objet.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="d5d4f-283">Mélanger les éléments de propriété et les éléments d’objets dans un objet avec une propriété de contenu</span><span class="sxs-lookup"><span data-stu-id="d5d4f-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="d5d4f-284">La spécification XAML déclare qu’un processeur XAML peut appliquer les éléments d’objet qui sont utilisés pour remplir la propriété de contenu XAML dans un élément d’objet doit être contigu, et ne doit pas être mélangé.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="d5d4f-285">Cette restriction contre le mélange des éléments [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] de propriété et du contenu est appliquée par les processeurs XAML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="d5d4f-286">Vous pouvez avoir un élément d’objet enfant comme premier balisage immédiat dans un élément d’objet.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="d5d4f-287">Ensuite, vous pouvez introduire des éléments de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-287">Then you can introduce property elements.</span></span> <span data-ttu-id="d5d4f-288">Ou, vous pouvez spécifier un ou plusieurs éléments de propriété, puis le contenu, puis plus d’éléments de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="d5d4f-289">Mais une fois qu’un élément de propriété suit le contenu, vous ne pouvez pas introduire de contenu supplémentaire, vous ne pouvez ajouter que des éléments de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="d5d4f-290">Cette exigence d’ordre d’élément de contenu/propriété ne s’applique pas au texte interne utilisé comme contenu.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="d5d4f-291">Cependant, il est toujours un bon style de balisage pour garder le texte intérieur contigu, parce que l’espace blanc significatif sera difficile à détecter visuellement dans le balisage si les éléments de propriété sont entrecoupés de texte intérieur.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>
## <a name="xaml-namespaces"></a><span data-ttu-id="d5d4f-292">Espaces de noms XAML</span><span class="sxs-lookup"><span data-stu-id="d5d4f-292">XAML Namespaces</span></span>  
 <span data-ttu-id="d5d4f-293">Aucun des exemples syntaxes précédents n’a spécifié un espace de nom XAML autre que l’espace nom XAML par défaut.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="d5d4f-294">Dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] les applications typiques, l’espace nom [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML par défaut est spécifié pour être l’espace de nom.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="d5d4f-295">Vous pouvez spécifier des espaces de nom XAML autres que l’espace nom XAML par défaut et toujours utiliser une syntaxe similaire.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="d5d4f-296">Mais alors, n’importe où où une classe est nommée qui n’est pas accessible dans l’espace de nom XAML par défaut, ce nom de classe doit être précédé avec le préfixe de l’espace de nom XAML tel que cartographié à l’espace de nom CLR correspondant.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="d5d4f-297">Par exemple, `<custom:Example/>` est la syntaxe d’élément `Example` d’objet pour instantanéiser une instance de la classe, où l’espace de `custom` nom CLR contenant cette classe (et peut-être les informations d’assemblage externe qui contient des types de support) a été précédemment cartographié au préfixe.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="d5d4f-298">Pour plus d’informations sur les espaces de noms XAML, voir [XAML Namespaces et Namespace Mapping pour WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>
## <a name="markup-extensions"></a><span data-ttu-id="d5d4f-299">Extensions de balisage</span><span class="sxs-lookup"><span data-stu-id="d5d4f-299">Markup Extensions</span></span>  
 <span data-ttu-id="d5d4f-300">XAML définit une entité de programmation d’extension de balisage qui permet de s’échapper de la manipulation normale des valeurs d’attributs de chaîne ou des éléments d’objet par processeur XAML, et reporte le traitement à une classe de support.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="d5d4f-301">Le caractère qui identifie une extension de balisage à un processeur XAML lors de l’utilisation de la syntaxe d’attribut est l’accolade bouclée d’ouverture (EN), suivie par tout personnage autre qu’une accolade bouclée de fermeture ().</span><span class="sxs-lookup"><span data-stu-id="d5d4f-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="d5d4f-302">La première chaîne suivant l’accolade bouclée d’ouverture doit faire référence à la classe qui fournit le comportement d’extension particulier, où la référence peut omettre le sous-corde "Extension" si cette sous-corde fait partie du vrai nom de classe.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="d5d4f-303">Par la suite, un seul espace peut apparaître, puis chaque personnage qui réussit est utilisé comme entrée par la mise en œuvre de l’extension, jusqu’à ce que l’accolade bouclée de fermeture soit rencontrée.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="d5d4f-304">La mise en œuvre <xref:System.Windows.Markup.MarkupExtension> .NET XAML utilise la classe abstraite comme base pour toutes les extensions de balisage soutenues par [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ainsi que d’autres cadres ou technologies.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="d5d4f-305">Les extensions de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] balisage qui implémentent spécifiquement sont souvent destinées à fournir un moyen de référencer d’autres objets existants, ou de faire des références différées à des objets qui seront évalués au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="d5d4f-306">Par exemple, une simple liaison de données `{Binding}` WPF est réalisée en spécifiant l’extension de balisage au lieu de la valeur qu’une propriété particulière prendrait habituellement.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="d5d4f-307">Bon nombre des extensions de balisage WPF permettent une syntaxe d’attribut pour les propriétés où une syntaxe d’attribut ne serait pas autrement possible.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="d5d4f-308">Par exemple, <xref:System.Windows.Style> un objet est un type relativement complexe qui contient une série d’objets et de propriétés imbriqués.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="d5d4f-309">Les styles dans WPF sont généralement <xref:System.Windows.ResourceDictionary>définis comme une ressource dans un , puis référencé par l’une des deux extensions de balisage WPF qui demandent une ressource.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="d5d4f-310">L’extension de majoration reporte l’évaluation de la valeur de la <xref:System.Windows.FrameworkElement.Style%2A> propriété à <xref:System.Windows.Style>une recherche de ressources et permet de fournir la valeur de la propriété, en prenant le type, en syntaxe d’attribut comme dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="d5d4f-311">Ici, `StaticResource` identifie <xref:System.Windows.StaticResourceExtension> la classe fournissant la mise en œuvre de l’extension de balisage.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="d5d4f-312">La chaîne `MyStyle` suivante est utilisée comme entrée <xref:System.Windows.StaticResourceExtension> pour le constructeur non par défaut, où <xref:System.Windows.ResourceKey>le paramètre tel qu’il est pris à partir de la chaîne d’extension déclare la demande .</span><span class="sxs-lookup"><span data-stu-id="d5d4f-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="d5d4f-313">`MyStyle`devrait être la valeur [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) d’un <xref:System.Windows.Style> défini comme une ressource.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="d5d4f-314">[L’utilisation de l’extension de markup De StaticResource](staticresource-markup-extension.md) demande que la ressource soit utilisée pour fournir la valeur de propriété par la <xref:System.Windows.Style> logique statique de recherche de ressources au moment de la charge.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="d5d4f-315">Pour plus d’informations sur les extensions de balisage, consultez [Extensions de balisage et XAML WPF](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="d5d4f-316">Pour une référence des extensions de balisage et d’autres fonctionnalités de programmation XAML activées dans la implémentation générale .NET XAML, voir [XAML Namespace (x:) Caractéristiques linguistiques](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="d5d4f-317">Pour les extensions de balisage spécifiques au WPF, voir [extensions WPF XAML](wpf-xaml-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>
## <a name="attached-properties"></a><span data-ttu-id="d5d4f-318">Propriétés jointes</span><span class="sxs-lookup"><span data-stu-id="d5d4f-318">Attached Properties</span></span>  
 <span data-ttu-id="d5d4f-319">Les propriétés ci-jointes sont un concept de programmation introduit dans XAML où les propriétés peuvent être détenues et définies par un type particulier, mais définies comme attributs ou éléments de propriété sur n’importe quel élément.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="d5d4f-320">Le scénario principal pour lequel les propriétés ci-jointes sont destinées est de permettre aux éléments pour enfants d’une structure de balisage de signaler l’information à un élément parent sans exiger un modèle d’objet largement partagé sur tous les éléments.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="d5d4f-321">Inversement, les propriétés ci-jointes peuvent être utilisées par les éléments parentaux pour signaler l’information aux éléments de l’enfant.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="d5d4f-322">Pour plus d’informations sur le but des propriétés ci-jointes et comment créer vos propres propriétés ci-jointes, voir [Aperçu des propriétés ci-jointes](attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="d5d4f-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="d5d4f-323">Les propriétés attachées utilisent une syntaxe qui ressemble superficiellement à la syntaxe d’élément de propriété, en ce que vous spécifiez également un *typeName*. *propertyName* combination.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="d5d4f-324">Il existe deux différences majeures :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="d5d4f-325">Vous pouvez utiliser le *typeName*. *propriétéMène* combinaison même lors de la mise d’une propriété attachée par syntaxe attribut.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="d5d4f-326">Les propriétés jointes sont le seul cas où la qualification du nom de propriété est une exigence dans une syntaxe d’attribut.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="d5d4f-327">Vous pouvez également utiliser la syntaxe d’élément de propriété pour les propriétés attachées.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="d5d4f-328">Toutefois, pour la syntaxe typique de l’élément de propriété, le *typeName* que vous spécifiez est l’élément objet qui contient l’élément de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="d5d4f-329">Si vous faites référence à une propriété attachée, alors le *typeName* est la classe qui définit la propriété ci-jointe, et non l’élément objet contenant.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>
## <a name="attached-events"></a><span data-ttu-id="d5d4f-330">Événements attachés</span><span class="sxs-lookup"><span data-stu-id="d5d4f-330">Attached Events</span></span>  
 <span data-ttu-id="d5d4f-331">Les événements ci-joints sont un autre concept de programmation introduit dans XAML où les événements peuvent être définis par un type spécifique, mais les gestionnaires peuvent être attachés sur n’importe quel élément d’objet.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="d5d4f-332">Dans la mise en œuvre WOF, souvent le type qui définit un événement ci-joint est un type statique qui définit un service, et parfois ces événements ci-joints sont exposés par un alias événement acheminé dans les types qui exposent le service.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="d5d4f-333">Les gestionnaires pour les événements ci-joints sont spécifiés par syntaxe d’attribut.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="d5d4f-334">Comme avec les événements ci-joints, la syntaxe d’attribut est étendue pour les événements attachés pour permettre un *typeName*. *eventName* utilisation, où *typeName* `Add` est `Remove` la classe qui fournit et les accesseurs de gestionnaire d’événements pour l’infrastructure d’événement ci-joint, et *eventName* est le nom de l’événement.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="d5d4f-335">Anatomie d’un élément racine XAML</span><span class="sxs-lookup"><span data-stu-id="d5d4f-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="d5d4f-336">Le tableau suivant montre un élément de racine XAML typique décomposé, montrant les attributs spécifiques d’un élément racine:</span><span class="sxs-lookup"><span data-stu-id="d5d4f-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="d5d4f-337">Élément d’objet d’ouverture de l’élément racine</span><span class="sxs-lookup"><span data-stu-id="d5d4f-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="d5d4f-338">La par[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]défaut ( ) XAML namespace</span><span class="sxs-lookup"><span data-stu-id="d5d4f-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="d5d4f-339">L’espace de nom XAML en langue XAML</span><span class="sxs-lookup"><span data-stu-id="d5d4f-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="d5d4f-340">La déclaration de classe partielle qui relie la majoration à tout code-derrière défini pour la classe partielle</span><span class="sxs-lookup"><span data-stu-id="d5d4f-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="d5d4f-341">Fin de l’élément objet pour la racine.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-341">End of object element for the root.</span></span> <span data-ttu-id="d5d4f-342">L’objet n’est pas encore fermé parce que l’élément contient des éléments pour enfants</span><span class="sxs-lookup"><span data-stu-id="d5d4f-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="d5d4f-343">Utilisations XAML facultatives et non modifiées</span><span class="sxs-lookup"><span data-stu-id="d5d4f-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="d5d4f-344">Les sections suivantes décrivent les utilisations XAML qui sont techniquement prises en charge par les processeurs XAML, mais qui produisent la verbosité ou d’autres problèmes esthétiques qui interfèrent avec les fichiers XAML restant lisibles par l’homme lorsque vous développez des applications qui contiennent des sources XAML.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="d5d4f-345">Utilisations facultatives d’élément de propriété</span><span class="sxs-lookup"><span data-stu-id="d5d4f-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="d5d4f-346">Les utilisations facultatives d’élément de propriété incluent l’écriture explicite des propriétés de contenu d’élément que le processeur XAML considère implicite.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="d5d4f-347"><xref:System.Windows.Controls.Menu>Par exemple, lorsque vous déclarez le contenu d’un , vous pouvez choisir de déclarer explicitement la <xref:System.Windows.Controls.ItemsControl.Items%2A> collection de l’étiquette <xref:System.Windows.Controls.Menu> d’élément <xref:System.Windows.Controls.Menu> <xref:System.Windows.Controls.MenuItem> <xref:System.Windows.Controls.ItemsControl.Items%2A> `<Menu.Items>` de propriété, et de placer chacun <xref:System.Windows.Controls.MenuItem> à l’intérieur, `<Menu.Items>`plutôt que d’utiliser le comportement implicite processeur XAML que tous les éléments de l’enfant d’un doit être un et sont placés dans la collection.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="d5d4f-348">Parfois, les utilisations facultatives peuvent aider à clarifier visuellement la structure de l’objet tel que représenté dans la balisage.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="d5d4f-349">Ou parfois une utilisation explicite d’élément de propriété peut éviter la marge qui est techniquement fonctionnelle mais visuellement déroutante, telle que les extensions de balisage imbriquées dans une valeur d’attribut.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="d5d4f-350">Type completName.memberName Qualified Attributes</span><span class="sxs-lookup"><span data-stu-id="d5d4f-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="d5d4f-351">Le *typeName*. *formulaire de nom* de membre pour un attribut fonctionne réellement plus universellement que juste le cas d’événement acheminé.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="d5d4f-352">Mais dans d’autres situations, cette forme est superflue et vous devriez l’éviter, ne serait-ce que pour des raisons de style de balisage et de lisibilité.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="d5d4f-353">Dans l’exemple suivant, chacune <xref:System.Windows.Controls.Control.Background%2A> des trois références à l’attribut est tout à fait équivalente :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="d5d4f-354">`Button.Background`fonctionne parce que la recherche <xref:System.Windows.Controls.Button> qualifiée pour<xref:System.Windows.Controls.Control.Background%2A> cette propriété sur <xref:System.Windows.Controls.Button> est réussie (a été héritée de contrôle) et est la classe de l’élément objet ou une classe de base.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="d5d4f-355">`Control.Background`fonctionne parce <xref:System.Windows.Controls.Control> que la <xref:System.Windows.Controls.Control.Background%2A> <xref:System.Windows.Controls.Control> classe <xref:System.Windows.Controls.Button> définit réellement et est une classe de base.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="d5d4f-356">Cependant, le *type suivantName*. *l’exemple* de formulaire de nom de membre ne fonctionne pas et est ainsi montré commenté :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="d5d4f-357"><xref:System.Windows.Controls.Label>est une autre <xref:System.Windows.Controls.Control>classe dérivée `Label.Background` de <xref:System.Windows.Controls.Label> , et si vous aviez spécifié dans un élément objet, cette utilisation aurait fonctionné.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="d5d4f-358">Cependant, <xref:System.Windows.Controls.Label> parce que n’est <xref:System.Windows.Controls.Button>pas la classe ou la classe `Label.Background` de base de , le comportement spécifié processeur XAML est de traiter alors comme une propriété attachée.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="d5d4f-359">`Label.Background`n’est pas une propriété attachée disponible, et cette utilisation échoue.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="d5d4f-360">baseTypeName.memberName Property Elements</span><span class="sxs-lookup"><span data-stu-id="d5d4f-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="d5d4f-361">D’une manière analogue à la façon dont le *typeName*. *formulaire de nom* de membre fonctionne pour la syntaxe d’attribut, une *baseTypeName*. *syntaxe membreName* fonctionne pour la syntaxe d’élément de propriété.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="d5d4f-362">Par exemple, la syntaxe suivante fonctionne :</span><span class="sxs-lookup"><span data-stu-id="d5d4f-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="d5d4f-363">En l’espèce, l’élément propriété a été donné, même `Control.Background` si l’élément de propriété était contenu dans `Button`.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="d5d4f-364">Mais tout comme *typeName*. *formulaire de nom de membre* pour les attributs, *baseTypeName*. *memberName* est mauvais style dans la balisage, et vous devriez l’éviter.</span><span class="sxs-lookup"><span data-stu-id="d5d4f-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d5d4f-365">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="d5d4f-365">See also</span></span>

- [<span data-ttu-id="d5d4f-366">Vue d’ensemble du langage XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="d5d4f-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="d5d4f-367">Espace de noms XAML (x:) Fonctionnalités de langage</span><span class="sxs-lookup"><span data-stu-id="d5d4f-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="d5d4f-368">Extensions XAML WPF</span><span class="sxs-lookup"><span data-stu-id="d5d4f-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="d5d4f-369">Vue d’ensemble des propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="d5d4f-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="d5d4f-370">TypeConverters et XAML</span><span class="sxs-lookup"><span data-stu-id="d5d4f-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="d5d4f-371">XAML et classes personnalisées pour WPF</span><span class="sxs-lookup"><span data-stu-id="d5d4f-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
