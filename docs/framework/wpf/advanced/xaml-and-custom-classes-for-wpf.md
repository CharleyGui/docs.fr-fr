---
title: XAML et classes personnalisées
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: 8dab7310826357d7fbe434002298032b8722e5b5
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/24/2020
ms.locfileid: "76744428"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="cb334-102">XAML et classes personnalisées pour WPF</span><span class="sxs-lookup"><span data-stu-id="cb334-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="cb334-103">XAML implémenté dans les infrastructures common language runtime (CLR) prend en charge la possibilité de définir une classe ou une structure personnalisée dans n’importe quel langage common language runtime (CLR), puis d’accéder à cette classe à l’aide du balisage XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-103">XAML as implemented in common language runtime (CLR) frameworks supports the ability to define a custom class or structure in any common language runtime (CLR) language, and then access that class using XAML markup.</span></span> <span data-ttu-id="cb334-104">Vous pouvez utiliser un mélange de types définis de [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] et de vos types personnalisés dans le même fichier de balisage, généralement en mappant les types personnalisés à un préfixe d’espace de noms XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="cb334-105">Cette rubrique décrit les conditions que doit satisfaire une classe personnalisée pour pouvoir être utilisée comme élément XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="cb334-106">Classes personnalisées dans les applications ou les assemblys</span><span class="sxs-lookup"><span data-stu-id="cb334-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="cb334-107">Les classes personnalisées qui sont utilisés dans XAML peuvent être définies de deux façons distinctes : dans le code-behind ou dans un autre code produisant l’application [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] principale, ou comme une classe dans un assembly distinct, comme un fichier exécutable ou une DLL utilisée comme bibliothèque de classes.</span><span class="sxs-lookup"><span data-stu-id="cb334-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="cb334-108">Chacune de ces approches a des avantages et des inconvénients spécifiques.</span><span class="sxs-lookup"><span data-stu-id="cb334-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="cb334-109">L’avantage de créer une bibliothèque de classes est que ces classes personnalisées peuvent être partagées entre de nombreuses applications différentes.</span><span class="sxs-lookup"><span data-stu-id="cb334-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="cb334-110">Une bibliothèque distincte facilite également le contrôle des problèmes de gestion des versions des applications et simplifie la création d’une classe là où l’utilisation prévue de la classe est d’être un élément racine dans une page XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="cb334-111">L’avantage de définir les classes personnalisées dans l’application est que cette technique est relativement légère et réduit les problèmes de déploiement et de test rencontrés quand vous introduisez des assemblys distincts au-delà de l’exécutable principal de l’application.</span><span class="sxs-lookup"><span data-stu-id="cb334-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="cb334-112">Qu’elles soient définies dans le même assembly ou dans un autre, les classes personnalisées doivent être mappées entre l’espace de noms CLR et l’espace de noms XML pour pouvoir être utilisées dans XAML en tant qu’éléments.</span><span class="sxs-lookup"><span data-stu-id="cb334-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="cb334-113">Consultez [Espaces de noms XAML et mappage d’espace de noms pour XAML WPF](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="cb334-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="cb334-114">Spécifications pour une classe personnalisée comme élément XAML</span><span class="sxs-lookup"><span data-stu-id="cb334-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="cb334-115">Pour pouvoir être instanciée comme élément objet, votre classe doit répondre aux spécifications suivantes :</span><span class="sxs-lookup"><span data-stu-id="cb334-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="cb334-116">Votre classe personnalisée doit être publique et prendre en charge un constructeur public (sans paramètre).</span><span class="sxs-lookup"><span data-stu-id="cb334-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="cb334-117">(Consultez la section suivante pour des remarques concernant les structures.)</span><span class="sxs-lookup"><span data-stu-id="cb334-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="cb334-118">Votre classe personnalisée ne doit pas être une classe imbriquée.</span><span class="sxs-lookup"><span data-stu-id="cb334-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="cb334-119">Les classes imbriquées et le « point » dans leur syntaxe générale d’utilisation du CLR interfèrent avec d’autres fonctionnalités [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] et/ou XAML, comme les propriétés attachées.</span><span class="sxs-lookup"><span data-stu-id="cb334-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="cb334-120">En plus de permettre une syntaxe d’élément objet, votre définition d’objet permet également la syntaxe des éléments de propriété pour les autres propriétés publiques qui prennent cet objet comme type de valeur.</span><span class="sxs-lookup"><span data-stu-id="cb334-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="cb334-121">La raison en est que l’objet peut maintenant être instancié comme un élément objet et qu’il peut remplir la valeur de l’élément propriété d’une telle propriété.</span><span class="sxs-lookup"><span data-stu-id="cb334-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="cb334-122">Structures</span><span class="sxs-lookup"><span data-stu-id="cb334-122">Structures</span></span>  
 <span data-ttu-id="cb334-123">Les structures que vous définissez en tant que types personnalisés peuvent toujours être construites en XAML dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Cela est dû au fait que les compilateurs CLR créent implicitement un constructeur sans paramètre pour une structure qui initialise toutes les valeurs de propriété à leurs valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="cb334-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the CLR compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="cb334-124">Dans certains cas, le comportement de construction et/ou l’utilisation de l’élément objet par défaut pour une structure ne sont pas souhaitables.</span><span class="sxs-lookup"><span data-stu-id="cb334-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="cb334-125">La raison peut en être que la structure est destinée à remplir des valeurs et à fonctionner conceptuellement comme une union, où les valeurs contenues peuvent avoir des interprétations mutuellement exclusives, aucune de ses propriétés ne pouvant donc être définie.</span><span class="sxs-lookup"><span data-stu-id="cb334-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="cb334-126">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] exemple d’une telle structure est <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="cb334-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="cb334-127">En règle générale, ces structures doivent implémenter un convertisseur de type, de sorte que les valeurs peuvent être exprimées sous forme d’attribut, en utilisant des conventions de chaîne qui créent les différents modes ou interprétations des valeurs de la structure.</span><span class="sxs-lookup"><span data-stu-id="cb334-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="cb334-128">La structure doit également exposer un comportement similaire pour la construction de code via un constructeur sans paramètre.</span><span class="sxs-lookup"><span data-stu-id="cb334-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="cb334-129">Spécifications pour les propriétés d’une classe personnalisée en tant qu’attributs XAML</span><span class="sxs-lookup"><span data-stu-id="cb334-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="cb334-130">Les propriétés doivent référencer un type par valeur (tel qu’une primitive) ou utiliser une classe pour le type qui a un constructeur sans paramètre ou un convertisseur de type dédié auquel un processeur XAML peut accéder.</span><span class="sxs-lookup"><span data-stu-id="cb334-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="cb334-131">Dans l’implémentation XAML CLR, les processeurs XAML trouvent ces convertisseurs via la prise en charge native des primitives de langage, ou via l’application de <xref:System.ComponentModel.TypeConverterAttribute> à un type ou un membre dans des définitions de type de stockage.</span><span class="sxs-lookup"><span data-stu-id="cb334-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="cb334-132">La propriété peut aussi référencer un type d’une classe abstraite ou une interface.</span><span class="sxs-lookup"><span data-stu-id="cb334-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="cb334-133">Pour les classes abstraites ou les interfaces, l’analyse XAML nécessite que la valeur de propriété soit remplie avec des instances de classe pratiques qui implémentent l’interface, ou avec des instances des types qui dérivent de la classe abstraite.</span><span class="sxs-lookup"><span data-stu-id="cb334-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="cb334-134">Les propriétés peuvent être déclarées sur une classe abstraite, mais ne peuvent être définies sur des classes pratiques qui dérivent de la classe abstraite.</span><span class="sxs-lookup"><span data-stu-id="cb334-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="cb334-135">Cela est dû au fait que la création de l’élément objet pour la classe requiert un constructeur sans paramètre public sur la classe.</span><span class="sxs-lookup"><span data-stu-id="cb334-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="cb334-136">Syntaxe d’attribut activée par TypeConverter</span><span class="sxs-lookup"><span data-stu-id="cb334-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="cb334-137">Si vous fournissez un convertisseur de type attribué dédié au niveau de la classe, la conversion de type appliquée permet la syntaxe d’attribut pour les propriétés qui doivent instancier ce type.</span><span class="sxs-lookup"><span data-stu-id="cb334-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="cb334-138">Un convertisseur de type n’active pas l’utilisation d’élément objet du type ; seule la présence d’un constructeur sans paramètre pour ce type active l’utilisation de l’élément objet.</span><span class="sxs-lookup"><span data-stu-id="cb334-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="cb334-139">Par conséquent, les propriétés qui sont activées par un convertisseur de type ne sont généralement pas utilisables dans la syntaxe de propriété, sauf si le type lui-même prend également en charge la syntaxe d’élément objet.</span><span class="sxs-lookup"><span data-stu-id="cb334-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="cb334-140">L’exception à cela est que vous pouvez spécifier une syntaxe des éléments de propriété, mais que l’élément de propriété doit alors contenir une chaîne.</span><span class="sxs-lookup"><span data-stu-id="cb334-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="cb334-141">Cette utilisation est essentiellement équivalente à l’utilisation d’une syntaxe d’attribut, et ce type d’utilisation n’est pas courant à moins qu’il soit nécessaire de gérer un espace blanc plus robuste de la valeur de l’attribut.</span><span class="sxs-lookup"><span data-stu-id="cb334-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="cb334-142">Par exemple, voici une utilisation d’élément de propriété qui prend une chaîne et l’utilisation d’attribut équivalente :</span><span class="sxs-lookup"><span data-stu-id="cb334-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="cb334-143">Les exemples de propriétés dans lesquelles la syntaxe d’attribut est autorisée, mais la syntaxe d’élément de propriété qui contient un élément objet n’est pas autorisée via XAML, sont différentes propriétés qui prennent le type <xref:System.Windows.Input.Cursor>.</span><span class="sxs-lookup"><span data-stu-id="cb334-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="cb334-144">La classe <xref:System.Windows.Input.Cursor> possède un convertisseur de type dédié <xref:System.Windows.Input.CursorConverter>, mais n’expose pas de constructeur sans paramètre, de sorte que la propriété <xref:System.Windows.FrameworkElement.Cursor%2A> ne peut être définie qu’à l’aide de la syntaxe d’attribut, même si le type de <xref:System.Windows.Input.Cursor> réel est un type référence.</span><span class="sxs-lookup"><span data-stu-id="cb334-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="cb334-145">Convertisseurs de type par propriété</span><span class="sxs-lookup"><span data-stu-id="cb334-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="cb334-146">Une autre possibilité est que la propriété proprement dite puisse déclarer un convertisseur de type au niveau de la propriété.</span><span class="sxs-lookup"><span data-stu-id="cb334-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="cb334-147">Cela active un « mini langage » qui instancie les objets du type de la propriété inline, en traitant les valeurs de chaîne entrantes de l’attribut comme entrée pour une opération de <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> en fonction du type approprié.</span><span class="sxs-lookup"><span data-stu-id="cb334-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="cb334-148">En général, ceci vise à fournir un accesseur pratique, et non pas à être le seul moyen de permettre la définition d’une propriété dans XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="cb334-149">Toutefois, il est également possible d’utiliser des convertisseurs de type pour les attributs où vous souhaitez utiliser des types CLR existants qui ne fournissent pas de constructeur sans paramètre ou de convertisseur de type attribué.</span><span class="sxs-lookup"><span data-stu-id="cb334-149">However, it is also possible to use type converters for attributes where you want to use existing CLR types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="cb334-150">Les exemples de l’API [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sont certaines propriétés qui prennent le type <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="cb334-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="cb334-151">Dans ce cas, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] utilisé le type de <xref:System.Globalization.CultureInfo> de Microsoft .NET Framework existant pour mieux résoudre les scénarios de compatibilité et de migration utilisés dans les versions antérieures des frameworks, mais le type de <xref:System.Globalization.CultureInfo> ne prenait pas en charge les constructeurs nécessaires ou la conversion de type au niveau du type pour être utilisables directement en tant que valeur de propriété XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="cb334-152">Quand vous exposez une propriété qui a une utilisation XAML, en particulier si vous êtes un créateur de contrôles, vous devez absolument envisager de stocker cette propriété avec une propriété de dépendance.</span><span class="sxs-lookup"><span data-stu-id="cb334-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="cb334-153">Cela est particulièrement vrai si vous utilisez l’implémentation [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] existante du processeur XAML, car vous pouvez améliorer les performances à l’aide de la sauvegarde de <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="cb334-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="cb334-154">Une propriété de dépendance exposera des fonctionnalités du système de propriétés pour votre propriété, que les utilisateurs viendront à attendre pour une propriété accessible de XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="cb334-155">Ceci inclut des fonctionnalités comme l’animation, la liaison de données et la prise en charge des styles.</span><span class="sxs-lookup"><span data-stu-id="cb334-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="cb334-156">Pour plus d’informations, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md) et [Propriétés de dépendance et chargement XAML](xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="cb334-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="cb334-157">Écriture et attribution d’un convertisseur de type</span><span class="sxs-lookup"><span data-stu-id="cb334-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="cb334-158">Vous devrez parfois écrire une classe dérivée <xref:System.ComponentModel.TypeConverter> personnalisée pour fournir la conversion de type pour votre type de propriété.</span><span class="sxs-lookup"><span data-stu-id="cb334-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="cb334-159">Pour obtenir des instructions sur la façon de dériver de et de créer un convertisseur de type qui peut prendre en charge les utilisations XAML, et comment appliquer le <xref:System.ComponentModel.TypeConverterAttribute>, consultez [TypeConverters et XAML](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="cb334-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="cb334-160">Spécifications pour la syntaxe d’attribut de gestionnaire d’événements XAML sur les événements d’une classe personnalisée</span><span class="sxs-lookup"><span data-stu-id="cb334-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="cb334-161">Pour être utilisable comme un événement CLR, l’événement doit être exposé comme un événement public sur une classe qui prend en charge un constructeur sans paramètre, ou sur une classe abstraite où l’événement est accessible sur les classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="cb334-161">To be usable as a CLR event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="cb334-162">Pour pouvoir être utilisé de manière pratique comme un événement routé, votre événement CLR doit implémenter des méthodes explicites de `add` et de `remove`, qui ajoutent et suppriment des gestionnaires pour la signature d’événement CLR et transfèrent ces gestionnaires aux méthodes <xref:System.Windows.UIElement.AddHandler%2A> et <xref:System.Windows.UIElement.RemoveHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="cb334-162">In order to be used conveniently as a routed event, your CLR event should implement explicit `add` and `remove` methods, which add and remove handlers for the CLR event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="cb334-163">Ces méthodes ajoutent ou suppriment les gestionnaires dans le magasin de gestionnaires d’événements routés sur l’instance à laquelle l’événement est attaché.</span><span class="sxs-lookup"><span data-stu-id="cb334-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="cb334-164">Il est possible d’inscrire directement des gestionnaires pour les événements routés à l’aide d' <xref:System.Windows.UIElement.AddHandler%2A>, et de ne pas définir délibérément un événement CLR qui expose l’événement routé.</span><span class="sxs-lookup"><span data-stu-id="cb334-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a CLR event that exposes the routed event.</span></span> <span data-ttu-id="cb334-165">Ceci est généralement non recommandé, car l’événement n’activera pas la syntaxe d’attribut XAML pour attacher des gestionnaires, et votre classe résultante offrira une vue XAML moins transparente des fonctionnalités de ce type.</span><span class="sxs-lookup"><span data-stu-id="cb334-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="cb334-166">Écriture de propriétés de collection</span><span class="sxs-lookup"><span data-stu-id="cb334-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="cb334-167">Les propriétés qui prennent un type collection ont une syntaxe XAML qui vous permet de spécifier les objets qui sont ajoutés à la collection.</span><span class="sxs-lookup"><span data-stu-id="cb334-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="cb334-168">Cette syntaxe a deux fonctions importantes.</span><span class="sxs-lookup"><span data-stu-id="cb334-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="cb334-169">L’objet qui est l’objet collection n’a pas besoin d’être spécifié dans la syntaxe d’élément objet.</span><span class="sxs-lookup"><span data-stu-id="cb334-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="cb334-170">La présence de ce type de collection est implicite quand vous spécifiez une propriété dans XAML qui prend un type collection.</span><span class="sxs-lookup"><span data-stu-id="cb334-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="cb334-171">Les éléments enfants de la propriété de collection dans le balisage sont traités pour devenir membres de la collection.</span><span class="sxs-lookup"><span data-stu-id="cb334-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="cb334-172">Normalement, l’accès du code aux membres d’une collection est effectué via des méthodes de liste/dictionnaire,comme `Add`, ou via un indexeur.</span><span class="sxs-lookup"><span data-stu-id="cb334-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="cb334-173">La syntaxe XAML ne prend cependant pas en charge les méthodes ou les indexeurs (exception : XAML 2009 peut prendre en charge des méthodes, mais l’utilisation de XAML 2009 restreint les utilisations possibles de WPF ; consultez [Fonctionnalités du langage XAML 2009](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md)).</span><span class="sxs-lookup"><span data-stu-id="cb334-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="cb334-174">Les collections sont à l’évidence une spécification très courante pour générer une arborescence d’éléments, et vous devez disposer d’un moyen de remplir ces collections dans du XAML déclaratif.</span><span class="sxs-lookup"><span data-stu-id="cb334-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="cb334-175">Par conséquent, les éléments enfants d’une propriété de collection sont traités en les ajoutant à la collection qui est la valeur du type de propriété de collection.</span><span class="sxs-lookup"><span data-stu-id="cb334-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="cb334-176">L’implémentation des services XAML .NET Framework, et donc le processeur XAML WPF, utilisent la définition suivante pour ce qui constitue une propriété de collection.</span><span class="sxs-lookup"><span data-stu-id="cb334-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="cb334-177">Le type de propriété de la propriété doit répondre à une des conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="cb334-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="cb334-178">Implémente <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="cb334-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="cb334-179">Implémente <xref:System.Collections.IDictionary> ou l’équivalent générique (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="cb334-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="cb334-180">Dérive de <xref:System.Array> (pour plus d’informations sur les tableaux en XAML, consultez [X :Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="cb334-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
- <span data-ttu-id="cb334-181">Implémente <xref:System.Windows.Markup.IAddChild> (une interface définie par [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="cb334-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="cb334-182">Chacun de ces types dans CLR a une méthode `Add`, qui est utilisée par le processeur XAML pour ajouter des éléments à la collection sous-jacente lors de la création du graphe d’objets.</span><span class="sxs-lookup"><span data-stu-id="cb334-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="cb334-183">Les interfaces `List` et `Dictionary` génériques (<xref:System.Collections.Generic.IList%601> et <xref:System.Collections.Generic.IDictionary%602>) ne sont pas prises en charge pour la détection de collection par le processeur [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="cb334-184">Toutefois, vous pouvez utiliser la classe <xref:System.Collections.Generic.List%601> comme classe de base, car elle implémente <xref:System.Collections.IList> directement, ou <xref:System.Collections.Generic.Dictionary%602> comme classe de base, car elle implémente <xref:System.Collections.IDictionary> directement.</span><span class="sxs-lookup"><span data-stu-id="cb334-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="cb334-185">Quand vous déclarez une propriété qui prend une collection, soyez attentif à la façon dont cette valeur de propriété est initialisée dans les nouvelles instances du type.</span><span class="sxs-lookup"><span data-stu-id="cb334-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="cb334-186">Si vous n’implémentez pas la propriété en tant que propriété de dépendance, il convient que la propriété utilise un champ de stockage qui appelle le constructeur du type collection.</span><span class="sxs-lookup"><span data-stu-id="cb334-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="cb334-187">Si votre propriété est une propriété de dépendance, vous devez initialiser la propriété de collection dans le cadre du constructeur de type par défaut.</span><span class="sxs-lookup"><span data-stu-id="cb334-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="cb334-188">La raison en est qu’une propriété de dépendance prend sa valeur par défaut à partir des métadonnées, et vous ne voulez généralement pas que la valeur initiale d’une propriété de collection soit une collection statique et partagée.</span><span class="sxs-lookup"><span data-stu-id="cb334-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="cb334-189">Il doit exister une instance de la collection pour chaque instance de type conteneur.</span><span class="sxs-lookup"><span data-stu-id="cb334-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="cb334-190">Pour plus d’informations, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="cb334-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="cb334-191">Vous pouvez implémenter un type de collection personnalisé pour votre propriété de collection.</span><span class="sxs-lookup"><span data-stu-id="cb334-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="cb334-192">En raison du traitement implicite des propriétés de collection, le type de collection personnalisé n’a pas besoin de fournir un constructeur sans paramètre pour pouvoir être utilisé implicitement en XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="cb334-193">Toutefois, vous pouvez éventuellement fournir un constructeur sans paramètre pour le type de collection.</span><span class="sxs-lookup"><span data-stu-id="cb334-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="cb334-194">Cette pratique peut être utile.</span><span class="sxs-lookup"><span data-stu-id="cb334-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="cb334-195">À moins que vous ne fournissiez un constructeur sans paramètre, vous ne pouvez pas déclarer explicitement la collection en tant qu’élément objet.</span><span class="sxs-lookup"><span data-stu-id="cb334-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="cb334-196">Certains créateurs de balisage peuvent préférer voir la collection explicite comme une question de style de balisage.</span><span class="sxs-lookup"><span data-stu-id="cb334-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="cb334-197">En outre, un constructeur sans paramètre peut simplifier les spécifications d’initialisation lorsque vous créez des objets qui utilisent votre type de collection en tant que valeur de propriété.</span><span class="sxs-lookup"><span data-stu-id="cb334-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="cb334-198">Déclaration de propriétés de contenu XAML</span><span class="sxs-lookup"><span data-stu-id="cb334-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="cb334-199">Le langage XAML définit le concept de propriété de contenu [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="cb334-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="cb334-200">Chaque classe utilisable dans la syntaxe d’objet peut avoir une et une seule propriété de contenu XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="cb334-201">Pour déclarer une propriété comme étant la propriété de contenu XAML pour votre classe, appliquez la <xref:System.Windows.Markup.ContentPropertyAttribute> dans le cadre de la définition de classe.</span><span class="sxs-lookup"><span data-stu-id="cb334-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="cb334-202">Spécifiez le nom de la propriété de contenu XAML prévue en tant que <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> dans l’attribut.</span><span class="sxs-lookup"><span data-stu-id="cb334-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="cb334-203">La propriété est spécifiée sous la forme d’une chaîne par son nom, et non comme une construction de réflexion comme <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="cb334-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="cb334-204">Vous pouvez spécifier qu’une propriété de collection doit être la propriété de contenu XAML.</span><span class="sxs-lookup"><span data-stu-id="cb334-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="cb334-205">Ceci aboutit à une utilisation de cette propriété où l’élément objet peut avoir un ou plusieurs éléments enfants, sans éléments objet de collection intermédiaires ou de balises d’élément de propriété.</span><span class="sxs-lookup"><span data-stu-id="cb334-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="cb334-206">Ces éléments sont ensuite traités comme étant la valeur pour la propriété de contenu XAML et ajoutés à l’instance de collection de stockage.</span><span class="sxs-lookup"><span data-stu-id="cb334-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="cb334-207">Certaines propriétés de contenu XAML existantes utilisent le type de propriété `Object`.</span><span class="sxs-lookup"><span data-stu-id="cb334-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="cb334-208">Cela active une propriété de contenu XAML qui peut prendre des valeurs primitives telles qu’une <xref:System.String>, ainsi qu’une valeur d’objet de référence unique.</span><span class="sxs-lookup"><span data-stu-id="cb334-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="cb334-209">Si vous suivez ce modèle, votre type est responsable de la détermination du type, ainsi que de la gestion des types possibles.</span><span class="sxs-lookup"><span data-stu-id="cb334-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="cb334-210">La raison courante d’un type de contenu <xref:System.Object> est de prendre en charge à la fois un moyen simple d’ajouter du contenu d’objet sous forme de chaîne (qui reçoit un traitement de présentation par défaut), ou un moyen avancé d’ajouter du contenu d’objet qui spécifie une présentation non définie par défaut ou des données supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="cb334-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="cb334-211">Sérialisation du XAML</span><span class="sxs-lookup"><span data-stu-id="cb334-211">Serializing XAML</span></span>  
 <span data-ttu-id="cb334-212">Dans certains cas, par exemple si vous êtes créateur de contrôles, vous voulez aussi garantir qu’une représentation d’objet qui peut être instanciée en XAML peut également être sérialisée dans un balisage XAML équivalent.</span><span class="sxs-lookup"><span data-stu-id="cb334-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="cb334-213">Les spécifications de la sérialisation ne sont pas décrites dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="cb334-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="cb334-214">Consultez [Vue d’ensemble de la création de contrôles](../controls/control-authoring-overview.md) et [Sérialisation et arborescence d’éléments](element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="cb334-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cb334-215">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="cb334-215">See also</span></span>

- [<span data-ttu-id="cb334-216">Vue d’ensemble du langage XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="cb334-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="cb334-217">Propriétés de dépendance personnalisées</span><span class="sxs-lookup"><span data-stu-id="cb334-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="cb334-218">Vue d’ensemble de la création de contrôles</span><span class="sxs-lookup"><span data-stu-id="cb334-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="cb334-219">Vue d’ensemble des éléments de base</span><span class="sxs-lookup"><span data-stu-id="cb334-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="cb334-220">Propriétés de dépendance et chargement XAML</span><span class="sxs-lookup"><span data-stu-id="cb334-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
