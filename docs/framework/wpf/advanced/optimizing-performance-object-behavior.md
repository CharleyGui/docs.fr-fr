---
title: "Optimisation des performances : comportement d'objets"
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- user interface virtualization [WPF]
- dependency properties [WPF], performance
- event handlers [WPF]
- object performance considerations [WPF]
- Freezable objects [WPF], performance
ms.assetid: 73aa2f47-1d73-439a-be1f-78dc4ba2b5bd
ms.openlocfilehash: 67184db7fc1459e83ac7b1e6ff09ef56e43f0ca4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187074"
---
# <a name="optimizing-performance-object-behavior"></a><span data-ttu-id="b3d5f-102">Optimisation des performances : comportement d'objets</span><span class="sxs-lookup"><span data-stu-id="b3d5f-102">Optimizing Performance: Object Behavior</span></span>
<span data-ttu-id="b3d5f-103">Une bonne compréhension du comportement intrinsèque des objets [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] vous permet de choisir le bon compromis entre fonctionnalités et performances.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-103">Understanding the intrinsic behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] objects will help you make the right tradeoffs between functionality and performance.</span></span>  

<a name="Not_Removing_Event_Handlers"></a>
## <a name="not-removing-event-handlers-on-objects-may-keep-objects-alive"></a><span data-ttu-id="b3d5f-104">Le fait de ne pas supprimer les gestionnaires d’événements sur les objets permet de conserver les objets actifs</span><span class="sxs-lookup"><span data-stu-id="b3d5f-104">Not Removing Event Handlers on Objects may Keep Objects Alive</span></span>  
 <span data-ttu-id="b3d5f-105">Le délégué qu’un objet passe à son événement est une référence à cet objet.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-105">The delegate that an object passes to its event is effectively a reference to that object.</span></span> <span data-ttu-id="b3d5f-106">Par conséquent, les gestionnaires d’événements peuvent conserver les objets actifs plus longtemps que prévu.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-106">Therefore, event handlers can keep objects alive longer than expected.</span></span> <span data-ttu-id="b3d5f-107">Quand vous nettoyez un objet inscrit pour détecter l’événement d’un objet, il est essentiel de supprimer ce délégué avant de libérer l’objet.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-107">When performing clean up of an object that has registered to listen to an object's event, it is essential to remove that delegate before releasing the object.</span></span> <span data-ttu-id="b3d5f-108">La conservation d’objets actifs inutiles augmente l’utilisation de mémoire de l’application.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-108">Keeping unneeded objects alive increases the application's memory usage.</span></span> <span data-ttu-id="b3d5f-109">Cela est particulièrement vrai quand l’objet est la racine d’une arborescence logique ou d’une arborescence de visuels.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-109">This is especially true when the object is the root of a logical tree or a visual tree.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b3d5f-110">introduit un modèle de détecteur d’événements faibles qui peut être utile quand les relations de durée de vie d’objet entre la source et l’écouteur sont difficiles à suivre.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-110">introduces a weak event listener pattern for events that can be useful in situations where the object lifetime relationships between source and listener are difficult to keep track of.</span></span> <span data-ttu-id="b3d5f-111">Certains événements [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] existants utilisent ce modèle.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-111">Some existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] events use this pattern.</span></span> <span data-ttu-id="b3d5f-112">Si vous implémentez des objets avec des événements personnalisés, ce modèle peut vous être utile.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-112">If you are implementing objects with custom events, this pattern may be of use to you.</span></span> <span data-ttu-id="b3d5f-113">Pour plus d’informations, consultez [Modèles d’événement faible](weak-event-patterns.md).</span><span class="sxs-lookup"><span data-stu-id="b3d5f-113">For details, see [Weak Event Patterns](weak-event-patterns.md).</span></span>  
  
 <span data-ttu-id="b3d5f-114">Il existe plusieurs outils, comme le profileur CLR et la visionneuse de jeux de travail, qui peuvent fournir des informations sur l’utilisation de mémoire d’un processus spécifié.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-114">There are several tools, such as the CLR Profiler and the Working Set Viewer, that can provides information on the memory usage of a specified process.</span></span> <span data-ttu-id="b3d5f-115">Le profileur CLR inclut un nombre de vues très utiles du profil d’allocation, notamment un histogramme des types alloués, des graphiques d’allocation et d’appels, une chronologie montrant les opérations de garbage collection de diverses générations et l’état obtenu du tas managé après ces collections, ainsi qu’une arborescence des appels présentant les allocations par méthode et les chargements d’assembly.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-115">The CLR Profiler includes a number of very useful views of the allocation profile, including a histogram of allocated types, allocation and call graphs, a time line showing garbage collections of various generations and the resulting state of the managed heap after those collections, and a call tree showing per-method allocations and assembly loads.</span></span> <span data-ttu-id="b3d5f-116">Pour plus d’informations, consultez [Performances](https://docs.microsoft.com/previous-versions/aa497289(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="b3d5f-116">For more information, see [Performance](https://docs.microsoft.com/previous-versions/aa497289(v=msdn.10)).</span></span>  
  
<a name="DPs_and_Objects"></a>
## <a name="dependency-properties-and-objects"></a><span data-ttu-id="b3d5f-117">Propriétés de dépendance et objets</span><span class="sxs-lookup"><span data-stu-id="b3d5f-117">Dependency Properties and Objects</span></span>  
 <span data-ttu-id="b3d5f-118">En général, l’accès à <xref:System.Windows.DependencyObject> une propriété de dépendance d’a n’est pas plus lent que d’accéder à une propriété CLR.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-118">In general, accessing a dependency property of a <xref:System.Windows.DependencyObject> is not slower than accessing a CLR property.</span></span> <span data-ttu-id="b3d5f-119">Tandis qu’il y a une petite tête-d’œil de performance pour fixer une valeur de propriété, obtenir une valeur est aussi rapide que d’obtenir la valeur d’une propriété de CLR.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-119">While there is a small performance overhead for setting a property value, getting a value is as fast as getting the value from a CLR property.</span></span> <span data-ttu-id="b3d5f-120">La légère baisse des performances s’explique par le fait que les propriétés de dépendance prennent en charge des fonctionnalités robustes, comme la liaison de données, l’animation, l’héritage et les styles.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-120">Offsetting the small performance overhead is the fact that dependency properties support robust features, such as data binding, animation, inheritance, and styling.</span></span> <span data-ttu-id="b3d5f-121">Pour plus d’informations, consultez [Vue d’ensemble des propriétés de dépendance](dependency-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="b3d5f-121">For more information, see [Dependency Properties Overview](dependency-properties-overview.md).</span></span>  
  
### <a name="dependencyproperty-optimizations"></a><span data-ttu-id="b3d5f-122">Optimisations de DependencyProperty</span><span class="sxs-lookup"><span data-stu-id="b3d5f-122">DependencyProperty Optimizations</span></span>  
 <span data-ttu-id="b3d5f-123">Vous devez soigneusement définir les propriétés de dépendance dans votre application.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-123">You should define dependency properties in your application very carefully.</span></span> <span data-ttu-id="b3d5f-124">Si <xref:System.Windows.DependencyProperty> vos effets ne rendent que les options de métadonnées de type, plutôt que d’autres options de métadonnées telles que <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, vous devriez le marquer en tant que tel en l’emportent sur ses métadonnées.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-124">If your <xref:System.Windows.DependencyProperty> affects only render type metadata options, rather than other metadata options such as <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, you should mark it as such by overriding its metadata.</span></span> <span data-ttu-id="b3d5f-125">Pour plus d’informations sur la substitution ou l’obtention de métadonnées de propriété, consultez [Métadonnées de propriété de dépendance](dependency-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="b3d5f-125">For more information about overriding or obtaining property metadata, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>  
  
 <span data-ttu-id="b3d5f-126">Il peut être plus efficace d’avoir un gestionnaire de changement de propriété qui invalide manuellement les passes de mesure, d’organisation et d’affichage si tous les changements de propriété n’affectent pas réellement la mesure, l’organisation et l’affichage.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-126">It may be more efficient to have a property change handler invalidate the measure, arrange, and render passes manually if not all property changes actually affect measure, arrange, and render.</span></span> <span data-ttu-id="b3d5f-127">Par exemple, vous pouvez décider de réafficher un arrière-plan uniquement quand une valeur est supérieure à une limite définie.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-127">For instance, you might decide to re-render a background only when a value is greater than a set limit.</span></span> <span data-ttu-id="b3d5f-128">Dans ce cas, votre gestionnaire de changement de propriété invalide l’affichage uniquement quand la valeur dépasse la limite définie.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-128">In this case, your property change handler would only invalidate render when the value exceeds the set limit.</span></span>  
  
### <a name="making-a-dependencyproperty-inheritable-is-not-free"></a><span data-ttu-id="b3d5f-129">Rendre une propriété de dépendance héritable n’est pas gratuit</span><span class="sxs-lookup"><span data-stu-id="b3d5f-129">Making a DependencyProperty Inheritable is Not Free</span></span>  
 <span data-ttu-id="b3d5f-130">Par défaut, les propriétés de dépendance inscrites ne sont pas héritables.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-130">By default, registered dependency properties are non-inheritable.</span></span> <span data-ttu-id="b3d5f-131">Toutefois, vous pouvez explicitement rendre une propriété héritable.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-131">However, you can explicitly make any property inheritable.</span></span> <span data-ttu-id="b3d5f-132">Bien qu’il s’agisse d’une fonctionnalité utile, la conversion d’une propriété pour qu’elle soit héritable affecte les performances en augmentant la durée d’invalidation de la propriété.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-132">While this is a useful feature, converting a property to be inheritable impacts performance by increasing the length of time for property invalidation.</span></span>  
  
### <a name="use-registerclasshandler-carefully"></a><span data-ttu-id="b3d5f-133">Utiliser RegisterClassHandler avec précaution</span><span class="sxs-lookup"><span data-stu-id="b3d5f-133">Use RegisterClassHandler Carefully</span></span>  
 <span data-ttu-id="b3d5f-134">Bien <xref:System.Windows.EventManager.RegisterClassHandler%2A> que l’appel vous permet d’enregistrer votre état d’instance, il est important d’être conscient que le gestionnaire est appelé sur chaque cas, ce qui peut causer des problèmes de performance.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-134">While calling <xref:System.Windows.EventManager.RegisterClassHandler%2A> allows you to save your instance state, it is important to be aware that the handler is called on every instance, which can cause performance problems.</span></span> <span data-ttu-id="b3d5f-135">Utilisez <xref:System.Windows.EventManager.RegisterClassHandler%2A> uniquement lorsque votre application exige que vous enregistrez votre état d’instance.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-135">Only use <xref:System.Windows.EventManager.RegisterClassHandler%2A> when your application requires that you save your instance state.</span></span>  
  
### <a name="set-the-default-value-for-a-dependencyproperty-during-registration"></a><span data-ttu-id="b3d5f-136">Définir la valeur par défaut d’une propriété DependencyProperty pendant l’inscription</span><span class="sxs-lookup"><span data-stu-id="b3d5f-136">Set the Default Value for a DependencyProperty during Registration</span></span>  
 <span data-ttu-id="b3d5f-137">Lors de <xref:System.Windows.DependencyProperty> la création d’un qui nécessite une valeur par défaut, <xref:System.Windows.DependencyProperty.Register%2A> définissez <xref:System.Windows.DependencyProperty>la valeur à l’aide des métadonnées par défaut transmises comme un paramètre à la méthode de la .</span><span class="sxs-lookup"><span data-stu-id="b3d5f-137">When creating a <xref:System.Windows.DependencyProperty> that requires a default value, set the value using the default metadata passed as a parameter to the <xref:System.Windows.DependencyProperty.Register%2A> method of the <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="b3d5f-138">Utilisez cette technique au lieu de définir la valeur de propriété dans un constructeur ou sur chaque instance d’un élément.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-138">Use this technique rather than setting the property value in a constructor or on each instance of an element.</span></span>  
  
### <a name="set-the-propertymetadata-value-using-register"></a><span data-ttu-id="b3d5f-139">Définir la valeur PropertyMetadata à l’aide du Registre</span><span class="sxs-lookup"><span data-stu-id="b3d5f-139">Set the PropertyMetadata Value using Register</span></span>  
 <span data-ttu-id="b3d5f-140">Lors de <xref:System.Windows.DependencyProperty>la création d’un <xref:System.Windows.PropertyMetadata> , <xref:System.Windows.DependencyProperty.Register%2A> vous <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> avez la possibilité de définir l’utilisation ou les méthodes.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-140">When creating a <xref:System.Windows.DependencyProperty>, you have the option of setting the <xref:System.Windows.PropertyMetadata> using either the <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> methods.</span></span> <span data-ttu-id="b3d5f-141">Bien que votre objet pourrait avoir <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>un constructeur statique à appeler, ce n’est pas la solution optimale et aura un impact sur les performances.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-141">Although your object could have a static constructor to call <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, this is not the optimal solution and will impact performance.</span></span> <span data-ttu-id="b3d5f-142">Pour les meilleures <xref:System.Windows.PropertyMetadata> performances, définissez le pendant l’appel à <xref:System.Windows.DependencyProperty.Register%2A>.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-142">For best performance, set the <xref:System.Windows.PropertyMetadata> during the call to <xref:System.Windows.DependencyProperty.Register%2A>.</span></span>  
  
<a name="Freezable_Objects"></a>
## <a name="freezable-objects"></a><span data-ttu-id="b3d5f-143">Objets Freezable</span><span class="sxs-lookup"><span data-stu-id="b3d5f-143">Freezable Objects</span></span>  
 <span data-ttu-id="b3d5f-144">A <xref:System.Windows.Freezable> est un type spécial d’objet qui a deux états: non gelé et congelé.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-144">A <xref:System.Windows.Freezable> is a special type of object that has two states: unfrozen and frozen.</span></span> <span data-ttu-id="b3d5f-145">Le fait de figer les objets chaque fois que cela est possible améliore les performances de votre application et réduit son jeu de travail.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-145">Freezing objects whenever possible improves the performance of your application and reduces its working set.</span></span> <span data-ttu-id="b3d5f-146">Pour plus d’informations, consultez [Vue d’ensemble des objets Freezable](freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="b3d5f-146">For more information, see [Freezable Objects Overview](freezable-objects-overview.md).</span></span>  
  
 <span data-ttu-id="b3d5f-147">Chacun <xref:System.Windows.Freezable> a <xref:System.Windows.Freezable.Changed> un événement qui est soulevé chaque fois qu’il change.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-147">Each <xref:System.Windows.Freezable> has a <xref:System.Windows.Freezable.Changed> event that is raised whenever it changes.</span></span> <span data-ttu-id="b3d5f-148">Toutefois, les notifications de changement détériorent les performances de l’application.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-148">However, change notifications are costly in terms of application performance.</span></span>  
  
 <span data-ttu-id="b3d5f-149">Prenons l’exemple suivant <xref:System.Windows.Shapes.Rectangle> dans <xref:System.Windows.Media.Brush> lequel chacun utilise le même objet :</span><span class="sxs-lookup"><span data-stu-id="b3d5f-149">Consider the following example in which each <xref:System.Windows.Shapes.Rectangle> uses the same <xref:System.Windows.Media.Brush> object:</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet2)]
 [!code-vb[Performance#PerformanceSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet2)]  
  
 <span data-ttu-id="b3d5f-150">Par [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] défaut, fournit un <xref:System.Windows.Media.SolidColorBrush> gestionnaire d’événement pour l’événement de <xref:System.Windows.Freezable.Changed> l’objet afin d’invalider la propriété de <xref:System.Windows.Shapes.Rectangle> <xref:System.Windows.Shapes.Shape.Fill%2A> l’objet.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-150">By default, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provides an event handler for the <xref:System.Windows.Media.SolidColorBrush> object's <xref:System.Windows.Freezable.Changed> event in order to invalidate the <xref:System.Windows.Shapes.Rectangle> object's <xref:System.Windows.Shapes.Shape.Fill%2A> property.</span></span> <span data-ttu-id="b3d5f-151">Dans ce cas, <xref:System.Windows.Media.SolidColorBrush> chaque fois <xref:System.Windows.Freezable.Changed> que le doit congédier son <xref:System.Windows.Shapes.Rectangle>événement, il est nécessaire d’invoquer la fonction de rappel pour chacun — l’accumulation de ces invocations de fonction de rappel imposent une pénalité de rendement importante.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-151">In this case, each time the <xref:System.Windows.Media.SolidColorBrush> has to fire its <xref:System.Windows.Freezable.Changed> event it is required to invoke the callback function for each <xref:System.Windows.Shapes.Rectangle>—the accumulation of these callback function invocations impose a significant performance penalty.</span></span> <span data-ttu-id="b3d5f-152">Par ailleurs, l’ajout et la suppression des gestionnaires à ce stade consomment une grande part des performances, car cette opération oblige l’application à parcourir l’intégralité de la liste.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-152">In addition, it is very performance intensive to add and remove handlers at this point since the application would have to traverse the entire list to do so.</span></span> <span data-ttu-id="b3d5f-153">Si votre scénario de <xref:System.Windows.Media.SolidColorBrush>demande ne change jamais le <xref:System.Windows.Freezable.Changed> , vous paiera le coût de l’entretien des gestionnaires d’événements inutilement.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-153">If your application scenario never changes the <xref:System.Windows.Media.SolidColorBrush>, you will be paying the cost of maintaining <xref:System.Windows.Freezable.Changed> event handlers unnecessarily.</span></span>  
  
 <span data-ttu-id="b3d5f-154">Le <xref:System.Windows.Freezable> gel d’un peut améliorer ses performances, car il n’a plus besoin de dépenser des ressources sur le maintien des notifications de changement.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-154">Freezing a <xref:System.Windows.Freezable> can improve its performance, because it no longer needs to expend resources on maintaining change notifications.</span></span> <span data-ttu-id="b3d5f-155">Le tableau ci-dessous montre <xref:System.Windows.Media.SolidColorBrush> la <xref:System.Windows.Freezable.IsFrozen%2A> taille d’un simple lorsque sa propriété est définie à `true`, par rapport à quand il n’est pas.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-155">The table below shows the size of a simple <xref:System.Windows.Media.SolidColorBrush> when its <xref:System.Windows.Freezable.IsFrozen%2A> property is set to `true`, compared to when it is not.</span></span> <span data-ttu-id="b3d5f-156">Cela suppose l’application <xref:System.Windows.Shapes.Shape.Fill%2A> d’un <xref:System.Windows.Shapes.Rectangle> pinceau à la propriété de dix objets.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-156">This assumes applying one brush to the <xref:System.Windows.Shapes.Shape.Fill%2A> property of ten <xref:System.Windows.Shapes.Rectangle> objects.</span></span>  
  
|<span data-ttu-id="b3d5f-157">**État**</span><span class="sxs-lookup"><span data-stu-id="b3d5f-157">**State**</span></span>|<span data-ttu-id="b3d5f-158">**Taille**</span><span class="sxs-lookup"><span data-stu-id="b3d5f-158">**Size**</span></span>|  
|---------------|--------------|  
|<span data-ttu-id="b3d5f-159">La Reine des neiges<xref:System.Windows.Media.SolidColorBrush></span><span class="sxs-lookup"><span data-stu-id="b3d5f-159">Frozen <xref:System.Windows.Media.SolidColorBrush></span></span>|<span data-ttu-id="b3d5f-160">212 octets</span><span class="sxs-lookup"><span data-stu-id="b3d5f-160">212 Bytes</span></span>|  
|<span data-ttu-id="b3d5f-161">Non congelé<xref:System.Windows.Media.SolidColorBrush></span><span class="sxs-lookup"><span data-stu-id="b3d5f-161">Non-frozen <xref:System.Windows.Media.SolidColorBrush></span></span>|<span data-ttu-id="b3d5f-162">972 octets</span><span class="sxs-lookup"><span data-stu-id="b3d5f-162">972 Bytes</span></span>|  
  
 <span data-ttu-id="b3d5f-163">L'exemple de code suivant illustre ce concept :</span><span class="sxs-lookup"><span data-stu-id="b3d5f-163">The following code sample demonstrates this concept:</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet3)]
 [!code-vb[Performance#PerformanceSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet3)]  
  
### <a name="changed-handlers-on-unfrozen-freezables-may-keep-objects-alive"></a><span data-ttu-id="b3d5f-164">Les gestionnaires de changement sur des Freezables non figés peuvent conserver les objets actifs</span><span class="sxs-lookup"><span data-stu-id="b3d5f-164">Changed Handlers on Unfrozen Freezables may Keep Objects Alive</span></span>  
 <span data-ttu-id="b3d5f-165">Le délégué qu’un <xref:System.Windows.Freezable> objet passe <xref:System.Windows.Freezable.Changed> à l’événement d’un objet est en fait une référence à cet objet.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-165">The delegate that an object passes to a <xref:System.Windows.Freezable> object's <xref:System.Windows.Freezable.Changed> event is effectively a reference to that object.</span></span> <span data-ttu-id="b3d5f-166">Par <xref:System.Windows.Freezable.Changed> conséquent, les gestionnaires d’événements peuvent garder les objets en vie plus longtemps que prévu.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-166">Therefore, <xref:System.Windows.Freezable.Changed> event handlers can keep objects alive longer than expected.</span></span> <span data-ttu-id="b3d5f-167">Lors du nettoyage d’un objet qui <xref:System.Windows.Freezable> s’est <xref:System.Windows.Freezable.Changed> inscrit pour écouter l’événement d’un objet, il est essentiel de supprimer ce délégué avant de libérer l’objet.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-167">When performing clean up of an object that has registered to listen to a <xref:System.Windows.Freezable> object's <xref:System.Windows.Freezable.Changed> event, it is essential to remove that delegate before releasing the object.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="b3d5f-168">connecte également <xref:System.Windows.Freezable.Changed> les événements en interne.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-168">also hooks up <xref:System.Windows.Freezable.Changed> events internally.</span></span> <span data-ttu-id="b3d5f-169">Par exemple, toutes les <xref:System.Windows.Freezable> propriétés de <xref:System.Windows.Freezable.Changed> dépendance qui prennent comme valeur écouteront automatiquement les événements.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-169">For example, all dependency properties which take <xref:System.Windows.Freezable> as a value will listen to <xref:System.Windows.Freezable.Changed> events automatically.</span></span> <span data-ttu-id="b3d5f-170">La <xref:System.Windows.Shapes.Shape.Fill%2A> propriété, qui <xref:System.Windows.Media.Brush>prend un , illustre ce concept.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-170">The <xref:System.Windows.Shapes.Shape.Fill%2A> property, which takes a <xref:System.Windows.Media.Brush>, illustrates this concept.</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet4)]
 [!code-vb[Performance#PerformanceSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet4)]  
  
 <span data-ttu-id="b3d5f-171">Sur la `myBrush` cession `myRectangle.Fill`de , un <xref:System.Windows.Shapes.Rectangle> délégué pointant vers <xref:System.Windows.Media.SolidColorBrush> l’objet sera ajouté à l’événement de <xref:System.Windows.Freezable.Changed> l’objet.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-171">On the assignment of `myBrush` to `myRectangle.Fill`, a delegate pointing back to the <xref:System.Windows.Shapes.Rectangle> object will be added to the <xref:System.Windows.Media.SolidColorBrush> object's <xref:System.Windows.Freezable.Changed> event.</span></span> <span data-ttu-id="b3d5f-172">Cela signifie que le code suivant ne rend pas `myRect` éligible pour l’opération de garbage collection :</span><span class="sxs-lookup"><span data-stu-id="b3d5f-172">This means the following code does not actually make `myRect` eligible for garbage collection:</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet5)]
 [!code-vb[Performance#PerformanceSnippet5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet5)]  
  
 <span data-ttu-id="b3d5f-173">Dans ce `myBrush` cas, `myRectangle` est toujours en cours et <xref:System.Windows.Freezable.Changed> rappellera à elle quand il tire son événement.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-173">In this case `myBrush` is still keeping `myRectangle` alive and will call back to it when it fires its <xref:System.Windows.Freezable.Changed> event.</span></span> <span data-ttu-id="b3d5f-174">Notez que `myBrush` l’attribution à la <xref:System.Windows.Shapes.Shape.Fill%2A> propriété d’un nouveau <xref:System.Windows.Shapes.Rectangle> va simplement ajouter un autre gestionnaire d’événements à `myBrush`.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-174">Note that assigning `myBrush` to the <xref:System.Windows.Shapes.Shape.Fill%2A> property of a new <xref:System.Windows.Shapes.Rectangle> will simply add another event handler to `myBrush`.</span></span>  
  
 <span data-ttu-id="b3d5f-175">La façon recommandée de nettoyer ces types <xref:System.Windows.Media.Brush> d’objets est de retirer la <xref:System.Windows.Shapes.Shape.Fill%2A> propriété, ce qui enlèvera à son tour le gestionnaire d’événements. <xref:System.Windows.Freezable.Changed></span><span class="sxs-lookup"><span data-stu-id="b3d5f-175">The recommended way to clean up these types of objects is to remove the <xref:System.Windows.Media.Brush> from the <xref:System.Windows.Shapes.Shape.Fill%2A> property, which will in turn remove the <xref:System.Windows.Freezable.Changed> event handler.</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet6](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet6)]
 [!code-vb[Performance#PerformanceSnippet6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet6)]  
  
<a name="User_Interface_Virtualization"></a>
## <a name="user-interface-virtualization"></a><span data-ttu-id="b3d5f-176">Virtualisation de l'interface utilisateur</span><span class="sxs-lookup"><span data-stu-id="b3d5f-176">User Interface Virtualization</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="b3d5f-177">fournit également une <xref:System.Windows.Controls.StackPanel> variante de l’élément qui « virtualise » automatiquement le contenu de l’enfant lié aux données.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-177">also provides a variation of the <xref:System.Windows.Controls.StackPanel> element that automatically "virtualizes" data-bound child content.</span></span> <span data-ttu-id="b3d5f-178">Dans ce contexte, le mot virtualiser fait référence à une technique par laquelle une partie des objets est généré à partir d’un plus grand nombre d’éléments de données en fonction des éléments visibles à l’écran.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-178">In this context, the word virtualize refers to a technique by which a subset of objects are generated from a larger number of data items based upon which items are visible on-screen.</span></span> <span data-ttu-id="b3d5f-179">La génération d’un grand nombre d'éléments d'interface utilisateur, alors que seul un certain nombre de ces éléments peut figurer à l'écran à un moment donné, entraîne une utilisation intensive de la mémoire et du processeur.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-179">It is intensive, both in terms of memory and processor, to generate a large number of UI elements when only a few may be on the screen at a given time.</span></span> <span data-ttu-id="b3d5f-180"><xref:System.Windows.Controls.VirtualizingStackPanel>(grâce à la <xref:System.Windows.Controls.VirtualizingPanel>fonctionnalité fournie par ) <xref:System.Windows.Controls.ItemContainerGenerator> calcule <xref:System.Windows.Controls.ItemsControl> les <xref:System.Windows.Controls.ListBox> éléments <xref:System.Windows.Controls.ListView>visibles et fonctionne avec le d’un (tel ou ) pour créer seulement des éléments pour les éléments visibles.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-180"><xref:System.Windows.Controls.VirtualizingStackPanel> (through functionality provided by <xref:System.Windows.Controls.VirtualizingPanel>) calculates visible items and works with the <xref:System.Windows.Controls.ItemContainerGenerator> from an <xref:System.Windows.Controls.ItemsControl> (such as <xref:System.Windows.Controls.ListBox> or <xref:System.Windows.Controls.ListView>) to only create elements for visible items.</span></span>  
  
 <span data-ttu-id="b3d5f-181">Pour optimiser les performances, des objets visuels pour ces éléments sont générés ou maintenus actifs uniquement s’ils sont visibles à l’écran.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-181">As a performance optimization, visual objects for these items are only generated or kept alive if they are visible on the screen.</span></span> <span data-ttu-id="b3d5f-182">Quand ils ne sont plus dans la zone visible du contrôle, les objets visuels peuvent être supprimés.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-182">When they are no longer in the viewable area of the control, the visual objects may be removed.</span></span> <span data-ttu-id="b3d5f-183">Cette virtualisation ne doit pas être confondue avec la virtualisation des données, où les objets de données ne sont pas tous présents dans la collection locale, mais diffusés selon les besoins.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-183">This is not to be confused with data virtualization, where data objects are not all present in the local collection- rather streamed in as needed.</span></span>  
  
 <span data-ttu-id="b3d5f-184">Le tableau ci-dessous montre le temps écoulé ajoutant et <xref:System.Windows.Controls.TextBlock> rendant <xref:System.Windows.Controls.StackPanel> 5000 éléments à un et un <xref:System.Windows.Controls.VirtualizingStackPanel>.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-184">The table below shows the elapsed time adding and rendering 5000 <xref:System.Windows.Controls.TextBlock> elements to a <xref:System.Windows.Controls.StackPanel> and a <xref:System.Windows.Controls.VirtualizingStackPanel>.</span></span> <span data-ttu-id="b3d5f-185">Dans ce scénario, les mesures représentent le temps entre <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> l’attachement d’une chaîne de texte à la propriété d’un <xref:System.Windows.Controls.ItemsControl> objet à l’heure où les éléments du panneau affichent la chaîne de texte.</span><span class="sxs-lookup"><span data-stu-id="b3d5f-185">In this scenario, the measurements represent the time between attaching a text string to the <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> property of an <xref:System.Windows.Controls.ItemsControl> object to the time when the panel elements display the text string.</span></span>  
  
|<span data-ttu-id="b3d5f-186">**Panneau hôte**</span><span class="sxs-lookup"><span data-stu-id="b3d5f-186">**Host panel**</span></span>|<span data-ttu-id="b3d5f-187">**Temps d’affichage (ms)**</span><span class="sxs-lookup"><span data-stu-id="b3d5f-187">**Render time (ms)**</span></span>|  
|--------------------|----------------------------|  
|<xref:System.Windows.Controls.StackPanel>|<span data-ttu-id="b3d5f-188">3210</span><span class="sxs-lookup"><span data-stu-id="b3d5f-188">3210</span></span>|  
|<xref:System.Windows.Controls.VirtualizingStackPanel>|<span data-ttu-id="b3d5f-189">46</span><span class="sxs-lookup"><span data-stu-id="b3d5f-189">46</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="b3d5f-190">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="b3d5f-190">See also</span></span>

- [<span data-ttu-id="b3d5f-191">Optimisation des performances des applications WPF</span><span class="sxs-lookup"><span data-stu-id="b3d5f-191">Optimizing WPF Application Performance</span></span>](optimizing-wpf-application-performance.md)
- [<span data-ttu-id="b3d5f-192">Planification des performances des applications</span><span class="sxs-lookup"><span data-stu-id="b3d5f-192">Planning for Application Performance</span></span>](planning-for-application-performance.md)
- [<span data-ttu-id="b3d5f-193">Tirer parti du matériel</span><span class="sxs-lookup"><span data-stu-id="b3d5f-193">Taking Advantage of Hardware</span></span>](optimizing-performance-taking-advantage-of-hardware.md)
- [<span data-ttu-id="b3d5f-194">Disposition et conception</span><span class="sxs-lookup"><span data-stu-id="b3d5f-194">Layout and Design</span></span>](optimizing-performance-layout-and-design.md)
- [<span data-ttu-id="b3d5f-195">Graphisme 2D et acquisition d’images</span><span class="sxs-lookup"><span data-stu-id="b3d5f-195">2D Graphics and Imaging</span></span>](optimizing-performance-2d-graphics-and-imaging.md)
- [<span data-ttu-id="b3d5f-196">Ressources d’application</span><span class="sxs-lookup"><span data-stu-id="b3d5f-196">Application Resources</span></span>](optimizing-performance-application-resources.md)
- [<span data-ttu-id="b3d5f-197">Texte</span><span class="sxs-lookup"><span data-stu-id="b3d5f-197">Text</span></span>](optimizing-performance-text.md)
- [<span data-ttu-id="b3d5f-198">Liaison de données</span><span class="sxs-lookup"><span data-stu-id="b3d5f-198">Data Binding</span></span>](optimizing-performance-data-binding.md)
- [<span data-ttu-id="b3d5f-199">Autres recommandations relatives aux performances</span><span class="sxs-lookup"><span data-stu-id="b3d5f-199">Other Performance Recommendations</span></span>](optimizing-performance-other-recommendations.md)
