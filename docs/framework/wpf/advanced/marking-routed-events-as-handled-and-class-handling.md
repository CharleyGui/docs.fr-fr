---
title: Marquage des événements routés comme étant gérés et gestion de classe
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: a1004ce10baf6293c4c93efc61b91b3b6361377f
ms.sourcegitcommit: eaa6d5cd0f4e7189dbe0bd756e9f53508b01989e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/07/2019
ms.locfileid: "67610370"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="48bab-102">Marquage des événements routés comme étant gérés et gestion de classe</span><span class="sxs-lookup"><span data-stu-id="48bab-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="48bab-103">Les gestionnaires d’un événement routé peuvent marquer l’événement comme étant géré dans les données d’événement.</span><span class="sxs-lookup"><span data-stu-id="48bab-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="48bab-104">La gestion de l’événement a pour effet de raccourcir efficacement l’itinéraire.</span><span class="sxs-lookup"><span data-stu-id="48bab-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="48bab-105">La gestion de classe est un concept de programmation pris en charge par les événements routés.</span><span class="sxs-lookup"><span data-stu-id="48bab-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="48bab-106">Un gestionnaire de classe peut gérer un événement routé particulier au niveau d’une classe à l’aide d’un gestionnaire appelé avant tout gestionnaire d’instance sur une instance de la classe.</span><span class="sxs-lookup"><span data-stu-id="48bab-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="48bab-107">Prérequis</span><span class="sxs-lookup"><span data-stu-id="48bab-107">Prerequisites</span></span>  
 <span data-ttu-id="48bab-108">Cette rubrique décrit plus en détail les concepts introduits dans [Vue d’ensemble des événements routés](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="48bab-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="48bab-109">Quand marquer des événements comme étant gérés</span><span class="sxs-lookup"><span data-stu-id="48bab-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="48bab-110">Lorsque vous définissez la valeur de la <xref:System.Windows.RoutedEventArgs.Handled%2A> propriété `true` de l’événement des données pour un événement routé, il est appelé « marquer l’événement géré ».</span><span class="sxs-lookup"><span data-stu-id="48bab-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="48bab-111">Que vous soyez auteur d’une application ou auteur d’un contrôle qui répond à des événements routés existants ou qui implémente de nouveaux événements routés, il n’existe aucune règle absolue qui indique à quel moment marquer les événements routés comme étant gérés.</span><span class="sxs-lookup"><span data-stu-id="48bab-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="48bab-112">Globalement, le concept « géré », tel qu’il est indiqué dans les données de l’événement routé, doit être utilisé comme un protocole limité pour les réponses de votre propre application aux divers événements routés exposés dans les [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], ainsi que pour les événements routés personnalisés.</span><span class="sxs-lookup"><span data-stu-id="48bab-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] as well as for any custom routed events.</span></span> <span data-ttu-id="48bab-113">Une autre façon d’envisager la question du marquage « géré » est que vous devez généralement marquer un événement routé comme étant géré si votre code a répondu à l’événement routé d’une manière significative et relativement complète.</span><span class="sxs-lookup"><span data-stu-id="48bab-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="48bab-114">En règle générale, il ne doit pas exister plus d’une réponse significative à exiger des implémentations de gestionnaire distinctes pour une même occurrence d’événement routé.</span><span class="sxs-lookup"><span data-stu-id="48bab-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="48bab-115">Si plusieurs réponses sont nécessaires, le code correspondant doit être implémenté à travers la logique d’application intégrée à un gestionnaire unique plutôt qu’en utilisant le système d’événement routé pour le transfert.</span><span class="sxs-lookup"><span data-stu-id="48bab-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="48bab-116">L’idée de ce qui est « significatif » revêt aussi une dimension subjective et dépend de votre application ou de votre code.</span><span class="sxs-lookup"><span data-stu-id="48bab-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="48bab-117">À titre d’indication générale, voici quelques exemples de « réponses significatives » : définition du focus, modification de l’état public, définition des propriétés qui affectent la représentation visuelle et déclenchement d’autres événements nouveaux.</span><span class="sxs-lookup"><span data-stu-id="48bab-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="48bab-118">À l’inverse, la modification de l’état privé (sans impact visuel ni représentation de programmation), la journalisation d’événements ou la consultation des arguments d’un événement et la décision de ne pas y répondre sont des exemples de réponses non significatives.</span><span class="sxs-lookup"><span data-stu-id="48bab-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="48bab-119">Le comportement de système d’événement routé renforce ce modèle de « réponse significative » pour l’utilisation de l’état géré d’un événement routé, car les gestionnaires ajoutés dans [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] ou la signature commune de <xref:System.Windows.UIElement.AddHandler%2A> ne sont pas appelés en réponse à un événement routé où l’événement données sont déjà marqué comme gérées.</span><span class="sxs-lookup"><span data-stu-id="48bab-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="48bab-120">Vous devez passer par l’effort supplémentaire de l’ajout d’un gestionnaire avec la `handledEventsToo` version du paramètre (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) afin de gérer les événements routés sont marqués comme étant gérés par premiers participants acheminer de l’événement.</span><span class="sxs-lookup"><span data-stu-id="48bab-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="48bab-121">Dans certains cas, les contrôles proprement dits marquent certains événements routés comme étant gérés.</span><span class="sxs-lookup"><span data-stu-id="48bab-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="48bab-122">Un événement routé géré représente une décision de la part des auteurs d’un contrôle [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] que les actions du contrôle en réponse à l’événement routé sont significatives ou terminées dans le cadre de l’implémentation du contrôle, et l’événement n’a plus besoin d’être géré.</span><span class="sxs-lookup"><span data-stu-id="48bab-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="48bab-123">Cela consiste généralement à ajouter un gestionnaire de classe pour un événement ou à remplacer l’un des virtuels de gestionnaire de classe qui existent dans une classe de base.</span><span class="sxs-lookup"><span data-stu-id="48bab-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="48bab-124">Vous pouvez toujours contourner cette gestion d’événement, si nécessaire ; consultez la page [Résolution des problèmes liés à la suppression d’événements par des contrôles](#WorkingAroundEventSuppressionByControls) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="48bab-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="48bab-125">Événements Preview (tunneling) versus événements de propagation et gestion des événements</span><span class="sxs-lookup"><span data-stu-id="48bab-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="48bab-126">Les événements routés Preview sont des événements qui suivent un itinéraire de tunneling dans l’arborescence des éléments.</span><span class="sxs-lookup"><span data-stu-id="48bab-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="48bab-127">« Preview », exprimé dans la convention de nommage, est révélateur du principe général des événements d’entrée selon lequel les événements routés Preview (tunneling) sont déclenchés avant l’événement routé de propagation équivalent.</span><span class="sxs-lookup"><span data-stu-id="48bab-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="48bab-128">Par ailleurs, les événements routés d’entrée associés à une paire de tunneling et de propagation ont une logique de gestion distincte.</span><span class="sxs-lookup"><span data-stu-id="48bab-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="48bab-129">Si l’événement routé de tunneling/preview est marqué comme étant géré par un écouteur d’événements, l’événement routé de propagation est alors marqué comme étant géré, avant même qu’un écouteur de l’événement routé de propagation l’ait reçu.</span><span class="sxs-lookup"><span data-stu-id="48bab-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="48bab-130">Les événements routés de tunneling et de propagation sont des événements techniquement distincts, mais ils partagent délibérément la même instance de données d’événement pour autoriser ce comportement.</span><span class="sxs-lookup"><span data-stu-id="48bab-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="48bab-131">La connexion entre les événements routés de tunneling et de propagation est établie par l’implémentation interne du mode de déclenchement des événements routés déclarés d’une classe [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] donnée, et cela s’applique aux événements routés d’entrée associés.</span><span class="sxs-lookup"><span data-stu-id="48bab-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="48bab-132">Cependant, à moins que cette implémentation au niveau de la classe existe, aucune connexion n’est établie entre un événement routé de tunneling et un événement routé de propagation qui partagent le modèle de nommage : sans cette implémentation, ils deviendraient deux événements routés totalement distincts et ne seraient pas déclenchés dans l’ordre, ni ne partageraient les données d’événement.</span><span class="sxs-lookup"><span data-stu-id="48bab-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="48bab-133">Pour plus d’informations sur l’implémentation des paires d’événements routés d’entrée de tunneling/propagation dans une classe personnalisée, consultez [Créer un événement routé personnalisé](how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="48bab-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="48bab-134">Gestionnaires de classe et gestionnaires d’instance</span><span class="sxs-lookup"><span data-stu-id="48bab-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="48bab-135">Les événements routés reconnaissent deux types d’écouteur d’événement : les écouteurs de classe et les écouteurs d’instance.</span><span class="sxs-lookup"><span data-stu-id="48bab-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="48bab-136">Écouteurs de classe existent parce que les types ont appelé un particulier <xref:System.Windows.EventManager> API,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, dans leur constructeur statique, ou ont remplacé une méthode virtuelle de gestionnaire de classe à partir d’une classe de base d’élément.</span><span class="sxs-lookup"><span data-stu-id="48bab-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> API ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="48bab-137">Écouteurs d’instance sont des éléments/instances de classe particulier où un ou plusieurs gestionnaires ont été associés à cet événement routé par un appel à <xref:System.Windows.UIElement.AddHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="48bab-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="48bab-138">Existant [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] événements routés effectuer des appels vers <xref:System.Windows.UIElement.AddHandler%2A> dans le cadre de la [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] wrapper d’événement ajouter{} et supprimer{} implémentations de l’événement, qui est également comment la simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mécanisme de l’attachement gestionnaires d’événements via une syntaxe d’attribut est activée.</span><span class="sxs-lookup"><span data-stu-id="48bab-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="48bab-139">Par conséquent même simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] utilisation équivaut en fin de compte à un <xref:System.Windows.UIElement.AddHandler%2A> appeler.</span><span class="sxs-lookup"><span data-stu-id="48bab-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="48bab-140">Les éléments de l’arborescence d’éléments visuels sont vérifiés pour déterminer s’ils comportent des implémentations de gestionnaire enregistré.</span><span class="sxs-lookup"><span data-stu-id="48bab-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="48bab-141">Les gestionnaires sont potentiellement appelés tout au long de l’itinéraire, dans l’ordre inhérent au type de la stratégie de routage pour cet événement routé.</span><span class="sxs-lookup"><span data-stu-id="48bab-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="48bab-142">Par exemple, les événements routés de propagation appellent d’abord les gestionnaires associés à l’élément qui a déclenché l’événement routé.</span><span class="sxs-lookup"><span data-stu-id="48bab-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="48bab-143">Les événements routés sont ensuite « propagés » au prochain élément parent, et ainsi de suite jusqu’à ce que l’élément racine de l’application soit atteint.</span><span class="sxs-lookup"><span data-stu-id="48bab-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="48bab-144">Du point de vue de l’élément racine d’un itinéraire de propagation, si la gestion de classe ou tout élément plus proche de la source de l’événement routé appelle des gestionnaires qui marquent les arguments d’événement comme étant gérés, les gestionnaires des éléments racine ne sont pas appelés, et l’itinéraire de l’événement est raccourci efficacement avant d’atteindre l’élément racine en question.</span><span class="sxs-lookup"><span data-stu-id="48bab-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="48bab-145">Cependant, l’itinéraire n’est pas complètement arrêté, car il est possible d’ajouter des gestionnaires à l’aide d’un conditionnel spécial qui exige qu’ils soient tout de même appelés, même si un gestionnaire de classe ou d’instance a marqué l’événement routé comme étant géré.</span><span class="sxs-lookup"><span data-stu-id="48bab-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="48bab-146">Cet aspect est détaillé plus loin dans cette rubrique dans [Ajout de gestionnaires d’instance déclenchés y compris quand les événements sont marqués comme étant gérés](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled).</span><span class="sxs-lookup"><span data-stu-id="48bab-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="48bab-147">À un niveau plus approfondi que l’itinéraire d’événement se trouvent également des gestionnaires de classe potentiellement multiples qui agissent sur une instance donnée d’une classe.</span><span class="sxs-lookup"><span data-stu-id="48bab-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="48bab-148">Cela est dû au fait que le modèle de gestion de classe des événements routés permet à toutes les classes possibles d’une hiérarchie de classes d’enregistrer chacune son propre gestionnaire de classe pour chaque événement routé.</span><span class="sxs-lookup"><span data-stu-id="48bab-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="48bab-149">Chaque gestionnaire de classe est ajouté à un magasin interne, et quand l’itinéraire d’événement d’une application est construit, les gestionnaires de classe sont tous ajoutés à l’itinéraire d’événement.</span><span class="sxs-lookup"><span data-stu-id="48bab-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="48bab-150">Les gestionnaires de classe sont ajoutés à l’itinéraire de sorte que le gestionnaire de classe le plus dérivé soit appelé en premier et que les gestionnaires de chaque classe de base consécutive soient appelés ensuite.</span><span class="sxs-lookup"><span data-stu-id="48bab-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="48bab-151">En règle générale, les gestionnaires de classe ne sont pas enregistrés de sorte qu’ils répondent aussi aux événements routés qui étaient déjà marqués comme étant gérés.</span><span class="sxs-lookup"><span data-stu-id="48bab-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="48bab-152">Par conséquent, ce mécanisme de gestion de classe permet d’opter pour l’un des deux choix suivants :</span><span class="sxs-lookup"><span data-stu-id="48bab-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="48bab-153">Les classes dérivées peuvent compléter la gestion de classe héritée de la classe de base en ajoutant un gestionnaire qui ne marque pas l’événement routé comme étant géré, car le gestionnaire de classe de base sera appelé peu de temps après le gestionnaire de classe dérivé.</span><span class="sxs-lookup"><span data-stu-id="48bab-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="48bab-154">Les classes dérivées peuvent remplacer la gestion de classe à partir de la classe de base en ajoutant un gestionnaire de classe qui marque l’événement routé comme étant géré.</span><span class="sxs-lookup"><span data-stu-id="48bab-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="48bab-155">Vous devez être prudent avec cette approche, car elle est susceptible de changer la conception du contrôle de base prévu dans des domaines tels que l’apparence visuelle, la logique d’état, la gestion des entrées et la gestion des commandes.</span><span class="sxs-lookup"><span data-stu-id="48bab-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="48bab-156">Gestion de classe des événements routés par les classes de base de contrôle</span><span class="sxs-lookup"><span data-stu-id="48bab-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="48bab-157">Sur chaque nœud d’élément donné au sein d’un itinéraire d’événement, les écouteurs de classe peuvent répondre à l’événement routé avant n’importe quel écouteur d’instance de l’élément.</span><span class="sxs-lookup"><span data-stu-id="48bab-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="48bab-158">C’est pourquoi les gestionnaires de classe sont parfois utilisés pour supprimer les événements routés qu’une implémentation de classe de contrôle particulière ne souhaite pas propager davantage, ou pour assurer une gestion spéciale de l’événement routé qui compte parmi les fonctionnalités de la classe.</span><span class="sxs-lookup"><span data-stu-id="48bab-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="48bab-159">Par exemple, une classe peut déclencher son propre événement spécifique qui contient davantage de détails sur la signification de la condition d’entrée utilisateur dans le contexte de cette classe particulière.</span><span class="sxs-lookup"><span data-stu-id="48bab-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="48bab-160">L’implémentation de classe peut ensuite marquer l’événement routé plus général comme étant géré.</span><span class="sxs-lookup"><span data-stu-id="48bab-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="48bab-161">Gestionnaires de classe sont généralement ajoutés tels qu’ils ne sont pas appelés pour routé où les données d’événement partagées a déjà marquées les événements gérés, mais pour les cas atypiques il existe également un <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature qui enregistre les gestionnaires de classe pour appeler la même lorsque les événements routés sont marqué comme géré.</span><span class="sxs-lookup"><span data-stu-id="48bab-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="48bab-162">Virtuels de gestionnaire de classe</span><span class="sxs-lookup"><span data-stu-id="48bab-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="48bab-163">Certains éléments, en particulier les éléments de base comme <xref:System.Windows.UIElement>, exposent » sur \* événement » et « OnPreview\*événement « méthodes virtuelles qui correspondent à leur liste d’événements routés publics.</span><span class="sxs-lookup"><span data-stu-id="48bab-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="48bab-164">Ces méthodes virtuelles peuvent être remplacées de façon à implémenter un gestionnaire de classe pour l’événement routé en question.</span><span class="sxs-lookup"><span data-stu-id="48bab-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="48bab-165">Les classes d’élément de base enregistrent ces méthodes virtuelles comme leur gestionnaire de classe pour chacun de ces routés à l’aide de l’événement <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> comme décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="48bab-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="48bab-166">Les méthodes virtuelles On\*Event facilitent considérablement l’implémentation de la gestion de classe pour les événements routés correspondants, sans nécessiter d’initialisation spéciale dans les constructeurs statiques de chaque type.</span><span class="sxs-lookup"><span data-stu-id="48bab-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="48bab-167">Par exemple, vous pouvez ajouter la gestion de classe pour le <xref:System.Windows.UIElement.DragEnter> événements dans les <xref:System.Windows.UIElement> classe dérivée en substituant le <xref:System.Windows.UIElement.OnDragEnter%2A> méthode virtuelle.</span><span class="sxs-lookup"><span data-stu-id="48bab-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="48bab-168">Au cours de ce remplacement, vous pouvez gérer l’événement routé, déclencher d’autres événements, initialiser la logique spécifique à la classe qui pourrait changer des propriétés d’élément dans les instances, ou toute combinaison de ces actions.</span><span class="sxs-lookup"><span data-stu-id="48bab-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="48bab-169">En règle générale, dans ce type de modification, vous devez appeler l’implémentation de base même si vous marquez l’événement comme étant géré.</span><span class="sxs-lookup"><span data-stu-id="48bab-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="48bab-170">Il est vivement recommandé d’appeler l’implémentation de base, car la méthode virtuelle se trouve au niveau de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="48bab-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="48bab-171">Dans l’absolu, le modèle virtuel protégé standard mis en œuvre pour appeler les implémentations de base à partir de chaque virtuel remplace et met en parallèle un mécanisme similaire natif de la gestion des classes d’événements routés, au moyen duquel sont appelés les gestionnaires de toutes les classes d’une hiérarchie de classes d’une instance donnée, en commençant par le gestionnaire de classe le plus dérivé pour ensuite passer au gestionnaire de classe de base.</span><span class="sxs-lookup"><span data-stu-id="48bab-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="48bab-172">Vous ne devez omettre l’appel à l’implémentation de base que si votre classe exige délibérément de changer la logique de gestion de classe de base.</span><span class="sxs-lookup"><span data-stu-id="48bab-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="48bab-173">C’est la nature de votre implémentation qui détermine si vous appelez l’implémentation de base avant ou après votre code de substitution.</span><span class="sxs-lookup"><span data-stu-id="48bab-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="48bab-174">Gestion des classes d’événements d’entrée</span><span class="sxs-lookup"><span data-stu-id="48bab-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="48bab-175">Les méthodes virtuelles des gestionnaires de classe sont toutes enregistrées pour faire en sorte qu’elles ne soient appelées que si les données d’événement partagées ne sont pas déjà marquées comme étant gérées.</span><span class="sxs-lookup"><span data-stu-id="48bab-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="48bab-176">Par ailleurs, pour les événements d’entrée uniquement, les versions de tunneling et de propagation sont généralement déclenchées dans l’ordre et partagent les données d’événement.</span><span class="sxs-lookup"><span data-stu-id="48bab-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="48bab-177">Par conséquent, pour une paire donnée de gestionnaires de classe d’événements d’entrée, où l’un correspond à la version de tunneling et l’autre à la version de propagation, vous pouvez ne pas marquer immédiatement l’événement comme étant géré.</span><span class="sxs-lookup"><span data-stu-id="48bab-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="48bab-178">Si vous implémentez la méthode virtuelle de gestion de classe par tunneling pour marquer l’événement comme étant géré, le gestionnaire de classe de propagation ne pourra pas être appelé (ni même les gestionnaires d’instance enregistrés normalement pour l’événement de tunneling ou de propagation).</span><span class="sxs-lookup"><span data-stu-id="48bab-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="48bab-179">Une fois que la gestion de classe est terminée sur un nœud, les écouteurs d’instance sont pris en considération.</span><span class="sxs-lookup"><span data-stu-id="48bab-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="48bab-180">Ajout de gestionnaires d’instance déclenchés y compris quand les événements sont marqués comme étant gérés</span><span class="sxs-lookup"><span data-stu-id="48bab-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="48bab-181">Le <xref:System.Windows.UIElement.AddHandler%2A> méthode fournit une surcharge particulière qui vous permet d’ajouter des gestionnaires qui seront appelés par le système d’événement chaque fois qu’un événement atteint l’élément de gestion dans l’itinéraire, même si un autre gestionnaire a déjà ajusté les données d’événement pour marquer qui événement comme géré.</span><span class="sxs-lookup"><span data-stu-id="48bab-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="48bab-182">Il ne s’agit pas de la procédure courante.</span><span class="sxs-lookup"><span data-stu-id="48bab-182">This is not typically done.</span></span> <span data-ttu-id="48bab-183">En général, des gestionnaires peuvent être écrits pour ajuster toutes les zones de code d’application susceptibles d’être influencées par un événement, indépendamment de l’emplacement où il a été géré dans une arborescence d’éléments, même si plusieurs résultats finaux sont souhaités.</span><span class="sxs-lookup"><span data-stu-id="48bab-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="48bab-184">De plus, seul un élément est généralement chargé véritablement de répondre à cet événement, et la logique d’application appropriée s’est déjà exécutée.</span><span class="sxs-lookup"><span data-stu-id="48bab-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="48bab-185">Cependant, la surcharge `handledEventsToo` est disponible pour les cas exceptionnels où un autre élément d’une arborescence d’éléments ou une composition de contrôles a déjà marqué un événement comme étant géré, mais que d’autres éléments situés plus haut ou plus bas dans l’arborescence d’éléments (en fonction de l’itinéraire) demandent toujours à ce que leurs propres gestionnaires soient appelés.</span><span class="sxs-lookup"><span data-stu-id="48bab-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="48bab-186">Quand marquer des événements gérés comme étant non gérés</span><span class="sxs-lookup"><span data-stu-id="48bab-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="48bab-187">En règle générale, les événements routés sont marqués comme étant gérés ne doivent pas être marqués non gérées (<xref:System.Windows.RoutedEventArgs.Handled%2A> retrouvent `false`) même par les gestionnaires qui agissent sur `handledEventsToo`.</span><span class="sxs-lookup"><span data-stu-id="48bab-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="48bab-188">Cependant, certains événements d’entrée ont des représentations d’événement de haut niveau et de bas niveau qui peuvent se chevaucher quand l’événement de haut niveau et l’événement de bas niveau ne se trouvent pas à la même position dans l’arborescence.</span><span class="sxs-lookup"><span data-stu-id="48bab-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="48bab-189">Par exemple, prenons le cas où un élément enfant écoute un événement de touche haut niveau tels que <xref:System.Windows.UIElement.TextInput> pendant un élément parent écoute un événement de bas niveau tels que <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="48bab-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="48bab-190">Si l’élément parent gère l’événement de bas niveau, l’événement de haut niveau peut être supprimé même dans l’élément enfant qui logiquement devrait être le premier à pouvoir gérer l’événement.</span><span class="sxs-lookup"><span data-stu-id="48bab-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="48bab-191">Dans ce cas, il peut s’avérer nécessaire d’ajouter des gestionnaires aux éléments parents et enfants pour l’événement de bas niveau.</span><span class="sxs-lookup"><span data-stu-id="48bab-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="48bab-192">L’implémentation du gestionnaire d’éléments enfants peut marquer l’événement de bas niveau comme étant géré, mais l’implémentation du gestionnaire d’éléments parents le redéfinirait comme étant non géré, si bien que les éléments de niveau supérieur de l’arborescence (ainsi que l’événement de haut niveau) peuvent avoir l’occasion de répondre.</span><span class="sxs-lookup"><span data-stu-id="48bab-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="48bab-193">Ce cas de figure devrait être assez rare.</span><span class="sxs-lookup"><span data-stu-id="48bab-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="48bab-194">Suppression délibérée d’événements d’entrée pour la composition de contrôles</span><span class="sxs-lookup"><span data-stu-id="48bab-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="48bab-195">La gestion de classe d’événements routés est principalement utilisée pour les événements d’entrée et les contrôles composés.</span><span class="sxs-lookup"><span data-stu-id="48bab-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="48bab-196">Un contrôle composé est par définition composé de plusieurs contrôles pratiques ou classes de base de contrôle.</span><span class="sxs-lookup"><span data-stu-id="48bab-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="48bab-197">Souvent, l’intention de l’auteur du contrôle est d’amalgamer tous les événements d’entrée possibles que chaque sous-composant peut déclencher, de façon à signaler l’ensemble du contrôle comme étant la source singulière des événements.</span><span class="sxs-lookup"><span data-stu-id="48bab-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="48bab-198">Dans certains cas, l’auteur du contrôle peut souhaiter supprimer totalement les événements des composants ou remplacer un événement défini par un composant qui contient davantage d’informations ou implique un comportement plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="48bab-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="48bab-199">L’exemple canonique immédiatement visible par les auteurs de n’importe quel composant est comment un [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> gère un événement de souris qui se résoudra finalement en événement intuitif que tous les boutons possèdent : un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement.</span><span class="sxs-lookup"><span data-stu-id="48bab-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="48bab-200">Le <xref:System.Windows.Controls.Button> classe de base (<xref:System.Windows.Controls.Primitives.ButtonBase>) dérive <xref:System.Windows.Controls.Control> qui dérive à son tour de <xref:System.Windows.FrameworkElement> et <xref:System.Windows.UIElement>et une grande partie de l’infrastructure d’événements nécessaire pour contrôler le traitement d’entrée est disponible à la <xref:System.Windows.UIElement> niveau.</span><span class="sxs-lookup"><span data-stu-id="48bab-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="48bab-201">En particulier, <xref:System.Windows.UIElement> traite général <xref:System.Windows.Input.Mouse> les événements qui gèrent le test d’atteinte pour le curseur de souris dans ses limites et fournit des événements distincts pour la plus courante bouton actions, telles que <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="48bab-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="48bab-202"><xref:System.Windows.UIElement> fournit également un vide virtuel <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> en tant que gestionnaire de classe préenregistré pour <xref:System.Windows.UIElement.MouseLeftButtonDown>, et <xref:System.Windows.Controls.Primitives.ButtonBase> se substitue à elle.</span><span class="sxs-lookup"><span data-stu-id="48bab-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="48bab-203">De même, <xref:System.Windows.Controls.Primitives.ButtonBase> utilise gestionnaires de classe pour <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="48bab-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="48bab-204">Dans les remplacements, qui sont passées les données d’événement, les implémentations marquent cette <xref:System.Windows.RoutedEventArgs> instance comme étant géré en définissant <xref:System.Windows.RoutedEventArgs.Handled%2A> à `true`, et que les mêmes données d’événement soient ce qui se poursuit sur le reste de l’itinéraire à d’autres gestionnaires de classe et également pour les gestionnaires d’instance ou les méthodes setter d’événement.</span><span class="sxs-lookup"><span data-stu-id="48bab-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="48bab-205">En outre, le <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> remplacement déclenche ensuite le <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement.</span><span class="sxs-lookup"><span data-stu-id="48bab-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="48bab-206">Le résultat final pour la plupart des écouteurs qui sera le <xref:System.Windows.UIElement.MouseLeftButtonDown> et <xref:System.Windows.UIElement.MouseLeftButtonUp> événements « disparaissent » et sont remplacés par <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, un événement plus significatif, car il est connu que cet événement provient d’un bouton véritable et pas certains composite entièrement la pièce du bouton ou à partir d’un autre élément.</span><span class="sxs-lookup"><span data-stu-id="48bab-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="48bab-207">Résolution des problèmes liés à la suppression d’événements par des contrôles</span><span class="sxs-lookup"><span data-stu-id="48bab-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="48bab-208">Ce comportement de suppression d’événements au sein des contrôles individuels peut parfois interférer avec certaines intentions plus générales de la logique de gestion des événements de votre application.</span><span class="sxs-lookup"><span data-stu-id="48bab-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="48bab-209">Par exemple, si pour une raison quelconque votre application avait un gestionnaire pour <xref:System.Windows.UIElement.MouseLeftButtonDown> situé dans l’élément racine d’application, vous noterez qu’un clic de souris sur un bouton n’appelle pas <xref:System.Windows.UIElement.MouseLeftButtonDown> ou <xref:System.Windows.UIElement.MouseLeftButtonUp> gestionnaires au niveau racine.</span><span class="sxs-lookup"><span data-stu-id="48bab-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="48bab-210">L’événement proprement dit s’est bien propagé (encore une fois, les itinéraires d’événements ne se terminent pas véritablement, mais le système d’événements routés change leur comportement d’appel de gestionnaire après qu’ils ont été marqués comme étant gérés).</span><span class="sxs-lookup"><span data-stu-id="48bab-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="48bab-211">Lorsque l’événement routé a atteint le bouton, le <xref:System.Windows.Controls.Primitives.ButtonBase> gestion de classe marqué le <xref:System.Windows.UIElement.MouseLeftButtonDown> géré, car elle a voulu remplacer le <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement avec plus de sens.</span><span class="sxs-lookup"><span data-stu-id="48bab-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="48bab-212">Par conséquent, n’importe quelle norme <xref:System.Windows.UIElement.MouseLeftButtonDown> Gestionnaire davantage l’itinéraire n’est pas appelé.</span><span class="sxs-lookup"><span data-stu-id="48bab-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="48bab-213">Vous avez le choix entre deux techniques pour faire en sorte que vos gestionnaires soient appelés dans ce cas.</span><span class="sxs-lookup"><span data-stu-id="48bab-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="48bab-214">La première technique consiste à ajouter délibérément le gestionnaire en utilisant le `handledEventsToo` signature de <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="48bab-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="48bab-215">La limite de cette approche vient du fait que le gestionnaire d’événements ne peut être joint qu’à partir du code et non du balisage.</span><span class="sxs-lookup"><span data-stu-id="48bab-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="48bab-216">La syntaxe simple de spécification du nom du gestionnaire d’événements en tant que valeur d’attribut d’événement via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] n’active pas ce comportement.</span><span class="sxs-lookup"><span data-stu-id="48bab-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="48bab-217">La deuxième technique vaut uniquement pour les événements d’entrée où les versions de tunneling et de propagation de l’événement routé sont associées.</span><span class="sxs-lookup"><span data-stu-id="48bab-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="48bab-218">Pour ces événements routés, vous pouvez plutôt ajouter des gestionnaires à l’événement routé équivalent preview/tunneling équivalent.</span><span class="sxs-lookup"><span data-stu-id="48bab-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="48bab-219">Cet événement routé crée un tunnel le long de l’itinéraire en partant de la racine, si bien que le code de gestion de classe Button ne l’intercepte pas, présumant que vous avez joint le gestionnaire Preview au niveau d’un élément ancêtre dans l’arborescence d’éléments de l’application.</span><span class="sxs-lookup"><span data-stu-id="48bab-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="48bab-220">Si vous utilisez cette approche, faites attention quand il s’agit de marquer un événement Preview comment étant géré.</span><span class="sxs-lookup"><span data-stu-id="48bab-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="48bab-221">Dans l’exemple donné avec <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> géré à l’élément racine, si vous marquiez l’événement <xref:System.Windows.RoutedEventArgs.Handled%2A> dans l’implémentation du gestionnaire, vous supprimeriez de fait le <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement.</span><span class="sxs-lookup"><span data-stu-id="48bab-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="48bab-222">Ce comportement n’est généralement pas souhaitable.</span><span class="sxs-lookup"><span data-stu-id="48bab-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="48bab-223">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="48bab-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="48bab-224">Événements Preview</span><span class="sxs-lookup"><span data-stu-id="48bab-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="48bab-225">Créer un événement routé personnalisé</span><span class="sxs-lookup"><span data-stu-id="48bab-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="48bab-226">Vue d’ensemble des événements routés</span><span class="sxs-lookup"><span data-stu-id="48bab-226">Routed Events Overview</span></span>](routed-events-overview.md)
