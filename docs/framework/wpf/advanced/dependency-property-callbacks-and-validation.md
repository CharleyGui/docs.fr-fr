---
title: Validation et rappels de propriétés de dépendance
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- dependency properties [WPF], validation
- coerce value callbacks [WPF]
- callbacks [WPF], validation
- dependency properties [WPF], callbacks
- validation of dependency properties [WPF]
ms.assetid: 48db5fb2-da7f-49a6-8e81-3540e7b25825
ms.openlocfilehash: c5f7439753037aeb5c2ff558da63e063ad65a5e1
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186434"
---
# <a name="dependency-property-callbacks-and-validation"></a><span data-ttu-id="3d471-102">Validation et rappels de propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="3d471-102">Dependency Property Callbacks and Validation</span></span>
<span data-ttu-id="3d471-103">Cette rubrique décrit comment créer des propriétés de dépendance à l’aide d’autres implémentations personnalisées pour des fonctionnalités liées aux propriétés telles que la détermination de la validation, les rappels effectués chaque fois que la valeur effective de la propriété change, et la non prise en compte des possibles influences extérieures sur la détermination de la valeur.</span><span class="sxs-lookup"><span data-stu-id="3d471-103">This topic describes how to create dependency properties using alternative custom implementations for property-related features such as validation determination, callbacks that are invoked whenever the property's effective value is changed, and overriding possible outside influences on value determination.</span></span> <span data-ttu-id="3d471-104">Elle décrit également les scénarios où il est nécessaire de développer les comportements par défaut du système de propriétés à l’aide de ces techniques.</span><span class="sxs-lookup"><span data-stu-id="3d471-104">This topic also discusses scenarios where expanding on the default property system behaviors by using these techniques is appropriate.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="3d471-105">Conditions préalables requises</span><span class="sxs-lookup"><span data-stu-id="3d471-105">Prerequisites</span></span>  
 <span data-ttu-id="3d471-106">Cette rubrique part du principe que vous comprenez les scénarios de base de l’implémentation d’une propriété de dépendance et que vous savez comment les métadonnées sont appliquées à une propriété de dépendance personnalisée.</span><span class="sxs-lookup"><span data-stu-id="3d471-106">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="3d471-107">Pour plus d’informations sur le contexte, consultez [Propriétés de dépendance personnalisées](custom-dependency-properties.md) et [Métadonnées de propriété de dépendance](dependency-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="3d471-107">See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context.</span></span>  
  
<a name="Validation_Callbacks"></a>
## <a name="validation-callbacks"></a><span data-ttu-id="3d471-108">Rappels de validation</span><span class="sxs-lookup"><span data-stu-id="3d471-108">Validation Callbacks</span></span>  
 <span data-ttu-id="3d471-109">Les rappels de validation peuvent être attribués à une propriété de dépendance quand vous l’inscrivez initialement.</span><span class="sxs-lookup"><span data-stu-id="3d471-109">Validation callbacks can be assigned to a dependency property when you first register it.</span></span> <span data-ttu-id="3d471-110">Le rappel de validation ne fait pas partie des métadonnées immobilières; il s’agit d’une entrée directe de la <xref:System.Windows.DependencyProperty.Register%2A> méthode.</span><span class="sxs-lookup"><span data-stu-id="3d471-110">The validation callback is not part of property metadata; it is a direct input of the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="3d471-111">Par conséquent, une fois qu’un rappel de validation a été créé pour une propriété de dépendance, il ne peut pas être remplacé par une nouvelle implémentation.</span><span class="sxs-lookup"><span data-stu-id="3d471-111">Therefore, once a validation callback is created for a dependency property, it cannot be overridden by a new implementation.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="3d471-112">Les rappels sont implémentés de manière à ce qu’une valeur d’objet leur soit fournie.</span><span class="sxs-lookup"><span data-stu-id="3d471-112">The callbacks are implemented such that they are provided an object value.</span></span> <span data-ttu-id="3d471-113">Ils retournent `true` si la valeur fournie est valide pour la propriété ; sinon, ils retournent `false`.</span><span class="sxs-lookup"><span data-stu-id="3d471-113">They return `true` if the provided value is valid for the property; otherwise, they return `false`.</span></span> <span data-ttu-id="3d471-114">Il est supposé que la propriété est du type correct inscrit auprès du système de propriétés. Ainsi, la vérification du type dans les rappels n’est pas effectuée habituellement.</span><span class="sxs-lookup"><span data-stu-id="3d471-114">It is assumed that the property is of the correct type per the type registered with the property system, so checking type within the callbacks is not ordinarily done.</span></span> <span data-ttu-id="3d471-115">Les rappels sont utilisés par le système de propriétés dans diverses opérations différentes.</span><span class="sxs-lookup"><span data-stu-id="3d471-115">The callbacks are used by the property system in a variety of different operations.</span></span> <span data-ttu-id="3d471-116">Cela comprend l’initialisation de type initiale par valeur <xref:System.Windows.DependencyObject.SetValue%2A>par défaut, la modification programmatique en invoquant, ou les tentatives de remplacer les métadonnées avec la nouvelle valeur par défaut fournie.</span><span class="sxs-lookup"><span data-stu-id="3d471-116">This includes the initial type initialization by default value, programmatic change by invoking <xref:System.Windows.DependencyObject.SetValue%2A>, or attempts to override metadata with new default value provided.</span></span> <span data-ttu-id="3d471-117">Si le rappel de validation est appelé par l’une de ces opérations et qu’il retourne `false`, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="3d471-117">If the validation callback is invoked by any of these operations, and returns `false`, then an exception will be raised.</span></span> <span data-ttu-id="3d471-118">Les développeurs d’application doivent être prêts à gérer ces exceptions.</span><span class="sxs-lookup"><span data-stu-id="3d471-118">Application writers must be prepared to handle these exceptions.</span></span> <span data-ttu-id="3d471-119">L’une des utilisations courantes des rappels de validation consiste à valider des valeurs d’énumération, ou à contraindre des valeurs d’entiers ou des valeurs doubles quand la propriété définit des mesures qui doivent être supérieures ou égales à zéro.</span><span class="sxs-lookup"><span data-stu-id="3d471-119">A common use of validation callbacks is validating enumeration values, or constraining values of integers or doubles when the property sets measurements that must be zero or greater.</span></span>  
  
 <span data-ttu-id="3d471-120">Les rappels de validation sont spécifiquement prévus pour être des validateurs de classe, et non des validateurs d’instance.</span><span class="sxs-lookup"><span data-stu-id="3d471-120">Validation callbacks specifically are intended to be class validators, not instance validators.</span></span> <span data-ttu-id="3d471-121">Les paramètres du rappel ne communiquent <xref:System.Windows.DependencyObject> pas un spécifique sur lequel les propriétés à valider sont définies.</span><span class="sxs-lookup"><span data-stu-id="3d471-121">The parameters of the callback do not communicate a specific <xref:System.Windows.DependencyObject> on which the properties to validate are set.</span></span> <span data-ttu-id="3d471-122">Par conséquent, les rappels de validation ne sont pas utiles pour appliquer les dépendances « possibles » qui peuvent influencer une valeur de propriété, où la valeur propre à l’instance d’une propriété dépend de facteurs tels que des valeurs propres à l’instance d’autres propriétés ou l’état d’exécution.</span><span class="sxs-lookup"><span data-stu-id="3d471-122">Therefore the validation callbacks are not useful for enforcing the possible "dependencies" that might influence a property value, where the instance-specific value of a property is dependent on factors such as instance-specific values of other properties, or run-time state.</span></span>  
  
 <span data-ttu-id="3d471-123">Ce qui suit est le code d’exemple pour un scénario de rappel <xref:System.Double> de <xref:System.Double.PositiveInfinity> validation <xref:System.Double.NegativeInfinity>très simple: valider qu’une propriété qui est tapé comme le primitif n’est pas ou .</span><span class="sxs-lookup"><span data-stu-id="3d471-123">The following is example code for a very simple validation callback scenario: validating that a property that is typed as the <xref:System.Double> primitive is not <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>.</span></span>  
  
 [!code-csharp[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]
 [!code-vb[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]  
  
<a name="Coerce_Value_Callbacks_and_Property_Changed_Events"></a>
## <a name="coerce-value-callbacks-and-property-changed-events"></a><span data-ttu-id="3d471-124">Rappels de forçage de valeurs et événements de modification de propriété</span><span class="sxs-lookup"><span data-stu-id="3d471-124">Coerce Value Callbacks and Property Changed Events</span></span>  
 <span data-ttu-id="3d471-125">Les rappels de valeur coercitifs passent l’exemple spécifique <xref:System.Windows.DependencyObject> pour les propriétés, de même que les <xref:System.Windows.PropertyChangedCallback> implémentations qui sont invoquées par le système de propriété chaque fois que la valeur d’une propriété de dépendance change.</span><span class="sxs-lookup"><span data-stu-id="3d471-125">Coerce value callbacks do pass the specific <xref:System.Windows.DependencyObject> instance for properties, as do <xref:System.Windows.PropertyChangedCallback> implementations that are invoked by the property system whenever the value of a dependency property changes.</span></span> <span data-ttu-id="3d471-126">À l’aide de ces deux rappels en combinaison, vous pouvez créer une série de propriétés sur des éléments où les modifications d’une propriété forcent la réévaluation d’une autre propriété.</span><span class="sxs-lookup"><span data-stu-id="3d471-126">Using these two callbacks in combination, you can create a series of properties on elements where changes in one property will force a coercion or reevaluation of another property.</span></span>  
  
 <span data-ttu-id="3d471-127">Un scénario typique d’utilisation d’un chaînage de propriétés de dépendance est quand vous définissez une propriété pilotée par l’interface utilisateur où l’élément contient une propriété pour la valeur minimale, une autre propriété pour la valeur maximale et une troisième propriété pour la valeur réelle ou actuelle.</span><span class="sxs-lookup"><span data-stu-id="3d471-127">A typical scenario for using a linkage of dependency properties is when you have a user interface driven property where the element holds one property each for the minimum and maximum value, and a third property for the actual or current value.</span></span> <span data-ttu-id="3d471-128">Dans ce cas, si la valeur maximale a été modifiée de telle sorte que la valeur actuelle dépasse la nouvelle valeur maximale, vous souhaiterez forcer la valeur actuelle pour qu’elle n’excède pas la nouvelle valeur maximale (et de même en ce qui concerne la valeur minimale).</span><span class="sxs-lookup"><span data-stu-id="3d471-128">Here, if the maximum was adjusted in such a way that the current value exceeded the new maximum, you would want to coerce the current value to be no greater than the new maximum, and a similar relationship for minimum to current.</span></span>  
  
 <span data-ttu-id="3d471-129">Le court exemple de code ci-dessous concerne l’une des trois propriétés de dépendance qui illustrent cette relation.</span><span class="sxs-lookup"><span data-stu-id="3d471-129">The following is very brief example code for just one of the three dependency properties that illustrate this relationship.</span></span> <span data-ttu-id="3d471-130">Il montre comment la propriété `CurrentReading` d’un ensemble Min/Max/Current de propriétés Reading est inscrit.</span><span class="sxs-lookup"><span data-stu-id="3d471-130">The example shows how the `CurrentReading` property of a Min/Max/Current set of related \*Reading properties is registered.</span></span> <span data-ttu-id="3d471-131">Il utilise la validation comme illustré dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="3d471-131">It uses the validation as shown in the previous section.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="3d471-132">Le rappel de modification de propriété pour Current est utilisé pour transférer la modification à d’autres propriétés dépendantes, en appelant explicitement les rappels de forçage de valeur inscrits pour ces autres propriétés :</span><span class="sxs-lookup"><span data-stu-id="3d471-132">The property changed callback for Current is used to forward the change to other dependent properties, by explicitly invoking the coerce value callbacks that are registered for those other properties:</span></span>  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 <span data-ttu-id="3d471-133">Le rappel de forçage de valeur vérifie les valeurs des propriétés dont dépend potentiellement la propriété actuelle, et force la valeur actuelle si nécessaire :</span><span class="sxs-lookup"><span data-stu-id="3d471-133">The coerce value callback checks the values of properties that the current property is potentially dependent upon, and coerces the current value if necessary:</span></span>  
  
 [!code-csharp[DPCallbackOverride#CoerceCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]
 [!code-vb[DPCallbackOverride#CoerceCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]  
  
> [!NOTE]
> <span data-ttu-id="3d471-134">Les valeurs par défaut des propriétés ne sont pas forcées.</span><span class="sxs-lookup"><span data-stu-id="3d471-134">Default values of properties are not coerced.</span></span> <span data-ttu-id="3d471-135">Une valeur de propriété égale à la valeur par défaut peut se produire <xref:System.Windows.DependencyObject.ClearValue%2A>si une valeur de propriété a toujours son défaut initial, ou par compensation d’autres valeurs avec .</span><span class="sxs-lookup"><span data-stu-id="3d471-135">A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>.</span></span>  
  
 <span data-ttu-id="3d471-136">Les rappels de forçage de valeur et de modification de propriété font partie des métadonnées de propriété.</span><span class="sxs-lookup"><span data-stu-id="3d471-136">The coerce value and property changed callbacks are part of property metadata.</span></span> <span data-ttu-id="3d471-137">Ainsi, vous pouvez changer les rappels pour une propriété de dépendance particulière telle qu’elle existe sur un type dérivant du type qui possède la propriété de dépendance, en substituant les métadonnées de cette propriété sur votre type.</span><span class="sxs-lookup"><span data-stu-id="3d471-137">Therefore, you can change the callbacks for a particular dependency property as it exists on a type that you derive from the type that owns the dependency property, by overriding the metadata for that property on your type.</span></span>  
  
<a name="Advanced"></a>
## <a name="advanced-coercion-and-callback-scenarios"></a><span data-ttu-id="3d471-138">Scénarios de forçage et de rappel avancés</span><span class="sxs-lookup"><span data-stu-id="3d471-138">Advanced Coercion and Callback Scenarios</span></span>  
  
### <a name="constraints-and-desired-values"></a><span data-ttu-id="3d471-139">Contraintes et valeurs souhaitées</span><span class="sxs-lookup"><span data-stu-id="3d471-139">Constraints and Desired Values</span></span>  
 <span data-ttu-id="3d471-140">Les <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> rappels seront utilisés par le système de propriété pour contraindre une valeur conformément à la logique que vous déclarez, mais une valeur forcée d’une propriété fixée localement conservera toujours une « valeur désirée » à l’interne.</span><span class="sxs-lookup"><span data-stu-id="3d471-140">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> callbacks will be used by the property system to coerce a value in accordance to the logic you declare, but a coerced value of a locally set property will still retain a "desired value" internally.</span></span> <span data-ttu-id="3d471-141">Si les contraintes sont basées sur d’autres valeurs de propriété qui peuvent changer de manière dynamique pendant la durée de vie de l’application, les contraintes de forçage sont aussi changées de manière dynamique, et la propriété contrainte peut modifier sa valeur pour qu’elle soit le plus proche possible de la valeur souhaitée étant donné les nouvelles contraintes.</span><span class="sxs-lookup"><span data-stu-id="3d471-141">If the constraints are based on other property values that may change dynamically during the application lifetime, the coercion constraints are changed dynamically also, and the constrained property can change its value to get as close to the desired value as possible given the new constraints.</span></span> <span data-ttu-id="3d471-142">La valeur devient la valeur souhaitée si toutes les contraintes sont levées.</span><span class="sxs-lookup"><span data-stu-id="3d471-142">The value will become the desired value if all constraints are lifted.</span></span> <span data-ttu-id="3d471-143">Vous pouvez introduire potentiellement certains scénarios de dépendance relativement compliqués si vous avez plusieurs propriétés qui dépendent les unes des autres de manière circulaire.</span><span class="sxs-lookup"><span data-stu-id="3d471-143">You can potentially introduce some fairly complicated dependency scenarios if you have multiple properties that are dependent on one another in a circular manner.</span></span> <span data-ttu-id="3d471-144">Par exemple, dans le scénario Min/Max/Current, vous pouvez choisir de faire en sorte que Minimum et Maximum soient définissables par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3d471-144">For instance, in the Min/Max/Current scenario, you could choose to have Minimum and Maximum be user settable.</span></span> <span data-ttu-id="3d471-145">Dans ce cas, vous devrez peut-être forcer la propriété Maximum pour qu’elle soit toujours supérieure à Minimum, et inversement.</span><span class="sxs-lookup"><span data-stu-id="3d471-145">If so, you might need to coerce that Maximum is always greater than Minimum and vice versa.</span></span> <span data-ttu-id="3d471-146">Mais si cette contrainte est active, et que la valeur de Maximum est forcée sur celle de Minimum, cela laisse Current dans un état non définissable, car cette valeur dépend des deux autres et est limitée à la plage comprise entre ces deux valeurs, qui est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="3d471-146">But if that coercion is active, and Maximum coerces to Minimum, it leaves Current in an unsettable state, because it is dependent on both and is constrained to the range between the values, which is zero.</span></span> <span data-ttu-id="3d471-147">Ensuite, si Maximum ou Minimum est ajustée, Current paraîtra « suivre » l’une des valeurs, car la valeur souhaitée de Current sera encore stockée et tentera d’atteindre la valeur souhaitée à mesure que les contraintes sont assouplies.</span><span class="sxs-lookup"><span data-stu-id="3d471-147">Then, if Maximum or Minimum are adjusted, Current will seem to "follow" one of the values, because the desired value of Current is still stored and is attempting to reach the desired value as the constraints are loosened.</span></span>  
  
 <span data-ttu-id="3d471-148">Il n’y a rien de techniquement incorrect avec les dépendances complexes, mais elles peuvent réduire légèrement les performances si elles nécessitent un grand nombre de réévaluations, et peuvent également être déconcertantes pour les utilisateurs si elles affectent directement l’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3d471-148">There is nothing technically wrong with complex dependencies, but they can be a slight performance detriment if they require large numbers of reevaluations, and can also be confusing to users if they affect the UI directly.</span></span> <span data-ttu-id="3d471-149">Soyez prudent avec les rappels de forçage de valeur et les rappels de modification de propriété, et vérifiez que la contrainte tentée peut être traitée aussi clairement que possible et ne pas « surcontraindre ».</span><span class="sxs-lookup"><span data-stu-id="3d471-149">Be careful with property changed and coerce value callbacks and make sure that the coercion being attempted can be treated as unambiguously as possible, and does not "overconstrain".</span></span>  
  
### <a name="using-coercevalue-to-cancel-value-changes"></a><span data-ttu-id="3d471-150">Utilisation de CoerceValue pour annuler des modifications de valeur</span><span class="sxs-lookup"><span data-stu-id="3d471-150">Using CoerceValue to Cancel Value Changes</span></span>  
 <span data-ttu-id="3d471-151">Le système de <xref:System.Windows.CoerceValueCallback> propriété traitera <xref:System.Windows.DependencyProperty.UnsetValue> tout ce qui retourne la valeur comme un cas spécial.</span><span class="sxs-lookup"><span data-stu-id="3d471-151">The property system will treat any <xref:System.Windows.CoerceValueCallback> that returns the value <xref:System.Windows.DependencyProperty.UnsetValue> as a special case.</span></span> <span data-ttu-id="3d471-152">Ce cas particulier signifie que le <xref:System.Windows.CoerceValueCallback> changement de propriété qui a abouti à l’appel devrait être rejeté par le système de propriété, et que le système de propriété devrait plutôt déclarer quelle que soit la valeur précédente de la propriété avait.</span><span class="sxs-lookup"><span data-stu-id="3d471-152">This special case means that the property change that resulted in the <xref:System.Windows.CoerceValueCallback> being called should be rejected by the property system, and that the property system should instead report whatever previous value the property had.</span></span> <span data-ttu-id="3d471-153">Ce mécanisme peut être utile pour vérifier que les modifications d’une propriété qui ont été lancées de façon asynchrone sont toujours valides pour l’état actuel de l’objet, et pour supprimer les modifications si ce n’est pas le cas.</span><span class="sxs-lookup"><span data-stu-id="3d471-153">This mechanism can be useful to check that changes to a property that were initiated asynchronously are still valid for the current object state, and suppress the changes if not.</span></span> <span data-ttu-id="3d471-154">Un autre scénario possible consiste à supprimer sélectivement une valeur en fonction du composant de détermination de la valeur de propriété responsable du signalement de la valeur.</span><span class="sxs-lookup"><span data-stu-id="3d471-154">Another possible scenario is that you can selectively suppress a value depending on which component of property value determination is responsible for the value being reported.</span></span> <span data-ttu-id="3d471-155">Pour ce faire, vous <xref:System.Windows.DependencyProperty> pouvez utiliser le passé dans le <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>rappel et <xref:System.Windows.ValueSource>l’identifiant de propriété comme entrée pour , puis traiter le .</span><span class="sxs-lookup"><span data-stu-id="3d471-155">To do this, you can use the <xref:System.Windows.DependencyProperty> passed in the callback and the property identifier as input for <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>, and then process the <xref:System.Windows.ValueSource>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3d471-156">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="3d471-156">See also</span></span>

- [<span data-ttu-id="3d471-157">Aperçu des propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="3d471-157">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="3d471-158">Métadonnées de propriété de dépendance</span><span class="sxs-lookup"><span data-stu-id="3d471-158">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="3d471-159">Propriétés de dépendance personnalisées</span><span class="sxs-lookup"><span data-stu-id="3d471-159">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
