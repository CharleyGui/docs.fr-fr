---
title: Meilleures pratiques pour la fiabilité
description: Pour plus d’SQL Server, consultez meilleures pratiques en matière de fiabilité dans les applications serveur basées sur un hôte .NET. Empêchez les fuites de ressources ou les mises en route.
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474239"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="e29a9-104">Meilleures pratiques pour la fiabilité</span><span class="sxs-lookup"><span data-stu-id="e29a9-104">Reliability Best Practices</span></span>

<span data-ttu-id="e29a9-105">Même si les règles de fiabilité suivantes concernent plus spécialement SQL Server, elles peuvent également s’appliquer à n’importe quelle application serveur basée sur l’hôte.</span><span class="sxs-lookup"><span data-stu-id="e29a9-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="e29a9-106">Il est extrêmement important d’éviter que les serveurs, tels que les serveurs SQL Server, soient victimes de fuite de ressources ou de panne.</span><span class="sxs-lookup"><span data-stu-id="e29a9-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="e29a9-107">Toutefois, il est impossible de le faire en écrivant du code réécrit pour chaque méthode qui modifie l’état d’un objet.</span><span class="sxs-lookup"><span data-stu-id="e29a9-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="e29a9-108">Le but n’est pas ici d’écrire du code managé totalement fiable et capable de récupérer des erreurs partout où elles se produisent avec du code réécrit.</span><span class="sxs-lookup"><span data-stu-id="e29a9-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="e29a9-109">Cette tâche relèverait pratiquement de l’impossible.</span><span class="sxs-lookup"><span data-stu-id="e29a9-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="e29a9-110">Le Common Language Runtime (CLR) ne peut offrir suffisamment de garanties quant à la possibilité d’écrire du code managé parfait.</span><span class="sxs-lookup"><span data-stu-id="e29a9-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="e29a9-111">Notez qu’à la différence d’ASP.NET, SQL Server utilise un seul processus qui ne peut pas être recyclé sans mettre une base de données hors connexion pendant une durée inacceptable.</span><span class="sxs-lookup"><span data-stu-id="e29a9-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="e29a9-112">Compte tenu de l’insuffisance de garanties offertes et de l’exécution au sein d’un seul processus, la fiabilité est fondée sur la possibilité d’arrêter des threads ou de recycler des domaines d’application chaque fois que nécessaire et de prendre des mesures adéquates assurant l’absence de fuites de ressources de système d’exploitation telles que les handles ou la mémoire.</span><span class="sxs-lookup"><span data-stu-id="e29a9-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="e29a9-113">Même avec cette contrainte de fiabilité plus simple, il existe encore d’autres exigences importantes concernant la fiabilité :</span><span class="sxs-lookup"><span data-stu-id="e29a9-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="e29a9-114">Il ne doit jamais y avoir de fuite de ressources du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="e29a9-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="e29a9-115">Tous les verrous managés, sous toutes leurs formes, doivent être identifiés pour le CLR.</span><span class="sxs-lookup"><span data-stu-id="e29a9-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="e29a9-116">L’état partagé entre les domaines d’application ne doit jamais être interrompu pour permettre au recyclage de <xref:System.AppDomain> de se dérouler correctement.</span><span class="sxs-lookup"><span data-stu-id="e29a9-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="e29a9-117">Bien qu’il soit théoriquement possible d’écrire du code managé pour gérer des exceptions <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> et <xref:System.OutOfMemoryException>, il est pratiquement impossible que les développeurs réussissent à écrire du code aussi robuste dans toute une application.</span><span class="sxs-lookup"><span data-stu-id="e29a9-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="e29a9-118">C’est la raison pour laquelle des exceptions hors plage mettent un terme au thread en cours d’exécution et, si le thread interrompu était en train de modifier l’état partagé (ce qui peut être déterminé par la présence d’un verrou sur le thread), <xref:System.AppDomain> est déchargé.</span><span class="sxs-lookup"><span data-stu-id="e29a9-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="e29a9-119">Quand une méthode qui modifie l’état partagé est arrêtée, l’état est endommagé parce qu’il n’est pas possible d’écrire du code réécrit fiable pour les mises à jour apportées à l’état partagé.</span><span class="sxs-lookup"><span data-stu-id="e29a9-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="e29a9-120">Dans .NET Framework version 2.0, SQL Server est le seul hôte pour lequel la fiabilité est indispensable.</span><span class="sxs-lookup"><span data-stu-id="e29a9-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="e29a9-121">Si votre assembly est exécuté sur SQL Server, vous devez faire en sorte que chaque partie de cet assembly soit fiable, même si des fonctionnalités spécifiques sont désactivées pendant leur exécution dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="e29a9-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="e29a9-122">En effet, le moteur d’analyse du code examine le code au niveau de l’assembly et ne peut pas identifier du code désactivé.</span><span class="sxs-lookup"><span data-stu-id="e29a9-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="e29a9-123">Un autre élément à prendre en compte dans la programmation SQL Server est le fait que SQL Server exécute tout dans un seul processus et le recyclage de <xref:System.AppDomain> est utilisé pour nettoyer toutes les ressources telles que la mémoire ou les handles du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="e29a9-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="e29a9-124">Vous ne pouvez pas compter sur des finaliseurs, des destructeurs ou des blocs `try/finally` pour du code réécrit,</span><span class="sxs-lookup"><span data-stu-id="e29a9-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="e29a9-125">car ils peuvent être interrompus ou ne pas être appelés.</span><span class="sxs-lookup"><span data-stu-id="e29a9-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="e29a9-126">Les exceptions asynchrones peuvent être levées dans des emplacements inattendus, parfois même dans chaque instruction machine : <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> et <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="e29a9-127">Les threads gérés ne sont pas nécessairement des threads Win32 dans SQL ; il peut s’agir de fibres.</span><span class="sxs-lookup"><span data-stu-id="e29a9-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="e29a9-128">La modification sans risque de l’état partagé mutable au niveau du processus ou du domaine d’application est pratiquement impossible et doit donc être évitée dans la mesure du possible.</span><span class="sxs-lookup"><span data-stu-id="e29a9-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="e29a9-129">Les conditions de mémoire insuffisante ne sont pas rares dans SQL Server.</span><span class="sxs-lookup"><span data-stu-id="e29a9-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="e29a9-130">Si les bibliothèques hébergées dans SQL Server ne mettent pas correctement à jour leur état partagé, il est fort probable que le code ne récupère pas tant que la base de données n’a pas été redémarrée.</span><span class="sxs-lookup"><span data-stu-id="e29a9-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="e29a9-131">Dans quelques cas extrêmes, il est également possible que cela provoque l’échec du processus SQL Server, et donc le redémarrage de la base de données.</span><span class="sxs-lookup"><span data-stu-id="e29a9-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="e29a9-132">Le redémarrage de la base de données peut entraîner la mise hors service d’un site web ou affecter les opérations de la société, et donc la disponibilité.</span><span class="sxs-lookup"><span data-stu-id="e29a9-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="e29a9-133">Dans le cas d’une fuite lente des ressources du système d’exploitation, telles que la mémoire ou les handles, il se peut que le serveur ne parvienne plus à allouer des handles, sans possibilité de récupération, ou que ses performances diminuent lentement et finissent par réduire la disponibilité de l’application d’un client.</span><span class="sxs-lookup"><span data-stu-id="e29a9-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="e29a9-134">Ce sont là des scénarios qu’il faut éviter à tout prix.</span><span class="sxs-lookup"><span data-stu-id="e29a9-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="e29a9-135">Règles relatives aux meilleures pratiques</span><span class="sxs-lookup"><span data-stu-id="e29a9-135">Best practice rules</span></span>

<span data-ttu-id="e29a9-136">L’introduction traitait des exceptions que la revue du code managé exécuté sur le serveur devait intercepter afin d’améliorer la stabilité et la fiabilité du framework.</span><span class="sxs-lookup"><span data-stu-id="e29a9-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="e29a9-137">Toutes ces vérifications sont généralement conseillées à tous les niveaux, mais sont absolument obligatoires sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="e29a9-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="e29a9-138">Confronté à un blocage ou une contrainte de ressource, SQL Server abandonne un thread ou détruit un <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="e29a9-139">Quand c’est le cas, seule l’exécution de code réécrit dans une région d’exécution limitée est garantie.</span><span class="sxs-lookup"><span data-stu-id="e29a9-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="e29a9-140">Utiliser SafeHandle pour éviter les fuites de ressources</span><span class="sxs-lookup"><span data-stu-id="e29a9-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="e29a9-141">Dans le cas d’un déchargement de <xref:System.AppDomain>, il n’est pas certain que des blocs `finally` ou des finaliseurs soient exécutés ; il est donc important d’effectuer une abstraction de l’accès à toutes les ressources du système d’exploitation via la classe <xref:System.Runtime.InteropServices.SafeHandle> au lieu de la classe <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef> ou classes similaires.</span><span class="sxs-lookup"><span data-stu-id="e29a9-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="e29a9-142">Cela permet au CLR de suivre et de fermer les handles que vous utilisez même dans le cas de destruction <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="e29a9-143"><xref:System.Runtime.InteropServices.SafeHandle> utilise un finaliseur critique que le CLR exécute toujours.</span><span class="sxs-lookup"><span data-stu-id="e29a9-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="e29a9-144">Le handle du système d’exploitation est stocké dans le handle sécurisé à partir du moment où il est créé jusqu’au moment où il est libéré.</span><span class="sxs-lookup"><span data-stu-id="e29a9-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="e29a9-145">Il n’existe aucune fenêtre pendant laquelle une <xref:System.Threading.ThreadAbortException> peut se produire et provoquer une fuite du handle.</span><span class="sxs-lookup"><span data-stu-id="e29a9-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="e29a9-146">De plus, l’appel de code non managé effectue un décompte de références du handle, ce qui permet d’effectuer un suivi précis de la durée de vie du handle. Vous évitez ainsi de rencontrer un problème de sécurité liée à une condition de concurrence critique entre `Dispose` et une méthode utilisant le handle.</span><span class="sxs-lookup"><span data-stu-id="e29a9-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="e29a9-147">La plupart des classes qui ont un finaliseur chargé de nettoyer simplement un handle de système d’exploitation n’ont plus besoin du finaliseur.</span><span class="sxs-lookup"><span data-stu-id="e29a9-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="e29a9-148">Au lieu de cela, le finaliseur est sur la classe dérivée <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="e29a9-149">Notez que <xref:System.Runtime.InteropServices.SafeHandle> ne remplace pas <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="e29a9-150">La suppression explicite des ressources du système d’exploitation présente encore des avantages concernant le niveau de performance, mais aussi des risques de contention de ressources.</span><span class="sxs-lookup"><span data-stu-id="e29a9-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="e29a9-151">Vous devez simplement savoir que les blocs `finally` qui suppriment explicitement des ressources peuvent ne pas arriver au terme de leur exécution.</span><span class="sxs-lookup"><span data-stu-id="e29a9-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="e29a9-152"><xref:System.Runtime.InteropServices.SafeHandle> vous permet d’implémenter votre propre méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> destinée à libérer le handle, en passant par exemple l’état à une routine de libération du handle du système d’exploitation ou en libérant un ensemble de handles dans une boucle.</span><span class="sxs-lookup"><span data-stu-id="e29a9-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="e29a9-153">Le CLR garantit l’exécution de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="e29a9-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="e29a9-154">Il incombe à l’auteur de l’implémentation de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> de garantir la libération du handle dans toutes les circonstances.</span><span class="sxs-lookup"><span data-stu-id="e29a9-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="e29a9-155">Si ce n’est pas le cas,une fuite du handle se produit, souvent associée à la fuite des ressources natives qui lui sont associées.</span><span class="sxs-lookup"><span data-stu-id="e29a9-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="e29a9-156">Ainsi, il est essentiel de structurer des classes dérivées <xref:System.Runtime.InteropServices.SafeHandle> de telle sorte que l’implémentation de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> ne nécessite pas l’allocation de ressources qui ne seront peut-être pas disponibles au moment de l’appel.</span><span class="sxs-lookup"><span data-stu-id="e29a9-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="e29a9-157">Notez que l’appel à des méthodes susceptibles d’échouer dans l’implémentation de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> est admis pour autant que votre code puisse gérer de tels échecs et achever le contrat pour libérer le handle natif.</span><span class="sxs-lookup"><span data-stu-id="e29a9-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="e29a9-158">À des fins de débogage, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> a une valeur de retour de type <xref:System.Boolean> à laquelle il est possible d’affecter la valeur `false` si une erreur grave se produit et empêche la libération de la ressource.</span><span class="sxs-lookup"><span data-stu-id="e29a9-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="e29a9-159">Cela active l’Assistant Débogage managé (MDA) de [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md), s’il est activé, pour vous permettre d’identifier le problème.</span><span class="sxs-lookup"><span data-stu-id="e29a9-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="e29a9-160">Il n’affecte le runtime d’aucune autre façon ; la méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> n’est plus appelée pour la même ressource et, en conséquence, une fuite du handle se produit.</span><span class="sxs-lookup"><span data-stu-id="e29a9-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="e29a9-161">L’utilisation de <xref:System.Runtime.InteropServices.SafeHandle> n’est pas appropriée dans certains contextes.</span><span class="sxs-lookup"><span data-stu-id="e29a9-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="e29a9-162">Dans la mesure où la méthode <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> peut être exécutée sur un thread finaliseur <xref:System.GC> tous les handles qui doivent être libérés sur un thread particulier ne doivent pas être encapsulés dans <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="e29a9-163">Les wrappers RCW (Runtime Callable Wrapper) peuvent être nettoyés par le CLR sans code supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="e29a9-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="e29a9-164">Pour le code qui utilise un appel de code non managé et traite un objet COM comme un `IUnknown*` ou un <xref:System.IntPtr>, le code doit être réécrit pour utiliser un RCW.</span><span class="sxs-lookup"><span data-stu-id="e29a9-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="e29a9-165"><xref:System.Runtime.InteropServices.SafeHandle> peut ne pas être adéquat pour ce scénario en raison de la possibilité d’un rappel dans le code managé par une méthode de libération non managée.</span><span class="sxs-lookup"><span data-stu-id="e29a9-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-166">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-166">Code analysis rule</span></span>

<span data-ttu-id="e29a9-167">Utilisez <xref:System.Runtime.InteropServices.SafeHandle> pour encapsuler des ressources de système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="e29a9-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="e29a9-168">N’utilisez pas <xref:System.Runtime.InteropServices.HandleRef> ou des champs de type <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="e29a9-169">S’assurer que les finaliseurs n’ont pas à s’exécuter pour empêcher la fuite des ressources du système d’exploitation</span><span class="sxs-lookup"><span data-stu-id="e29a9-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="e29a9-170">Vérifiez soigneusement vos finaliseurs pour éviter, même s’ils ne s’exécutent pas, une fuite d’une ressource du système d’exploitation critique.</span><span class="sxs-lookup"><span data-stu-id="e29a9-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="e29a9-171">Contrairement à un déchargement normal de <xref:System.AppDomain> quand l’application s’exécute dans un état stable ou qu’un serveur tel que SQL Server s’arrête, les objets ne sont pas finalisés durant un déchargement inattendu de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="e29a9-172">Vérifiez l’absence de fuite de ressources dans le cas d’un déchargement soudain, puisque l’état correct d’une application ne peut plus être garanti, mais qu’il faut préserver l’intégrité du serveur en évitant une fuite des ressources.</span><span class="sxs-lookup"><span data-stu-id="e29a9-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="e29a9-173">Utilisez <xref:System.Runtime.InteropServices.SafeHandle> pour libérer les ressources du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="e29a9-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="e29a9-174">Assurez-vous que les clauses finally n’ont pas besoin de s’exécuter pour empêcher la fuite des ressources du système d’exploitation</span><span class="sxs-lookup"><span data-stu-id="e29a9-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="e29a9-175">Comme rien ne garantit que les clauses `finally` puissent s’exécuter en dehors de régions d’exécution limitée, les développeurs de bibliothèque ne peuvent pas compter sur le code d’un bloc `finally` pour libérer des ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="e29a9-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="e29a9-176">L’utilisation de <xref:System.Runtime.InteropServices.SafeHandle> est la solution recommandée.</span><span class="sxs-lookup"><span data-stu-id="e29a9-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-177">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-177">Code analysis rule</span></span>

<span data-ttu-id="e29a9-178">Utilisez <xref:System.Runtime.InteropServices.SafeHandle> pour nettoyer des ressources de système d’exploitation au lieu de `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="e29a9-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="e29a9-179">N’utilisez pas <xref:System.IntPtr>, mais plutôt <xref:System.Runtime.InteropServices.SafeHandle> pour encapsuler des ressources.</span><span class="sxs-lookup"><span data-stu-id="e29a9-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="e29a9-180">Si la clause finally doit être exécutée, placez-la dans une région d’exécution limitée.</span><span class="sxs-lookup"><span data-stu-id="e29a9-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="e29a9-181">Tous les verrous doivent traverser le code de verrouillage géré existant</span><span class="sxs-lookup"><span data-stu-id="e29a9-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="e29a9-182">Le CLR doit pouvoir identifier du code placé dans un verrou afin de détruire <xref:System.AppDomain> au lien d’interrompre simplement le thread.</span><span class="sxs-lookup"><span data-stu-id="e29a9-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="e29a9-183">L’abandon du thread peut être dangereux dans la mesure où les données manipulées par le thread peuvent être laissées dans un état incohérent.</span><span class="sxs-lookup"><span data-stu-id="e29a9-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="e29a9-184">Ainsi, <xref:System.AppDomain> doit être recyclé dans son intégralité.</span><span class="sxs-lookup"><span data-stu-id="e29a9-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="e29a9-185">L’impossibilité d’identifier un verrou peut se traduire par des interblocages ou des résultats incorrects.</span><span class="sxs-lookup"><span data-stu-id="e29a9-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="e29a9-186">Utilisez les méthodes <xref:System.Threading.Thread.BeginCriticalRegion%2A> et <xref:System.Threading.Thread.EndCriticalRegion%2A> pour identifier des régions de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="e29a9-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="e29a9-187">Il s’agit de méthodes statiques sur la classe <xref:System.Threading.Thread> qui s’appliquent uniquement au thread actif, permettant d’éviter qu’un thread modifie le nombre de verrous d’un autre thread.</span><span class="sxs-lookup"><span data-stu-id="e29a9-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="e29a9-188">La notification CLR étant intégrée à <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> leur utilisation est recommandée de même que celle de l’[instruction lock](../../csharp/language-reference/keywords/lock-statement.md), qui utilise ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="e29a9-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="e29a9-189">D’autres mécanismes de verrouillage tels que les verrouillages spinlock et <xref:System.Threading.AutoResetEvent> doivent appeler ces méthodes pour notifier le CLR de l’entrée dans une section critique.</span><span class="sxs-lookup"><span data-stu-id="e29a9-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="e29a9-190">Ces méthodes ne prennent pas de verrous ; elles informent le CLR que le code s’exécute dans une section critique et que l’abandon du thread peut provoquer un état partagé incohérent.</span><span class="sxs-lookup"><span data-stu-id="e29a9-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="e29a9-191">Si vous avez défini votre propre type de verrou, tel qu’une classe <xref:System.Threading.ReaderWriterLock> personnalisée, utilisez ces méthodes de décompte de verrous.</span><span class="sxs-lookup"><span data-stu-id="e29a9-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-192">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-192">Code analysis rule</span></span>

<span data-ttu-id="e29a9-193">Marquez et identifiez tous les verrous à l’aide de <xref:System.Threading.Thread.BeginCriticalRegion%2A> et de <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="e29a9-194">N’utilisez pas <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A> et <xref:System.Threading.Interlocked.Decrement%2A> dans une boucle.</span><span class="sxs-lookup"><span data-stu-id="e29a9-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="e29a9-195">N’effectuez pas d’appel de code non managé des variantes Win32 de ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="e29a9-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="e29a9-196">N’utilisez pas <xref:System.Threading.Thread.Sleep%2A> dans une boucle.</span><span class="sxs-lookup"><span data-stu-id="e29a9-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="e29a9-197">N’utilisez pas de champs volatils.</span><span class="sxs-lookup"><span data-stu-id="e29a9-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="e29a9-198">Le code de nettoyage doit être dans un bloc finally ou catch, et non après une commande catch</span><span class="sxs-lookup"><span data-stu-id="e29a9-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="e29a9-199">Le code de nettoyage ne doit jamais suivre un bloc `catch` ; il doit se trouver dans un bloc `finally` ou dans le bloc `catch` lui-même.</span><span class="sxs-lookup"><span data-stu-id="e29a9-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="e29a9-200">Il s’agit là d’une bonne pratique à respecter.</span><span class="sxs-lookup"><span data-stu-id="e29a9-200">This should be a normal good practice.</span></span> <span data-ttu-id="e29a9-201">Le choix se porte généralement sur un bloc `finally` dans la mesure où il exécute le même code à la fois au moment de la levée d’une exception et à la fin escomptée du bloc `try`.</span><span class="sxs-lookup"><span data-stu-id="e29a9-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="e29a9-202">Dans le cas où une exception inattendue est levée, par exemple <xref:System.Threading.ThreadAbortException>, le code de nettoyage ne s’exécute pas.</span><span class="sxs-lookup"><span data-stu-id="e29a9-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="e29a9-203">Toutes les ressources non managées que vous nettoyez dans un bloc `finally` doivent idéalement être encapsulées dans un <xref:System.Runtime.InteropServices.SafeHandle> pour éviter des fuites.</span><span class="sxs-lookup"><span data-stu-id="e29a9-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="e29a9-204">Notez que le mot clé `using` C# permet de supprimer efficacement des objets, y compris les handles.</span><span class="sxs-lookup"><span data-stu-id="e29a9-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="e29a9-205">Bien que le recyclage de <xref:System.AppDomain> puisse nettoyer des ressources sur le thread finaliseur, il est néanmoins important de placer le code de nettoyage à l’emplacement adéquat.</span><span class="sxs-lookup"><span data-stu-id="e29a9-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="e29a9-206">Notez que si un thread reçoit une exception asynchrone sans détenir de verrou, le CLR tente de terminer le thread lui-même sans devoir recycler <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="e29a9-207">Un nettoyage précoce des ressources garantit la disponibilité d’un plus grand nombre de ressources et permet de mieux gérer la durée de vie.</span><span class="sxs-lookup"><span data-stu-id="e29a9-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="e29a9-208">Si vous ne fermez pas explicitement un handle d’un fichier dans un chemin de code d’erreur quelconque puis attendez que le finaliseur <xref:System.Runtime.InteropServices.SafeHandle> le nettoie, à la prochaine exécution de votre code, il est possible que sa tentative d’accès au même fichier échoue si le finaliseur ne s’est pas encore exécuté.</span><span class="sxs-lookup"><span data-stu-id="e29a9-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="e29a9-209">Pour cette raison, il est important de vérifier que le code de nettoyage existe et fonctionne correctement. Cela permet une récupération plus rapide et propre en cas de défaillance, même si ce n’est pas indispensable à proprement parler.</span><span class="sxs-lookup"><span data-stu-id="e29a9-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-210">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-210">Code analysis rule</span></span>

<span data-ttu-id="e29a9-211">Le code de nettoyage après le bloc `catch` doit être dans un bloc `finally`.</span><span class="sxs-lookup"><span data-stu-id="e29a9-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="e29a9-212">Placez les appels à supprimer dans un bloc finally.</span><span class="sxs-lookup"><span data-stu-id="e29a9-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="e29a9-213">Les blocs `catch` doivent se terminer dans une clause throw ou rethrow.</span><span class="sxs-lookup"><span data-stu-id="e29a9-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="e29a9-214">Même s’il y a des exceptions, par exemple du code qui détecte s’il est possible d’établir une connexion réseau là où un grand nombre d’exceptions peuvent se produire, tout code exigeant l’interception d’une série d’exceptions dans des circonstances normales doit indiquer si le code doit être testé pour s’assurer de son exécution correcte.</span><span class="sxs-lookup"><span data-stu-id="e29a9-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="e29a9-215">L’état partagé mutable au niveau du processus entre des domaines d’application doit être éliminé ou utiliser une région d’exécution avec restriction</span><span class="sxs-lookup"><span data-stu-id="e29a9-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="e29a9-216">Comme mentionné dans l’introduction, il peut être très difficile d’écrire du code managé fiable pour surveiller l’état partagé au niveau du processus entre des domaines d’application.</span><span class="sxs-lookup"><span data-stu-id="e29a9-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="e29a9-217">L’état partagé au niveau du processus représente une structure de données quelconque partagée entre des domaines d’application, dans du code Win32, à l’intérieur du CLR ou dans du code managé à l’aide de la communication à distance.</span><span class="sxs-lookup"><span data-stu-id="e29a9-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="e29a9-218">Il est très difficile d’écrire un état partagé mutable correctement dans du code managé et un état partagé statique ne peut être écrit qu’en prenant de grandes précautions.</span><span class="sxs-lookup"><span data-stu-id="e29a9-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="e29a9-219">Si vous avez un état partagé au niveau du processus ou de la machine, cherchez un moyen de l’éliminer ou de le protéger à l’aide d’une région d’exécution limitée.</span><span class="sxs-lookup"><span data-stu-id="e29a9-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="e29a9-220">Notez qu’une bibliothèque avec un état partagé qui n’est pas identifiée et corrigée peut provoquer la défaillance d’un hôte, tel que SQL Server, qui exige un déchargement propre de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="e29a9-221">Si le code utilise un objet COM, évitez de partager cet objet COM entre des domaines d’application.</span><span class="sxs-lookup"><span data-stu-id="e29a9-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="e29a9-222">Les verrous ne fonctionnent pas au niveau du processus ou entre des domaines d’application.</span><span class="sxs-lookup"><span data-stu-id="e29a9-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="e29a9-223">Auparavant, on utilisait <xref:System.Threading.Monitor.Enter%2A> et l’[instruction lock](../../csharp/language-reference/keywords/lock-statement.md) pour créer des verrous de processus globaux.</span><span class="sxs-lookup"><span data-stu-id="e29a9-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="e29a9-224">Cela se produit, par exemple, au moment d’un verrouillage sur des classes agiles <xref:System.AppDomain>, telles que des instances de <xref:System.Type> provenant d’assemblys non partagés, des objets <xref:System.Threading.Thread>, des chaînes internées et certaines chaînes partagées entre des domaines d’application à l’aide de la communication à distance.</span><span class="sxs-lookup"><span data-stu-id="e29a9-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="e29a9-225">Ces verrous ne sont plus placés au niveau du processus.</span><span class="sxs-lookup"><span data-stu-id="e29a9-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="e29a9-226">Pour identifier la présence d’un verrou de niveau processus entre domaines d’application, déterminez si le code du verrou utilise une ressource persistante externe, telle qu’un fichier sur le disque ou éventuellement une base de données.</span><span class="sxs-lookup"><span data-stu-id="e29a9-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="e29a9-227">Notez que l’acquisition d’un verrou dans un <xref:System.AppDomain> peut provoquer des problèmes si le code protégé utilise une ressource externe dans la mesure où ce code peut s’exécuter simultanément dans plusieurs domaines d’application.</span><span class="sxs-lookup"><span data-stu-id="e29a9-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="e29a9-228">Cela peut poser un problème au moment de l’écriture dans un fichier journal ou d’une liaison à un socket pour tout le processus.</span><span class="sxs-lookup"><span data-stu-id="e29a9-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="e29a9-229">Ces modifications montrent qu’il n’y a aucun moyen facile, à l’aide du code managé, d’obtenir un verrou au niveau du processus global, autre que celui consistant à utiliser une instance de <xref:System.Threading.Mutex> ou <xref:System.Threading.Semaphore> nommée.</span><span class="sxs-lookup"><span data-stu-id="e29a9-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="e29a9-230">Créez du code qui ne s’exécute pas simultanément dans deux domaines d’application ou utilisez les classes <xref:System.Threading.Mutex> ou <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="e29a9-231">Si le code existant ne peut pas être changé, n’utilisez pas un mutex Win32 nommé pour accomplir cette synchronisation. En effet, durant une exécution en mode fibre, vous ne pouvez pas garantir que le même thread de système d’exploitation acquerra et libérera un mutex.</span><span class="sxs-lookup"><span data-stu-id="e29a9-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="e29a9-232">Vous devez utiliser la classe <xref:System.Threading.Mutex> managée, un <xref:System.Threading.ManualResetEvent> nommé, <xref:System.Threading.AutoResetEvent> ou un <xref:System.Threading.Semaphore> pour synchroniser le verrou de code d’une façon reconnue par le CLR au lieu de synchroniser le verrou à l’aide de code non managé.</span><span class="sxs-lookup"><span data-stu-id="e29a9-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="e29a9-233">Évitez d’utiliser lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="e29a9-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="e29a9-234">Les objets <xref:System.Type> privés et publics dans les assemblys partagés avec une seule copie du code partagée dans tous les domaines d’application posent également des problèmes.</span><span class="sxs-lookup"><span data-stu-id="e29a9-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="e29a9-235">Pour les assemblys partagés, il n’existe qu’une seule instance de <xref:System.Type> par processus, ce qui signifie que plusieurs domaines d’application partagent la même instance de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="e29a9-236">L’acquisition d’un verrou sur une instance de <xref:System.Type> place un verrou qui affecte tout le processus, et pas seulement le <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="e29a9-237">Si un <xref:System.AppDomain> acquiert un verrou sur un objet <xref:System.Type>, ce thread est subitement interrompu et ne libère pas le verrou.</span><span class="sxs-lookup"><span data-stu-id="e29a9-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="e29a9-238">Ce verrou peut provoquer ensuite l’interblocage d’autres domaines d’application.</span><span class="sxs-lookup"><span data-stu-id="e29a9-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="e29a9-239">Pour acquérir des verrous dans les méthodes statiques, une solution intéressante consiste à ajouter un objet de synchronisation interne statique au code.</span><span class="sxs-lookup"><span data-stu-id="e29a9-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="e29a9-240">Cela peut être initialisé dans le constructeur de classe s’il en existe un, sinon, de la façon suivante :</span><span class="sxs-lookup"><span data-stu-id="e29a9-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="e29a9-241">Ensuite, quand vous acquérez un verrou, utilisez la propriété `InternalSyncObject` pour obtenir un objet à verrouiller.</span><span class="sxs-lookup"><span data-stu-id="e29a9-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="e29a9-242">Vous n’avez pas besoin d’utiliser la propriété si vous avez initialisé l’objet de synchronisation interne dans votre constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="e29a9-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="e29a9-243">Le code d’initialisation du verrou à double contrôle doit ressembler à l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="e29a9-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="e29a9-244">Note relative au verrouillage (this)</span><span class="sxs-lookup"><span data-stu-id="e29a9-244">A note about lock(this)</span></span>

<span data-ttu-id="e29a9-245">L’acquisition d’un verrou sur un objet individuel publiquement accessible est généralement admise.</span><span class="sxs-lookup"><span data-stu-id="e29a9-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="e29a9-246">Toutefois, si l’objet est un objet singleton susceptible de provoquer l’interblocage de l’ensemble d’un sous-système, envisagez d’utiliser également le modèle de conception précité.</span><span class="sxs-lookup"><span data-stu-id="e29a9-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="e29a9-247">Par exemple, un verrou sur l’objet <xref:System.Security.SecurityManager> peut provoquer un interblocage dans le <xref:System.AppDomain> rendant l’ensemble du <xref:System.AppDomain> inutilisable.</span><span class="sxs-lookup"><span data-stu-id="e29a9-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="e29a9-248">La bonne pratique consiste à ne pas acquérir de verrou sur un objet publiquement accessible de ce type.</span><span class="sxs-lookup"><span data-stu-id="e29a9-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="e29a9-249">En revanche, l’acquisition d’un verrou sur une collection ou un tableau individuel ne doit en principe pas poser de problème.</span><span class="sxs-lookup"><span data-stu-id="e29a9-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-250">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-250">Code analysis rule</span></span>

<span data-ttu-id="e29a9-251">N’acquérez pas de verrous sur des types qui peuvent être utilisés entre domaines d’application ou qui ne possèdent pas une identité forte.</span><span class="sxs-lookup"><span data-stu-id="e29a9-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="e29a9-252">N’appelez pas <xref:System.Threading.Monitor.Enter%2A> sur<xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread> ou tout objet dérivant de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="e29a9-253">Supprimez GC. Appels KeepAlive</span><span class="sxs-lookup"><span data-stu-id="e29a9-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="e29a9-254">Une partie importante de code existant n’utilise pas <xref:System.GC.KeepAlive%2A> quand il le devrait ou l’utilise de façon inappropriée.</span><span class="sxs-lookup"><span data-stu-id="e29a9-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="e29a9-255">Après une conversion vers <xref:System.Runtime.InteropServices.SafeHandle>, les classes n’ont pas besoin d’appeler <xref:System.GC.KeepAlive%2A>, en supposant qu’elles n’ont pas de finaliseur, mais qu’elles se fondent sur <xref:System.Runtime.InteropServices.SafeHandle> pour finaliser les handles du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="e29a9-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="e29a9-256">Si la conservation d’un appel à <xref:System.GC.KeepAlive%2A> a effectivement un impact négligeable sur les performances, il ne faut pas croire qu’un appel à <xref:System.GC.KeepAlive%2A> est nécessaire ou suffit à résoudre un problème de durée de vie qui n’existe peut-être plus. Le code n’en serait alors que plus difficile à gérer.</span><span class="sxs-lookup"><span data-stu-id="e29a9-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="e29a9-257">Toutefois, durant l’utilisation des wrappers RCW COM Interop, <xref:System.GC.KeepAlive%2A> est encore requis par le code.</span><span class="sxs-lookup"><span data-stu-id="e29a9-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-258">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-258">Code analysis rule</span></span>

<span data-ttu-id="e29a9-259">Supprimez <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="e29a9-260">Utiliser l’attribut HostProtection</span><span class="sxs-lookup"><span data-stu-id="e29a9-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="e29a9-261"><xref:System.Security.Permissions.HostProtectionAttribute> (HPA) autorise l’utilisation d’actions de sécurité déclarative pour déterminer les exigences de protection de l’hôte, ce qui permet à l’hôte d’empêcher du code, même d’un niveau de confiance totale, d’appeler certaines méthodes qui ne conviennent pas à l’hôte donné, par exemple <xref:System.Environment.Exit%2A> ou <xref:System.Windows.Forms.MessageBox.Show%2A> pour SQL Server.</span><span class="sxs-lookup"><span data-stu-id="e29a9-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="e29a9-262">Cet attribut HPA n’affecte que les applications non managées, telles que SQL Server, qui hébergent le common language runtime et implémentent la protection de l’hôte.</span><span class="sxs-lookup"><span data-stu-id="e29a9-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="e29a9-263">Quand elle s’applique, l’action de sécurité crée une demande de liaison sur la base des ressources hôte que la classe ou la méthode expose.</span><span class="sxs-lookup"><span data-stu-id="e29a9-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="e29a9-264">Si le code est exécuté dans une application cliente ou sur un serveur sans protection de l’hôte, l’attribut « s’évapore » ; non détecté, il ne peut pas s’appliquer.</span><span class="sxs-lookup"><span data-stu-id="e29a9-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e29a9-265">Cet attribut a pour but de permettre de suivre un modèle de programmation spécifique de l’hôte et non d’adopter un comportement de sécurité.</span><span class="sxs-lookup"><span data-stu-id="e29a9-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="e29a9-266">Bien qu’une demande de liaison vérifie la conformité aux exigences en termes de modèle de programmation, <xref:System.Security.Permissions.HostProtectionAttribute> n’est pas une autorisation de sécurité.</span><span class="sxs-lookup"><span data-stu-id="e29a9-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="e29a9-267">Si l’hôte n’a pas d’exigences de ce type, il n’y a pas de demande de liaison.</span><span class="sxs-lookup"><span data-stu-id="e29a9-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="e29a9-268">Cet attribut identifie les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="e29a9-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="e29a9-269">Méthodes ou classes qui ne correspondent pas au modèle de programmation hôte, mais sans gravité par ailleurs.</span><span class="sxs-lookup"><span data-stu-id="e29a9-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="e29a9-270">Méthodes ou classes qui ne correspondent pas au modèle de programmation hôte et pourraient déstabiliser le code utilisateur géré par le serveur.</span><span class="sxs-lookup"><span data-stu-id="e29a9-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="e29a9-271">Méthodes ou classes qui ne correspondent pas au modèle de programmation hôte et pourraient mener à une déstabilisation du processus serveur lui-même.</span><span class="sxs-lookup"><span data-stu-id="e29a9-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="e29a9-272">Si vous créez une bibliothèque de classes destinée à être appelée par des applications exécutables dans un environnement protégé par un hôte, vous devez appliquer cet attribut aux membres qui exposent des catégories de ressources <xref:System.Security.Permissions.HostProtectionResource>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="e29a9-273">Quand des membres de la bibliothèque de classes du .NET Framework ont cet attribut, seul l’appelant immédiat est vérifié.</span><span class="sxs-lookup"><span data-stu-id="e29a9-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="e29a9-274">Votre membre de bibliothèque doit également demander une vérification de son appelant immédiat de la même manière.</span><span class="sxs-lookup"><span data-stu-id="e29a9-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="e29a9-275">Pour plus d’informations sur l’attribut HPA, consultez <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-276">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-276">Code analysis rule</span></span>

<span data-ttu-id="e29a9-277">Pour SQL Server, toutes les méthodes utilisées pour introduire la synchronisation ou le threading doivent être identifiées avec l’attribut HPA.</span><span class="sxs-lookup"><span data-stu-id="e29a9-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="e29a9-278">Il s’agit notamment de méthodes qui partagent l’état, qui sont synchronisées ou gèrent des processus externes.</span><span class="sxs-lookup"><span data-stu-id="e29a9-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="e29a9-279">Les valeurs <xref:System.Security.Permissions.HostProtectionResource> qui concernent SQL Server sont <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization> et <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="e29a9-280">Toutefois, toute méthode exposant <xref:System.Security.Permissions.HostProtectionResource> doit être identifiée par un attribut HPA, pas seulement celles utilisant des ressources affectant SQL.</span><span class="sxs-lookup"><span data-stu-id="e29a9-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="e29a9-281">Ne pas bloquer indéfiniment dans du code non managé</span><span class="sxs-lookup"><span data-stu-id="e29a9-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="e29a9-282">Le blocage d’un thread dans du code non managé au lieu du code managé peut provoquer une attaque par déni de service, car le CLR n’est pas en mesure d’interrompre le thread.</span><span class="sxs-lookup"><span data-stu-id="e29a9-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="e29a9-283">Un thread bloqué empêche le CLR de décharger le <xref:System.AppDomain>, ou alors en exécutant des opérations très peu sécurisées.</span><span class="sxs-lookup"><span data-stu-id="e29a9-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="e29a9-284">Le blocage de l’utilisation d’une primitive de synchronisation Windows est un exemple clair d’un point que nous ne pouvons pas autoriser.</span><span class="sxs-lookup"><span data-stu-id="e29a9-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="e29a9-285">Le blocage dans un appel à `ReadFile` sur un socket doit être évité si possible. dans l’idéal, l’API Windows doit fournir un mécanisme pour qu’une opération comme celle-ci expire.</span><span class="sxs-lookup"><span data-stu-id="e29a9-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="e29a9-286">Toute méthode qui effectue des appels dans du code natif doit de préférence utiliser un appel Win32 avec un délai d’attente raisonnable et limité.</span><span class="sxs-lookup"><span data-stu-id="e29a9-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="e29a9-287">Si l’utilisateur est autorisé à spécifier le délai d’attente, il ne doit pas être autorisé à spécifier un délai d’attente infini sans une autorisation de sécurité spécifique.</span><span class="sxs-lookup"><span data-stu-id="e29a9-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="e29a9-288">À titre indicatif, si une méthode se bloque pendant plus de 10 secondes, vous devez utiliser une version qui prend en charge des délais d’attente ou vous avez besoin d’une assistance CLR supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="e29a9-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="e29a9-289">Voici quelques exemples d’API problématiques.</span><span class="sxs-lookup"><span data-stu-id="e29a9-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="e29a9-290">Les canaux (à la fois anonymes et nommés) peuvent être créés avec un délai d’attente ; toutefois, le code doit vérifier qu’il n’appelle jamais `CreateNamedPipe` ni `WaitNamedPipe` avec NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="e29a9-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="e29a9-291">De plus, un blocage inattendu peut survenir même si un délai d’attente est spécifié.</span><span class="sxs-lookup"><span data-stu-id="e29a9-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="e29a9-292">L’appel à `WriteFile` sur un canal anonyme se bloque jusqu’à ce que tous les octets aient été écrits. En d’autres termes, si la mémoire tampon a des données non lues, l’appel à `WriteFile` se bloque tant que le lecteur n’a pas libéré d’espace dans la mémoire tampon du canal.</span><span class="sxs-lookup"><span data-stu-id="e29a9-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="e29a9-293">Les sockets doivent toujours utiliser une API qui applique un mécanisme de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="e29a9-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-294">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-294">Code analysis rule</span></span>

<span data-ttu-id="e29a9-295">Un blocage sans délai d’attente dans du code non managé constitue une attaque par déni de service.</span><span class="sxs-lookup"><span data-stu-id="e29a9-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="e29a9-296">N’exécutez pas des appels de code non managé à `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects` et `MsgWaitForMultipleObjectsEx`.</span><span class="sxs-lookup"><span data-stu-id="e29a9-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="e29a9-297">N’utilisez pas NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="e29a9-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="e29a9-298">Identifier les fonctionnalités dépendantes du STA</span><span class="sxs-lookup"><span data-stu-id="e29a9-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="e29a9-299">Identifiez le code qui utilise les threads cloisonnés (STA) de COM.</span><span class="sxs-lookup"><span data-stu-id="e29a9-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="e29a9-300">Les threads cloisonnés sont désactivés dans le processus SQL Server.</span><span class="sxs-lookup"><span data-stu-id="e29a9-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="e29a9-301">Les fonctionnalités qui dépendent de `CoInitialize`, telles que les compteurs de performance ou le Presse-papiers, doivent être désactivées dans SQL Server.</span><span class="sxs-lookup"><span data-stu-id="e29a9-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="e29a9-302">Vérifier que les finaliseurs sont exempts de problèmes de synchronisation</span><span class="sxs-lookup"><span data-stu-id="e29a9-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="e29a9-303">Il est possible qu’il existe plusieurs threads finaliseurs dans les futures versions du .NET Framework, ce qui peut donner lieu à l’exécution simultanée de finaliseurs d’instances différentes du même type.</span><span class="sxs-lookup"><span data-stu-id="e29a9-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="e29a9-304">Ils ne doivent pas être complètement thread-safe ; le récupérateur de mémoire garantit qu’un seul thread à la fois exécute le finaliseur pour une instance d’objet donnée.</span><span class="sxs-lookup"><span data-stu-id="e29a9-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="e29a9-305">Toutefois, les finaliseurs doivent être codés pour éviter des conditions de concurrence critique et des interblocages durant leur exécution simultanée sur différentes instances d’objet.</span><span class="sxs-lookup"><span data-stu-id="e29a9-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="e29a9-306">Pendant l’utilisation d’un état externe, par exemple l’écriture dans un fichier journal, dans un finaliseur, les problèmes de threading doivent être gérés.</span><span class="sxs-lookup"><span data-stu-id="e29a9-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="e29a9-307">Ne comptez pas sur la finalisation pour garantir la cohérence de thread.</span><span class="sxs-lookup"><span data-stu-id="e29a9-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="e29a9-308">N’utilisez pas le stockage local des threads, managé ou natif, pour stocker l’état sur le thread finaliseur.</span><span class="sxs-lookup"><span data-stu-id="e29a9-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-309">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-309">Code analysis rule</span></span>

<span data-ttu-id="e29a9-310">Les finaliseurs ne doivent pas avoir de problèmes de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="e29a9-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="e29a9-311">N’utilisez pas un état mutable statique dans un finaliseur.</span><span class="sxs-lookup"><span data-stu-id="e29a9-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="e29a9-312">Évitez si possible la mémoire non managée</span><span class="sxs-lookup"><span data-stu-id="e29a9-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="e29a9-313">Il peut y avoir des fuites de mémoire non managée, comme pour un handle de système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="e29a9-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="e29a9-314">Si possible, essayez d’utiliser la mémoire sur la pile à l’aide de [stackalloc](../../csharp/language-reference/operators/stackalloc.md) ou d’un objet managé épinglé (par exemple, avec l’[instruction fixed](../../csharp/language-reference/keywords/fixed-statement.md)) ou un <xref:System.Runtime.InteropServices.GCHandle> utilisant un tableau d’octets (byte[]).</span><span class="sxs-lookup"><span data-stu-id="e29a9-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="e29a9-315"><xref:System.GC> finit par nettoyer ceux-ci.</span><span class="sxs-lookup"><span data-stu-id="e29a9-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="e29a9-316">Toutefois, si vous devez allouer de la mémoire non managée, envisagez d’utiliser une classe qui dérive de <xref:System.Runtime.InteropServices.SafeHandle> pour inclure l’allocation de mémoire dans un wrapper.</span><span class="sxs-lookup"><span data-stu-id="e29a9-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="e29a9-317">Notez que <xref:System.Runtime.InteropServices.SafeHandle> ne convient pas dans un cas au moins.</span><span class="sxs-lookup"><span data-stu-id="e29a9-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="e29a9-318">Pour les appels de méthode COM qui allouent ou libèrent de la mémoire, il est fréquent qu’une DLL alloue de la mémoire via `CoTaskMemAlloc`, puis qu’une autre DLL libère cette mémoire avec `CoTaskMemFree`.</span><span class="sxs-lookup"><span data-stu-id="e29a9-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="e29a9-319">Utiliser <xref:System.Runtime.InteropServices.SafeHandle> dans ces emplacements n’est pas adapté puisqu’il tente alors d’attacher la durée de vie de la mémoire non managée à la durée de vie de <xref:System.Runtime.InteropServices.SafeHandle> au lieu de laisser l’autre DLL contrôler la durée de vie de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="e29a9-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="e29a9-320">Passer en revue toutes les utilisations de catch (exception)</span><span class="sxs-lookup"><span data-stu-id="e29a9-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="e29a9-321">Les blocs catch qui interceptent toutes les exceptions au lieu d’une exception spécifique interceptent désormais aussi les exceptions asynchrones.</span><span class="sxs-lookup"><span data-stu-id="e29a9-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="e29a9-322">Examinez chaque bloc catch(Exception), en recherchant une libération de ressource peu importante ou du code réécrit qui peut être ignoré, ainsi qu’un comportement éventuellement incorrect dans le bloc catch lui-même pour gérer un <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> ou <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="e29a9-323">Notez qu’il est possible que ce code enregistre ou suppose qu’il ne peut consulter que certaines exceptions ou encore que chaque fois qu’une exception se produit, l’échec soit lié à une raison particulière.</span><span class="sxs-lookup"><span data-stu-id="e29a9-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="e29a9-324">Il se peut que ces hypothèses doivent être mises à jour pour inclure <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="e29a9-325">Envisagez de changer tous les emplacements qui interceptent toutes les exceptions pour qu’ils n’interceptent plus qu’un type spécifique d’exception dont vous prévoyez la levée, par exemple une exception <xref:System.FormatException> provenant des méthodes de mise en forme de chaînes.</span><span class="sxs-lookup"><span data-stu-id="e29a9-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="e29a9-326">Cela empêche le bloc catch de s’exécuter sur des exceptions inattendues et garantit que le code ne masque pas de bogues en interceptant des exceptions inattendues.</span><span class="sxs-lookup"><span data-stu-id="e29a9-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="e29a9-327">En règle générale, ne gérez jamais une exception dans du code de bibliothèque (du code exigeant que vous interceptiez une exception peut indiquer un défaut de conception dans le code que vous appelez).</span><span class="sxs-lookup"><span data-stu-id="e29a9-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="e29a9-328">Dans certains cas, vous pouvez souhaiter intercepter une exception et lever un type d’exception différent pour fournir plus de données.</span><span class="sxs-lookup"><span data-stu-id="e29a9-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="e29a9-329">Utilisez dans ce cas des exceptions imbriquées, en stockant la vraie cause de l’échec dans la propriété <xref:System.Exception.InnerException%2A> de la nouvelle exception.</span><span class="sxs-lookup"><span data-stu-id="e29a9-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-330">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-330">Code analysis rule</span></span>

<span data-ttu-id="e29a9-331">Examinez tous les blocs catch dans le code managé qui interceptent tous les objets ou toutes les exceptions.</span><span class="sxs-lookup"><span data-stu-id="e29a9-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="e29a9-332">En C#, cela signifie marquer à la fois `catch` {} et `catch(Exception)` {} .</span><span class="sxs-lookup"><span data-stu-id="e29a9-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="e29a9-333">Envisagez de définir un type d’exception très spécifique ou effectuez une revue du code pour garantir qu’il ne se comporte pas de façon incorrecte s’il intercepte un type d’exception inattendu.</span><span class="sxs-lookup"><span data-stu-id="e29a9-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="e29a9-334">Ne partez pas du principe qu’un thread managé est un thread Win32, car il s’agit d’une fibre</span><span class="sxs-lookup"><span data-stu-id="e29a9-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="e29a9-335">L’utilisation du stockage local des threads managés fonctionne, mais vous ne pourrez peut-être pas utiliser le stockage local des threads non managés ou supposer que le code se réexécutera sur le thread du système d’exploitation actuel.</span><span class="sxs-lookup"><span data-stu-id="e29a9-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="e29a9-336">Ne changez pas des paramètres tels que les paramètres régionaux du thread.</span><span class="sxs-lookup"><span data-stu-id="e29a9-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="e29a9-337">N’appelez pas `InitializeCriticalSection` ou `CreateMutex` via un appel de code non managé, car ils exigent que le thread du système d’exploitation qui est verrouillé puisse aussi être déverrouillé.</span><span class="sxs-lookup"><span data-stu-id="e29a9-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="e29a9-338">Comme cela n’est pas le cas pendant l’utilisation de fibres, des mutex et des sections critiques Win32 ne peuvent pas être utilisés directement dans SQL.</span><span class="sxs-lookup"><span data-stu-id="e29a9-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="e29a9-339">Notez que la classe <xref:System.Threading.Mutex> managée ne gère pas ces problèmes d’affinité de thread.</span><span class="sxs-lookup"><span data-stu-id="e29a9-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="e29a9-340">Vous pouvez utiliser sans risque la plupart des éléments d’état sur un objet <xref:System.Threading.Thread> managé, y compris le stockage local des threads managés et la culture actuelle de l’interface utilisateur du thread.</span><span class="sxs-lookup"><span data-stu-id="e29a9-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="e29a9-341">Vous pouvez également utiliser <xref:System.ThreadStaticAttribute>, qui permet uniquement au thread managé actif d’accéder à la valeur d’une variable statique existante (c’est là un autre moyen de procéder à un stockage local de fibres dans le CLR).</span><span class="sxs-lookup"><span data-stu-id="e29a9-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="e29a9-342">Pour des raisons liées au modèle de programmation, vous ne pouvez pas changer la culture actuelle d’un thread durant l’exécution dans SQL.</span><span class="sxs-lookup"><span data-stu-id="e29a9-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-343">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-343">Code analysis rule</span></span>

<span data-ttu-id="e29a9-344">SQL Server s’exécute en mode fibre ; n’utilisez pas le stockage local des threads.</span><span class="sxs-lookup"><span data-stu-id="e29a9-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="e29a9-345">Évitez les appels de code non managé à `TlsAlloc`, `TlsFree`, `TlsGetValue` et `TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="e29a9-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="e29a9-346">Laissez SQL Server gérer l’emprunt d’identité</span><span class="sxs-lookup"><span data-stu-id="e29a9-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="e29a9-347">Dans la mesure où l’emprunt d’identité fonctionne au niveau du thread et où SQL peut s’exécuter en mode fibre, le code managé ne doit pas emprunter l’identité d’utilisateurs et ne doit pas appeler `RevertToSelf`.</span><span class="sxs-lookup"><span data-stu-id="e29a9-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-348">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-348">Code analysis rule</span></span>

<span data-ttu-id="e29a9-349">Laissez SQL Server gérer l’emprunt d’identité.</span><span class="sxs-lookup"><span data-stu-id="e29a9-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="e29a9-350">N’utilisez pas `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx` ou `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="e29a9-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="e29a9-351">Ne pas appeler Thread :: suspend</span><span class="sxs-lookup"><span data-stu-id="e29a9-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="e29a9-352">Suspendre un thread peut sembler une opération simple, mais elle peut provoquer des interblocages.</span><span class="sxs-lookup"><span data-stu-id="e29a9-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="e29a9-353">Si un thread qui maintient un verrou est suspendu par un deuxième thread et que ce deuxième thread essaie de prendre le même verrou, un interblocage se produit.</span><span class="sxs-lookup"><span data-stu-id="e29a9-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="e29a9-354"><xref:System.Threading.Thread.Suspend%2A> peut interférer avec la sécurité, le chargement de classe, la communication à distance et la réflexion.</span><span class="sxs-lookup"><span data-stu-id="e29a9-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="e29a9-355">Règle d’analyse du code</span><span class="sxs-lookup"><span data-stu-id="e29a9-355">Code analysis rule</span></span>

<span data-ttu-id="e29a9-356">N’appelez pas <xref:System.Threading.Thread.Suspend%2A>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="e29a9-357">Envisagez d’utiliser à la place une vraie primitive de synchronisation, telle que <xref:System.Threading.Semaphore> ou <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="e29a9-358">Protéger les opérations critiques avec des régions d’exécution restreintes et des contrats de fiabilité</span><span class="sxs-lookup"><span data-stu-id="e29a9-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="e29a9-359">Pendant l’exécution d’une opération complexe qui met à jour un état partagé ou qui doit échouer ou réussir pleinement de façon déterministe, vérifiez si elle est protégée par une région d’exécution limitée.</span><span class="sxs-lookup"><span data-stu-id="e29a9-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="e29a9-360">Cela garantit l’exécution systématique du code, même dans le cas d’un abandon brusque de thread ou d’un déchargement soudain de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="e29a9-361">Une région d’exécution limitée est un bloc `try/finally` particulier, directement précédé par un appel à <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="e29a9-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="e29a9-362">Cette action indique au compilateur juste-à-temps de préparer tout le code dans le bloc finally avant d’exécuter le bloc `try`.</span><span class="sxs-lookup"><span data-stu-id="e29a9-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="e29a9-363">Cela garantit que le code du bloc finally est généré et s’exécute dans tous les cas.</span><span class="sxs-lookup"><span data-stu-id="e29a9-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="e29a9-364">Il n’est pas rare d’avoir un bloc `try` vide dans une région d’exécution limitée.</span><span class="sxs-lookup"><span data-stu-id="e29a9-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="e29a9-365">L’utilisation d’une région d’exécution limitée protège des abandons de threads asynchrones et des exceptions de mémoire insuffisante.</span><span class="sxs-lookup"><span data-stu-id="e29a9-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="e29a9-366">Consultez <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> pour obtenir une forme de région d’exécution limitée qui gère en plus des dépassements de la capacité de la pile pour du code très profond.</span><span class="sxs-lookup"><span data-stu-id="e29a9-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="e29a9-367">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="e29a9-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="e29a9-368">Attributs de programmation et de protection des hôtes SQL Server</span><span class="sxs-lookup"><span data-stu-id="e29a9-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
