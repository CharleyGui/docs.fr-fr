---
title: régions d'exécution limitée
ms.date: 03/30/2017
helpviewer_keywords:
- constrained execution regions
- CERs
ms.assetid: 99354547-39c1-4b0b-8553-938e8f8d1808
ms.openlocfilehash: 3161f77399030c287649ee5757814963b6afb7cf
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/23/2020
ms.locfileid: "85247725"
---
# <a name="constrained-execution-regions"></a><span data-ttu-id="43b41-102">régions d'exécution limitée</span><span class="sxs-lookup"><span data-stu-id="43b41-102">Constrained Execution Regions</span></span>
<span data-ttu-id="43b41-103">Une région d’exécution limitée (CER, Constrained Execution Region) fait partie d’un mécanisme pour la création de code managé fiable.</span><span class="sxs-lookup"><span data-stu-id="43b41-103">A constrained execution region (CER) is part of a mechanism for authoring reliable managed code.</span></span> <span data-ttu-id="43b41-104">Elle définit une zone dans laquelle le Common Language Runtime (CLR) ne peut pas lever d’exceptions hors-bande qui empêcheraient le code dans la zone de s’exécuter dans son intégralité.</span><span class="sxs-lookup"><span data-stu-id="43b41-104">A CER defines an area in which the common language runtime (CLR) is constrained from throwing out-of-band exceptions that would prevent the code in the area from executing in its entirety.</span></span> <span data-ttu-id="43b41-105">Dans cette région, le code utilisateur ne peut pas exécuter de code qui entraînerait la levée d’exceptions hors-bande.</span><span class="sxs-lookup"><span data-stu-id="43b41-105">Within that region, user code is constrained from executing code that would result in the throwing of out-of-band exceptions.</span></span> <span data-ttu-id="43b41-106">La méthode <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> doit précéder immédiatement un bloc `try`, et marque les blocs `catch`, `finally` et `fault` en tant que régions d’exécution limitée.</span><span class="sxs-lookup"><span data-stu-id="43b41-106">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method must immediately precede a `try` block and marks `catch`, `finally`, and `fault` blocks as constrained execution regions.</span></span> <span data-ttu-id="43b41-107">Une fois marqué comme région limitée, le code doit appeler uniquement du code avec des contrats de fiabilité forts, et il ne doit pas allouer ou effectuer des appels virtuels à des méthodes non préparées ou non fiables, sauf s’il est prêt à gérer les échecs.</span><span class="sxs-lookup"><span data-stu-id="43b41-107">Once marked as a constrained region, code must only call other code with strong reliability contracts, and code should not allocate or make virtual calls to unprepared or unreliable methods unless the code is prepared to handle failures.</span></span> <span data-ttu-id="43b41-108">Le CLR retarde les abandons de thread pour le code qui s’exécute dans une région CER.</span><span class="sxs-lookup"><span data-stu-id="43b41-108">The CLR delays thread aborts for code that is executing in a CER.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="43b41-109">CER est pris en charge uniquement dans .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="43b41-109">CER is only supported in .NET Framework.</span></span> <span data-ttu-id="43b41-110">Cet article ne s’applique pas à .NET Core ou .NET 5 et versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="43b41-110">This article doesn't apply to .NET Core or .NET 5 and above.</span></span>

 <span data-ttu-id="43b41-111">Les régions d’exécution limitée sont utilisées sous des formes différentes dans le CLR en plus d’un bloc `try` annoté, notamment sous forme de finaliseurs critiques exécutés dans des classes dérivées de la classe <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> et de code exécuté à l’aide de la méthode <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>.</span><span class="sxs-lookup"><span data-stu-id="43b41-111">Constrained execution regions are used in different forms in the CLR in addition to an annotated `try` block, notably critical finalizers executing in classes derived from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class and code executed using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.</span></span>  
  
## <a name="cer-advance-preparation"></a><span data-ttu-id="43b41-112">Préparation avancée de région CER</span><span class="sxs-lookup"><span data-stu-id="43b41-112">CER Advance Preparation</span></span>  
 <span data-ttu-id="43b41-113">Le CLR prépare les régions CER à l’avance pour éviter toute condition de mémoire insuffisante.</span><span class="sxs-lookup"><span data-stu-id="43b41-113">The CLR prepares CERs in advance to avoid out-of-memory conditions.</span></span> <span data-ttu-id="43b41-114">Une préparation est nécessaire pour que le CLR ne provoque pas d’insuffisance de mémoire pendant le chargement de type ou la compilation juste-à-temps.</span><span class="sxs-lookup"><span data-stu-id="43b41-114">Advance preparation is required so the CLR does not cause an out of memory condition during just-in-time compilation or type loading.</span></span>  
  
 <span data-ttu-id="43b41-115">Le développeur doit obligatoirement indiquer qu’une région de code est une région CER :</span><span class="sxs-lookup"><span data-stu-id="43b41-115">The developer is required to indicate that a code region is a CER:</span></span>  
  
- <span data-ttu-id="43b41-116">La région CER et les méthodes de niveau supérieur dans le graphique des appels complet auxquels l’attribut <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> est appliqué sont préparées à l’avance.</span><span class="sxs-lookup"><span data-stu-id="43b41-116">The top level CER region and methods in the full call graph that have the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute applied are prepared in advance.</span></span> <span data-ttu-id="43b41-117">Le <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> peut déclarer uniquement des garanties <xref:System.Runtime.ConstrainedExecution.Cer.Success> ou <xref:System.Runtime.ConstrainedExecution.Cer.MayFail>.</span><span class="sxs-lookup"><span data-stu-id="43b41-117">The <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> can only state guarantees of <xref:System.Runtime.ConstrainedExecution.Cer.Success> or <xref:System.Runtime.ConstrainedExecution.Cer.MayFail>.</span></span>  
  
- <span data-ttu-id="43b41-118">La préparation ne peut pas être effectuée pour les appels qui ne peuvent pas être déterminés statiquement, comme par exemple en cas de dispatch virtuel.</span><span class="sxs-lookup"><span data-stu-id="43b41-118">Advance preparation cannot be performed for calls that cannot be statically determined, such as virtual dispatch.</span></span> <span data-ttu-id="43b41-119">Dans ces cas-là, utilisez la méthode <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%2A>.</span><span class="sxs-lookup"><span data-stu-id="43b41-119">Use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%2A> method in these cases.</span></span> <span data-ttu-id="43b41-120">Quand vous utilisez la méthode <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>, l’attribut <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> doit être appliqué au code de nettoyage.</span><span class="sxs-lookup"><span data-stu-id="43b41-120">When using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method, the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute should be applied to the clean up code.</span></span>  
  
## <a name="constraints"></a><span data-ttu-id="43b41-121">Contraintes</span><span class="sxs-lookup"><span data-stu-id="43b41-121">Constraints</span></span>  
 <span data-ttu-id="43b41-122">Les utilisateurs sont limités quant au type de code qu’ils peuvent écrire dans une région CER.</span><span class="sxs-lookup"><span data-stu-id="43b41-122">Users are constrained in the type of code they can write in a CER.</span></span> <span data-ttu-id="43b41-123">Le code ne peut pas provoquer d’exceptions hors-bande, telles que celles dues aux opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="43b41-123">The code cannot cause an out-of-band exception, such as might result from the following operations:</span></span>  
  
- <span data-ttu-id="43b41-124">Allocation explicite</span><span class="sxs-lookup"><span data-stu-id="43b41-124">Explicit allocation.</span></span>  
  
- <span data-ttu-id="43b41-125">Boxing</span><span class="sxs-lookup"><span data-stu-id="43b41-125">Boxing.</span></span>  
  
- <span data-ttu-id="43b41-126">Acquisition d’un verrou</span><span class="sxs-lookup"><span data-stu-id="43b41-126">Acquiring a lock.</span></span>  
  
- <span data-ttu-id="43b41-127">Appel de méthodes non préparées de manière virtuelle</span><span class="sxs-lookup"><span data-stu-id="43b41-127">Calling unprepared methods virtually.</span></span>  
  
- <span data-ttu-id="43b41-128">Appel de méthodes avec un contrat de fiabilité faible ou inexistant</span><span class="sxs-lookup"><span data-stu-id="43b41-128">Calling methods with a weak or nonexistent reliability contract.</span></span>  
  
 <span data-ttu-id="43b41-129">Dans le .NET Framework version 2.0, ces contraintes sont des recommandations.</span><span class="sxs-lookup"><span data-stu-id="43b41-129">In the .NET Framework version 2.0, these constraints are guidelines.</span></span> <span data-ttu-id="43b41-130">Des diagnostics sont fournis par les outils d’analyse du code.</span><span class="sxs-lookup"><span data-stu-id="43b41-130">Diagnostics are provided through code analysis tools.</span></span>  
  
## <a name="reliability-contracts"></a><span data-ttu-id="43b41-131">Contrats de fiabilité</span><span class="sxs-lookup"><span data-stu-id="43b41-131">Reliability Contracts</span></span>  
 <span data-ttu-id="43b41-132"><xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> est un attribut personnalisé qui documente les garanties de fiabilité et l’état d’altération d’une méthode donnée.</span><span class="sxs-lookup"><span data-stu-id="43b41-132">The <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> is a custom attribute that documents the reliability guarantees and the corruption state of a given method.</span></span>  
  
### <a name="reliability-guarantees"></a><span data-ttu-id="43b41-133">Garanties de fiabilité</span><span class="sxs-lookup"><span data-stu-id="43b41-133">Reliability Guarantees</span></span>  
 <span data-ttu-id="43b41-134">Les garanties de fiabilité, représentées par des valeurs d’énumération <xref:System.Runtime.ConstrainedExecution.Cer>, indiquent le degré de fiabilité d’une méthode donnée :</span><span class="sxs-lookup"><span data-stu-id="43b41-134">Reliability guarantees, represented by <xref:System.Runtime.ConstrainedExecution.Cer> enumeration values, indicate the degree of reliability of a given method:</span></span>  
  
- <span data-ttu-id="43b41-135"><xref:System.Runtime.ConstrainedExecution.Cer.MayFail>.</span><span class="sxs-lookup"><span data-stu-id="43b41-135"><xref:System.Runtime.ConstrainedExecution.Cer.MayFail>.</span></span> <span data-ttu-id="43b41-136">Dans des conditions exceptionnelles, la méthode peut échouer.</span><span class="sxs-lookup"><span data-stu-id="43b41-136">Under exceptional conditions, the method might fail.</span></span> <span data-ttu-id="43b41-137">Dans ce cas, elle indique à la méthode appelante si elle a réussi ou échoué.</span><span class="sxs-lookup"><span data-stu-id="43b41-137">In this case, the method reports back to the calling method whether it succeeded or failed.</span></span> <span data-ttu-id="43b41-138">La méthode doit être contenue dans une région CER pour que vous soyez sûr qu’elle puisse signaler la valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="43b41-138">The method must be contained in a CER to ensure that it can report the return value.</span></span>  
  
- <span data-ttu-id="43b41-139"><xref:System.Runtime.ConstrainedExecution.Cer.None>.</span><span class="sxs-lookup"><span data-stu-id="43b41-139"><xref:System.Runtime.ConstrainedExecution.Cer.None>.</span></span> <span data-ttu-id="43b41-140">La méthode, le type et l’assembly n’ont aucun concept de région CER. Il est probablement risqué de les appeler dans une région CER sans atténuation substantielle contre les risques d’altération de l’état.</span><span class="sxs-lookup"><span data-stu-id="43b41-140">The method, type, or assembly has no concept of a CER and is most likely not safe to call within a CER without substantial mitigation from state corruption.</span></span> <span data-ttu-id="43b41-141">Ils ne tirent pas parti des garanties offertes par les régions CER.</span><span class="sxs-lookup"><span data-stu-id="43b41-141">It does not take advantage of CER guarantees.</span></span> <span data-ttu-id="43b41-142">Cela implique ce qui suit :</span><span class="sxs-lookup"><span data-stu-id="43b41-142">This implies the following:</span></span>  
  
    1. <span data-ttu-id="43b41-143">Dans des conditions exceptionnelles, la méthode peut échouer.</span><span class="sxs-lookup"><span data-stu-id="43b41-143">Under exceptional conditions the method might fail.</span></span>  
  
    2. <span data-ttu-id="43b41-144">La méthode ne signale pas nécessairement qu’elle a échoué.</span><span class="sxs-lookup"><span data-stu-id="43b41-144">The method might or might not report that it failed.</span></span>  
  
    3. <span data-ttu-id="43b41-145">La méthode n’est pas écrite pour utiliser une région CER, le scénario le plus probable.</span><span class="sxs-lookup"><span data-stu-id="43b41-145">The method is not written to use a CER, the most likely scenario.</span></span>  
  
    4. <span data-ttu-id="43b41-146">Si une méthode, un type ou un assembly n’est pas identifié de manière explicite pour réussir, il est implicitement identifié comme <xref:System.Runtime.ConstrainedExecution.Cer.None>.</span><span class="sxs-lookup"><span data-stu-id="43b41-146">If a method, type, or assembly is not explicitly identified to succeed, it is implicitly identified as <xref:System.Runtime.ConstrainedExecution.Cer.None>.</span></span>  
  
- <span data-ttu-id="43b41-147"><xref:System.Runtime.ConstrainedExecution.Cer.Success>.</span><span class="sxs-lookup"><span data-stu-id="43b41-147"><xref:System.Runtime.ConstrainedExecution.Cer.Success>.</span></span> <span data-ttu-id="43b41-148">Dans des conditions exceptionnelles, la réussite de la méthode est garantie.</span><span class="sxs-lookup"><span data-stu-id="43b41-148">Under exceptional conditions, the method is guaranteed to succeed.</span></span> <span data-ttu-id="43b41-149">Pour atteindre ce niveau de fiabilité, vous devez toujours construire une région CER autour de la méthode appelée, même quand elle est appelée dans une région non-CER.</span><span class="sxs-lookup"><span data-stu-id="43b41-149">To achieve this level of reliability you should always construct a CER around the method that is called, even when it is called from within a non-CER region.</span></span> <span data-ttu-id="43b41-150">Une méthode réussit si elle accomplit ce qui est prévu, bien que la réussite puisse être considérée comme subjective.</span><span class="sxs-lookup"><span data-stu-id="43b41-150">A method is successful if it accomplishes what is intended, although success can be viewed subjectively.</span></span> <span data-ttu-id="43b41-151">Par exemple, le fait de marquer Count avec `ReliabilityContractAttribute(Cer.Success)` implique qu’en cas d’exécution dans une région CER, elle retourne toujours le nombre d’éléments dans le <xref:System.Collections.ArrayList> et ne peut jamais laisser les champs internes dans un état indéterminé.</span><span class="sxs-lookup"><span data-stu-id="43b41-151">For example, marking Count with `ReliabilityContractAttribute(Cer.Success)` implies that when it is run under a CER, it always returns a count of the number of elements in the <xref:System.Collections.ArrayList> and it can never leave the internal fields in an undetermined state.</span></span>  <span data-ttu-id="43b41-152">Toutefois, la méthode <xref:System.Threading.Interlocked.CompareExchange%2A> est aussi marquée comme ayant réussi, étant entendu que la réussite peut signifier que la valeur n’a pas pu être remplacée par une nouvelle valeur à cause d’une condition de concurrence.</span><span class="sxs-lookup"><span data-stu-id="43b41-152">However, the <xref:System.Threading.Interlocked.CompareExchange%2A> method is marked as success as well, with the understanding that success may mean the value could not be replaced with a new value due to a race condition.</span></span>  <span data-ttu-id="43b41-153">Le point essentiel est que la méthode se comporte de la manière documentée, et que le code de région CER n’a pas besoin d’être écrit pour s’attendre à un comportement inhabituel au-delà de ce à quoi peut ressembler du code correct mais non fiable.</span><span class="sxs-lookup"><span data-stu-id="43b41-153">The key point is that the method behaves in the way it is documented to behave, and CER code does not need to be written to expect any unusual behavior beyond what correct but unreliable code would look like.</span></span>  
  
### <a name="corruption-levels"></a><span data-ttu-id="43b41-154">Niveaux d’altération</span><span class="sxs-lookup"><span data-stu-id="43b41-154">Corruption levels</span></span>  
 <span data-ttu-id="43b41-155">Les niveaux d’altération, représentés par des valeurs d’énumération <xref:System.Runtime.ConstrainedExecution.Consistency>, indiquent dans quelle mesure l’état peut être altéré dans un environnement donné :</span><span class="sxs-lookup"><span data-stu-id="43b41-155">Corruption levels, represented by <xref:System.Runtime.ConstrainedExecution.Consistency> enumeration values, indicate how much state may be corrupted in a given environment:</span></span>  
  
- <span data-ttu-id="43b41-156"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain>.</span><span class="sxs-lookup"><span data-stu-id="43b41-156"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain>.</span></span> <span data-ttu-id="43b41-157">Dans des conditions exceptionnelles, le CLR n’offre aucune garantie quant à la cohérence de l’état dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="43b41-157">Under exceptional conditions, the common language runtime (CLR) makes no guarantees regarding state consistency in the current application domain.</span></span>  
  
- <span data-ttu-id="43b41-158"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance>.</span><span class="sxs-lookup"><span data-stu-id="43b41-158"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance>.</span></span> <span data-ttu-id="43b41-159">Dans des conditions exceptionnelles, il est garanti que la méthode limite l’altération de l’état à l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="43b41-159">Under exceptional conditions, the method is guaranteed to limit state corruption to the current instance.</span></span>  
  
- <span data-ttu-id="43b41-160"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptProcess>. Dans des conditions exceptionnelles, le CLR n’offre aucune garantie quant à la cohérence de l’état. Autrement dit, la condition peut endommager le processus.</span><span class="sxs-lookup"><span data-stu-id="43b41-160"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptProcess>, Under exceptional conditions, the CLR makes no guarantees regarding state consistency; that is, the condition might corrupt the process.</span></span>  
  
- <span data-ttu-id="43b41-161"><xref:System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState>.</span><span class="sxs-lookup"><span data-stu-id="43b41-161"><xref:System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState>.</span></span> <span data-ttu-id="43b41-162">Dans des conditions exceptionnelles, il est garanti que la méthode n’altère pas l’état.</span><span class="sxs-lookup"><span data-stu-id="43b41-162">Under exceptional conditions, the method is guaranteed not to corrupt state.</span></span>  
  
## <a name="reliability-trycatchfinally"></a><span data-ttu-id="43b41-163">Bloc try/catch/finally de fiabilité</span><span class="sxs-lookup"><span data-stu-id="43b41-163">Reliability try/catch/finally</span></span>  
 <span data-ttu-id="43b41-164">Le bloc `try/catch/finally` de fiabilité est un mécanisme de gestion des exceptions offrant les mêmes garanties de prévisibilité que la version non managée.</span><span class="sxs-lookup"><span data-stu-id="43b41-164">The reliability `try/catch/finally` is an exception handling mechanism with the same level of predictability guarantees as the unmanaged version.</span></span> <span data-ttu-id="43b41-165">Le bloc `catch/finally` est la région CER.</span><span class="sxs-lookup"><span data-stu-id="43b41-165">The `catch/finally` block is the CER.</span></span> <span data-ttu-id="43b41-166">Les méthodes dans le bloc exigent une préparation et doivent être non interruptibles.</span><span class="sxs-lookup"><span data-stu-id="43b41-166">Methods in the block require advance preparation and must be noninterruptible.</span></span>  
  
 <span data-ttu-id="43b41-167">Dans le .NET Framework version 2.0, le code informe le runtime qu’une tentative est fiable en appelant <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> juste avant un bloc try.</span><span class="sxs-lookup"><span data-stu-id="43b41-167">In the .NET Framework version 2.0, code informs the runtime that a try is reliable by calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> immediately preceding a try block.</span></span> <span data-ttu-id="43b41-168"><xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> est un membre de <xref:System.Runtime.CompilerServices.RuntimeHelpers>, une classe de prise en charge du compilateur.</span><span class="sxs-lookup"><span data-stu-id="43b41-168"><xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> is a member of <xref:System.Runtime.CompilerServices.RuntimeHelpers>, a compiler support class.</span></span> <span data-ttu-id="43b41-169">Appelez <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> directement en attendant sa disponibilité par le biais des compilateurs.</span><span class="sxs-lookup"><span data-stu-id="43b41-169">Call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> directly pending its availability through compilers.</span></span>  
  
## <a name="noninterruptible-regions"></a><span data-ttu-id="43b41-170">Régions non interruptibles</span><span class="sxs-lookup"><span data-stu-id="43b41-170">Noninterruptible Regions</span></span>  
 <span data-ttu-id="43b41-171">Une région non interruptible regroupe un ensemble d’instructions dans une région CER.</span><span class="sxs-lookup"><span data-stu-id="43b41-171">A noninterruptible region groups a set of instructions into a CER.</span></span>  
  
 <span data-ttu-id="43b41-172">Dans le .NET Framework version 2.0, dans l’attente de la disponibilité par le biais de la prise en charge du compilateur, le code utilisateur crée des régions non interruptibles avec un bloc try/catch/finally fiable qui contient un bloc try/catch vide précédé d’un appel de méthode <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="43b41-172">In .NET Framework version 2.0, pending availability through compiler support, user code creates non-interruptible regions with a reliable try/catch/finally that contains an empty try/catch block preceded by a <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method call.</span></span>  
  
## <a name="critical-finalizer-object"></a><span data-ttu-id="43b41-173">Objet finaliseur critique</span><span class="sxs-lookup"><span data-stu-id="43b41-173">Critical Finalizer Object</span></span>  
 <span data-ttu-id="43b41-174">Un <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> garantit que le garbage collection exécutera le finaliseur.</span><span class="sxs-lookup"><span data-stu-id="43b41-174">A <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> guarantees that garbage collection will execute the finalizer.</span></span> <span data-ttu-id="43b41-175">Lors de l’allocation, le finaliseur et son graphique des appels sont préparés à l’avance.</span><span class="sxs-lookup"><span data-stu-id="43b41-175">Upon allocation, the finalizer and its call graph are prepared in advance.</span></span> <span data-ttu-id="43b41-176">La méthode de finaliseur s’exécute dans une région CER et doit respecter toutes les contraintes sur les régions CER et les finaliseurs.</span><span class="sxs-lookup"><span data-stu-id="43b41-176">The finalizer method executes in a CER, and must obey all the constraints on CERs and finalizers.</span></span>  
  
 <span data-ttu-id="43b41-177">Pour tout type héritant de <xref:System.Runtime.InteropServices.SafeHandle> et <xref:System.Runtime.InteropServices.CriticalHandle>, il est garanti que son finaliseur s’exécute dans une région CER.</span><span class="sxs-lookup"><span data-stu-id="43b41-177">Any types inheriting from <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> are guaranteed to have their finalizer execute within a CER.</span></span> <span data-ttu-id="43b41-178">Implémentez <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> dans les classes dérivées <xref:System.Runtime.InteropServices.SafeHandle> pour exécuter tout code devant libérer le handle.</span><span class="sxs-lookup"><span data-stu-id="43b41-178">Implement <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> in <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle.</span></span>  
  
## <a name="code-not-permitted-in-cers"></a><span data-ttu-id="43b41-179">Code non autorisé dans les régions CER</span><span class="sxs-lookup"><span data-stu-id="43b41-179">Code Not Permitted in CERs</span></span>  
 <span data-ttu-id="43b41-180">Les opérations suivantes ne sont pas autorisées dans les régions CER :</span><span class="sxs-lookup"><span data-stu-id="43b41-180">The following operations are not permitted in CERs:</span></span>  
  
- <span data-ttu-id="43b41-181">Allocations explicites</span><span class="sxs-lookup"><span data-stu-id="43b41-181">Explicit allocations.</span></span>  
  
- <span data-ttu-id="43b41-182">Acquisition d’un verrou</span><span class="sxs-lookup"><span data-stu-id="43b41-182">Acquiring a lock.</span></span>  
  
- <span data-ttu-id="43b41-183">Boxing</span><span class="sxs-lookup"><span data-stu-id="43b41-183">Boxing.</span></span>  
  
- <span data-ttu-id="43b41-184">Accès à un tableau multidimensionnel</span><span class="sxs-lookup"><span data-stu-id="43b41-184">Multidimensional array access.</span></span>  
  
- <span data-ttu-id="43b41-185">Appels de méthode par réflexion</span><span class="sxs-lookup"><span data-stu-id="43b41-185">Method calls through reflection.</span></span>  
  
- <span data-ttu-id="43b41-186"><xref:System.Threading.Monitor.Enter%2A> ou <xref:System.IO.FileStream.Lock%2A>.</span><span class="sxs-lookup"><span data-stu-id="43b41-186"><xref:System.Threading.Monitor.Enter%2A> or <xref:System.IO.FileStream.Lock%2A>.</span></span>  
  
- <span data-ttu-id="43b41-187">Vérifications de sécurité.</span><span class="sxs-lookup"><span data-stu-id="43b41-187">Security checks.</span></span> <span data-ttu-id="43b41-188">N’effectuez pas de demande, mais uniquement des demandes de liaison.</span><span class="sxs-lookup"><span data-stu-id="43b41-188">Do not perform demands, only link demands.</span></span>  
  
- <span data-ttu-id="43b41-189"><xref:System.Reflection.Emit.OpCodes.Isinst> et <xref:System.Reflection.Emit.OpCodes.Castclass> pour les proxys et les objets COM</span><span class="sxs-lookup"><span data-stu-id="43b41-189"><xref:System.Reflection.Emit.OpCodes.Isinst> and <xref:System.Reflection.Emit.OpCodes.Castclass> for COM objects and proxies</span></span>  
  
- <span data-ttu-id="43b41-190">Obtention ou définition de champs sur un proxy transparent.</span><span class="sxs-lookup"><span data-stu-id="43b41-190">Getting or setting fields on a transparent proxy.</span></span>  
  
- <span data-ttu-id="43b41-191">Sérialisation.</span><span class="sxs-lookup"><span data-stu-id="43b41-191">Serialization.</span></span>  
  
- <span data-ttu-id="43b41-192">Pointeurs de fonction et délégués.</span><span class="sxs-lookup"><span data-stu-id="43b41-192">Function pointers and delegates.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="43b41-193">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="43b41-193">See also</span></span>

- [<span data-ttu-id="43b41-194">Meilleures pratiques pour la fiabilité</span><span class="sxs-lookup"><span data-stu-id="43b41-194">Reliability Best Practices</span></span>](reliability-best-practices.md)
