---
title: Initialisation tardive
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 7b19fbeb0144698c5091a9bbe6bce45c21c4f0d8
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64616369"
---
# <a name="lazy-initialization"></a><span data-ttu-id="6db7c-102">Initialisation tardive</span><span class="sxs-lookup"><span data-stu-id="6db7c-102">Lazy Initialization</span></span>
<span data-ttu-id="6db7c-103">*L’initialisation tardive* d’un objet signifie que sa création est différée jusqu’à sa première utilisation.</span><span class="sxs-lookup"><span data-stu-id="6db7c-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="6db7c-104">(Pour cette rubrique, les termes *initialisation tardive* et *instanciation tardive* sont synonymes.) L’initialisation tardive est principalement utilisée pour améliorer les performances, éviter les calculs inutiles et réduire les besoins en mémoire programme.</span><span class="sxs-lookup"><span data-stu-id="6db7c-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="6db7c-105">Voici les scénarios les plus courants :</span><span class="sxs-lookup"><span data-stu-id="6db7c-105">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="6db7c-106">Lorsqu’un objet est coûteux à créer, et qu’il est possible que le programme ne l’utilise pas.</span><span class="sxs-lookup"><span data-stu-id="6db7c-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="6db7c-107">Par exemple, supposons que vous ayez en mémoire un objet `Customer` avec une propriété `Orders` contenant un grand tableau d’objets `Order` qui, pour être initialisé, nécessite une connexion de base de données.</span><span class="sxs-lookup"><span data-stu-id="6db7c-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="6db7c-108">Si l’utilisateur ne demande jamais à afficher les commandes ou à utiliser les données dans un calcul, il est inutile d’utiliser la mémoire système ou les cycles de calcul pour les créer.</span><span class="sxs-lookup"><span data-stu-id="6db7c-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="6db7c-109">En utilisant `Lazy<Orders>` pour déclarer l’objet `Orders` en vue de son initialisation tardive, vous évitez de gaspiller les ressources système lorsque l’objet n’est pas utilisé.</span><span class="sxs-lookup"><span data-stu-id="6db7c-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="6db7c-110">Si vous avez un objet qui est coûteux à créer, et si vous souhaitez différer sa création jusqu’à ce que d’autres opérations coûteuses soient terminées.</span><span class="sxs-lookup"><span data-stu-id="6db7c-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="6db7c-111">Par exemple, supposons que votre programme charge plusieurs instances d’objet lorsqu’il démarre, mais que seules certaines d’entre elles soient immédiatement nécessaires.</span><span class="sxs-lookup"><span data-stu-id="6db7c-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="6db7c-112">Vous pouvez améliorer les performances de démarrage du programme en différant l’initialisation des objets qui ne sont pas nécessaires tant que les objets nécessaires n’ont pas été créés.</span><span class="sxs-lookup"><span data-stu-id="6db7c-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="6db7c-113">Même si vous pouvez écrire votre propre code pour effectuer une initialisation tardive, nous vous recommandons d’utiliser <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="6db7c-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="6db7c-114"><xref:System.Lazy%601> et ses types associés prennent également en charge la cohérence de thread et fournissent une stratégie cohérente de propagation des exceptions.</span><span class="sxs-lookup"><span data-stu-id="6db7c-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="6db7c-115">Le tableau suivant répertorie les types fournis par le .NET Framework version 4 pour permettre l’initialisation tardive dans différents scénarios.</span><span class="sxs-lookup"><span data-stu-id="6db7c-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="6db7c-116">Type</span><span class="sxs-lookup"><span data-stu-id="6db7c-116">Type</span></span>|<span data-ttu-id="6db7c-117">Description</span><span class="sxs-lookup"><span data-stu-id="6db7c-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="6db7c-118">Classe wrapper qui fournit une sémantique d’initialisation tardive pour toute bibliothèque de classes ou type défini par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="6db7c-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="6db7c-119">Similaire à <xref:System.Lazy%601>, sauf qu’il fournit une sémantique d’initialisation tardive en fonction du thread local.</span><span class="sxs-lookup"><span data-stu-id="6db7c-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="6db7c-120">Chaque thread a accès à sa propre valeur.</span><span class="sxs-lookup"><span data-stu-id="6db7c-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="6db7c-121">Fournit des méthodes `static` avancées (`Shared` en Visual Basic) pour l’initialisation tardive des objets, sans la surcharge d’une classe.</span><span class="sxs-lookup"><span data-stu-id="6db7c-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="6db7c-122">Initialisation tardive de base</span><span class="sxs-lookup"><span data-stu-id="6db7c-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="6db7c-123">Pour définir un type initialisé tardivement (par exemple, `MyType`), utilisez `Lazy<MyType>` (`Lazy(Of MyType)` en Visual Basic), comme illustré dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="6db7c-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="6db7c-124">Si aucun délégué n’est passé dans le constructeur <xref:System.Lazy%601>, le type encapsulé est créé à l’aide de <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> lors du premier accès à la propriété de la valeur.</span><span class="sxs-lookup"><span data-stu-id="6db7c-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="6db7c-125">Si le type n’a pas de constructeur par défaut, une exception runtime est levée.</span><span class="sxs-lookup"><span data-stu-id="6db7c-125">If the type does not have a default constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="6db7c-126">Dans l’exemple suivant, supposons que `Orders` soit une classe qui contienne un tableau d’objets `Order` récupérés à partir d’une base de données.</span><span class="sxs-lookup"><span data-stu-id="6db7c-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="6db7c-127">Un objet `Customer` contient une instance de `Orders`, mais en fonction des actions de l’utilisateur, les données de l’objet `Orders` peuvent ne pas être nécessaires.</span><span class="sxs-lookup"><span data-stu-id="6db7c-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="6db7c-128">Vous pouvez également passer un délégué dans le constructeur <xref:System.Lazy%601> qui appelle une surcharge de constructeur sur le type encapsulé au moment de la création, et effectuer d’autres étapes d’initialisation nécessaires, comme indiqué dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="6db7c-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="6db7c-129">Une fois que l’objet différé est créé, aucune instance de `Orders` n’est créée tant que la propriété <xref:System.Lazy%601.Value%2A> de la variable tardive n’a pas fait l’objet d’un accès.</span><span class="sxs-lookup"><span data-stu-id="6db7c-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="6db7c-130">Lors du premier accès à la propriété, le type encapsulé est créé, retourné, puis stocké en vue d’une utilisation ultérieure.</span><span class="sxs-lookup"><span data-stu-id="6db7c-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="6db7c-131">Un objet <xref:System.Lazy%601> retourne toujours le même objet (ou la même valeur) qui a été utilisé lors de son initialisation.</span><span class="sxs-lookup"><span data-stu-id="6db7c-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="6db7c-132">Par conséquent, la propriété <xref:System.Lazy%601.Value%2A> est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="6db7c-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="6db7c-133">Si <xref:System.Lazy%601.Value%2A> stocke un type référence, vous ne pouvez pas lui attribuer un nouvel objet</span><span class="sxs-lookup"><span data-stu-id="6db7c-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="6db7c-134">(toutefois, vous pouvez modifier la valeur de ses champs et de ses propriétés publics paramétrables). Si <xref:System.Lazy%601.Value%2A> stocke un type valeur, vous ne pouvez pas modifier sa valeur.</span><span class="sxs-lookup"><span data-stu-id="6db7c-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="6db7c-135">Toutefois, vous pouvez créer une variable en rappelant le constructeur de variable à l’aide de nouveaux arguments.</span><span class="sxs-lookup"><span data-stu-id="6db7c-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="6db7c-136">La nouvelle instance tardive, comme la précédente, n’instancie pas `Orders` tant que sa propriété <xref:System.Lazy%601.Value%2A> n’a pas fait l’objet d’un accès.</span><span class="sxs-lookup"><span data-stu-id="6db7c-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="6db7c-137">Initialisation thread-safe</span><span class="sxs-lookup"><span data-stu-id="6db7c-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="6db7c-138">Par défaut, les objets <xref:System.Lazy%601> sont thread-safe.</span><span class="sxs-lookup"><span data-stu-id="6db7c-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="6db7c-139">Autrement dit, si le constructeur ne spécifie pas le type de cohérence de thread, les objets <xref:System.Lazy%601> qu’il crée sont thread-safe.</span><span class="sxs-lookup"><span data-stu-id="6db7c-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="6db7c-140">Dans les scénarios multithreads, le premier thread qui accède à la propriété <xref:System.Lazy%601.Value%2A> d’un objet <xref:System.Lazy%601> thread-safe initialise celui-ci pour tous les accès suivants sur tous les threads. De plus, tous les threads partagent les mêmes données.</span><span class="sxs-lookup"><span data-stu-id="6db7c-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="6db7c-141">Par conséquent, le thread qui initialise l’objet importe peu, et les conditions de concurrence sont sans conséquences.</span><span class="sxs-lookup"><span data-stu-id="6db7c-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6db7c-142">Vous pouvez étendre cette cohérence aux conditions d’erreur à l’aide de la mise en cache des exceptions.</span><span class="sxs-lookup"><span data-stu-id="6db7c-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="6db7c-143">Pour plus d’informations, consultez la section suivante, [Exceptions des objets différés](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="6db7c-143">For more information, see the next section, [Exceptions in Lazy Objects](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="6db7c-144">L’exemple suivant montre que la même instance `Lazy<int>` a la même valeur pour trois threads différents.</span><span class="sxs-lookup"><span data-stu-id="6db7c-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="6db7c-145">Si chaque thread doit contenir des données distinctes, utilisez le type <xref:System.Threading.ThreadLocal%601>, comme décrit plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="6db7c-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="6db7c-146">Certains constructeurs <xref:System.Lazy%601> ont un paramètre booléen nommé `isThreadSafe` qui permet de spécifier si la propriété <xref:System.Lazy%601.Value%2A> est accessible à partir de plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="6db7c-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="6db7c-147">Si vous envisagez d’accéder à la propriété à partir d’un seul thread, vous pouvez passer `false` pour obtenir un gain de performances modeste.</span><span class="sxs-lookup"><span data-stu-id="6db7c-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="6db7c-148">Si vous avez l’intention d’accéder à la propriété à partir de plusieurs threads, passez `true` pour indiquer à l’instance <xref:System.Lazy%601> qu’elle doit gérer correctement les conditions de concurrence dans lesquelles un thread lève une exception au moment de l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="6db7c-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="6db7c-149">Certains constructeurs <xref:System.Lazy%601> ont un paramètre <xref:System.Threading.LazyThreadSafetyMode> nommé `mode`.</span><span class="sxs-lookup"><span data-stu-id="6db7c-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="6db7c-150">Ces constructeurs fournissent un mode de cohérence de thread supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="6db7c-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="6db7c-151">Le tableau suivant montre comment la cohérence de thread d’un objet <xref:System.Lazy%601> est affectée par les paramètres du constructeur qui spécifient la cohérence de thread.</span><span class="sxs-lookup"><span data-stu-id="6db7c-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="6db7c-152">Chaque constructeur comprend un tel paramètre.</span><span class="sxs-lookup"><span data-stu-id="6db7c-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="6db7c-153">Cohérence de thread de l’objet</span><span class="sxs-lookup"><span data-stu-id="6db7c-153">Thread safety of the object</span></span>|<span data-ttu-id="6db7c-154">Paramètre `LazyThreadSafetyMode` `mode`</span><span class="sxs-lookup"><span data-stu-id="6db7c-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="6db7c-155">Paramètre `isThreadSafe` booléen</span><span class="sxs-lookup"><span data-stu-id="6db7c-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="6db7c-156">Aucun paramètre de cohérence de thread</span><span class="sxs-lookup"><span data-stu-id="6db7c-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="6db7c-157">Entièrement thread-safe. Seul un thread à la fois tente d’initialiser la valeur.</span><span class="sxs-lookup"><span data-stu-id="6db7c-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="6db7c-158">Oui.</span><span class="sxs-lookup"><span data-stu-id="6db7c-158">Yes.</span></span>|  
|<span data-ttu-id="6db7c-159">Non thread-safe.</span><span class="sxs-lookup"><span data-stu-id="6db7c-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="6db7c-160">Non applicable.</span><span class="sxs-lookup"><span data-stu-id="6db7c-160">Not applicable.</span></span>|  
|<span data-ttu-id="6db7c-161">Entièrement thread-safe. Concurrence de threads pour initialiser la valeur.</span><span class="sxs-lookup"><span data-stu-id="6db7c-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="6db7c-162">Non applicable.</span><span class="sxs-lookup"><span data-stu-id="6db7c-162">Not applicable.</span></span>|<span data-ttu-id="6db7c-163">Non applicable.</span><span class="sxs-lookup"><span data-stu-id="6db7c-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="6db7c-164">Comme le montre le tableau, spécifier <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> pour le paramètre `mode` équivaut à spécifier `true` pour le paramètre `isThreadSafe`, et spécifier <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> revient à spécifier `false`.</span><span class="sxs-lookup"><span data-stu-id="6db7c-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="6db7c-165">Le fait de spécifier <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> permet à plusieurs threads de tenter d’initialiser l’instance <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="6db7c-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="6db7c-166">Seul un thread peut gagner cette course. Tous les autres threads reçoivent la valeur qui a été initialisée par le thread gagnant.</span><span class="sxs-lookup"><span data-stu-id="6db7c-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="6db7c-167">Si une exception est levée sur un thread pendant l’initialisation, ce thread ne reçoit pas la valeur définie par le thread gagnant.</span><span class="sxs-lookup"><span data-stu-id="6db7c-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="6db7c-168">Les exceptions ne sont pas mises en cache. De fait, une nouvelle tentative d’accès à la propriété <xref:System.Lazy%601.Value%2A> peut aboutir à une initialisation.</span><span class="sxs-lookup"><span data-stu-id="6db7c-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="6db7c-169">Ce traitement des exceptions est différent de celui des autres modes, et fait l’objet de la section suivante.</span><span class="sxs-lookup"><span data-stu-id="6db7c-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="6db7c-170">Pour plus d’informations, consultez l’énumération <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="6db7c-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>   
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="6db7c-171">Exceptions des objets différés</span><span class="sxs-lookup"><span data-stu-id="6db7c-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="6db7c-172">Comme indiqué précédemment, un objet <xref:System.Lazy%601> retourne toujours le même objet (ou la même valeur) avec lequel il a été initialisé. De fait, la propriété <xref:System.Lazy%601.Value%2A> est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="6db7c-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="6db7c-173">Si vous activez la mise en cache des exceptions, cette immuabilité s’étend également au comportement des exceptions.</span><span class="sxs-lookup"><span data-stu-id="6db7c-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="6db7c-174">Si un objet initialisé tardivement exception mise en cache activée et lève une exception à partir de sa méthode d’initialisation lorsque le <xref:System.Lazy%601.Value%2A> du premier accès de propriété, cette même exception est levée à chaque tentative suivante pour accéder à la <xref:System.Lazy%601.Value%2A> propriété .</span><span class="sxs-lookup"><span data-stu-id="6db7c-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="6db7c-175">En d’autres termes, le constructeur du type encapsulé n’est jamais rappelé, même dans les scénarios multithreads.</span><span class="sxs-lookup"><span data-stu-id="6db7c-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="6db7c-176">Par conséquent, l’objet <xref:System.Lazy%601> ne peut pas lever une exception lors d’un accès et retourner une valeur lors d’un accès ultérieur.</span><span class="sxs-lookup"><span data-stu-id="6db7c-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="6db7c-177">La mise en cache des exceptions est activée lorsque vous utilisez un constructeur <xref:System.Lazy%601?displayProperty=nameWithType> qui accepte une méthode d’initialisation (un paramètre `valueFactory`). Par exemple, elle est activée lorsque vous utilisez le constructeur `Lazy(T)(Func(T))`.</span><span class="sxs-lookup"><span data-stu-id="6db7c-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="6db7c-178">Si le constructeur accepte également une valeur <xref:System.Threading.LazyThreadSafetyMode> (un paramètre `mode`), spécifiez <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> ou <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6db7c-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6db7c-179">La spécification d’une méthode d’initialisation permet la mise en cache des exceptions pour ces deux modes.</span><span class="sxs-lookup"><span data-stu-id="6db7c-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="6db7c-180">La méthode d’initialisation peut être très simple.</span><span class="sxs-lookup"><span data-stu-id="6db7c-180">The initialization method can be very simple.</span></span> <span data-ttu-id="6db7c-181">Par exemple, elle peut appeler le constructeur par défaut de `T` (`new Lazy<Contents>(() => new Contents(), mode)` en C# ou `New Lazy(Of Contents)(Function() New Contents())` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="6db7c-181">For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="6db7c-182">Si vous utilisez un constructeur <xref:System.Lazy%601?displayProperty=nameWithType> qui ne spécifie pas une méthode d’initialisation, les exceptions levées par le constructeur par défaut pour `T` ne sont pas mises en cache.</span><span class="sxs-lookup"><span data-stu-id="6db7c-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached.</span></span> <span data-ttu-id="6db7c-183">Pour plus d’informations, consultez l’énumération <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="6db7c-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6db7c-184">Si vous créez un objet <xref:System.Lazy%601> avec le paramètre de constructeur `isThreadSafe` défini sur `false` ou le paramètre de constructeur `mode` défini sur <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, vous devez accéder à l’objet <xref:System.Lazy%601> à partir d’un thread unique ou fournir votre propre synchronisation.</span><span class="sxs-lookup"><span data-stu-id="6db7c-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="6db7c-185">Cela s’applique à tous les aspects de l’objet, y compris la mise en cache des exceptions.</span><span class="sxs-lookup"><span data-stu-id="6db7c-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="6db7c-186">Comme indiqué dans la section précédente, les objets <xref:System.Lazy%601> créés en spécifiant <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> traitent les exceptions différemment.</span><span class="sxs-lookup"><span data-stu-id="6db7c-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="6db7c-187">Avec <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, plusieurs threads peuvent rivaliser pour initialiser l’instance <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="6db7c-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="6db7c-188">Dans ce cas, les exceptions ne sont pas mises en cache, et les tentatives d’accès à la propriété <xref:System.Lazy%601.Value%2A> peuvent continuer jusqu’à ce que l’initialisation soit effectuée.</span><span class="sxs-lookup"><span data-stu-id="6db7c-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="6db7c-189">Le tableau suivant récapitule la façon dont les constructeurs <xref:System.Lazy%601> contrôlent la mise en cache des exceptions.</span><span class="sxs-lookup"><span data-stu-id="6db7c-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="6db7c-190">Constructeur</span><span class="sxs-lookup"><span data-stu-id="6db7c-190">Constructor</span></span>|<span data-ttu-id="6db7c-191">Mode de cohérence de thread</span><span class="sxs-lookup"><span data-stu-id="6db7c-191">Thread safety mode</span></span>|<span data-ttu-id="6db7c-192">Utilise la méthode d’initialisation</span><span class="sxs-lookup"><span data-stu-id="6db7c-192">Uses initialization method</span></span>|<span data-ttu-id="6db7c-193">Exceptions mises en cache</span><span class="sxs-lookup"><span data-stu-id="6db7c-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="6db7c-194">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="6db7c-194">Lazy(T)()</span></span>|<span data-ttu-id="6db7c-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="6db7c-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="6db7c-196">Non</span><span class="sxs-lookup"><span data-stu-id="6db7c-196">No</span></span>|<span data-ttu-id="6db7c-197">Non</span><span class="sxs-lookup"><span data-stu-id="6db7c-197">No</span></span>|  
|<span data-ttu-id="6db7c-198">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="6db7c-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="6db7c-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="6db7c-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="6db7c-200">Oui</span><span class="sxs-lookup"><span data-stu-id="6db7c-200">Yes</span></span>|<span data-ttu-id="6db7c-201">Oui</span><span class="sxs-lookup"><span data-stu-id="6db7c-201">Yes</span></span>|  
|<span data-ttu-id="6db7c-202">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="6db7c-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="6db7c-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) ou `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="6db7c-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="6db7c-204">Non</span><span class="sxs-lookup"><span data-stu-id="6db7c-204">No</span></span>|<span data-ttu-id="6db7c-205">Non</span><span class="sxs-lookup"><span data-stu-id="6db7c-205">No</span></span>|  
|<span data-ttu-id="6db7c-206">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="6db7c-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="6db7c-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) ou `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="6db7c-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="6db7c-208">Oui</span><span class="sxs-lookup"><span data-stu-id="6db7c-208">Yes</span></span>|<span data-ttu-id="6db7c-209">Oui</span><span class="sxs-lookup"><span data-stu-id="6db7c-209">Yes</span></span>|  
|<span data-ttu-id="6db7c-210">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="6db7c-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="6db7c-211">Spécifié par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="6db7c-211">User-specified</span></span>|<span data-ttu-id="6db7c-212">Non</span><span class="sxs-lookup"><span data-stu-id="6db7c-212">No</span></span>|<span data-ttu-id="6db7c-213">Non</span><span class="sxs-lookup"><span data-stu-id="6db7c-213">No</span></span>|  
|<span data-ttu-id="6db7c-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="6db7c-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="6db7c-215">Spécifié par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="6db7c-215">User-specified</span></span>|<span data-ttu-id="6db7c-216">Oui</span><span class="sxs-lookup"><span data-stu-id="6db7c-216">Yes</span></span>|<span data-ttu-id="6db7c-217">Non, si l’utilisateur spécifie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> ; sinon, Oui.</span><span class="sxs-lookup"><span data-stu-id="6db7c-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="6db7c-218">Implémentation d’une propriété à initialisation tardive</span><span class="sxs-lookup"><span data-stu-id="6db7c-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="6db7c-219">Pour implémenter une propriété publique à l’aide de l’initialisation tardive, définissez le champ de stockage de la propriété comme un <xref:System.Lazy%601>, puis retournez la propriété <xref:System.Lazy%601.Value%2A> à partir de l’accesseur `get` de la propriété.</span><span class="sxs-lookup"><span data-stu-id="6db7c-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="6db7c-220">La propriété <xref:System.Lazy%601.Value%2A> est en lecture seule, par conséquent, la propriété qui l’expose n’a pas d’accesseur `set`.</span><span class="sxs-lookup"><span data-stu-id="6db7c-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="6db7c-221">Si vous avez besoin d’une propriété en lecture/écriture stockée par un objet <xref:System.Lazy%601>, l’accesseur `set` doit créer un nouvel objet <xref:System.Lazy%601> et l’assigner au magasin de stockage.</span><span class="sxs-lookup"><span data-stu-id="6db7c-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="6db7c-222">L’accesseur `set` doit créer une expression lambda qui retourne la nouvelle valeur de propriété qui a été passée à l’accesseur `set`, et passer cette expression lambda au constructeur pour le nouvel objet <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="6db7c-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="6db7c-223">Le prochain accès à la propriété <xref:System.Lazy%601.Value%2A> va entraîner l’initialisation du nouveau <xref:System.Lazy%601>, et sa propriété <xref:System.Lazy%601.Value%2A> va alors retourner la nouvelle valeur qui a été affectée à la propriété.</span><span class="sxs-lookup"><span data-stu-id="6db7c-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="6db7c-224">L’objectif de cet arrangement complexe est de conserver les protections de multithreading intégrées à <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="6db7c-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="6db7c-225">Sans cela, les accesseurs de propriété devraient mettre en cache la première valeur retournée par la propriété <xref:System.Lazy%601.Value%2A> et modifier uniquement la valeur mise en cache. En plus, vous auriez à écrire votre propre code thread-safe pour réaliser cela.</span><span class="sxs-lookup"><span data-stu-id="6db7c-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="6db7c-226">En raison des initialisations supplémentaires exigées par une propriété en lecture/écriture stockée dans un objet <xref:System.Lazy%601>, les performances peuvent ne pas être acceptables.</span><span class="sxs-lookup"><span data-stu-id="6db7c-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="6db7c-227">De plus, selon le scénario, une coordination supplémentaire peut être nécessaire pour éviter des conditions de concurrence entre les méthodes setter et getter.</span><span class="sxs-lookup"><span data-stu-id="6db7c-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="6db7c-228">Initialisation tardive de thread local</span><span class="sxs-lookup"><span data-stu-id="6db7c-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="6db7c-229">Dans certains scénarios multithreads, vous pouvez souhaiter que chaque thread ait ses propres données privées.</span><span class="sxs-lookup"><span data-stu-id="6db7c-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="6db7c-230">Ces données sont appelées *données de thread local*.</span><span class="sxs-lookup"><span data-stu-id="6db7c-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="6db7c-231">Dans le .NET Framework 3.5 et versions antérieures, vous pouvez appliquer l’attribut `ThreadStatic` à une variable statique pour qu’elle devienne une variable de thread local.</span><span class="sxs-lookup"><span data-stu-id="6db7c-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="6db7c-232">Toutefois, l’utilisation de l’attribut `ThreadStatic` peut entraîner des erreurs subtiles.</span><span class="sxs-lookup"><span data-stu-id="6db7c-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="6db7c-233">Par exemple, même avec des instructions d’initialisation basiques, la variable est initialisée uniquement sur le premier thread qui y accède, comme indiqué dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="6db7c-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="6db7c-234">Sur tous les autres threads, la variable est initialisée à l’aide de sa valeur par défaut (zéro).</span><span class="sxs-lookup"><span data-stu-id="6db7c-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="6db7c-235">En guise d’alternative dans le .NET Framework version 4, vous pouvez utiliser le type <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> pour créer une variable de thread local basée sur l’instance, qui est initialisée sur tous les threads par le délégué <xref:System.Action%601> que vous fournissez.</span><span class="sxs-lookup"><span data-stu-id="6db7c-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="6db7c-236">Dans l’exemple suivant, tous les threads qui accèdent à `counter` vont voir que sa valeur de départ est égale à 1.</span><span class="sxs-lookup"><span data-stu-id="6db7c-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="6db7c-237"><xref:System.Threading.ThreadLocal%601> encapsule son objet de la même façon que <xref:System.Lazy%601>, avec toutefois ces différences essentielles :</span><span class="sxs-lookup"><span data-stu-id="6db7c-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="6db7c-238">Chaque thread initialise la variable de thread local à l’aide de ses données privées, qui ne sont pas accessibles par d’autres threads.</span><span class="sxs-lookup"><span data-stu-id="6db7c-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="6db7c-239">La propriété <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> est en lecture-écriture et peut être modifiée autant de fois que nécessaire.</span><span class="sxs-lookup"><span data-stu-id="6db7c-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="6db7c-240">Cela peut affecter la propagation des exceptions. Par exemple, une opération `get` peut lever une exception, mais celle qui suit peut initialiser la valeur.</span><span class="sxs-lookup"><span data-stu-id="6db7c-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="6db7c-241">Si aucun délégué d’initialisation n’est fourni, <xref:System.Threading.ThreadLocal%601> va initialiser son type encapsulé à l’aide de la valeur par défaut du type.</span><span class="sxs-lookup"><span data-stu-id="6db7c-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="6db7c-242">À cet égard, <xref:System.Threading.ThreadLocal%601> est cohérent avec l’attribut <xref:System.ThreadStaticAttribute>.</span><span class="sxs-lookup"><span data-stu-id="6db7c-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="6db7c-243">L’exemple suivant montre que chaque thread qui accède à l’instance `ThreadLocal<int>` obtient sa propre copie des données.</span><span class="sxs-lookup"><span data-stu-id="6db7c-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="6db7c-244">Variables de thread local dans Parallel.For et ForEach</span><span class="sxs-lookup"><span data-stu-id="6db7c-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="6db7c-245">Lorsque vous utilisez la méthode <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> pour parcourir des sources de données en parallèle, vous pouvez utiliser les surcharges qui ont une prise en charge intégrée pour les données de thread local.</span><span class="sxs-lookup"><span data-stu-id="6db7c-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="6db7c-246">Dans ces méthodes, pour obtenir des données de thread local, vous devez utiliser des délégués locaux pour créer ces données, y accéder et les nettoyer.</span><span class="sxs-lookup"><span data-stu-id="6db7c-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="6db7c-247">Pour plus d'informations, voir [Procédure : écrire une boucle Parallel.For avec des variables locales de thread](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) et [Guide pratique pour écrire une boucle Parallel.ForEach avec des variables locales de partition](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="6db7c-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="6db7c-248">Utilisation de l’initialisation tardive pour les scénarios de faible charge</span><span class="sxs-lookup"><span data-stu-id="6db7c-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="6db7c-249">Dans les scénarios où vous devez initialiser tardivement un grand nombre d’objets, vous pouvez décider que l’encapsulation de chaque objet dans un <xref:System.Lazy%601> nécessite trop de mémoire ou trop de ressources informatiques.</span><span class="sxs-lookup"><span data-stu-id="6db7c-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="6db7c-250">Vous pouvez aussi avoir des exigences strictes sur la façon dont l’initialisation tardive est exposée.</span><span class="sxs-lookup"><span data-stu-id="6db7c-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="6db7c-251">Dans ce cas, vous pouvez utiliser les méthodes `static` (`Shared` en Visual Basic) de la classe <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> pour initialiser tardivement chaque objet sans l’encapsuler dans une instance de <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="6db7c-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="6db7c-252">Dans l’exemple suivant, supposons que, au lieu d’encapsuler un objet `Orders` entier dans un objet <xref:System.Lazy%601>, vous n’avez que des objets `Order` initialisés tardivement seulement lorsqu’ils sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="6db7c-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="6db7c-253">Dans cet exemple, notez que la procédure d’initialisation est appelée sur chaque itération de la boucle.</span><span class="sxs-lookup"><span data-stu-id="6db7c-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="6db7c-254">Dans les scénarios multithreads, le premier thread à appeler la procédure d’initialisation est celui dont la valeur est visible par tous les threads.</span><span class="sxs-lookup"><span data-stu-id="6db7c-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="6db7c-255">Les threads suivants appellent également la procédure d’initialisation, mais leurs résultats ne sont pas utilisés.</span><span class="sxs-lookup"><span data-stu-id="6db7c-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="6db7c-256">Si ce type de condition de concurrence potentielle n’est pas acceptable, utilisez la surcharge de <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> qui accepte un argument booléen et un objet de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="6db7c-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6db7c-257">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="6db7c-257">See also</span></span>

- [<span data-ttu-id="6db7c-258">Éléments fondamentaux du threading managé</span><span class="sxs-lookup"><span data-stu-id="6db7c-258">Managed Threading Basics</span></span>](../../../docs/standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="6db7c-259">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="6db7c-259">Threads and Threading</span></span>](../../../docs/standard/threading/threads-and-threading.md)
- [<span data-ttu-id="6db7c-260">La bibliothèque parallèle de tâches</span><span class="sxs-lookup"><span data-stu-id="6db7c-260">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="6db7c-261">Guide pratique pour Effectuer une initialisation tardive d’objets</span><span class="sxs-lookup"><span data-stu-id="6db7c-261">How to: Perform Lazy Initialization of Objects</span></span>](../../../docs/framework/performance/how-to-perform-lazy-initialization-of-objects.md)
