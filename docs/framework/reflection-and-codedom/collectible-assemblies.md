---
title: Assemblys pouvant être collectés pour la génération de type dynamique
description: Prise en main des assemblys pouvant être collectés pour la génération de type dynamique dans .NET. En savoir plus sur les durées de vie et restrictions des assemblys pouvant être collectées.
ms.date: 08/29/2017
helpviewer_keywords:
- reflection, dynamic assembly
- assemblies, collectible
- collectible assemblies, retrieving
ms.openlocfilehash: 4981b93dbd49a6da96740bebed0f2ed7b89036c8
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/20/2020
ms.locfileid: "86475123"
---
# <a name="collectible-assemblies-for-dynamic-type-generation"></a><span data-ttu-id="e6969-104">Assemblys pouvant être collectés pour la génération de type dynamique</span><span class="sxs-lookup"><span data-stu-id="e6969-104">Collectible assemblies for dynamic type generation</span></span>

<span data-ttu-id="e6969-105">Les *assemblys pouvant être collectés* sont des assemblys dynamiques qui peuvent être déchargés sans décharger le domaine d’application dans lequel ils ont été créés.</span><span class="sxs-lookup"><span data-stu-id="e6969-105">*Collectible assemblies* are dynamic assemblies that can be unloaded without unloading the application domain in which they were created.</span></span> <span data-ttu-id="e6969-106">Toute la mémoire managée et non managée utilisée par un assembly pouvant être collecté et les types qu’il contient peuvent être récupérés.</span><span class="sxs-lookup"><span data-stu-id="e6969-106">All managed and unmanaged memory used by a collectible assembly and the types it contains can be reclaimed.</span></span> <span data-ttu-id="e6969-107">Les informations telles que le nom de l’assembly sont supprimées des tables internes.</span><span class="sxs-lookup"><span data-stu-id="e6969-107">Information such as the assembly name is removed from internal tables.</span></span>

<span data-ttu-id="e6969-108">Pour activer le déchargement, utilisez l’indicateur <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType> quand vous créez un assembly dynamique.</span><span class="sxs-lookup"><span data-stu-id="e6969-108">To enable unloading, use the <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType> flag when you create a dynamic assembly.</span></span> <span data-ttu-id="e6969-109">L’assembly est transitoire (autrement dit, il ne peut pas être enregistré) et est soumis aux limitations décrites dans la section [Restrictions sur les assemblys pouvant être collectés](#restrictions-on-collectible-assemblies).</span><span class="sxs-lookup"><span data-stu-id="e6969-109">The assembly is transient (that is, it cannot be saved) and is subject to limitations described in the [Restrictions on Collectible Assemblies](#restrictions-on-collectible-assemblies) section.</span></span> <span data-ttu-id="e6969-110">Le common language runtime (CLR) décharge automatiquement un assembly pouvant être collecté lors de la mise en production de tous les objets associés à l’assembly.</span><span class="sxs-lookup"><span data-stu-id="e6969-110">The common language runtime (CLR) unloads a collectible assembly automatically when you release all objects associated with the assembly.</span></span> <span data-ttu-id="e6969-111">Sous tous les autres aspects, les assemblys pouvant être collectés sont créés et utilisés de la même façon que d’autres assemblys dynamiques.</span><span class="sxs-lookup"><span data-stu-id="e6969-111">In all other respects, collectible assemblies are created and used in the same way as other dynamic assemblies.</span></span>

## <a name="lifetime-of-collectible-assemblies"></a><span data-ttu-id="e6969-112">Durée de vie des assemblys pouvant être collectés</span><span class="sxs-lookup"><span data-stu-id="e6969-112">Lifetime of collectible assemblies</span></span>

<span data-ttu-id="e6969-113">La durée de vie d’un assembly pouvant être collecté est contrôlée par l’existence de références aux types qu’il contient et aux objets qui sont créés à partir de ces types.</span><span class="sxs-lookup"><span data-stu-id="e6969-113">The lifetime of a collectible assembly is controlled by the existence of references to the types it contains and the objects that are created from those types.</span></span> <span data-ttu-id="e6969-114">Le common language runtime ne décharge pas d’assembly tant qu’un ou que plusieurs des éléments suivants existent (`T` correspond à tout type qui est défini dans l’assembly) :</span><span class="sxs-lookup"><span data-stu-id="e6969-114">The common language runtime does not unload an assembly as long as one or more of the following exist (`T` is any type that is defined in the assembly):</span></span>

- <span data-ttu-id="e6969-115">Instance de `T`.</span><span class="sxs-lookup"><span data-stu-id="e6969-115">An instance of `T`.</span></span>

- <span data-ttu-id="e6969-116">Instance d’un tableau de `T`.</span><span class="sxs-lookup"><span data-stu-id="e6969-116">An instance of an array of `T`.</span></span>

- <span data-ttu-id="e6969-117">Instance d’un type générique qui a `T` comme l’un de ses arguments de type.</span><span class="sxs-lookup"><span data-stu-id="e6969-117">An instance of a generic type that has `T` as one of its type arguments.</span></span> <span data-ttu-id="e6969-118">Cela inclut les collections génériques de `T`, même si cette collection est vide.</span><span class="sxs-lookup"><span data-stu-id="e6969-118">This includes generic collections of `T`, even if that collection is empty.</span></span>

- <span data-ttu-id="e6969-119">Instance de <xref:System.Type> ou <xref:System.Reflection.Emit.TypeBuilder> qui représente `T`.</span><span class="sxs-lookup"><span data-stu-id="e6969-119">An instance of <xref:System.Type> or <xref:System.Reflection.Emit.TypeBuilder> that represents `T`.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="e6969-120">Vous devez libérer tous les objets qui représentent des parties de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="e6969-120">You must release all objects that represent parts of the assembly.</span></span> <span data-ttu-id="e6969-121"><xref:System.Reflection.Emit.ModuleBuilder> qui définit `T` conserve une référence à <xref:System.Reflection.Emit.TypeBuilder>, et l’objet <xref:System.Reflection.Emit.AssemblyBuilder> conserve une référence à <xref:System.Reflection.Emit.ModuleBuilder>, de sorte que les références à ces objets doivent être libérées.</span><span class="sxs-lookup"><span data-stu-id="e6969-121">The <xref:System.Reflection.Emit.ModuleBuilder> that defines `T` keeps a reference to the <xref:System.Reflection.Emit.TypeBuilder>, and the <xref:System.Reflection.Emit.AssemblyBuilder> object keeps a reference to the <xref:System.Reflection.Emit.ModuleBuilder>, so references to these objects must be released.</span></span> <span data-ttu-id="e6969-122">Même l’existence d’un <xref:System.Reflection.Emit.LocalBuilder> ou <xref:System.Reflection.Emit.ILGenerator> utilisé dans la construction de `T` empêche le déchargement.</span><span class="sxs-lookup"><span data-stu-id="e6969-122">Even the existence of a <xref:System.Reflection.Emit.LocalBuilder> or an <xref:System.Reflection.Emit.ILGenerator> used in the construction of `T` prevents unloading.</span></span>

- <span data-ttu-id="e6969-123">Référence statique à `T` par un autre type défini dynamiquement `T1` qui est encore accessible par l’exécution de code.</span><span class="sxs-lookup"><span data-stu-id="e6969-123">A static reference to `T` by another dynamically defined type `T1` that is still reachable by executing code.</span></span> <span data-ttu-id="e6969-124">Par exemple, `T1` peut dériver de `T`, ou `T` peut être le type d’un paramètre dans une méthode de `T1`.</span><span class="sxs-lookup"><span data-stu-id="e6969-124">For example, `T1` might derive from `T`, or `T` might be the type of a parameter in a method of `T1`.</span></span>

- <span data-ttu-id="e6969-125">**ByRef** pour un champ statique qui appartient à `T`.</span><span class="sxs-lookup"><span data-stu-id="e6969-125">A **ByRef** to a static field that belongs to `T`.</span></span>

- <span data-ttu-id="e6969-126"><xref:System.RuntimeTypeHandle>, <xref:System.RuntimeFieldHandle> ou <xref:System.RuntimeMethodHandle> qui fait référence à `T` ou à un composant de `T`.</span><span class="sxs-lookup"><span data-stu-id="e6969-126">A <xref:System.RuntimeTypeHandle>, <xref:System.RuntimeFieldHandle>, or <xref:System.RuntimeMethodHandle> that refers to `T` or to a component of `T`.</span></span>

- <span data-ttu-id="e6969-127">Instance de tout objet reflection qui peut être utilisée indirectement ou directement pour accéder à l’objet <xref:System.Type> qui représente `T`.</span><span class="sxs-lookup"><span data-stu-id="e6969-127">An instance of any reflection object that could be used indirectly or directly to access the <xref:System.Type> object that represents `T`.</span></span> <span data-ttu-id="e6969-128">Par exemple, l’objet <xref:System.Type> pour `T` peut être obtenu à partir d’un type tableau dont le type d’élément est `T`, ou à partir d’un type générique qui a `T` comme argument de type.</span><span class="sxs-lookup"><span data-stu-id="e6969-128">For example, the <xref:System.Type> object for `T` can be obtained from an array type whose element type is `T`, or from a generic type that has `T` as a type argument.</span></span>

- <span data-ttu-id="e6969-129">Méthode `M` sur la pile des appels de tout thread, où `M` est une méthode de `T` ou une méthode de niveau module qui est définie dans l’assembly.</span><span class="sxs-lookup"><span data-stu-id="e6969-129">A method `M` on the call stack of any thread, where `M` is a method of `T` or a module-level method that is defined in the assembly.</span></span>

- <span data-ttu-id="e6969-130">Délégué d’une méthode statique qui est définie dans un module de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="e6969-130">A delegate to a static method that is defined in a module of the assembly.</span></span>

<span data-ttu-id="e6969-131">Si un seul élément de cette liste existe pour un seul type ou une seule méthode dans l’assembly, le runtime ne peut pas décharger l’assembly.</span><span class="sxs-lookup"><span data-stu-id="e6969-131">If only one item from this list exists for only one type or one method in the assembly, the runtime cannot unload the assembly.</span></span>

> [!NOTE]
> <span data-ttu-id="e6969-132">Le runtime ne décharge pas réellement l’assembly tant que les finaliseurs n’ont pas été exécutés pour tous les éléments de la liste.</span><span class="sxs-lookup"><span data-stu-id="e6969-132">The runtime does not actually unload the assembly until finalizers have run for all items in the list.</span></span>

<span data-ttu-id="e6969-133">À des fins de suivi de durée de vie, un type générique construit comme `List<int>` (en C#) ou `List(Of Integer)` (en Visual Basic), qui est créé et utilisé dans la génération d’un assembly pouvant être collecté est considéré comme ayant été défini dans l’assembly qui contient la définition de type générique ou dans un assembly qui contient la définition de l’un de ses arguments de type.</span><span class="sxs-lookup"><span data-stu-id="e6969-133">For purposes of tracking lifetime, a constructed generic type such as `List<int>` (in C#) or `List(Of Integer)` (in Visual Basic) that is created and used in the generation of a collectible assembly is considered to have been defined either in the assembly that contains the generic type definition or in an assembly that contains the definition of one of its type arguments.</span></span> <span data-ttu-id="e6969-134">L’assembly exact utilisé est un détail d’implémentation et est susceptible de changer.</span><span class="sxs-lookup"><span data-stu-id="e6969-134">The exact assembly that is used is an implementation detail and subject to change.</span></span>

## <a name="restrictions-on-collectible-assemblies"></a><span data-ttu-id="e6969-135">Restrictions sur les assemblys pouvant être collectés</span><span class="sxs-lookup"><span data-stu-id="e6969-135">Restrictions on collectible assemblies</span></span>

<span data-ttu-id="e6969-136">Les restrictions suivantes s’appliquent aux assemblys pouvant être collectés :</span><span class="sxs-lookup"><span data-stu-id="e6969-136">The following restrictions apply to collectible assemblies:</span></span>

- <span data-ttu-id="e6969-137">**Références statiques** Les types d’un assembly dynamique ordinaire ne peuvent pas avoir de références statiques à des types définis dans un assembly pouvant être collecté.</span><span class="sxs-lookup"><span data-stu-id="e6969-137">**Static references** Types in an ordinary dynamic assembly cannot have static references to types that are defined in a collectible assembly.</span></span> <span data-ttu-id="e6969-138">Par exemple, si vous définissez un type simple qui hérite d’un type dans un assembly pouvant être collecté, une exception <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="e6969-138">For example, if you define an ordinary type that inherits from a type in a collectible assembly, a <xref:System.NotSupportedException> exception is thrown.</span></span> <span data-ttu-id="e6969-139">Un type dans un assembly pouvant être collecté peut avoir des références statiques à un type dans un autre assembly pouvant être collecté, mais cela permet d’étendre la durée de vie de l’assembly référencé à la durée de vie de l’assembly de référence.</span><span class="sxs-lookup"><span data-stu-id="e6969-139">A type in a collectible assembly can have static references to a type in another collectible assembly, but this extends the lifetime of the referenced assembly to the lifetime of the referencing assembly.</span></span>

- <span data-ttu-id="e6969-140">**COM Interop** Aucune interface COM ne peut être définie dans un assembly pouvant être collecté, et aucune instance de type dans un assembly pouvant être collecté ne peut être convertie en objets COM.</span><span class="sxs-lookup"><span data-stu-id="e6969-140">**COM interop** No COM interfaces can be defined within a collectible assembly, and no instances of types within a collectible assembly can be converted into COM objects.</span></span> <span data-ttu-id="e6969-141">Un type dans un assembly pouvant être collecté ne peut pas servir de wrapper CCW (COM Callable Wrapper) ni de wrapper RCW (Runtime Callable Wrapper).</span><span class="sxs-lookup"><span data-stu-id="e6969-141">A type in a collectible assembly cannot serve as a COM callable wrapper (CCW) or runtime callable wrapper (RCW).</span></span> <span data-ttu-id="e6969-142">Toutefois, les types dans les assemblys pouvant être collectés peuvent utiliser des objets qui implémentent les interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="e6969-142">However, types in collectible assemblies can use objects that implement COM interfaces.</span></span>

- <span data-ttu-id="e6969-143">**Appel** de code non managé Les méthodes qui ont l' <xref:System.Runtime.InteropServices.DllImportAttribute> attribut ne sont pas compilées quand elles sont déclarées dans un assembly pouvant être collecté.</span><span class="sxs-lookup"><span data-stu-id="e6969-143">**Platform invoke** Methods that have the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute will not compile when they are declared in a collectible assembly.</span></span> <span data-ttu-id="e6969-144">L’instruction <xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType> ne peut pas être utilisée dans l’implémentation d’un type dans un assembly pouvant être collecté, et ces types ne peuvent pas être marshalés en code non managé.</span><span class="sxs-lookup"><span data-stu-id="e6969-144">The <xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType> instruction cannot be used in the implementation of a type in a collectible assembly, and such types cannot be marshaled to unmanaged code.</span></span> <span data-ttu-id="e6969-145">Toutefois, vous pouvez effectuer un appel en code natif à l’aide d’un point d’entrée qui est déclaré dans un assembly ne pouvant pas être collecté.</span><span class="sxs-lookup"><span data-stu-id="e6969-145">However, you can call into native code by using an entry point that is declared in a non-collectible assembly.</span></span>

- <span data-ttu-id="e6969-146">**Marshaling** Les objets (en particulier, les délégués) définis dans les assemblys pouvant être collectés ne peuvent pas être marshalés.</span><span class="sxs-lookup"><span data-stu-id="e6969-146">**Marshaling** Objects (in particular, delegates) that are defined in collectible assemblies cannot be marshaled.</span></span> <span data-ttu-id="e6969-147">Il s’agit d’une restriction sur tous les types émis transitoires.</span><span class="sxs-lookup"><span data-stu-id="e6969-147">This is a restriction on all transient emitted types.</span></span>

- <span data-ttu-id="e6969-148">**Chargement d’assembly** L’émission de réflexion est le seul mécanisme pris en charge pour le chargement des assemblys pouvant être collectés.</span><span class="sxs-lookup"><span data-stu-id="e6969-148">**Assembly loading** Reflection emit is the only mechanism that is supported for loading collectible assemblies.</span></span> <span data-ttu-id="e6969-149">Les assemblys chargés à l’aide de toute autre forme de chargement d’assembly ne peuvent pas être déchargés.</span><span class="sxs-lookup"><span data-stu-id="e6969-149">Assemblies that are loaded by using any other form of assembly loading cannot be unloaded.</span></span>

- <span data-ttu-id="e6969-150">**Objets liés au contexte** Les variables statiques de contexte ne sont pas prises en charge.</span><span class="sxs-lookup"><span data-stu-id="e6969-150">**Context-bound objects** Context-static variables are not supported.</span></span> <span data-ttu-id="e6969-151">Les types dans un assembly pouvant être collecté ne peuvent pas étendre <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="e6969-151">Types in a collectible assembly cannot extend <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="e6969-152">Toutefois, le code dans les assemblys pouvant être collectés peut utiliser des objets liés au contexte définis ailleurs.</span><span class="sxs-lookup"><span data-stu-id="e6969-152">However, code in collectible assemblies can use context-bound objects that are defined elsewhere.</span></span>

- <span data-ttu-id="e6969-153">**Données statiques de thread** Les variables statiques de thread ne sont pas prises en charge.</span><span class="sxs-lookup"><span data-stu-id="e6969-153">**Thread-static data** Thread-static variables are not supported.</span></span>

## <a name="see-also"></a><span data-ttu-id="e6969-154">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="e6969-154">See also</span></span>

- [<span data-ttu-id="e6969-155">Émission d’assemblys et de méthodes dynamiques</span><span class="sxs-lookup"><span data-stu-id="e6969-155">Emitting Dynamic Methods and Assemblies</span></span>](emitting-dynamic-methods-and-assemblies.md)
