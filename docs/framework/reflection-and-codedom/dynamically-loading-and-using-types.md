---
title: Chargement et utilisation dynamiques des types
description: Chargez et utilisez dynamiquement les types dans .NET. Utilisez la réflexion, qui fournit l’infrastructure utilisée par les compilateurs de langage pour implémenter la liaison tardive implicite.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
ms.openlocfilehash: be9991a4df866f65aabe063be3cc2b374f4d124d
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96266790"
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="8aae6-104">Chargement et utilisation dynamiques des types</span><span class="sxs-lookup"><span data-stu-id="8aae6-104">Dynamically Loading and Using Types</span></span>

<span data-ttu-id="8aae6-105">La réflexion fournit l’infrastructure utilisée par les compilateurs de langages pour implémenter la liaison tardive implicite.</span><span class="sxs-lookup"><span data-stu-id="8aae6-105">Reflection provides infrastructure used by language compilers to implement implicit late binding.</span></span> <span data-ttu-id="8aae6-106">La liaison est le processus de localisation de la déclaration (en d’autres termes, l’implémentation) qui correspond à un type spécifié unique.</span><span class="sxs-lookup"><span data-stu-id="8aae6-106">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="8aae6-107">Quand ce processus se produit au moment de l’exécution plutôt qu’au moment de la compilation, il est appelé liaison tardive.</span><span class="sxs-lookup"><span data-stu-id="8aae6-107">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> <span data-ttu-id="8aae6-108">Visual Basic permet d’utiliser la liaison tardive implicite dans le code ; le compilateur Visual Basic appelle une méthode d’assistance qui utilise la réflexion pour récupérer le type d’objet.</span><span class="sxs-lookup"><span data-stu-id="8aae6-108">Visual Basic allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="8aae6-109">Les arguments passés à la méthode d’assistance entraînent l’appel de la méthode appropriée au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="8aae6-109">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="8aae6-110">Ces arguments sont l’instance (un objet) sur laquelle appeler la méthode, le nom de la méthode appelée (une chaîne) et les arguments passés à la méthode appelée (un tableau d’objets).</span><span class="sxs-lookup"><span data-stu-id="8aae6-110">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="8aae6-111">Dans l’exemple suivant, le compilateur Visual Basic utilise implicitement la réflexion pour appeler une méthode sur un objet dont le type n’est pas connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="8aae6-111">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="8aae6-112">Une classe **HelloWorld** a une méthode **PrintHello** qui imprime « Hello World » concaténé à du texte passé à la méthode **PrintHello**.</span><span class="sxs-lookup"><span data-stu-id="8aae6-112">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="8aae6-113">La méthode **PrintHello** appelée dans cet exemple équivaut en fait à un <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>. Le code Visual Basic permet à la méthode **PrintHello** d’être appelée comme si le type de l’objet (helloObj) était connu au moment de la compilation (liaison anticipée) plutôt qu’au moment de l’exécution (liaison tardive).</span><span class="sxs-lookup"><span data-stu-id="8aae6-113">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```vb
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="8aae6-114">Liaison personnalisée</span><span class="sxs-lookup"><span data-stu-id="8aae6-114">Custom Binding</span></span>  

 <span data-ttu-id="8aae6-115">Outre son utilisation implicite par les compilateurs, la réflexion peut également être utilisée explicitement dans le code pour exécuter la liaison tardive.</span><span class="sxs-lookup"><span data-stu-id="8aae6-115">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="8aae6-116">Le [Common Language Runtime](../../standard/clr.md) prend en charge plusieurs langages de programmation dont les règles de liaison diffèrent.</span><span class="sxs-lookup"><span data-stu-id="8aae6-116">The [common language runtime](../../standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="8aae6-117">Dans le cadre de la liaison anticipée, les générateurs de code peuvent contrôler complètement cette liaison.</span><span class="sxs-lookup"><span data-stu-id="8aae6-117">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="8aae6-118">Cependant, dans la liaison tardive par réflexion, celle-ci doit être contrôlée par une liaison personnalisée.</span><span class="sxs-lookup"><span data-stu-id="8aae6-118">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="8aae6-119">La classe <xref:System.Reflection.Binder> assure un contrôle personnalisé de la sélection et de l’appel des membres.</span><span class="sxs-lookup"><span data-stu-id="8aae6-119">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="8aae6-120">Grâce à la liaison personnalisée, vous pouvez charger un assembly au moment de l’exécution, obtenir des informations sur les types de cet assembly, spécifier le type souhaité, puis appeler les méthodes ou accéder aux champs ou propriétés de ce type.</span><span class="sxs-lookup"><span data-stu-id="8aae6-120">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="8aae6-121">Cette technique est très utile quand vous ne connaissez pas le type d’un objet au moment de la compilation, par exemple quand le type de l’objet dépend de l’entrée d’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="8aae6-121">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="8aae6-122">L’exemple suivant illustre un binder personnalisé simple qui ne fournit aucune conversion de type d’argument.</span><span class="sxs-lookup"><span data-stu-id="8aae6-122">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="8aae6-123">Le code pour `Simple_Type.dll` précède l’exemple principal.</span><span class="sxs-lookup"><span data-stu-id="8aae6-123">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="8aae6-124">Créez `Simple_Type.dll`, puis incluez une référence à ce fichier dans le projet au moment de la génération.</span><span class="sxs-lookup"><span data-stu-id="8aae6-124">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="8aae6-125">InvokeMember et CreateInstance</span><span class="sxs-lookup"><span data-stu-id="8aae6-125">InvokeMember and CreateInstance</span></span>  

 <span data-ttu-id="8aae6-126">Utilisez <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> pour appeler un membre d’un type.</span><span class="sxs-lookup"><span data-stu-id="8aae6-126">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="8aae6-127">Les méthodes **CreateInstance** de diverses classes, telles que <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> et <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, sont des formes particulières de **InvokeMember** qui créent des instances du type spécifié.</span><span class="sxs-lookup"><span data-stu-id="8aae6-127">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="8aae6-128">La classe **Binder** est utilisée pour la résolution de surcharge et la contrainte d’argument dans ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="8aae6-128">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="8aae6-129">L’exemple suivant montre les trois combinaisons possibles de contrainte d’argument (conversion de type) et de sélection de membre.</span><span class="sxs-lookup"><span data-stu-id="8aae6-129">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="8aae6-130">Dans le cas n°1, aucune contrainte d’argument ou sélection de membre n’est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8aae6-130">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="8aae6-131">Dans le cas n°2, seule la sélection de membre est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8aae6-131">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="8aae6-132">Dans le cas n°3, seule la contrainte d’argument est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8aae6-132">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="8aae6-133">La résolution de surcharge est nécessaire quand plusieurs membres du même nom sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="8aae6-133">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="8aae6-134">Les méthodes <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> et <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> permettent de résoudre la liaison à un seul membre.</span><span class="sxs-lookup"><span data-stu-id="8aae6-134">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="8aae6-135">**Binder.BindToMethod** fournit également la résolution des propriétés par l’intermédiaire des accesseurs de propriété **get** et **set**.</span><span class="sxs-lookup"><span data-stu-id="8aae6-135">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="8aae6-136">**BindToMethod** retourne le <xref:System.Reflection.MethodBase> à appeler ou une référence null (**Nothing** en Visual Basic) si aucun appel n’est possible.</span><span class="sxs-lookup"><span data-stu-id="8aae6-136">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="8aae6-137">La valeur de retour de **MethodBase** n’est pas forcément contenue dans le paramètre *match*, même si cela est souvent le cas.</span><span class="sxs-lookup"><span data-stu-id="8aae6-137">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="8aae6-138">Quand les arguments ByRef sont présents, l’appelant souhaitera peut-être les récupérer.</span><span class="sxs-lookup"><span data-stu-id="8aae6-138">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="8aae6-139">Ainsi, **Binder** autorise un client à mapper le tableau des arguments vers sa forme d’origine si **BindToMethod** a manipulé le tableau des arguments.</span><span class="sxs-lookup"><span data-stu-id="8aae6-139">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="8aae6-140">Pour ce faire, l’appelant doit avoir la garantie que l’ordre des arguments n’a pas été changé.</span><span class="sxs-lookup"><span data-stu-id="8aae6-140">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="8aae6-141">Quand des arguments sont passés par nom, **Binder** réorganise le tableau d’arguments, et c’est ce que voit l’appelant.</span><span class="sxs-lookup"><span data-stu-id="8aae6-141">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="8aae6-142">Pour plus d’informations, consultez <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8aae6-142">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8aae6-143">L’ensemble des membres disponibles correspond aux membres définis dans le type ou n’importe quel type de base.</span><span class="sxs-lookup"><span data-stu-id="8aae6-143">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="8aae6-144">Si <xref:System.Reflection.BindingFlags> est spécifié, les membres d’une accessibilité quelconque sont retournés dans l’ensemble.</span><span class="sxs-lookup"><span data-stu-id="8aae6-144">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="8aae6-145">Si **BindingFlags.NonPublic** n’est pas spécifié, le binder doit appliquer les règles d’accessibilité.</span><span class="sxs-lookup"><span data-stu-id="8aae6-145">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="8aae6-146">Quand vous spécifiez l’indicateur de liaison **Public** ou **NonPublic**, vous devez également spécifier l’indicateur de liaison **Instance** ou **Static**, sinon aucun membre n’est retourné.</span><span class="sxs-lookup"><span data-stu-id="8aae6-146">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="8aae6-147">S’il n’existe qu’un seul membre avec le nom spécifié, aucun rappel n’est nécessaire, et la liaison s’effectue sur cette méthode.</span><span class="sxs-lookup"><span data-stu-id="8aae6-147">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="8aae6-148">Le cas n°1 de l’exemple de code illustre ce point : une seule méthode **PrintBob** étant disponible, aucun rappel n’est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8aae6-148">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="8aae6-149">S’il existe plusieurs membres dans l’ensemble disponible, toutes ces méthodes sont passées à **BindToMethod**, qui sélectionne la méthode appropriée et la retourne.</span><span class="sxs-lookup"><span data-stu-id="8aae6-149">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="8aae6-150">Dans le cas n°2 de l’exemple de code, il existe deux méthodes nommées **PrintValue**.</span><span class="sxs-lookup"><span data-stu-id="8aae6-150">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="8aae6-151">La méthode appropriée est sélectionnée par l’appel à **BindToMethod**.</span><span class="sxs-lookup"><span data-stu-id="8aae6-151">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="8aae6-152"><xref:System.Reflection.Binder.ChangeType%2A> effectue une contrainte d’argument (conversion de type) qui convertit les arguments réels au type des arguments formels de la méthode sélectionnée.</span><span class="sxs-lookup"><span data-stu-id="8aae6-152"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="8aae6-153">**ChangeType** est appelé pour chaque argument même si les types correspondent exactement.</span><span class="sxs-lookup"><span data-stu-id="8aae6-153">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="8aae6-154">Dans le cas n°3 de l’exemple de code, un argument réel de type **String** avec la valeur « 5,5 » est passé à une méthode avec un argument formel de type **Double**.</span><span class="sxs-lookup"><span data-stu-id="8aae6-154">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="8aae6-155">Pour que l’appel réussisse, la valeur de chaîne « 5,5 » doit être convertie en valeur double.</span><span class="sxs-lookup"><span data-stu-id="8aae6-155">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="8aae6-156">**ChangeType** effectue cette conversion.</span><span class="sxs-lookup"><span data-stu-id="8aae6-156">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="8aae6-157">**ChangeType** n’effectue que des [contraintes étendues](../../standard/base-types/type-conversion.md) ou sans perte, comme l’illustre le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="8aae6-157">**ChangeType** performs only lossless or [widening coercions](../../standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="8aae6-158">Type de source</span><span class="sxs-lookup"><span data-stu-id="8aae6-158">Source type</span></span>|<span data-ttu-id="8aae6-159">Type cible</span><span class="sxs-lookup"><span data-stu-id="8aae6-159">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="8aae6-160">Tout type</span><span class="sxs-lookup"><span data-stu-id="8aae6-160">Any type</span></span>|<span data-ttu-id="8aae6-161">Son type de base</span><span class="sxs-lookup"><span data-stu-id="8aae6-161">Its base type</span></span>|  
|<span data-ttu-id="8aae6-162">Tout type</span><span class="sxs-lookup"><span data-stu-id="8aae6-162">Any type</span></span>|<span data-ttu-id="8aae6-163">L’interface implémentée</span><span class="sxs-lookup"><span data-stu-id="8aae6-163">Interface it implements</span></span>|  
|<span data-ttu-id="8aae6-164">Char</span><span class="sxs-lookup"><span data-stu-id="8aae6-164">Char</span></span>|<span data-ttu-id="8aae6-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="8aae6-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="8aae6-166">Byte</span><span class="sxs-lookup"><span data-stu-id="8aae6-166">Byte</span></span>|<span data-ttu-id="8aae6-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="8aae6-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="8aae6-168">SByte</span><span class="sxs-lookup"><span data-stu-id="8aae6-168">SByte</span></span>|<span data-ttu-id="8aae6-169">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="8aae6-169">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="8aae6-170">UInt16</span><span class="sxs-lookup"><span data-stu-id="8aae6-170">UInt16</span></span>|<span data-ttu-id="8aae6-171">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="8aae6-171">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="8aae6-172">Int16</span><span class="sxs-lookup"><span data-stu-id="8aae6-172">Int16</span></span>|<span data-ttu-id="8aae6-173">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="8aae6-173">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="8aae6-174">UInt32</span><span class="sxs-lookup"><span data-stu-id="8aae6-174">UInt32</span></span>|<span data-ttu-id="8aae6-175">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="8aae6-175">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="8aae6-176">Int32</span><span class="sxs-lookup"><span data-stu-id="8aae6-176">Int32</span></span>|<span data-ttu-id="8aae6-177">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="8aae6-177">Int64, Single, Double</span></span>|  
|<span data-ttu-id="8aae6-178">UInt64</span><span class="sxs-lookup"><span data-stu-id="8aae6-178">UInt64</span></span>|<span data-ttu-id="8aae6-179">Single, Double</span><span class="sxs-lookup"><span data-stu-id="8aae6-179">Single, Double</span></span>|  
|<span data-ttu-id="8aae6-180">Int64</span><span class="sxs-lookup"><span data-stu-id="8aae6-180">Int64</span></span>|<span data-ttu-id="8aae6-181">Single, Double</span><span class="sxs-lookup"><span data-stu-id="8aae6-181">Single, Double</span></span>|  
|<span data-ttu-id="8aae6-182">Unique</span><span class="sxs-lookup"><span data-stu-id="8aae6-182">Single</span></span>|<span data-ttu-id="8aae6-183">Double</span><span class="sxs-lookup"><span data-stu-id="8aae6-183">Double</span></span>|  
|<span data-ttu-id="8aae6-184">Type non référence</span><span class="sxs-lookup"><span data-stu-id="8aae6-184">Nonreference type</span></span>|<span data-ttu-id="8aae6-185">Type de référence</span><span class="sxs-lookup"><span data-stu-id="8aae6-185">Reference type</span></span>|  
  
 <span data-ttu-id="8aae6-186">La classe <xref:System.Type> a des méthodes **Get** qui utilisent des paramètres de type **Binder** pour résoudre les références à un membre particulier.</span><span class="sxs-lookup"><span data-stu-id="8aae6-186">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="8aae6-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> et <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> recherchent un membre particulier du type actuel en fournissant les informations de signature pour ce membre.</span><span class="sxs-lookup"><span data-stu-id="8aae6-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="8aae6-188"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> et <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> sont rappelés pour sélectionner les informations de signature données des méthodes appropriées.</span><span class="sxs-lookup"><span data-stu-id="8aae6-188"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8aae6-189">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="8aae6-189">See also</span></span>

- <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- [<span data-ttu-id="8aae6-190">Affichage des informations de type</span><span class="sxs-lookup"><span data-stu-id="8aae6-190">Viewing Type Information</span></span>](viewing-type-information.md)
- [<span data-ttu-id="8aae6-191">Conversion de type dans le .NET Framework</span><span class="sxs-lookup"><span data-stu-id="8aae6-191">Type Conversion in the .NET Framework</span></span>](../../standard/base-types/type-conversion.md)
