---
title: Notions fondamentales de la sécurité d'accès du code
description: 'Découvrez les principes fondamentaux de la sécurité d’accès du code pour les applications ciblant le CLR : le code de type sécurisé, la syntaxe impérative et déclarative, les bibliothèques de classes sécurisées et le code transparent.'
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- security [.NET Framework], code access security
ms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921
ms.openlocfilehash: 9f6049913a2e8cf3e3f220b0148598a236b60bef
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90557069"
---
# <a name="code-access-security-basics"></a><span data-ttu-id="72052-103">Notions fondamentales de la sécurité d'accès du code</span><span class="sxs-lookup"><span data-stu-id="72052-103">Code Access Security Basics</span></span>

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

<span data-ttu-id="72052-104">Chaque application qui cible le Common Language Runtime (autrement dit, chaque application managée) doit interagir avec le système de sécurité du runtime.</span><span class="sxs-lookup"><span data-stu-id="72052-104">Every application that targets the common language runtime (that is, every managed application) must interact with the runtime's security system.</span></span> <span data-ttu-id="72052-105">Quand une application managée est chargée, son hôte lui attribue automatiquement un jeu d'autorisations.</span><span class="sxs-lookup"><span data-stu-id="72052-105">When a managed application is loaded, its host automatically grants it a set of permissions.</span></span> <span data-ttu-id="72052-106">Ces autorisations sont déterminées par les paramètres de sécurité locaux de l'hôte ou par le bac à sable (sandbox) dans lequel se trouve l'application.</span><span class="sxs-lookup"><span data-stu-id="72052-106">These permissions are determined by the host's local security settings or by the sandbox the application is in.</span></span> <span data-ttu-id="72052-107">En fonction de ces autorisations, l'application peut s'exécuter correctement ou générer une exception de sécurité.</span><span class="sxs-lookup"><span data-stu-id="72052-107">Depending on these permissions, the application either runs properly or generates a security exception.</span></span>

<span data-ttu-id="72052-108">L'hôte par défaut pour les applications bureautiques permet d'exécuter du code avec une confiance totale.</span><span class="sxs-lookup"><span data-stu-id="72052-108">The default host for desktop applications allows code to run in full trust.</span></span> <span data-ttu-id="72052-109">Ainsi, si votre application cible le bureau, elle dispose d'un jeu d'autorisations illimité.</span><span class="sxs-lookup"><span data-stu-id="72052-109">Therefore, if your application targets the desktop, it has an unrestricted permission set.</span></span> <span data-ttu-id="72052-110">D'autres hôtes ou bacs à sable (sandbox) fournissent un jeu d'autorisations limité pour les applications.</span><span class="sxs-lookup"><span data-stu-id="72052-110">Other hosts or sandboxes provide a limited permission set for applications.</span></span> <span data-ttu-id="72052-111">Étant donné que le jeu d'autorisations peut changer d'un hôte à l'autre, l'application que vous concevez doit utiliser uniquement les autorisations permises par votre hôte cible.</span><span class="sxs-lookup"><span data-stu-id="72052-111">Because the permission set can change from host to host, you must design your application to use only the permissions that your target host allows.</span></span>

<span data-ttu-id="72052-112">Vous devez connaître les concepts de sécurité d'accès du code suivants pour écrire des applications efficaces ciblant le Common Language Runtime :</span><span class="sxs-lookup"><span data-stu-id="72052-112">You must be familiar with the following code access security concepts in order to write effective applications that target the common language runtime:</span></span>

- <span data-ttu-id="72052-113">**Code de type sécurisé**: le code de type sécurisé est du code qui accède aux types uniquement de manière autorisée et bien définie.</span><span class="sxs-lookup"><span data-stu-id="72052-113">**Type-safe code**: Type-safe code is code that accesses types only in well-defined, allowable ways.</span></span> <span data-ttu-id="72052-114">Par exemple, dans le cas d'une référence d'objet valide, le code de type sécurisé peut accéder à la mémoire à des décalages fixes correspondant à des membres de champ réels.</span><span class="sxs-lookup"><span data-stu-id="72052-114">For example, given a valid object reference, type-safe code can access memory at fixed offsets that correspond to actual field members.</span></span> <span data-ttu-id="72052-115">Si le code accède à la mémoire à des décalages arbitraires en dehors de la plage de mémoire qui appartient aux champs de cet objet exposés publiquement, il n'est pas de type sécurisé.</span><span class="sxs-lookup"><span data-stu-id="72052-115">If the code accesses memory at arbitrary offsets outside the range of memory that belongs to that object's publicly exposed fields, it is not type-safe.</span></span> <span data-ttu-id="72052-116">Pour permettre au code de bénéficier de la sécurité d'accès du code, vous devez utiliser un compilateur qui génère du code de type sécurisé.</span><span class="sxs-lookup"><span data-stu-id="72052-116">To enable code to benefit from code access security, you must use a compiler that generates verifiably type-safe code.</span></span> <span data-ttu-id="72052-117">Pour plus d’informations, consultez la section [écriture de code de type sécurisé vérifié](#typesafe_code) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="72052-117">For more information, see the [Writing Verifiably Type-Safe Code](#typesafe_code) section later in this topic.</span></span>

- <span data-ttu-id="72052-118">**Syntaxe impérative et déclarative**: le code qui cible le Common Language Runtime peut interagir avec le système de sécurité en demandant des autorisations, en exigeant que les appelants aient des autorisations spécifiées et en substituant certains paramètres de sécurité (avec suffisamment de privilèges).</span><span class="sxs-lookup"><span data-stu-id="72052-118">**Imperative and declarative syntax**: Code that targets the common language runtime can interact with the security system by requesting permissions, demanding that callers have specified permissions, and overriding certain security settings (given enough privileges).</span></span> <span data-ttu-id="72052-119">Vous utilisez deux formes de syntaxe pour interagir par programmation avec le système de sécurité .NET Framework : la syntaxe déclarative et la syntaxe impérative.</span><span class="sxs-lookup"><span data-stu-id="72052-119">You use two forms of syntax to programmatically interact with the .NET Framework security system: declarative syntax and imperative syntax.</span></span> <span data-ttu-id="72052-120">Les appels déclaratifs sont effectués à l'aide d'attributs, tandis que les appels impératifs sont réalisés à l'aide de nouvelles instances de classes dans votre code.</span><span class="sxs-lookup"><span data-stu-id="72052-120">Declarative calls are performed using attributes; imperative calls are performed using new instances of classes within your code.</span></span> <span data-ttu-id="72052-121">Certains appels peuvent être effectués de manière impérative uniquement, d'autres peuvent l'être de manière déclarative uniquement et certains peuvent l'être des deux manières.</span><span class="sxs-lookup"><span data-stu-id="72052-121">Some calls can be performed only imperatively, others can be performed only declaratively, and some calls can be performed in either manner.</span></span>

- <span data-ttu-id="72052-122">**Bibliothèques de classes sécurisées**: une bibliothèque de classes sécurisée utilise des demandes de sécurité pour s’assurer que les appelants de la bibliothèque ont l’autorisation d’accéder aux ressources exposées par la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="72052-122">**Secure class libraries**: A secure class library uses security demands to ensure that the library's callers have permission to access the resources that the library exposes.</span></span> <span data-ttu-id="72052-123">Par exemple, une bibliothèque de classes sécurisée peut avoir une méthode de création de fichiers qui exige que ses appelants possèdent des autorisations pour créer des fichiers.</span><span class="sxs-lookup"><span data-stu-id="72052-123">For example, a secure class library might have a method for creating files that would demand that its callers have permissions to create files.</span></span> <span data-ttu-id="72052-124">Le .NET Framework se compose de bibliothèques de classes sécurisées.</span><span class="sxs-lookup"><span data-stu-id="72052-124">The .NET Framework consists of secure class libraries.</span></span> <span data-ttu-id="72052-125">Vous devez connaître les autorisations nécessaires pour accéder aux bibliothèques utilisées par votre code.</span><span class="sxs-lookup"><span data-stu-id="72052-125">You should be aware of the permissions required to access any library that your code uses.</span></span> <span data-ttu-id="72052-126">Pour plus d’informations, consultez la section [utilisation des bibliothèques de classes sécurisées](#secure_library) , plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="72052-126">For more information, see the [Using Secure Class Libraries](#secure_library) section later in this topic.</span></span>

- <span data-ttu-id="72052-127">**Code transparent**: à partir du .NET Framework 4, en plus d’identifier des autorisations spécifiques, vous devez également déterminer si votre code doit s’exécuter en tant que code transparent de sécurité.</span><span class="sxs-lookup"><span data-stu-id="72052-127">**Transparent code**: Starting with the .NET Framework 4, in addition to identifying specific permissions, you must also determine whether your code should run as security-transparent.</span></span> <span data-ttu-id="72052-128">Le code transparent de sécurité ne peut pas appeler de types ni de membres critiques de sécurité.</span><span class="sxs-lookup"><span data-stu-id="72052-128">Security-transparent code cannot call types or members that are identified as security-critical.</span></span> <span data-ttu-id="72052-129">Cette règle s'applique aux applications de confiance totale et aux applications partiellement fiables.</span><span class="sxs-lookup"><span data-stu-id="72052-129">This rule applies to full-trust applications as well as partially trusted applications.</span></span> <span data-ttu-id="72052-130">Pour plus d’informations, consultez [code transparent de sécurité](security-transparent-code.md).</span><span class="sxs-lookup"><span data-stu-id="72052-130">For more information, see [Security-Transparent Code](security-transparent-code.md).</span></span>

<a name="typesafe_code"></a>

## <a name="writing-verifiably-type-safe-code"></a><span data-ttu-id="72052-131">Écriture de code de type sécurisé vérifié</span><span class="sxs-lookup"><span data-stu-id="72052-131">Writing Verifiably Type-Safe Code</span></span>

<span data-ttu-id="72052-132">La compilation juste-à-temps (JIT, Just-In-Time) exécute un processus de vérification qui examine le code et tente de déterminer s'il est de type sécurisé.</span><span class="sxs-lookup"><span data-stu-id="72052-132">Just-in-time (JIT) compilation performs a verification process that examines code and tries to determine whether the code is type-safe.</span></span> <span data-ttu-id="72052-133">Le code qui est prouvé pendant la vérification pour être de type sécurisé est appelé *Code de type sécurisé vérifié*.</span><span class="sxs-lookup"><span data-stu-id="72052-133">Code that is proven during verification to be type-safe is called *verifiably type-safe code*.</span></span> <span data-ttu-id="72052-134">Le code peut être de type sécurisé, mais non de type sécurisé vérifié, en raison des limites du processus de vérification ou du compilateur.</span><span class="sxs-lookup"><span data-stu-id="72052-134">Code can be type-safe, yet might not be verifiably type-safe because of the limitations of the verification process or of the compiler.</span></span> <span data-ttu-id="72052-135">Tous les langages ne sont pas de type sécurisé, et certains compilateurs de langage, tels que Microsoft Visual C++, ne peuvent pas générer de code managé de type sécurisé vérifié.</span><span class="sxs-lookup"><span data-stu-id="72052-135">Not all languages are type-safe, and some language compilers, such as Microsoft Visual C++, cannot generate verifiably type-safe managed code.</span></span> <span data-ttu-id="72052-136">Pour déterminer si le compilateur de langage que vous utilisez génère du code de type sécurisé vérifié, consultez la documentation du compilateur.</span><span class="sxs-lookup"><span data-stu-id="72052-136">To determine whether the language compiler you use generates verifiably type-safe code, consult the compiler's documentation.</span></span> <span data-ttu-id="72052-137">Si vous utilisez un compilateur de langage qui génère du code de type sécurisé vérifié uniquement lorsque vous évitez certaines constructions de langage, vous souhaiterez peut-être utiliser l' [outil PEVerify](../tools/peverify-exe-peverify-tool.md) pour déterminer si votre code est de type sécurisé vérifié.</span><span class="sxs-lookup"><span data-stu-id="72052-137">If you use a language compiler that generates verifiably type-safe code only when you avoid certain language constructs, you might want to use the [PEVerify tool](../tools/peverify-exe-peverify-tool.md) to determine whether your code is verifiably type-safe.</span></span>

<span data-ttu-id="72052-138">Le code qui n'est pas de type sécurisé vérifié peut tenter de s'exécuter si la stratégie de sécurité permet au code de contourner la vérification.</span><span class="sxs-lookup"><span data-stu-id="72052-138">Code that is not verifiably type-safe can attempt to execute if security policy allows the code to bypass verification.</span></span> <span data-ttu-id="72052-139">Cependant, étant donné que la sécurité de type est une partie essentielle du mécanisme du runtime pour isoler les assemblys, la sécurité ne peut pas être appliquée de manière fiable si du code enfreint les règles de la sécurité de type.</span><span class="sxs-lookup"><span data-stu-id="72052-139">However, because type safety is an essential part of the runtime's mechanism for isolating assemblies, security cannot be reliably enforced if code violates the rules of type safety.</span></span> <span data-ttu-id="72052-140">Par défaut, du code qui n'est pas de type sécurisé n'est autorisé à s'exécuter que s'il provient de l'ordinateur local.</span><span class="sxs-lookup"><span data-stu-id="72052-140">By default, code that is not type-safe is allowed to run only if it originates from the local computer.</span></span> <span data-ttu-id="72052-141">Du code mobile doit donc être de type sécurisé.</span><span class="sxs-lookup"><span data-stu-id="72052-141">Therefore, mobile code should be type-safe.</span></span>

<a name="secure_library"></a>

## <a name="using-secure-class-libraries"></a><span data-ttu-id="72052-142">Utilisation de bibliothèques de classes sécurisées</span><span class="sxs-lookup"><span data-stu-id="72052-142">Using Secure Class Libraries</span></span>

<span data-ttu-id="72052-143">Si votre code demande et reçoit les autorisations requises par la bibliothèque de classes, il sera autorisé à accéder à la bibliothèque et les ressources exposées par la bibliothèque seront protégées de tout accès non autorisé.</span><span class="sxs-lookup"><span data-stu-id="72052-143">If your code requests and is granted the permissions required by the class library, it will be allowed to access the library and the resources that the library exposes will be protected from unauthorized access.</span></span> <span data-ttu-id="72052-144">Si votre code n'a pas les autorisations appropriées, il ne sera pas autorisé à accéder à la bibliothèque de classes et du code nuisible ne pourra pas utiliser votre code pour accéder aux ressources de manière indirecte.</span><span class="sxs-lookup"><span data-stu-id="72052-144">If your code does not have the appropriate permissions, it will not be allowed to access the class library, and malicious code will not be able to use your code to indirectly access protected resources.</span></span> <span data-ttu-id="72052-145">Tout autre code qui appelle votre code doit également être autorisé à accéder à la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="72052-145">Other code that calls your code must also have permission to access the library.</span></span> <span data-ttu-id="72052-146">Dans le cas contraire, l'exécution de votre code s'en trouvera également entravée.</span><span class="sxs-lookup"><span data-stu-id="72052-146">If it does not, your code will be restricted from running as well.</span></span>

<span data-ttu-id="72052-147">La sécurité d'accès du code n'élimine pas la possibilité d'une erreur humaine dans l'écriture du code.</span><span class="sxs-lookup"><span data-stu-id="72052-147">Code access security does not eliminate the possibility of human error in writing code.</span></span> <span data-ttu-id="72052-148">Cependant, si votre application utilise les bibliothèques de classes sécurisées pour accéder aux ressources protégées, le risque est réduit pour le code de l'application, car les bibliothèques de classes sont soigneusement examinées quant aux éventuels problèmes de sécurité.</span><span class="sxs-lookup"><span data-stu-id="72052-148">However, if your application uses secure class libraries to access protected resources, the security risk for application code is decreased, because class libraries are closely scrutinized for potential security problems.</span></span>

## <a name="declarative-security"></a><span data-ttu-id="72052-149">Sécurité déclarative</span><span class="sxs-lookup"><span data-stu-id="72052-149">Declarative Security</span></span>

<span data-ttu-id="72052-150">La syntaxe de sécurité déclarative utilise des [attributs](../../standard/attributes/index.md) pour placer des informations de sécurité dans les [métadonnées](../../standard/metadata-and-self-describing-components.md) de votre code.</span><span class="sxs-lookup"><span data-stu-id="72052-150">Declarative security syntax uses [attributes](../../standard/attributes/index.md) to place security information into the [metadata](../../standard/metadata-and-self-describing-components.md) of your code.</span></span> <span data-ttu-id="72052-151">Les attributs peuvent être placés au niveau de l'assembly, de la classe ou du membre pour indiquer le type de demande, d'exigence ou de substitution que vous souhaitez utiliser.</span><span class="sxs-lookup"><span data-stu-id="72052-151">Attributes can be placed at the assembly, class, or member level, to indicate the type of request, demand, or override you want to use.</span></span> <span data-ttu-id="72052-152">Les demandes sont utilisées dans les applications qui ciblent le Common Language Runtime pour informer le système de sécurité du runtime des autorisations dont votre application a besoin ou qu'elle refuse.</span><span class="sxs-lookup"><span data-stu-id="72052-152">Requests are used in applications that target the common language runtime to inform the runtime security system about the permissions that your application needs or does not want.</span></span> <span data-ttu-id="72052-153">Les exigences et les substitutions sont utilisées dans les bibliothèques pour protéger les ressources des appelants ou substituer le comportement de sécurité par défaut.</span><span class="sxs-lookup"><span data-stu-id="72052-153">Demands and overrides are used in libraries to help protect resources from callers or to override default security behavior.</span></span>

> [!NOTE]
> <span data-ttu-id="72052-154">Dans le .NET Framework 4, des modifications importantes ont été apportées à la terminologie et au modèle de sécurité .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="72052-154">In the .NET Framework 4, there have been important changes to the .NET Framework security model and terminology.</span></span> <span data-ttu-id="72052-155">Pour plus d’informations sur ces modifications, consultez [modifications de sécurité](/previous-versions/dotnet/framework/security/security-changes).</span><span class="sxs-lookup"><span data-stu-id="72052-155">For more information about these changes, see [Security Changes](/previous-versions/dotnet/framework/security/security-changes).</span></span>

<span data-ttu-id="72052-156">Pour utiliser des appels de sécurité déclarative, vous devez initialiser les données d'état de l'objet d'autorisation afin qu'elles représentent la forme particulière de l'autorisation dont vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="72052-156">In order to use declarative security calls, you must initialize the state data of the permission object so that it represents the particular form of permission you need.</span></span> <span data-ttu-id="72052-157">Chaque autorisation intégrée a un attribut auquel une énumération <xref:System.Security.Permissions.SecurityAction> est passée pour décrire le type d'opération de sécurité que vous souhaitez effectuer.</span><span class="sxs-lookup"><span data-stu-id="72052-157">Every built-in permission has an attribute that is passed a <xref:System.Security.Permissions.SecurityAction> enumeration to describe the type of security operation you want to perform.</span></span> <span data-ttu-id="72052-158">Les autorisations acceptent toutefois aussi leurs propres paramètres qui leur sont exclusifs.</span><span class="sxs-lookup"><span data-stu-id="72052-158">However, permissions also accept their own parameters that are exclusive to them.</span></span>

<span data-ttu-id="72052-159">Le fragment de code suivant illustre la syntaxe déclarative permettant de demander que les appelants de votre code aient une autorisation personnalisée appelée `MyPermission`.</span><span class="sxs-lookup"><span data-stu-id="72052-159">The following code fragment shows declarative syntax for requesting that your code's callers have a custom permission called `MyPermission`.</span></span> <span data-ttu-id="72052-160">Cette autorisation est une autorisation personnalisée hypothétique et n'existe pas dans le .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="72052-160">This permission is a hypothetical custom permission and does not exist in the .NET Framework.</span></span> <span data-ttu-id="72052-161">Dans cet exemple, l'appel déclaratif est placé directement avant la définition de classe, spécifiant que cette autorisation doit être appliquée au niveau de la classe.</span><span class="sxs-lookup"><span data-stu-id="72052-161">In this example, the declarative call is placed directly before the class definition, specifying that this permission be applied to the class level.</span></span> <span data-ttu-id="72052-162">Une structure **SecurityAction. Demand** est passée à l’attribut pour spécifier que les appelants doivent avoir cette autorisation pour pouvoir s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="72052-162">The attribute is passed a **SecurityAction.Demand** structure to specify that callers must have this permission in order to run.</span></span>

```vb
<MyPermission(SecurityAction.Demand, Unrestricted = True)> Public Class MyClass1

   Public Sub New()
      'The constructor is protected by the security call.
   End Sub

   Public Sub MyMethod()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'This method is protected by the security call.
   End Sub
End Class
```

```csharp
[MyPermission(SecurityAction.Demand, Unrestricted = true)]
public class MyClass
{
   public MyClass()
   {
      //The constructor is protected by the security call.
   }

   public void MyMethod()
   {
      //This method is protected by the security call.
   }

   public void YourMethod()
   {
      //This method is protected by the security call.
   }
}
```

## <a name="imperative-security"></a><span data-ttu-id="72052-163">Sécurité impérative</span><span class="sxs-lookup"><span data-stu-id="72052-163">Imperative Security</span></span>

<span data-ttu-id="72052-164">La syntaxe de sécurité impérative émet un appel de sécurité en créant une instance de l'objet d'autorisation que vous souhaitez appeler.</span><span class="sxs-lookup"><span data-stu-id="72052-164">Imperative security syntax issues a security call by creating a new instance of the permission object you want to invoke.</span></span> <span data-ttu-id="72052-165">Vous pouvez utiliser la syntaxe impérative pour effectuer des exigences et des substitutions, mais pas des demandes.</span><span class="sxs-lookup"><span data-stu-id="72052-165">You can use imperative syntax to perform demands and overrides, but not requests.</span></span>

<span data-ttu-id="72052-166">Avant de procéder à l'appel de sécurité, vous devez initialiser les données d'état de l'objet d'autorisation afin qu'elles représentent la forme particulière de l'autorisation dont vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="72052-166">Before you make the security call, you must initialize the state data of the permission object so that it represents the particular form of the permission you need.</span></span> <span data-ttu-id="72052-167">Par exemple, lors de la création d’un <xref:System.Security.Permissions.FileIOPermission> objet, vous pouvez utiliser le constructeur pour initialiser l’objet **FileIOPermission** afin qu’il représente un accès non restreint à tous les fichiers ou aucun accès aux fichiers.</span><span class="sxs-lookup"><span data-stu-id="72052-167">For example, when creating a <xref:System.Security.Permissions.FileIOPermission> object, you can use the constructor to initialize the **FileIOPermission** object so that it represents either unrestricted access to all files or no access to files.</span></span> <span data-ttu-id="72052-168">Vous pouvez également utiliser un autre objet **FileIOPermission** , en passant des paramètres qui indiquent le type d’accès que vous souhaitez que l’objet représente (c’est-à-dire, en lecture, en écriture ou en écriture) et les fichiers que vous voulez que l’objet protège.</span><span class="sxs-lookup"><span data-stu-id="72052-168">Or, you can use a different **FileIOPermission** object, passing parameters that indicate the type of access you want the object to represent (that is, read, append, or write) and what files you want the object to protect.</span></span>

<span data-ttu-id="72052-169">Outre utiliser la syntaxe de sécurité impérative pour appeler un objet de sécurité unique, vous pouvez y recourir pour initialiser un groupe d'autorisations dans un jeu d'autorisations.</span><span class="sxs-lookup"><span data-stu-id="72052-169">In addition to using imperative security syntax to invoke a single security object, you can use it to initialize a group of permissions in a permission set.</span></span> <span data-ttu-id="72052-170">Par exemple, cette technique est la seule façon d’effectuer de manière fiable des appels d' [assertion](using-the-assert-method.md) sur plusieurs autorisations dans une même méthode.</span><span class="sxs-lookup"><span data-stu-id="72052-170">For example, this technique is the only way to reliably perform [assert](using-the-assert-method.md) calls on multiple permissions in one method.</span></span> <span data-ttu-id="72052-171">Utilisez les classes <xref:System.Security.PermissionSet> et <xref:System.Security.NamedPermissionSet> pour créer un groupe d'autorisations, puis appelez la méthode appropriée pour appeler l'appel de sécurité souhaité.</span><span class="sxs-lookup"><span data-stu-id="72052-171">Use the <xref:System.Security.PermissionSet> and <xref:System.Security.NamedPermissionSet> classes to create a group of permissions and then call the appropriate method to invoke the desired security call.</span></span>

<span data-ttu-id="72052-172">Vous pouvez utiliser la syntaxe impérative pour effectuer des exigences et des substitutions, mais pas des demandes.</span><span class="sxs-lookup"><span data-stu-id="72052-172">You can use imperative syntax to perform demands and overrides, but not requests.</span></span> <span data-ttu-id="72052-173">Vous pouvez éventuellement utiliser la syntaxe impérative à la place de la syntaxe déclarative pour les exigences et les substitutions quand les informations dont vous avez besoin pour initialiser l'état d'autorisation ne sont connues qu'au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="72052-173">You might use imperative syntax for demands and overrides instead of declarative syntax when information that you need in order to initialize the permission state becomes known only at run time.</span></span> <span data-ttu-id="72052-174">Par exemple, si vous souhaitez vous assurer que les appelants ont l'autorisation de lire un certain fichier, mais que vous ne connaissez pas le nom du fichier avant l'exécution, utilisez une exigence impérative.</span><span class="sxs-lookup"><span data-stu-id="72052-174">For example, if you want to ensure that callers have permission to read a certain file, but you do not know the name of that file until run time, use an imperative demand.</span></span> <span data-ttu-id="72052-175">Vous pouvez aussi éventuellement choisir d'utiliser des vérifications impératives au lieu de vérifications déclaratives quand vous avez besoin de déterminer si une condition est valable ou non au moment de l'exécution et, en fonction du résultat du test, de procéder (ou non) à une demande de sécurité.</span><span class="sxs-lookup"><span data-stu-id="72052-175">You might also choose to use imperative checks instead of declarative checks when you need to determine at run time whether a condition holds and, based on the result of the test, make a security demand (or not).</span></span>

<span data-ttu-id="72052-176">Le fragment de code suivant illustre la syntaxe impérative permettant de demander que les appelants de votre code aient une autorisation personnalisée appelée `MyPermission`.</span><span class="sxs-lookup"><span data-stu-id="72052-176">The following code fragment shows imperative syntax for requesting that your code's callers have a custom permission called `MyPermission`.</span></span> <span data-ttu-id="72052-177">Cette autorisation est une autorisation personnalisée hypothétique et n'existe pas dans le .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="72052-177">This permission is a hypothetical custom permission and does not exist in the .NET Framework.</span></span> <span data-ttu-id="72052-178">Une instance de `MyPermission` est créée dans `MyMethod`, protégeant uniquement cette méthode avec l'appel de sécurité.</span><span class="sxs-lookup"><span data-stu-id="72052-178">A new instance of `MyPermission` is created in `MyMethod`, guarding only this method with the security call.</span></span>

```vb
Public Class MyClass1

   Public Sub New()

   End Sub

   Public Sub MyMethod()
      'MyPermission is demanded using imperative syntax.
      Dim Perm As New MyPermission()
      Perm.Demand()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'YourMethod 'This method is not protected by the security call.
   End Sub
End Class
```

```csharp
public class MyClass {
   public MyClass(){

   }

   public void MyMethod() {
       //MyPermission is demanded using imperative syntax.
       MyPermission Perm = new MyPermission();
       Perm.Demand();
       //This method is protected by the security call.
   }

   public void YourMethod() {
       //This method is not protected by the security call.
   }
}
```

## <a name="using-managed-wrapper-classes"></a><span data-ttu-id="72052-179">Utilisation des classes wrapper managées</span><span class="sxs-lookup"><span data-stu-id="72052-179">Using Managed Wrapper Classes</span></span>

<span data-ttu-id="72052-180">La plupart des applications et des composants (excepté les bibliothèques sécurisées) ne doivent pas directement appeler du code non managé,</span><span class="sxs-lookup"><span data-stu-id="72052-180">Most applications and components (except secure libraries) should not directly call unmanaged code.</span></span> <span data-ttu-id="72052-181">et ce, pour plusieurs raisons.</span><span class="sxs-lookup"><span data-stu-id="72052-181">There are several reasons for this.</span></span> <span data-ttu-id="72052-182">Si du code appelle directement du code non managé, il ne sera pas autorisé à s'exécuter dans de nombreux cas, car du code doit avoir reçu un niveau de confiance élevé pour appeler du code natif.</span><span class="sxs-lookup"><span data-stu-id="72052-182">If code calls unmanaged code directly, it will not be allowed to run in many circumstances because code must be granted a high level of trust to call native code.</span></span> <span data-ttu-id="72052-183">Si la stratégie est modifiée de manière à autoriser l’exécution de cette application, cela peut considérablement affaiblir la sécurité du système, laissant l’application libre d’effectuer quasiment n’importe quelle opération.</span><span class="sxs-lookup"><span data-stu-id="72052-183">If policy is modified to allow such an application to run, it can significantly weaken the security of the system, leaving the application free to perform almost any operation.</span></span>

<span data-ttu-id="72052-184">De plus, du code qui a l'autorisation d'accéder à du code non managé peut dans l'absolu effectuer pratiquement n'importe quelle opération en appelant dans une interface API non managée.</span><span class="sxs-lookup"><span data-stu-id="72052-184">Additionally, code that has permission to access unmanaged code can probably perform almost any operation by calling into an unmanaged API.</span></span> <span data-ttu-id="72052-185">Par exemple, le code qui a l’autorisation d’appeler du code non managé n’a pas besoin <xref:System.Security.Permissions.FileIOPermission> d’accéder à un fichier ; il peut simplement appeler une API de fichier non managé (Win32) directement, en ignorant l’API de fichier managé qui requiert **FileIOPermission**.</span><span class="sxs-lookup"><span data-stu-id="72052-185">For example, code that has permission to call unmanaged code does not need <xref:System.Security.Permissions.FileIOPermission> to access a file; it can just call an unmanaged (Win32) file API directly, bypassing the managed file API that requires **FileIOPermission**.</span></span> <span data-ttu-id="72052-186">Si du code managé a l'autorisation d'appeler dans du code non managé et n'appelle pas directement dans du code non managé, le système de sécurité ne pourra pas appliquer les restrictions de sécurité de manière fiable puisque le runtime ne peut pas appliquer ces restrictions sur du code non managé.</span><span class="sxs-lookup"><span data-stu-id="72052-186">If managed code has permission to call into unmanaged code and does call directly into unmanaged code, the security system will be unable to reliably enforce security restrictions, since the runtime cannot enforce such restrictions on unmanaged code.</span></span>

<span data-ttu-id="72052-187">Si vous souhaitez que votre application effectue une opération qui nécessite l'accès à du code non managé, elle doit le faire par l'intermédiaire d'une classe managée de confiance qui englobe la fonctionnalité requise (si une telle classe existe).</span><span class="sxs-lookup"><span data-stu-id="72052-187">If you want your application to perform an operation that requires accessing unmanaged code, it should do so through a trusted managed class that wraps the required functionality (if such a class exists).</span></span> <span data-ttu-id="72052-188">Ne créez pas vous-même une classe wrapper s'il en existe déjà une dans une bibliothèque de classes sécurisée.</span><span class="sxs-lookup"><span data-stu-id="72052-188">Do not create a wrapper class yourself if one already exists in a secure class library.</span></span> <span data-ttu-id="72052-189">La classe wrapper, qui doit avoir reçu un degré de confiance élevé pour être autorisée à appeler dans du code non managé, est chargée d'exiger que ses appelants aient les autorisations appropriées.</span><span class="sxs-lookup"><span data-stu-id="72052-189">The wrapper class, which must be granted a high degree of trust to be allowed to make the call into unmanaged code, is responsible for demanding that its callers have the appropriate permissions.</span></span> <span data-ttu-id="72052-190">Si vous utilisez la classe wrapper, votre code a seulement besoin de demander et de recevoir les autorisations que la classe wrapper exige.</span><span class="sxs-lookup"><span data-stu-id="72052-190">If you use the wrapper class, your code only needs to request and be granted the permissions that the wrapper class demands.</span></span>

## <a name="see-also"></a><span data-ttu-id="72052-191">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="72052-191">See also</span></span>

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.NamedPermissionSet>
- <xref:System.Security.Permissions.SecurityAction>
- [<span data-ttu-id="72052-192">Assert</span><span class="sxs-lookup"><span data-stu-id="72052-192">Assert</span></span>](using-the-assert-method.md)
- [<span data-ttu-id="72052-193">Sécurité d’accès du code</span><span class="sxs-lookup"><span data-stu-id="72052-193">Code Access Security</span></span>](code-access-security.md)
- [<span data-ttu-id="72052-194">Notions fondamentales de la sécurité d'accès du code</span><span class="sxs-lookup"><span data-stu-id="72052-194">Code Access Security Basics</span></span>](code-access-security-basics.md)
- [<span data-ttu-id="72052-195">Attributs</span><span class="sxs-lookup"><span data-stu-id="72052-195">Attributes</span></span>](../../standard/attributes/index.md)
- [<span data-ttu-id="72052-196">Métadonnées et composants autodescriptifs</span><span class="sxs-lookup"><span data-stu-id="72052-196">Metadata and Self-Describing Components</span></span>](../../standard/metadata-and-self-describing-components.md)
