---
title: Considérations sur la sécurité et la communication à distance
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
ms.openlocfilehash: 7a56c9894da88382f40dcd475e89776a83a59322
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/14/2020
ms.locfileid: "77215780"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="68218-102">Considérations sur la sécurité et la communication à distance</span><span class="sxs-lookup"><span data-stu-id="68218-102">Security and Remoting Considerations</span></span>
<span data-ttu-id="68218-103">La communication à distance vous permet de définir des appels transparents entre des domaines d'application, des processus ou des ordinateurs.</span><span class="sxs-lookup"><span data-stu-id="68218-103">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="68218-104">Cependant, le parcours de pile de la sécurité d'accès du code ne peut pas traverser des processus ou des limites de machine (il s'applique pourtant entre les domaines d'application du même processus).</span><span class="sxs-lookup"><span data-stu-id="68218-104">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="68218-105">Toute classe accessible à distance (dérivée d'une classe <xref:System.MarshalByRefObject>) doit être responsable de la sécurité.</span><span class="sxs-lookup"><span data-stu-id="68218-105">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="68218-106">Soit le code ne doit être utilisé que dans des environnements fermés où le code appelant peut faire l'objet d'une confiance implicite, soit des appels de communication à distance doivent être conçus de façon à ne pas soumettre de code protégé à une entrée externe qui pourrait être utilisée à des fins malveillantes.</span><span class="sxs-lookup"><span data-stu-id="68218-106">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="68218-107">En général, vous ne devez jamais exposer de méthodes, de propriétés ou d’événements protégés par [LinkDemand](link-demands.md) déclaratif et les vérifications de sécurité <xref:System.Security.Permissions.SecurityAction.InheritanceDemand>.</span><span class="sxs-lookup"><span data-stu-id="68218-107">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="68218-108">Avec la communication à distance, ces contrôles ne sont pas appliqués.</span><span class="sxs-lookup"><span data-stu-id="68218-108">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="68218-109">D’autres vérifications de sécurité, telles que <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), etc., fonctionnent entre les domaines d’application au sein d’un processus, mais ne fonctionnent pas dans les scénarios inter-processus ou inter-ordinateurs.</span><span class="sxs-lookup"><span data-stu-id="68218-109">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="68218-110">Objets protégés</span><span class="sxs-lookup"><span data-stu-id="68218-110">Protected objects</span></span>  
 <span data-ttu-id="68218-111">Certains objets comportent un état de sécurité.</span><span class="sxs-lookup"><span data-stu-id="68218-111">Some objects hold security state in themselves.</span></span> <span data-ttu-id="68218-112">Ces objets ne doivent pas être passés à du code non fiable, qui obtiendrait alors des autorisations de sécurité n'entrant pas dans le champ de ses propres autorisations.</span><span class="sxs-lookup"><span data-stu-id="68218-112">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="68218-113">Un exemple consiste à créer un objet <xref:System.IO.FileStream>.</span><span class="sxs-lookup"><span data-stu-id="68218-113">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="68218-114">Le <xref:System.Security.Permissions.FileIOPermission> est exigé au moment de la création et, en cas de réussite, l'objet de fichier est retourné.</span><span class="sxs-lookup"><span data-stu-id="68218-114">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="68218-115">Toutefois, si cette référence d'objet est passée au code sans les autorisations de fichier, l'objet pourra lire et écrire dans ce fichier.</span><span class="sxs-lookup"><span data-stu-id="68218-115">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="68218-116">La défense la plus simple pour un tel objet consiste à demander la même **autorisation FileIOPermission** de tout code visant à obtenir la référence d’objet via un élément d’API public.</span><span class="sxs-lookup"><span data-stu-id="68218-116">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="68218-117">Questions relatives au franchissement de domaine d'application</span><span class="sxs-lookup"><span data-stu-id="68218-117">Application domain crossing issues</span></span>  
 <span data-ttu-id="68218-118">Pour isoler du code dans des environnements d'hébergement managés, il est courant de générer plusieurs domaines d'application enfants dont la stratégie explicite réduit les niveaux d'autorisations pour divers assemblys.</span><span class="sxs-lookup"><span data-stu-id="68218-118">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="68218-119">Cependant, la stratégie pour ces assemblys reste inchangée dans le domaine d'application par défaut.</span><span class="sxs-lookup"><span data-stu-id="68218-119">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="68218-120">Si l'un des domaines d'application enfants peut forcer le domaine d'application par défaut à charger un assembly, l'effet de l'isolement du code est perdu et les types dans l'assembly chargé de force pourront exécuter du code à un niveau de confiance plus élevé.</span><span class="sxs-lookup"><span data-stu-id="68218-120">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="68218-121">Un domaine d'application peut forcer un autre domaine d'application à charger un assembly et exécuter le code qu'il contient en appelant un proxy vers un objet hébergé dans l'autre domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="68218-121">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="68218-122">Pour obtenir un proxy entre domaines d'application, le domaine d'application qui héberge l'objet doit en distribuer un par l'intermédiaire d'un paramètre d'appel de méthode ou d'une valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="68218-122">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="68218-123">Ou, si le domaine d'application vient d'être créé, le créateur possède un proxy vers l'objet Ou, si le domaine d'application vient d'être créé, le créateur possède un proxy vers l'objet <xref:System.AppDomain> par défaut.</span><span class="sxs-lookup"><span data-stu-id="68218-123">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="68218-124">Ainsi, pour éviter d’interrompre l’isolement du code, un domaine d’application dont le niveau de confiance est supérieur ne doit pas distribuer de références aux objets marshalés par référence (instances de classes dérivées de <xref:System.MarshalByRefObject>) dans son domaine à des domaines d’application dont les niveaux de confiance sont moindres.</span><span class="sxs-lookup"><span data-stu-id="68218-124">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="68218-125">Généralement, le domaine d'application par défaut crée les domaines d'application enfants avec un objet contrôle dans chacun d'entre eux.</span><span class="sxs-lookup"><span data-stu-id="68218-125">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="68218-126">L'objet contrôle gère le nouveau domaine d'application et de manière occasionnelle reçoit des instructions du domaine d'application par défaut, mais il ne peut pas en fait contacter le domaine directement.</span><span class="sxs-lookup"><span data-stu-id="68218-126">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="68218-127">Parfois, le domaine d'application par défaut appelle son proxy vers l'objet contrôle.</span><span class="sxs-lookup"><span data-stu-id="68218-127">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="68218-128">Cependant, il se peut qu'il y ait des cas où il est nécessaire que l'objet contrôle rappelle dans le domaine d'application par défaut.</span><span class="sxs-lookup"><span data-stu-id="68218-128">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="68218-129">Dans ces cas, le domaine d’application par défaut passe un objet de rappel marshalé par référence au constructeur de l’objet contrôle.</span><span class="sxs-lookup"><span data-stu-id="68218-129">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="68218-130">L'objet contrôle est responsable de la protection de ce proxy.</span><span class="sxs-lookup"><span data-stu-id="68218-130">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="68218-131">Si l'objet contrôle devait placer le proxy sur un champ statique public d'une classe public ou exposer publiquement le proxy d'une autre manière, cela ouvrirait un mécanisme dangereux permettant à un autre code de rappeler dans le domaine d'application par défaut.</span><span class="sxs-lookup"><span data-stu-id="68218-131">If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.</span></span> <span data-ttu-id="68218-132">C'est la raison pour laquelle les objets contrôle sont toujours autorisés de manière implicite à maintenir le proxy privé.</span><span class="sxs-lookup"><span data-stu-id="68218-132">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="68218-133">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="68218-133">See also</span></span>

- [<span data-ttu-id="68218-134">Instructions de codage sécurisé</span><span class="sxs-lookup"><span data-stu-id="68218-134">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
