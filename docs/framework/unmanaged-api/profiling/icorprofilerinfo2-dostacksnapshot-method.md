---
title: ICorProfilerInfo2::DoStackSnapshot, méthode
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
ms.openlocfilehash: ff0ff35f42e20725cab49afd971523aabda866c3
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90547803"
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a><span data-ttu-id="7599a-102">ICorProfilerInfo2::DoStackSnapshot, méthode</span><span class="sxs-lookup"><span data-stu-id="7599a-102">ICorProfilerInfo2::DoStackSnapshot Method</span></span>
<span data-ttu-id="7599a-103">Parcourt les frames managés sur la pile pour le thread spécifié et envoie des informations au profileur par le biais d’un rappel.</span><span class="sxs-lookup"><span data-stu-id="7599a-103">Walks the managed frames on the stack for the specified thread, and sends information to the profiler through a callback.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="7599a-104">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="7599a-104">Syntax</span></span>  
  
```cpp  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
## <a name="parameters"></a><span data-ttu-id="7599a-105">Paramètres</span><span class="sxs-lookup"><span data-stu-id="7599a-105">Parameters</span></span>  
 `thread`  
 <span data-ttu-id="7599a-106">dans ID du thread cible.</span><span class="sxs-lookup"><span data-stu-id="7599a-106">[in] The ID of the target thread.</span></span>  
  
 <span data-ttu-id="7599a-107">Le passage de NULL dans `thread` produit un instantané du thread en cours.</span><span class="sxs-lookup"><span data-stu-id="7599a-107">Passing null in `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="7599a-108">Si un `ThreadID` d’un thread différent est passé, le Common Language Runtime (CLR) interrompt ce thread, exécute l’instantané, puis reprend.</span><span class="sxs-lookup"><span data-stu-id="7599a-108">If a `ThreadID` of a different thread is passed, the common language runtime (CLR) suspends that thread, performs the snapshot, and resumes.</span></span>  
  
 `callback`  
 <span data-ttu-id="7599a-109">dans Pointeur vers l’implémentation de la méthode [StackSnapshotCallback](stacksnapshotcallback-function.md) , qui est appelée par le CLR pour fournir au profileur des informations sur chaque frame managé et chaque exécution de frames non managés.</span><span class="sxs-lookup"><span data-stu-id="7599a-109">[in] A pointer to the implementation of the [StackSnapshotCallback](stacksnapshotcallback-function.md) method, which is called by the CLR to provide the profiler with information on each managed frame and each run of unmanaged frames.</span></span>  
  
 <span data-ttu-id="7599a-110">La `StackSnapshotCallback` méthode est implémentée par le writer du profileur.</span><span class="sxs-lookup"><span data-stu-id="7599a-110">The `StackSnapshotCallback` method is implemented by the profiler writer.</span></span>  
  
 `infoFlags`  
 <span data-ttu-id="7599a-111">dans Valeur de l’énumération [COR_PRF_SNAPSHOT_INFO](cor-prf-snapshot-info-enumeration.md) , qui spécifie la quantité de données à repasser pour chaque frame par `StackSnapshotCallback` .</span><span class="sxs-lookup"><span data-stu-id="7599a-111">[in] A value of the [COR_PRF_SNAPSHOT_INFO](cor-prf-snapshot-info-enumeration.md) enumeration, which specifies the amount of data to be passed back for each frame by `StackSnapshotCallback`.</span></span>  
  
 `clientData`  
 <span data-ttu-id="7599a-112">dans Pointeur vers les données du client, qui est passé directement à la `StackSnapshotCallback` fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="7599a-112">[in] A pointer to the client data, which is passed straight through to the `StackSnapshotCallback` callback function.</span></span>  
  
 `context`  
 <span data-ttu-id="7599a-113">dans Pointeur vers une structure Win32 `CONTEXT` qui est utilisée pour amorcer le parcours de la pile.</span><span class="sxs-lookup"><span data-stu-id="7599a-113">[in] A pointer to a Win32 `CONTEXT` structure, which is used to seed the stack walk.</span></span> <span data-ttu-id="7599a-114">La `CONTEXT` structure Win32 contient des valeurs des registres de l’UC et représente l’état de l’UC à un moment précis dans le temps.</span><span class="sxs-lookup"><span data-stu-id="7599a-114">The Win32 `CONTEXT` structure contains values of the CPU registers and represents the state of the CPU at a particular moment in time.</span></span>  
  
 <span data-ttu-id="7599a-115">La valeur de départ aide le CLR à déterminer où commencer le parcours de la pile, si le haut de la pile est un code d’assistance non managé ; dans le cas contraire, la valeur initiale est ignorée.</span><span class="sxs-lookup"><span data-stu-id="7599a-115">The seed helps the CLR determine where to begin the stack walk, if the top of the stack is unmanaged helper code; otherwise, the seed is ignored.</span></span> <span data-ttu-id="7599a-116">Une valeur de départ doit être fournie pour une procédure asynchrone.</span><span class="sxs-lookup"><span data-stu-id="7599a-116">A seed must be supplied for an asynchronous walk.</span></span> <span data-ttu-id="7599a-117">Si vous effectuez une procédure synchrone, aucune valeur de départ n’est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="7599a-117">If you are doing a synchronous walk, no seed is necessary.</span></span>  
  
 <span data-ttu-id="7599a-118">Le `context` paramètre n’est valide que si l’indicateur COR_PRF_SNAPSHOT_CONTEXT a été passé dans le `infoFlags` paramètre.</span><span class="sxs-lookup"><span data-stu-id="7599a-118">The `context` parameter is valid only if the COR_PRF_SNAPSHOT_CONTEXT flag was passed in the `infoFlags` parameter.</span></span>  
  
 `contextSize`  
 <span data-ttu-id="7599a-119">dans Taille de la `CONTEXT` structure, qui est référencée par le `context` paramètre.</span><span class="sxs-lookup"><span data-stu-id="7599a-119">[in] The size of the `CONTEXT` structure, which is referenced by the `context` parameter.</span></span>  
  
## <a name="remarks"></a><span data-ttu-id="7599a-120">Notes</span><span class="sxs-lookup"><span data-stu-id="7599a-120">Remarks</span></span>  
 <span data-ttu-id="7599a-121">Le passage de la valeur null à `thread` génère un instantané du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="7599a-121">Passing null for `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="7599a-122">Les instantanés ne peuvent être utilisés par d’autres threads que si le thread cible est suspendu à ce moment-là.</span><span class="sxs-lookup"><span data-stu-id="7599a-122">Snapshots can be taken of other threads only if the target thread is suspended at the time.</span></span>  
  
 <span data-ttu-id="7599a-123">Quand le profileur souhaite remonter la pile, il appelle `DoStackSnapshot` .</span><span class="sxs-lookup"><span data-stu-id="7599a-123">When the profiler wants to walk the stack, it calls `DoStackSnapshot`.</span></span> <span data-ttu-id="7599a-124">Avant que le CLR ne retourne à partir de cet appel, il appelle `StackSnapshotCallback` plusieurs fois, une fois pour chaque frame managé (ou l’exécution de frames non managés) sur la pile.</span><span class="sxs-lookup"><span data-stu-id="7599a-124">Before the CLR returns from that call, it calls your `StackSnapshotCallback` several times, once for each managed frame (or run of unmanaged frames) on the stack.</span></span> <span data-ttu-id="7599a-125">Lorsque des frames non managés sont détectés, vous devez les parcourir vous-même.</span><span class="sxs-lookup"><span data-stu-id="7599a-125">When unmanaged frames are encountered, you must walk them yourself.</span></span>  
  
 <span data-ttu-id="7599a-126">L’ordre dans lequel la pile est parcourue est l’inverse de la façon dont les frames ont fait l’objet d’un push sur la pile : Frame (dernier push) frame en premier, Frame principal (premier-push) en dernier.</span><span class="sxs-lookup"><span data-stu-id="7599a-126">The order in which the stack is walked is the reverse of how the frames were pushed onto the stack: leaf (last-pushed) frame first, main (first-pushed) frame last.</span></span>  
  
 <span data-ttu-id="7599a-127">Pour plus d’informations sur la façon de programmer le profileur pour parcourir les piles managées, consultez [parcours de la pile du profileur dans le .NET Framework 2,0 : notions de base et au-delà](/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="7599a-127">For more information about how to program the profiler to walk managed stacks, see [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>  
  
 <span data-ttu-id="7599a-128">Un parcours de pile peut être synchrone ou asynchrone, comme expliqué dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="7599a-128">A stack walk can be synchronous or asynchronous, as explained in the following sections.</span></span>  
  
## <a name="synchronous-stack-walk"></a><span data-ttu-id="7599a-129">Parcours de pile synchrone</span><span class="sxs-lookup"><span data-stu-id="7599a-129">Synchronous Stack Walk</span></span>  
 <span data-ttu-id="7599a-130">Un parcours de pile synchrone implique le parcours de la pile du thread actuel en réponse à un rappel.</span><span class="sxs-lookup"><span data-stu-id="7599a-130">A synchronous stack walk involves walking the stack of the current thread in response to a callback.</span></span> <span data-ttu-id="7599a-131">Elle ne nécessite pas d’amorçage ou de suspension.</span><span class="sxs-lookup"><span data-stu-id="7599a-131">It does not require seeding or suspending.</span></span>  
  
 <span data-ttu-id="7599a-132">Vous effectuez un appel synchrone quand, en réponse au CLR appelant l’une des méthodes [ICorProfilerCallback](icorprofilercallback-interface.md) (ou [ICorProfilerCallback2](icorprofilercallback2-interface.md)) de votre profileur, vous appelez `DoStackSnapshot` pour parcourir la pile du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="7599a-132">You make a synchronous call when, in response to the CLR calling one of your profiler's [ICorProfilerCallback](icorprofilercallback-interface.md) (or [ICorProfilerCallback2](icorprofilercallback2-interface.md)) methods, you call `DoStackSnapshot` to walk the stack of the current thread.</span></span> <span data-ttu-id="7599a-133">Cela est utile lorsque vous souhaitez voir à quoi ressemble la pile dans une notification telle que [ICorProfilerCallback :: ObjectAllocated](icorprofilercallback-objectallocated-method.md).</span><span class="sxs-lookup"><span data-stu-id="7599a-133">This is useful when you want to see what the stack looks like at a notification such as [ICorProfilerCallback::ObjectAllocated](icorprofilercallback-objectallocated-method.md).</span></span> <span data-ttu-id="7599a-134">Vous appelez simplement `DoStackSnapshot` à partir de votre `ICorProfilerCallback` méthode, en passant la valeur null dans les `context` `thread` paramètres et.</span><span class="sxs-lookup"><span data-stu-id="7599a-134">You just call `DoStackSnapshot` from within your `ICorProfilerCallback` method, passing null in the `context` and `thread` parameters.</span></span>  
  
## <a name="asynchronous-stack-walk"></a><span data-ttu-id="7599a-135">Parcours de pile asynchrone</span><span class="sxs-lookup"><span data-stu-id="7599a-135">Asynchronous Stack Walk</span></span>  
 <span data-ttu-id="7599a-136">Un parcours de pile asynchrone implique le parcours de la pile d’un thread différent, ou le parcours de la pile du thread actuel, et non en réponse à un rappel, mais en détournent le pointeur d’instruction du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="7599a-136">An asynchronous stack walk entails walking the stack of a different thread, or walking the stack of the current thread, not in response to a callback, but by hijacking the current thread's instruction pointer.</span></span> <span data-ttu-id="7599a-137">Un parcours asynchrone requiert une valeur de départ si le haut de la pile est du code non managé qui ne fait pas partie d’un appel de code non managé (PInvoke) ou d’un appel COM, mais code d’assistance dans le CLR lui-même.</span><span class="sxs-lookup"><span data-stu-id="7599a-137">An asynchronous walk requires a seed if the top of the stack is unmanaged code that is not part of a platform invoke (PInvoke) or COM call, but helper code in the CLR itself.</span></span> <span data-ttu-id="7599a-138">Par exemple, le code qui effectue une compilation juste-à-temps (JIT) ou garbage collection est un code d’assistance.</span><span class="sxs-lookup"><span data-stu-id="7599a-138">For example, code that does just-in-time (JIT) compiling or garbage collection is helper code.</span></span>  
  
 <span data-ttu-id="7599a-139">Vous obtenez une valeur de départ en suspendant directement le thread cible et en parcourant sa pile vous-même, jusqu’à ce que vous trouviez le frame managé le plus haut.</span><span class="sxs-lookup"><span data-stu-id="7599a-139">You obtain a seed by directly suspending the target thread and walking its stack yourself, until you find the topmost managed frame.</span></span> <span data-ttu-id="7599a-140">Une fois le thread cible suspendu, obtient le contexte de registre actuel du thread cible.</span><span class="sxs-lookup"><span data-stu-id="7599a-140">After the target thread is suspended, get the target thread's current register context.</span></span> <span data-ttu-id="7599a-141">Ensuite, déterminez si le contexte de registre pointe vers du code non managé en appelant [ICorProfilerInfo :: GetFunctionFromIP,](icorprofilerinfo-getfunctionfromip-method.md) : s’il retourne un `FunctionID` égal à zéro, le frame est du code non managé.</span><span class="sxs-lookup"><span data-stu-id="7599a-141">Next, determine whether the register context points to unmanaged code by calling [ICorProfilerInfo::GetFunctionFromIP](icorprofilerinfo-getfunctionfromip-method.md) — if it returns a `FunctionID` equal to zero, the frame is unmanaged code.</span></span> <span data-ttu-id="7599a-142">À présent, parcourez la pile jusqu’à ce que vous atteigniez le premier frame géré, puis calculez le contexte de départ en fonction du contexte de registre de ce frame.</span><span class="sxs-lookup"><span data-stu-id="7599a-142">Now, walk the stack until you reach the first managed frame, and then calculate the seed context based on the register context for that frame.</span></span>  
  
 <span data-ttu-id="7599a-143">Appelez `DoStackSnapshot` avec votre contexte de valeur initiale pour commencer le parcours de la pile asynchrone.</span><span class="sxs-lookup"><span data-stu-id="7599a-143">Call `DoStackSnapshot` with your seed context to begin the asynchronous stack walk.</span></span> <span data-ttu-id="7599a-144">Si vous ne fournissez pas de valeur de départ, `DoStackSnapshot` peut ignorer des frames managés en haut de la pile et, par conséquent, vous donnera un parcours de pile incomplet.</span><span class="sxs-lookup"><span data-stu-id="7599a-144">If you do not supply a seed, `DoStackSnapshot` might skip managed frames at the top of the stack and, consequently, will give you an incomplete stack walk.</span></span> <span data-ttu-id="7599a-145">Si vous fournissez une valeur de départ, elle doit pointer vers du code généré juste-à-temps ou un générateur d’images natives (Ngen.exe). Sinon, `DoStackSnapshot` retourne le code d’échec, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span><span class="sxs-lookup"><span data-stu-id="7599a-145">If you do supply a seed, it must point to JIT-compiled or Native Image Generator (Ngen.exe)-generated code; otherwise, `DoStackSnapshot` returns the failure code, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span></span>  
  
 <span data-ttu-id="7599a-146">Les parcours de pile asynchrones peuvent facilement provoquer des interblocages ou des violations d’accès, sauf si vous suivez ces instructions :</span><span class="sxs-lookup"><span data-stu-id="7599a-146">Asynchronous stack walks can easily cause deadlocks or access violations, unless you follow these guidelines:</span></span>  
  
- <span data-ttu-id="7599a-147">Lorsque vous suspendez directement les threads, n’oubliez pas que seul un thread qui n’a jamais exécuté du code managé peut suspendre un autre thread.</span><span class="sxs-lookup"><span data-stu-id="7599a-147">When you directly suspend threads, remember that only a thread that has never run managed code can suspend another thread.</span></span>  
  
- <span data-ttu-id="7599a-148">Bloquez toujours dans votre rappel [ICorProfilerCallback :: ThreadDestroyed](icorprofilercallback-threaddestroyed-method.md) jusqu’à ce que le parcours de la pile de ce thread soit terminé.</span><span class="sxs-lookup"><span data-stu-id="7599a-148">Always block in your [ICorProfilerCallback::ThreadDestroyed](icorprofilercallback-threaddestroyed-method.md) callback until that thread's stack walk is complete.</span></span>  
  
- <span data-ttu-id="7599a-149">Ne conservez pas de verrou pendant que votre profileur appelle dans une fonction CLR qui peut déclencher un garbage collection.</span><span class="sxs-lookup"><span data-stu-id="7599a-149">Do not hold a lock while your profiler calls into a CLR function that can trigger a garbage collection.</span></span> <span data-ttu-id="7599a-150">Autrement dit, ne pas conserver de verrou si le thread propriétaire peut effectuer un appel qui déclenche un garbage collection.</span><span class="sxs-lookup"><span data-stu-id="7599a-150">That is, do not hold a lock if the owning thread might make a call that triggers a garbage collection.</span></span>  
  
 <span data-ttu-id="7599a-151">Il y a également un risque d’interblocage si vous appelez `DoStackSnapshot` à partir d’un thread que votre profileur a créé afin que vous puissiez parcourir la pile d’un thread cible séparé.</span><span class="sxs-lookup"><span data-stu-id="7599a-151">There is also a risk of deadlock if you call `DoStackSnapshot` from a thread that your profiler has created so that you can walk the stack of a separate target thread.</span></span> <span data-ttu-id="7599a-152">La première fois que le thread que vous avez créé entre dans certaines `ICorProfilerInfo*` méthodes (y compris `DoStackSnapshot` ), le CLR effectuera une initialisation par thread et spécifique au CLR sur ce thread.</span><span class="sxs-lookup"><span data-stu-id="7599a-152">The first time the thread you created enters certain `ICorProfilerInfo*` methods (including `DoStackSnapshot`), the CLR will perform per-thread, CLR-specific initialization on that thread.</span></span> <span data-ttu-id="7599a-153">Si votre profileur a suspendu le thread cible dont vous tentez de parcourir la pile, et si ce thread cible est devenu propriétaire d’un verrou nécessaire pour effectuer cette initialisation par thread, un interblocage se produit.</span><span class="sxs-lookup"><span data-stu-id="7599a-153">If your profiler has suspended the target thread whose stack you are trying to walk, and if that target thread happened to own a lock necessary for performing this per-thread initialization, a deadlock will occur.</span></span> <span data-ttu-id="7599a-154">Pour éviter ce blocage, effectuez un appel initial `DoStackSnapshot` de à partir de votre thread créé par le profileur pour parcourir un thread cible séparé, mais n’interrompez pas d’abord le thread cible.</span><span class="sxs-lookup"><span data-stu-id="7599a-154">To avoid this deadlock, make an initial call into `DoStackSnapshot` from your profiler-created thread to walk a separate target thread, but do not suspend the target thread first.</span></span> <span data-ttu-id="7599a-155">Cet appel initial garantit que l’initialisation par thread peut se terminer sans interblocage.</span><span class="sxs-lookup"><span data-stu-id="7599a-155">This initial call ensures that the per-thread initialization can complete without deadlock.</span></span> <span data-ttu-id="7599a-156">Si `DoStackSnapshot` suit et signale au moins un frame, après ce point, il est possible pour ce thread créé par le profileur d’interrompre n’importe quel thread cible et `DoStackSnapshot` d’appeler pour parcourir la pile de ce thread cible.</span><span class="sxs-lookup"><span data-stu-id="7599a-156">If `DoStackSnapshot` succeeds and reports at least one frame, after that point, it will be safe for that profiler-created thread to suspend any target thread and call `DoStackSnapshot` to walk the stack of that target thread.</span></span>  
  
## <a name="requirements"></a><span data-ttu-id="7599a-157">Spécifications</span><span class="sxs-lookup"><span data-stu-id="7599a-157">Requirements</span></span>  
 <span data-ttu-id="7599a-158">**Plateformes :** Consultez [Configuration requise](../../get-started/system-requirements.md).</span><span class="sxs-lookup"><span data-stu-id="7599a-158">**Platforms:** See [System Requirements](../../get-started/system-requirements.md).</span></span>  
  
 <span data-ttu-id="7599a-159">**En-tête :** CorProf.idl, CorProf.h</span><span class="sxs-lookup"><span data-stu-id="7599a-159">**Header:** CorProf.idl, CorProf.h</span></span>  
  
 <span data-ttu-id="7599a-160">**Bibliothèque :** CorGuids.lib</span><span class="sxs-lookup"><span data-stu-id="7599a-160">**Library:** CorGuids.lib</span></span>  
  
 <span data-ttu-id="7599a-161">**Versions de .NET Framework :**[!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span><span class="sxs-lookup"><span data-stu-id="7599a-161">**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7599a-162">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="7599a-162">See also</span></span>

- [<span data-ttu-id="7599a-163">ICorProfilerInfo, interface</span><span class="sxs-lookup"><span data-stu-id="7599a-163">ICorProfilerInfo Interface</span></span>](icorprofilerinfo-interface.md)
- [<span data-ttu-id="7599a-164">ICorProfilerInfo2, interface</span><span class="sxs-lookup"><span data-stu-id="7599a-164">ICorProfilerInfo2 Interface</span></span>](icorprofilerinfo2-interface.md)
