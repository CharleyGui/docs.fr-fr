---
title: Vue d’ensemble du profilage
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
ms.openlocfilehash: 3836b562d969726a6587d702d3edf45abb147d10
ms.sourcegitcommit: 961ec21c22d2f1d55c9cc8a7edf2ade1d1fd92e3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/02/2020
ms.locfileid: "80588508"
---
# <a name="profiling-overview"></a><span data-ttu-id="601b9-102">Vue d’ensemble du profilage</span><span class="sxs-lookup"><span data-stu-id="601b9-102">Profiling Overview</span></span>

<span data-ttu-id="601b9-103">Un profileur est un outil qui surveille l'exécution d'une autre application.</span><span class="sxs-lookup"><span data-stu-id="601b9-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="601b9-104">Un profileur CLR (Common Language Runtime) est une bibliothèque de liens dynamiques (DLL) qui se compose de fonctions qui reçoivent des messages du CLR et qui lui en envoient à l'aide de l'API de profilage.</span><span class="sxs-lookup"><span data-stu-id="601b9-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="601b9-105">La DLL du profileur est chargée par le CLR au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="601b9-105">The profiler DLL is loaded by the CLR at run time.</span></span>

<span data-ttu-id="601b9-106">Les outils de profilage traditionnels se contentent sur la mesure de l'exécution de l'application.</span><span class="sxs-lookup"><span data-stu-id="601b9-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="601b9-107">Autrement dit, ils mesurent le temps passé dans chaque fonction ou l'utilisation de la mémoire de l'application au fil du temps.</span><span class="sxs-lookup"><span data-stu-id="601b9-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="601b9-108">L'API de profilage cible une classe plus large d'outils de diagnostic tels que les utilitaires de couverture du code et même des outils de débogage avancés.</span><span class="sxs-lookup"><span data-stu-id="601b9-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="601b9-109">Ces utilisations relèvent du diagnostic de par leur nature.</span><span class="sxs-lookup"><span data-stu-id="601b9-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="601b9-110">L'API de profilage non seulement mesure mais surveille également l'exécution d'une application.</span><span class="sxs-lookup"><span data-stu-id="601b9-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="601b9-111">C'est pourquoi l'API de profilage ne doit jamais être utilisée par l'application elle-même et l'exécution de l'application ne doit pas dépendre du profileur (ni être affectée par lui).</span><span class="sxs-lookup"><span data-stu-id="601b9-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>

<span data-ttu-id="601b9-112">Le profilage d'une application CLR requiert plus de support qu'un profilage de code machine compilé de manière conventionnelle.</span><span class="sxs-lookup"><span data-stu-id="601b9-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="601b9-113">Ceci est dû au fait que le CLR introduit des concepts tels que les domaines d'application, le garbage collection, la gestion des exceptions managées, la compilation de code juste-à-temps (JIT) (conversion du code MSIL, ou Microsoft Intermediate Language, en code machine natif) et des fonctionnalités similaires.</span><span class="sxs-lookup"><span data-stu-id="601b9-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="601b9-114">Les mécanismes de profilage conventionnels ne peuvent pas identifier ni fournir des informations utiles sur ces fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="601b9-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="601b9-115">L'API de profilage fournit ces informations manquantes efficacement, avec un impact minimal sur les performances du CLR et l'application profilée.</span><span class="sxs-lookup"><span data-stu-id="601b9-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>

<span data-ttu-id="601b9-116">La compilation JIT au moment de l'exécution offre de bonnes possibilités au profilage.</span><span class="sxs-lookup"><span data-stu-id="601b9-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="601b9-117">L'API de profilage permet à un profileur de modifier le flux de code MSIL en mémoire par une routine avant sa compilation JIT.</span><span class="sxs-lookup"><span data-stu-id="601b9-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="601b9-118">De cette manière, le profileur peut ajouter dynamiquement le code d'instrumentation à des routines particulières nécessitant un examen plus approfondi.</span><span class="sxs-lookup"><span data-stu-id="601b9-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="601b9-119">Bien que cette approche soit possible dans les scénarios conventionnels, il est beaucoup plus facile à implémenter pour le CLR à l'aide de l'API de profilage.</span><span class="sxs-lookup"><span data-stu-id="601b9-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>

## <a name="the-profiling-api"></a><span data-ttu-id="601b9-120">L'API de profilage</span><span class="sxs-lookup"><span data-stu-id="601b9-120">The Profiling API</span></span>

<span data-ttu-id="601b9-121">Typiquement, l’API de profilage est utilisé pour écrire un *profiler de code*, qui est un programme qui surveille l’exécution d’une application gérée.</span><span class="sxs-lookup"><span data-stu-id="601b9-121">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>

<span data-ttu-id="601b9-122">L'API de profilage est utilisée par une DLL du profileur, chargée dans le même processus que l'application en cours de profilage.</span><span class="sxs-lookup"><span data-stu-id="601b9-122">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="601b9-123">Le profileur DLL implémente une interface de rappel ([ICorProfilerCallback](icorprofilercallback-interface.md) dans la version .NET Framework 1.0 et 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) dans la version 2.0 et plus tard).</span><span class="sxs-lookup"><span data-stu-id="601b9-123">The profiler DLL implements a callback interface ([ICorProfilerCallback](icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="601b9-124">Le CLR appelle les méthodes dans cette interface pour notifier le profileur des événements dans le processus profilé.</span><span class="sxs-lookup"><span data-stu-id="601b9-124">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="601b9-125">Le profileur peut rappeler dans le runtime en utilisant les méthodes dans les interfaces [ICorProfilerInfo](icorprofilerinfo-interface.md) et [ICorProfilerInfo2](icorprofilerinfo2-interface.md) pour obtenir des informations sur l’état de l’application profilée.</span><span class="sxs-lookup"><span data-stu-id="601b9-125">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>

> [!NOTE]
> <span data-ttu-id="601b9-126">Seule la partie collecte de données de la solution du profileur doit s'exécuter dans le même processus que l'application profilée.</span><span class="sxs-lookup"><span data-stu-id="601b9-126">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="601b9-127">Toutes les analyses de données et d'interface utilisateur doivent être effectuées dans un processus séparé.</span><span class="sxs-lookup"><span data-stu-id="601b9-127">All user interface and data analysis should be performed in a separate process.</span></span>

<span data-ttu-id="601b9-128">L'illustration suivante montre comment la DLL du profileur interagit avec l'application en cours de profilage et le CLR.</span><span class="sxs-lookup"><span data-stu-id="601b9-128">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>

![Capture d’écran qui montre l’architecture de profilage.](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a><span data-ttu-id="601b9-130">Interfaces de notification</span><span class="sxs-lookup"><span data-stu-id="601b9-130">The Notification Interfaces</span></span>

<span data-ttu-id="601b9-131">[ICorProfilerCallback](icorprofilercallback-interface.md) et [ICorProfilerCallback2](icorprofilercallback2-interface.md) peuvent être considérés comme des interfaces de notification.</span><span class="sxs-lookup"><span data-stu-id="601b9-131">[ICorProfilerCallback](icorprofilercallback-interface.md) and [ICorProfilerCallback2](icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="601b9-132">Ces interfaces se composent de méthodes telles que [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md), et [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span><span class="sxs-lookup"><span data-stu-id="601b9-132">These interfaces consist of methods such as [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="601b9-133">Chaque fois que le CLR charge ou décharge une classe, compile une fonction, etc., il appelle la méthode correspondante dans l'interface `ICorProfilerCallback` ou `ICorProfilerCallback2` du profileur.</span><span class="sxs-lookup"><span data-stu-id="601b9-133">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>

<span data-ttu-id="601b9-134">Par exemple, un profileur peut mesurer la performance du code à travers deux fonctions de notification : [FunctionEnter2](functionenter2-function.md) et [FunctionLeave2](functionleave2-function.md).</span><span class="sxs-lookup"><span data-stu-id="601b9-134">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](functionenter2-function.md) and [FunctionLeave2](functionleave2-function.md).</span></span> <span data-ttu-id="601b9-135">Il horodate simplement chaque notification, cumule les résultats et génère une liste qui indique quelles fonctions ont consommé le plus de temps processeur ou de temps horloge pendant l'exécution de l'application.</span><span class="sxs-lookup"><span data-stu-id="601b9-135">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>

### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="601b9-136">Interfaces de récupération d'informations</span><span class="sxs-lookup"><span data-stu-id="601b9-136">The Information Retrieval Interfaces</span></span>

<span data-ttu-id="601b9-137">Les autres interfaces principales impliquées dans le profilage sont [ICorProfilerInfo](icorprofilerinfo-interface.md) et [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span><span class="sxs-lookup"><span data-stu-id="601b9-137">The other main interfaces involved in profiling are [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="601b9-138">Le profileur appelle ces interfaces au besoin pour obtenir plus d'informations afin de faciliter son analyse.</span><span class="sxs-lookup"><span data-stu-id="601b9-138">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="601b9-139">Par exemple, chaque fois que le CLR appelle la fonction [FunctionEnter2,](functionenter2-function.md) il fournit un identifiant de fonction.</span><span class="sxs-lookup"><span data-stu-id="601b9-139">For example, whenever the CLR calls the [FunctionEnter2](functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="601b9-140">Le profileur peut obtenir plus d’informations sur cette fonction en appelant la méthode [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) pour découvrir la classe mère de la fonction, son nom, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="601b9-140">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>

## <a name="supported-features"></a><span data-ttu-id="601b9-141">Fonctionnalités prises en charge</span><span class="sxs-lookup"><span data-stu-id="601b9-141">Supported Features</span></span>

<span data-ttu-id="601b9-142">L'API de profilage fournit des informations sur divers événements et actions qui se produisent dans le Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="601b9-142">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="601b9-143">Vous pouvez utiliser ces informations pour surveiller le fonctionnement interne des processus et analyser les performances de votre application .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="601b9-143">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>

<span data-ttu-id="601b9-144">L'API de profilage récupère des informations sur les événements et actions ci-après qui se produisent dans le CLR :</span><span class="sxs-lookup"><span data-stu-id="601b9-144">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>

- <span data-ttu-id="601b9-145">Événements de démarrage et d'arrêt du CLR.</span><span class="sxs-lookup"><span data-stu-id="601b9-145">CLR startup and shutdown events.</span></span>

- <span data-ttu-id="601b9-146">Événements de création et d'arrêt de domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="601b9-146">Application domain creation and shutdown events.</span></span>

- <span data-ttu-id="601b9-147">Événements de chargement et de déchargement d'assemblys.</span><span class="sxs-lookup"><span data-stu-id="601b9-147">Assembly loading and unloading events.</span></span>

- <span data-ttu-id="601b9-148">Événements de chargement et de déchargement de modules.</span><span class="sxs-lookup"><span data-stu-id="601b9-148">Module loading and unloading events.</span></span>

- <span data-ttu-id="601b9-149">Événements de création et de destruction de tables vtable COM.</span><span class="sxs-lookup"><span data-stu-id="601b9-149">COM vtable creation and destruction events.</span></span>

- <span data-ttu-id="601b9-150">Événements de compilation juste-à-temps (JIT) et de lancement de code.</span><span class="sxs-lookup"><span data-stu-id="601b9-150">Just-in-time (JIT) compilation and code-pitching events.</span></span>

- <span data-ttu-id="601b9-151">Événements de chargement et de déchargement de classes.</span><span class="sxs-lookup"><span data-stu-id="601b9-151">Class loading and unloading events.</span></span>

- <span data-ttu-id="601b9-152">Événements de création et de destruction de threads.</span><span class="sxs-lookup"><span data-stu-id="601b9-152">Thread creation and destruction events.</span></span>

- <span data-ttu-id="601b9-153">Événements d'entrée et de sortie de fonction.</span><span class="sxs-lookup"><span data-stu-id="601b9-153">Function entry and exit events.</span></span>

- <span data-ttu-id="601b9-154">Les exceptions.</span><span class="sxs-lookup"><span data-stu-id="601b9-154">Exceptions.</span></span>

- <span data-ttu-id="601b9-155">Transitions entre l'exécution de code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="601b9-155">Transitions between managed and unmanaged code execution.</span></span>

- <span data-ttu-id="601b9-156">Transitions entre des contextes d'exécution différents.</span><span class="sxs-lookup"><span data-stu-id="601b9-156">Transitions between different runtime contexts.</span></span>

- <span data-ttu-id="601b9-157">Informations sur les suspensions du runtime.</span><span class="sxs-lookup"><span data-stu-id="601b9-157">Information about runtime suspensions.</span></span>

- <span data-ttu-id="601b9-158">Informations sur l'activité du tas de mémoire du runtime et du garbage collection.</span><span class="sxs-lookup"><span data-stu-id="601b9-158">Information about the runtime memory heap and garbage collection activity.</span></span>

<span data-ttu-id="601b9-159">L'API de profilage peut être appelée à partir de tout langage compatible COM (non managé).</span><span class="sxs-lookup"><span data-stu-id="601b9-159">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>

<span data-ttu-id="601b9-160">L'API est efficace en matière de consommation de processeur et de mémoire.</span><span class="sxs-lookup"><span data-stu-id="601b9-160">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="601b9-161">Le profilage n'implique pas de modifications de l'application profilée suffisamment significatives pour générer des résultats trompeurs.</span><span class="sxs-lookup"><span data-stu-id="601b9-161">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>

<span data-ttu-id="601b9-162">L'API de profilage s'avère utile à la fois pour les profileurs d'échantillonnage et de non-échantillonnage.</span><span class="sxs-lookup"><span data-stu-id="601b9-162">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="601b9-163">Un *profileur d’échantillonnage* inspecte le profil à des tiques d’horloge régulières, par exemple, à 5 millisecondes l’une de l’autre.</span><span class="sxs-lookup"><span data-stu-id="601b9-163">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="601b9-164">Un *profileur non-échantillonnage* est informé d’un événement de façon synchronisée avec le fil qui cause l’événement.</span><span class="sxs-lookup"><span data-stu-id="601b9-164">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>

### <a name="unsupported-functionality"></a><span data-ttu-id="601b9-165">Fonctionnalités non prises en charge</span><span class="sxs-lookup"><span data-stu-id="601b9-165">Unsupported Functionality</span></span>

<span data-ttu-id="601b9-166">L'API de profilage ne prend pas en charge les fonctionnalités suivantes :</span><span class="sxs-lookup"><span data-stu-id="601b9-166">The profiling API does not support the following functionality:</span></span>

- <span data-ttu-id="601b9-167">Code non managé, qui doit être profilé à l'aide de méthodes Win32 classiques.</span><span class="sxs-lookup"><span data-stu-id="601b9-167">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="601b9-168">Toutefois, le profileur CLR inclut des événements de transition pour déterminer les limites entre code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="601b9-168">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>

- <span data-ttu-id="601b9-169">Applications qui modifient elles-mêmes leur propre code à des fins de programmation orientée aspect par exemple.</span><span class="sxs-lookup"><span data-stu-id="601b9-169">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>

- <span data-ttu-id="601b9-170">Vérification des limites, car l'API de profilage ne fournit pas ces informations.</span><span class="sxs-lookup"><span data-stu-id="601b9-170">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="601b9-171">Le CLR assure une prise en charge intrinsèque de la vérification des limites de tout le code managé.</span><span class="sxs-lookup"><span data-stu-id="601b9-171">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>

- <span data-ttu-id="601b9-172">Profilage distant, qui n'est pas pris en charge pour les raisons suivantes :</span><span class="sxs-lookup"><span data-stu-id="601b9-172">Remote profiling, which is not supported for the following reasons:</span></span>

  - <span data-ttu-id="601b9-173">Le profilage distant allonge le temps d'exécution.</span><span class="sxs-lookup"><span data-stu-id="601b9-173">Remote profiling extends execution time.</span></span> <span data-ttu-id="601b9-174">Quand vous utilisez les interfaces de profilage, vous devez minimiser le temps d'exécution afin que les résultats de profilage ne soient pas indûment affectés.</span><span class="sxs-lookup"><span data-stu-id="601b9-174">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="601b9-175">Cela s'avère particulièrement pertinent quand les performances de l'exécution sont analysées.</span><span class="sxs-lookup"><span data-stu-id="601b9-175">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="601b9-176">Toutefois, le profilage distant n'est pas une limitation quand les interfaces de profilage sont utilisées pour analyser l'utilisation de la mémoire ou pour obtenir des informations d'exécution sur les frames de pile, les objets, etc.</span><span class="sxs-lookup"><span data-stu-id="601b9-176">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>

  - <span data-ttu-id="601b9-177">Le profileur de code CLR doit inscrire une ou plusieurs interfaces de rappel auprès du runtime sur l'ordinateur local sur lequel s'exécute l'application profilée.</span><span class="sxs-lookup"><span data-stu-id="601b9-177">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="601b9-178">Cela limite la possibilité de créer un profileur de code distant.</span><span class="sxs-lookup"><span data-stu-id="601b9-178">This limits the ability to create a remote code profiler.</span></span>

## <a name="notification-threads"></a><span data-ttu-id="601b9-179">Threads de notification</span><span class="sxs-lookup"><span data-stu-id="601b9-179">Notification Threads</span></span>

<span data-ttu-id="601b9-180">Dans la plupart des cas, le thread qui génère un événement exécute également des notifications.</span><span class="sxs-lookup"><span data-stu-id="601b9-180">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="601b9-181">Ces notifications (par exemple, [FunctionEnter](functionenter-function.md) et [FunctionLeave](functionleave-function.md)) `ThreadID`n’ont pas besoin de fournir l’explicite .</span><span class="sxs-lookup"><span data-stu-id="601b9-181">Such notifications (for example, [FunctionEnter](functionenter-function.md) and [FunctionLeave](functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="601b9-182">En outre, le profileur peut décider d'utiliser le stockage local des threads pour stocker et mettre à jour ses blocs d'analyse au lieu d'indexer les blocs d'analyse dans le stockage global, selon le `ThreadID` du thread affecté.</span><span class="sxs-lookup"><span data-stu-id="601b9-182">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>

<span data-ttu-id="601b9-183">Notez que ces rappels ne sont pas sérialisés.</span><span class="sxs-lookup"><span data-stu-id="601b9-183">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="601b9-184">Les utilisateurs doivent protéger leur code en créant des structures de données thread-safe et en verrouillant le code du profileur si nécessaire pour empêcher tout accès parallèle à partir de plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="601b9-184">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="601b9-185">Par conséquent, dans certains cas, vous pouvez recevoir une séquence inhabituelle de rappels.</span><span class="sxs-lookup"><span data-stu-id="601b9-185">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="601b9-186">Par exemple, supposons qu'une application managée engendre deux threads qui exécutent un code identique.</span><span class="sxs-lookup"><span data-stu-id="601b9-186">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="601b9-187">Dans ce cas, il est possible de recevoir un [ICorProfilerCallback::JITCompilationDé l’événement](icorprofilercallback-jitcompilationstarted-method.md) pour une fonction d’un thread et un `FunctionEnter` rappel de l’autre thread avant de recevoir [l’ICorProfilerCallback::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) callback.</span><span class="sxs-lookup"><span data-stu-id="601b9-187">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="601b9-188">Le cas échéant, l'utilisateur reçoit un rappel `FunctionEnter` pour une fonction qui n'a peut-être pas encore été entièrement compilée juste-à-temps (JIT).</span><span class="sxs-lookup"><span data-stu-id="601b9-188">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>

## <a name="security"></a><span data-ttu-id="601b9-189">Sécurité</span><span class="sxs-lookup"><span data-stu-id="601b9-189">Security</span></span>

<span data-ttu-id="601b9-190">Une DLL de profileur est une DLL non managée qui s'exécute dans le cadre du moteur d'exécution du Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="601b9-190">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="601b9-191">Par conséquent, le code inclus dans la DLL de profileur n'est pas soumis aux restrictions de sécurité d'accès du code managé.</span><span class="sxs-lookup"><span data-stu-id="601b9-191">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="601b9-192">Les seules limitations applicables à la DLL de profileur sont celles imposées par le système d'exploitation sur l'utilisateur qui exécute l'application profilée.</span><span class="sxs-lookup"><span data-stu-id="601b9-192">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>

<span data-ttu-id="601b9-193">Les auteurs de profileur doivent prendre les précautions appropriées pour éviter les problèmes de sécurité.</span><span class="sxs-lookup"><span data-stu-id="601b9-193">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="601b9-194">Par exemple, lors de l'installation, une DLL de profileur doit être ajoutée à la liste de contrôle d'accès (ACL) afin qu'aucun utilisateur malveillant ne puisse la modifier.</span><span class="sxs-lookup"><span data-stu-id="601b9-194">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="601b9-195">Combinaison de code managé et non managé dans un profileur de code</span><span class="sxs-lookup"><span data-stu-id="601b9-195">Combining Managed and Unmanaged Code in a Code Profiler</span></span>

<span data-ttu-id="601b9-196">Un profileur incorrectement écrit peut provoquer des références circulaires à lui-même, ce qui entraîne un comportement imprévisible.</span><span class="sxs-lookup"><span data-stu-id="601b9-196">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>

<span data-ttu-id="601b9-197">Une revue de l’API de profilage CLR peut donner l’impression de pouvoir écrire un profileur contenant des composants managés et non managés qui s’appellent mutuellement via COM interop ou des appels indirects.</span><span class="sxs-lookup"><span data-stu-id="601b9-197">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>

<span data-ttu-id="601b9-198">Bien que cela soit possible du point de vue de la conception, l'API de profilage ne prend pas en charge les composants managés.</span><span class="sxs-lookup"><span data-stu-id="601b9-198">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="601b9-199">Un profileur CLR doit être entièrement non managé.</span><span class="sxs-lookup"><span data-stu-id="601b9-199">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="601b9-200">Toute tentative de combiner du code managé et non managé dans un profileur CLR risque d'entraîner des violations d'accès, des échecs de programme ou des interblocages.</span><span class="sxs-lookup"><span data-stu-id="601b9-200">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="601b9-201">Les composants managés du profileur déclenchent des événements sur leurs composants non managés, qui rappellent ensuite les composants managés, ce qui entraîne des références circulaires.</span><span class="sxs-lookup"><span data-stu-id="601b9-201">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>

<span data-ttu-id="601b9-202">Le seul emplacement où un profileur CLR peut appeler du code managé en toute sécurité est le corps MSIL (Microsoft Intermediate Language) d'une méthode.</span><span class="sxs-lookup"><span data-stu-id="601b9-202">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="601b9-203">La pratique recommandée pour modifier le corps MSIL est d’utiliser les méthodes de recomplification JIT dans [l’interface ICorProfilerCallback4.](icorprofilercallback4-interface.md)</span><span class="sxs-lookup"><span data-stu-id="601b9-203">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](icorprofilercallback4-interface.md) interface.</span></span>

<span data-ttu-id="601b9-204">Il est également possible d'utiliser les anciennes méthodes d'instrumentation pour modifier du code MSIL.</span><span class="sxs-lookup"><span data-stu-id="601b9-204">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="601b9-205">Avant que la compilation juste-à-temps (JIT) d’une fonction soit terminée, le profileur peut insérer des appels gérés dans le corps MSIL d’une méthode, puis JIT-compiler (voir [l’ICorProfilerInfo::GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) méthode).</span><span class="sxs-lookup"><span data-stu-id="601b9-205">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="601b9-206">Cette technique peut être utilisée avec succès pour l'instrumentation sélective du code managé, ou pour collecter des statistiques et des données de performance sur la compilation JIT.</span><span class="sxs-lookup"><span data-stu-id="601b9-206">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>

<span data-ttu-id="601b9-207">Un profileur de code peut également insérer des raccordements natifs dans le corps MSIL de chaque fonction managée appelée dans du code non managé.</span><span class="sxs-lookup"><span data-stu-id="601b9-207">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="601b9-208">Cette technique peut être utilisée pour l'instrumentation et la couverture.</span><span class="sxs-lookup"><span data-stu-id="601b9-208">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="601b9-209">Par exemple, un profileur de code peut insérer des raccordements d'instrumentation après chaque bloc MSIL pour vous assurer que le bloc a été exécuté.</span><span class="sxs-lookup"><span data-stu-id="601b9-209">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="601b9-210">La modification du corps MSIL d'une méthode est une opération très délicate et il existe de nombreux facteurs à prendre en considération.</span><span class="sxs-lookup"><span data-stu-id="601b9-210">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>

## <a name="profiling-unmanaged-code"></a><span data-ttu-id="601b9-211">Profilage de code non managé</span><span class="sxs-lookup"><span data-stu-id="601b9-211">Profiling Unmanaged Code</span></span>

<span data-ttu-id="601b9-212">L'API de profilage CLR (Common Language Runtime) fournit la prise en charge minimale pour profiler du code non managé.</span><span class="sxs-lookup"><span data-stu-id="601b9-212">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="601b9-213">Les fonctionnalités suivantes sont fournies :</span><span class="sxs-lookup"><span data-stu-id="601b9-213">The following functionality is provided:</span></span>

- <span data-ttu-id="601b9-214">Énumération des chaînes de pile.</span><span class="sxs-lookup"><span data-stu-id="601b9-214">Enumeration of stack chains.</span></span> <span data-ttu-id="601b9-215">Cette fonctionnalité permet à un profileur de code de déterminer la limite entre code managé et code non managé.</span><span class="sxs-lookup"><span data-stu-id="601b9-215">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>

- <span data-ttu-id="601b9-216">Détermination de la nature d'une chaîne de pile, à savoir s'il s'agit de code managé ou de code natif.</span><span class="sxs-lookup"><span data-stu-id="601b9-216">Determination whether a stack chain corresponds to managed code or native code.</span></span>

<span data-ttu-id="601b9-217">Dans les versions 1.0 et 1.1 du .NET Framework, ces méthodes sont disponibles via le sous-ensemble in-process de l'API de débogage CLR.</span><span class="sxs-lookup"><span data-stu-id="601b9-217">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="601b9-218">Elles sont définies dans le fichier CorDebug.idl.</span><span class="sxs-lookup"><span data-stu-id="601b9-218">They are defined in the CorDebug.idl file.</span></span>

<span data-ttu-id="601b9-219">Dans le cadre .NET 2.0 et plus tard, vous pouvez utiliser la méthode [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) pour cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="601b9-219">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>

## <a name="using-com"></a><span data-ttu-id="601b9-220">Utilisation de COM</span><span class="sxs-lookup"><span data-stu-id="601b9-220">Using COM</span></span>

<span data-ttu-id="601b9-221">Bien que les interfaces de profilage soient définies en tant qu'interfaces COM, le Common Language Runtime (CLR) n'initialise pas réellement COM pour utiliser ces interfaces.</span><span class="sxs-lookup"><span data-stu-id="601b9-221">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="601b9-222">La raison en est d’éviter d’avoir à définir le modèle de threading en utilisant la fonction [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) avant que l’application gérée a eu la chance de spécifier son modèle de threading souhaité.</span><span class="sxs-lookup"><span data-stu-id="601b9-222">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="601b9-223">De même, le profileur lui-même ne doit pas appeler `CoInitialize`, car il risque de choisir un modèle de thread qui n'est pas compatible avec l'application en cours de profilage, ce qui risque d'entraîner l'échec de l'application.</span><span class="sxs-lookup"><span data-stu-id="601b9-223">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>

## <a name="call-stacks"></a><span data-ttu-id="601b9-224">Pile des appels</span><span class="sxs-lookup"><span data-stu-id="601b9-224">Call Stacks</span></span>

<span data-ttu-id="601b9-225">L'API de profilage fournit deux méthodes pour obtenir des piles des appels : une méthode d'instantané de pile, qui permet la collecte fragmentée des piles des appels et une méthode de pile cachée, qui effectue le suivi de la pile des appels à chaque instant.</span><span class="sxs-lookup"><span data-stu-id="601b9-225">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>

### <a name="stack-snapshot"></a><span data-ttu-id="601b9-226">Instantané de pile</span><span class="sxs-lookup"><span data-stu-id="601b9-226">Stack Snapshot</span></span>

<span data-ttu-id="601b9-227">Un instantané de pile est une trace de la pile d'un thread à un instant précis.</span><span class="sxs-lookup"><span data-stu-id="601b9-227">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="601b9-228">L'API de profilage prend en charge le traçage des fonctions managées sur la pile, mais elle laisse le traçage des fonctions non managées au propre analyseur de pile du profileur.</span><span class="sxs-lookup"><span data-stu-id="601b9-228">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>

<span data-ttu-id="601b9-229">Pour plus d’informations sur la façon de programmer le profileur de marcher piles gérées, voir [l’ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) méthode dans cet ensemble de documentation, et [Profiler Stack Walking dans le cadre .NET 2.0: Bases et au-delà](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="601b9-229">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>

### <a name="shadow-stack"></a><span data-ttu-id="601b9-230">Pile cachée</span><span class="sxs-lookup"><span data-stu-id="601b9-230">Shadow Stack</span></span>

<span data-ttu-id="601b9-231">L'utilisation trop fréquente de la méthode d'instantané de pile peut rapidement créer un problème de performances.</span><span class="sxs-lookup"><span data-stu-id="601b9-231">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="601b9-232">Si vous voulez prendre des traces de pile fréquemment, votre profileur devrait plutôt construire une pile d’ombre en utilisant le [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md), et [ICorProfilerCallback2](icorprofilercallback2-interface.md) rappels d’exception.</span><span class="sxs-lookup"><span data-stu-id="601b9-232">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md), and [ICorProfilerCallback2](icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="601b9-233">La pile cachée est toujours actuelle et peut rapidement être copiée vers le stockage, chaque fois qu'un instantané de pile est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="601b9-233">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>

<span data-ttu-id="601b9-234">Une pile cachée peut obtenir des arguments de fonction, des valeurs de retour et des informations sur les instanciations génériques.</span><span class="sxs-lookup"><span data-stu-id="601b9-234">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="601b9-235">Ces informations sont uniquement disponibles via la pile cachée et peuvent être obtenues quand le contrôle est transmis à une fonction.</span><span class="sxs-lookup"><span data-stu-id="601b9-235">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="601b9-236">Toutefois, ces informations peuvent devenir indisponibles lors de l'exécution ultérieure de la fonction.</span><span class="sxs-lookup"><span data-stu-id="601b9-236">However, this information may not be available later during the run of the function.</span></span>

## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="601b9-237">Rappels et profondeur de la pile</span><span class="sxs-lookup"><span data-stu-id="601b9-237">Callbacks and Stack Depth</span></span>

<span data-ttu-id="601b9-238">Les rappels du profileur peuvent être émis dans des circonstances où la pile est contrainte. De plus, un débordement de la pile dans un rappel du profileur entraîne une sortie immédiate du processus.</span><span class="sxs-lookup"><span data-stu-id="601b9-238">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="601b9-239">Un profileur doit veiller à utiliser une pile aussi petite que possible en réponse à des rappels.</span><span class="sxs-lookup"><span data-stu-id="601b9-239">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="601b9-240">Si le profileur est prévu pour être utilisé avec des processus robustes face à un débordement de pile, il doit également éviter lui-même de déclencher un débordement de pile.</span><span class="sxs-lookup"><span data-stu-id="601b9-240">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>

## <a name="related-topics"></a><span data-ttu-id="601b9-241">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="601b9-241">Related Topics</span></span>

|<span data-ttu-id="601b9-242">Intitulé</span><span class="sxs-lookup"><span data-stu-id="601b9-242">Title</span></span>|<span data-ttu-id="601b9-243">Description</span><span class="sxs-lookup"><span data-stu-id="601b9-243">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="601b9-244">Configuration d'un environnement de profilage</span><span class="sxs-lookup"><span data-stu-id="601b9-244">Setting Up a Profiling Environment</span></span>](setting-up-a-profiling-environment.md)|<span data-ttu-id="601b9-245">Explique comment initialiser un profileur, définir des notifications d'événements et profiler un service Windows.</span><span class="sxs-lookup"><span data-stu-id="601b9-245">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|
|[<span data-ttu-id="601b9-246">Interfaces de profilage</span><span class="sxs-lookup"><span data-stu-id="601b9-246">Profiling Interfaces</span></span>](profiling-interfaces.md)|<span data-ttu-id="601b9-247">Décrit les interfaces non managées que l'API de profilage utilise.</span><span class="sxs-lookup"><span data-stu-id="601b9-247">Describes the unmanaged interfaces that the profiling API uses.</span></span>|
|[<span data-ttu-id="601b9-248">Fonctions statiques globales du profilage</span><span class="sxs-lookup"><span data-stu-id="601b9-248">Profiling Global Static Functions</span></span>](profiling-global-static-functions.md)|<span data-ttu-id="601b9-249">Décrit les fonctions statiques globales non managées que l'API de profilage utilise.</span><span class="sxs-lookup"><span data-stu-id="601b9-249">Describes the unmanaged global static functions that the profiling API uses.</span></span>|
|[<span data-ttu-id="601b9-250">Énumérations de profilage</span><span class="sxs-lookup"><span data-stu-id="601b9-250">Profiling Enumerations</span></span>](profiling-enumerations.md)|<span data-ttu-id="601b9-251">Décrit les énumérations non managées utilisées par l'API de profilage.</span><span class="sxs-lookup"><span data-stu-id="601b9-251">Describes the unmanaged enumerations that the profiling API uses.</span></span>|
|[<span data-ttu-id="601b9-252">Structures de profilage</span><span class="sxs-lookup"><span data-stu-id="601b9-252">Profiling Structures</span></span>](profiling-structures.md)|<span data-ttu-id="601b9-253">Décrit les structures non managées utilisées par l'API de profilage.</span><span class="sxs-lookup"><span data-stu-id="601b9-253">Describes the unmanaged structures that the profiling API uses.</span></span>|
