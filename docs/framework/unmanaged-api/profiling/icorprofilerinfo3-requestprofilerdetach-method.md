---
title: ICorProfilerInfo3::RequestProfilerDetach, méthode
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo3.RequestProfilerDetach Method
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo3::RequestProfilerDetach
helpviewer_keywords:
- RequestProfilerDetach method [.NET Framework profiling]
- ICorProfilerInfo3::RequestProfilerDetach method [.NET Framework profiling]
ms.assetid: ea102e62-0454-4477-bcf3-126773acd184
topic_type:
- apiref
ms.openlocfilehash: 8520f5fc0a6ff7e71f40cd7fbb1caf68aab63197
ms.sourcegitcommit: b11efd71c3d5ce3d9449c8d4345481b9f21392c6
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/29/2020
ms.locfileid: "76868510"
---
# <a name="icorprofilerinfo3requestprofilerdetach-method"></a><span data-ttu-id="39eca-102">ICorProfilerInfo3::RequestProfilerDetach, méthode</span><span class="sxs-lookup"><span data-stu-id="39eca-102">ICorProfilerInfo3::RequestProfilerDetach Method</span></span>
<span data-ttu-id="39eca-103">Indique au runtime de détacher le profileur.</span><span class="sxs-lookup"><span data-stu-id="39eca-103">Instructs the runtime to detach the profiler.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="39eca-104">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="39eca-104">Syntax</span></span>  
  
```cpp  
HRESULT RequestProfilerDetach(  
   [in] DWORD    dwExpectedCompletionMilliseconds);  
```  
  
## <a name="parameters"></a><span data-ttu-id="39eca-105">Parameters</span><span class="sxs-lookup"><span data-stu-id="39eca-105">Parameters</span></span>  
 `dwExpectedCompletionMilliseconds`  
 <span data-ttu-id="39eca-106">[in] Durée, en millisecondes, pendant laquelle le Common Language Runtime (CLR) doit attendre avant de vérifier si le déchargement du profileur peut être exécuté en tout sécurité.</span><span class="sxs-lookup"><span data-stu-id="39eca-106">[in] The length of time, in milliseconds, the common language runtime (CLR) should wait before checking to see whether it is safe to unload the profiler.</span></span>  
  
## <a name="return-value"></a><span data-ttu-id="39eca-107">Valeur de retour</span><span class="sxs-lookup"><span data-stu-id="39eca-107">Return Value</span></span>  
 <span data-ttu-id="39eca-108">Cette méthode retourne les HRESULT spécifiques suivants ainsi que les erreurs HRESULT indiquant l'échec de la méthode.</span><span class="sxs-lookup"><span data-stu-id="39eca-108">This method returns the following specific HRESULTs as well as HRESULT errors that indicate method failure.</span></span>  
  
|<span data-ttu-id="39eca-109">HRESULT</span><span class="sxs-lookup"><span data-stu-id="39eca-109">HRESULT</span></span>|<span data-ttu-id="39eca-110">Description</span><span class="sxs-lookup"><span data-stu-id="39eca-110">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="39eca-111">S_OK</span><span class="sxs-lookup"><span data-stu-id="39eca-111">S_OK</span></span>|<span data-ttu-id="39eca-112">La demande de détachement est valide, et la procédure de détachement se poursuit maintenant sur un autre thread.</span><span class="sxs-lookup"><span data-stu-id="39eca-112">The detach request is valid, and the detach procedure is now continuing on another thread.</span></span> <span data-ttu-id="39eca-113">Une fois le détachement terminé, un événement `ProfilerDetachSucceeded` est émis.</span><span class="sxs-lookup"><span data-stu-id="39eca-113">When the detach is fully complete, a `ProfilerDetachSucceeded` event is issued.</span></span>|  
|<span data-ttu-id="39eca-114">E_ CORPROF_E_CALLBACK3_REQUIRED</span><span class="sxs-lookup"><span data-stu-id="39eca-114">E_ CORPROF_E_CALLBACK3_REQUIRED</span></span>|<span data-ttu-id="39eca-115">Le profileur a échoué une tentative [IUnknown :: QueryInterface](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) pour l’interface [ICorProfilerCallback3](icorprofilercallback3-interface.md) , qu’il doit implémenter pour prendre en charge l’opération de détachement.</span><span class="sxs-lookup"><span data-stu-id="39eca-115">The profiler failed an [IUnknown::QueryInterface](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) attempt for the [ICorProfilerCallback3](icorprofilercallback3-interface.md) interface, which it must implement to support the detach operation.</span></span> <span data-ttu-id="39eca-116">La tentative de détachement n'a pas eu lieu.</span><span class="sxs-lookup"><span data-stu-id="39eca-116">Detach was not attempted.</span></span>|  
|<span data-ttu-id="39eca-117">CORPROF_E_IMMUTABLE_FLAGS_SET</span><span class="sxs-lookup"><span data-stu-id="39eca-117">CORPROF_E_IMMUTABLE_FLAGS_SET</span></span>|<span data-ttu-id="39eca-118">Le détachement est impossible, car le profileur a défini des indicateurs immuables au démarrage.</span><span class="sxs-lookup"><span data-stu-id="39eca-118">Detachment is impossible because the profiler set immutable flags at startup.</span></span> <span data-ttu-id="39eca-119">La tentative de détachement n'a pas eu lieu ; le profileur est toujours entièrement attaché.</span><span class="sxs-lookup"><span data-stu-id="39eca-119">Detachment was not attempted; the profiler is still fully attached.</span></span>|  
|<span data-ttu-id="39eca-120">CORPROF_E_IRREVERSIBLE_INSTRUMENTATION_PRESENT</span><span class="sxs-lookup"><span data-stu-id="39eca-120">CORPROF_E_IRREVERSIBLE_INSTRUMENTATION_PRESENT</span></span>|<span data-ttu-id="39eca-121">Le détachement est impossible, car le profileur a utilisé du code MSIL (Microsoft Intermediate Language) instrumenté ou inséré `enter`/des hooks `leave`.</span><span class="sxs-lookup"><span data-stu-id="39eca-121">Detachment is impossible because the profiler used instrumented Microsoft intermediate language (MSIL) code, or inserted `enter`/`leave` hooks.</span></span> <span data-ttu-id="39eca-122">La tentative de détachement n'a pas eu lieu ; le profileur est toujours entièrement attaché.</span><span class="sxs-lookup"><span data-stu-id="39eca-122">Detachment was not attempted; the profiler is still fully attached.</span></span><br /><br /> <span data-ttu-id="39eca-123">**Remarque** Le code MSIL instrumenté est le code fourni par le profileur à l’aide de la méthode [SetILFunctionBody](icorprofilerinfo-setilfunctionbody-method.md) .</span><span class="sxs-lookup"><span data-stu-id="39eca-123">**Note** Instrumented MSIL is code is code that is provided by the profiler using the [SetILFunctionBody](icorprofilerinfo-setilfunctionbody-method.md) method.</span></span>|  
|<span data-ttu-id="39eca-124">CORPROF_E_RUNTIME_UNINITIALIZED</span><span class="sxs-lookup"><span data-stu-id="39eca-124">CORPROF_E_RUNTIME_UNINITIALIZED</span></span>|<span data-ttu-id="39eca-125">Le runtime n'a pas encore été initialisé dans l'application managée.</span><span class="sxs-lookup"><span data-stu-id="39eca-125">The runtime has not been initialized yet in the managed application.</span></span> <span data-ttu-id="39eca-126">(Autrement dit, le runtime n’a pas été entièrement chargé.) Ce code d’erreur peut être retourné lorsque le détachement est demandé à l’intérieur de la méthode [ICorProfilerCallback :: Initialize](icorprofilercallback-initialize-method.md) du rappel du profileur.</span><span class="sxs-lookup"><span data-stu-id="39eca-126">(That is, the runtime has not been fully loaded.) This error code may be returned when detachment is requested inside the profiler callback's [ICorProfilerCallback::Initialize](icorprofilercallback-initialize-method.md) method.</span></span>|  
|<span data-ttu-id="39eca-127">CORPROF_E_UNSUPPORTED_CALL_SEQUENCE</span><span class="sxs-lookup"><span data-stu-id="39eca-127">CORPROF_E_UNSUPPORTED_CALL_SEQUENCE</span></span>|<span data-ttu-id="39eca-128">`RequestProfilerDetach` a été appelée à une heure non prise en charge.</span><span class="sxs-lookup"><span data-stu-id="39eca-128">`RequestProfilerDetach` was called at an unsupported time.</span></span> <span data-ttu-id="39eca-129">Cela se produit si la méthode est appelée sur un thread managé, mais pas à partir d’une méthode [ICorProfilerCallback](icorprofilercallback-interface.md) , ou à partir d’une méthode [ICorProfilerCallback](icorprofilercallback-interface.md) qui ne peut pas tolérer un garbage collection.</span><span class="sxs-lookup"><span data-stu-id="39eca-129">This occurs if the method is called on a managed thread but not from within an [ICorProfilerCallback](icorprofilercallback-interface.md) method or from within an [ICorProfilerCallback](icorprofilercallback-interface.md) method that cannot tolerate a garbage collection.</span></span> <span data-ttu-id="39eca-130">Pour plus d’informations, consultez [CORPROF_E_UNSUPPORTED_CALL_SEQUENCE HRESULT](corprof-e-unsupported-call-sequence-hresult.md).</span><span class="sxs-lookup"><span data-stu-id="39eca-130">For more information, see [CORPROF_E_UNSUPPORTED_CALL_SEQUENCE HRESULT](corprof-e-unsupported-call-sequence-hresult.md).</span></span>|  
  
## <a name="remarks"></a><span data-ttu-id="39eca-131">Notes</span><span class="sxs-lookup"><span data-stu-id="39eca-131">Remarks</span></span>  
 <span data-ttu-id="39eca-132">Pendant la procédure de détachement, le thread de détachement (thread créé spécifiquement pour détacher le profileur) vérifie parfois si tous les threads ont quitté le code du profileur.</span><span class="sxs-lookup"><span data-stu-id="39eca-132">During the detach procedure, the detach thread (the thread created specifically for detaching the profiler) occasionally checks whether all threads have exited the profiler’s code.</span></span> <span data-ttu-id="39eca-133">Le profileur doit fournir une estimation de la durée de cette opération via le paramètre `dwExpectedCompletionMilliseconds`.</span><span class="sxs-lookup"><span data-stu-id="39eca-133">The profiler should provide an estimate of how long this should take through the `dwExpectedCompletionMilliseconds` parameter.</span></span> <span data-ttu-id="39eca-134">Une valeur appropriée à utiliser est le temps passé par le profileur dans une méthode `ICorProfilerCallback*` donnée ; cette valeur ne doit pas être inférieure à la moitié du temps maximal que le profileur prévoit de passer.</span><span class="sxs-lookup"><span data-stu-id="39eca-134">A good value to use is the typical amount of time the profiler spends inside any given `ICorProfilerCallback*` method; this value should not be less than half of the maximum amount of time the profiler expects to spend.</span></span>  
  
 <span data-ttu-id="39eca-135">Le thread de détachement utilise `dwExpectedCompletionMilliseconds` pour décider de la durée de la veille avant de vérifier si le code de rappel du profileur a été dépilé.</span><span class="sxs-lookup"><span data-stu-id="39eca-135">The detach thread uses `dwExpectedCompletionMilliseconds` to decide how long to sleep before checking whether profiler callback code has been popped off all stacks.</span></span> <span data-ttu-id="39eca-136">Bien que les détails de l’algorithme suivant puissent changer dans les mises en production ultérieures du CLR, il illustre comment `dwExpectedCompletionMilliseconds` peut être utilisé pour déterminer si le profileur peut être déchargé en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="39eca-136">Although the details of the following algorithm may change in future releases of the CLR, it illustrates one way `dwExpectedCompletionMilliseconds` can be used when determining when it is safe to unload the profiler.</span></span> <span data-ttu-id="39eca-137">Le thread de détachement est d'abord en veille pendant `dwExpectedCompletionMilliseconds` millisecondes.</span><span class="sxs-lookup"><span data-stu-id="39eca-137">The detach thread first sleeps for `dwExpectedCompletionMilliseconds` milliseconds.</span></span> <span data-ttu-id="39eca-138">Si, après avoir quitté le mode veille, le CLR détecte que le code de rappel du profileur est encore présent, le thread de détachement est de nouveau mis en veille, cette fois pour deux fois `dwExpectedCompletionMilliseconds` millisecondes.</span><span class="sxs-lookup"><span data-stu-id="39eca-138">If, after awakening from the sleep, the CLR finds that profiler callback code is still present, the detach thread sleeps again, this time for two times `dwExpectedCompletionMilliseconds` milliseconds.</span></span> <span data-ttu-id="39eca-139">Si, après avoir quitté ce deuxième état de veille, le thread de détachement détermine que le code de rappel du profileur est encore présent, il repasse en état de veille pendant 10 minutes avant d'effectuer une nouvelle vérification.</span><span class="sxs-lookup"><span data-stu-id="39eca-139">If, after awakening from this second sleep, the detach thread finds that profiler callback code is still present, it sleeps for 10 minutes before checking again.</span></span> <span data-ttu-id="39eca-140">Le thread de détachement procède à une revérification toutes les 10 minutes.</span><span class="sxs-lookup"><span data-stu-id="39eca-140">The detach thread continues to recheck every 10 minutes.</span></span>  
  
 <span data-ttu-id="39eca-141">Si le profileur affecte à `dwExpectedCompletionMilliseconds` la valeur 0 (zéro), le CLR utilise une valeur par défaut de 5000, ce qui signifie qu'il effectue une vérification après 5 secondes, une autre après 10 secondes, puis toutes les 10 minutes.</span><span class="sxs-lookup"><span data-stu-id="39eca-141">If the profiler specifies `dwExpectedCompletionMilliseconds` as 0 (zero), the CLR uses a default value of 5000, which means that it will perform a check after 5 seconds, again after 10 seconds, and then every 10 minutes thereafter.</span></span>  
  
## <a name="requirements"></a><span data-ttu-id="39eca-142">Configuration requise pour</span><span class="sxs-lookup"><span data-stu-id="39eca-142">Requirements</span></span>  
 <span data-ttu-id="39eca-143">**Plateformes :** Consultez [Configuration requise](../../../../docs/framework/get-started/system-requirements.md).</span><span class="sxs-lookup"><span data-stu-id="39eca-143">**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).</span></span>  
  
 <span data-ttu-id="39eca-144">**En-tête :** CorProf.idl, CorProf.h</span><span class="sxs-lookup"><span data-stu-id="39eca-144">**Header:** CorProf.idl, CorProf.h</span></span>  
  
 <span data-ttu-id="39eca-145">**Bibliothèque :** CorGuids.lib</span><span class="sxs-lookup"><span data-stu-id="39eca-145">**Library:** CorGuids.lib</span></span>  
  
 <span data-ttu-id="39eca-146">**Versions du .NET Framework :** [!INCLUDE[net_current_v40plus](../../../../includes/net-current-v40plus-md.md)]</span><span class="sxs-lookup"><span data-stu-id="39eca-146">**.NET Framework Versions:** [!INCLUDE[net_current_v40plus](../../../../includes/net-current-v40plus-md.md)]</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="39eca-147">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="39eca-147">See also</span></span>

- [<span data-ttu-id="39eca-148">ICorProfilerInfo3, interface</span><span class="sxs-lookup"><span data-stu-id="39eca-148">ICorProfilerInfo3 Interface</span></span>](icorprofilerinfo3-interface.md)
- [<span data-ttu-id="39eca-149">Interfaces de profilage</span><span class="sxs-lookup"><span data-stu-id="39eca-149">Profiling Interfaces</span></span>](profiling-interfaces.md)
- [<span data-ttu-id="39eca-150">Profilage</span><span class="sxs-lookup"><span data-stu-id="39eca-150">Profiling</span></span>](index.md)
