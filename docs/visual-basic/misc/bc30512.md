---
title: Option Strict On interdit les conversions implicites de' <type1> 'en' <type2> '
ms.date: 07/20/2015
f1_keywords:
- bc30512
- vbc30512
helpviewer_keywords:
- BC30512
ms.assetid: b9756d48-05fa-4027-8a80-b4a0ef92099d
ms.openlocfilehash: 21e90b10b3de7366eea67428b1cfa79824ef24dd
ms.sourcegitcommit: bf5c5850654187705bc94cc40ebfb62fe346ab02
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/23/2020
ms.locfileid: "91101359"
---
# <a name="option-strict-on-disallows-implicit-conversions-from-type1-to-type2"></a><span data-ttu-id="931e6-102">Option Strict On interdit les conversions implicites de' \<type1> 'en' \<type2> '</span><span class="sxs-lookup"><span data-stu-id="931e6-102">Option Strict On disallows implicit conversions from '\<type1>' to '\<type2>'</span></span>

<span data-ttu-id="931e6-103">Vous avez tenté de convertir un type en un autre type qui ne peut peut-être pas contenir la valeur, comme un `Long` en `Integer`, tandis que le commutateur de vérification de type ([Option Strict Statement](../language-reference/statements/option-strict-statement.md)) a la valeur `On`.</span><span class="sxs-lookup"><span data-stu-id="931e6-103">You have tried to convert a type to another type that may not be able to contain the value, such as a `Long` to an `Integer`, while the type checking switch ([Option Strict Statement](../language-reference/statements/option-strict-statement.md)) is set to `On`.</span></span>  
  
 <span data-ttu-id="931e6-104">Ce type de conversion, appelé *conversion restrictive*, est susceptible d’échouer au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="931e6-104">This type of conversion is called a *narrowing conversion*, and it is possible for it to fail at run time.</span></span> <span data-ttu-id="931e6-105">Pour cette raison, `Option Strict On` interdit les conversions restrictives implicites.</span><span class="sxs-lookup"><span data-stu-id="931e6-105">For this reason, `Option Strict On` disallows implicit narrowing conversions.</span></span>  
  
 <span data-ttu-id="931e6-106">**ID d’erreur :** BC30512</span><span class="sxs-lookup"><span data-stu-id="931e6-106">**Error ID:** BC30512</span></span>  
  
## <a name="to-correct-this-error"></a><span data-ttu-id="931e6-107">Pour corriger cette erreur</span><span class="sxs-lookup"><span data-stu-id="931e6-107">To correct this error</span></span>  
  
1. <span data-ttu-id="931e6-108">Déterminez si une conversion de n’importe quel type existe de `<type1>` à `<type2>`.</span><span class="sxs-lookup"><span data-stu-id="931e6-108">Determine whether a conversion of any type exists from `<type1>` to `<type2>`.</span></span> <span data-ttu-id="931e6-109">Si les deux sont Visual Basic des types élémentaires, ou si les deux sont des instances de classes, vous pouvez généralement effectuer cette détermination en consultant la table dans les [conversions étendues et restrictives](../programming-guide/language-features/data-types/widening-and-narrowing-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="931e6-109">If both are Visual Basic elementary types, or if both are instances of classes, you can usually make this determination by consulting the table in [Widening and Narrowing Conversions](../programming-guide/language-features/data-types/widening-and-narrowing-conversions.md).</span></span>  
  
2. <span data-ttu-id="931e6-110">S’il existe uniquement une conversion restrictive de `<type1>` à `<type2>`, vous devez utiliser un cast explicite.</span><span class="sxs-lookup"><span data-stu-id="931e6-110">If only a narrowing conversion exists from `<type1>` to `<type2>`, you should use explicit casting.</span></span> <span data-ttu-id="931e6-111">Les mots clés [CType Function](../language-reference/functions/ctype-function.md) et [DirectCast Operator](../language-reference/operators/directcast-operator.md) lèvent une exception au moment de l’exécution si la conversion échoue.</span><span class="sxs-lookup"><span data-stu-id="931e6-111">The [CType Function](../language-reference/functions/ctype-function.md) and [DirectCast Operator](../language-reference/operators/directcast-operator.md) keywords throw a run-time exception if the conversion fails.</span></span> <span data-ttu-id="931e6-112">Le mot clé de l' [opérateur TryCast](../language-reference/operators/trycast-operator.md) s’applique uniquement aux types référence et ne retourne [rien](../language-reference/nothing.md) si la conversion échoue.</span><span class="sxs-lookup"><span data-stu-id="931e6-112">The [TryCast Operator](../language-reference/operators/trycast-operator.md) keyword applies only to reference types and returns [Nothing](../language-reference/nothing.md) if the conversion fails.</span></span>  
  
3. <span data-ttu-id="931e6-113">Si une conversion restrictive existe et que votre programme peut tolérer une défaillance du runtime, ou si vous avez la certitude qu’aucune défaillance du runtime ne peut se produire, vous pouvez spécifier `Option Strict Off` au début de votre code source.</span><span class="sxs-lookup"><span data-stu-id="931e6-113">If a narrowing conversion exists and your program can tolerate a run-time failure, or you are confident that a run-time failure is not possible, you can specify `Option Strict Off` at the beginning of your source code.</span></span> <span data-ttu-id="931e6-114">Mais vous devez toujours placer la conversion dans une [tentative... Catch... Finally](../language-reference/statements/try-catch-finally-statement.md) , bloc d’instructions pour éviter des résultats inattendus ou un arrêt anticipé de votre programme.</span><span class="sxs-lookup"><span data-stu-id="931e6-114">But you should still enclose the conversion in a [Try...Catch...Finally Statement](../language-reference/statements/try-catch-finally-statement.md) block to avoid unexpected results or early termination of your program.</span></span>  
  
4. <span data-ttu-id="931e6-115">Si aucune conversion n’est effectuée de `<type1>` à `<type2>`, vous devez réévaluer la logique de votre programme.</span><span class="sxs-lookup"><span data-stu-id="931e6-115">If no conversion exists from `<type1>` to `<type2>`, you must re-evaluate your program logic.</span></span> <span data-ttu-id="931e6-116">Vous pouvez peut-être écrire du code qui assigne des valeurs à `<type2>` correspondant aux valeurs anticipées de `<type1>`.</span><span class="sxs-lookup"><span data-stu-id="931e6-116">You might be able to write code that can assign values to `<type2>` corresponding to anticipated values of `<type1>`.</span></span>  
  
5. <span data-ttu-id="931e6-117">Si aucune conversion n’est effectuée de `<type1>` à `<type2>` et que l’un des types est une classe ou une structure que vous avez définie, vous pouvez peut-être définir un opérateur de conversion de ce type vers l’autre type ou à partir de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="931e6-117">If no conversion exists from `<type1>` to `<type2>` and one of the types is a class or structure you have defined, you might be able to define a conversion operator from that type to or from the other type.</span></span> <span data-ttu-id="931e6-118">Pour plus d'informations, consultez [How to: Define a Conversion Operator](../programming-guide/language-features/procedures/how-to-define-a-conversion-operator.md).</span><span class="sxs-lookup"><span data-stu-id="931e6-118">For more information, see [How to: Define a Conversion Operator](../programming-guide/language-features/procedures/how-to-define-a-conversion-operator.md).</span></span>  
  
6. <span data-ttu-id="931e6-119">En règle générale, il est recommandé de ne pas utiliser de conversions restrictives, sauf si vous pouvez intercepter les défaillances dans un bloc `Catch` et les traiter de manière efficace.</span><span class="sxs-lookup"><span data-stu-id="931e6-119">In all cases and as a general guideline, you should avoid using narrowing conversions unless you can trap failures in a `Catch` block and deal with them effectively.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="931e6-120">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="931e6-120">See also</span></span>

- [<span data-ttu-id="931e6-121">Option Strict Statement</span><span class="sxs-lookup"><span data-stu-id="931e6-121">Option Strict Statement</span></span>](../language-reference/statements/option-strict-statement.md)
- [<span data-ttu-id="931e6-122">Widening and Narrowing Conversions</span><span class="sxs-lookup"><span data-stu-id="931e6-122">Widening and Narrowing Conversions</span></span>](../programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)
- [<span data-ttu-id="931e6-123">CType Function</span><span class="sxs-lookup"><span data-stu-id="931e6-123">CType Function</span></span>](../language-reference/functions/ctype-function.md)
- [<span data-ttu-id="931e6-124">DirectCast, opérateur</span><span class="sxs-lookup"><span data-stu-id="931e6-124">DirectCast Operator</span></span>](../language-reference/operators/directcast-operator.md)
- [<span data-ttu-id="931e6-125">TryCast, opérateur</span><span class="sxs-lookup"><span data-stu-id="931e6-125">TryCast Operator</span></span>](../language-reference/operators/trycast-operator.md)
- [<span data-ttu-id="931e6-126">Nothing</span><span class="sxs-lookup"><span data-stu-id="931e6-126">Nothing</span></span>](../language-reference/nothing.md)
- [<span data-ttu-id="931e6-127">Try...Catch...Finally (instruction)</span><span class="sxs-lookup"><span data-stu-id="931e6-127">Try...Catch...Finally Statement</span></span>](../language-reference/statements/try-catch-finally-statement.md)
- [<span data-ttu-id="931e6-128">Guide pratique : définir un opérateur de conversion</span><span class="sxs-lookup"><span data-stu-id="931e6-128">How to: Define a Conversion Operator</span></span>](../programming-guide/language-features/procedures/how-to-define-a-conversion-operator.md)
