---
title: Tuples
ms.date: 04/23/2017
helpviewer_keywords:
- tuples [Visual Basic]
ms.assetid: 3e66cd1b-3432-4e1d-8c37-5ebacae8f53f
ms.openlocfilehash: 378ee4e7d3a3b106b719e5da819b09f336ff218e
ms.sourcegitcommit: 67cf756b033c6173a1bbd1cbd5aef1fccac99e34
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/10/2020
ms.locfileid: "86226658"
---
# <a name="tuples-visual-basic"></a><span data-ttu-id="deab3-102">Tuples (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="deab3-102">Tuples (Visual Basic)</span></span>

<span data-ttu-id="deab3-103">À compter de Visual Basic 2017, le langage de Visual Basic offre une prise en charge intégrée des tuples qui facilitent la création de tuples et l’accès aux éléments de tuples.</span><span class="sxs-lookup"><span data-stu-id="deab3-103">Starting with Visual Basic 2017, the Visual Basic language offers built-in support for tuples that makes creating tuples and accessing the elements of tuples easier.</span></span> <span data-ttu-id="deab3-104">Un tuple est une structure de données légère qui possède un nombre et une séquence de valeurs spécifiques.</span><span class="sxs-lookup"><span data-stu-id="deab3-104">A tuple is a lightweight data structure that has a specific number and sequence of values.</span></span> <span data-ttu-id="deab3-105">Lorsque vous instanciez le tuple, vous définissez le nombre et le type de données de chaque valeur (ou élément).</span><span class="sxs-lookup"><span data-stu-id="deab3-105">When you instantiate the tuple, you define the number and the data type of each value (or element).</span></span> <span data-ttu-id="deab3-106">Par exemple, un 2 tuples (ou une paire) comporte deux éléments.</span><span class="sxs-lookup"><span data-stu-id="deab3-106">For example, a 2-tuple (or pair) has two elements.</span></span> <span data-ttu-id="deab3-107">La première peut être une `Boolean` valeur, tandis que la seconde est un `String` .</span><span class="sxs-lookup"><span data-stu-id="deab3-107">The first might be a `Boolean` value, while the second is a `String`.</span></span> <span data-ttu-id="deab3-108">Étant donné que les tuples facilitent le stockage de plusieurs valeurs dans un objet unique, ils sont souvent utilisés comme un moyen léger de retourner plusieurs valeurs à partir d’une méthode.</span><span class="sxs-lookup"><span data-stu-id="deab3-108">Because tuples make it easy to store multiple values in a single object, they are often used as a lightweight way to return multiple values from a method.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="deab3-109">La prise en charge des tuples requiert le <xref:System.ValueTuple> type.</span><span class="sxs-lookup"><span data-stu-id="deab3-109">Tuple support requires the <xref:System.ValueTuple> type.</span></span> <span data-ttu-id="deab3-110">Si le .NET Framework 4,7 n’est pas installé, vous devez ajouter le package NuGet `System.ValueTuple` , qui est disponible dans la galerie NuGet.</span><span class="sxs-lookup"><span data-stu-id="deab3-110">If the .NET Framework 4.7 is not installed, you must add the NuGet package `System.ValueTuple`, which is available on the NuGet Gallery.</span></span> <span data-ttu-id="deab3-111">Sans ce package, vous pouvez obtenir une erreur de compilation semblable à la suivante : « le type prédéfini «ValueTuple (of,,,) » n’est pas défini ou importé».</span><span class="sxs-lookup"><span data-stu-id="deab3-111">Without this package, you may get a compilation error similar to, "Predefined type 'ValueTuple(Of,,,)' is not defined or imported."</span></span>

## <a name="instantiating-and-using-a-tuple"></a><span data-ttu-id="deab3-112">Instanciation et utilisation d’un tuple</span><span class="sxs-lookup"><span data-stu-id="deab3-112">Instantiating and using a tuple</span></span>

<span data-ttu-id="deab3-113">Vous instanciez un tuple en plaçant ses valeurs délimitées par des virgules entre parenthèses.</span><span class="sxs-lookup"><span data-stu-id="deab3-113">You instantiate a tuple by enclosing its comma-delimited values in parentheses.</span></span> <span data-ttu-id="deab3-114">Chacune de ces valeurs devient alors un champ du tuple.</span><span class="sxs-lookup"><span data-stu-id="deab3-114">Each of those values then becomes a field of the tuple.</span></span> <span data-ttu-id="deab3-115">Par exemple, le code suivant définit un triple (ou 3 tuples) avec `Date` comme première valeur, un `String` comme deuxième, et un `Boolean` comme troisième.</span><span class="sxs-lookup"><span data-stu-id="deab3-115">For example, the following code defines a triple (or 3-tuple) with a `Date` as its first value, a `String` as its second, and a `Boolean` as its third.</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#1)]

<span data-ttu-id="deab3-116">Par défaut, le nom de chaque champ dans un tuple se compose de la chaîne, `Item` avec la position de base un du champ dans le tuple.</span><span class="sxs-lookup"><span data-stu-id="deab3-116">By default, the name of each field in a tuple consists of the string `Item` along with the field's one-based position in the tuple.</span></span> <span data-ttu-id="deab3-117">Pour ce tuple à 3 tuples, le champ est `Date` `Item1` , le `String` champ est `Item2` , et le `Boolean` champ est `Item3` .</span><span class="sxs-lookup"><span data-stu-id="deab3-117">For this 3-tuple, the `Date` field is `Item1`, the `String` field is `Item2`, and the `Boolean` field is `Item3`.</span></span> <span data-ttu-id="deab3-118">L’exemple suivant affiche les valeurs des champs du tuple instanciés dans la ligne de code précédente.</span><span class="sxs-lookup"><span data-stu-id="deab3-118">The following example displays the values of fields of the tuple instantiated in the previous line of code</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#2)]

<span data-ttu-id="deab3-119">Les champs d’un tuple Visual Basic sont en lecture-écriture ; une fois que vous avez instancié un tuple, vous pouvez modifier ses valeurs.</span><span class="sxs-lookup"><span data-stu-id="deab3-119">The fields of a Visual Basic tuple are read-write; after you've instantiated a tuple, you can modify its values.</span></span> <span data-ttu-id="deab3-120">L’exemple suivant modifie deux des trois champs du tuple créé dans l’exemple précédent et affiche le résultat.</span><span class="sxs-lookup"><span data-stu-id="deab3-120">The following example modifies two of the three fields of the tuple created in the previous example and displays the result.</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#3)]

## <a name="instantiating-and-using-a-named-tuple"></a><span data-ttu-id="deab3-121">Instanciation et utilisation d’un tuple nommé</span><span class="sxs-lookup"><span data-stu-id="deab3-121">Instantiating and using a named tuple</span></span>

<span data-ttu-id="deab3-122">Au lieu d’utiliser des noms par défaut pour les champs d’un tuple, vous pouvez instancier un *Tuple nommé* en assignant vos propres noms aux éléments du tuple.</span><span class="sxs-lookup"><span data-stu-id="deab3-122">Rather than using default names for a tuple's fields, you can instantiate a *named tuple* by assigning your own names to the tuple's elements.</span></span> <span data-ttu-id="deab3-123">Les champs du tuple sont ensuite accessibles par leurs noms attribués *ou* par leurs noms par défaut.</span><span class="sxs-lookup"><span data-stu-id="deab3-123">The tuple's fields can then be accessed by their assigned names *or* by their default names.</span></span> <span data-ttu-id="deab3-124">L’exemple suivant instancie le même 3 tuples que précédemment, à ceci près qu’il nomme explicitement le premier champ `EventDate` , le deuxième `Name` et le troisième `IsHoliday` .</span><span class="sxs-lookup"><span data-stu-id="deab3-124">The following example instantiates the same 3-tuple as previously, except that it explicitly names the first field `EventDate`, the second `Name`, and the third `IsHoliday`.</span></span> <span data-ttu-id="deab3-125">Il affiche ensuite les valeurs de champ, les modifie, puis affiche à nouveau les valeurs de champ.</span><span class="sxs-lookup"><span data-stu-id="deab3-125">It then displays the field values, modifies them, and displays the field values again.</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#4)]

## <a name="inferred-tuple-element-names"></a><span data-ttu-id="deab3-126">Noms des éléments de tuple inférés</span><span class="sxs-lookup"><span data-stu-id="deab3-126">Inferred tuple element names</span></span>

<span data-ttu-id="deab3-127">À partir de Visual Basic 15,3, Visual Basic pouvez déduire les noms des éléments de Tuple ; vous n’avez pas à les assigner explicitement.</span><span class="sxs-lookup"><span data-stu-id="deab3-127">Starting with Visual Basic 15.3, Visual Basic can infer the names of tuple elements; you do not have to assign them explicitly.</span></span> <span data-ttu-id="deab3-128">Les noms de tuple déduits sont utiles lorsque vous initialisez un tuple à partir d’un ensemble de variables et que vous souhaitez que le nom d’élément de tuple soit identique au nom de la variable.</span><span class="sxs-lookup"><span data-stu-id="deab3-128">Inferred tuple names are useful when you initialize a tuple from a set of variables, and you want the tuple element name to be the same as the variable name.</span></span>

<span data-ttu-id="deab3-129">L’exemple suivant crée un `stateInfo` tuple qui contient trois éléments nommés explicitement, `state` , `stateName` et `capital` .</span><span class="sxs-lookup"><span data-stu-id="deab3-129">The following example creates a `stateInfo` tuple that contains three explicitly named elements, `state`, `stateName`, and `capital`.</span></span> <span data-ttu-id="deab3-130">Notez que, lorsque vous nommez les éléments, l’instruction d’initialisation de tuple affecte simplement les éléments nommés aux valeurs des variables portant le même nom.</span><span class="sxs-lookup"><span data-stu-id="deab3-130">Note that, in naming the elements, the tuple initialization statement simply assigns the named elements the values of the identically named variables.</span></span>

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#1)]

<span data-ttu-id="deab3-131">Étant donné que les éléments et les variables portent le même nom, le compilateur Visual Basic peut déduire les noms des champs, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="deab3-131">Because elements and variables have the same name, the Visual Basic compiler can infer the names of the fields, as the following example shows.</span></span>

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="deab3-132">Pour activer les noms d’éléments tuples déduits, vous devez définir la version du compilateur Visual Basic à utiliser dans votre fichier projet Visual Basic ( \* . vbproj) :</span><span class="sxs-lookup"><span data-stu-id="deab3-132">To enable inferred tuple element names, you must define the version of the Visual Basic compiler to use in your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.3</LangVersion>
</PropertyGroup>
```

<span data-ttu-id="deab3-133">Le numéro de version peut être n’importe quelle version du compilateur Visual Basic à partir de 15,3.</span><span class="sxs-lookup"><span data-stu-id="deab3-133">The version number can be any version of the Visual Basic compiler starting with 15.3.</span></span> <span data-ttu-id="deab3-134">Au lieu de coder en dur une version spécifique du compilateur, vous pouvez également spécifier « latest » comme valeur de `LangVersion` pour compiler avec la version la plus récente du compilateur Visual Basic installé sur votre système.</span><span class="sxs-lookup"><span data-stu-id="deab3-134">Rather than hard-coding a specific compiler version, you can also specify "Latest" as the value of `LangVersion` to compile with the most recent version of the Visual Basic compiler installed on your system.</span></span>

<span data-ttu-id="deab3-135">Pour plus d’informations, consultez [définition de la version du langage Visual Basic](../../../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="deab3-135">For more information, see [setting the Visual Basic language version](../../../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="deab3-136">Dans certains cas, le compilateur Visual Basic ne peut pas déduire le nom d’élément de tuple à partir du nom du candidat, et le champ de tuple ne peut être référencé qu’à l’aide de son nom par défaut, par exemple `Item1` ,, `Item2` etc. Il s’agit notamment des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="deab3-136">In some cases, the Visual Basic compiler cannot infer the tuple element name from the candidate name, and the tuple field can only be referenced using its default name, such as `Item1`, `Item2`, etc. These include:</span></span>

- <span data-ttu-id="deab3-137">Le nom du candidat est le même que le nom d’un membre de tuple, tel que `Item3` , `Rest` ou `ToString` .</span><span class="sxs-lookup"><span data-stu-id="deab3-137">The candidate name is the same as the name of a tuple member, such as `Item3`, `Rest`, or `ToString`.</span></span>

- <span data-ttu-id="deab3-138">Le nom du candidat est dupliqué dans le tuple.</span><span class="sxs-lookup"><span data-stu-id="deab3-138">The candidate name is duplicated in the tuple.</span></span>

<span data-ttu-id="deab3-139">Lorsque l’inférence de nom de champ échoue, Visual Basic ne génère pas d’erreur de compilateur et n’est pas une exception levée au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="deab3-139">When field name inference fails, Visual Basic does not generate a compiler error, nor is an exception thrown at runtime.</span></span> <span data-ttu-id="deab3-140">Au lieu de cela, les champs de tuple doivent être référencés par leurs noms prédéfinis, tels que `Item1` et `Item2` .</span><span class="sxs-lookup"><span data-stu-id="deab3-140">Instead, tuple fields must be referenced by their predefined names, such as `Item1` and `Item2`.</span></span>

## <a name="tuples-versus-structures"></a><span data-ttu-id="deab3-141">Tuples et structures</span><span class="sxs-lookup"><span data-stu-id="deab3-141">Tuples versus structures</span></span>

<span data-ttu-id="deab3-142">Un tuple Visual Basic est un type valeur qui est une instance de l’un des types génériques **System. ValueTuple** .</span><span class="sxs-lookup"><span data-stu-id="deab3-142">A Visual Basic tuple is a value type that is an instance of one of the a **System.ValueTuple** generic types.</span></span> <span data-ttu-id="deab3-143">Par exemple, le `holiday` Tuple défini dans l’exemple précédent est une instance de la <xref:System.ValueTuple%603> structure.</span><span class="sxs-lookup"><span data-stu-id="deab3-143">For example, the `holiday` tuple defined in the previous example is an instance of the <xref:System.ValueTuple%603> structure.</span></span> <span data-ttu-id="deab3-144">Il est conçu pour être un conteneur léger de données.</span><span class="sxs-lookup"><span data-stu-id="deab3-144">It is designed to be a lightweight container for data.</span></span> <span data-ttu-id="deab3-145">Étant donné que le tuple a pour but de faciliter la création d’un objet avec plusieurs éléments de données, il manque certaines des fonctionnalités qu’une structure personnalisée peut avoir.</span><span class="sxs-lookup"><span data-stu-id="deab3-145">Since the tuple aims to make it easy to create an object with multiple data items, it lacks some of the features that a custom structure might have.</span></span> <span data-ttu-id="deab3-146">notamment :</span><span class="sxs-lookup"><span data-stu-id="deab3-146">These include:</span></span>

- <span data-ttu-id="deab3-147">Membres personnalisés.</span><span class="sxs-lookup"><span data-stu-id="deab3-147">Custom members.</span></span> <span data-ttu-id="deab3-148">Vous ne pouvez pas définir vos propres propriétés, méthodes ou événements pour un tuple.</span><span class="sxs-lookup"><span data-stu-id="deab3-148">You cannot define your own properties, methods, or events for a tuple.</span></span>

- <span data-ttu-id="deab3-149">Métrage.</span><span class="sxs-lookup"><span data-stu-id="deab3-149">Validation.</span></span> <span data-ttu-id="deab3-150">Vous ne pouvez pas valider les données assignées à des champs.</span><span class="sxs-lookup"><span data-stu-id="deab3-150">You cannot validate the data assigned to fields.</span></span>

- <span data-ttu-id="deab3-151">Altér.</span><span class="sxs-lookup"><span data-stu-id="deab3-151">Immutability.</span></span> <span data-ttu-id="deab3-152">Les tuples Visual Basic sont mutables.</span><span class="sxs-lookup"><span data-stu-id="deab3-152">Visual Basic tuples are mutable.</span></span> <span data-ttu-id="deab3-153">En revanche, une structure personnalisée vous permet de contrôler si une instance est mutable ou immuable.</span><span class="sxs-lookup"><span data-stu-id="deab3-153">In contrast, a custom structure allows you to control whether an instance is mutable or immutable.</span></span>

<span data-ttu-id="deab3-154">Si les membres personnalisés, la validation de propriété et de champ ou l’immuabilité sont importants, vous devez utiliser l’instruction Visual Basic [structure](../../../language-reference/statements/structure-statement.md) pour définir un type de valeur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="deab3-154">If custom members, property and field validation, or immutability are important, you should use the Visual Basic [Structure](../../../language-reference/statements/structure-statement.md) statement to define a custom value type.</span></span>

<span data-ttu-id="deab3-155">Un tuple Visual Basic hérite des membres de son type **ValueTuple** .</span><span class="sxs-lookup"><span data-stu-id="deab3-155">A Visual Basic tuple does inherit the members of its **ValueTuple** type.</span></span> <span data-ttu-id="deab3-156">En plus de ses champs, il s’agit des méthodes suivantes :</span><span class="sxs-lookup"><span data-stu-id="deab3-156">In addition to its fields, these include the following methods:</span></span>

| <span data-ttu-id="deab3-157">Membre</span><span class="sxs-lookup"><span data-stu-id="deab3-157">Member</span></span> | <span data-ttu-id="deab3-158">Description</span><span class="sxs-lookup"><span data-stu-id="deab3-158">Description</span></span> |
| ---|---|
| <span data-ttu-id="deab3-159">CompareTo</span><span class="sxs-lookup"><span data-stu-id="deab3-159">CompareTo</span></span> | <span data-ttu-id="deab3-160">Compare le tuple actuel à un autre Tuple avec le même nombre d’éléments.</span><span class="sxs-lookup"><span data-stu-id="deab3-160">Compares the current tuple to another tuple with the same number of elements.</span></span> |
| <span data-ttu-id="deab3-161">Est égal à</span><span class="sxs-lookup"><span data-stu-id="deab3-161">Equals</span></span> | <span data-ttu-id="deab3-162">Détermine si le tuple actuel est égal à un autre tuple ou objet.</span><span class="sxs-lookup"><span data-stu-id="deab3-162">Determines whether the current tuple is equal to another tuple or object.</span></span> |
| <span data-ttu-id="deab3-163">GetHashCode</span><span class="sxs-lookup"><span data-stu-id="deab3-163">GetHashCode</span></span> | <span data-ttu-id="deab3-164">Calcule le code de hachage pour l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="deab3-164">Calculates the hash code for the current instance.</span></span> |
| <span data-ttu-id="deab3-165">ToString</span><span class="sxs-lookup"><span data-stu-id="deab3-165">ToString</span></span> | <span data-ttu-id="deab3-166">Retourne la représentation sous forme de chaîne de ce tuple, qui prend la forme `(Item1, Item2...)` , où `Item1` et `Item2` représentent les valeurs des champs du tuple.</span><span class="sxs-lookup"><span data-stu-id="deab3-166">Returns the string representation of this tuple, which takes the form `(Item1, Item2...)`, where `Item1` and `Item2` represent the values of the tuple's fields.</span></span> |

<span data-ttu-id="deab3-167">En outre, les types **ValueTuple** implémentent les <xref:System.Collections.IStructuralComparable> <xref:System.Collections.IStructuralEquatable> interfaces et, qui vous permettent de définir des comparateurs de clients.</span><span class="sxs-lookup"><span data-stu-id="deab3-167">In addition, the **ValueTuple** types implement <xref:System.Collections.IStructuralComparable> and <xref:System.Collections.IStructuralEquatable> interfaces, which allow you to define customer comparers.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="deab3-168">Affectation et tuples</span><span class="sxs-lookup"><span data-stu-id="deab3-168">Assignment and tuples</span></span>

<span data-ttu-id="deab3-169">Visual Basic prend en charge l’assignation entre les types tuple qui ont le même nombre de champs.</span><span class="sxs-lookup"><span data-stu-id="deab3-169">Visual Basic supports assignment between tuple types that have the same number of fields.</span></span> <span data-ttu-id="deab3-170">Les types de champs peuvent être convertis si l’une des conditions suivantes est vraie :</span><span class="sxs-lookup"><span data-stu-id="deab3-170">The field types can be converted if one of the following is true:</span></span>

- <span data-ttu-id="deab3-171">Les champs source et cible sont du même type.</span><span class="sxs-lookup"><span data-stu-id="deab3-171">The source and target field are of the same type.</span></span>

- <span data-ttu-id="deab3-172">Une conversion étendue (ou implicite) du type de source vers le type cible est définie.</span><span class="sxs-lookup"><span data-stu-id="deab3-172">A widening (or implicit) conversion of the source type to the target type is defined.</span></span>

- <span data-ttu-id="deab3-173">`Option Strict`est `On` , et une conversion restrictive (ou explicite) du type source vers le type cible est définie.</span><span class="sxs-lookup"><span data-stu-id="deab3-173">`Option Strict` is `On`, and a narrowing (or explicit) conversion of the source type to the target type is defined.</span></span> <span data-ttu-id="deab3-174">Cette conversion peut lever une exception si la valeur source est en dehors de la plage du type cible.</span><span class="sxs-lookup"><span data-stu-id="deab3-174">This conversion can throw an exception if the source value is outside the range of the target type.</span></span>

<span data-ttu-id="deab3-175">Les autres conversions ne sont pas prises en compte pour les affectations.</span><span class="sxs-lookup"><span data-stu-id="deab3-175">Other conversions are not considered for assignments.</span></span> <span data-ttu-id="deab3-176">Examinons les types d’affectation qui sont autorisés entre les types tuple.</span><span class="sxs-lookup"><span data-stu-id="deab3-176">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="deab3-177">Prenez en compte les variables utilisées dans les exemples suivants :</span><span class="sxs-lookup"><span data-stu-id="deab3-177">Consider these variables used in the following examples:</span></span>

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#1)]

<span data-ttu-id="deab3-178">Les deux premières variables, `unnamed` et `anonymous` , n’ont pas de noms sémantiques fournis pour les champs.</span><span class="sxs-lookup"><span data-stu-id="deab3-178">The first two variables, `unnamed` and `anonymous`, do not have semantic names provided for the fields.</span></span> <span data-ttu-id="deab3-179">Leurs noms de champs sont les valeurs par défaut `Item1` et `Item2` .</span><span class="sxs-lookup"><span data-stu-id="deab3-179">Their field names are the default `Item1` and `Item2`.</span></span> <span data-ttu-id="deab3-180">Les deux dernières variables, `named` et `differentName` ont des noms de champ sémantique.</span><span class="sxs-lookup"><span data-stu-id="deab3-180">The last two variables, `named` and `differentName` have semantic field names.</span></span> <span data-ttu-id="deab3-181">Notez que ces deux tuples ont des noms différents pour les champs.</span><span class="sxs-lookup"><span data-stu-id="deab3-181">Note that these two tuples have different names for the fields.</span></span>

<span data-ttu-id="deab3-182">Ces quatre tuples ont le même nombre de champs (appelé « arité ») et les types de ces champs sont identiques.</span><span class="sxs-lookup"><span data-stu-id="deab3-182">All four of these tuples have the same number of fields (referred to as 'arity'), and the types of those fields are identical.</span></span> <span data-ttu-id="deab3-183">Par conséquent, toutes ces affectations fonctionnent :</span><span class="sxs-lookup"><span data-stu-id="deab3-183">Therefore, all of these assignments work:</span></span>

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#2)]

<span data-ttu-id="deab3-184">Notez que les noms des tuples ne sont pas affectés.</span><span class="sxs-lookup"><span data-stu-id="deab3-184">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="deab3-185">Les valeurs des champs sont affectées suivant l’ordre des champs dans le tuple.</span><span class="sxs-lookup"><span data-stu-id="deab3-185">The values of the fields are assigned following the order of the fields in the tuple.</span></span>

<span data-ttu-id="deab3-186">Enfin, Notez que nous pouvons assigner le `named` Tuple au `conversion` tuple, même si le premier champ de `named` est un `Integer` et que le premier champ de `conversion` est un `Long` .</span><span class="sxs-lookup"><span data-stu-id="deab3-186">Finally, notice that we can assign the `named` tuple to the `conversion` tuple, even though the first field of `named` is an `Integer`, and the first field of `conversion` is a `Long`.</span></span> <span data-ttu-id="deab3-187">Cette assignation est réussie, car la conversion d’un `Integer` en `Long` est une conversion étendue.</span><span class="sxs-lookup"><span data-stu-id="deab3-187">This assignment succeeds because converting an `Integer` to a `Long` is a widening conversion.</span></span>

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#3)]

<span data-ttu-id="deab3-188">Les tuples avec différents nombres de champs ne peuvent pas être assignés :</span><span class="sxs-lookup"><span data-stu-id="deab3-188">Tuples with different numbers of fields are not assignable:</span></span>

```vb
' Does not compile.
' VB30311: Value of type '(Integer, Integer, Integer)' cannot be converted
'          to '(Answer As Integer, Message As String)'
var differentShape = (1, 2, 3)
named = differentShape
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="deab3-189">Tuples comme valeurs de retour de méthode</span><span class="sxs-lookup"><span data-stu-id="deab3-189">Tuples as method return values</span></span>

<span data-ttu-id="deab3-190">Une méthode ne peut retourner qu’une seule valeur.</span><span class="sxs-lookup"><span data-stu-id="deab3-190">A method can return only a single value.</span></span> <span data-ttu-id="deab3-191">Bien souvent, vous aimeriez qu’un appel de méthode retourne plusieurs valeurs.</span><span class="sxs-lookup"><span data-stu-id="deab3-191">Frequently, though, you'd like a method call to return multiple values.</span></span> <span data-ttu-id="deab3-192">Il existe plusieurs façons de contourner cette limitation :</span><span class="sxs-lookup"><span data-stu-id="deab3-192">There are several ways to work around this limitation:</span></span>

- <span data-ttu-id="deab3-193">Vous pouvez créer une classe ou une structure personnalisée dont les propriétés ou les champs représentent des valeurs retournées par la méthode.</span><span class="sxs-lookup"><span data-stu-id="deab3-193">You can create a custom class or structure whose properties or fields represent values returned by the method.</span></span> <span data-ttu-id="deab3-194">C’est donc une solution à haute densité ; pour cela, vous devez définir un type personnalisé dont le seul but est de récupérer des valeurs à partir d’un appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="deab3-194">Thus is a heavyweight solution; it requires that you define a custom type whose only purpose is to retrieve values from a method call.</span></span>

- <span data-ttu-id="deab3-195">Vous pouvez retourner une valeur unique à partir de la méthode et retourner les valeurs restantes en les passant par référence à la méthode.</span><span class="sxs-lookup"><span data-stu-id="deab3-195">You can return a single value from the method, and return the remaining values by passing them by reference to the method.</span></span> <span data-ttu-id="deab3-196">Cela implique la surcharge liée à l’instanciation d’une variable et les risques de remplacement par inadvertance de la valeur de la variable que vous transmettez par référence.</span><span class="sxs-lookup"><span data-stu-id="deab3-196">This involves the overhead of instantiating a variable and risks inadvertently overwriting the value of the variable that you pass by reference.</span></span>

- <span data-ttu-id="deab3-197">Vous pouvez utiliser un tuple, qui fournit une solution légère pour récupérer plusieurs valeurs de retour.</span><span class="sxs-lookup"><span data-stu-id="deab3-197">You can use a tuple, which provides a lightweight solution to retrieving multiple return values.</span></span>

<span data-ttu-id="deab3-198">Par exemple, les méthodes **TryParse** dans .net retournent une `Boolean` valeur qui indique si l’opération d’analyse a réussi.</span><span class="sxs-lookup"><span data-stu-id="deab3-198">For example, the **TryParse** methods in .NET return a `Boolean` value that indicates whether the parsing operation succeeded.</span></span> <span data-ttu-id="deab3-199">Le résultat de l’opération d’analyse est retourné dans une variable passée par référence à la méthode.</span><span class="sxs-lookup"><span data-stu-id="deab3-199">The result of the parsing operation is returned in a variable passed by reference to the method.</span></span> <span data-ttu-id="deab3-200">Normalement, un appel à la méthode d’analyse, comme <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> celui-ci, se présente comme suit :</span><span class="sxs-lookup"><span data-stu-id="deab3-200">Normally, a call to the a parsing method such as <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> looks like the following:</span></span>

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#1)]

<span data-ttu-id="deab3-201">Nous pouvons retourner un tuple à partir de l’opération d’analyse si nous encapsulerons l’appel à la <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> méthode dans notre propre méthode.</span><span class="sxs-lookup"><span data-stu-id="deab3-201">We can return a tuple from the parsing operation if we wrap the call to the <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> method in our own method.</span></span> <span data-ttu-id="deab3-202">Dans l’exemple suivant, `NumericLibrary.ParseInteger` appelle la <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> méthode et retourne un tuple nommé avec deux éléments.</span><span class="sxs-lookup"><span data-stu-id="deab3-202">In the following example, `NumericLibrary.ParseInteger` calls the <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> method and returns a named tuple with two elements.</span></span>

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="deab3-203">Vous pouvez ensuite appeler la méthode avec un code semblable au suivant :</span><span class="sxs-lookup"><span data-stu-id="deab3-203">You can then call the method with code like the following:</span></span>

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

## <a name="visual-basic-tuples-and-tuples-in-the-net-framework"></a><span data-ttu-id="deab3-204">Visual Basic des tuples et des tuples dans le .NET Framework</span><span class="sxs-lookup"><span data-stu-id="deab3-204">Visual Basic tuples and tuples in the .NET Framework</span></span>

<span data-ttu-id="deab3-205">Un tuple Visual Basic est une instance de l’un des types génériques **System. ValueTuple** , qui ont été introduits dans le .NET Framework 4,7.</span><span class="sxs-lookup"><span data-stu-id="deab3-205">A Visual Basic tuple is an instance of one of the **System.ValueTuple** generic types, which were introduced in the .NET Framework 4.7.</span></span> <span data-ttu-id="deab3-206">Le .NET Framework comprend également un ensemble de classes **System. Tuple** génériques.</span><span class="sxs-lookup"><span data-stu-id="deab3-206">The .NET Framework also includes a set of generic **System.Tuple** classes.</span></span> <span data-ttu-id="deab3-207">Toutefois, ces classes diffèrent de Visual Basic tuples et des types génériques **System. ValueTuple** de plusieurs façons :</span><span class="sxs-lookup"><span data-stu-id="deab3-207">These classes, however, differ from Visual Basic tuples and the **System.ValueTuple** generic types in a number of ways:</span></span>

- <span data-ttu-id="deab3-208">Les éléments des classes **Tuple** sont des propriétés nommées `Item1` , `Item2` , et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="deab3-208">The elements of the **Tuple** classes are properties named `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="deab3-209">Dans Visual Basic tuples et les types **ValueTuple** , les éléments Tuple sont des champs.</span><span class="sxs-lookup"><span data-stu-id="deab3-209">In Visual Basic tuples and the **ValueTuple** types, tuple elements are fields.</span></span>

- <span data-ttu-id="deab3-210">Vous ne pouvez pas assigner des noms explicites aux éléments d’une instance de **Tuple** ou d’une instance de **ValueTuple** .</span><span class="sxs-lookup"><span data-stu-id="deab3-210">You cannot assign meaningful names to the elements of a **Tuple** instance or of a **ValueTuple** instance.</span></span> <span data-ttu-id="deab3-211">Visual Basic vous permet d’attribuer des noms qui communiquent la signification des champs.</span><span class="sxs-lookup"><span data-stu-id="deab3-211">Visual Basic allows you to assign names that communicate the meaning of the fields.</span></span>

- <span data-ttu-id="deab3-212">Les propriétés d’une instance de **Tuple** sont en lecture seule ; les tuples sont immuables.</span><span class="sxs-lookup"><span data-stu-id="deab3-212">The properties of a **Tuple** instance are read-only; the tuples are immutable.</span></span> <span data-ttu-id="deab3-213">Dans Visual Basic les tuples et les types **ValueTuple** , les champs de tuple sont en lecture-écriture ; les tuples sont mutables.</span><span class="sxs-lookup"><span data-stu-id="deab3-213">In Visual Basic tuples and the **ValueTuple** types, tuple fields are read-write; the tuples are mutable.</span></span>

- <span data-ttu-id="deab3-214">Les types de **tuples** génériques sont des types référence.</span><span class="sxs-lookup"><span data-stu-id="deab3-214">The generic **Tuple** types are reference types.</span></span> <span data-ttu-id="deab3-215">L’utilisation de ces types de **tuples** signifie l’allocation d’objets.</span><span class="sxs-lookup"><span data-stu-id="deab3-215">Using these **Tuple** types means allocating objects.</span></span> <span data-ttu-id="deab3-216">Sur des chemins réactifs, cela peut avoir un impact mesurable sur les performances de votre application.</span><span class="sxs-lookup"><span data-stu-id="deab3-216">On hot paths, this can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="deab3-217">Visual Basic tuples et les types **ValueTuple** sont des types valeur.</span><span class="sxs-lookup"><span data-stu-id="deab3-217">Visual Basic tuples and the **ValueTuple** types are value types.</span></span>

<span data-ttu-id="deab3-218">Les méthodes d’extension dans la <xref:System.TupleExtensions> classe facilitent la conversion entre les tuples Visual Basic et les objets de **Tuple** .net.</span><span class="sxs-lookup"><span data-stu-id="deab3-218">Extension methods in the <xref:System.TupleExtensions> class make it easy to convert between Visual Basic tuples and .NET **Tuple** objects.</span></span> <span data-ttu-id="deab3-219">La méthode **ToTuple** convertit un tuple Visual Basic en objet de **Tuple** .net, et la méthode **ToValueTuple** convertit un objet de **Tuple** .net en un tuple Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="deab3-219">The **ToTuple** method converts a Visual Basic tuple to a .NET **Tuple** object, and the **ToValueTuple** method converts a .NET **Tuple** object to a Visual Basic tuple.</span></span>

<span data-ttu-id="deab3-220">L’exemple suivant crée un tuple, le convertit en objet de **Tuple** .net et le convertit en un tuple Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="deab3-220">The following example creates a tuple, converts it to a .NET **Tuple** object, and converts it back to a Visual Basic tuple.</span></span> <span data-ttu-id="deab3-221">L’exemple compare ensuite ce tuple avec celui d’origine pour s’assurer qu’ils sont égaux.</span><span class="sxs-lookup"><span data-stu-id="deab3-221">The example then compares this tuple with the original one to ensure that they are equal.</span></span>

[!code-vb[Convert](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple2.vb#1)]

## <a name="see-also"></a><span data-ttu-id="deab3-222">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="deab3-222">See also</span></span>

- [<span data-ttu-id="deab3-223">Informations de référence sur le langage Visual Basic</span><span class="sxs-lookup"><span data-stu-id="deab3-223">Visual Basic Language Reference</span></span>](index.md)
