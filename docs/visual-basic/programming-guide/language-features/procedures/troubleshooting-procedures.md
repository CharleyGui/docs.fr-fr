---
title: Procédures de dépannage (Visual Basic)
ms.date: 07/20/2015
helpviewer_keywords:
- troubleshooting Visual Basic, procedures
- procedures [Visual Basic], troubleshooting
- Visual Basic code, procedures
- troubleshooting procedures
- procedures [Visual Basic], about procedures
ms.assetid: 525721e8-2e02-4f75-b5d8-6b893462cf2b
ms.openlocfilehash: d8309b9bd63a2a3d1b0b56f97be121a06b78d6b6
ms.sourcegitcommit: 3094dcd17141b32a570a82ae3f62a331616e2c9c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/01/2019
ms.locfileid: "71700131"
---
# <a name="troubleshooting-procedures-visual-basic"></a><span data-ttu-id="065f0-102">Procédures de dépannage (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="065f0-102">Troubleshooting Procedures (Visual Basic)</span></span>

<span data-ttu-id="065f0-103">Cette page répertorie certains problèmes courants qui peuvent se produire lors de l’utilisation de procédures.</span><span class="sxs-lookup"><span data-stu-id="065f0-103">This page lists some common problems that can occur when working with procedures.</span></span>

## <a name="returning-an-array-type-from-a-function-procedure"></a><span data-ttu-id="065f0-104">Retour d’un type tableau à partir d’une procédure de fonction</span><span class="sxs-lookup"><span data-stu-id="065f0-104">Returning an Array Type from a Function Procedure</span></span>

 <span data-ttu-id="065f0-105">Si une procédure `Function` retourne un type de données tableau, vous ne pouvez pas utiliser le nom `Function` pour stocker des valeurs dans les éléments du tableau.</span><span class="sxs-lookup"><span data-stu-id="065f0-105">If a `Function` procedure returns an array data type, you cannot use the `Function` name to store values in the elements of the array.</span></span> <span data-ttu-id="065f0-106">Si vous tentez de le faire, le compilateur l’interprète comme un appel à la `Function`.</span><span class="sxs-lookup"><span data-stu-id="065f0-106">If you attempt to do this, the compiler interprets it as a call to the `Function`.</span></span> <span data-ttu-id="065f0-107">L’exemple suivant génère des erreurs de compilation.</span><span class="sxs-lookup"><span data-stu-id="065f0-107">The following example generates compiler errors.</span></span>

 ```vb
 Function AllOnes(n As Integer) As Integer()
     For i = 1 To n - 1
         ' The following statement generates a COMPILER ERROR.
         AllOnes(i) = 1
     Next
     ' The following statement generates a COMPILER ERROR.
     Return AllOnes()
 End Function
 ```
  
 <span data-ttu-id="065f0-108">L’instruction `AllOnes(i) = 1` génère une erreur du compilateur, car elle semble appeler `AllOnes` avec un argument de type de données incorrect (un scalaire `Integer` au lieu d’un tableau `Integer`).</span><span class="sxs-lookup"><span data-stu-id="065f0-108">The statement `AllOnes(i) = 1` generates a compiler error because it appears to call `AllOnes` with an argument of the wrong data type (a scalar `Integer` instead of an `Integer` array).</span></span> <span data-ttu-id="065f0-109">L’instruction `Return AllOnes()` génère une erreur du compilateur, car elle semble appeler `AllOnes` sans argument.</span><span class="sxs-lookup"><span data-stu-id="065f0-109">The statement `Return AllOnes()` generates a compiler error because it appears to call `AllOnes` with no argument.</span></span>

 <span data-ttu-id="065f0-110">**Approche correcte :** Pour être en mesure de modifier les éléments d’un tableau qui doit être retourné, définissez un tableau interne en tant que variable locale.</span><span class="sxs-lookup"><span data-stu-id="065f0-110">**Correct Approach:** To be able to modify the elements of an array that is to be returned, define an internal array as a local variable.</span></span> <span data-ttu-id="065f0-111">L’exemple suivant compile sans erreur.</span><span class="sxs-lookup"><span data-stu-id="065f0-111">The following example compiles without error.</span></span>

 [!code-vb[VbVbcnProcedures#66](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#66)]

## <a name="argument-not-being-modified-by-procedure-call"></a><span data-ttu-id="065f0-112">Argument non modifié par l’appel de procédure</span><span class="sxs-lookup"><span data-stu-id="065f0-112">Argument Not Being Modified by Procedure Call</span></span>

 <span data-ttu-id="065f0-113">Si vous souhaitez autoriser une procédure à modifier un élément de programmation sous-jacent à un argument dans le code appelant, vous devez le passer par référence.</span><span class="sxs-lookup"><span data-stu-id="065f0-113">If you intend to allow a procedure to change a programming element underlying an argument in the calling code, you must pass it by reference.</span></span> <span data-ttu-id="065f0-114">Toutefois, une procédure peut accéder aux éléments d’un argument de type référence même si vous la transmettez par valeur.</span><span class="sxs-lookup"><span data-stu-id="065f0-114">But a procedure can access the elements of a reference type argument even if you pass it by value.</span></span>

- <span data-ttu-id="065f0-115">**Variable sous-jacente**.</span><span class="sxs-lookup"><span data-stu-id="065f0-115">**Underlying Variable**.</span></span> <span data-ttu-id="065f0-116">Pour permettre à la procédure de remplacer la valeur de l’élément de variable sous-jacent lui-même, la procédure doit déclarer le paramètre [ByRef](../../../language-reference/modifiers/byref.md).</span><span class="sxs-lookup"><span data-stu-id="065f0-116">To allow the procedure to replace the value of the underlying variable element itself, the procedure must declare the parameter [ByRef](../../../language-reference/modifiers/byref.md).</span></span> <span data-ttu-id="065f0-117">En outre, le code appelant ne doit pas placer l’argument entre parenthèses, car cela remplacerait le mécanisme de passage `ByRef`.</span><span class="sxs-lookup"><span data-stu-id="065f0-117">Also, the calling code must not enclose the argument in parentheses, because that would override the `ByRef` passing mechanism.</span></span>

- <span data-ttu-id="065f0-118">**Éléments de type référence**.</span><span class="sxs-lookup"><span data-stu-id="065f0-118">**Reference Type Elements**.</span></span> <span data-ttu-id="065f0-119">Si vous déclarez un paramètre [ByVal](../../../language-reference/modifiers/byval.md), la procédure ne peut pas modifier l’élément de variable sous-jacent lui-même.</span><span class="sxs-lookup"><span data-stu-id="065f0-119">If you declare a parameter [ByVal](../../../language-reference/modifiers/byval.md), the procedure cannot modify the underlying variable element itself.</span></span> <span data-ttu-id="065f0-120">Toutefois, si l’argument est un type référence, la procédure peut modifier les membres de l’objet vers lequel il pointe, même s’il ne peut pas remplacer la valeur de la variable.</span><span class="sxs-lookup"><span data-stu-id="065f0-120">However, if the argument is a reference type, the procedure can modify the members of the object to which it points, even though it cannot replace the variable's value.</span></span> <span data-ttu-id="065f0-121">Par exemple, si l’argument est une variable tableau, la procédure ne peut pas lui assigner un nouveau tableau, mais il peut modifier un ou plusieurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="065f0-121">For example, if the argument is an array variable, the procedure cannot assign a new array to it, but it can change one or more of its elements.</span></span> <span data-ttu-id="065f0-122">Les éléments modifiés sont reflétés dans la variable de tableau sous-jacente dans le code appelant.</span><span class="sxs-lookup"><span data-stu-id="065f0-122">The changed elements are reflected in the underlying array variable in the calling code.</span></span>

 <span data-ttu-id="065f0-123">L’exemple suivant définit deux procédures qui prennent une variable tableau par valeur et opèrent sur ses éléments.</span><span class="sxs-lookup"><span data-stu-id="065f0-123">The following example defines two procedures that take an array variable by value and operate on its elements.</span></span> <span data-ttu-id="065f0-124">La procédure `increase` ajoute simplement une à chaque élément.</span><span class="sxs-lookup"><span data-stu-id="065f0-124">Procedure `increase` simply adds one to each element.</span></span> <span data-ttu-id="065f0-125">La procédure `replace` affecte un nouveau tableau au paramètre `a()`, puis ajoute un à chaque élément.</span><span class="sxs-lookup"><span data-stu-id="065f0-125">Procedure `replace` assigns a new array to the parameter `a()` and then adds one to each element.</span></span> <span data-ttu-id="065f0-126">Toutefois, la réassignation n’affecte pas la variable de tableau sous-jacente dans le code appelant, car `a()` est déclarée `ByVal`.</span><span class="sxs-lookup"><span data-stu-id="065f0-126">However, the reassignment does not affect the underlying array variable in the calling code because `a()` is declared `ByVal`.</span></span>

 [!code-vb[VbVbcnProcedures#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#35)]

 [!code-vb[VbVbcnProcedures#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#38)]

 <span data-ttu-id="065f0-127">L’exemple suivant effectue des appels à `increase` et `replace`.</span><span class="sxs-lookup"><span data-stu-id="065f0-127">The following example makes calls to `increase` and `replace`.</span></span>

 [!code-vb[VbVbcnProcedures#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#37)]

 <span data-ttu-id="065f0-128">Le premier appel de `MsgBox` affiche «après l’augmentation (n) : 11, 21, 31, 41 ".</span><span class="sxs-lookup"><span data-stu-id="065f0-128">The first `MsgBox` call displays "After increase(n): 11, 21, 31, 41".</span></span> <span data-ttu-id="065f0-129">Étant donné que `n` est un type référence, `increase` peut modifier ses membres, même s’il est passé `ByVal`.</span><span class="sxs-lookup"><span data-stu-id="065f0-129">Because `n` is a reference type, `increase` can change its members, even though it is passed `ByVal`.</span></span>

 <span data-ttu-id="065f0-130">Le deuxième appel de `MsgBox` affiche «after Replace (n) : 11, 21, 31, 41 ".</span><span class="sxs-lookup"><span data-stu-id="065f0-130">The second `MsgBox` call displays "After replace(n): 11, 21, 31, 41".</span></span> <span data-ttu-id="065f0-131">Étant donné que `n` est passé `ByVal`, `replace` ne peut pas modifier la variable `n` en lui assignant un nouveau tableau.</span><span class="sxs-lookup"><span data-stu-id="065f0-131">Because `n` is passed `ByVal`, `replace` cannot modify the variable `n` by assigning a new array to it.</span></span> <span data-ttu-id="065f0-132">Lorsque `replace` crée la nouvelle instance de tableau `k` et l’assigne à la variable locale `a`, elle perd la référence à `n` passée par le code appelant.</span><span class="sxs-lookup"><span data-stu-id="065f0-132">When `replace` creates the new array instance `k` and assigns it to the local variable `a`, it loses the reference to `n` passed in by the calling code.</span></span> <span data-ttu-id="065f0-133">Lorsqu’il incrémente les membres de `a`, seul le tableau local `k` est affecté.</span><span class="sxs-lookup"><span data-stu-id="065f0-133">When it increments the members of `a`, only the local array `k` is affected.</span></span>

 <span data-ttu-id="065f0-134">**Approche correcte :** Pour être en mesure de modifier un élément de variable sous-jacent lui-même, transmettez-le par référence.</span><span class="sxs-lookup"><span data-stu-id="065f0-134">**Correct Approach:** To be able to modify an underlying variable element itself, pass it by reference.</span></span> <span data-ttu-id="065f0-135">L’exemple suivant illustre la modification apportée à la déclaration de `replace` qui lui permet de remplacer un tableau par un autre dans le code appelant.</span><span class="sxs-lookup"><span data-stu-id="065f0-135">The following example shows the change in the declaration of `replace` that allows it to replace one array with another in the calling code.</span></span>

 [!code-vb[VbVbcnProcedures#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#64)]

## <a name="unable-to-define-an-overload"></a><span data-ttu-id="065f0-136">Impossible de définir une surcharge</span><span class="sxs-lookup"><span data-stu-id="065f0-136">Unable to Define an Overload</span></span>

 <span data-ttu-id="065f0-137">Si vous souhaitez définir une version surchargée d’une procédure, vous devez utiliser le même nom, mais une signature différente.</span><span class="sxs-lookup"><span data-stu-id="065f0-137">If you want to define an overloaded version of a procedure, you must use the same name but a different signature.</span></span> <span data-ttu-id="065f0-138">Si le compilateur ne peut pas différencier votre déclaration d’une surcharge avec la même signature, il génère une erreur.</span><span class="sxs-lookup"><span data-stu-id="065f0-138">If the compiler cannot differentiate your declaration from an overload with the same signature, it generates an error.</span></span>

 <span data-ttu-id="065f0-139">La *signature* d’une procédure est déterminée par le nom de la procédure et la liste de paramètres.</span><span class="sxs-lookup"><span data-stu-id="065f0-139">The *signature* of a procedure is determined by the procedure name and the parameter list.</span></span> <span data-ttu-id="065f0-140">Chaque surcharge doit avoir le même nom que toutes les autres surcharges, mais elle doit être différente de toutes les autres dans au moins l’un des autres composants de la signature.</span><span class="sxs-lookup"><span data-stu-id="065f0-140">Each overload must have the same name as all the other overloads but must differ from all of them in at least one of the other components of the signature.</span></span> <span data-ttu-id="065f0-141">Pour plus d'informations, consultez [Procedure Overloading](procedure-overloading.md).</span><span class="sxs-lookup"><span data-stu-id="065f0-141">For more information, see [Procedure Overloading](procedure-overloading.md).</span></span>

 <span data-ttu-id="065f0-142">Les éléments suivants, même s’ils se rapportent à la liste de paramètres, ne sont pas des composants de la signature d’une procédure :</span><span class="sxs-lookup"><span data-stu-id="065f0-142">The following items, even though they pertain to the parameter list, are not components of a procedure's signature:</span></span>

- <span data-ttu-id="065f0-143">Mots clés de modificateur de procédure, tels que `Public`, `Shared` et `Static`</span><span class="sxs-lookup"><span data-stu-id="065f0-143">Procedure modifier keywords, such as `Public`, `Shared`, and `Static`</span></span>

- <span data-ttu-id="065f0-144">Noms de paramètres</span><span class="sxs-lookup"><span data-stu-id="065f0-144">Parameter names</span></span>

- <span data-ttu-id="065f0-145">Mots clés de modificateur de paramètre, tels que `ByRef` et `Optional`</span><span class="sxs-lookup"><span data-stu-id="065f0-145">Parameter modifier keywords, such as `ByRef` and `Optional`</span></span>

- <span data-ttu-id="065f0-146">Type de données de la valeur de retour (à l’exception d’un opérateur de conversion)</span><span class="sxs-lookup"><span data-stu-id="065f0-146">The data type of the return value (except for a conversion operator)</span></span>

 <span data-ttu-id="065f0-147">Vous ne pouvez pas surcharger une procédure en faisant varier un ou plusieurs des éléments précédents.</span><span class="sxs-lookup"><span data-stu-id="065f0-147">You cannot overload a procedure by varying only one or more of the preceding items.</span></span>

 <span data-ttu-id="065f0-148">**Approche correcte :** Pour pouvoir définir une surcharge de procédure, vous devez faire varier la signature.</span><span class="sxs-lookup"><span data-stu-id="065f0-148">**Correct Approach:** To be able to define a procedure overload, you must vary the signature.</span></span> <span data-ttu-id="065f0-149">Étant donné que vous devez utiliser le même nom, vous devez faire varier le nombre, l’ordre ou les types de données des paramètres.</span><span class="sxs-lookup"><span data-stu-id="065f0-149">Because you must use the same name, you must vary the number, order, or data types of the parameters.</span></span> <span data-ttu-id="065f0-150">Dans une procédure générique, vous pouvez faire varier le nombre de paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="065f0-150">In a generic procedure, you can vary the number of type parameters.</span></span> <span data-ttu-id="065f0-151">Dans un opérateur de conversion ([fonction CType](../../../language-reference/functions/ctype-function.md)), vous pouvez faire varier le type de retour.</span><span class="sxs-lookup"><span data-stu-id="065f0-151">In a conversion operator ([CType Function](../../../language-reference/functions/ctype-function.md)), you can vary the return type.</span></span>

### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a><span data-ttu-id="065f0-152">Résolution de surcharge avec des arguments facultatifs et ParamArray</span><span class="sxs-lookup"><span data-stu-id="065f0-152">Overload Resolution with Optional and ParamArray Arguments</span></span>

 <span data-ttu-id="065f0-153">Si vous surchargez une procédure avec un ou plusieurs paramètres [facultatifs](../../../language-reference/modifiers/optional.md) ou un paramètre [ParamArray](../../../language-reference/modifiers/paramarray.md) , vous devez éviter de dupliquer les *surcharges implicites*.</span><span class="sxs-lookup"><span data-stu-id="065f0-153">If you are overloading a procedure with one or more [Optional](../../../language-reference/modifiers/optional.md) parameters or a [ParamArray](../../../language-reference/modifiers/paramarray.md) parameter, you must avoid duplicating any of the *implicit overloads*.</span></span> <span data-ttu-id="065f0-154">Pour plus d’informations, consultez [Considérations sur la surcharge des procédures](considerations-in-overloading-procedures.md).</span><span class="sxs-lookup"><span data-stu-id="065f0-154">For information, see [Considerations in Overloading Procedures](considerations-in-overloading-procedures.md).</span></span>

## <a name="calling-a-wrong-version-of-an-overloaded-procedure"></a><span data-ttu-id="065f0-155">Appel d’une version incorrecte d’une procédure surchargée</span><span class="sxs-lookup"><span data-stu-id="065f0-155">Calling a Wrong Version of an Overloaded Procedure</span></span>

 <span data-ttu-id="065f0-156">Si une procédure a plusieurs versions surchargées, vous devez connaître toutes les listes de paramètres et comprendre comment Visual Basic résout les appels entre les surcharges.</span><span class="sxs-lookup"><span data-stu-id="065f0-156">If a procedure has several overloaded versions, you should be familiar with all their parameter lists and understand how Visual Basic resolves calls among the overloads.</span></span> <span data-ttu-id="065f0-157">Sinon, vous pouvez appeler une surcharge autre que celle prévue.</span><span class="sxs-lookup"><span data-stu-id="065f0-157">Otherwise you could call an overload other than the intended one.</span></span>

 <span data-ttu-id="065f0-158">Une fois que vous avez déterminé la surcharge que vous souhaitez appeler, veillez à respecter les règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="065f0-158">When you have determined which overload you want to call, be careful to observe the following rules:</span></span>

- <span data-ttu-id="065f0-159">Fournissez le nombre correct d’arguments et dans le bon ordre.</span><span class="sxs-lookup"><span data-stu-id="065f0-159">Supply the correct number of arguments, and in the correct order.</span></span>

- <span data-ttu-id="065f0-160">Dans l’idéal, vos arguments doivent avoir exactement les mêmes types de données que les paramètres correspondants.</span><span class="sxs-lookup"><span data-stu-id="065f0-160">Ideally, your arguments should have the exact same data types as the corresponding parameters.</span></span> <span data-ttu-id="065f0-161">Dans tous les cas, le type de données de chaque argument doit être étendu à celui de son paramètre correspondant.</span><span class="sxs-lookup"><span data-stu-id="065f0-161">In any case, the data type of each argument must widen to that of its corresponding parameter.</span></span> <span data-ttu-id="065f0-162">Cela est vrai même si l' [instruction Option Strict](../../../language-reference/statements/option-strict-statement.md) est définie sur `Off`.</span><span class="sxs-lookup"><span data-stu-id="065f0-162">This is true even with the [Option Strict Statement](../../../language-reference/statements/option-strict-statement.md) set to `Off`.</span></span> <span data-ttu-id="065f0-163">Si une surcharge requiert une conversion restrictive de la liste d’arguments, cette surcharge ne peut pas être appelée.</span><span class="sxs-lookup"><span data-stu-id="065f0-163">If an overload requires any narrowing conversion from your argument list, that overload is not eligible to be called.</span></span>

- <span data-ttu-id="065f0-164">Si vous fournissez des arguments qui requièrent l’élargissement, rendez leurs types de données aussi proches que possible des types de données de paramètre correspondants.</span><span class="sxs-lookup"><span data-stu-id="065f0-164">If you supply arguments that require widening, make their data types as close as possible to the corresponding parameter data types.</span></span> <span data-ttu-id="065f0-165">Si au moins deux surcharges acceptent vos types de données d’argument, le compilateur résout votre appel à la surcharge qui appelle pour l’élargissement le plus faible.</span><span class="sxs-lookup"><span data-stu-id="065f0-165">If two or more overloads accept your argument data types, the compiler resolves your call to the overload that calls for the least amount of widening.</span></span>

 <span data-ttu-id="065f0-166">Vous pouvez réduire le risque d’incompatibilités de type de données à l’aide du mot clé [CType Function](../../../language-reference/functions/ctype-function.md) conversion lors de la préparation de vos arguments.</span><span class="sxs-lookup"><span data-stu-id="065f0-166">You can reduce the chance of data type mismatches by using the [CType Function](../../../language-reference/functions/ctype-function.md) conversion keyword when preparing your arguments.</span></span>

### <a name="overload-resolution-failure"></a><span data-ttu-id="065f0-167">Échec de résolution de surcharge</span><span class="sxs-lookup"><span data-stu-id="065f0-167">Overload Resolution Failure</span></span>

 <span data-ttu-id="065f0-168">Quand vous appelez une procédure surchargée, le compilateur tente d’éliminer toutes les surcharges sauf une.</span><span class="sxs-lookup"><span data-stu-id="065f0-168">When you call an overloaded procedure, the compiler attempts to eliminate all but one of the overloads.</span></span> <span data-ttu-id="065f0-169">Si elle est réussie, elle résout l’appel à cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="065f0-169">If it succeeds, it resolves the call to that overload.</span></span> <span data-ttu-id="065f0-170">S’il élimine toutes les surcharges, ou s’il ne peut pas réduire les surcharges éligibles à un seul candidat, il génère une erreur.</span><span class="sxs-lookup"><span data-stu-id="065f0-170">If it eliminates all the overloads, or if it cannot reduce the eligible overloads to a single candidate, it generates an error.</span></span>

 <span data-ttu-id="065f0-171">L’exemple suivant illustre le processus de résolution de surcharge.</span><span class="sxs-lookup"><span data-stu-id="065f0-171">The following example illustrates the overload resolution process.</span></span>

 [!code-vb[VbVbcnProcedures#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#62)]

 [!code-vb[VbVbcnProcedures#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#63)]

 <span data-ttu-id="065f0-172">Dans le premier appel, le compilateur élimine la première surcharge, car le type du premier argument (`Short`) est limité au type du paramètre correspondant (`Byte`).</span><span class="sxs-lookup"><span data-stu-id="065f0-172">In the first call, the compiler eliminates the first overload because the type of the first argument (`Short`) narrows to the type of the corresponding parameter (`Byte`).</span></span> <span data-ttu-id="065f0-173">Il élimine ensuite la troisième surcharge, car chaque type d’argument de la deuxième surcharge (`Short` et `Single`) s’étend au type correspondant dans la troisième surcharge (`Integer` et `Single`).</span><span class="sxs-lookup"><span data-stu-id="065f0-173">It then eliminates the third overload because each argument type in the second overload (`Short` and `Single`) widens to the corresponding type in the third overload (`Integer` and `Single`).</span></span> <span data-ttu-id="065f0-174">La deuxième surcharge nécessite moins d’élargissement, donc le compilateur l’utilise pour l’appel.</span><span class="sxs-lookup"><span data-stu-id="065f0-174">The second overload requires less widening, so the compiler uses it for the call.</span></span>

 <span data-ttu-id="065f0-175">Dans le deuxième appel, le compilateur ne peut pas éliminer les surcharges sur la base de la fonction restrictive.</span><span class="sxs-lookup"><span data-stu-id="065f0-175">In the second call, the compiler cannot eliminate any of the overloads on the basis of narrowing.</span></span> <span data-ttu-id="065f0-176">Elle élimine la troisième surcharge pour la même raison que dans le premier appel, car elle peut appeler la deuxième surcharge avec moins d’élargissement des types d’arguments.</span><span class="sxs-lookup"><span data-stu-id="065f0-176">It eliminates the third overload for the same reason as in the first call, because it can call the second overload with less widening of the argument types.</span></span> <span data-ttu-id="065f0-177">Toutefois, le compilateur ne peut pas résoudre entre la première et la deuxième surcharge.</span><span class="sxs-lookup"><span data-stu-id="065f0-177">However, the compiler cannot resolve between the first and second overloads.</span></span> <span data-ttu-id="065f0-178">Chaque est associé à un type de paramètre défini qui s’étend au type correspondant dans l’autre (`Byte` à `Short`, mais `Single` à `Double`).</span><span class="sxs-lookup"><span data-stu-id="065f0-178">Each has one defined parameter type that widens to the corresponding type in the other (`Byte` to `Short`, but `Single` to `Double`).</span></span> <span data-ttu-id="065f0-179">Par conséquent, le compilateur génère une erreur de résolution de surcharge.</span><span class="sxs-lookup"><span data-stu-id="065f0-179">The compiler therefore generates an overload resolution error.</span></span>

 <span data-ttu-id="065f0-180">**Approche correcte :** Pour pouvoir appeler une procédure surchargée sans ambiguïté, utilisez la [fonction CType](../../../language-reference/functions/ctype-function.md) pour faire correspondre les types de données d’argument aux types de paramètres.</span><span class="sxs-lookup"><span data-stu-id="065f0-180">**Correct Approach:** To be able to call an overloaded procedure without ambiguity, use [CType Function](../../../language-reference/functions/ctype-function.md) to match the argument data types to the parameter types.</span></span> <span data-ttu-id="065f0-181">L’exemple suivant montre un appel à `z` qui force la résolution à la deuxième surcharge.</span><span class="sxs-lookup"><span data-stu-id="065f0-181">The following example shows a call to `z` that forces resolution to the second overload.</span></span>

 [!code-vb[VbVbcnProcedures#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#65)]

### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a><span data-ttu-id="065f0-182">Résolution de surcharge avec des arguments facultatifs et ParamArray</span><span class="sxs-lookup"><span data-stu-id="065f0-182">Overload Resolution with Optional and ParamArray Arguments</span></span>

 <span data-ttu-id="065f0-183">Si deux surcharges d’une procédure ont des signatures identiques, sauf que le dernier paramètre est déclaré [facultatif](../../../language-reference/modifiers/optional.md) dans un et [ParamArray](../../../language-reference/modifiers/paramarray.md) dans l’autre, le compilateur résout un appel à cette procédure en fonction de la correspondance la plus proche.</span><span class="sxs-lookup"><span data-stu-id="065f0-183">If two overloads of a procedure have identical signatures except that the last parameter is declared [Optional](../../../language-reference/modifiers/optional.md) in one and [ParamArray](../../../language-reference/modifiers/paramarray.md) in the other, the compiler resolves a call to that procedure according to the closest match.</span></span> <span data-ttu-id="065f0-184">Pour plus d'informations, consultez [Overload Resolution](overload-resolution.md).</span><span class="sxs-lookup"><span data-stu-id="065f0-184">For more information, see [Overload Resolution](overload-resolution.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="065f0-185">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="065f0-185">See also</span></span>

- [<span data-ttu-id="065f0-186">Procédures</span><span class="sxs-lookup"><span data-stu-id="065f0-186">Procedures</span></span>](index.md)
- [<span data-ttu-id="065f0-187">Procédures Sub</span><span class="sxs-lookup"><span data-stu-id="065f0-187">Sub Procedures</span></span>](sub-procedures.md)
- [<span data-ttu-id="065f0-188">Procédures Function</span><span class="sxs-lookup"><span data-stu-id="065f0-188">Function Procedures</span></span>](function-procedures.md)
- [<span data-ttu-id="065f0-189">Procédures de propriété</span><span class="sxs-lookup"><span data-stu-id="065f0-189">Property Procedures</span></span>](property-procedures.md)
- [<span data-ttu-id="065f0-190">Procédures d’opérateur</span><span class="sxs-lookup"><span data-stu-id="065f0-190">Operator Procedures</span></span>](operator-procedures.md)
- [<span data-ttu-id="065f0-191">Paramètres et arguments d’une procédure</span><span class="sxs-lookup"><span data-stu-id="065f0-191">Procedure Parameters and Arguments</span></span>](procedure-parameters-and-arguments.md)
- [<span data-ttu-id="065f0-192">Surcharge de procédure</span><span class="sxs-lookup"><span data-stu-id="065f0-192">Procedure Overloading</span></span>](procedure-overloading.md)
- [<span data-ttu-id="065f0-193">Considérations sur les surcharges de procédures</span><span class="sxs-lookup"><span data-stu-id="065f0-193">Considerations in Overloading Procedures</span></span>](considerations-in-overloading-procedures.md)
- [<span data-ttu-id="065f0-194">Résolution de surcharge</span><span class="sxs-lookup"><span data-stu-id="065f0-194">Overload Resolution</span></span>](overload-resolution.md)
