---
title: 'Durée de vie d’un objet : création et destruction des objets'
ms.date: 07/20/2015
f1_keywords:
- vb.Constructor
helpviewer_keywords:
- destructors, object lifetime
- Sub Finalize destructor
- objects [Visual Basic], destroying
- lifetime [Visual Basic], objects
- Sub New constructor, object lifetime
- Finalize method [Visual Basic], object lifetime
- objects [Visual Basic], creating
- Class_Terminate
- Dispose method [Visual Basic], object lifetime
- Class_Initialize
- object creation [Visual Basic], object lifetime
- parameterized constructors
- objects [Visual Basic], lifetime
- objects [Visual Basic], garbage collection
- constructors [Visual Basic], object lifetime
- Sub Dispose destructor
- garbage collection [Visual Basic], Visual Basic
ms.assetid: f1ee8458-b156-44e0-9a8a-5dd171648cd8
ms.openlocfilehash: a32a5d075b5b1d02632c80216e7c2c12920bf4a2
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90544139"
---
# <a name="object-lifetime-how-objects-are-created-and-destroyed-visual-basic"></a><span data-ttu-id="0dc9f-102">Durée de vie d'un objet : création et destruction des objets (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-102">Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)</span></span>

<span data-ttu-id="0dc9f-103">Une instance de classe (objet) est créée à l'aide du mot clé `New`.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-103">An instance of a class, an object, is created by using the `New` keyword.</span></span> <span data-ttu-id="0dc9f-104">Des tâches d’initialisation doivent souvent être exécutées sur les nouveaux objets préalablement à leur utilisation.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-104">Initialization tasks often must be performed on new objects before they are used.</span></span> <span data-ttu-id="0dc9f-105">Ces tâches d’initialisation consistent généralement à ouvrir des fichiers, à se connecter à des bases de données et à lire des valeurs de clés de Registre.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-105">Common initialization tasks include opening files, connecting to databases, and reading values of registry keys.</span></span> <span data-ttu-id="0dc9f-106">Visual Basic contrôle l’initialisation de nouveaux objets à l’aide de procédures appelées *constructeurs* (méthodes spéciales qui autorisent le contrôle sur l’initialisation).</span><span class="sxs-lookup"><span data-stu-id="0dc9f-106">Visual Basic controls the initialization of new objects using procedures called *constructors* (special methods that allow control over initialization).</span></span>

<span data-ttu-id="0dc9f-107">Dès lors qu'un objet est hors de portée, il est libéré par le CLR (Common Language Runtime).</span><span class="sxs-lookup"><span data-stu-id="0dc9f-107">After an object leaves scope, it is released by the common language runtime (CLR).</span></span> <span data-ttu-id="0dc9f-108">Visual Basic contrôle la mise en version des ressources système à l’aide de procédures appelées *destructeurs*.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-108">Visual Basic controls the release of system resources using procedures called *destructors*.</span></span> <span data-ttu-id="0dc9f-109">Ensemble, constructeurs et destructeurs facilitent la création de bibliothèques de classes robustes et prévisibles.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-109">Together, constructors and destructors support the creation of robust and predictable class libraries.</span></span>

## <a name="using-constructors-and-destructors"></a><span data-ttu-id="0dc9f-110">Utilisation des constructeurs et des destructeurs</span><span class="sxs-lookup"><span data-stu-id="0dc9f-110">Using Constructors and Destructors</span></span>

<span data-ttu-id="0dc9f-111">Les constructeurs et les destructeurs contrôlent la création et la destruction d'objets.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-111">Constructors and destructors control the creation and destruction of objects.</span></span> <span data-ttu-id="0dc9f-112">Les `Sub New` `Sub Finalize` procédures et de Visual Basic initialiser et détruire des objets ; elles remplacent les `Class_Initialize` `Class_Terminate` méthodes et utilisées dans Visual Basic 6,0 et versions antérieures.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-112">The `Sub New` and `Sub Finalize` procedures in Visual Basic initialize and destroy objects; they replace the `Class_Initialize` and `Class_Terminate` methods used in Visual Basic 6.0 and earlier versions.</span></span>

### <a name="sub-new"></a><span data-ttu-id="0dc9f-113">Sub New</span><span class="sxs-lookup"><span data-stu-id="0dc9f-113">Sub New</span></span>

<span data-ttu-id="0dc9f-114">Le constructeur `Sub New` ne peut s'exécuter qu'une seule fois lors de la création d'une classe.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-114">The `Sub New` constructor can run only once when a class is created.</span></span> <span data-ttu-id="0dc9f-115">Il ne peut pas être appelé explicitement ailleurs que dans la première ligne de code d'un autre constructeur de la même classe ou d'une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-115">It cannot be called explicitly anywhere other than in the first line of code of another constructor from either the same class or from a derived class.</span></span> <span data-ttu-id="0dc9f-116">De plus, le code figurant dans la méthode `Sub New` s'exécute toujours avant tout autre code présent dans une classe.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-116">Furthermore, the code in the `Sub New` method always runs before any other code in a class.</span></span> <span data-ttu-id="0dc9f-117">Visual Basic crée implicitement un `Sub New` constructeur au moment de l’exécution si vous ne définissez pas explicitement une `Sub New` procédure pour une classe.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-117">Visual Basic implicitly creates a `Sub New` constructor at run time if you do not explicitly define a `Sub New` procedure for a class.</span></span>

<span data-ttu-id="0dc9f-118">Pour créer un constructeur pour une classe, créez une procédure nommée `Sub New` n'importe où dans la définition de la classe.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-118">To create a constructor for a class, create a procedure named `Sub New` anywhere in the class definition.</span></span> <span data-ttu-id="0dc9f-119">Pour créer un constructeur paramétrable, spécifiez les noms et les types de données des arguments de `Sub New` comme vous le feriez pour spécifier les arguments d’une autre procédure, comme dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="0dc9f-119">To create a parameterized constructor, specify the names and data types of arguments to `Sub New` just as you would specify arguments for any other procedure, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#42)]

<span data-ttu-id="0dc9f-120">Les constructeurs sont souvent surchargés, comme dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="0dc9f-120">Constructors are frequently overloaded, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#116](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#116)]

<span data-ttu-id="0dc9f-121">Quand vous définissez une classe dérivée d'une autre classe, la première ligne d'un constructeur doit être un appel au constructeur de la classe de base, à moins que celle-ci contienne un constructeur accessible qui n'accepte aucun paramètre.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-121">When you define a class derived from another class, the first line of a constructor must be a call to the constructor of the base class, unless the base class has an accessible constructor that takes no parameters.</span></span> <span data-ttu-id="0dc9f-122">Un appel à la classe de base contenant le constructeur ci-dessus, par exemple, serait `MyBase.New(s)`.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-122">A call to the base class that contains the above constructor, for example, would be `MyBase.New(s)`.</span></span> <span data-ttu-id="0dc9f-123">Sinon, `MyBase.New` est facultatif et le runtime Visual Basic l’appelle implicitement.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-123">Otherwise, `MyBase.New` is optional, and the Visual Basic runtime calls it implicitly.</span></span>

<span data-ttu-id="0dc9f-124">Une fois que vous avez écrit le code destiné à appeler le constructeur de l'objet parent, vous pouvez ajouter du code d'initialisation supplémentaire à la procédure `Sub New`.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-124">After you write the code to call the parent object's constructor, you can add any additional initialization code to the `Sub New` procedure.</span></span> <span data-ttu-id="0dc9f-125">`Sub New` peut accepter des arguments quand elle est appelée en tant que constructeur paramétrable.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-125">`Sub New` can accept arguments when called as a parameterized constructor.</span></span> <span data-ttu-id="0dc9f-126">Ces paramètres sont passés à partir de la procédure appelant le constructeur, par exemple, `Dim AnObject As New ThisClass(X)`.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-126">These parameters are passed from the procedure calling the constructor, for example, `Dim AnObject As New ThisClass(X)`.</span></span>

### <a name="sub-finalize"></a><span data-ttu-id="0dc9f-127">Sub Finalize</span><span class="sxs-lookup"><span data-stu-id="0dc9f-127">Sub Finalize</span></span>

<span data-ttu-id="0dc9f-128">Avant de libérer des objets, le CLR appelle automatiquement la méthode `Finalize` pour les objets qui définissent une procédure `Sub Finalize`.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-128">Before releasing objects, the CLR automatically calls the `Finalize` method for objects that define a `Sub Finalize` procedure.</span></span> <span data-ttu-id="0dc9f-129">La méthode `Finalize` peut contenir du code qui doit s'exécuter juste avant la destruction d'un objet. Tel est le cas du code destiné à fermer les fichiers et à enregistrer les informations d'état.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-129">The `Finalize` method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information.</span></span> <span data-ttu-id="0dc9f-130">L'exécution de `Sub Finalize` pouvant occasionner une légère baisse des performances, ne définissez une méthode `Sub Finalize` que si vous avez besoin de libérer des objets explicitement.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-130">There is a slight performance penalty for executing `Sub Finalize`, so you should define a `Sub Finalize` method only when you need to release objects explicitly.</span></span>

> [!NOTE]
> <span data-ttu-id="0dc9f-131">Le garbage collector du CLR ne supprime pas (et ne peut pas) les objets *non managés*, les objets que le système d’exploitation exécute directement, en dehors de l’environnement CLR.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-131">The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment.</span></span> <span data-ttu-id="0dc9f-132">Ceci s'explique par le fait que la méthode de suppression des objets non managés varie en fonction de leur type.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-132">This is because different unmanaged objects must be disposed of in different ways.</span></span> <span data-ttu-id="0dc9f-133">Ces informations ne sont pas directement associées à l'objet non managé ; elles doivent se trouver dans la documentation relative à l'objet.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-133">That information is not directly associated with the unmanaged object; it must be found in the documentation for the object.</span></span> <span data-ttu-id="0dc9f-134">Une classe qui utilise des objets non managés doit les supprimer dans sa méthode `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-134">A class that uses unmanaged objects must dispose of them in its `Finalize` method.</span></span>

<span data-ttu-id="0dc9f-135">Le destructeur `Finalize` est une méthode protégée qui ne peut être appelée qu'à partir de la classe à laquelle elle appartient ou de classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-135">The `Finalize` destructor is a protected method that can be called only from the class it belongs to, or from derived classes.</span></span> <span data-ttu-id="0dc9f-136">Étant donné que le système appelle `Finalize` automatiquement quand un objet est détruit, il n’est pas conseillé d’appeler `Finalize` explicitement en dehors de l’implémentation de `Finalize` d’une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-136">The system calls `Finalize` automatically when an object is destroyed, so you should not explicitly call `Finalize` from outside of a derived class's `Finalize` implementation.</span></span>

<span data-ttu-id="0dc9f-137">Contrairement à `Class_Terminate`, qui s'exécute dès qu'un objet a la valeur nothing, il s'écoule généralement un certain laps de temps entre le moment où un objet est hors de portée et le moment où Visual Basic appelle le destructeur `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-137">Unlike `Class_Terminate`, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the `Finalize` destructor.</span></span> <span data-ttu-id="0dc9f-138">Visual Basic .NET autorise un deuxième type de destructeur, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> , qui peut être appelé explicitement à tout moment pour libérer immédiatement des ressources.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-138">Visual Basic .NET allows for a second kind of destructor, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>, which can be explicitly called at any time to immediately release resources.</span></span>

> [!NOTE]
> <span data-ttu-id="0dc9f-139">Un destructeur `Finalize` ne doit pas lever d'exceptions, car elles ne peuvent pas être gérées par l'application et peuvent provoquer l'arrêt de l'application.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-139">A `Finalize` destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.</span></span>

### <a name="how-new-and-finalize-methods-work-in-a-class-hierarchy"></a><span data-ttu-id="0dc9f-140">Fonctionnement des méthodes New et Finalize dans une hiérarchie de classes</span><span class="sxs-lookup"><span data-stu-id="0dc9f-140">How New and Finalize Methods Work in a Class Hierarchy</span></span>

<span data-ttu-id="0dc9f-141">Chaque fois qu'une instance de classe est créée, le CLR (Common Language Runtime) tente d'exécuter une procédure nommée `New`, si elle existe dans cet objet.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-141">Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named `New`, if it exists in that object.</span></span> <span data-ttu-id="0dc9f-142">`New` est un type de procédure appelée `constructor` qui sert à initialiser les nouveaux objets avant l'exécution de tout autre code contenu dans un objet.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-142">`New` is a type of procedure called a `constructor` that is used to initialize new objects before any other code in an object executes.</span></span> <span data-ttu-id="0dc9f-143">Un constructeur `New` permet d'ouvrir des fichiers, de se connecter à des bases de données, d'initialiser des variables et de gérer d'autres tâches à effectuer préalablement à l'utilisation d'un objet.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-143">A `New` constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used.</span></span>

<span data-ttu-id="0dc9f-144">Quand une instance de classe dérivée est créée, le constructeur `Sub New` de la classe de base s'exécute en premier, suivie des constructeurs des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-144">When an instance of a derived class is created, the `Sub New` constructor of the base class executes first, followed by constructors in derived classes.</span></span> <span data-ttu-id="0dc9f-145">Cela s'explique par le fait que la première ligne de code d'un constructeur `Sub New` utilise la syntaxe `MyBase.New()` pour appeler le constructeur de la classe qui le précède immédiatement dans la hiérarchie de classes.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-145">This happens because the first line of code in a `Sub New` constructor uses the syntax `MyBase.New()`to call the constructor of the class immediately above itself in the class hierarchy.</span></span> <span data-ttu-id="0dc9f-146">Le constructeur `Sub New` est ensuite appelé pour chaque classe de la hiérarchie de classes jusqu'à ce que le constructeur de la classe de base ait été atteint.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-146">The `Sub New` constructor is then called for each class in the class hierarchy until the constructor for the base class is reached.</span></span> <span data-ttu-id="0dc9f-147">À ce stade, le code contenu dans le constructeur de la classe de base s'exécute, suivi du code contenu dans chaque constructeur de toutes les classes dérivées, tandis que le code contenu dans les classes les plus dérivées est exécuté en dernier.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-147">At that point, the code in the constructor for the base class executes, followed by the code in each constructor in all derived classes and the code in the most derived classes is executed last.</span></span>

![Capture d’écran montrant les constructeurs et l’héritage de la hiérarchie de classes.](./media/object-lifetime-how-objects-are-created-and-destroyed/subnew-constructor-inheritance.gif)

<span data-ttu-id="0dc9f-149">Quand un objet n'est plus utile, le CLR appelle la méthode <xref:System.Object.Finalize%2A> pour cet objet avant de libérer sa mémoire.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-149">When an object is no longer needed, the CLR calls the <xref:System.Object.Finalize%2A> method for that object before freeing its memory.</span></span> <span data-ttu-id="0dc9f-150">La méthode <xref:System.Object.Finalize%2A> est appelée `destructor`, car elle effectue des tâches de nettoyage, comme l’enregistrement des informations d’état, la fermeture des fichiers et des connexions aux bases de données, ainsi que les autres tâches à effectuer avant de libérer l’objet.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-150">The <xref:System.Object.Finalize%2A> method is called a `destructor` because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object.</span></span>

![Capture d’écran montrant le destructeur de méthode Finalize.](./media/object-lifetime-how-objects-are-created-and-destroyed/finalize-method-destructor.gif)

## <a name="idisposable-interface"></a><span data-ttu-id="0dc9f-152">Interface IDisposable</span><span class="sxs-lookup"><span data-stu-id="0dc9f-152">IDisposable Interface</span></span>

<span data-ttu-id="0dc9f-153">Les instances de classe contrôlent souvent les ressources non gérées par le CLR, comme les handles Windows et les connexions de base de données.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-153">Class instances often control resources not managed by the CLR, such as Windows handles and database connections.</span></span> <span data-ttu-id="0dc9f-154">Ces ressources doivent être supprimées dans la méthode `Finalize` de la classe, afin qu'elles soient libérées au moment où l'objet est détruit par le récupérateur de mémoire.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-154">These resources must be disposed of in the `Finalize` method of the class, so that they will be released when the object is destroyed by the garbage collector.</span></span> <span data-ttu-id="0dc9f-155">Cependant, celui-ci ne détruit les objets qu’à partir du moment où le CLR a besoin de mémoire supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-155">However, the garbage collector destroys objects only when the CLR requires more free memory.</span></span> <span data-ttu-id="0dc9f-156">Autrement dit, la libération des ressources peut prendre un certain temps après que l'objet est hors de portée.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-156">This means that the resources may not be released until long after the object goes out of scope.</span></span>

<span data-ttu-id="0dc9f-157">Pour compléter l'action du récupérateur de mémoire, vos classes peuvent fournir un mécanisme de gestion active des ressources système si elles implémentent l'interface <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-157">To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="0dc9f-158"><xref:System.IDisposable> dispose d'une méthode, <xref:System.IDisposable.Dispose%2A>, que les clients doivent appeler quand ils cessent d'utiliser un objet.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-158"><xref:System.IDisposable> has one method, <xref:System.IDisposable.Dispose%2A>, which clients should call when they finish using an object.</span></span> <span data-ttu-id="0dc9f-159">Vous pouvez utiliser la méthode <xref:System.IDisposable.Dispose%2A> pour libérer immédiatement des ressources et effectuer certaines tâches, comme la fermeture des fichiers et des connexions de base de données.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-159">You can use the <xref:System.IDisposable.Dispose%2A> method to immediately release resources and perform tasks such as closing files and database connections.</span></span> <span data-ttu-id="0dc9f-160">Contrairement au destructeur `Finalize`, la méthode <xref:System.IDisposable.Dispose%2A> n'est pas appelée automatiquement.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-160">Unlike the `Finalize` destructor, the <xref:System.IDisposable.Dispose%2A> method is not called automatically.</span></span> <span data-ttu-id="0dc9f-161">Les clients d’une classe doivent appeler <xref:System.IDisposable.Dispose%2A> explicitement quand vous voulez libérer immédiatement des ressources.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-161">Clients of a class must explicitly call <xref:System.IDisposable.Dispose%2A> when you want to immediately release resources.</span></span>

### <a name="implementing-idisposable"></a><span data-ttu-id="0dc9f-162">Implémentation de IDisposable</span><span class="sxs-lookup"><span data-stu-id="0dc9f-162">Implementing IDisposable</span></span>

<span data-ttu-id="0dc9f-163">Une classe qui implémente l'interface <xref:System.IDisposable> doit inclure les sections de code suivantes :</span><span class="sxs-lookup"><span data-stu-id="0dc9f-163">A class that implements the <xref:System.IDisposable> interface should include these sections of code:</span></span>

- <span data-ttu-id="0dc9f-164">Un champ de suivi permettant de déterminer si l'objet a été supprimé :</span><span class="sxs-lookup"><span data-stu-id="0dc9f-164">A field for keeping track of whether the object has been disposed:</span></span>

  ```vb
  Protected disposed As Boolean = False
  ```

- <span data-ttu-id="0dc9f-165">Une surcharge de la méthode <xref:System.IDisposable.Dispose%2A> qui libère les ressources de la classe.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-165">An overload of the <xref:System.IDisposable.Dispose%2A> that frees the class's resources.</span></span> <span data-ttu-id="0dc9f-166">Cette méthode doit être appelée par les méthodes <xref:System.IDisposable.Dispose%2A> et `Finalize` de la classe de base :</span><span class="sxs-lookup"><span data-stu-id="0dc9f-166">This method should be called by the <xref:System.IDisposable.Dispose%2A> and `Finalize` methods of the base class:</span></span>

  ```vb
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
          If disposing Then
              ' Insert code to free managed resources.
          End If
          ' Insert code to free unmanaged resources.
      End If
      Me.disposed = True
  End Sub
  ```

- <span data-ttu-id="0dc9f-167">Une implémentation de <xref:System.IDisposable.Dispose%2A> qui contient uniquement le code suivant :</span><span class="sxs-lookup"><span data-stu-id="0dc9f-167">An implementation of <xref:System.IDisposable.Dispose%2A> that contains only the following code:</span></span>

  ```vb
  Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
  End Sub
  ```

- <span data-ttu-id="0dc9f-168">Une substitution de la méthode `Finalize` qui contient uniquement le code suivant :</span><span class="sxs-lookup"><span data-stu-id="0dc9f-168">An override of the `Finalize` method that contains only the following code:</span></span>

  ```vb
  Protected Overrides Sub Finalize()
      Dispose(False)
      MyBase.Finalize()
  End Sub
  ```

### <a name="deriving-from-a-class-that-implements-idisposable"></a><span data-ttu-id="0dc9f-169">Dérivation d'une classe qui implémente IDisposable</span><span class="sxs-lookup"><span data-stu-id="0dc9f-169">Deriving from a Class that Implements IDisposable</span></span>

<span data-ttu-id="0dc9f-170">Une classe dérivée d'une classe de base qui implémente l'interface <xref:System.IDisposable> n'a pas besoin de substituer les méthodes de base à moins qu'elle utilise des ressources supplémentaires dont la suppression s'avère nécessaire.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-170">A class that derives from a base class that implements the <xref:System.IDisposable> interface does not need to override any of the base methods unless it uses additional resources that need to be disposed.</span></span> <span data-ttu-id="0dc9f-171">Dans ce cas, la classe dérivée doit substituer la méthode `Dispose(disposing)` de la classe de base pour supprimer les ressources de la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-171">In that situation, the derived class should override the base class's `Dispose(disposing)` method to dispose of the derived class's resources.</span></span> <span data-ttu-id="0dc9f-172">Cette substitution doit appeler la méthode `Dispose(disposing)` de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-172">This override must call the base class's `Dispose(disposing)` method.</span></span>

```vb
Protected Overrides Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
        If disposing Then
            ' Insert code to free managed resources.
        End If
        ' Insert code to free unmanaged resources.
    End If
    MyBase.Dispose(disposing)
End Sub
```

<span data-ttu-id="0dc9f-173">Une classe dérivée ne doit pas substituer les méthodes <xref:System.IDisposable.Dispose%2A> et `Finalize` de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-173">A derived class should not override the base class's <xref:System.IDisposable.Dispose%2A> and `Finalize` methods.</span></span> <span data-ttu-id="0dc9f-174">Quand ces méthodes sont appelées à partir d'une instance de la classe dérivée, l'implémentation de ces méthodes au niveau de la classe de base appelle la substitution de la méthode `Dispose(disposing)` de la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-174">When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the `Dispose(disposing)` method.</span></span>

## <a name="garbage-collection-and-the-finalize-destructor"></a><span data-ttu-id="0dc9f-175">Garbage collection et destructeur Finalize</span><span class="sxs-lookup"><span data-stu-id="0dc9f-175">Garbage Collection and the Finalize Destructor</span></span>

<span data-ttu-id="0dc9f-176">Le .NET Framework utilise le système de *garbage collection de suivi des références* pour libérer périodiquement les ressources inutilisées.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-176">The .NET Framework uses the *reference-tracing garbage collection* system to periodically release unused resources.</span></span> <span data-ttu-id="0dc9f-177">Visual Basic 6,0 et les versions antérieures utilisaient un système différent appelé *décompte de références* pour gérer les ressources.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-177">Visual Basic 6.0 and earlier versions used a different system called *reference counting* to manage resources.</span></span> <span data-ttu-id="0dc9f-178">Même si les deux systèmes remplissent la même fonction automatiquement, des différences importantes existent entre les deux.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-178">Although both systems perform the same function automatically, there are a few important differences.</span></span>

<span data-ttu-id="0dc9f-179">Le CLR détruit périodiquement des objets quand le système considère qu’ils ne sont plus nécessaires.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-179">The CLR periodically destroys objects when the system determines that such objects are no longer needed.</span></span> <span data-ttu-id="0dc9f-180">Les objets sont libérés plus rapidement quand les ressources système viennent à manquer et moins souvent dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-180">Objects are released more quickly when system resources are in short supply, and less frequently otherwise.</span></span> <span data-ttu-id="0dc9f-181">Compte tenu du décalage qui existe entre le moment où un objet est hors de portée et le moment où le CLR le libère, contrairement aux objets dans Visual Basic 6.0 et les versions antérieures, il est impossible de déterminer exactement à quel moment l'objet sera détruit.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-181">The delay between when an object loses scope and when the CLR releases it means that, unlike with objects in Visual Basic 6.0 and earlier versions, you cannot determine exactly when the object will be destroyed.</span></span> <span data-ttu-id="0dc9f-182">Dans ce cas, les objets sont considérés comme ayant une *durée de vie non déterministe*.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-182">In such a situation, objects are said to have *non-deterministic lifetime*.</span></span> <span data-ttu-id="0dc9f-183">Dans la plupart des cas, la durée de vie non déterministe ne change pas la façon dont vous écrivez les applications, à condition de ne pas perdre de vue que le destructeur `Finalize` ne peut pas s'exécuter immédiatement à partir du moment où un objet est hors de portée.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-183">In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the `Finalize` destructor may not immediately execute when an object loses scope.</span></span>

<span data-ttu-id="0dc9f-184">Les systèmes de garbage collection se distinguent aussi en ce qui concerne l’utilisation de `Nothing`.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-184">Another difference between the garbage-collection systems involves the use of `Nothing`.</span></span> <span data-ttu-id="0dc9f-185">Pour tirer parti du comptage de références dans Visual Basic 6.0 et les versions antérieures, les programmeurs attribuaient parfois aux variables objets la valeur `Nothing` pour libérer les références contenues dans ces variables.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-185">To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned `Nothing` to object variables to release the references those variables held.</span></span> <span data-ttu-id="0dc9f-186">Si la variable contenait la dernière référence à l’objet, les ressources de l’objet étaient libérées immédiatement.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-186">If the variable held the last reference to the object, the object's resources were released immediately.</span></span> <span data-ttu-id="0dc9f-187">Dans les versions ultérieures de Visual Basic, même si dans certains cas cette procédure est toujours utile, son exécution ne conduit jamais l’objet référencé à libérer immédiatement ses ressources.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-187">In later versions of Visual Basic, while there may be cases in which this procedure is still valuable, performing it never causes the referenced object to release its resources immediately.</span></span> <span data-ttu-id="0dc9f-188">Pour libérer immédiatement des ressources, utilisez la méthode <xref:System.IDisposable.Dispose%2A> de l’objet, si elle est disponible.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-188">To release resources immediately, use the object's <xref:System.IDisposable.Dispose%2A> method, if available.</span></span> <span data-ttu-id="0dc9f-189">Le seul cas où vous devez affecter la valeur `Nothing` à une variable est quand sa durée de vie est plus longue que le temps dont a besoin le récupérateur de mémoire pour détecter les objets orphelins.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-189">The only time you should set a variable to `Nothing` is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="0dc9f-190">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="0dc9f-190">See also</span></span>

- <xref:System.IDisposable.Dispose%2A>
- <span data-ttu-id="0dc9f-191">[Initialisation et suppression des composants](/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span><span class="sxs-lookup"><span data-stu-id="0dc9f-191">[Initialization and Termination of Components](/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span></span>
- [<span data-ttu-id="0dc9f-192">Nouvel opérateur</span><span class="sxs-lookup"><span data-stu-id="0dc9f-192">New Operator</span></span>](../../../language-reference/operators/new-operator.md)
- [<span data-ttu-id="0dc9f-193">Nettoyage des ressources non managées</span><span class="sxs-lookup"><span data-stu-id="0dc9f-193">Cleaning Up Unmanaged Resources</span></span>](../../../../standard/garbage-collection/unmanaged.md)
- [<span data-ttu-id="0dc9f-194">Nothing</span><span class="sxs-lookup"><span data-stu-id="0dc9f-194">Nothing</span></span>](../../../language-reference/nothing.md)
