---
title: Collecter les diagnostics dans les conteneurs
description: Dans cet article, vous allez découvrir comment utiliser les outils de diagnostic de .NET Core dans les conteneurs de l’ancrage.
ms.date: 09/01/2020
ms.openlocfilehash: cf4bbdf75e943f093a2202f91303a2eea7125487
ms.sourcegitcommit: 5114e7847e0ff8ddb8c266802d47af78567949cf
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/19/2020
ms.locfileid: "94916207"
---
# <a name="collect-diagnostics-in-containers"></a><span data-ttu-id="b6363-103">Collecter les diagnostics dans les conteneurs</span><span class="sxs-lookup"><span data-stu-id="b6363-103">Collect diagnostics in containers</span></span>

<span data-ttu-id="b6363-104">Les mêmes outils de diagnostic qui sont utiles pour diagnostiquer les problèmes de .NET Core dans d’autres scénarios fonctionnent également dans les conteneurs de l’ancrage.</span><span class="sxs-lookup"><span data-stu-id="b6363-104">The same diagnostics tools that are useful for diagnosing .NET Core issues in other scenarios also work in Docker containers.</span></span> <span data-ttu-id="b6363-105">Toutefois, certains des outils requièrent des étapes spéciales pour travailler dans un conteneur.</span><span class="sxs-lookup"><span data-stu-id="b6363-105">However, some of the tools require special steps to work in a container.</span></span> <span data-ttu-id="b6363-106">Cet article explique comment utiliser les outils pour rassembler des traces de performances et collecter des vidages dans des conteneurs dockers.</span><span class="sxs-lookup"><span data-stu-id="b6363-106">This article covers how tools for gathering performance traces and collecting dumps can be used in Docker containers.</span></span>

## <a name="using-net-core-cli-tools-in-a-container"></a><span data-ttu-id="b6363-107">Utilisation d’outils de CLI .NET Core dans un conteneur</span><span class="sxs-lookup"><span data-stu-id="b6363-107">Using .NET Core CLI tools in a container</span></span>

<span data-ttu-id="b6363-108">**Ces outils s’appliquent à : ✔️ Kit de** développement logiciel (SDK) .net Core 3,0 et versions ultérieures</span><span class="sxs-lookup"><span data-stu-id="b6363-108">**These tools apply to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="b6363-109">Les outils de diagnostic globaux de l’interface CLI .net Core ( [`dotnet-counters`](dotnet-counters.md) , [`dotnet-dump`](dotnet-dump.md) , [`dotnet-gcdump`](dotnet-gcdump.md) et [`dotnet-trace`](dotnet-trace.md) ) sont conçus pour fonctionner dans un large éventail d’environnements et doivent tous fonctionner directement dans les conteneurs de l’ancrage.</span><span class="sxs-lookup"><span data-stu-id="b6363-109">The .NET Core global CLI diagnostic tools ([`dotnet-counters`](dotnet-counters.md), [`dotnet-dump`](dotnet-dump.md), [`dotnet-gcdump`](dotnet-gcdump.md), and [`dotnet-trace`](dotnet-trace.md)) are designed to work in a wide variety of environments and should all work directly in Docker containers.</span></span> <span data-ttu-id="b6363-110">Pour cette raison, ces outils sont la méthode recommandée pour collecter des informations de diagnostic pour les scénarios .NET Core ciblant .NET Core 3,0 ou une version ultérieure (ou 3,1 ou version ultérieure dans le cas de `dotnet-gcdump` ) dans des conteneurs.</span><span class="sxs-lookup"><span data-stu-id="b6363-110">Because of this, these tools are the preferred method of collecting diagnostic information for .NET Core scenarios targeting .NET Core 3.0 or above (or 3.1 or above in the case of `dotnet-gcdump`) in containers.</span></span>

<span data-ttu-id="b6363-111">Le seul facteur de compliquation de l’utilisation de ces outils dans un conteneur est qu’ils sont installés avec le kit SDK .NET Core et que de nombreux conteneurs de l’arrimeur s’exécutent sans l’kit SDK .NET Core présent.</span><span class="sxs-lookup"><span data-stu-id="b6363-111">The only complicating factor of using these tools in a container is that they are installed with the .NET Core SDK and many Docker containers run without the .NET Core SDK present.</span></span> <span data-ttu-id="b6363-112">Une solution simple à ce problème consiste à installer les outils dans l’image initiale de l’ancrage.</span><span class="sxs-lookup"><span data-stu-id="b6363-112">One easy solution to this problem is to install the tools in the initial Docker image.</span></span> <span data-ttu-id="b6363-113">Les outils n’ont pas besoin de l’kit SDK .NET Core pour être exécutés, mais uniquement pour être installés.</span><span class="sxs-lookup"><span data-stu-id="b6363-113">The tools don't need the .NET Core SDK to run, only to be installed.</span></span> <span data-ttu-id="b6363-114">Par conséquent, il est possible de créer un fichier dockerfile avec une [Build à plusieurs étapes](https://docs.docker.com/develop/develop-images/multistage-build/) qui installe les outils dans une étape de génération (où le kit SDK .net Core est présent), puis copie les fichiers binaires dans l’image finale.</span><span class="sxs-lookup"><span data-stu-id="b6363-114">Therefore, it's possible to create a Dockerfile with a [multi-stage build](https://docs.docker.com/develop/develop-images/multistage-build/) that installs the tools in a build stage (where the .NET Core SDK is present) and then copies the binaries into the final image.</span></span> <span data-ttu-id="b6363-115">Le seul inconvénient de cette approche est l’augmentation de la taille de l’image de l’ancrage.</span><span class="sxs-lookup"><span data-stu-id="b6363-115">The only downside to this approach is increased Docker image size.</span></span>

```dockerfile
# In build stage
# Install desired .NET CLI diagnostics tools
RUN dotnet tool install --tool-path /tools dotnet-trace
RUN dotnet tool install --tool-path /tools dotnet-counters
RUN dotnet tool install --tool-path /tools dotnet-dump

...

# In final stage
# Copy diagnostics tools
WORKDIR /tools
COPY --from=build /tools .
```

<span data-ttu-id="b6363-116">Vous pouvez également installer le kit SDK .NET Core dans un conteneur si nécessaire pour installer les outils CLI.</span><span class="sxs-lookup"><span data-stu-id="b6363-116">Alternatively, the .NET Core SDK can be installed in a container when needed in order to install the CLI tools.</span></span> <span data-ttu-id="b6363-117">N’oubliez pas que l’installation du kit SDK .NET Core aura l’effet secondaire de réinstaller le Runtime .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b6363-117">Be aware that installing the .NET Core SDK will have the side-effect of reinstalling the .NET Core runtime.</span></span> <span data-ttu-id="b6363-118">Veillez donc à installer la version du kit de développement logiciel (SDK) qui correspond au runtime présent dans le conteneur.</span><span class="sxs-lookup"><span data-stu-id="b6363-118">So be sure to install the version of the SDK that matches the runtime present in the container.</span></span>

### <a name="using-net-core-global-cli-tools-in-a-sidecar-container"></a><span data-ttu-id="b6363-119">Utilisation des outils CLI globaux .NET Core dans un conteneur side-car</span><span class="sxs-lookup"><span data-stu-id="b6363-119">Using .NET Core global CLI tools in a sidecar container</span></span>

<span data-ttu-id="b6363-120">Si vous souhaitez utiliser les outils de diagnostic de l’interface CLI .NET Core globaux pour diagnostiquer les processus dans un autre conteneur, vous devez tenir compte des conditions supplémentaires suivantes :</span><span class="sxs-lookup"><span data-stu-id="b6363-120">If you would like to use .NET Core global CLI diagnostic tools to diagnose processes in a different container, bear the following additional requirements in mind:</span></span>

1. <span data-ttu-id="b6363-121">Les conteneurs doivent [partager un espace de noms de processus](https://docs.docker.com/engine/reference/run/#pid-settings---pid) (afin que les outils dans le conteneur side-car puissent accéder aux processus dans le conteneur cible).</span><span class="sxs-lookup"><span data-stu-id="b6363-121">The containers must [share a process namespace](https://docs.docker.com/engine/reference/run/#pid-settings---pid) (so that tools in the sidecar container can access processes in the target container).</span></span>
2. <span data-ttu-id="b6363-122">Les outils de diagnostic de l’interface CLI .NET Core doivent accéder aux fichiers que le Runtime .NET Core écrit dans le répertoire/tmp, de sorte que le répertoire/tmp doit être partagé entre le conteneur cible et le conteneur side-car via un montage de volume.</span><span class="sxs-lookup"><span data-stu-id="b6363-122">The .NET Core global CLI diagnostic tools need access to files the .NET Core runtime writes to the /tmp directory, so the /tmp directory must be shared between the target and sidecar container via a volume mount.</span></span> <span data-ttu-id="b6363-123">Cela peut être fait, par exemple, en faisant en sorte que les conteneurs partagent un [volume commun ou un volume Kubernetes](https://docs.docker.com/storage/volumes/#create-and-manage-volumes) [emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) .</span><span class="sxs-lookup"><span data-stu-id="b6363-123">This could be done, for example, by having the containers share a common [volume](https://docs.docker.com/storage/volumes/#create-and-manage-volumes) or a Kubernetes [emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) volume.</span></span> <span data-ttu-id="b6363-124">Si vous tentez d’utiliser les outils de diagnostic à partir d’un conteneur side-car sans partager le répertoire/tmp, vous obtiendrez une erreur concernant le processus « pas en cours d’exécution du Runtime .NET compatible ».</span><span class="sxs-lookup"><span data-stu-id="b6363-124">If you attempt to use the diagnostic tools from a sidecar container without sharing the /tmp directory, you will get an error about the process "not running compatible .NET runtime."</span></span>

## <a name="using-perfcollect-in-a-container"></a><span data-ttu-id="b6363-125">Utilisation `PerfCollect` dans un conteneur</span><span class="sxs-lookup"><span data-stu-id="b6363-125">Using `PerfCollect` in a container</span></span>

<span data-ttu-id="b6363-126">**Cet outil s’applique à : ✔️** .net Core 2,1 et versions ultérieures</span><span class="sxs-lookup"><span data-stu-id="b6363-126">**This tool applies to: ✔️** .NET Core 2.1 and later versions</span></span>

<span data-ttu-id="b6363-127">Le [`PerfCollect`](./trace-perfcollect-lttng.md) script est utile pour la collecte des traces de performances et est l’outil recommandé pour la collecte des traces avant .net Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="b6363-127">The [`PerfCollect`](./trace-perfcollect-lttng.md) script is useful for collecting performance traces and is the recommended tool for collecting traces prior to .NET Core 3.0.</span></span> <span data-ttu-id="b6363-128">Si vous utilisez `PerfCollect` dans un conteneur, gardez à l’esprit les exigences suivantes :</span><span class="sxs-lookup"><span data-stu-id="b6363-128">If using `PerfCollect` in a container, keep the following requirements in mind:</span></span>

1. <span data-ttu-id="b6363-129">`PerfCollect`nécessite la [ `SYS_ADMIN` fonctionnalité](https://man7.org/linux/man-pages/man7/capabilities.7.html) (pour exécuter l' `perf` outil), assurez-vous que le conteneur est [démarré avec cette fonctionnalité](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).</span><span class="sxs-lookup"><span data-stu-id="b6363-129">`PerfCollect` requires the [`SYS_ADMIN` capability](https://man7.org/linux/man-pages/man7/capabilities.7.html) (in order to run the `perf` tool), so be sure the container is [started with that capability](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).</span></span>
2. <span data-ttu-id="b6363-130">`PerfCollect` certaines variables d’environnement doivent être définies avant le profilage de l’application.</span><span class="sxs-lookup"><span data-stu-id="b6363-130">`PerfCollect` requires some environment variables be set prior to the app it is profiling starting.</span></span> <span data-ttu-id="b6363-131">Ils peuvent être définis dans un [fichier dockerfile](https://docs.docker.com/engine/reference/builder/#env) ou lors [du démarrage du conteneur](https://docs.docker.com/engine/reference/run/#env-environment-variables).</span><span class="sxs-lookup"><span data-stu-id="b6363-131">These can be set either in a [Dockerfile](https://docs.docker.com/engine/reference/builder/#env) or when [starting the container](https://docs.docker.com/engine/reference/run/#env-environment-variables).</span></span> <span data-ttu-id="b6363-132">Étant donné que ces variables ne doivent pas être définies dans des environnements de production normaux, il est courant de les ajouter simplement au démarrage d’un conteneur qui sera profilé.</span><span class="sxs-lookup"><span data-stu-id="b6363-132">Because these variables shouldn't be set in normal production environments, it's common to just add them when starting a container that will be profiled.</span></span> <span data-ttu-id="b6363-133">Les deux variables requises par PerfCollect sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="b6363-133">The two variables which PerfCollect requires are:</span></span>
    1. <span data-ttu-id="b6363-134">COMPlus_PerfMapEnabled = 1</span><span class="sxs-lookup"><span data-stu-id="b6363-134">COMPlus_PerfMapEnabled=1</span></span>
    1. <span data-ttu-id="b6363-135">COMPlus_EnableEventLog = 1</span><span class="sxs-lookup"><span data-stu-id="b6363-135">COMPlus_EnableEventLog=1</span></span>

### <a name="using-perfcollect-in-a-sidecar-container"></a><span data-ttu-id="b6363-136">Utilisation `PerfCollect` dans un conteneur side-car</span><span class="sxs-lookup"><span data-stu-id="b6363-136">Using `PerfCollect` in a sidecar container</span></span>

<span data-ttu-id="b6363-137">Si vous souhaitez exécuter `PerfCollect` dans un conteneur pour profiler un processus .net core dans un autre conteneur, l’expérience est presque la même, à l’exception de ces différences :</span><span class="sxs-lookup"><span data-stu-id="b6363-137">If you would like to run `PerfCollect` in one container to profile a .NET Core process in a different container, the experience is almost the same except for these differences:</span></span>

1. <span data-ttu-id="b6363-138">Les variables d’environnement mentionnées précédemment (COMPlus_PerfMapEnabled et COMPlus_EnableEventLog) doivent être définies pour le conteneur cible (pas celle en cours d’exécution `PerfCollect` ).</span><span class="sxs-lookup"><span data-stu-id="b6363-138">The environment variables mentioned previously (COMPlus_PerfMapEnabled and COMPlus_EnableEventLog) must be set for the target container (not the one running `PerfCollect`).</span></span>
2. <span data-ttu-id="b6363-139">Le conteneur en cours d’exécution `PerfCollect` doit avoir la `SYS_ADMIN` capacité (et non le conteneur cible).</span><span class="sxs-lookup"><span data-stu-id="b6363-139">The container running `PerfCollect` must have the `SYS_ADMIN` capability (not the target container).</span></span>
3. <span data-ttu-id="b6363-140">Les deux conteneurs doivent [partager un espace de noms de processus](https://docs.docker.com/engine/reference/run/#pid-settings---pid).</span><span class="sxs-lookup"><span data-stu-id="b6363-140">The two containers must [share a process namespace](https://docs.docker.com/engine/reference/run/#pid-settings---pid).</span></span>

## <a name="using-createdump-in-a-container"></a><span data-ttu-id="b6363-141">Utilisation `createdump` dans un conteneur</span><span class="sxs-lookup"><span data-stu-id="b6363-141">Using `createdump` in a container</span></span>

<span data-ttu-id="b6363-142">**Cet outil s’applique à : ✔️** .net Core 2,1 et versions ultérieures</span><span class="sxs-lookup"><span data-stu-id="b6363-142">**This tool applies to: ✔️** .NET Core 2.1 and later versions</span></span>

<span data-ttu-id="b6363-143">Une alternative à `dotnet-dump` , [`createdump`](https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/xplat-minidump-generation.md) peut être utilisée pour créer des vidages principaux sur Linux contenant des informations natives et gérées.</span><span class="sxs-lookup"><span data-stu-id="b6363-143">An alternative to `dotnet-dump`, [`createdump`](https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/xplat-minidump-generation.md) can be used for creating core dumps on Linux containing both native and managed information.</span></span> <span data-ttu-id="b6363-144">L' `createdump` outil est installé avec le Runtime .net Core et se trouve en regard de libcoreclr.so (généralement dans « /usr/share/dotnet/Shared/Microsoft.NETCore.app/[version] »).</span><span class="sxs-lookup"><span data-stu-id="b6363-144">The `createdump` tool is installed with the .NET Core runtime and can be found next to libcoreclr.so (typically in "/usr/share/dotnet/shared/Microsoft.NETCore.App/[version]").</span></span> <span data-ttu-id="b6363-145">L’outil fonctionne de la même manière dans un conteneur que dans les environnements Linux non conteneurs, à l’exception près que l’outil requiert la [ `SYS_PTRACE` fonctionnalité](https://man7.org/linux/man-pages/man7/capabilities.7.html), de sorte que le conteneur de la station d’accueil doit être [démarré avec cette fonctionnalité](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).</span><span class="sxs-lookup"><span data-stu-id="b6363-145">The tool works the same in a container as it does in non-containerized Linux environments with the single exception that the tool requires the [`SYS_PTRACE` capability](https://man7.org/linux/man-pages/man7/capabilities.7.html), so the Docker container must be [started with that capability](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).</span></span>

### <a name="using-createdump-in-a-sidecar-container"></a><span data-ttu-id="b6363-146">Utilisation `createdump` dans un conteneur side-car</span><span class="sxs-lookup"><span data-stu-id="b6363-146">Using `createdump` in a sidecar container</span></span>

<span data-ttu-id="b6363-147">Si vous souhaitez utiliser `createdump` pour créer un vidage à partir d’un processus dans un autre conteneur, l’expérience est presque la même, à l’exception de ces différences :</span><span class="sxs-lookup"><span data-stu-id="b6363-147">If you would like to use `createdump` to create a dump from a process in a different container, the experience is almost the same except for these differences:</span></span>

1. <span data-ttu-id="b6363-148">Le conteneur en cours d’exécution `createdump` doit avoir la `SYS_PTRACE` capacité (et non le conteneur cible).</span><span class="sxs-lookup"><span data-stu-id="b6363-148">The container running `createdump` must have the `SYS_PTRACE` capability (not the target container).</span></span>
2. <span data-ttu-id="b6363-149">Les deux conteneurs doivent [partager un espace de noms de processus](https://docs.docker.com/engine/reference/run/#pid-settings---pid).</span><span class="sxs-lookup"><span data-stu-id="b6363-149">The two containers must [share a process namespace](https://docs.docker.com/engine/reference/run/#pid-settings---pid).</span></span>
