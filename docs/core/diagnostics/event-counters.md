---
title: EventCounters dans .NET Core
description: Dans cet article, vous allez découvrir les EventCounters, comment les implémenter et comment les utiliser.
ms.date: 08/07/2020
ms.openlocfilehash: 843f1ec645bf7f52fd4f85e30d183e6e21fee5c6
ms.sourcegitcommit: 78eb25647b0c750cd80354ebd6ce83a60668e22c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/29/2021
ms.locfileid: "99065062"
---
# <a name="eventcounters-in-net-core"></a><span data-ttu-id="bb42f-103">EventCounters dans .NET Core</span><span class="sxs-lookup"><span data-stu-id="bb42f-103">EventCounters in .NET Core</span></span>

<span data-ttu-id="bb42f-104">**Cet article s’applique à : ✔️ le kit de** développement logiciel (SDK) .net Core 3,0 et versions ultérieures</span><span class="sxs-lookup"><span data-stu-id="bb42f-104">**This article applies to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="bb42f-105">EventCounters sont des API .NET Core utilisées pour la collecte des métriques de performances légère, multiplateforme et quasiment en temps réel.</span><span class="sxs-lookup"><span data-stu-id="bb42f-105">EventCounters are .NET Core APIs used for lightweight, cross-platform, and near real-time performance metric collection.</span></span> <span data-ttu-id="bb42f-106">Les EventCounters ont été ajoutés comme une alternative multiplateforme aux « compteurs de performances » de l' .NET Framework sur Windows.</span><span class="sxs-lookup"><span data-stu-id="bb42f-106">EventCounters were added as a cross-platform alternative to the "performance counters" of the .NET Framework on Windows.</span></span> <span data-ttu-id="bb42f-107">Dans cet article, vous allez découvrir les EventCounters, comment les implémenter et comment les utiliser.</span><span class="sxs-lookup"><span data-stu-id="bb42f-107">In this article you'll learn what EventCounters are, how to implement them, and how to consume them.</span></span>

<span data-ttu-id="bb42f-108">Le Runtime .NET Core et quelques bibliothèques .NET publient des informations de diagnostic de base à l’aide de EventCounters à partir de .NET Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="bb42f-108">The .NET Core runtime and a few .NET libraries publish basic diagnostics information using EventCounters starting in .NET Core 3.0.</span></span> <span data-ttu-id="bb42f-109">Outre les EventCounters fournies par le Runtime .NET, vous pouvez choisir d’implémenter votre propre EventCounters.</span><span class="sxs-lookup"><span data-stu-id="bb42f-109">Apart from the EventCounters that are provided by the .NET runtime, you may choose to implement your own EventCounters.</span></span> <span data-ttu-id="bb42f-110">EventCounters peut être utilisé pour effectuer le suivi de diverses mesures.</span><span class="sxs-lookup"><span data-stu-id="bb42f-110">EventCounters can be used to track various metrics.</span></span> <span data-ttu-id="bb42f-111">En savoir plus à leur sujet dans le [EventCounters connu dans .net](available-counters.md)</span><span class="sxs-lookup"><span data-stu-id="bb42f-111">Learn more about them in the [well-known EventCounters in .NET](available-counters.md)</span></span>

<span data-ttu-id="bb42f-112">EventCounters en direct dans le cadre d’un <xref:System.Diagnostics.Tracing.EventSource> objet et sont automatiquement poussés vers les outils d’écouteur régulièrement.</span><span class="sxs-lookup"><span data-stu-id="bb42f-112">EventCounters live as a part of an <xref:System.Diagnostics.Tracing.EventSource>, and are automatically pushed to listener tools on a regular basis.</span></span> <span data-ttu-id="bb42f-113">Comme tous les autres événements sur un <xref:System.Diagnostics.Tracing.EventSource> , ils peuvent être utilisés à la fois en-proc et hors processus via <xref:System.Diagnostics.Tracing.EventListener> et [EventPipe](./eventpipe.md).</span><span class="sxs-lookup"><span data-stu-id="bb42f-113">Like all other events on an <xref:System.Diagnostics.Tracing.EventSource>, they can be consumed both in-proc and out-of-proc via <xref:System.Diagnostics.Tracing.EventListener> and [EventPipe](./eventpipe.md).</span></span> <span data-ttu-id="bb42f-114">Cet article se concentre sur les fonctionnalités inter-plateformes de EventCounters et exclut intentionnellement PerfView et ETW (Suivi d’v nements pour Windows), bien que les deux puissent être utilisés avec EventCounters.</span><span class="sxs-lookup"><span data-stu-id="bb42f-114">This article focuses on the cross-platform capabilities of EventCounters, and intentionally excludes PerfView and ETW (Event Tracing for Windows) - although both can be used with EventCounters.</span></span>

![Image de diagramme in-proc et out-of-proc EventCounters](media/event-counters.svg)

## <a name="eventcounter-api-overview"></a><span data-ttu-id="bb42f-116">Vue d’ensemble de l’API EventCounter</span><span class="sxs-lookup"><span data-stu-id="bb42f-116">EventCounter API overview</span></span>

<span data-ttu-id="bb42f-117">Il existe deux catégories principales de compteurs.</span><span class="sxs-lookup"><span data-stu-id="bb42f-117">There are two primary categories of counters.</span></span> <span data-ttu-id="bb42f-118">Certains compteurs correspondent aux valeurs « rate », telles que le nombre total d’exceptions, le nombre total de catalogues globaux et le nombre total de demandes.</span><span class="sxs-lookup"><span data-stu-id="bb42f-118">Some counters are for "rate" values, such as total number of exceptions, total number of GCs, and total number of requests.</span></span> <span data-ttu-id="bb42f-119">D’autres compteurs sont des valeurs « instantané », telles que l’utilisation du tas, l’utilisation du processeur et la taille de la plage de travail.</span><span class="sxs-lookup"><span data-stu-id="bb42f-119">Other counters are "snapshot" values, such as heap usage, CPU usage, and working set size.</span></span> <span data-ttu-id="bb42f-120">Dans chacune de ces catégories de compteurs, il existe deux types de compteurs qui varient en fonction de la façon dont ils obtiennent leur valeur.</span><span class="sxs-lookup"><span data-stu-id="bb42f-120">Within each of these categories of counters, there are two types of counters that vary by how they get their value.</span></span> <span data-ttu-id="bb42f-121">Les compteurs d’interrogation récupèrent leur valeur via un rappel, et les compteurs sans interrogation ont leurs valeurs directement définies sur l’instance de compteur.</span><span class="sxs-lookup"><span data-stu-id="bb42f-121">Polling counters retrieve their value via a callback, and non-polling counters have their values directly set on the counter instance.</span></span>

<span data-ttu-id="bb42f-122">Les compteurs sont représentés par les implémentations suivantes :</span><span class="sxs-lookup"><span data-stu-id="bb42f-122">The counters are represented by the following implementations:</span></span>

* <xref:System.Diagnostics.Tracing.EventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingEventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>
* <xref:System.Diagnostics.Tracing.PollingCounter>

<span data-ttu-id="bb42f-123">Un écouteur d’événements spécifie la durée des intervalles de mesure.</span><span class="sxs-lookup"><span data-stu-id="bb42f-123">An event listener specifies how long measurement intervals are.</span></span> <span data-ttu-id="bb42f-124">À la fin de chaque intervalle, une valeur est transmise à l’écouteur pour chaque compteur.</span><span class="sxs-lookup"><span data-stu-id="bb42f-124">At the end of each interval a value is transmitted to the listener for each counter.</span></span> <span data-ttu-id="bb42f-125">Les implémentations d’un compteur déterminent les API et les calculs utilisés pour produire la valeur chaque intervalle.</span><span class="sxs-lookup"><span data-stu-id="bb42f-125">The implementations of a counter determine what APIs and calculations are used to produce the value each interval.</span></span>

1. <span data-ttu-id="bb42f-126"><xref:System.Diagnostics.Tracing.EventCounter>Enregistre un ensemble de valeurs.</span><span class="sxs-lookup"><span data-stu-id="bb42f-126">The <xref:System.Diagnostics.Tracing.EventCounter> records a set of values.</span></span> <span data-ttu-id="bb42f-127">La <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> méthode ajoute une nouvelle valeur à l’ensemble.</span><span class="sxs-lookup"><span data-stu-id="bb42f-127">The <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> method adds a new value to the set.</span></span> <span data-ttu-id="bb42f-128">À chaque intervalle, un résumé statistique pour l’ensemble est calculé, par exemple, min, Max et Mean.</span><span class="sxs-lookup"><span data-stu-id="bb42f-128">With each interval, a statistical summary for the set is computed, such as the min, max, and mean.</span></span> <span data-ttu-id="bb42f-129">L’outil [dotnet-Counters](dotnet-counters.md) affiche toujours la valeur moyenne.</span><span class="sxs-lookup"><span data-stu-id="bb42f-129">The [dotnet-counters](dotnet-counters.md) tool will always display the mean value.</span></span> <span data-ttu-id="bb42f-130"><xref:System.Diagnostics.Tracing.EventCounter>Est utile pour décrire un ensemble discret d’opérations.</span><span class="sxs-lookup"><span data-stu-id="bb42f-130">The <xref:System.Diagnostics.Tracing.EventCounter> is useful to describe a discrete set of operations.</span></span> <span data-ttu-id="bb42f-131">L’utilisation courante peut inclure la surveillance de la taille moyenne en octets d’opérations d’e/s récentes ou la valeur monétaire moyenne d’un ensemble de transactions financières.</span><span class="sxs-lookup"><span data-stu-id="bb42f-131">Common usage may include monitoring the average size in bytes of recent IO operations, or the average monetary value of a set of financial transactions.</span></span>

1. <span data-ttu-id="bb42f-132"><xref:System.Diagnostics.Tracing.IncrementingEventCounter>Enregistre un total cumulé pour chaque intervalle de temps.</span><span class="sxs-lookup"><span data-stu-id="bb42f-132">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> records a running total for each time interval.</span></span> <span data-ttu-id="bb42f-133">La <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> méthode ajoute au total.</span><span class="sxs-lookup"><span data-stu-id="bb42f-133">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> method adds to the total.</span></span> <span data-ttu-id="bb42f-134">Par exemple, si `Increment()` est appelé trois fois dans un intervalle avec des valeurs `1` , `2` et, `5` le total cumulé de `8` est signalé comme valeur de compteur pour cet intervalle.</span><span class="sxs-lookup"><span data-stu-id="bb42f-134">For example, if `Increment()` is called three times during one interval with values `1`, `2`, and `5`, then the running total of `8` will be reported as the counter value for this interval.</span></span> <span data-ttu-id="bb42f-135">L’outil [dotnet-Counters](dotnet-counters.md) affiche le taux en tant que total/heure enregistré.</span><span class="sxs-lookup"><span data-stu-id="bb42f-135">The [dotnet-counters](dotnet-counters.md) tool will display the rate as the recorded total / time.</span></span> <span data-ttu-id="bb42f-136"><xref:System.Diagnostics.Tracing.IncrementingEventCounter>Est utile pour mesurer la fréquence d’exécution d’une action, comme le nombre de demandes traitées par seconde.</span><span class="sxs-lookup"><span data-stu-id="bb42f-136">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> is useful to measure how frequently an action is occurring, such as the number of requests processed per second.</span></span>

1. <span data-ttu-id="bb42f-137"><xref:System.Diagnostics.Tracing.PollingCounter>Utilise un rappel pour déterminer la valeur qui est signalée.</span><span class="sxs-lookup"><span data-stu-id="bb42f-137">The <xref:System.Diagnostics.Tracing.PollingCounter> uses a callback to determine the value that is reported.</span></span> <span data-ttu-id="bb42f-138">Avec chaque intervalle de temps, la fonction de rappel fournie par l’utilisateur est appelée et la valeur de retour est utilisée comme valeur de compteur.</span><span class="sxs-lookup"><span data-stu-id="bb42f-138">With each time interval, the user provided callback function is invoked and the return value is used as the counter value.</span></span> <span data-ttu-id="bb42f-139">Un <xref:System.Diagnostics.Tracing.PollingCounter> peut être utilisé pour interroger une mesure à partir d’une source externe, par exemple pour obtenir les octets libres actuels sur un disque.</span><span class="sxs-lookup"><span data-stu-id="bb42f-139">A <xref:System.Diagnostics.Tracing.PollingCounter> can be used to query a metric from an external source, for example getting the current free bytes on a disk.</span></span> <span data-ttu-id="bb42f-140">Il peut également être utilisé pour signaler des statistiques personnalisées qui peuvent être calculées à la demande par une application.</span><span class="sxs-lookup"><span data-stu-id="bb42f-140">It can also be used to report custom statistics that can be computed on demand by an application.</span></span> <span data-ttu-id="bb42f-141">Les exemples incluent la création de rapports sur le 95e centile des latences de demandes récentes ou le taux d’accès actuel ou d’échec d’un cache.</span><span class="sxs-lookup"><span data-stu-id="bb42f-141">Examples include reporting the 95th percentile of recent request latencies, or the current hit or miss ratio of a cache.</span></span>

1. <span data-ttu-id="bb42f-142"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter>Utilise un rappel pour déterminer la valeur d’incrément signalée.</span><span class="sxs-lookup"><span data-stu-id="bb42f-142">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses a callback to determine the reported increment value.</span></span> <span data-ttu-id="bb42f-143">Avec chaque intervalle de temps, le rappel est appelé, puis la différence entre l’appel en cours et le dernier appel est la valeur signalée.</span><span class="sxs-lookup"><span data-stu-id="bb42f-143">With each time interval, the callback is invoked, and then the difference between the current invocation, and the last invocation is the reported value.</span></span> <span data-ttu-id="bb42f-144">L’outil [dotnet-Counters](dotnet-counters.md) affiche toujours la différence comme une vitesse, la valeur/l’heure indiquée.</span><span class="sxs-lookup"><span data-stu-id="bb42f-144">The [dotnet-counters](dotnet-counters.md) tool will always display the difference as a rate, the reported value / time.</span></span> <span data-ttu-id="bb42f-145">Ce compteur est utile lorsqu’il n’est pas possible d’appeler une API sur chaque occurrence, mais qu’il est possible d’interroger le nombre total d’occurrences.</span><span class="sxs-lookup"><span data-stu-id="bb42f-145">This counter is useful when it isn't feasible to call an API on each occurrence, but it's possible to query the total number of occurrences.</span></span> <span data-ttu-id="bb42f-146">Par exemple, vous pouvez signaler le nombre d’octets écrits dans un fichier par seconde, même sans notification chaque fois qu’un octet est écrit.</span><span class="sxs-lookup"><span data-stu-id="bb42f-146">For example, you could report the number of bytes written to a file per second, even without a notification each time a byte is written.</span></span>

## <a name="implement-an-eventsource"></a><span data-ttu-id="bb42f-147">Implémenter une EventSource</span><span class="sxs-lookup"><span data-stu-id="bb42f-147">Implement an EventSource</span></span>

<span data-ttu-id="bb42f-148">Le code suivant implémente un exemple <xref:System.Diagnostics.Tracing.EventSource> exposé comme fournisseur nommé `"Sample.EventCounter.Minimal"` .</span><span class="sxs-lookup"><span data-stu-id="bb42f-148">The following code implements a sample <xref:System.Diagnostics.Tracing.EventSource> exposed as the named `"Sample.EventCounter.Minimal"` provider.</span></span> <span data-ttu-id="bb42f-149">Cette source contient une <xref:System.Diagnostics.Tracing.EventCounter> durée de traitement de la demande de représentation.</span><span class="sxs-lookup"><span data-stu-id="bb42f-149">This source contains an <xref:System.Diagnostics.Tracing.EventCounter> representing request processing time.</span></span> <span data-ttu-id="bb42f-150">Ce compteur a un nom (autrement dit, son ID unique dans la source) et un nom d’affichage, tous deux utilisés par des outils d’écouteur tels que [dotnet-Counter](dotnet-counters.md).</span><span class="sxs-lookup"><span data-stu-id="bb42f-150">Such a counter has a name (that is, its unique ID in the source) and a display name, both used by listener tools such as [dotnet-counter](dotnet-counters.md).</span></span>

:::code language="csharp" source="snippets/EventCounters/MinimalEventCounterSource.cs":::

<span data-ttu-id="bb42f-151">Vous utilisez `dotnet-counters ps` pour afficher une liste de processus .net qui peuvent être analysés :</span><span class="sxs-lookup"><span data-stu-id="bb42f-151">You use `dotnet-counters ps` to display a list of .NET processes that can be monitored:</span></span>

```console
dotnet-counters ps
   1398652 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399072 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399112 dotnet     C:\Program Files\dotnet\dotnet.exe
   1401880 dotnet     C:\Program Files\dotnet\dotnet.exe
   1400180 sample-counters C:\sample-counters\bin\Debug\netcoreapp3.1\sample-counters.exe
```

<span data-ttu-id="bb42f-152">Transmettez le <xref:System.Diagnostics.Tracing.EventSource> nom à l' `--counters` option pour démarrer l’analyse de votre compteur :</span><span class="sxs-lookup"><span data-stu-id="bb42f-152">Pass the <xref:System.Diagnostics.Tracing.EventSource> name to the `--counters` option to start monitoring your counter:</span></span>

```console
dotnet-counters monitor --process-id 1400180 --counters Sample.EventCounter.Minimal
```

<span data-ttu-id="bb42f-153">L’exemple suivant illustre la sortie de l’analyse :</span><span class="sxs-lookup"><span data-stu-id="bb42f-153">The following example shows monitor output:</span></span>

```console
Press p to pause, r to resume, q to quit.
    Status: Running

[Samples-EventCounterDemos-Minimal]
    Request Processing Time (ms)                            0.445
```

<span data-ttu-id="bb42f-154">Appuyez sur <kbd>q</kbd> pour arrêter la commande d’analyse.</span><span class="sxs-lookup"><span data-stu-id="bb42f-154">Press <kbd>q</kbd> to stop the monitoring command.</span></span>

#### <a name="conditional-counters"></a><span data-ttu-id="bb42f-155">Compteurs conditionnels</span><span class="sxs-lookup"><span data-stu-id="bb42f-155">Conditional counters</span></span>

<span data-ttu-id="bb42f-156">Lors de l’implémentation d’un <xref:System.Diagnostics.Tracing.EventSource> , les compteurs conteneur peuvent être instanciés de manière conditionnelle lorsque la <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> méthode est appelée avec une <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> valeur `EventCommand.Enable` .</span><span class="sxs-lookup"><span data-stu-id="bb42f-156">When implementing an <xref:System.Diagnostics.Tracing.EventSource>, the containing counters can be conditionally instantiated when the <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> method is called with a <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> value of `EventCommand.Enable`.</span></span> <span data-ttu-id="bb42f-157">Pour instancier en toute sécurité une instance de compteur uniquement si c’est `null` le cas, utilisez l' [opérateur d’assignation de fusion Null](../../csharp/language-reference/operators/null-coalescing-operator.md).</span><span class="sxs-lookup"><span data-stu-id="bb42f-157">To safely instantiate a counter instance only if it is `null`, use the [null-coalescing assignment operator](../../csharp/language-reference/operators/null-coalescing-operator.md).</span></span> <span data-ttu-id="bb42f-158">En outre, les méthodes personnalisées peuvent évaluer la <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> méthode pour déterminer si la source d’événements actuelle est activée ou non.</span><span class="sxs-lookup"><span data-stu-id="bb42f-158">Additionally, custom methods can evaluate the <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> method to determine whether or not the current event source is enabled.</span></span>

:::code language="csharp" source="snippets/EventCounters/ConditionalEventCounterSource.cs":::

> [!TIP]
> <span data-ttu-id="bb42f-159">Les compteurs conditionnels sont des compteurs qui sont instanciés de manière conditionnelle, une micro-optimisation.</span><span class="sxs-lookup"><span data-stu-id="bb42f-159">Conditional counters are counters that are conditionally instantiated, a micro-optimization.</span></span> <span data-ttu-id="bb42f-160">Le runtime adopte ce modèle pour les scénarios où les compteurs ne sont normalement pas utilisés, pour économiser une fraction d’une milliseconde.</span><span class="sxs-lookup"><span data-stu-id="bb42f-160">The runtime adopts this pattern for scenarios where counters are normally not used, to save a fraction of a millisecond.</span></span>

### <a name="net-core-runtime-example-counters"></a><span data-ttu-id="bb42f-161">Exemples de compteurs du Runtime .NET Core</span><span class="sxs-lookup"><span data-stu-id="bb42f-161">.NET Core runtime example counters</span></span>

<span data-ttu-id="bb42f-162">Le Runtime .NET Core contient de nombreux exemples d’implémentations excellents.</span><span class="sxs-lookup"><span data-stu-id="bb42f-162">There are many great example implementations in the .NET Core runtime.</span></span> <span data-ttu-id="bb42f-163">Voici l’implémentation du runtime pour le compteur qui effectue le suivi de la taille de la plage de travail de l’application.</span><span class="sxs-lookup"><span data-stu-id="bb42f-163">Here is the runtime implementation for the counter that tracks the working set size of the application.</span></span>

```csharp
var workingSetCounter = new PollingCounter(
    "working-set",
    this,
    () => (double)(Environment.WorkingSet / 1_000_000))
{
    DisplayName = "Working Set",
    DisplayUnits = "MB"
};
```

<span data-ttu-id="bb42f-164">Le <xref:System.Diagnostics.Tracing.PollingCounter> signale la quantité actuelle de mémoire physique mappée au processus (plage de travail) de l’application, car elle capture une mesure à un moment donné.</span><span class="sxs-lookup"><span data-stu-id="bb42f-164">The <xref:System.Diagnostics.Tracing.PollingCounter> reports the current amount of physical memory mapped to the process (working set) of the app, since it captures a metric at a moment in time.</span></span> <span data-ttu-id="bb42f-165">Le rappel d’interrogation d’une valeur est l’expression lambda fournie, qui est simplement un appel à l' <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span><span class="sxs-lookup"><span data-stu-id="bb42f-165">The callback for polling a value is the provided lambda expression, which is just a call to the <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span></span> <span data-ttu-id="bb42f-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> et <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> sont des propriétés facultatives qui peuvent être définies pour aider le côté client du compteur à afficher la valeur plus clairement.</span><span class="sxs-lookup"><span data-stu-id="bb42f-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> and <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> are optional properties that can be set to help the consumer side of the counter to display the value more clearly.</span></span> <span data-ttu-id="bb42f-167">Par exemple, [dotnet-Counters](dotnet-counters.md) utilise ces propriétés pour afficher la version la plus conviviale des noms de compteurs.</span><span class="sxs-lookup"><span data-stu-id="bb42f-167">For example, [dotnet-counters](dotnet-counters.md) uses these properties to display the more display-friendly version of the counter names.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="bb42f-168">Les `DisplayName` Propriétés ne sont pas localisées.</span><span class="sxs-lookup"><span data-stu-id="bb42f-168">The `DisplayName` properties are not localized.</span></span>

<span data-ttu-id="bb42f-169">Pour <xref:System.Diagnostics.Tracing.PollingCounter> , et <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> , rien d’autre ne doit être fait.</span><span class="sxs-lookup"><span data-stu-id="bb42f-169">For the <xref:System.Diagnostics.Tracing.PollingCounter>, and the <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, nothing else needs to be done.</span></span> <span data-ttu-id="bb42f-170">Ils interrogent les valeurs elles-mêmes à un intervalle demandé par le consommateur.</span><span class="sxs-lookup"><span data-stu-id="bb42f-170">They both poll the values themselves at an interval requested by the consumer.</span></span>

<span data-ttu-id="bb42f-171">Voici un exemple de compteur d’exécution implémenté à l’aide de <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> .</span><span class="sxs-lookup"><span data-stu-id="bb42f-171">Here is an example of a runtime counter implemented using <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span></span>

```csharp
var monitorContentionCounter = new IncrementingPollingCounter(
    "monitor-lock-contention-count",
    this,
    () => Monitor.LockContentionCount
)
{
    DisplayName = "Monitor Lock Contention Count",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

<span data-ttu-id="bb42f-172"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter>Utilise l' <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API pour signaler l’incrément du nombre total de conflits de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="bb42f-172">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses the <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API to report the increment of the total lock contention count.</span></span> <span data-ttu-id="bb42f-173">La <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> propriété est facultative, mais quand elle est utilisée, elle peut fournir une indication de l’intervalle de temps le plus approprié pour l’affichage du compteur.</span><span class="sxs-lookup"><span data-stu-id="bb42f-173">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> property is optional, but when used it can provide a hint for what time interval the counter is best displayed at.</span></span> <span data-ttu-id="bb42f-174">Par exemple, le nombre de conflits de verrouillage est mieux affiché en tant que _nombre par seconde_, donc sa <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> valeur est définie sur une seconde.</span><span class="sxs-lookup"><span data-stu-id="bb42f-174">For example, the lock contention count is best displayed as _count per second_, so its <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is set to one second.</span></span> <span data-ttu-id="bb42f-175">La vitesse d’affichage peut être ajustée pour différents types de compteurs de taux.</span><span class="sxs-lookup"><span data-stu-id="bb42f-175">The display rate can be adjusted for different types of rate counters.</span></span>

> [!NOTE]
> <span data-ttu-id="bb42f-176"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale>N’est _pas_ utilisé par [dotnet-Counters](dotnet-counters.md), et les écouteurs d’événements ne sont pas tenus de l’utiliser.</span><span class="sxs-lookup"><span data-stu-id="bb42f-176">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is _not_ used by [dotnet-counters](dotnet-counters.md), and event listeners are not required to use it.</span></span>

<span data-ttu-id="bb42f-177">Il existe d’autres implémentations de compteur à utiliser comme référence dans le [Runtime .net](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) référentiel.</span><span class="sxs-lookup"><span data-stu-id="bb42f-177">There are more counter implementations to use as a reference in the [.NET runtime](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) repo.</span></span>

## <a name="concurrency"></a><span data-ttu-id="bb42f-178">Accès concurrentiel</span><span class="sxs-lookup"><span data-stu-id="bb42f-178">Concurrency</span></span>

> [!TIP]
> <span data-ttu-id="bb42f-179">L’API EventCounters ne garantit pas la sécurité des threads.</span><span class="sxs-lookup"><span data-stu-id="bb42f-179">The EventCounters API does not guarantee thread safety.</span></span> <span data-ttu-id="bb42f-180">Lorsque les délégués passés à <xref:System.Diagnostics.Tracing.PollingCounter> <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> des instances ou sont appelés par plusieurs threads, il vous incombe de garantir la sécurité des threads des délégués.</span><span class="sxs-lookup"><span data-stu-id="bb42f-180">When the delegates passed to <xref:System.Diagnostics.Tracing.PollingCounter> or <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instances are called by multiple threads, it's your responsibility to guarantee the delegates' thread-safety.</span></span>

<span data-ttu-id="bb42f-181">Par exemple, considérez les éléments suivants pour effectuer le <xref:System.Diagnostics.Tracing.EventSource> suivi des demandes.</span><span class="sxs-lookup"><span data-stu-id="bb42f-181">For example, consider the following <xref:System.Diagnostics.Tracing.EventSource> to keep track of requests.</span></span>

:::code language="csharp" source="snippets/EventCounters/RequestEventSource.cs":::

<span data-ttu-id="bb42f-182">La `AddRequest()` méthode peut être appelée à partir d’un gestionnaire de requêtes et le `RequestRateCounter` interroge la valeur à l’intervalle spécifié par le consommateur du compteur.</span><span class="sxs-lookup"><span data-stu-id="bb42f-182">The `AddRequest()` method can be called from a request handler, and the `RequestRateCounter` polls the value at the interval specified by the consumer of the counter.</span></span> <span data-ttu-id="bb42f-183">Toutefois, la `AddRequest()` méthode peut être appelée par plusieurs threads à la fois, en plaçant une condition de concurrence sur `_requestCount` .</span><span class="sxs-lookup"><span data-stu-id="bb42f-183">However, the `AddRequest()` method can be called by multiple threads at once, putting a race condition on `_requestCount`.</span></span> <span data-ttu-id="bb42f-184">Une autre façon thread-safe d’incrémenter `_requestCount` est d’utiliser <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="bb42f-184">A thread-safe alternative way to increment the `_requestCount` is to use <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span></span>

```csharp
public void AddRequest() => Interlocked.Increment(ref _requestCount);
```

<span data-ttu-id="bb42f-185">Pour éviter les lectures endommagées (sur les architectures 32 bits) de l' `long` utilisation du champ-Field `_requestCount` <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="bb42f-185">To prevent torn reads (on 32-bit architectures) of the `long`-field `_requestCount` use <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span></span>

```csharp
_requestRateCounter = new IncrementingPollingCounter("request-rate", this, () => Interlocked.Read(ref _requestCount))
{
    DisplayName = "Request Rate",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

## <a name="consume-eventcounters"></a><span data-ttu-id="bb42f-186">Consommer EventCounters</span><span class="sxs-lookup"><span data-stu-id="bb42f-186">Consume EventCounters</span></span>

<span data-ttu-id="bb42f-187">Il existe deux façons principales de consommer des EventCounters, soit in-proc, soit out-of-process.</span><span class="sxs-lookup"><span data-stu-id="bb42f-187">There are two primary ways of consuming EventCounters, either in-proc, or out-of-proc.</span></span> <span data-ttu-id="bb42f-188">La consommation de EventCounters peut être distinguée en trois couches de technologies consommatrices différentes.</span><span class="sxs-lookup"><span data-stu-id="bb42f-188">The consumption of EventCounters can be distinguished into three layers of various consuming technologies.</span></span>

- <span data-ttu-id="bb42f-189">Transport d’événements dans un flux brut via ETW ou EventPipe :</span><span class="sxs-lookup"><span data-stu-id="bb42f-189">Transporting events in a raw stream via ETW or EventPipe:</span></span>
  - <span data-ttu-id="bb42f-190">Les API ETW sont fournies avec le système d’exploitation Windows, et EventPipe sont accessibles en tant qu' [API .net](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console)ou le [protocole IPC](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md)de diagnostic.</span><span class="sxs-lookup"><span data-stu-id="bb42f-190">ETW APIs come with the Windows OS, and EventPipe is accessible as a [.NET API](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console), or the diagnostic [IPC protocol](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span></span>
- <span data-ttu-id="bb42f-191">Décodage du flux d’événements binaires en événements :</span><span class="sxs-lookup"><span data-stu-id="bb42f-191">Decoding the binary event stream into events:</span></span>
  - <span data-ttu-id="bb42f-192">La [bibliothèque TraceEvent](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) gère à la fois les formats de flux ETW et EventPipe.</span><span class="sxs-lookup"><span data-stu-id="bb42f-192">The [TraceEvent library](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) handles both ETW and EventPipe stream formats.</span></span>
- <span data-ttu-id="bb42f-193">Outils de ligne de commande et d’interface utilisateur graphique :</span><span class="sxs-lookup"><span data-stu-id="bb42f-193">Command-line and GUI tools:</span></span>
  - <span data-ttu-id="bb42f-194">Outils tels que PerfView (ETW ou EventPipe), dotnet-Counters (EventPipe uniquement) et DOTNET-Monitor (EventPipe uniquement).</span><span class="sxs-lookup"><span data-stu-id="bb42f-194">Tools like PerfView (ETW or EventPipe), dotnet-counters (EventPipe only), and dotnet-monitor (EventPipe only).</span></span>

### <a name="consume-out-of-proc"></a><span data-ttu-id="bb42f-195">Consommer hors processus</span><span class="sxs-lookup"><span data-stu-id="bb42f-195">Consume out-of-proc</span></span>

<span data-ttu-id="bb42f-196">L’utilisation de EventCounters out-of-proc est une approche très courante.</span><span class="sxs-lookup"><span data-stu-id="bb42f-196">Consuming EventCounters out-of-proc is a very common approach.</span></span> <span data-ttu-id="bb42f-197">Vous pouvez utiliser [dotnet-Counters](dotnet-counters.md) pour les utiliser de manière multiplateforme via un EventPipe.</span><span class="sxs-lookup"><span data-stu-id="bb42f-197">You can use [dotnet-counters](dotnet-counters.md) to consume them in a cross-platform manner via an EventPipe.</span></span> <span data-ttu-id="bb42f-198">L' `dotnet-counters` outil est un outil global de l’interface CLI dotnet multiplateforme qui peut être utilisé pour analyser les valeurs de compteur.</span><span class="sxs-lookup"><span data-stu-id="bb42f-198">The `dotnet-counters` tool is a cross-platform dotnet CLI global tool that can be used to monitor the counter values.</span></span> <span data-ttu-id="bb42f-199">Pour savoir comment utiliser `dotnet-counters` pour surveiller vos compteurs, consultez [dotnet-Counters](dotnet-counters.md), ou utilisez le didacticiel [mesurer les performances à l’aide de EventCounters](event-counter-perf.md) .</span><span class="sxs-lookup"><span data-stu-id="bb42f-199">To find out how to use `dotnet-counters` to monitor your counters, see [dotnet-counters](dotnet-counters.md), or work through the [Measure performance using EventCounters](event-counter-perf.md) tutorial.</span></span>

#### <a name="dotnet-trace"></a><span data-ttu-id="bb42f-200">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="bb42f-200">dotnet-trace</span></span>

<span data-ttu-id="bb42f-201">L' `dotnet-trace` outil peut être utilisé pour consommer les données de compteur via un EventPipe.</span><span class="sxs-lookup"><span data-stu-id="bb42f-201">The `dotnet-trace` tool can be used to consume the counter data through an EventPipe.</span></span> <span data-ttu-id="bb42f-202">Voici un exemple qui utilise `dotnet-trace` pour collecter des données de compteur.</span><span class="sxs-lookup"><span data-stu-id="bb42f-202">Here is an example using `dotnet-trace` to collect counter data.</span></span>

```console
dotnet-trace collect --process-id <pid> Sample.EventCounter.Minimal:0:0:EventCounterIntervalSec=1
```

<span data-ttu-id="bb42f-203">Pour plus d’informations sur la collecte des valeurs de compteur au fil du temps, consultez la documentation de [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) .</span><span class="sxs-lookup"><span data-stu-id="bb42f-203">For more information on how to collect counter values over time, see the [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) documentation.</span></span>

#### <a name="azure-application-insights"></a><span data-ttu-id="bb42f-204">Azure Application Insights</span><span class="sxs-lookup"><span data-stu-id="bb42f-204">Azure Application Insights</span></span>

<span data-ttu-id="bb42f-205">EventCounters peut être utilisé par Azure Monitor, plus particulièrement Azure Application Insights.</span><span class="sxs-lookup"><span data-stu-id="bb42f-205">EventCounters can be consumed by Azure Monitor, specifically Azure Application Insights.</span></span> <span data-ttu-id="bb42f-206">Vous pouvez ajouter et supprimer des compteurs, et vous êtes libre de spécifier des compteurs personnalisés ou des compteurs connus.</span><span class="sxs-lookup"><span data-stu-id="bb42f-206">Counters can be added and removed, and you're free to specify custom counters, or well-known counters.</span></span> <span data-ttu-id="bb42f-207">Pour plus d’informations, consultez [Personnalisation des compteurs à collecter](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span><span class="sxs-lookup"><span data-stu-id="bb42f-207">For more information, see [Customizing counters to be collected](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span></span>

#### <a name="dotnet-monitor"></a><span data-ttu-id="bb42f-208">dotnet-Monitor</span><span class="sxs-lookup"><span data-stu-id="bb42f-208">dotnet-monitor</span></span>

<span data-ttu-id="bb42f-209">L' `dotnet-monitor` outil est un outil expérimental qui facilite l’accès aux informations de diagnostic dans un processus .net.</span><span class="sxs-lookup"><span data-stu-id="bb42f-209">The `dotnet-monitor` tool is an experimental tool that makes it easier to get access to diagnostics information in a .NET process.</span></span> <span data-ttu-id="bb42f-210">L’outil sert de sur-ensemble de tous les outils de diagnostic.</span><span class="sxs-lookup"><span data-stu-id="bb42f-210">The tool serves as a superset of all diagnostics tools.</span></span> <span data-ttu-id="bb42f-211">En plus des traces, il peut surveiller les métriques, collecter les vidages de la mémoire et collecter les vidages de la mémoire GC.</span><span class="sxs-lookup"><span data-stu-id="bb42f-211">In addition to traces, it can monitor metrics, collect memory dumps, and collect GC dumps.</span></span> <span data-ttu-id="bb42f-212">Elle est distribuée à la fois comme un outil d’interface de commande et une image d’ancrage.</span><span class="sxs-lookup"><span data-stu-id="bb42f-212">It's distributed as both a CLI tool and a docker image.</span></span> <span data-ttu-id="bb42f-213">Il expose une API REST, et la collection d’artefacts de diagnostic se produit par le biais d’appels REST.</span><span class="sxs-lookup"><span data-stu-id="bb42f-213">It exposes a REST API, and the collection of diagnostic artifacts occurs through REST calls.</span></span>

<span data-ttu-id="bb42f-214">Pour plus d’informations, consultez [Présentation de dotnet-Monitor, outil expérimental](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span><span class="sxs-lookup"><span data-stu-id="bb42f-214">For more information, see [Introducing dotnet-monitor, an experimental tool](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span></span>

### <a name="consume-in-proc"></a><span data-ttu-id="bb42f-215">Utiliser in-proc</span><span class="sxs-lookup"><span data-stu-id="bb42f-215">Consume in-proc</span></span>

<span data-ttu-id="bb42f-216">Vous pouvez utiliser les valeurs de compteur via l' <xref:System.Diagnostics.Tracing.EventListener> API.</span><span class="sxs-lookup"><span data-stu-id="bb42f-216">You can consume the counter values via the <xref:System.Diagnostics.Tracing.EventListener> API.</span></span> <span data-ttu-id="bb42f-217">Un <xref:System.Diagnostics.Tracing.EventListener> est une méthode in-proc qui consiste à consommer les événements écrits par toutes les instances d’un <xref:System.Diagnostics.Tracing.EventSource> dans votre application.</span><span class="sxs-lookup"><span data-stu-id="bb42f-217">An <xref:System.Diagnostics.Tracing.EventListener> is an in-proc way of consuming any events written by all instances of an <xref:System.Diagnostics.Tracing.EventSource> in your application.</span></span> <span data-ttu-id="bb42f-218">Pour plus d’informations sur l’utilisation de l' `EventListener` API, consultez <xref:System.Diagnostics.Tracing.EventListener> .</span><span class="sxs-lookup"><span data-stu-id="bb42f-218">For more information on how to use the `EventListener` API, see <xref:System.Diagnostics.Tracing.EventListener>.</span></span>

<span data-ttu-id="bb42f-219">Tout d’abord, le <xref:System.Diagnostics.Tracing.EventSource> qui produit la valeur de compteur doit être activé.</span><span class="sxs-lookup"><span data-stu-id="bb42f-219">First, the <xref:System.Diagnostics.Tracing.EventSource> that produces the counter value needs to be enabled.</span></span> <span data-ttu-id="bb42f-220">Substituez la <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> méthode pour obtenir une notification quand un <xref:System.Diagnostics.Tracing.EventSource> est créé, et si c’est le correct <xref:System.Diagnostics.Tracing.EventSource> avec votre EventCounters, vous pouvez appeler <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> dessus.</span><span class="sxs-lookup"><span data-stu-id="bb42f-220">Override the <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> method to get a notification when an <xref:System.Diagnostics.Tracing.EventSource> is created, and if this is the correct <xref:System.Diagnostics.Tracing.EventSource> with your EventCounters, then you can call <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> on it.</span></span> <span data-ttu-id="bb42f-221">Voici un exemple de remplacement :</span><span class="sxs-lookup"><span data-stu-id="bb42f-221">Here is an example override:</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs" range="11-22":::

#### <a name="sample-code"></a><span data-ttu-id="bb42f-222">Exemple de code</span><span class="sxs-lookup"><span data-stu-id="bb42f-222">Sample code</span></span>

<span data-ttu-id="bb42f-223">Voici un exemple de <xref:System.Diagnostics.Tracing.EventListener> classe qui imprime tous les noms et valeurs de compteur à partir du Runtime .NET <xref:System.Diagnostics.Tracing.EventSource> , pour la publication de ses compteurs internes ( `System.Runtime` ) chaque seconde.</span><span class="sxs-lookup"><span data-stu-id="bb42f-223">Here is a sample <xref:System.Diagnostics.Tracing.EventListener> class that prints out all the counter names and values from the .NET runtime's <xref:System.Diagnostics.Tracing.EventSource>, for publishing its internal counters (`System.Runtime`) every second.</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs":::

<span data-ttu-id="bb42f-224">Comme indiqué ci-dessus, vous _devez_ vous assurer que l' `"EventCounterIntervalSec"` argument est défini dans l' `filterPayload` argument lors de l’appel de <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A> .</span><span class="sxs-lookup"><span data-stu-id="bb42f-224">As shown above, you _must_ make sure the `"EventCounterIntervalSec"` argument is set in the `filterPayload` argument when calling <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span></span> <span data-ttu-id="bb42f-225">Dans le cas contraire, les compteurs ne seront pas en mesure de vider les valeurs, car il ne sait pas à quel intervalle il doit être vidé.</span><span class="sxs-lookup"><span data-stu-id="bb42f-225">Otherwise the counters will not be able to flush out values since it doesn't know at which interval it should be getting flushed out.</span></span>

## <a name="see-also"></a><span data-ttu-id="bb42f-226">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="bb42f-226">See also</span></span>

- [<span data-ttu-id="bb42f-227">dotnet-counters</span><span class="sxs-lookup"><span data-stu-id="bb42f-227">dotnet-counters</span></span>](dotnet-counters.md)
- [<span data-ttu-id="bb42f-228">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="bb42f-228">dotnet-trace</span></span>](dotnet-trace.md)
- <xref:System.Diagnostics.Tracing.EventCounter>
- <xref:System.Diagnostics.Tracing.EventListener>
- <xref:System.Diagnostics.Tracing.EventSource>
