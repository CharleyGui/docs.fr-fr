---
title: Comprendre AssemblyLoadContext-.NET Core
description: Concepts clés pour comprendre l’objectif et le comportement de AssemblyLoadContext dans .NET Core.
ms.date: 08/09/2019
author: sdmaclea
ms.author: stmaclea
ms.openlocfilehash: 8a73a432bf8cc72cced77cf6c62a785b72032913
ms.sourcegitcommit: 9c3a4f2d3babca8919a1e490a159c1500ba7a844
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/12/2019
ms.locfileid: "72291261"
---
# <a name="understanding-systemruntimeloaderassemblyloadcontext"></a><span data-ttu-id="62bc7-103">Fonctionnement de System. Runtime. Loader. AssemblyLoadContext</span><span class="sxs-lookup"><span data-stu-id="62bc7-103">Understanding System.Runtime.Loader.AssemblyLoadContext</span></span>

<span data-ttu-id="62bc7-104">La classe <xref:System.Runtime.Loader.AssemblyLoadContext> est propre à .NET Core.</span><span class="sxs-lookup"><span data-stu-id="62bc7-104">The <xref:System.Runtime.Loader.AssemblyLoadContext> class is unique to .NET Core.</span></span> <span data-ttu-id="62bc7-105">Cet article tente de compléter la documentation de l’API <xref:System.Runtime.Loader.AssemblyLoadContext> à l’aide d’informations conceptuelles.</span><span class="sxs-lookup"><span data-stu-id="62bc7-105">This article attempts to supplement the <xref:System.Runtime.Loader.AssemblyLoadContext> API documentation with conceptual information.</span></span>

<span data-ttu-id="62bc7-106">Cet article s’applique aux développeurs qui implémentent le chargement dynamique, en particulier les développeurs d’infrastructures de chargement dynamique.</span><span class="sxs-lookup"><span data-stu-id="62bc7-106">This article is relevant to developers implementing dynamic loading, especially dynamic loading framework developers.</span></span>

## <a name="what-is-the-assemblyloadcontext"></a><span data-ttu-id="62bc7-107">Qu’est-ce que le AssemblyLoadContext ?</span><span class="sxs-lookup"><span data-stu-id="62bc7-107">What is the AssemblyLoadContext?</span></span>

<span data-ttu-id="62bc7-108">Chaque application .NET Core utilise implicitement le <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-108">Every .NET Core application implicitly uses the <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span>
<span data-ttu-id="62bc7-109">Il s’agit du fournisseur du runtime pour la localisation et le chargement des dépendances.</span><span class="sxs-lookup"><span data-stu-id="62bc7-109">It's the runtime's provider for locating and loading dependencies.</span></span> <span data-ttu-id="62bc7-110">Chaque fois qu’une dépendance est chargée, une instance <xref:System.Runtime.Loader.AssemblyLoadContext> est appelée pour la localiser.</span><span class="sxs-lookup"><span data-stu-id="62bc7-110">Whenever a dependency is loaded, an <xref:System.Runtime.Loader.AssemblyLoadContext> instance is invoked to locate it.</span></span>

- <span data-ttu-id="62bc7-111">Il fournit un service de localisation, de chargement et de mise en cache des assemblys managés et d’autres dépendances.</span><span class="sxs-lookup"><span data-stu-id="62bc7-111">It provides a service of locating, loading, and caching managed assemblies and other dependencies.</span></span>

- <span data-ttu-id="62bc7-112">Pour prendre en charge le chargement et le déchargement de code dynamique, il crée un contexte isolé pour le chargement du code et de ses dépendances dans leur propre instance <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-112">To support dynamic code loading and unloading, it creates an isolated context for loading code and its dependencies in their own <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span>

## <a name="when-do-you-need-multiple-assemblyloadcontext-instances"></a><span data-ttu-id="62bc7-113">Quand avez-vous besoin de plusieurs instances AssemblyLoadContext ?</span><span class="sxs-lookup"><span data-stu-id="62bc7-113">When do you need multiple AssemblyLoadContext instances?</span></span>

<span data-ttu-id="62bc7-114">Une seule instance <xref:System.Runtime.Loader.AssemblyLoadContext> est limitée au chargement d’une seule version d’un <xref:System.Reflection.Assembly> par nom d’assembly simple, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-114">A single <xref:System.Runtime.Loader.AssemblyLoadContext> instance is limited to loading exactly one version of an <xref:System.Reflection.Assembly> per simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="62bc7-115">Cette restriction peut devenir un problème lors du chargement dynamique des modules de code.</span><span class="sxs-lookup"><span data-stu-id="62bc7-115">This restriction can become a problem when loading code modules dynamically.</span></span> <span data-ttu-id="62bc7-116">Chaque module est compilé indépendamment et peut dépendre de différentes versions d’un <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-116">Each module is independently compiled and may depend on different versions of an <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="62bc7-117">Ce problème se produit généralement lorsque les différents modules dépendent de différentes versions d’une bibliothèque couramment utilisée.</span><span class="sxs-lookup"><span data-stu-id="62bc7-117">This problem commonly occurs when different modules depend on different versions of a commonly used library.</span></span>

<span data-ttu-id="62bc7-118">Pour prendre en charge le chargement dynamique du code, l’API <xref:System.Runtime.Loader.AssemblyLoadContext> permet de charger les versions conflictuelles d’une <xref:System.Reflection.Assembly> dans la même application.</span><span class="sxs-lookup"><span data-stu-id="62bc7-118">To support dynamically loading code, the <xref:System.Runtime.Loader.AssemblyLoadContext> API provides for loading conflicting versions of an <xref:System.Reflection.Assembly> in the same application.</span></span> <span data-ttu-id="62bc7-119">Chaque instance <xref:System.Runtime.Loader.AssemblyLoadContext> fournit une correspondance de dictionnaire unique chaque <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> à une instance <xref:System.Reflection.Assembly> spécifique.</span><span class="sxs-lookup"><span data-stu-id="62bc7-119">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance provides a unique dictionary mapping each <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> to a specific <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="62bc7-120">Il fournit également un mécanisme pratique pour regrouper les dépendances liées à un module de code en vue d’un déchargement ultérieur.</span><span class="sxs-lookup"><span data-stu-id="62bc7-120">It also provides a convenient mechanism for grouping dependencies related to a code module for later unload.</span></span>

## <a name="what-is-special-about-the-assemblyloadcontextdefault-instance"></a><span data-ttu-id="62bc7-121">Qu’est-ce qui est spécial à propos de l’instance AssemblyLoadContext. default ?</span><span class="sxs-lookup"><span data-stu-id="62bc7-121">What is special about the AssemblyLoadContext.Default instance?</span></span>

<span data-ttu-id="62bc7-122">L’instance <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> est automatiquement renseignée par le runtime au démarrage.</span><span class="sxs-lookup"><span data-stu-id="62bc7-122">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance is automatically populated by the runtime at startup.</span></span>  <span data-ttu-id="62bc7-123">Elle utilise la [détection par défaut](default-probing.md) pour rechercher et rechercher toutes les dépendances statiques.</span><span class="sxs-lookup"><span data-stu-id="62bc7-123">It uses [default probing](default-probing.md) to locate and find all static dependencies.</span></span>

<span data-ttu-id="62bc7-124">Il résout les scénarios de chargement de dépendances les plus courants.</span><span class="sxs-lookup"><span data-stu-id="62bc7-124">It solves the most common dependency loading scenarios.</span></span>

## <a name="how-does-assemblyloadcontext-support-dynamic-dependencies"></a><span data-ttu-id="62bc7-125">Comment AssemblyLoadContext prend-il en charge les dépendances dynamiques ?</span><span class="sxs-lookup"><span data-stu-id="62bc7-125">How does AssemblyLoadContext support dynamic dependencies?</span></span>

<span data-ttu-id="62bc7-126"><xref:System.Runtime.Loader.AssemblyLoadContext> a plusieurs événements et fonctions virtuelles qui peuvent être substitués.</span><span class="sxs-lookup"><span data-stu-id="62bc7-126"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span>

<span data-ttu-id="62bc7-127">L’instance <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> ne prend en charge que le remplacement des événements.</span><span class="sxs-lookup"><span data-stu-id="62bc7-127">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance only supports overriding the events.</span></span>

<span data-ttu-id="62bc7-128">Les articles [algorithme de chargement d’assembly géré](loading-managed.md), [algorithme de chargement d’assembly satellite](loading-resources.md)et [algorithme de chargement de bibliothèque non managée (natif)](loading-unmanaged.md) font référence à tous les événements et fonctions virtuelles disponibles.</span><span class="sxs-lookup"><span data-stu-id="62bc7-128">The articles [Managed assembly loading algorithm](loading-managed.md), [Satellite assembly loading algorithm](loading-resources.md), and [Unmanaged (native) library loading algorithm](loading-unmanaged.md) refer to all the available events and virtual functions.</span></span>  <span data-ttu-id="62bc7-129">Les articles montrent la position relative de chaque événement et de chaque fonction dans les algorithmes de chargement.</span><span class="sxs-lookup"><span data-stu-id="62bc7-129">The articles show each event and function's relative position in the loading algorithms.</span></span> <span data-ttu-id="62bc7-130">Cet article ne reproduit pas ces informations.</span><span class="sxs-lookup"><span data-stu-id="62bc7-130">This article doesn't reproduce that information.</span></span>

<span data-ttu-id="62bc7-131">Cette section décrit les principes généraux des événements et des fonctions pertinents.</span><span class="sxs-lookup"><span data-stu-id="62bc7-131">This section covers the general principles for the relevant events and functions.</span></span>

- <span data-ttu-id="62bc7-132">**Soyez renouvelable**.</span><span class="sxs-lookup"><span data-stu-id="62bc7-132">**Be repeatable**.</span></span> <span data-ttu-id="62bc7-133">Une requête pour une dépendance spécifique doit toujours aboutir à la même réponse.</span><span class="sxs-lookup"><span data-stu-id="62bc7-133">A query for a specific dependency must always result in the same response.</span></span> <span data-ttu-id="62bc7-134">La même instance de dépendance chargée doit être retournée.</span><span class="sxs-lookup"><span data-stu-id="62bc7-134">The same loaded dependency instance must be returned.</span></span> <span data-ttu-id="62bc7-135">Cette exigence est fondamentale pour la cohérence du cache.</span><span class="sxs-lookup"><span data-stu-id="62bc7-135">This requirement is fundamental  for cache consistency.</span></span> <span data-ttu-id="62bc7-136">Pour les assemblys managés, en particulier, nous créons un cache <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-136">For managed assemblies in particular, we're creating a <xref:System.Reflection.Assembly> cache.</span></span> <span data-ttu-id="62bc7-137">La clé de cache est un nom d’assembly simple, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-137">The cache key is a simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="62bc7-138">**En général, ne levez pas d’exception**.</span><span class="sxs-lookup"><span data-stu-id="62bc7-138">**Typically don't throw**.</span></span>  <span data-ttu-id="62bc7-139">Il est prévu que ces fonctions retournent `null` au lieu de Throw lorsqu’il est impossible de trouver la dépendance demandée.</span><span class="sxs-lookup"><span data-stu-id="62bc7-139">It's expected that these functions return `null` rather than throw when unable to find the requested dependency.</span></span> <span data-ttu-id="62bc7-140">La levée met fin prématurément à la recherche et propage une exception à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="62bc7-140">Throwing will prematurely end the search and be propagate an exception to the caller.</span></span> <span data-ttu-id="62bc7-141">La levée doit être limitée à des erreurs inattendues, telles qu’un assembly endommagé ou une condition de mémoire insuffisante.</span><span class="sxs-lookup"><span data-stu-id="62bc7-141">Throwing should be restricted to unexpected errors like a corrupted assembly or an out of memory condition.</span></span>
- <span data-ttu-id="62bc7-142">**Évitez la récursivité**.</span><span class="sxs-lookup"><span data-stu-id="62bc7-142">**Avoid recursion**.</span></span> <span data-ttu-id="62bc7-143">N’oubliez pas que ces fonctions et gestionnaires implémentent les règles de chargement pour localiser les dépendances.</span><span class="sxs-lookup"><span data-stu-id="62bc7-143">Be aware that these functions and handlers implement the loading rules for locating dependencies.</span></span> <span data-ttu-id="62bc7-144">Votre implémentation ne doit pas appeler les API qui déclenchent la récursivité.</span><span class="sxs-lookup"><span data-stu-id="62bc7-144">Your implementation shouldn't call APIs that trigger recursion.</span></span> <span data-ttu-id="62bc7-145">Votre code doit généralement appeler des fonctions de chargement **AssemblyLoadContext** qui requièrent un argument de référence de mémoire ou un chemin d’accès spécifique.</span><span class="sxs-lookup"><span data-stu-id="62bc7-145">Your code should typically call **AssemblyLoadContext** load functions that require a specific path or memory reference argument.</span></span>
- <span data-ttu-id="62bc7-146">**Chargez dans le bon AssemblyLoadContext**.</span><span class="sxs-lookup"><span data-stu-id="62bc7-146">**Load into the correct AssemblyLoadContext**.</span></span> <span data-ttu-id="62bc7-147">Le choix de l’emplacement de chargement des dépendances est spécifique à l’application.</span><span class="sxs-lookup"><span data-stu-id="62bc7-147">The choice of where to load dependencies is application-specific.</span></span>  <span data-ttu-id="62bc7-148">Le choix est implémenté par ces événements et fonctions.</span><span class="sxs-lookup"><span data-stu-id="62bc7-148">The choice is implemented by these events and functions.</span></span> <span data-ttu-id="62bc7-149">Lorsque votre code appelle des fonctions de chargement par chemin d’accès **AssemblyLoadContext** , appelez-les sur l’instance où vous souhaitez que le code soit chargé.</span><span class="sxs-lookup"><span data-stu-id="62bc7-149">When your code calls **AssemblyLoadContext** load-by-path functions call them on the instance where you want the code loaded.</span></span> <span data-ttu-id="62bc7-150">Parfois, le retour de `null` et l' <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> du handle de charge peuvent être l’option la plus simple.</span><span class="sxs-lookup"><span data-stu-id="62bc7-150">Sometime returning `null` and letting the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> handle the load may be the simplest option.</span></span>
- <span data-ttu-id="62bc7-151">**Tenez compte des concurrences de thread**.</span><span class="sxs-lookup"><span data-stu-id="62bc7-151">**Be aware of thread races**.</span></span> <span data-ttu-id="62bc7-152">Le chargement peut être déclenché par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="62bc7-152">Loading can be triggered by multiple threads.</span></span> <span data-ttu-id="62bc7-153">AssemblyLoadContext gère les courses de threads en ajoutant atomiquement des assemblys à son cache.</span><span class="sxs-lookup"><span data-stu-id="62bc7-153">The AssemblyLoadContext handles thread races by atomically adding assemblies to its cache.</span></span> <span data-ttu-id="62bc7-154">L’instance de la course perdante est ignorée.</span><span class="sxs-lookup"><span data-stu-id="62bc7-154">The race loser's instance is discarded.</span></span> <span data-ttu-id="62bc7-155">Dans votre logique d’implémentation, n’ajoutez pas de logique supplémentaire qui ne gère pas correctement plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="62bc7-155">In your implementation logic, don't add extra logic that doesn't handle multiple threads properly.</span></span>

## <a name="how-are-dynamic-dependencies-isolated"></a><span data-ttu-id="62bc7-156">Comment les dépendances dynamiques sont-elles isolées ?</span><span class="sxs-lookup"><span data-stu-id="62bc7-156">How are dynamic dependencies isolated?</span></span>

<span data-ttu-id="62bc7-157">Chaque instance <xref:System.Runtime.Loader.AssemblyLoadContext> représente une étendue unique pour les instances de <xref:System.Reflection.Assembly> et les définitions de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-157">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance represents a unique scope for <xref:System.Reflection.Assembly> instances and <xref:System.Type> definitions.</span></span>

<span data-ttu-id="62bc7-158">Il n’y a pas d’isolation binaire entre ces dépendances.</span><span class="sxs-lookup"><span data-stu-id="62bc7-158">There's no binary isolation between these dependencies.</span></span> <span data-ttu-id="62bc7-159">Elles sont isolées uniquement si elles ne se trouvent pas mutuellement par nom.</span><span class="sxs-lookup"><span data-stu-id="62bc7-159">They're only isolated by not finding each other by name.</span></span>

<span data-ttu-id="62bc7-160">Dans chaque <xref:System.Runtime.Loader.AssemblyLoadContext> :</span><span class="sxs-lookup"><span data-stu-id="62bc7-160">In each <xref:System.Runtime.Loader.AssemblyLoadContext>:</span></span>

- <span data-ttu-id="62bc7-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> peut faire référence à une instance différente de <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> may refer to a different <xref:System.Reflection.Assembly> instance.</span></span>
- <span data-ttu-id="62bc7-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> peut retourner une instance de type différente pour le même type `name`.</span><span class="sxs-lookup"><span data-stu-id="62bc7-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> may return a different type instance for the same type `name`.</span></span>

## <a name="how-are-dependencies-shared"></a><span data-ttu-id="62bc7-163">Comment les dépendances sont-elles partagées ?</span><span class="sxs-lookup"><span data-stu-id="62bc7-163">How are dependencies shared?</span></span>

<span data-ttu-id="62bc7-164">Les dépendances peuvent facilement être partagées entre des instances <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-164">Dependencies can easily be shared between <xref:System.Runtime.Loader.AssemblyLoadContext> instances.</span></span> <span data-ttu-id="62bc7-165">Le modèle général correspond à un <xref:System.Runtime.Loader.AssemblyLoadContext> pour charger une dépendance.</span><span class="sxs-lookup"><span data-stu-id="62bc7-165">The general model is for one <xref:System.Runtime.Loader.AssemblyLoadContext> to load a dependency.</span></span>  <span data-ttu-id="62bc7-166">L’autre partage la dépendance à l’aide d’une référence à l’assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="62bc7-166">The other shares the dependency by using a reference to the loaded assembly.</span></span>

<span data-ttu-id="62bc7-167">Ce partage est requis pour les assemblys du Runtime.</span><span class="sxs-lookup"><span data-stu-id="62bc7-167">This sharing is required of the runtime assemblies.</span></span> <span data-ttu-id="62bc7-168">Ces assemblys peuvent uniquement être chargés dans le <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-168">These assemblies can only be loaded into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="62bc7-169">Il en est de même pour les frameworks comme `ASP.NET`, `WPF` ou `WinForms`.</span><span class="sxs-lookup"><span data-stu-id="62bc7-169">The same is required for frameworks like `ASP.NET`, `WPF`, or `WinForms`.</span></span>

<span data-ttu-id="62bc7-170">Il est recommandé de charger les dépendances partagées dans <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-170">It's recommended that shared dependencies should be loaded into <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="62bc7-171">Ce partage est le modèle de conception courant.</span><span class="sxs-lookup"><span data-stu-id="62bc7-171">This sharing is the common design pattern.</span></span>

<span data-ttu-id="62bc7-172">Le partage est implémenté dans le codage de l’instance <xref:System.Runtime.Loader.AssemblyLoadContext> personnalisée.</span><span class="sxs-lookup"><span data-stu-id="62bc7-172">Sharing is implemented in the coding of the custom <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span> <span data-ttu-id="62bc7-173"><xref:System.Runtime.Loader.AssemblyLoadContext> a plusieurs événements et fonctions virtuelles qui peuvent être substitués.</span><span class="sxs-lookup"><span data-stu-id="62bc7-173"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span> <span data-ttu-id="62bc7-174">Quand l’une de ces fonctions retourne une référence à une instance <xref:System.Reflection.Assembly> qui a été chargée dans une autre instance <xref:System.Runtime.Loader.AssemblyLoadContext>, l’instance <xref:System.Reflection.Assembly> est partagée.</span><span class="sxs-lookup"><span data-stu-id="62bc7-174">When any of these functions return a reference to an <xref:System.Reflection.Assembly> instance that was loaded in another <xref:System.Runtime.Loader.AssemblyLoadContext> instance, the <xref:System.Reflection.Assembly> instance is shared.</span></span> <span data-ttu-id="62bc7-175">L’algorithme de chargement standard défère à <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> pour le chargement afin de simplifier le modèle de partage commun.</span><span class="sxs-lookup"><span data-stu-id="62bc7-175">The standard load algorithm defers to <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> for loading to simplify the common sharing pattern.</span></span>  <span data-ttu-id="62bc7-176">Consultez [algorithme de chargement d’assembly managé](loading-managed.md).</span><span class="sxs-lookup"><span data-stu-id="62bc7-176">See [Managed assembly loading algorithm](loading-managed.md).</span></span>

## <a name="complications"></a><span data-ttu-id="62bc7-177">Complications</span><span class="sxs-lookup"><span data-stu-id="62bc7-177">Complications</span></span>

### <a name="type-conversion-issues"></a><span data-ttu-id="62bc7-178">Problèmes de conversion de type</span><span class="sxs-lookup"><span data-stu-id="62bc7-178">Type conversion issues</span></span>

<span data-ttu-id="62bc7-179">Lorsque deux instances <xref:System.Runtime.Loader.AssemblyLoadContext> contiennent des définitions de type avec le même `name`, elles ne sont pas du même type.</span><span class="sxs-lookup"><span data-stu-id="62bc7-179">When two <xref:System.Runtime.Loader.AssemblyLoadContext> instances contain type definitions with the same `name`, they're not the same type.</span></span> <span data-ttu-id="62bc7-180">Ils sont du même type si et seulement s’ils proviennent de la même instance de <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-180">They're the same type if and only if they come from the same <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="62bc7-181">Pour compliquer les choses, les messages d’exception concernant ces types incompatibles peuvent prêter à confusion.</span><span class="sxs-lookup"><span data-stu-id="62bc7-181">To complicate matters, exception messages about these mismatched types can be confusing.</span></span> <span data-ttu-id="62bc7-182">Les types sont référencés dans les messages d’exception par leurs noms de types simples.</span><span class="sxs-lookup"><span data-stu-id="62bc7-182">The types are referred to in the exception messages by their simple type names.</span></span> <span data-ttu-id="62bc7-183">Dans ce cas, le message d’exception courant se présente sous la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="62bc7-183">The common exception message in this case would be of the form:</span></span>

> <span data-ttu-id="62bc7-184">L’objet de type’IsolatedType’ne peut pas être converti en type’IsolatedType'.</span><span class="sxs-lookup"><span data-stu-id="62bc7-184">Object of type 'IsolatedType' cannot be converted to type 'IsolatedType'.</span></span>

### <a name="debugging-type-conversion-issues"></a><span data-ttu-id="62bc7-185">Débogage des problèmes de conversion de type</span><span class="sxs-lookup"><span data-stu-id="62bc7-185">Debugging type conversion issues</span></span>

<span data-ttu-id="62bc7-186">À partir d’une paire de types incompatibles, il est également important de savoir :</span><span class="sxs-lookup"><span data-stu-id="62bc7-186">Given a pair of mismatched types it's important to also know:</span></span>

- <span data-ttu-id="62bc7-187">Le @no__t de chaque type-0</span><span class="sxs-lookup"><span data-stu-id="62bc7-187">Each type's <xref:System.Type.Assembly?displayProperty=nameWithType></span></span>
- <span data-ttu-id="62bc7-188">@No__t-0 de chaque type, qui peut être obtenu via la fonction <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="62bc7-188">Each type's <xref:System.Runtime.Loader.AssemblyLoadContext>, which can be obtained via the <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> function.</span></span>

<span data-ttu-id="62bc7-189">À partir de deux objets `a` et `b`, l’évaluation de ce qui suit dans le débogueur est utile :</span><span class="sxs-lookup"><span data-stu-id="62bc7-189">Given two objects `a` and `b`, evaluating the following in the debugger will be helpful:</span></span>

```csharp
// In debugger look at each assembly's instance, Location, and FullName
a.GetType().Assembly
b.GetType().Assembly
// In debugger look at each AssemblyLoadContext's instance and name
System.Runtime.AssemblyLoadContext.GetLoadContext(a.GetType().Assembly)
System.Runtime.AssemblyLoadContext.GetLoadContext(b.GetType().Assembly)
```

### <a name="resolving-type-conversion-issues"></a><span data-ttu-id="62bc7-190">Résolution des problèmes de conversion de type</span><span class="sxs-lookup"><span data-stu-id="62bc7-190">Resolving type conversion issues</span></span>

<span data-ttu-id="62bc7-191">Il existe deux modèles de conception pour résoudre ces problèmes de conversion de type.</span><span class="sxs-lookup"><span data-stu-id="62bc7-191">There are two design patterns for solving these type conversion issues.</span></span>

1. <span data-ttu-id="62bc7-192">Utilisez les types partagés communs.</span><span class="sxs-lookup"><span data-stu-id="62bc7-192">Use common shared types.</span></span> <span data-ttu-id="62bc7-193">Ce type partagé peut être un type de Runtime primitif, ou il peut impliquer la création d’un nouveau type partagé dans un assembly partagé.</span><span class="sxs-lookup"><span data-stu-id="62bc7-193">This shared type can either be a primitive runtime type, or it can involve creating a new shared type in a shared assembly.</span></span>  <span data-ttu-id="62bc7-194">Le type partagé est souvent une [interface](../../csharp/language-reference/keywords/interface.md) définie dans un assembly d’application.</span><span class="sxs-lookup"><span data-stu-id="62bc7-194">Often the shared type is an [interface](../../csharp/language-reference/keywords/interface.md) defined in an application assembly.</span></span> <span data-ttu-id="62bc7-195">Voir aussi : [Comment les dépendances sont-elles partagées ?](#how-are-dependencies-shared)</span><span class="sxs-lookup"><span data-stu-id="62bc7-195">See also: [How are dependencies shared?](#how-are-dependencies-shared).</span></span>

2. <span data-ttu-id="62bc7-196">Utilisez les techniques de marshaling pour convertir d’un type en un autre.</span><span class="sxs-lookup"><span data-stu-id="62bc7-196">Use marshaling techniques to convert from one type to another.</span></span>
