---
title: Comprendre AssemblyLoadContext - .NET Core
description: Concepts clés pour comprendre le but et le comportement de AssemblyLoadContext dans .NET Core.
ms.date: 08/09/2019
author: sdmaclea
ms.author: stmaclea
ms.openlocfilehash: 43fb0d792ddeb20b8a141af452a86dd50f37ba43
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/01/2020
ms.locfileid: "80523612"
---
# <a name="understanding-systemruntimeloaderassemblyloadcontext"></a><span data-ttu-id="aced9-103">Comprendre System.Runtime.Loader.AssemblyLoadContext</span><span class="sxs-lookup"><span data-stu-id="aced9-103">Understanding System.Runtime.Loader.AssemblyLoadContext</span></span>

<span data-ttu-id="aced9-104">La <xref:System.Runtime.Loader.AssemblyLoadContext> classe est unique à .NET Core.</span><span class="sxs-lookup"><span data-stu-id="aced9-104">The <xref:System.Runtime.Loader.AssemblyLoadContext> class is unique to .NET Core.</span></span> <span data-ttu-id="aced9-105">Cet article tente <xref:System.Runtime.Loader.AssemblyLoadContext> de compléter la documentation de l’API avec des informations conceptuelles.</span><span class="sxs-lookup"><span data-stu-id="aced9-105">This article attempts to supplement the <xref:System.Runtime.Loader.AssemblyLoadContext> API documentation with conceptual information.</span></span>

<span data-ttu-id="aced9-106">Cet article est pertinent pour les développeurs mettant en œuvre le chargement dynamique, en particulier les développeurs de cadres de chargement dynamiques.</span><span class="sxs-lookup"><span data-stu-id="aced9-106">This article is relevant to developers implementing dynamic loading, especially dynamic loading framework developers.</span></span>

## <a name="what-is-the-assemblyloadcontext"></a><span data-ttu-id="aced9-107">Qu’est-ce que le texte AssemblyLoadContext?</span><span class="sxs-lookup"><span data-stu-id="aced9-107">What is the AssemblyLoadContext?</span></span>

<span data-ttu-id="aced9-108">Chaque application .NET Core <xref:System.Runtime.Loader.AssemblyLoadContext>utilise implicitement le .</span><span class="sxs-lookup"><span data-stu-id="aced9-108">Every .NET Core application implicitly uses the <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span>
<span data-ttu-id="aced9-109">C’est le fournisseur de l’heure d’exécution pour localiser et charger les dépendances.</span><span class="sxs-lookup"><span data-stu-id="aced9-109">It's the runtime's provider for locating and loading dependencies.</span></span> <span data-ttu-id="aced9-110">Chaque fois qu’une <xref:System.Runtime.Loader.AssemblyLoadContext> dépendance est chargée, une instance est invoquée pour la localiser.</span><span class="sxs-lookup"><span data-stu-id="aced9-110">Whenever a dependency is loaded, an <xref:System.Runtime.Loader.AssemblyLoadContext> instance is invoked to locate it.</span></span>

- <span data-ttu-id="aced9-111">Il fournit un service de localisation, de chargement et de mise en cache d’assemblages gérés et d’autres dépendances.</span><span class="sxs-lookup"><span data-stu-id="aced9-111">It provides a service of locating, loading, and caching managed assemblies and other dependencies.</span></span>

- <span data-ttu-id="aced9-112">Pour prendre en charge le chargement et le déchargement dynamiques du code, il crée un contexte isolé pour le code de chargement et ses dépendances dans leur propre <xref:System.Runtime.Loader.AssemblyLoadContext> cas.</span><span class="sxs-lookup"><span data-stu-id="aced9-112">To support dynamic code loading and unloading, it creates an isolated context for loading code and its dependencies in their own <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span>

## <a name="when-do-you-need-multiple-assemblyloadcontext-instances"></a><span data-ttu-id="aced9-113">Quand avez-vous besoin de plusieurs instances AssemblyLoadContext ?</span><span class="sxs-lookup"><span data-stu-id="aced9-113">When do you need multiple AssemblyLoadContext instances?</span></span>

<span data-ttu-id="aced9-114">Une <xref:System.Runtime.Loader.AssemblyLoadContext> seule instance se limite au <xref:System.Reflection.Assembly> chargement exactement <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>d’une version d’un nom d’assemblage simple, .</span><span class="sxs-lookup"><span data-stu-id="aced9-114">A single <xref:System.Runtime.Loader.AssemblyLoadContext> instance is limited to loading exactly one version of an <xref:System.Reflection.Assembly> per simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aced9-115">Cette restriction peut devenir un problème lors du chargement dynamique des modules de code.</span><span class="sxs-lookup"><span data-stu-id="aced9-115">This restriction can become a problem when loading code modules dynamically.</span></span> <span data-ttu-id="aced9-116">Chaque module est compilé indépendamment et peut dépendre de différentes versions d’un <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="aced9-116">Each module is independently compiled and may depend on different versions of an <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="aced9-117">Ce problème se produit généralement lorsque différents modules dépendent de différentes versions d’une bibliothèque couramment utilisée.</span><span class="sxs-lookup"><span data-stu-id="aced9-117">This problem commonly occurs when different modules depend on different versions of a commonly used library.</span></span>

<span data-ttu-id="aced9-118">Pour prendre en charge <xref:System.Runtime.Loader.AssemblyLoadContext> le code de chargement dynamique, <xref:System.Reflection.Assembly> l’API prévoit le chargement des versions contradictoires d’une application dans la même application.</span><span class="sxs-lookup"><span data-stu-id="aced9-118">To support dynamically loading code, the <xref:System.Runtime.Loader.AssemblyLoadContext> API provides for loading conflicting versions of an <xref:System.Reflection.Assembly> in the same application.</span></span> <span data-ttu-id="aced9-119">Chaque <xref:System.Runtime.Loader.AssemblyLoadContext> instance fournit une <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> cartographie unique <xref:System.Reflection.Assembly> de dictionnaire chacun à une instance spécifique.</span><span class="sxs-lookup"><span data-stu-id="aced9-119">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance provides a unique dictionary mapping each <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> to a specific <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="aced9-120">Il fournit également un mécanisme pratique pour regrouper les dépendances liées à un module de code pour décharger plus tard.</span><span class="sxs-lookup"><span data-stu-id="aced9-120">It also provides a convenient mechanism for grouping dependencies related to a code module for later unload.</span></span>

## <a name="what-is-special-about-the-assemblyloadcontextdefault-instance"></a><span data-ttu-id="aced9-121">Qu’y a-t-il de spécial dans l’instance AssemblyLoadContext.Default ?</span><span class="sxs-lookup"><span data-stu-id="aced9-121">What is special about the AssemblyLoadContext.Default instance?</span></span>

<span data-ttu-id="aced9-122">L’instance <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> est automatiquement peuplée par le temps d’exécution au démarrage.</span><span class="sxs-lookup"><span data-stu-id="aced9-122">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance is automatically populated by the runtime at startup.</span></span>  <span data-ttu-id="aced9-123">Il utilise [l’enquête par défaut](default-probing.md) pour localiser et trouver toutes les dépendances statiques.</span><span class="sxs-lookup"><span data-stu-id="aced9-123">It uses [default probing](default-probing.md) to locate and find all static dependencies.</span></span>

<span data-ttu-id="aced9-124">Il résout les scénarios de chargement de dépendance les plus courants.</span><span class="sxs-lookup"><span data-stu-id="aced9-124">It solves the most common dependency loading scenarios.</span></span>

## <a name="how-does-assemblyloadcontext-support-dynamic-dependencies"></a><span data-ttu-id="aced9-125">Comment AssemblyLoadContext soutient-il les dépendances dynamiques ?</span><span class="sxs-lookup"><span data-stu-id="aced9-125">How does AssemblyLoadContext support dynamic dependencies?</span></span>

<span data-ttu-id="aced9-126"><xref:System.Runtime.Loader.AssemblyLoadContext>a divers événements et fonctions virtuelles qui peuvent être remplacés.</span><span class="sxs-lookup"><span data-stu-id="aced9-126"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span>

<span data-ttu-id="aced9-127">L’instance <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> ne prend en charge que la suppression des événements.</span><span class="sxs-lookup"><span data-stu-id="aced9-127">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance only supports overriding the events.</span></span>

<span data-ttu-id="aced9-128">Les articles [Managed assembly loading algorithm](loading-managed.md), Satellite assembly loading [algorithm](loading-resources.md), et [Unmanaged (native) library loading algorithm](loading-unmanaged.md) se réfèrent à tous les événements disponibles et les fonctions virtuelles.</span><span class="sxs-lookup"><span data-stu-id="aced9-128">The articles [Managed assembly loading algorithm](loading-managed.md), [Satellite assembly loading algorithm](loading-resources.md), and [Unmanaged (native) library loading algorithm](loading-unmanaged.md) refer to all the available events and virtual functions.</span></span>  <span data-ttu-id="aced9-129">Les articles montrent la position relative de chaque événement et de la fonction dans les algorithmes de chargement.</span><span class="sxs-lookup"><span data-stu-id="aced9-129">The articles show each event and function's relative position in the loading algorithms.</span></span> <span data-ttu-id="aced9-130">Cet article ne reproduit pas cette information.</span><span class="sxs-lookup"><span data-stu-id="aced9-130">This article doesn't reproduce that information.</span></span>

<span data-ttu-id="aced9-131">Cette section couvre les principes généraux des événements et fonctions pertinents.</span><span class="sxs-lookup"><span data-stu-id="aced9-131">This section covers the general principles for the relevant events and functions.</span></span>

- <span data-ttu-id="aced9-132">**Soyez reproductible**.</span><span class="sxs-lookup"><span data-stu-id="aced9-132">**Be repeatable**.</span></span> <span data-ttu-id="aced9-133">Une requête en une dépendance spécifique doit toujours donner lieu à la même réponse.</span><span class="sxs-lookup"><span data-stu-id="aced9-133">A query for a specific dependency must always result in the same response.</span></span> <span data-ttu-id="aced9-134">La même instance de dépendance chargée doit être retournée.</span><span class="sxs-lookup"><span data-stu-id="aced9-134">The same loaded dependency instance must be returned.</span></span> <span data-ttu-id="aced9-135">Cette exigence est fondamentale pour la cohérence des caches.</span><span class="sxs-lookup"><span data-stu-id="aced9-135">This requirement is fundamental  for cache consistency.</span></span> <span data-ttu-id="aced9-136">Pour les assemblages gérés en particulier, nous créons un <xref:System.Reflection.Assembly> cache.</span><span class="sxs-lookup"><span data-stu-id="aced9-136">For managed assemblies in particular, we're creating a <xref:System.Reflection.Assembly> cache.</span></span> <span data-ttu-id="aced9-137">La clé cache est un <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>nom d’assemblage simple, .</span><span class="sxs-lookup"><span data-stu-id="aced9-137">The cache key is a simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="aced9-138">**Typiquement ne jetez pas**.</span><span class="sxs-lookup"><span data-stu-id="aced9-138">**Typically don't throw**.</span></span>  <span data-ttu-id="aced9-139">On s’attend à ce `null` que ces fonctions reviennent plutôt que de jeter lorsqu’elles ne sont pas en mesure de trouver la dépendance demandée.</span><span class="sxs-lookup"><span data-stu-id="aced9-139">It's expected that these functions return `null` rather than throw when unable to find the requested dependency.</span></span> <span data-ttu-id="aced9-140">Le lancer mettra fin prématurément à la recherche et propagera une exception à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="aced9-140">Throwing will prematurely end the search and be propagate an exception to the caller.</span></span> <span data-ttu-id="aced9-141">Le lancer doit être limité à des erreurs inattendues comme un assemblage corrompu ou un état hors mémoire.</span><span class="sxs-lookup"><span data-stu-id="aced9-141">Throwing should be restricted to unexpected errors like a corrupted assembly or an out of memory condition.</span></span>
- <span data-ttu-id="aced9-142">**Évitez la récursion**.</span><span class="sxs-lookup"><span data-stu-id="aced9-142">**Avoid recursion**.</span></span> <span data-ttu-id="aced9-143">Sachez que ces fonctions et les gestionnaires mettent en œuvre les règles de chargement pour localiser les dépendances.</span><span class="sxs-lookup"><span data-stu-id="aced9-143">Be aware that these functions and handlers implement the loading rules for locating dependencies.</span></span> <span data-ttu-id="aced9-144">Votre implémentation ne devrait pas appeler les API qui déclenchent la récursion.</span><span class="sxs-lookup"><span data-stu-id="aced9-144">Your implementation shouldn't call APIs that trigger recursion.</span></span> <span data-ttu-id="aced9-145">Votre code devrait généralement appeler les fonctions **de chargement AssemblyLoadContext** qui nécessitent un argument spécifique de référence de voie ou de mémoire.</span><span class="sxs-lookup"><span data-stu-id="aced9-145">Your code should typically call **AssemblyLoadContext** load functions that require a specific path or memory reference argument.</span></span>
- <span data-ttu-id="aced9-146">**Chargez-vous dans le correct AssemblyLoadContext**.</span><span class="sxs-lookup"><span data-stu-id="aced9-146">**Load into the correct AssemblyLoadContext**.</span></span> <span data-ttu-id="aced9-147">Le choix de l’endroit où charger les dépendances est spécifique à l’application.</span><span class="sxs-lookup"><span data-stu-id="aced9-147">The choice of where to load dependencies is application-specific.</span></span>  <span data-ttu-id="aced9-148">Le choix est mis en œuvre par ces événements et fonctions.</span><span class="sxs-lookup"><span data-stu-id="aced9-148">The choice is implemented by these events and functions.</span></span> <span data-ttu-id="aced9-149">Lorsque votre code appelle les fonctions de charge par voie **AssemblyLoadContext,** appelez-les dans l’instance où vous voulez que le code soit chargé.</span><span class="sxs-lookup"><span data-stu-id="aced9-149">When your code calls **AssemblyLoadContext** load-by-path functions call them on the instance where you want the code loaded.</span></span> <span data-ttu-id="aced9-150">Parfois, `null` le <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> retour et laisser la poignée de la charge peut être l’option la plus simple.</span><span class="sxs-lookup"><span data-stu-id="aced9-150">Sometime returning `null` and letting the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> handle the load may be the simplest option.</span></span>
- <span data-ttu-id="aced9-151">**Soyez conscient des courses de fil**.</span><span class="sxs-lookup"><span data-stu-id="aced9-151">**Be aware of thread races**.</span></span> <span data-ttu-id="aced9-152">Le chargement peut être déclenché par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="aced9-152">Loading can be triggered by multiple threads.</span></span> <span data-ttu-id="aced9-153">L’AssemblageLoadContext gère les courses de threads en ajoutant atomiquement des assemblages à son cache.</span><span class="sxs-lookup"><span data-stu-id="aced9-153">The AssemblyLoadContext handles thread races by atomically adding assemblies to its cache.</span></span> <span data-ttu-id="aced9-154">L’instance du perdant de la course est écartée.</span><span class="sxs-lookup"><span data-stu-id="aced9-154">The race loser's instance is discarded.</span></span> <span data-ttu-id="aced9-155">Dans votre logique d’implémentation, n’ajoutez pas de logique supplémentaire qui ne gère pas correctement plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="aced9-155">In your implementation logic, don't add extra logic that doesn't handle multiple threads properly.</span></span>

## <a name="how-are-dynamic-dependencies-isolated"></a><span data-ttu-id="aced9-156">Comment les dépendances dynamiques sont-elles isolées?</span><span class="sxs-lookup"><span data-stu-id="aced9-156">How are dynamic dependencies isolated?</span></span>

<span data-ttu-id="aced9-157">Chaque <xref:System.Runtime.Loader.AssemblyLoadContext> instance représente une <xref:System.Reflection.Assembly> portée <xref:System.Type> unique pour les instances et les définitions.</span><span class="sxs-lookup"><span data-stu-id="aced9-157">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance represents a unique scope for <xref:System.Reflection.Assembly> instances and <xref:System.Type> definitions.</span></span>

<span data-ttu-id="aced9-158">Il n’y a pas d’isolement binaire entre ces dépendances.</span><span class="sxs-lookup"><span data-stu-id="aced9-158">There's no binary isolation between these dependencies.</span></span> <span data-ttu-id="aced9-159">Ils sont isolés en ne se trouvant pas par leur nom.</span><span class="sxs-lookup"><span data-stu-id="aced9-159">They're only isolated by not finding each other by name.</span></span>

<span data-ttu-id="aced9-160">Dans <xref:System.Runtime.Loader.AssemblyLoadContext>chaque :</span><span class="sxs-lookup"><span data-stu-id="aced9-160">In each <xref:System.Runtime.Loader.AssemblyLoadContext>:</span></span>

- <span data-ttu-id="aced9-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>peut se référer <xref:System.Reflection.Assembly> à un autre cas.</span><span class="sxs-lookup"><span data-stu-id="aced9-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> may refer to a different <xref:System.Reflection.Assembly> instance.</span></span>
- <span data-ttu-id="aced9-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType>peut retourner une instance de `name`type différente pour le même type .</span><span class="sxs-lookup"><span data-stu-id="aced9-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> may return a different type instance for the same type `name`.</span></span>

## <a name="how-are-dependencies-shared"></a><span data-ttu-id="aced9-163">Comment les dépendances sont-elles partagées?</span><span class="sxs-lookup"><span data-stu-id="aced9-163">How are dependencies shared?</span></span>

<span data-ttu-id="aced9-164">Les dépendances peuvent facilement <xref:System.Runtime.Loader.AssemblyLoadContext> être partagées entre les instances.</span><span class="sxs-lookup"><span data-stu-id="aced9-164">Dependencies can easily be shared between <xref:System.Runtime.Loader.AssemblyLoadContext> instances.</span></span> <span data-ttu-id="aced9-165">Le modèle général <xref:System.Runtime.Loader.AssemblyLoadContext> est pour un de charger une dépendance.</span><span class="sxs-lookup"><span data-stu-id="aced9-165">The general model is for one <xref:System.Runtime.Loader.AssemblyLoadContext> to load a dependency.</span></span>  <span data-ttu-id="aced9-166">L’autre partage la dépendance en utilisant une référence à l’assemblage chargé.</span><span class="sxs-lookup"><span data-stu-id="aced9-166">The other shares the dependency by using a reference to the loaded assembly.</span></span>

<span data-ttu-id="aced9-167">Ce partage est exigé des assemblées de runtime.</span><span class="sxs-lookup"><span data-stu-id="aced9-167">This sharing is required of the runtime assemblies.</span></span> <span data-ttu-id="aced9-168">Ces assemblages ne peuvent <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>être chargés que dans le .</span><span class="sxs-lookup"><span data-stu-id="aced9-168">These assemblies can only be loaded into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aced9-169">La même chose est `ASP.NET`nécessaire `WPF`pour `WinForms`les cadres comme , , ou .</span><span class="sxs-lookup"><span data-stu-id="aced9-169">The same is required for frameworks like `ASP.NET`, `WPF`, or `WinForms`.</span></span>

<span data-ttu-id="aced9-170">Il est recommandé que les dépendances <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>partagées devraient être chargées dans .</span><span class="sxs-lookup"><span data-stu-id="aced9-170">It's recommended that shared dependencies should be loaded into <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aced9-171">Ce partage est le modèle de conception commun.</span><span class="sxs-lookup"><span data-stu-id="aced9-171">This sharing is the common design pattern.</span></span>

<span data-ttu-id="aced9-172">Le partage est mis en <xref:System.Runtime.Loader.AssemblyLoadContext> œuvre dans le codage de l’instance personnalisée.</span><span class="sxs-lookup"><span data-stu-id="aced9-172">Sharing is implemented in the coding of the custom <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span> <span data-ttu-id="aced9-173"><xref:System.Runtime.Loader.AssemblyLoadContext>a divers événements et fonctions virtuelles qui peuvent être remplacés.</span><span class="sxs-lookup"><span data-stu-id="aced9-173"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span> <span data-ttu-id="aced9-174">Lorsque l’une de ces fonctions renvoie une référence à une <xref:System.Reflection.Assembly> instance qui a été chargée dans un autre <xref:System.Runtime.Loader.AssemblyLoadContext> cas, l’instance <xref:System.Reflection.Assembly> est partagée.</span><span class="sxs-lookup"><span data-stu-id="aced9-174">When any of these functions return a reference to an <xref:System.Reflection.Assembly> instance that was loaded in another <xref:System.Runtime.Loader.AssemblyLoadContext> instance, the <xref:System.Reflection.Assembly> instance is shared.</span></span> <span data-ttu-id="aced9-175">L’algorithme de charge <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> standard s’en remet au chargement pour simplifier le modèle de partage commun.</span><span class="sxs-lookup"><span data-stu-id="aced9-175">The standard load algorithm defers to <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> for loading to simplify the common sharing pattern.</span></span>  <span data-ttu-id="aced9-176">Voir [l’algorithme de chargement d’assemblage géré](loading-managed.md).</span><span class="sxs-lookup"><span data-stu-id="aced9-176">See [Managed assembly loading algorithm](loading-managed.md).</span></span>

## <a name="complications"></a><span data-ttu-id="aced9-177">Complications</span><span class="sxs-lookup"><span data-stu-id="aced9-177">Complications</span></span>

### <a name="type-conversion-issues"></a><span data-ttu-id="aced9-178">Problèmes de conversion de type</span><span class="sxs-lookup"><span data-stu-id="aced9-178">Type conversion issues</span></span>

<span data-ttu-id="aced9-179">Lorsque <xref:System.Runtime.Loader.AssemblyLoadContext> deux instances contiennent des `name`définitions de type avec la même, elles ne sont pas du même type.</span><span class="sxs-lookup"><span data-stu-id="aced9-179">When two <xref:System.Runtime.Loader.AssemblyLoadContext> instances contain type definitions with the same `name`, they're not the same type.</span></span> <span data-ttu-id="aced9-180">Ils sont du même type si et seulement <xref:System.Reflection.Assembly> s’ils viennent de la même instance.</span><span class="sxs-lookup"><span data-stu-id="aced9-180">They're the same type if and only if they come from the same <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="aced9-181">Pour compliquer les choses, les messages d’exception au sujet de ces types dépareillés peuvent être déroutants.</span><span class="sxs-lookup"><span data-stu-id="aced9-181">To complicate matters, exception messages about these mismatched types can be confusing.</span></span> <span data-ttu-id="aced9-182">Les types sont mentionnés dans les messages d’exception par leurs noms de type simple.</span><span class="sxs-lookup"><span data-stu-id="aced9-182">The types are referred to in the exception messages by their simple type names.</span></span> <span data-ttu-id="aced9-183">Le message d’exception commun en l’espèce serait du formulaire :</span><span class="sxs-lookup"><span data-stu-id="aced9-183">The common exception message in this case would be of the form:</span></span>

> <span data-ttu-id="aced9-184">L’objet de type 'IsolatedType' ne peut pas être converti en type 'IsolatedType'.</span><span class="sxs-lookup"><span data-stu-id="aced9-184">Object of type 'IsolatedType' cannot be converted to type 'IsolatedType'.</span></span>

### <a name="debugging-type-conversion-issues"></a><span data-ttu-id="aced9-185">Problèmes de conversion de type de débogage</span><span class="sxs-lookup"><span data-stu-id="aced9-185">Debugging type conversion issues</span></span>

<span data-ttu-id="aced9-186">Compte tenu d’une paire de types dépareillés, il est important de savoir aussi:</span><span class="sxs-lookup"><span data-stu-id="aced9-186">Given a pair of mismatched types it's important to also know:</span></span>

- <span data-ttu-id="aced9-187">Chaque type<xref:System.Type.Assembly?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="aced9-187">Each type's <xref:System.Type.Assembly?displayProperty=nameWithType></span></span>
- <span data-ttu-id="aced9-188">Chaque <xref:System.Runtime.Loader.AssemblyLoadContext>type, qui peut être obtenu <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> via la fonction.</span><span class="sxs-lookup"><span data-stu-id="aced9-188">Each type's <xref:System.Runtime.Loader.AssemblyLoadContext>, which can be obtained via the <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> function.</span></span>

<span data-ttu-id="aced9-189">Compte tenu `a` `b`de deux objets et , l’évaluation de ce qui suit dans le débbuggeur sera utile:</span><span class="sxs-lookup"><span data-stu-id="aced9-189">Given two objects `a` and `b`, evaluating the following in the debugger will be helpful:</span></span>

```csharp
// In debugger look at each assembly's instance, Location, and FullName
a.GetType().Assembly
b.GetType().Assembly
// In debugger look at each AssemblyLoadContext's instance and name
System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(a.GetType().Assembly)
System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(b.GetType().Assembly)
```

### <a name="resolving-type-conversion-issues"></a><span data-ttu-id="aced9-190">Résoudre les problèmes de conversion de type</span><span class="sxs-lookup"><span data-stu-id="aced9-190">Resolving type conversion issues</span></span>

<span data-ttu-id="aced9-191">Il existe deux modèles de conception pour résoudre ces problèmes de conversion de type.</span><span class="sxs-lookup"><span data-stu-id="aced9-191">There are two design patterns for solving these type conversion issues.</span></span>

1. <span data-ttu-id="aced9-192">Utilisez des types partagés courants.</span><span class="sxs-lookup"><span data-stu-id="aced9-192">Use common shared types.</span></span> <span data-ttu-id="aced9-193">Ce type partagé peut être soit un type de temps d’exécution primitif, soit il peut impliquer la création d’un nouveau type partagé dans un assemblage partagé.</span><span class="sxs-lookup"><span data-stu-id="aced9-193">This shared type can either be a primitive runtime type, or it can involve creating a new shared type in a shared assembly.</span></span>  <span data-ttu-id="aced9-194">Souvent, le type partagé est une [interface](../../csharp/language-reference/keywords/interface.md) définie dans un assemblage d’applications.</span><span class="sxs-lookup"><span data-stu-id="aced9-194">Often the shared type is an [interface](../../csharp/language-reference/keywords/interface.md) defined in an application assembly.</span></span> <span data-ttu-id="aced9-195">Voir aussi : [Comment les dépendances sont-elles partagées ?](#how-are-dependencies-shared).</span><span class="sxs-lookup"><span data-stu-id="aced9-195">See also: [How are dependencies shared?](#how-are-dependencies-shared).</span></span>

2. <span data-ttu-id="aced9-196">Utilisez des techniques de marshaling pour convertir d’un type à un autre.</span><span class="sxs-lookup"><span data-stu-id="aced9-196">Use marshaling techniques to convert from one type to another.</span></span>
