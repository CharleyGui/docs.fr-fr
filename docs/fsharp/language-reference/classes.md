---
title: Classes
description: 'Découvrez comment les classes F # sont des types qui représentent des objets qui peuvent avoir des propriétés, des méthodes et des événements.'
ms.date: 05/16/2016
ms.openlocfilehash: fd6638e0f1c08cf667a73582e19b2bb5bba46e20
ms.sourcegitcommit: 7ef96827b161ef3fcde75f79d839885632e26ef1
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "97970165"
---
# <a name="classes"></a><span data-ttu-id="569ff-103">Classes</span><span class="sxs-lookup"><span data-stu-id="569ff-103">Classes</span></span>

<span data-ttu-id="569ff-104">Les *classes* sont des types qui représentent des objets qui peuvent avoir des propriétés, des méthodes et des événements.</span><span class="sxs-lookup"><span data-stu-id="569ff-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>

## <a name="syntax"></a><span data-ttu-id="569ff-105">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="569ff-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="569ff-106">Notes</span><span class="sxs-lookup"><span data-stu-id="569ff-106">Remarks</span></span>

<span data-ttu-id="569ff-107">Les classes représentent la Description fondamentale des types d’objets .NET ; la classe est le concept de type principal qui prend en charge la programmation orientée objet en F #.</span><span class="sxs-lookup"><span data-stu-id="569ff-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="569ff-108">Dans la syntaxe précédente, `type-name` est un identificateur valide.</span><span class="sxs-lookup"><span data-stu-id="569ff-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="569ff-109">Le `type-params` décrit des paramètres de type générique facultatifs.</span><span class="sxs-lookup"><span data-stu-id="569ff-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="569ff-110">Il se compose de noms de paramètre de type et de contraintes placés entre crochets pointus ( `<` et `>` ).</span><span class="sxs-lookup"><span data-stu-id="569ff-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="569ff-111">Pour plus d’informations, consultez [génériques](./generics/index.md) et [contraintes](./generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="569ff-111">For more information, see [Generics](./generics/index.md) and [Constraints](./generics/constraints.md).</span></span> <span data-ttu-id="569ff-112">`parameter-list`Décrit les paramètres du constructeur.</span><span class="sxs-lookup"><span data-stu-id="569ff-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="569ff-113">Le premier modificateur d’accès concerne le type ; le deuxième appartient au constructeur principal.</span><span class="sxs-lookup"><span data-stu-id="569ff-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="569ff-114">Dans les deux cas, la valeur par défaut est `public` .</span><span class="sxs-lookup"><span data-stu-id="569ff-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="569ff-115">Vous spécifiez la classe de base pour une classe à l’aide du `inherit` mot clé.</span><span class="sxs-lookup"><span data-stu-id="569ff-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="569ff-116">Vous devez fournir des arguments entre parenthèses pour le constructeur de classe de base.</span><span class="sxs-lookup"><span data-stu-id="569ff-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="569ff-117">Vous déclarez des champs ou des valeurs de fonction qui sont locaux à la classe en utilisant des `let` liaisons, et vous devez suivre les règles générales pour les `let` liaisons.</span><span class="sxs-lookup"><span data-stu-id="569ff-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="569ff-118">La `do-bindings` section comprend le code à exécuter lors de la construction de l’objet.</span><span class="sxs-lookup"><span data-stu-id="569ff-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="569ff-119">Le `member-list` se compose de constructeurs supplémentaires, de déclarations de méthode statiques et d’instance, de déclarations d’interface, de liaisons abstraites et de déclarations de propriété et d’événement.</span><span class="sxs-lookup"><span data-stu-id="569ff-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="569ff-120">Celles-ci sont décrites dans [membres](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="569ff-120">These are described in [Members](./members/index.md).</span></span>

<span data-ttu-id="569ff-121">Le `identifier` utilisé avec le `as` mot clé facultatif donne un nom à la variable d’instance, ou à un auto-identificateur, qui peut être utilisé dans la définition de type pour faire référence à l’instance du type.</span><span class="sxs-lookup"><span data-stu-id="569ff-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="569ff-122">Pour plus d’informations, consultez la section auto Identifiers plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="569ff-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="569ff-123">Les mots clés `class` et `end` qui marquent le début et la fin de la définition sont facultatifs.</span><span class="sxs-lookup"><span data-stu-id="569ff-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="569ff-124">Les types mutuellement récursifs, qui sont des types qui se référencent mutuellement, sont joints au `and` mot clé, tout comme les fonctions mutuellement récursives.</span><span class="sxs-lookup"><span data-stu-id="569ff-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="569ff-125">Pour obtenir un exemple, consultez la section types mutuellement récursifs.</span><span class="sxs-lookup"><span data-stu-id="569ff-125">For an example, see the section Mutually Recursive Types.</span></span>

## <a name="constructors"></a><span data-ttu-id="569ff-126">Constructeurs</span><span class="sxs-lookup"><span data-stu-id="569ff-126">Constructors</span></span>

<span data-ttu-id="569ff-127">Le constructeur est du code qui crée une instance du type de classe.</span><span class="sxs-lookup"><span data-stu-id="569ff-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="569ff-128">Les constructeurs pour les classes fonctionnent un peu différemment en F # et dans d’autres langages .NET.</span><span class="sxs-lookup"><span data-stu-id="569ff-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="569ff-129">Dans une classe F #, il y a toujours un constructeur principal dont les arguments sont décrits dans le `parameter-list` qui suit le nom de type, et dont le corps se compose des `let` liaisons (et `let rec` ) au début de la déclaration de classe et des `do` liaisons qui suivent.</span><span class="sxs-lookup"><span data-stu-id="569ff-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="569ff-130">Les arguments du constructeur principal sont dans la portée tout au long de la déclaration de classe.</span><span class="sxs-lookup"><span data-stu-id="569ff-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="569ff-131">Vous pouvez ajouter des constructeurs supplémentaires en utilisant le `new` mot clé pour ajouter un membre, comme suit :</span><span class="sxs-lookup"><span data-stu-id="569ff-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="569ff-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="569ff-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="569ff-133">Le corps du nouveau constructeur doit appeler le constructeur principal qui est spécifié en haut de la déclaration de classe.</span><span class="sxs-lookup"><span data-stu-id="569ff-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="569ff-134">L’exemple suivant illustre ce concept.</span><span class="sxs-lookup"><span data-stu-id="569ff-134">The following example illustrates this concept.</span></span> <span data-ttu-id="569ff-135">Dans le code suivant, `MyClass` a deux constructeurs, un constructeur principal qui prend deux arguments et un autre constructeur qui ne prend pas d’arguments.</span><span class="sxs-lookup"><span data-stu-id="569ff-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a><span data-ttu-id="569ff-136">Liaisons Let et do</span><span class="sxs-lookup"><span data-stu-id="569ff-136">let and do Bindings</span></span>

<span data-ttu-id="569ff-137">Les `let` `do` liaisons et dans une définition de classe forment le corps du constructeur de classe primaire, et par conséquent, elles s’exécutent chaque fois qu’une instance de classe est créée.</span><span class="sxs-lookup"><span data-stu-id="569ff-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="569ff-138">Si une `let` liaison est une fonction, elle est compilée dans un membre.</span><span class="sxs-lookup"><span data-stu-id="569ff-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="569ff-139">Si la `let` liaison est une valeur qui n’est pas utilisée dans une fonction ou un membre, elle est compilée dans une variable locale pour le constructeur.</span><span class="sxs-lookup"><span data-stu-id="569ff-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="569ff-140">Dans le cas contraire, elle est compilée dans un champ de la classe.</span><span class="sxs-lookup"><span data-stu-id="569ff-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="569ff-141">Les `do` expressions qui suivent sont compilées dans le constructeur principal et exécutent le code d’initialisation pour chaque instance.</span><span class="sxs-lookup"><span data-stu-id="569ff-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="569ff-142">Étant donné que tous les constructeurs supplémentaires appellent toujours le constructeur principal, les `let` liaisons et les `do` liaisons s’exécutent toujours quel que soit le constructeur appelé.</span><span class="sxs-lookup"><span data-stu-id="569ff-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="569ff-143">Les champs créés par des `let` liaisons sont accessibles dans l’ensemble des méthodes et des propriétés de la classe ; Toutefois, ils ne sont pas accessibles à partir de méthodes statiques, même si les méthodes statiques prennent une variable d’instance comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="569ff-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="569ff-144">Ils ne sont pas accessibles à l’aide de l’auto-identificateur, s’il en existe un.</span><span class="sxs-lookup"><span data-stu-id="569ff-144">They cannot be accessed by using the self identifier, if one exists.</span></span>

## <a name="self-identifiers"></a><span data-ttu-id="569ff-145">Identificateurs automatiques</span><span class="sxs-lookup"><span data-stu-id="569ff-145">Self Identifiers</span></span>

<span data-ttu-id="569ff-146">Un *auto-identificateur* est un nom qui représente l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="569ff-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="569ff-147">Les auto-identificateurs ressemblent au `this` mot clé en C# ou C++ ou `Me` dans Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="569ff-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="569ff-148">Vous pouvez définir un auto-identificateur de deux manières différentes, selon que vous souhaitez que l’auto-identificateur soit dans la portée de la définition de classe entière ou uniquement pour une méthode individuelle.</span><span class="sxs-lookup"><span data-stu-id="569ff-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="569ff-149">Pour définir un auto-identificateur pour l’ensemble de la classe, utilisez le `as` mot clé après les parenthèses fermantes de la liste de paramètres du constructeur et spécifiez le nom de l’identificateur.</span><span class="sxs-lookup"><span data-stu-id="569ff-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="569ff-150">Pour définir un auto-identificateur pour une seule méthode, fournissez l’auto-identificateur dans la déclaration de membre, juste avant le nom de la méthode et un point (.) comme séparateur.</span><span class="sxs-lookup"><span data-stu-id="569ff-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="569ff-151">L’exemple de code suivant illustre les deux façons de créer un auto-identificateur.</span><span class="sxs-lookup"><span data-stu-id="569ff-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="569ff-152">Dans la première ligne, le `as` mot clé est utilisé pour définir l’auto-identificateur.</span><span class="sxs-lookup"><span data-stu-id="569ff-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="569ff-153">Dans la cinquième ligne, l’identificateur `this` est utilisé pour définir un auto-identificateur dont la portée est limitée à la méthode `PrintMessage` .</span><span class="sxs-lookup"><span data-stu-id="569ff-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="569ff-154">Contrairement à d’autres langages .NET, vous pouvez nommer l’auto-identificateur comme vous le souhaitez. vous n’êtes pas limité à des noms tels que `self` , `Me` ou `this` .</span><span class="sxs-lookup"><span data-stu-id="569ff-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="569ff-155">L’auto-identificateur qui est déclaré avec le `as` mot clé n’est pas initialisé avant le constructeur de base.</span><span class="sxs-lookup"><span data-stu-id="569ff-155">The self identifier that is declared with the `as` keyword is not initialized until after the base constructor.</span></span> <span data-ttu-id="569ff-156">Par conséquent, lorsqu’il est utilisé avant ou à l’intérieur du constructeur de base, `System.InvalidOperationException: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.` est déclenché pendant l’exécution.</span><span class="sxs-lookup"><span data-stu-id="569ff-156">Therefore, when used before or inside the base constructor, `System.InvalidOperationException: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.` will be raised during runtime.</span></span> <span data-ttu-id="569ff-157">Vous pouvez utiliser l’auto-identificateur librement après le constructeur de base, par exemple dans les `let` liaisons ou `do` liaisons.</span><span class="sxs-lookup"><span data-stu-id="569ff-157">You can use the self identifier freely after the base constructor, such as in `let` bindings or `do` bindings.</span></span>

## <a name="generic-type-parameters"></a><span data-ttu-id="569ff-158">Paramètres de type générique</span><span class="sxs-lookup"><span data-stu-id="569ff-158">Generic Type Parameters</span></span>

<span data-ttu-id="569ff-159">Les paramètres de type générique sont spécifiés entre crochets pointus ( `<` et `>` ), sous la forme d’un guillemet simple suivi d’un identificateur.</span><span class="sxs-lookup"><span data-stu-id="569ff-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="569ff-160">Plusieurs paramètres de type générique sont séparés par des virgules.</span><span class="sxs-lookup"><span data-stu-id="569ff-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="569ff-161">Le paramètre de type générique est dans la portée tout au long de la déclaration.</span><span class="sxs-lookup"><span data-stu-id="569ff-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="569ff-162">L’exemple de code suivant montre comment spécifier des paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="569ff-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="569ff-163">Les arguments de type sont déduits lorsque le type est utilisé.</span><span class="sxs-lookup"><span data-stu-id="569ff-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="569ff-164">Dans le code suivant, le type inféré est une séquence de tuples.</span><span class="sxs-lookup"><span data-stu-id="569ff-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a><span data-ttu-id="569ff-165">Spécification de l’héritage</span><span class="sxs-lookup"><span data-stu-id="569ff-165">Specifying Inheritance</span></span>

<span data-ttu-id="569ff-166">La `inherit` clause identifie la classe de base directe, le cas échéant.</span><span class="sxs-lookup"><span data-stu-id="569ff-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="569ff-167">En F #, une seule classe de base directe est autorisée.</span><span class="sxs-lookup"><span data-stu-id="569ff-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="569ff-168">Les interfaces qu’une classe implémente ne sont pas considérées comme des classes de base.</span><span class="sxs-lookup"><span data-stu-id="569ff-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="569ff-169">Les interfaces sont présentées dans la rubrique [interfaces](Interfaces.md) .</span><span class="sxs-lookup"><span data-stu-id="569ff-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="569ff-170">Vous pouvez accéder aux méthodes et aux propriétés de la classe de base à partir de la classe dérivée en utilisant le mot clé Language `base` comme identificateur, suivi d’un point (.) et du nom du membre.</span><span class="sxs-lookup"><span data-stu-id="569ff-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="569ff-171">Pour plus d’informations, consultez [Héritage](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="569ff-171">For more information, see [Inheritance](inheritance.md).</span></span>

## <a name="members-section"></a><span data-ttu-id="569ff-172">Section membres</span><span class="sxs-lookup"><span data-stu-id="569ff-172">Members Section</span></span>

<span data-ttu-id="569ff-173">Vous pouvez définir des méthodes statiques ou d’instance, des propriétés, des implémentations d’interface, des membres abstraits, des déclarations d’événements et des constructeurs supplémentaires dans cette section.</span><span class="sxs-lookup"><span data-stu-id="569ff-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="569ff-174">Les liaisons Let et do ne peuvent pas apparaître dans cette section.</span><span class="sxs-lookup"><span data-stu-id="569ff-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="569ff-175">Étant donné que les membres peuvent être ajoutés à divers types F # en plus des classes, ils sont décrits dans une rubrique distincte, [membres](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="569ff-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](./members/index.md).</span></span>

## <a name="mutually-recursive-types"></a><span data-ttu-id="569ff-176">Types mutuellement récursifs</span><span class="sxs-lookup"><span data-stu-id="569ff-176">Mutually Recursive Types</span></span>

<span data-ttu-id="569ff-177">Quand vous définissez des types qui font référence les uns aux autres de manière circulaire, vous associez les définitions de type à l’aide du `and` mot clé.</span><span class="sxs-lookup"><span data-stu-id="569ff-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="569ff-178">Le `and` mot clé remplace le `type` mot clé sur tous les autres définitions, à l’exception de la première définition, comme suit.</span><span class="sxs-lookup"><span data-stu-id="569ff-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="569ff-179">La sortie est une liste de tous les fichiers dans le répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="569ff-179">The output is a list of all the files in the current directory.</span></span>

## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="569ff-180">Quand utiliser des classes, des unions, des enregistrements et des structures</span><span class="sxs-lookup"><span data-stu-id="569ff-180">When to Use Classes, Unions, Records, and Structures</span></span>

<span data-ttu-id="569ff-181">Étant donné la variété des types à choisir, vous devez avoir une bonne compréhension de ce à quoi chaque type est conçu pour sélectionner le type approprié pour une situation particulière.</span><span class="sxs-lookup"><span data-stu-id="569ff-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="569ff-182">Les classes sont conçues pour une utilisation dans des contextes de programmation orientés objet.</span><span class="sxs-lookup"><span data-stu-id="569ff-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="569ff-183">La programmation orientée objet est le paradigme dominant utilisé dans les applications écrites pour le .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="569ff-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="569ff-184">Si votre code F # doit fonctionner étroitement avec la .NET Framework ou une autre bibliothèque orientée objet, et en particulier si vous devez étendre à partir d’un système de type orienté objet tel qu’une bibliothèque d’interface utilisateur, les classes sont probablement appropriées.</span><span class="sxs-lookup"><span data-stu-id="569ff-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="569ff-185">Si vous n’interopèrez pas étroitement avec le code orienté objet, ou si vous écrivez du code autonome qui, par conséquent, est protégé contre les interactions fréquentes avec le code orienté objet, vous devez envisager d’utiliser des enregistrements et des unions discriminées.</span><span class="sxs-lookup"><span data-stu-id="569ff-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="569ff-186">Une union discriminée unique et bien pensée, associée au code de correspondance de modèle approprié, peut souvent être utilisée comme une alternative plus simple à une hiérarchie d’objets.</span><span class="sxs-lookup"><span data-stu-id="569ff-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="569ff-187">Pour plus d’informations sur les unions discriminées, consultez [unions discriminées](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="569ff-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="569ff-188">Les enregistrements présentent l’avantage d’être plus simples que les classes, mais les enregistrements ne sont pas appropriés lorsque les demandes d’un type dépassent ce qui peut être accompli avec leur simplicité.</span><span class="sxs-lookup"><span data-stu-id="569ff-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="569ff-189">Les enregistrements sont fondamentalement des agrégats simples de valeurs, sans constructeurs distincts qui peuvent exécuter des actions personnalisées, sans champs masqués, et sans implémentations d’héritage ou d’interface.</span><span class="sxs-lookup"><span data-stu-id="569ff-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="569ff-190">Bien que les membres tels que les propriétés et les méthodes puissent être ajoutés aux enregistrements pour rendre leur comportement plus complexe, les champs stockés dans un enregistrement sont toujours un simple agrégat de valeurs.</span><span class="sxs-lookup"><span data-stu-id="569ff-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="569ff-191">Pour plus d’informations sur les enregistrements, consultez [enregistrements](records.md).</span><span class="sxs-lookup"><span data-stu-id="569ff-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="569ff-192">Les structures sont également utiles pour les petits agrégats de données, mais elles diffèrent des classes et des enregistrements dans le cas où il s’agit de types valeur .NET.</span><span class="sxs-lookup"><span data-stu-id="569ff-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="569ff-193">Les classes et les enregistrements sont des types référence .NET.</span><span class="sxs-lookup"><span data-stu-id="569ff-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="569ff-194">La sémantique des types valeur et des types référence est différente dans le fait que les types valeur sont passés par valeur.</span><span class="sxs-lookup"><span data-stu-id="569ff-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="569ff-195">Cela signifie qu’ils sont copiés bit par bit lorsqu’ils sont passés en tant que paramètres ou retournés par une fonction.</span><span class="sxs-lookup"><span data-stu-id="569ff-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="569ff-196">Ils sont également stockés sur la pile ou, s’ils sont utilisés en tant que champ, incorporés à l’intérieur de l’objet parent au lieu d’être stockés dans leur propre emplacement distinct sur le tas.</span><span class="sxs-lookup"><span data-stu-id="569ff-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="569ff-197">Par conséquent, les structures sont appropriées pour les données fréquemment sollicitées lorsque la surcharge liée à l’accès au segment de mémoire est un problème.</span><span class="sxs-lookup"><span data-stu-id="569ff-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="569ff-198">Pour plus d’informations sur les structures, consultez [structures](structures.md).</span><span class="sxs-lookup"><span data-stu-id="569ff-198">For more information about structures, see [Structures](structures.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="569ff-199">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="569ff-199">See also</span></span>

- [<span data-ttu-id="569ff-200">Informations de référence sur le langage F #</span><span class="sxs-lookup"><span data-stu-id="569ff-200">F# Language Reference</span></span>](index.md)
- <span data-ttu-id="569ff-201">[Members](./members/index.md) (Membres)</span><span class="sxs-lookup"><span data-stu-id="569ff-201">[Members](./members/index.md)</span></span>
- [<span data-ttu-id="569ff-202">Héritage</span><span class="sxs-lookup"><span data-stu-id="569ff-202">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="569ff-203">Interfaces</span><span class="sxs-lookup"><span data-stu-id="569ff-203">Interfaces</span></span>](interfaces.md)
