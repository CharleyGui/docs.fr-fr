---
title: Séquences
description: Apprenez à utiliser F# des séquences, lorsque vous disposez d’une collection de données volumineuse et ordonnée, mais que vous n’envisagez pas nécessairement d’utiliser tous les éléments.
ms.date: 11/04/2019
ms.openlocfilehash: 34e03f1cead0a9f678f637afcb6c8397ef7572bc
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/12/2019
ms.locfileid: "73971443"
---
# <a name="sequences"></a><span data-ttu-id="5851f-103">Séquences</span><span class="sxs-lookup"><span data-stu-id="5851f-103">Sequences</span></span>

> [!NOTE]
> <span data-ttu-id="5851f-104">Les liens des informations de référence sur les API qui figurent dans cet article pointent vers MSDN.</span><span class="sxs-lookup"><span data-stu-id="5851f-104">The API reference links in this article will take you to MSDN.</span></span>  <span data-ttu-id="5851f-105">Les informations de référence sur les API docs.microsoft.com ne sont pas terminées.</span><span class="sxs-lookup"><span data-stu-id="5851f-105">The docs.microsoft.com API reference is not complete.</span></span>

<span data-ttu-id="5851f-106">Une *séquence* est une série logique d’éléments d’un seul type.</span><span class="sxs-lookup"><span data-stu-id="5851f-106">A *sequence* is a logical series of elements all of one type.</span></span> <span data-ttu-id="5851f-107">Les séquences sont particulièrement utiles lorsque vous disposez d’une collection de données volumineuse et ordonnée, mais que vous n’envisagez pas nécessairement d’utiliser tous les éléments.</span><span class="sxs-lookup"><span data-stu-id="5851f-107">Sequences are particularly useful when you have a large, ordered collection of data but do not necessarily expect to use all of the elements.</span></span> <span data-ttu-id="5851f-108">Les éléments de séquence individuels sont calculés uniquement en fonction des besoins, de sorte qu’une séquence peut fournir de meilleures performances qu’une liste dans les cas où tous les éléments ne sont pas utilisés.</span><span class="sxs-lookup"><span data-stu-id="5851f-108">Individual sequence elements are computed only as required, so a sequence can provide better performance than a list in situations in which not all the elements are used.</span></span> <span data-ttu-id="5851f-109">Les séquences sont représentées par le type de `seq<'T>`, qui est un alias pour <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="5851f-109">Sequences are represented by the `seq<'T>` type, which is an alias for <xref:System.Collections.Generic.IEnumerable%601>.</span></span> <span data-ttu-id="5851f-110">Par conséquent, tout type .NET qui implémente <xref:System.Collections.Generic.IEnumerable%601> interface peut être utilisé comme une séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-110">Therefore, any .NET type that implements <xref:System.Collections.Generic.IEnumerable%601> interface can be used as a sequence.</span></span> <span data-ttu-id="5851f-111">Le [module Seq](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) assure la prise en charge des manipulations impliquant des séquences.</span><span class="sxs-lookup"><span data-stu-id="5851f-111">The [Seq module](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) provides support for manipulations involving sequences.</span></span>

## <a name="sequence-expressions"></a><span data-ttu-id="5851f-112">Expressions de séquence</span><span class="sxs-lookup"><span data-stu-id="5851f-112">Sequence Expressions</span></span>

<span data-ttu-id="5851f-113">Une *expression de séquence* est une expression qui prend la valeur d’une séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-113">A *sequence expression* is an expression that evaluates to a sequence.</span></span> <span data-ttu-id="5851f-114">Les expressions de séquence peuvent prendre plusieurs formes.</span><span class="sxs-lookup"><span data-stu-id="5851f-114">Sequence expressions can take a number of forms.</span></span> <span data-ttu-id="5851f-115">La forme la plus simple spécifie une plage.</span><span class="sxs-lookup"><span data-stu-id="5851f-115">The simplest form specifies a range.</span></span> <span data-ttu-id="5851f-116">Par exemple, `seq { 1 .. 5 }` crée une séquence qui contient cinq éléments, y compris les points de terminaison 1 et 5.</span><span class="sxs-lookup"><span data-stu-id="5851f-116">For example, `seq { 1 .. 5 }` creates a sequence that contains five elements, including the endpoints 1 and 5.</span></span> <span data-ttu-id="5851f-117">Vous pouvez également spécifier un incrément (ou une décrémentation) entre deux points doubles.</span><span class="sxs-lookup"><span data-stu-id="5851f-117">You can also specify an increment (or decrement) between two double periods.</span></span> <span data-ttu-id="5851f-118">Par exemple, le code suivant crée la séquence de multiples de 10.</span><span class="sxs-lookup"><span data-stu-id="5851f-118">For example, the following code creates the sequence of multiples of 10.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1502.fs)]

<span data-ttu-id="5851f-119">Les expressions de séquence sont constituées d' F# expressions qui produisent des valeurs de la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-119">Sequence expressions are made up of F# expressions that produce values of the sequence.</span></span> <span data-ttu-id="5851f-120">Vous pouvez également générer des valeurs par programmation :</span><span class="sxs-lookup"><span data-stu-id="5851f-120">You can also generate values programmatically:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1503.fs)]

<span data-ttu-id="5851f-121">L’exemple précédent utilise l’opérateur `->`, qui vous permet de spécifier une expression dont la valeur va devenir une partie de la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-121">The previous sample uses the `->` operator, which allows you to specify an expression whose value will become a part of the sequence.</span></span> <span data-ttu-id="5851f-122">Vous pouvez uniquement utiliser `->` si chaque partie du code qui le suit retourne une valeur.</span><span class="sxs-lookup"><span data-stu-id="5851f-122">You can only use `->` if every part of the code that follows it returns a value.</span></span>

<span data-ttu-id="5851f-123">Vous pouvez également spécifier le mot clé `do`, avec un `yield` facultatif qui suit :</span><span class="sxs-lookup"><span data-stu-id="5851f-123">Alternatively, you can specify the `do` keyword, with an optional `yield` that follows:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1504.fs)]

<span data-ttu-id="5851f-124">Le code suivant génère une liste de paires de coordonnées, ainsi qu’un index dans un tableau qui représente la grille.</span><span class="sxs-lookup"><span data-stu-id="5851f-124">The following code generates a list of coordinate pairs along with an index into an array that represents the grid.</span></span> <span data-ttu-id="5851f-125">Notez que la première expression de `for` nécessite la spécification d’une `do`.</span><span class="sxs-lookup"><span data-stu-id="5851f-125">Note that the first `for` expression requires a `do` to be specified.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1505.fs)]

<span data-ttu-id="5851f-126">Une expression `if` utilisée dans une séquence est un filtre.</span><span class="sxs-lookup"><span data-stu-id="5851f-126">An `if` expression used in a sequence is a filter.</span></span> <span data-ttu-id="5851f-127">Par exemple, pour générer une séquence de nombres premiers uniquement, en supposant que vous avez une fonction `isprime` de type `int -> bool`, construisez la séquence comme suit.</span><span class="sxs-lookup"><span data-stu-id="5851f-127">For example, to generate a sequence of only prime numbers, assuming that you have a function `isprime` of type `int -> bool`, construct the sequence as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1506.fs)]

<span data-ttu-id="5851f-128">Comme nous l’avons vu précédemment, `do` est nécessaire ici, car il n’existe aucune branche `else` qui accompagne le `if`.</span><span class="sxs-lookup"><span data-stu-id="5851f-128">As mentioned previously, `do` is required here because there is no `else` branch that goes with the `if`.</span></span> <span data-ttu-id="5851f-129">Si vous essayez d’utiliser `->`, vous obtenez une erreur indiquant que toutes les branches ne retournent pas de valeur.</span><span class="sxs-lookup"><span data-stu-id="5851f-129">If you try to use `->`, you'll get an error saying that not all branches return a value.</span></span>

## <a name="the-yield-keyword"></a><span data-ttu-id="5851f-130">Mot clé `yield!`</span><span class="sxs-lookup"><span data-stu-id="5851f-130">The `yield!` keyword</span></span>

<span data-ttu-id="5851f-131">Parfois, vous souhaiterez peut-être inclure une séquence d’éléments dans une autre séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-131">Sometimes, you may wish to include a sequence of elements into another sequence.</span></span> <span data-ttu-id="5851f-132">Pour inclure une séquence dans une autre séquence, vous devez utiliser le mot clé `yield!` :</span><span class="sxs-lookup"><span data-stu-id="5851f-132">To include a sequence within another sequence, you'll need to use the `yield!` keyword:</span></span>

```fsharp
// Repeats '1 2 3 4 5' ten times
seq {
    for _ in 1..10 do
        yield! seq { 1; 2; 3; 4; 5}
}
```

<span data-ttu-id="5851f-133">Une autre façon de penser à `yield!` est qu’elle aplatit une séquence interne, puis l’intègre dans la séquence contenante.</span><span class="sxs-lookup"><span data-stu-id="5851f-133">Another way of thinking of `yield!` is that it flattens an inner sequence and then includes that in the containing sequence.</span></span>

<span data-ttu-id="5851f-134">Lorsque `yield!` est utilisé dans une expression, toutes les autres valeurs uniques doivent utiliser le mot clé `yield` :</span><span class="sxs-lookup"><span data-stu-id="5851f-134">When `yield!` is used in an expression, all other single values must use the `yield` keyword:</span></span>

```fsharp
// Combine repeated values with their values
seq {
    for x in 1..10 do
        yield x
        yield! seq { for i in 1..x -> i}
}
```

<span data-ttu-id="5851f-135">Si vous spécifiez uniquement `x` dans l’exemple précédent, la séquence ne générant aucune valeur est générée.</span><span class="sxs-lookup"><span data-stu-id="5851f-135">Specifying only `x` in the previous example will result in the sequence generating no values.</span></span>

## <a name="examples"></a><span data-ttu-id="5851f-136">Exemples</span><span class="sxs-lookup"><span data-stu-id="5851f-136">Examples</span></span>

<span data-ttu-id="5851f-137">Le premier exemple utilise une expression de séquence qui contient une itération, un filtre et un yield pour générer un tableau.</span><span class="sxs-lookup"><span data-stu-id="5851f-137">The first example uses a sequence expression that contains an iteration, a filter, and a yield to generate an array.</span></span> <span data-ttu-id="5851f-138">Ce code imprime une séquence de nombres premiers entre 1 et 100 sur la console.</span><span class="sxs-lookup"><span data-stu-id="5851f-138">This code prints a sequence of prime numbers between 1 and 100 to the console.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1507.fs)]

<span data-ttu-id="5851f-139">L’exemple suivant crée une table de multiplication qui se compose de tuples de trois éléments, chacun comprenant deux facteurs et le produit :</span><span class="sxs-lookup"><span data-stu-id="5851f-139">The following example creates a multiplication table that consists of tuples of three elements, each consisting of two factors and the product:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1508.fs)]

<span data-ttu-id="5851f-140">L’exemple suivant illustre l’utilisation de `yield!` pour combiner des séquences individuelles en une seule séquence finale.</span><span class="sxs-lookup"><span data-stu-id="5851f-140">The following example demonstrates the use of `yield!` to combine individual sequences into a single final sequence.</span></span> <span data-ttu-id="5851f-141">Dans ce cas, les séquences pour chaque sous-arborescence d’une arborescence binaire sont concaténées dans une fonction récursive pour produire la séquence finale.</span><span class="sxs-lookup"><span data-stu-id="5851f-141">In this case, the sequences for each subtree in a binary tree are concatenated in a recursive function to produce the final sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1509.fs)]

## <a name="using-sequences"></a><span data-ttu-id="5851f-142">Utilisation de séquences</span><span class="sxs-lookup"><span data-stu-id="5851f-142">Using Sequences</span></span>

<span data-ttu-id="5851f-143">Les séquences prennent en charge un grand nombre des mêmes fonctions que les [listes](lists.md).</span><span class="sxs-lookup"><span data-stu-id="5851f-143">Sequences support many of the same functions as [lists](lists.md).</span></span> <span data-ttu-id="5851f-144">Les séquences prennent également en charge des opérations telles que le regroupement et le comptage à l’aide de fonctions génératrices de clé.</span><span class="sxs-lookup"><span data-stu-id="5851f-144">Sequences also support operations such as grouping and counting by using key-generating functions.</span></span> <span data-ttu-id="5851f-145">Les séquences prennent également en charge des fonctions plus variées pour l’extraction de sous-séquences.</span><span class="sxs-lookup"><span data-stu-id="5851f-145">Sequences also support more diverse functions for extracting subsequences.</span></span>

<span data-ttu-id="5851f-146">De nombreux types de données, tels que les listes, les tableaux, les jeux et les mappages sont implicitement des séquences, car il s’agit de collections énumérables.</span><span class="sxs-lookup"><span data-stu-id="5851f-146">Many data types, such as lists, arrays, sets, and maps are implicitly sequences because they are enumerable collections.</span></span> <span data-ttu-id="5851f-147">Une fonction qui prend une séquence comme argument fonctionne avec l’un des types de F# données courants, en plus de tout type de données .net qui implémente `System.Collections.Generic.IEnumerable<'T>`.</span><span class="sxs-lookup"><span data-stu-id="5851f-147">A function that takes a sequence as an argument works with any of the common F# data types, in addition to any .NET data type that implements `System.Collections.Generic.IEnumerable<'T>`.</span></span> <span data-ttu-id="5851f-148">Comparez ce à une fonction qui prend une liste comme argument, qui peut uniquement prendre des listes.</span><span class="sxs-lookup"><span data-stu-id="5851f-148">Contrast this to a function that takes a list as an argument, which can only take lists.</span></span> <span data-ttu-id="5851f-149">Le type `seq<'T>` est une abréviation de type pour `IEnumerable<'T>`.</span><span class="sxs-lookup"><span data-stu-id="5851f-149">The type `seq<'T>` is a type abbreviation for `IEnumerable<'T>`.</span></span> <span data-ttu-id="5851f-150">Cela signifie que tout type qui implémente le `System.Collections.Generic.IEnumerable<'T>`générique, qui comprend des tableaux, des listes, des ensembles et des F#mappages dans, ainsi que la plupart des types de collections .net, est compatible avec le type de `seq` et peut être utilisé partout où une séquence est attendue.</span><span class="sxs-lookup"><span data-stu-id="5851f-150">This means that any type that implements the generic `System.Collections.Generic.IEnumerable<'T>`, which includes arrays, lists, sets, and maps in F#, and also most .NET collection types, is compatible with the `seq` type and can be used wherever a sequence is expected.</span></span>

## <a name="module-functions"></a><span data-ttu-id="5851f-151">Fonctions de module</span><span class="sxs-lookup"><span data-stu-id="5851f-151">Module Functions</span></span>

<span data-ttu-id="5851f-152">Le [module Seq](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) de l' [espace de noms Microsoft. FSharp. Collections](https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f) contient des fonctions permettant d’utiliser des séquences.</span><span class="sxs-lookup"><span data-stu-id="5851f-152">The [Seq module](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) in the [Microsoft.FSharp.Collections namespace](https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f) contains functions for working with sequences.</span></span> <span data-ttu-id="5851f-153">Ces fonctions fonctionnent également avec des listes, des tableaux, des mappages et des jeux, car tous ces types sont énumérables et peuvent donc être traités comme des séquences.</span><span class="sxs-lookup"><span data-stu-id="5851f-153">These functions work with lists, arrays, maps, and sets as well, because all of those types are enumerable, and therefore can be treated as sequences.</span></span>

## <a name="creating-sequences"></a><span data-ttu-id="5851f-154">Création de séquences</span><span class="sxs-lookup"><span data-stu-id="5851f-154">Creating Sequences</span></span>

<span data-ttu-id="5851f-155">Vous pouvez créer des séquences à l’aide d’expressions de séquence, comme décrit précédemment, ou à l’aide de certaines fonctions.</span><span class="sxs-lookup"><span data-stu-id="5851f-155">You can create sequences by using sequence expressions, as described previously, or by using certain functions.</span></span>

<span data-ttu-id="5851f-156">Vous pouvez créer une séquence vide à l’aide de [Seq. Empty](https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59), ou vous pouvez créer une séquence d’un seul élément spécifié à l’aide de [Seq. Singleton](https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7).</span><span class="sxs-lookup"><span data-stu-id="5851f-156">You can create an empty sequence by using [Seq.empty](https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59), or you can create a sequence of just one specified element by using [Seq.singleton](https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7).</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet9.fs)]

<span data-ttu-id="5851f-157">Vous pouvez utiliser [Seq. init](https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576) pour créer une séquence pour laquelle les éléments sont créés à l’aide d’une fonction que vous fournissez.</span><span class="sxs-lookup"><span data-stu-id="5851f-157">You can use [Seq.init](https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576) to create a sequence for which the elements are created by using a function that you provide.</span></span> <span data-ttu-id="5851f-158">Vous fournissez également une taille pour la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-158">You also provide a size for the sequence.</span></span> <span data-ttu-id="5851f-159">Cette fonction est similaire à [List. init](https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83), sauf que les éléments ne sont pas créés tant que vous n’effectuez pas une itération au sein de la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-159">This function is just like [List.init](https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83), except that the elements are not created until you iterate through the sequence.</span></span> <span data-ttu-id="5851f-160">Le code suivant illustre l’utilisation de `Seq.init`.</span><span class="sxs-lookup"><span data-stu-id="5851f-160">The following code illustrates the use of `Seq.init`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet10.fs)]

<span data-ttu-id="5851f-161">La sortie est la suivante :</span><span class="sxs-lookup"><span data-stu-id="5851f-161">The output is</span></span>

```console
0 10 20 30 40
```

<span data-ttu-id="5851f-162">À l’aide de la [&#60;&#62; fonction](https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d) [Seq. ofArray](https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99) et seq. ofList, vous pouvez créer des séquences à partir de tableaux et de listes.</span><span class="sxs-lookup"><span data-stu-id="5851f-162">By using [Seq.ofArray](https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99) and [Seq.ofList&#60;'T&#62; Function](https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d), you can create sequences from arrays and lists.</span></span> <span data-ttu-id="5851f-163">Toutefois, vous pouvez également convertir des tableaux et des listes en séquences à l’aide d’un opérateur de cast.</span><span class="sxs-lookup"><span data-stu-id="5851f-163">However, you can also convert arrays and lists to sequences by using a cast operator.</span></span> <span data-ttu-id="5851f-164">Les deux techniques sont présentées dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="5851f-164">Both techniques are shown in the following code.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet11.fs)]

<span data-ttu-id="5851f-165">En utilisant [Seq. Cast](https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334), vous pouvez créer une séquence à partir d’une collection faiblement typée, telle que celles définies dans `System.Collections`.</span><span class="sxs-lookup"><span data-stu-id="5851f-165">By using [Seq.cast](https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334), you can create a sequence from a weakly typed collection, such as those defined in `System.Collections`.</span></span> <span data-ttu-id="5851f-166">Ces collections faiblement typées ont le type d’élément `System.Object` et sont énumérées à l’aide du type de `System.Collections.Generic.IEnumerable&#96;1` non générique.</span><span class="sxs-lookup"><span data-stu-id="5851f-166">Such weakly typed collections have the element type `System.Object` and are enumerated by using the non-generic `System.Collections.Generic.IEnumerable&#96;1` type.</span></span> <span data-ttu-id="5851f-167">Le code suivant illustre l’utilisation de `Seq.cast` pour convertir un `System.Collections.ArrayList` en séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-167">The following code illustrates the use of `Seq.cast` to convert an `System.Collections.ArrayList` into a sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet12.fs)]

<span data-ttu-id="5851f-168">Vous pouvez définir des séquences infinies à l’aide de la fonction [Seq. initInfinite (](https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef) .</span><span class="sxs-lookup"><span data-stu-id="5851f-168">You can define infinite sequences by using the [Seq.initInfinite](https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef) function.</span></span> <span data-ttu-id="5851f-169">Pour une telle séquence, vous fournissez une fonction qui génère chaque élément à partir de l’index de l’élément.</span><span class="sxs-lookup"><span data-stu-id="5851f-169">For such a sequence, you provide a function that generates each element from the index of the element.</span></span> <span data-ttu-id="5851f-170">Les séquences infinies sont possibles en raison de l’évaluation différée ; les éléments sont créés en fonction des besoins en appelant la fonction que vous spécifiez.</span><span class="sxs-lookup"><span data-stu-id="5851f-170">Infinite sequences are possible because of lazy evaluation; elements are created as needed by calling the function that you specify.</span></span> <span data-ttu-id="5851f-171">L’exemple de code suivant produit une séquence infinie de nombres à virgule flottante, dans ce cas, la série alternative de réciproques de carrés d’entiers successifs.</span><span class="sxs-lookup"><span data-stu-id="5851f-171">The following code example produces an infinite sequence of floating point numbers, in this case the alternating series of reciprocals of squares of successive integers.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet13.fs)]

<span data-ttu-id="5851f-172">[Seq. Unfold](https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21) génère une séquence à partir d’une fonction de calcul qui prend un État et le transforme pour produire chaque élément suivant dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-172">[Seq.unfold](https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21) generates a sequence from a computation function that takes a state and transforms it to produce each subsequent element in the sequence.</span></span> <span data-ttu-id="5851f-173">L’État est simplement une valeur utilisée pour calculer chaque élément et peut changer à mesure que chaque élément est calculé.</span><span class="sxs-lookup"><span data-stu-id="5851f-173">The state is just a value that is used to compute each element, and can change as each element is computed.</span></span> <span data-ttu-id="5851f-174">Le deuxième argument de `Seq.unfold` est la valeur initiale utilisée pour démarrer la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-174">The second argument to `Seq.unfold` is the initial value that is used to start the sequence.</span></span> <span data-ttu-id="5851f-175">`Seq.unfold` utilise un type d’option pour l’État, ce qui vous permet de terminer la séquence en retournant la valeur de `None`.</span><span class="sxs-lookup"><span data-stu-id="5851f-175">`Seq.unfold` uses an option type for the state, which enables you to terminate the sequence by returning the `None` value.</span></span> <span data-ttu-id="5851f-176">Le code suivant illustre deux exemples de séquences, `seq1` et `fib`, qui sont générés par une opération de `unfold`.</span><span class="sxs-lookup"><span data-stu-id="5851f-176">The following code shows two examples of sequences, `seq1` and `fib`, that are generated by an `unfold` operation.</span></span> <span data-ttu-id="5851f-177">La première, `seq1`, est simplement une séquence simple avec des nombres allant jusqu’à 20.</span><span class="sxs-lookup"><span data-stu-id="5851f-177">The first, `seq1`, is just a simple sequence with numbers up to 20.</span></span> <span data-ttu-id="5851f-178">Le deuxième, `fib`, utilise `unfold` pour calculer la séquence de Fibonacci.</span><span class="sxs-lookup"><span data-stu-id="5851f-178">The second, `fib`, uses `unfold` to compute the Fibonacci sequence.</span></span> <span data-ttu-id="5851f-179">Étant donné que chaque élément de la séquence de Fibonacci est la somme des deux nombres de Fibonacci précédents, la valeur d’État est un tuple qui se compose des deux nombres précédents de la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-179">Because each element in the Fibonacci sequence is the sum of the previous two Fibonacci numbers, the state value is a tuple that consists of the previous two numbers in the sequence.</span></span> <span data-ttu-id="5851f-180">La valeur initiale est `(1,1)`, les deux premiers nombres de la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-180">The initial value is `(1,1)`, the first two numbers in the sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet14.fs)]

<span data-ttu-id="5851f-181">La sortie est la suivante :</span><span class="sxs-lookup"><span data-stu-id="5851f-181">The output is as follows:</span></span>

```console
The sequence seq1 contains numbers from 0 to 20.

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

The sequence fib contains Fibonacci numbers.

2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

<span data-ttu-id="5851f-182">Le code suivant est un exemple qui utilise un grand nombre des fonctions de module de séquence décrites ici pour générer et calculer les valeurs de séquences infinies.</span><span class="sxs-lookup"><span data-stu-id="5851f-182">The following code is an example that uses many of the sequence module functions described here to generate and compute the values of infinite sequences.</span></span> <span data-ttu-id="5851f-183">L’exécution du code peut prendre quelques minutes.</span><span class="sxs-lookup"><span data-stu-id="5851f-183">The code might take a few minutes to run.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet15.fs)]

## <a name="searching-and-finding-elements"></a><span data-ttu-id="5851f-184">Recherche et recherche d’éléments</span><span class="sxs-lookup"><span data-stu-id="5851f-184">Searching and Finding Elements</span></span>

<span data-ttu-id="5851f-185">Les séquences prennent en charge les fonctionnalités disponibles avec les listes [Seq. Exists](https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1), [Seq. exists2](https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565), [Seq. Find](https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8), [Seq. FindIndex](https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3), [Seq. Pick](https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d), [Seq. tryFind](https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47)et [Seq. tryFindIndex](https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a).</span><span class="sxs-lookup"><span data-stu-id="5851f-185">Sequences support functionality available with lists: [Seq.exists](https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1), [Seq.exists2](https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565), [Seq.find](https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8), [Seq.findIndex](https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3), [Seq.pick](https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d), [Seq.tryFind](https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47), and [Seq.tryFindIndex](https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a).</span></span> <span data-ttu-id="5851f-186">Les versions de ces fonctions qui sont disponibles pour les séquences évaluent la séquence uniquement jusqu’à l’élément qui fait l’objet de la recherche.</span><span class="sxs-lookup"><span data-stu-id="5851f-186">The versions of these functions that are available for sequences evaluate the sequence only up to the element that is being searched for.</span></span> <span data-ttu-id="5851f-187">Pour obtenir des exemples, consultez [listes](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span><span class="sxs-lookup"><span data-stu-id="5851f-187">For examples, see [Lists](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span></span>

## <a name="obtaining-subsequences"></a><span data-ttu-id="5851f-188">Obtention de sous-séquences</span><span class="sxs-lookup"><span data-stu-id="5851f-188">Obtaining Subsequences</span></span>

<span data-ttu-id="5851f-189">[Seq. Filter](https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770) et [Seq. choose](https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395) sont semblables aux fonctions correspondantes qui sont disponibles pour les listes, sauf que le filtrage et le choix ne se produisent pas tant que les éléments de séquence ne sont pas évalués.</span><span class="sxs-lookup"><span data-stu-id="5851f-189">[Seq.filter](https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770) and [Seq.choose](https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395) are like the corresponding functions that are available for lists, except that the filtering and choosing does not occur until the sequence elements are evaluated.</span></span>

<span data-ttu-id="5851f-190">[Seq. Truncate](https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244) crée une séquence à partir d’une autre séquence, mais limite la séquence à un nombre spécifié d’éléments.</span><span class="sxs-lookup"><span data-stu-id="5851f-190">[Seq.truncate](https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244) creates a sequence from another sequence, but limits the sequence to a specified number of elements.</span></span> <span data-ttu-id="5851f-191">[Seq. Take](https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596) crée une séquence qui contient uniquement un nombre spécifié d’éléments à partir du début d’une séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-191">[Seq.take](https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596) creates a new sequence that contains only a specified number of elements from the start of a sequence.</span></span> <span data-ttu-id="5851f-192">S’il y a moins d’éléments dans la séquence que celui que vous spécifiez pour prendre, `Seq.take` lève une `System.InvalidOperationException`.</span><span class="sxs-lookup"><span data-stu-id="5851f-192">If there are fewer elements in the sequence than you specify to take, `Seq.take` throws a `System.InvalidOperationException`.</span></span> <span data-ttu-id="5851f-193">La différence entre `Seq.take` et `Seq.truncate` est que `Seq.truncate` ne génère pas d’erreur si le nombre d’éléments est inférieur au nombre que vous spécifiez.</span><span class="sxs-lookup"><span data-stu-id="5851f-193">The difference between `Seq.take` and `Seq.truncate` is that `Seq.truncate` does not produce an error if the number of elements is fewer than the number you specify.</span></span>

<span data-ttu-id="5851f-194">Le code suivant illustre le comportement de et les différences entre `Seq.truncate` et `Seq.take`.</span><span class="sxs-lookup"><span data-stu-id="5851f-194">The following code shows the behavior of and differences between `Seq.truncate` and `Seq.take`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet16.fs)]

<span data-ttu-id="5851f-195">La sortie, avant l’erreur, se présente comme suit.</span><span class="sxs-lookup"><span data-stu-id="5851f-195">The output, before the error occurs, is as follows.</span></span>

```console
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
```

<span data-ttu-id="5851f-196">En utilisant [Seq. TakeWhile](https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92), vous pouvez spécifier une fonction de prédicat (fonction booléenne) et créer une séquence à partir d’une autre séquence composée de ces éléments de la séquence d’origine pour laquelle le prédicat est `true`, mais s’arrêter avant le premier élément de que le prédicat retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="5851f-196">By using [Seq.takeWhile](https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92), you can specify a predicate function (a Boolean function) and create a sequence from another sequence made up of those elements of the original sequence for which the predicate is `true`, but stop before the first element for which the predicate returns `false`.</span></span> <span data-ttu-id="5851f-197">[Seq. Skip](https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1) retourne une séquence qui ignore un nombre spécifié de premiers éléments d’une autre séquence et retourne les éléments restants.</span><span class="sxs-lookup"><span data-stu-id="5851f-197">[Seq.skip](https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1) returns a sequence that skips a specified number of the first elements of another sequence and returns the remaining elements.</span></span> <span data-ttu-id="5851f-198">[Seq. SkipWhile](https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16) retourne une séquence qui ignore les premiers éléments d’une autre séquence tant que le prédicat retourne `true`, puis retourne les éléments restants, en commençant par le premier élément pour lequel le prédicat retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="5851f-198">[Seq.skipWhile](https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16) returns a sequence that skips the first elements of another sequence as long as the predicate returns `true`, and then returns the remaining elements, starting with the first element for which the predicate returns `false`.</span></span>

<span data-ttu-id="5851f-199">L’exemple de code suivant illustre le comportement de et les différences entre `Seq.takeWhile`, `Seq.skip`et `Seq.skipWhile`.</span><span class="sxs-lookup"><span data-stu-id="5851f-199">The following code example illustrates the behavior of and differences between `Seq.takeWhile`, `Seq.skip`, and `Seq.skipWhile`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet17.fs)]

<span data-ttu-id="5851f-200">La sortie est la suivante.</span><span class="sxs-lookup"><span data-stu-id="5851f-200">The output is as follows.</span></span>

```console
1 4 9
36 49 64 81 100
16 25 36 49 64 81 100
```

## <a name="transforming-sequences"></a><span data-ttu-id="5851f-201">Transformation de séquences</span><span class="sxs-lookup"><span data-stu-id="5851f-201">Transforming Sequences</span></span>

<span data-ttu-id="5851f-202">[Seq. pairwise](https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1) crée une séquence dans laquelle les éléments successifs de la séquence d’entrée sont regroupés en tuples.</span><span class="sxs-lookup"><span data-stu-id="5851f-202">[Seq.pairwise](https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1) creates a new sequence in which successive elements of the input sequence are grouped into tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet18.fs)]

<span data-ttu-id="5851f-203">[Seq. Windowed](https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744) est semblable à `Seq.pairwise`, mais au lieu de produire une séquence de tuples, il produit une séquence de tableaux qui contiennent des copies d’éléments adjacents (une *fenêtre*) de la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-203">[Seq.windowed](https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744) is like `Seq.pairwise`, except that instead of producing a sequence of tuples, it produces a sequence of arrays that contain copies of adjacent elements (a *window*) from the sequence.</span></span> <span data-ttu-id="5851f-204">Vous spécifiez le nombre d’éléments adjacents que vous souhaitez dans chaque tableau.</span><span class="sxs-lookup"><span data-stu-id="5851f-204">You specify the number of adjacent elements you want in each array.</span></span>

<span data-ttu-id="5851f-205">L'exemple de code suivant montre l'utilisation de `Seq.windowed`.</span><span class="sxs-lookup"><span data-stu-id="5851f-205">The following code example demonstrates the use of `Seq.windowed`.</span></span> <span data-ttu-id="5851f-206">Dans ce cas, le nombre d’éléments dans la fenêtre est 3.</span><span class="sxs-lookup"><span data-stu-id="5851f-206">In this case the number of elements in the window is 3.</span></span> <span data-ttu-id="5851f-207">L’exemple utilise `printSeq`, qui est défini dans l’exemple de code précédent.</span><span class="sxs-lookup"><span data-stu-id="5851f-207">The example uses `printSeq`, which is defined in the previous code example.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet180.fs)]

<span data-ttu-id="5851f-208">La sortie est la suivante.</span><span class="sxs-lookup"><span data-stu-id="5851f-208">The output is as follows.</span></span>

<span data-ttu-id="5851f-209">Séquence initiale :</span><span class="sxs-lookup"><span data-stu-id="5851f-209">Initial sequence:</span></span>

```console
1.0 1.5 2.0 1.5 1.0 1.5

Windows of length 3:
[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|]

Moving average:
1.5 1.666666667 1.5 1.333333333
```

## <a name="operations-with-multiple-sequences"></a><span data-ttu-id="5851f-210">Opérations avec plusieurs séquences</span><span class="sxs-lookup"><span data-stu-id="5851f-210">Operations with Multiple Sequences</span></span>

<span data-ttu-id="5851f-211">[Seq. zip](https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4) et [Seq. zip3](https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16) prennent deux ou trois séquences et produisent une séquence de tuples.</span><span class="sxs-lookup"><span data-stu-id="5851f-211">[Seq.zip](https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4) and [Seq.zip3](https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16) take two or three sequences and produce a sequence of tuples.</span></span> <span data-ttu-id="5851f-212">Ces fonctions sont semblables aux fonctions correspondantes disponibles pour les [listes](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span><span class="sxs-lookup"><span data-stu-id="5851f-212">These functions are like the corresponding functions available for [lists](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span></span> <span data-ttu-id="5851f-213">Il n’existe aucune fonctionnalité correspondante pour séparer une séquence en deux séquences ou plus.</span><span class="sxs-lookup"><span data-stu-id="5851f-213">There is no corresponding functionality to separate one sequence into two or more sequences.</span></span> <span data-ttu-id="5851f-214">Si vous avez besoin de cette fonctionnalité pour une séquence, convertissez la séquence en une liste et utilisez [List. unzip](https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21).</span><span class="sxs-lookup"><span data-stu-id="5851f-214">If you need this functionality for a sequence, convert the sequence to a list and use [List.unzip](https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21).</span></span>

## <a name="sorting-comparing-and-grouping"></a><span data-ttu-id="5851f-215">Tri, comparaison et regroupement</span><span class="sxs-lookup"><span data-stu-id="5851f-215">Sorting, Comparing, and Grouping</span></span>

<span data-ttu-id="5851f-216">Les fonctions de tri prises en charge pour les listes fonctionnent également avec les séquences.</span><span class="sxs-lookup"><span data-stu-id="5851f-216">The sorting functions supported for lists also work with sequences.</span></span> <span data-ttu-id="5851f-217">Cela comprend [Seq. sort](https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e) et [Seq. SortBy](https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f).</span><span class="sxs-lookup"><span data-stu-id="5851f-217">This includes [Seq.sort](https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e) and [Seq.sortBy](https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f).</span></span> <span data-ttu-id="5851f-218">Ces fonctions itèrent au sein de l’ensemble de la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-218">These functions iterate through the whole sequence.</span></span>

<span data-ttu-id="5851f-219">Vous comparez deux séquences à l’aide de la fonction [Seq. compareWith (](https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f) .</span><span class="sxs-lookup"><span data-stu-id="5851f-219">You compare two sequences by using the [Seq.compareWith](https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f) function.</span></span> <span data-ttu-id="5851f-220">La fonction compare ensuite les éléments successifs et s’arrête lorsqu’elle rencontre la première paire inégale.</span><span class="sxs-lookup"><span data-stu-id="5851f-220">The function compares successive elements in turn, and stops when it encounters the first unequal pair.</span></span> <span data-ttu-id="5851f-221">Tout élément supplémentaire ne contribue pas à la comparaison.</span><span class="sxs-lookup"><span data-stu-id="5851f-221">Any additional elements do not contribute to the comparison.</span></span>

<span data-ttu-id="5851f-222">Le code suivant illustre l'utilisation de `Seq.compareWith`.</span><span class="sxs-lookup"><span data-stu-id="5851f-222">The following code shows the use of `Seq.compareWith`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet19.fs)]

<span data-ttu-id="5851f-223">Dans le code précédent, seul le premier élément est calculé et examiné, et le résultat est-1.</span><span class="sxs-lookup"><span data-stu-id="5851f-223">In the previous code, only the first element is computed and examined, and the result is -1.</span></span>

<span data-ttu-id="5851f-224">[Seq. countBy](https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f) prend une fonction qui génère une valeur appelée *clé* pour chaque élément.</span><span class="sxs-lookup"><span data-stu-id="5851f-224">[Seq.countBy](https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f) takes a function that generates a value called a *key* for each element.</span></span> <span data-ttu-id="5851f-225">Une clé est générée pour chaque élément en appelant cette fonction sur chaque élément.</span><span class="sxs-lookup"><span data-stu-id="5851f-225">A key is generated for each element by calling this function on each element.</span></span> <span data-ttu-id="5851f-226">`Seq.countBy` retourne ensuite une séquence qui contient les valeurs de clés et le nombre d’éléments qui ont généré chaque valeur de la clé.</span><span class="sxs-lookup"><span data-stu-id="5851f-226">`Seq.countBy` then returns a sequence that contains the key values, and a count of the number of elements that generated each value of the key.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet201.fs)]

<span data-ttu-id="5851f-227">La sortie est la suivante.</span><span class="sxs-lookup"><span data-stu-id="5851f-227">The output is as follows.</span></span>

```console
(1, 34) (2, 33) (0, 33)
```

<span data-ttu-id="5851f-228">La sortie précédente montre qu’il existait 34 éléments de la séquence d’origine qui ont produit la clé 1, 33 valeurs qui ont produit la clé 2 et 33 valeurs qui ont produit la clé 0.</span><span class="sxs-lookup"><span data-stu-id="5851f-228">The previous output shows that there were 34 elements of the original sequence that produced the key 1, 33 values that produced the key 2, and 33 values that produced the key 0.</span></span>

<span data-ttu-id="5851f-229">Vous pouvez regrouper des éléments d’une séquence en appelant [Seq. GroupBy](https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd).</span><span class="sxs-lookup"><span data-stu-id="5851f-229">You can group elements of a sequence by calling [Seq.groupBy](https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd).</span></span> <span data-ttu-id="5851f-230">`Seq.groupBy` prend une séquence et une fonction qui génère une clé à partir d’un élément.</span><span class="sxs-lookup"><span data-stu-id="5851f-230">`Seq.groupBy` takes a sequence and a function that generates a key from an element.</span></span> <span data-ttu-id="5851f-231">La fonction est exécutée sur chaque élément de la séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-231">The function is executed on each element of the sequence.</span></span> <span data-ttu-id="5851f-232">`Seq.groupBy` retourne une séquence de tuples, où le premier élément de chaque tuple est la clé et le second est une séquence d’éléments qui produisent cette clé.</span><span class="sxs-lookup"><span data-stu-id="5851f-232">`Seq.groupBy` returns a sequence of tuples, where the first element of each tuple is the key and the second is a sequence of elements that produce that key.</span></span>

<span data-ttu-id="5851f-233">L’exemple de code suivant illustre l’utilisation de `Seq.groupBy` pour partitionner la séquence de nombres de 1 à 100 en trois groupes qui ont les valeurs de clé distinctes 0, 1 et 2.</span><span class="sxs-lookup"><span data-stu-id="5851f-233">The following code example shows the use of `Seq.groupBy` to partition the sequence of numbers from 1 to 100 into three groups that have the distinct key values 0, 1, and 2.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet202.fs)]

<span data-ttu-id="5851f-234">La sortie est la suivante.</span><span class="sxs-lookup"><span data-stu-id="5851f-234">The output is as follows.</span></span>

```console
(1, seq [1; 4; 7; 10; ...]) (2, seq [2; 5; 8; 11; ...]) (0, seq [3; 6; 9; 12; ...])
```

<span data-ttu-id="5851f-235">Vous pouvez créer une séquence qui élimine les doublons d’éléments en appelant [Seq. distinct](https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401).</span><span class="sxs-lookup"><span data-stu-id="5851f-235">You can create a sequence that eliminates duplicate elements by calling [Seq.distinct](https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401).</span></span> <span data-ttu-id="5851f-236">Ou vous pouvez utiliser [Seq. distinctBy (](https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75), qui prend une fonction de génération de clé à appeler sur chaque élément.</span><span class="sxs-lookup"><span data-stu-id="5851f-236">Or you can use [Seq.distinctBy](https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75), which takes a key-generating function to be called on each element.</span></span> <span data-ttu-id="5851f-237">La séquence résultante contient des éléments de la séquence d’origine qui ont des clés uniques ; les éléments ultérieurs qui produisent une clé dupliquée pour un élément antérieur sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="5851f-237">The resulting sequence contains elements of the original sequence that have unique keys; later elements that produce a duplicate key to an earlier element are discarded.</span></span>

<span data-ttu-id="5851f-238">L’exemple de code suivant illustre l’utilisation de `Seq.distinct`.</span><span class="sxs-lookup"><span data-stu-id="5851f-238">The following code example illustrates the use of `Seq.distinct`.</span></span> <span data-ttu-id="5851f-239">`Seq.distinct` est démontré en générant des séquences qui représentent des nombres binaires, puis en indiquant que les seuls éléments distincts sont 0 et 1.</span><span class="sxs-lookup"><span data-stu-id="5851f-239">`Seq.distinct` is demonstrated by generating sequences that represent binary numbers, and then showing that the only distinct elements are 0 and 1.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet22.fs)]

<span data-ttu-id="5851f-240">Le code suivant illustre `Seq.distinctBy` en commençant par une séquence qui contient des nombres négatifs et positifs et en utilisant la fonction de valeur absolue comme fonction génératrice de clé.</span><span class="sxs-lookup"><span data-stu-id="5851f-240">The following code demonstrates `Seq.distinctBy` by starting with a sequence that contains negative and positive numbers and using the absolute value function as the key-generating function.</span></span> <span data-ttu-id="5851f-241">La séquence résultante ne contient pas tous les nombres positifs qui correspondent aux nombres négatifs de la séquence, car les nombres négatifs apparaissent plus tôt dans la séquence et sont donc sélectionnés à la place des nombres positifs qui ont le même absolu valeur, ou clé.</span><span class="sxs-lookup"><span data-stu-id="5851f-241">The resulting sequence is missing all the positive numbers that correspond to the negative numbers in the sequence, because the negative numbers appear earlier in the sequence and therefore are selected instead of the positive numbers that have the same absolute value, or key.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet23.fs)]

## <a name="readonly-and-cached-sequences"></a><span data-ttu-id="5851f-242">Séquences ReadOnly et mises en cache</span><span class="sxs-lookup"><span data-stu-id="5851f-242">Readonly and Cached Sequences</span></span>

<span data-ttu-id="5851f-243">[Seq. ReadOnly](https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7) crée une copie en lecture seule d’une séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-243">[Seq.readonly](https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7) creates a read-only copy of a sequence.</span></span> <span data-ttu-id="5851f-244">`Seq.readonly` est utile lorsque vous disposez d’une collection en lecture-écriture, telle qu’un tableau, et que vous ne souhaitez pas modifier la collection d’origine.</span><span class="sxs-lookup"><span data-stu-id="5851f-244">`Seq.readonly` is useful when you have a read-write collection, such as an array, and you do not want to modify the original collection.</span></span> <span data-ttu-id="5851f-245">Cette fonction peut être utilisée pour conserver l’encapsulation des données.</span><span class="sxs-lookup"><span data-stu-id="5851f-245">This function can be used to preserve data encapsulation.</span></span> <span data-ttu-id="5851f-246">Dans l’exemple de code suivant, un type qui contient un tableau est créé.</span><span class="sxs-lookup"><span data-stu-id="5851f-246">In the following code example, a type that contains an array is created.</span></span> <span data-ttu-id="5851f-247">Une propriété expose le tableau, mais au lieu de retourner un tableau, elle retourne une séquence créée à partir du tableau à l’aide de `Seq.readonly`.</span><span class="sxs-lookup"><span data-stu-id="5851f-247">A property exposes the array, but instead of returning an array, it returns a sequence that is created from the array by using `Seq.readonly`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet24.fs)]

<span data-ttu-id="5851f-248">[Seq. cache](https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0) crée une version stockée d’une séquence.</span><span class="sxs-lookup"><span data-stu-id="5851f-248">[Seq.cache](https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0) creates a stored version of a sequence.</span></span> <span data-ttu-id="5851f-249">Utilisez `Seq.cache` pour éviter la réévaluation d’une séquence, ou lorsque vous avez plusieurs threads qui utilisent une séquence, mais que vous devez vous assurer que chaque élément est traité sur une seule fois.</span><span class="sxs-lookup"><span data-stu-id="5851f-249">Use `Seq.cache` to avoid reevaluation of a sequence, or when you have multiple threads that use a sequence, but you must make sure that each element is acted upon only one time.</span></span> <span data-ttu-id="5851f-250">Quand vous avez une séquence qui est utilisée par plusieurs threads, vous pouvez avoir un thread qui énumère et calcule les valeurs de la séquence d’origine, et les threads restants peuvent utiliser la séquence mise en cache.</span><span class="sxs-lookup"><span data-stu-id="5851f-250">When you have a sequence that is being used by multiple threads, you can have one thread that enumerates and computes the values for the original sequence, and remaining threads can use the cached sequence.</span></span>

## <a name="performing-computations-on-sequences"></a><span data-ttu-id="5851f-251">Exécution de calculs sur des séquences</span><span class="sxs-lookup"><span data-stu-id="5851f-251">Performing Computations on Sequences</span></span>

<span data-ttu-id="5851f-252">Les opérations arithmétiques simples sont similaires à celles des listes, telles que [Seq. Average](https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8), [Seq. Sum](https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a), [Seq. averageBy](https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8), [Seq. sumBy](https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1), et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="5851f-252">Simple arithmetic operations are like those of lists, such as [Seq.average](https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8), [Seq.sum](https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a), [Seq.averageBy](https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8), [Seq.sumBy](https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1), and so on.</span></span>

<span data-ttu-id="5851f-253">[Seq. fold](https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3), [Seq. Reduce](https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9)et [Seq. Scan](https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e) sont semblables aux fonctions correspondantes qui sont disponibles pour les listes.</span><span class="sxs-lookup"><span data-stu-id="5851f-253">[Seq.fold](https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3), [Seq.reduce](https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9), and [Seq.scan](https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e) are like the corresponding functions that are available for lists.</span></span> <span data-ttu-id="5851f-254">Les séquences prennent en charge un sous-ensemble des variantes complètes de ces fonctions qui répertorient la prise en charge.</span><span class="sxs-lookup"><span data-stu-id="5851f-254">Sequences support a subset of the full variations of these functions that lists support.</span></span> <span data-ttu-id="5851f-255">Pour plus d’informations et d’exemples, consultez [listes](lists.md).</span><span class="sxs-lookup"><span data-stu-id="5851f-255">For more information and examples, see [Lists](lists.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="5851f-256">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="5851f-256">See also</span></span>

- [<span data-ttu-id="5851f-257">Informations de référence sur le langage F#</span><span class="sxs-lookup"><span data-stu-id="5851f-257">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="5851f-258">Types F#</span><span class="sxs-lookup"><span data-stu-id="5851f-258">F# Types</span></span>](fsharp-types.md)
