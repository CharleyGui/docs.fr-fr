---
title: Valeurs
description: Découvrez comment les valeurs dans F# sont des quantités qui ont un type spécifique.
ms.date: 05/16/2016
ms.openlocfilehash: fe87bb568591b862737456ff92ba202ba7795e3d
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/15/2019
ms.locfileid: "65641628"
---
# <a name="values"></a><span data-ttu-id="ee9da-103">Valeurs</span><span class="sxs-lookup"><span data-stu-id="ee9da-103">Values</span></span>

<span data-ttu-id="ee9da-104">En F#, les valeurs sont des quantités qui ont un type spécifique ; les valeurs peuvent être des nombres intégraux ou à virgule flottante, des caractères ou du texte, des listes, des séquences, des tableaux, des tuples, des unions discriminées, des enregistrements, des types de classe ou des valeurs de fonction.</span><span class="sxs-lookup"><span data-stu-id="ee9da-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="ee9da-105">Liaison d’une valeur</span><span class="sxs-lookup"><span data-stu-id="ee9da-105">Binding a Value</span></span>

<span data-ttu-id="ee9da-106">Le terme *liaison* signifie l’association d’un nom à une définition.</span><span class="sxs-lookup"><span data-stu-id="ee9da-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="ee9da-107">Le mot clé `let` lie une valeur, comme dans les exemples suivants :</span><span class="sxs-lookup"><span data-stu-id="ee9da-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="ee9da-108">Le type d’une valeur est déduit de la définition.</span><span class="sxs-lookup"><span data-stu-id="ee9da-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="ee9da-109">Pour un type primitif, tel qu’un nombre intégral ou à virgule flottante, le type est déterminé à partir du type du littéral.</span><span class="sxs-lookup"><span data-stu-id="ee9da-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="ee9da-110">Par conséquent, dans l’exemple précédent, le compilateur déduit que le type de `b` est `unsigned int`, alors qu’il déduit que le type de `a` est `int`.</span><span class="sxs-lookup"><span data-stu-id="ee9da-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="ee9da-111">Le type d’une valeur de fonction est déterminé à partir de la valeur de retour dans le corps de la fonction.</span><span class="sxs-lookup"><span data-stu-id="ee9da-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="ee9da-112">Pour plus d’informations sur les types de valeurs de fonction, consultez [Fonctions](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="ee9da-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="ee9da-113">Pour plus d’informations sur les types de littéraux, consultez [Littéraux](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="ee9da-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="ee9da-114">Le compilateur n’émet pas de diagnostic concernant les liaisons inutilisés par défaut.</span><span class="sxs-lookup"><span data-stu-id="ee9da-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="ee9da-115">Pour recevoir ces messages, activez avertissement 1182 dans votre fichier projet ou lors de l’appel du compilateur (consultez `--warnon` sous [Options du compilateur](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="ee9da-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="ee9da-116">Pourquoi immuables ?</span><span class="sxs-lookup"><span data-stu-id="ee9da-116">Why Immutable?</span></span>

<span data-ttu-id="ee9da-117">Des valeurs immuables sont des valeurs qui ne peuvent pas être modifiées durant toute l’exécution d’un programme.</span><span class="sxs-lookup"><span data-stu-id="ee9da-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="ee9da-118">Si vous travaillez d’habitude avec des langages tels que C++, Visual Basic ou C#, vous pourrez être surpris de constater que F# donne la primauté aux valeurs immuables, et non aux variables auxquelles de nouvelles valeurs peuvent être assignées pendant l’exécution d’un programme.</span><span class="sxs-lookup"><span data-stu-id="ee9da-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="ee9da-119">Les données immuables sont un élément important de la programmation fonctionnelle.</span><span class="sxs-lookup"><span data-stu-id="ee9da-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="ee9da-120">Dans un environnement multithread, des variables mutables partagées qui peuvent être modifiées par différents threads sont difficiles à gérer.</span><span class="sxs-lookup"><span data-stu-id="ee9da-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="ee9da-121">Par ailleurs, avec des variables mutables, il peut parfois être difficile de savoir si une variable peut être modifiée quand elle est passée à une autre fonction.</span><span class="sxs-lookup"><span data-stu-id="ee9da-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="ee9da-122">Dans les langages fonctionnels purs, il n’y a pas de variables, les fonctions se comportent strictement comme des fonctions mathématiques.</span><span class="sxs-lookup"><span data-stu-id="ee9da-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="ee9da-123">Là où le code dans un langage procédural utilise une assignation de variable pour modifier une valeur, le code équivalent dans un langage fonctionnel comprend une valeur immuable comme entrée, une fonction immuable et différentes valeurs immuables comme sortie.</span><span class="sxs-lookup"><span data-stu-id="ee9da-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="ee9da-124">Cette rigueur mathématique donne lieu à un raisonnement plus carré sur le comportement du programme,</span><span class="sxs-lookup"><span data-stu-id="ee9da-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="ee9da-125">ce qui permet aux compilateurs de vérifier le code plus rigoureusement et de l’optimiser plus efficacement. Pour les développeurs, il est plus facile de comprendre le code et de l’écrire correctement.</span><span class="sxs-lookup"><span data-stu-id="ee9da-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="ee9da-126">Le code fonctionnel est donc probablement plus facile à déboguer que le code procédural ordinaire.</span><span class="sxs-lookup"><span data-stu-id="ee9da-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="ee9da-127">F# n’est pas un langage fonctionnel pur ; toutefois, il prend entièrement en charge la programmation fonctionnelle.</span><span class="sxs-lookup"><span data-stu-id="ee9da-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="ee9da-128">L’utilisation de valeurs immuables est conseillée, car votre code bénéficie ainsi d’un aspect important de la programmation fonctionnelle.</span><span class="sxs-lookup"><span data-stu-id="ee9da-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="ee9da-129">Variables mutables</span><span class="sxs-lookup"><span data-stu-id="ee9da-129">Mutable Variables</span></span>

<span data-ttu-id="ee9da-130">Vous pouvez utiliser le mot clé `mutable` pour spécifier une variable pouvant être modifiée.</span><span class="sxs-lookup"><span data-stu-id="ee9da-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="ee9da-131">En F#, les variables mutables doivent généralement avoir une portée limitée, soit comme champ d’un type, soit comme valeur locale.</span><span class="sxs-lookup"><span data-stu-id="ee9da-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="ee9da-132">Des variables mutables avec une portée limitée sont plus faciles à contrôler et moins susceptibles d’être modifiées de manière incorrecte.</span><span class="sxs-lookup"><span data-stu-id="ee9da-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="ee9da-133">Vous pouvez assigner une valeur initiale à une variable mutable à l’aide du mot clé `let`, de la même façon que vous définissez une valeur.</span><span class="sxs-lookup"><span data-stu-id="ee9da-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="ee9da-134">Toutefois, la différence est que vous pouvez assigner par la suite de nouvelles valeurs à des variables mutables à l’aide de l’opérateur `<-`, comme dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="ee9da-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="ee9da-135">Les valeurs marquées `mutable` peut être promue automatiquement en `'a ref` si capturées par une fermeture, y compris les formulaires qui créent des fermetures, comme `seq` générateurs.</span><span class="sxs-lookup"><span data-stu-id="ee9da-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="ee9da-136">Si vous souhaitez être averti lorsque cela se produit, activez l’avertissement 3180 dans votre fichier projet ou dans l’appel du compilateur.</span><span class="sxs-lookup"><span data-stu-id="ee9da-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="ee9da-137">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="ee9da-137">Related Topics</span></span>

|<span data-ttu-id="ee9da-138">Titre</span><span class="sxs-lookup"><span data-stu-id="ee9da-138">Title</span></span>|<span data-ttu-id="ee9da-139">Description</span><span class="sxs-lookup"><span data-stu-id="ee9da-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="ee9da-140">Liaisons let</span><span class="sxs-lookup"><span data-stu-id="ee9da-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="ee9da-141">Fournit des informations sur l’utilisation de la `let` mot clé pour lier des noms aux valeurs et aux fonctions.</span><span class="sxs-lookup"><span data-stu-id="ee9da-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="ee9da-142">Fonctions</span><span class="sxs-lookup"><span data-stu-id="ee9da-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="ee9da-143">Fournit une vue d’ensemble des fonctions en F#.</span><span class="sxs-lookup"><span data-stu-id="ee9da-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="ee9da-144">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="ee9da-144">See also</span></span>

- [<span data-ttu-id="ee9da-145">Valeurs Null</span><span class="sxs-lookup"><span data-stu-id="ee9da-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="ee9da-146">Informations de référence du langage F#</span><span class="sxs-lookup"><span data-stu-id="ee9da-146">F# Language Reference</span></span>](../index.md)
