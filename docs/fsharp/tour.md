---
title: Visite guidée de F#
description: Examiner certaines des fonctionnalités clés de la langue dans cette visite guidée avec exemples de code de programmation F#.
ms.date: 11/06/2018
ms.openlocfilehash: 64394342777003b33dd77028739fb7209b9f3c86
ms.sourcegitcommit: 621a5f6df00152006160987395b93b5b55f7ffcd
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/29/2019
ms.locfileid: "66301254"
---
# <a name="tour-of-f"></a><span data-ttu-id="5bdcd-103">Présentation du langage F\#</span><span class="sxs-lookup"><span data-stu-id="5bdcd-103">Tour of F\#</span></span>

<span data-ttu-id="5bdcd-104">La meilleure façon d’en savoir plus sur F# consiste à lire et écrire du code F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-104">The best way to learn about F# is to read and write F# code.</span></span> <span data-ttu-id="5bdcd-105">Cet article sera agissent comme une visite guidée de certaines des fonctionnalités clés du langage F# et vous donner quelques extraits de code que vous pouvez exécuter sur votre ordinateur.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-105">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span> <span data-ttu-id="5bdcd-106">Pour en savoir plus sur la configuration d’un environnement de développement, consultez [mise en route](tutorials/getting-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="5bdcd-106">To learn about setting up a development environment, check out [Getting Started](tutorials/getting-started/index.md).</span></span>

<span data-ttu-id="5bdcd-107">Il existe deux concepts principaux en F#: les types et les fonctions.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-107">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="5bdcd-108">Cette visite guidée sera mettre l’accent sur les fonctionnalités du langage qui appartiennent à ces deux concepts.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-108">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="executing-the-code-online"></a><span data-ttu-id="5bdcd-109">L’exécution du code en ligne</span><span class="sxs-lookup"><span data-stu-id="5bdcd-109">Executing the code online</span></span>

<span data-ttu-id="5bdcd-110">Si vous n’avez pas F# installé sur votre ordinateur, vous pouvez exécuter tous les exemples dans votre navigateur avec [essayez F# sur WebAssembly](https://tryfsharp.fsbolero.io/).</span><span class="sxs-lookup"><span data-stu-id="5bdcd-110">If you don't have F# installed on your machine, you can execute all of the samples in your browser with [Try F# on WebAssembly](https://tryfsharp.fsbolero.io/).</span></span> <span data-ttu-id="5bdcd-111">Fable est un dialecte F# qui s’exécute directement dans votre navigateur.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-111">Fable is a dialect of F# that executes directly in your browser.</span></span> <span data-ttu-id="5bdcd-112">Pour afficher les exemples qui suivent dans la boucle REPL, consultez **exemples > en savoir plus > visite guidée de F#**  dans la barre de menu de gauche de l’intervalle de Fable</span><span class="sxs-lookup"><span data-stu-id="5bdcd-112">To view the samples that follow in the REPL, check out **Samples > Learn > Tour of F#** in the left-hand menu bar of the Fable REPL.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="5bdcd-113">Fonctions et des Modules</span><span class="sxs-lookup"><span data-stu-id="5bdcd-113">Functions and Modules</span></span>

<span data-ttu-id="5bdcd-114">Les éléments essentiels de n’importe quel programme F# sont ***fonctions*** organisées en ***modules***.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-114">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="5bdcd-115">[Fonctions](language-reference/functions/index.md) effectuer le travail sur les entrées pour produire des sorties, et ils sont organisés sous [Modules](language-reference/modules.md), qui sont le principal moyen de regrouper de choses en F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-115">[Functions](language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="5bdcd-116">Elles sont définies à l’aide de la [ `let` liaison](language-reference/functions/let-bindings.md), donnez un nom à la fonction et définir ses arguments.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-116">They are defined using the [`let` binding](language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="5bdcd-117">`let` les liaisons sont également comment vous lier une valeur à un nom, semblable à une variable dans d’autres langages.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-117">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="5bdcd-118">`let` les liaisons sont ***immuable*** par défaut, ce qui signifie qu’une fois qu’une valeur ou une fonction est liée à un nom, il ne peut pas être modifié sur place.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-118">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="5bdcd-119">Ce comportement diffère variables dans d’autres langues, qui sont ***mutable***, ce qui signifie que leurs valeurs peut être modifié à n’importe quel point dans le temps.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-119">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="5bdcd-120">Si vous avez besoin d’une liaison mutable, vous pouvez utiliser `let mutable ...` syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-120">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="5bdcd-121">Nombres, les valeurs booléennes et les chaînes</span><span class="sxs-lookup"><span data-stu-id="5bdcd-121">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="5bdcd-122">Comme un langage .NET, F# prend en charge même sous-jacent [types primitifs](language-reference/primitive-types.md) qui existent dans .NET.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-122">As a .NET language, F# supports the same underlying [primitive types](language-reference/primitive-types.md) that exist in .NET.</span></span>

<span data-ttu-id="5bdcd-123">Voici comment différents types numériques sont représentées en F#:</span><span class="sxs-lookup"><span data-stu-id="5bdcd-123">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="5bdcd-124">Voici les valeurs booléennes et exécution d’une logique conditionnelle base ressemble à :</span><span class="sxs-lookup"><span data-stu-id="5bdcd-124">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="5bdcd-125">Et Voici quelles basic [chaîne](language-reference/strings.md) manipulation ressemble à :</span><span class="sxs-lookup"><span data-stu-id="5bdcd-125">And here's what basic [string](language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="5bdcd-126">Tuples</span><span class="sxs-lookup"><span data-stu-id="5bdcd-126">Tuples</span></span>

<span data-ttu-id="5bdcd-127">[Tuples](language-reference/tuples.md) sont considérables en F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-127">[Tuples](language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="5bdcd-128">Il s’agit d’un regroupement de valeurs sans nom, mais ordonnées, qui peut être traité en tant que valeurs elles-mêmes.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-128">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="5bdcd-129">Imaginez qu’elles en tant que valeurs qui sont agrégées à partir d’autres valeurs.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-129">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="5bdcd-130">Ils ont de nombreuses utilisations, telles que facilement retourner plusieurs valeurs à partir d’une fonction ou de regroupement pour des raisons pratiques ad-hoc.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-130">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="5bdcd-131">À compter de F# 4.1, vous pouvez également créer `struct` tuples.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-131">As of F# 4.1, you can also create `struct` tuples.</span></span>  <span data-ttu-id="5bdcd-132">Ces également interagissent entièrement avec C# 7/Visual Basic 15 tuples, qui sont également `struct` tuples :</span><span class="sxs-lookup"><span data-stu-id="5bdcd-132">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="5bdcd-133">Il est important de noter que, étant donné que `struct` tuples sont des types valeur, ils ne peuvent pas être convertis implicitement pour référencer des tuples, ou vice versa.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-133">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="5bdcd-134">Vous devez explicitement convertir entre un tuple de référence et de struct.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-134">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="5bdcd-135">Pipelines et Composition</span><span class="sxs-lookup"><span data-stu-id="5bdcd-135">Pipelines and Composition</span></span>

<span data-ttu-id="5bdcd-136">Diriger des opérateurs tels que `|>` sont largement utilisées lors du traitement des données en F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-136">Pipe operators such as `|>` are used extensively when processing data in F#.</span></span> <span data-ttu-id="5bdcd-137">Ces opérateurs sont des fonctions qui vous permettent d’établir un « pipelines » des fonctions de manière flexible.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-137">These operators are functions that allow you to establish "pipelines" of functions in a flexible manner.</span></span> <span data-ttu-id="5bdcd-138">L’exemple suivant décrit comment vous pouvez tirer parti de ces opérateurs pour créer un pipeline fonctionnel simple :</span><span class="sxs-lookup"><span data-stu-id="5bdcd-138">The following example walks through how you can take advantage of these operators to build a simple functional pipeline:</span></span>

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L282)]

<span data-ttu-id="5bdcd-139">L’exemple précédent apportée utiliser de nombreuses fonctionnalités de F#, y compris les fonctions de traitement de liste, les fonctions de première classe, et [application partielle](language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="5bdcd-139">The previous sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](language-reference/functions/index.md#partial-application-of-arguments).</span></span> <span data-ttu-id="5bdcd-140">Bien qu’une compréhension approfondie de chacun de ces concepts peut devenir un peu avancée, il doit être clair comment facilement les fonctions peuvent être utilisées pour traiter les données lors de la création de pipelines.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-140">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="5bdcd-141">Listes, tableaux et séquences</span><span class="sxs-lookup"><span data-stu-id="5bdcd-141">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="5bdcd-142">Listes, tableaux et séquences existe trois types de collection principale dans la bibliothèque principale F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-142">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="5bdcd-143">[Répertorie les](language-reference/lists.md) sont ordonnées, immuables des collections d’éléments du même type.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-143">[Lists](language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="5bdcd-144">Ils sont des listes liées uniques, ce qui signifie qu’ils sont destinés à énumération, mais un choix médiocre pour un accès aléatoire et concaténation s’ils sont volumineux.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-144">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="5bdcd-145">Cela Contrairement aux listes dans d’autres langages populaires, qui généralement n’utilisent pas une liste liée unique pour représenter les listes.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-145">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="5bdcd-146">[Tableaux](language-reference/arrays.md) sont de taille fixe, *mutable* collections d’éléments du même type.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-146">[Arrays](language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="5bdcd-147">Ils prennent en charge un accès aléatoire rapide d’éléments et sont plus rapides que les listes F#, car elles sont simplement contiguës blocs de mémoire.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-147">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="5bdcd-148">[Séquences](language-reference/sequences.md) sont une série logique d’éléments, tous du même type.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-148">[Sequences](language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="5bdcd-149">Il s’agit d’un type plus général que les listes et des tableaux, susceptibles d’être votre « vue » dans n’importe quelle série logique d’éléments.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-149">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="5bdcd-150">Ils également se démarquent car ils peuvent être ***différé***, ce qui signifie que les éléments peuvent être calculées uniquement lorsqu’elles sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-150">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="5bdcd-151">Fonctions récursives</span><span class="sxs-lookup"><span data-stu-id="5bdcd-151">Recursive Functions</span></span>

<span data-ttu-id="5bdcd-152">Le traitement des collections ou des séquences d’éléments est généralement effectué avec [récursivité](language-reference/functions/index.md#recursive-functions) en F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-152">Processing collections or sequences of elements is typically done with [recursion](language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="5bdcd-153">Bien que F# offre la prise en charge des boucles et la programmation impérative, la récursivité est préférée, car il est plus facile de garantir l’exactitude.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-153">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

> [!NOTE]
> <span data-ttu-id="5bdcd-154">L’exemple suivant utilise les critères spéciaux le `match` expression.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-154">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="5bdcd-155">Cette construction fondamentale est couvert plus loin dans cet article.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-155">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="5bdcd-156">F# a également une prise en charge complète pour l’optimisation d’appel Tail, qui est une façon d’optimiser les appels récursifs afin qu’ils soient tout aussi rapides comme une construction en boucle.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-156">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="5bdcd-157">Enregistrement et les Types d’Union discriminée</span><span class="sxs-lookup"><span data-stu-id="5bdcd-157">Record and Discriminated Union Types</span></span>

<span data-ttu-id="5bdcd-158">Enregistrement et types Union sont deux types de données fondamentaux utilisés dans le code F# et sont généralement la meilleure façon de représenter les données dans un programme F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-158">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="5bdcd-159">Bien que cela les rend semblables aux classes dans d’autres langues, une de leurs principales différences est qu’ils ont une sémantique d’égalité structurelle.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-159">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="5bdcd-160">Cela signifie qu’ils sont comparables « en mode natif » et l’égalité est simple : simplement vérifier si un est égal à l’autre.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-160">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="5bdcd-161">[Enregistrements](language-reference/records.md) sont un agrégat de valeurs nommées, avec des membres facultatifs (par exemple, les méthodes).</span><span class="sxs-lookup"><span data-stu-id="5bdcd-161">[Records](language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="5bdcd-162">Si vous êtes familiarisé avec c# ou Java, puis ces devraient sembler similaires à oct ou POJO - tout avec l’égalité structurelle et moins de cérémonie.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-162">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="5bdcd-163">À compter de F# 4.1, vous pouvez également représenter des enregistrements sous la forme `struct`s.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-163">As of F# 4.1, you can also represent Records as `struct`s.</span></span>  <span data-ttu-id="5bdcd-164">Cette opération est effectuée avec la `[<Struct>]` attribut :</span><span class="sxs-lookup"><span data-stu-id="5bdcd-164">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="5bdcd-165">[(DUs) d’Unions discriminées](language-reference/discriminated-unions.md) sont des valeurs qui peut être un nombre de formulaires nommés ou de cas.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-165">[Discriminated Unions (DUs)](language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="5bdcd-166">Données stockées dans le type peuvent être une de plusieurs valeurs distinctes.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-166">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="5bdcd-167">Vous pouvez également utiliser DUs en tant que *Unions discriminées de cas unique*, pour faciliter la modélisation sur les types primitifs de domaine.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-167">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="5bdcd-168">Souvent, les chaînes et autres types primitifs sont utilisés pour représenter un élément et bénéficient ainsi d’une signification particulière.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-168">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="5bdcd-169">Toutefois, l’utilisation uniquement la primitive représentation des données peut entraîner par inadvertance affectation d’une valeur incorrecte !</span><span class="sxs-lookup"><span data-stu-id="5bdcd-169">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="5bdcd-170">Représentant chaque type d’informations sous la forme d’une union de cas unique distincte peut imposer l’exactitude dans ce scénario.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-170">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="5bdcd-171">Comme illustré dans l’exemple ci-dessus, pour obtenir la valeur sous-jacente dans un cas unique Union discriminée, vous devez le déballer explicitement.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-171">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="5bdcd-172">En outre, DUs prennent également en charge les définitions récursives, ce qui vous permet de représenter facilement des arborescences et, par nature, les données récursives.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-172">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="5bdcd-173">Par exemple, voici comment vous pouvez représenter une arborescence de recherche binaire avec `exists` et `insert` fonctions.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-173">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="5bdcd-174">Étant donné que DUs vous autorisent à représenter la structure récursive de l’arborescence dans le type de données, d’exploitation sur cette structure récursive est simple et garantit l’exactitude.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-174">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="5bdcd-175">Il est également pris en charge dans les critères spéciaux, comme indiqué ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-175">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="5bdcd-176">En outre, vous pouvez représenter DUs en tant que `struct`s avec la `[<Struct>]` attribut :</span><span class="sxs-lookup"><span data-stu-id="5bdcd-176">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="5bdcd-177">Toutefois, il existe deux éléments clés à prendre en compte lorsque vous procédez ainsi :</span><span class="sxs-lookup"><span data-stu-id="5bdcd-177">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="5bdcd-178">Un struct de base de données ne peut pas être défini de manière récursive.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-178">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="5bdcd-179">Un struct est FACTURÉE possèdent des noms uniques pour chacun de ses cas.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-179">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="5bdcd-180">Suivez la méthode ci-dessus entraîne une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-180">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="5bdcd-181">Critères spéciaux</span><span class="sxs-lookup"><span data-stu-id="5bdcd-181">Pattern Matching</span></span>

<span data-ttu-id="5bdcd-182">[Correspondance de modèle](language-reference/pattern-matching.md) est la fonctionnalité du langage F# qui est correct pour l’exploitation de types F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-182">[Pattern Matching](language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="5bdcd-183">Dans les exemples ci-dessus, vous avez probablement remarqué un peu de `match x with ...` syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-183">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="5bdcd-184">Cette construction permet au compilateur, ce qui peut comprendre la « forme » des types de données, à vous obliger à prendre en compte pour tous les cas possibles lors de l’utilisation d’un type de données via ce qui est connu comme Exhaustive des critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-184">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="5bdcd-185">Cela est incroyablement puissante est correcte et peut être intelligemment à « élèvent » ce qui serait normalement pas un problème d’exécution dans la compilation.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-185">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L742)]

<span data-ttu-id="5bdcd-186">Quelque chose que vous avez peut-être remarqué est l’utilisation de la `_` modèle.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-186">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="5bdcd-187">Il s’agit du [modèle de caractère générique](language-reference/pattern-matching.md#wildcard-pattern), qui est une façon de dire « Peu importe ce que quelque chose est ».</span><span class="sxs-lookup"><span data-stu-id="5bdcd-187">This is known as the [Wildcard Pattern](language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="5bdcd-188">Bien que pratique, vous pouvez accidentellement contourner Exhaustive des critères spéciaux et ne bénéficie plus des mises en conformité de la compilation si vous ne faites pas attention à l’aide de `_`.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-188">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="5bdcd-189">Il est particulièrement adapté lorsque vous ne vous souciez certains éléments d’un type décomposé lorsque modèle mise en correspondance ou la clause finale lorsque vous avez énuméré tous les cas significatives dans une expression de critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-189">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="5bdcd-190">[Modèles actifs](language-reference/active-patterns.md) sont une autre construction puissants à utiliser avec les critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-190">[Active Patterns](language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="5bdcd-191">Ils permettent de partitionner les données d’entrée de formulaires personnalisés, les décomposer au site d’appel de correspondance de modèle.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-191">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="5bdcd-192">Ils peuvent également être paramétrés, ce qui permet de définir la partition en tant que fonction.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-192">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="5bdcd-193">Développe l’exemple précédent pour prendre en charge les modèles actifs ressemble à ceci :</span><span class="sxs-lookup"><span data-stu-id="5bdcd-193">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a><span data-ttu-id="5bdcd-194">Types facultatifs</span><span class="sxs-lookup"><span data-stu-id="5bdcd-194">Optional Types</span></span>

<span data-ttu-id="5bdcd-195">Un cas spécial de types Union discriminée est le Type d’Option, ce qui est donc utile qu’il fait partie de la bibliothèque principale F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-195">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="5bdcd-196">[Le Type d’Option](language-reference/options.md) est un type qui représente un des deux cas : une valeur ou rien du tout.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-196">[The Option Type](language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="5bdcd-197">Il est utilisé dans les scénarios où une valeur peut ou ne peut-être pas provenir d’une opération particulière.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-197">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="5bdcd-198">Cela force ensuite pour prendre en compte les deux cas, en rendant un problème lors de la compilation plutôt que d’un problème d’exécution.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-198">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="5bdcd-199">Ceux-ci sont souvent utilisés dans les API où `null` est utilisé pour représenter « nothing » au lieu de cela, ce qui évite à vous soucier `NullReferenceException` dans de nombreux cas.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-199">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a><span data-ttu-id="5bdcd-200">Unités de mesure</span><span class="sxs-lookup"><span data-stu-id="5bdcd-200">Units of Measure</span></span>

<span data-ttu-id="5bdcd-201">Une fonctionnalité unique de système de type F# est la possibilité de fournir un contexte pour les littéraux numériques par le biais des unités de mesure.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-201">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="5bdcd-202">[Unités de mesure](language-reference/units-of-measure.md) vous permettent d’associer un type numérique à une unité, par exemple, en mètres, et ont les fonctions ne fonctionnent sur les unités au lieu de littéraux numériques.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-202">[Units of Measure](language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="5bdcd-203">Cela permet au compilateur vérifier que les types de littéraux numériques passés dans les sens sous un contexte particulier, ce qui évite des erreurs d’exécution associé à ce type de travail.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-203">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L817-L842)]

<span data-ttu-id="5bdcd-204">La bibliothèque principale F# définit plusieurs types d’unités SI et conversions d’unité.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-204">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="5bdcd-205">Pour plus d’informations, consultez le [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="5bdcd-205">To learn more, check out the [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="5bdcd-206">Classes et Interfaces</span><span class="sxs-lookup"><span data-stu-id="5bdcd-206">Classes and Interfaces</span></span>

<span data-ttu-id="5bdcd-207">F# offre également une prise en charge complète pour les classes .NET, [Interfaces](language-reference/interfaces.md), [Classes abstraites](language-reference/abstract-classes.md), [héritage](language-reference/inheritance.md), et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-207">F# also has full support for .NET classes, [Interfaces](language-reference/interfaces.md), [Abstract Classes](language-reference/abstract-classes.md), [Inheritance](language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="5bdcd-208">[Classes](language-reference/classes.md) sont des types qui représentent des objets .NET, qui peut avoir des propriétés, méthodes et événements en tant que son [membres](language-reference/members/index.md).</span><span class="sxs-lookup"><span data-stu-id="5bdcd-208">[Classes](language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L845-L880)]

<span data-ttu-id="5bdcd-209">Définition des classes génériques est également très simple.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-209">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L883-L908)]

<span data-ttu-id="5bdcd-210">Pour implémenter une Interface, vous pouvez utiliser `interface ... with` syntaxe ou un [Expression d’objet](language-reference/object-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="5bdcd-210">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a><span data-ttu-id="5bdcd-211">Les Types à utiliser</span><span class="sxs-lookup"><span data-stu-id="5bdcd-211">Which Types to Use</span></span>

<span data-ttu-id="5bdcd-212">La présence de Classes, les enregistrements, les Unions discriminées et les Tuples mène à une question importante : lequel devez-vous utiliser ?</span><span class="sxs-lookup"><span data-stu-id="5bdcd-212">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="5bdcd-213">Comme pour la plupart des tout dans la vie, la réponse dépend de votre situation.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-213">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="5bdcd-214">Les tuples sont exceptionnelles afin de retourner plusieurs valeurs à partir d’une fonction et à l’aide d’un agrégat ad-hoc de valeurs en tant que valeur lui-même.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-214">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="5bdcd-215">Les enregistrements sont un « step up » à partir de Tuples, avoir nommé étiquettes et la prise en charge des membres facultatifs.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-215">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="5bdcd-216">Elles sont idéales pour une représentation sous forme de cérémonie de faible des données en transit via votre programme.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-216">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="5bdcd-217">Parce qu’ils ont l’égalité structurelle, ils sont faciles à utiliser avec la comparaison.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-217">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="5bdcd-218">Les Unions discriminées ont de nombreuses utilisations, mais les principaux avantages sont de pouvoir les utiliser conjointement avec les critères spéciaux pour prendre en compte pour toutes les possibles « formes » disposant de données.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-218">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="5bdcd-219">Les classes sont idéales pour un très grand nombre de raisons, par exemple lorsque vous devez représentent des informations et également comment lier ces informations à la fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-219">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="5bdcd-220">En règle générale, lorsque vous disposez de fonctionnalités sur le plan conceptuel lié à des données, à l’aide des Classes et les principes de programmation orientée objet est un grand avantage.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-220">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="5bdcd-221">Les classes sont également le type de données par défaut lors de l’interaction avec c# et Visual Basic, comme ces langues utilisent des classes pour quasiment tous les éléments.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-221">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="5bdcd-222">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="5bdcd-222">Next Steps</span></span>

<span data-ttu-id="5bdcd-223">Maintenant que vous avez vu certaines des principales fonctionnalités du langage, vous devez être prêt à écrire vos premiers programmes F# !</span><span class="sxs-lookup"><span data-stu-id="5bdcd-223">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="5bdcd-224">Découvrez [mise en route](tutorials/getting-started/index.md) pour savoir comment configurer votre environnement de développement et d’écrire du code.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-224">Check out [Getting Started](tutorials/getting-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="5bdcd-225">Les étapes suivantes pour en savoir plus peuvent être comme vous le souhaitez, mais nous vous recommandons de [Introduction à la programmation fonctionnelle dans F# ](introduction-to-functional-programming/index.md) à se familiariser avec les principaux concepts de programmation fonctionnelle.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-225">The next steps for learning more can be whatever you like, but we recommend [Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md) to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="5bdcd-226">Il s’agira essentielles dans la création de programmes robustes en F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-226">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="5bdcd-227">Consultez également le [référence du langage F#](language-reference/index.md) pour voir un ensemble complet de contenu conceptuel sur F#.</span><span class="sxs-lookup"><span data-stu-id="5bdcd-227">Also, check out the [F# Language Reference](language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
