---
title: Modèles de données cloud natifs
description: Architecture des applications .NET natives Cloud pour Azure | Modèles de données natifs du Cloud
ms.date: 06/30/2019
ms.openlocfilehash: 0d251f3046fcd3f3a2f5d856a123a35d3f7ecff2
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73087698"
---
# <a name="cloud-native-data-patterns"></a><span data-ttu-id="ffc72-103">Modèles de données cloud natifs</span><span class="sxs-lookup"><span data-stu-id="ffc72-103">Cloud-native data patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="ffc72-104">Si les données décentralisées peuvent améliorer les performances, l’évolutivité et les économies, elles présentent également de nombreux défis.</span><span class="sxs-lookup"><span data-stu-id="ffc72-104">While decentralized data can lead to improved performance, scalability, and cost savings, it also presents many challenges.</span></span> <span data-ttu-id="ffc72-105">L’interrogation des données entre les microservices est complexe.</span><span class="sxs-lookup"><span data-stu-id="ffc72-105">Querying for data across microservices is complex.</span></span> <span data-ttu-id="ffc72-106">Une transaction qui s’étend sur les microservices doit être gérée par programmation, car les transactions distribuées ne sont pas prises en charge dans les applications natives du Cloud.</span><span class="sxs-lookup"><span data-stu-id="ffc72-106">A transaction that spans microservices must be managed programmatically as distributed transactions aren't supported in cloud-native applications.</span></span> <span data-ttu-id="ffc72-107">Vous passez d’un monde de *cohérence immédiate* à *la cohérence éventuelle*.</span><span class="sxs-lookup"><span data-stu-id="ffc72-107">You  move from a world of *immediate consistency* to *eventual consistency*.</span></span>

<span data-ttu-id="ffc72-108">Nous aborderons ces défis maintenant.</span><span class="sxs-lookup"><span data-stu-id="ffc72-108">We discuss these challenges now.</span></span>

## <a name="cross-service-queries"></a><span data-ttu-id="ffc72-109">Requêtes entre services</span><span class="sxs-lookup"><span data-stu-id="ffc72-109">Cross-service queries</span></span>

<span data-ttu-id="ffc72-110">Comment une application interroge-t-elle les données qui sont réparties sur plusieurs microservices indépendants ?</span><span class="sxs-lookup"><span data-stu-id="ffc72-110">How does an application query data that is spread across many independent microservices?</span></span>

<span data-ttu-id="ffc72-111">La figure 5-4 illustre ce scénario.</span><span class="sxs-lookup"><span data-stu-id="ffc72-111">Figure 5-4 shows this scenario.</span></span>

![Interrogation sur des microservices](./media/cross-service-query.png)

<span data-ttu-id="ffc72-113">**Figure 5-4**.</span><span class="sxs-lookup"><span data-stu-id="ffc72-113">**Figure 5-4**.</span></span> <span data-ttu-id="ffc72-114">Interrogation sur des microservices</span><span class="sxs-lookup"><span data-stu-id="ffc72-114">Querying across microservices</span></span>

<span data-ttu-id="ffc72-115">Notez comment, dans la figure précédente, nous voyons un microservice de panier d’achat qui ajoute un élément au panier d’achat d’un utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ffc72-115">Note how in the previous figure we see a shopping basket microservice that adds an item to a user's shopping cart.</span></span> <span data-ttu-id="ffc72-116">Alors que le magasin de données du panier d’achat contient une table basket et lineItem, il ne contient pas de données de produit ou de tarification, car ces éléments se trouvent dans les microservices Product et Price.</span><span class="sxs-lookup"><span data-stu-id="ffc72-116">While the shopping basket's data store contains a basket and lineItem table, it doesn't contain product or pricing data as those items are found in the product and price microservices.</span></span> <span data-ttu-id="ffc72-117">Pour ajouter un élément, le microservice du panier d’achat a besoin des données de produit et de tarification.</span><span class="sxs-lookup"><span data-stu-id="ffc72-117">To add an item, the shopping basket microservice needs product data and pricing data.</span></span> <span data-ttu-id="ffc72-118">Quelles sont les options permettant d’obtenir le produit et les données de tarification ?</span><span class="sxs-lookup"><span data-stu-id="ffc72-118">What are options to obtain the product and pricing data?</span></span>

<span data-ttu-id="ffc72-119">La figure 5-5 montre le microservice du panier d’achat qui effectue un appel HTTP direct au catalogue de produits et aux microservices de tarification.</span><span class="sxs-lookup"><span data-stu-id="ffc72-119">Figure 5-5 shows the shopping basket microservice making a direct HTTP call to both the product catalog and pricing microservices.</span></span>

![Communication http directe](./media/direct-http-communication.png)

<span data-ttu-id="ffc72-121">**Figure 5-5**.</span><span class="sxs-lookup"><span data-stu-id="ffc72-121">**Figure 5-5**.</span></span> <span data-ttu-id="ffc72-122">Communication HTTP directe</span><span class="sxs-lookup"><span data-stu-id="ffc72-122">Direct HTTP communication</span></span>

<span data-ttu-id="ffc72-123">Tout en réalisant l’implémentation, dans le chapitre 4, nous avons abordé la manière dont les appels HTTP directs entre les microservices couplent le système et ne sont pas considérés comme une bonne pratique.</span><span class="sxs-lookup"><span data-stu-id="ffc72-123">While feasible to implement, in chapter 4 we discussed how direct HTTP calls across microservices couple the system and aren't considered a good practice.</span></span>

<span data-ttu-id="ffc72-124">Nous pourrions implémenter un microservice d’agrégation illustré à la figure 5-6.</span><span class="sxs-lookup"><span data-stu-id="ffc72-124">We could implement an aggregator microservice shown in Figure 5-6.</span></span>

![Microservice de l’agrégateur](./media/aggregator-microservice.png)

<span data-ttu-id="ffc72-126">**Figure 5-6.**</span><span class="sxs-lookup"><span data-stu-id="ffc72-126">**Figure 5-6.**</span></span> <span data-ttu-id="ffc72-127">Microservice de l’agrégateur</span><span class="sxs-lookup"><span data-stu-id="ffc72-127">Aggregator microservice</span></span>

<span data-ttu-id="ffc72-128">Bien que cette approche encapsule le flux de travail de l’opération d’entreprise dans un microservice individuel, elle ajoute de la complexité et entraîne toujours des appels HTTP directs.</span><span class="sxs-lookup"><span data-stu-id="ffc72-128">While this approach encapsulates the business operation workflow in an individual microservice, it adds complexity and still results in direct HTTP calls.</span></span>

<span data-ttu-id="ffc72-129">Une approche courante pour l’exécution de requêtes entre services utilise le [modèle de vue matérialisée](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), illustré à la figure 5-7.</span><span class="sxs-lookup"><span data-stu-id="ffc72-129">A common approach for executing cross-service queries uses the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-7.</span></span>

![Modèle de vue matérialisée](./media/materialized-view-pattern.png)

<span data-ttu-id="ffc72-131">**Figure5-7**.</span><span class="sxs-lookup"><span data-stu-id="ffc72-131">**Figure5-7**.</span></span> <span data-ttu-id="ffc72-132">Modèle de vue matérialisée</span><span class="sxs-lookup"><span data-stu-id="ffc72-132">Materialized View Pattern</span></span>

<span data-ttu-id="ffc72-133">Avec ce modèle, vous placez directement une table locale (appelée modèle de *lecture*) dans le service panier d’achat qui contient une copie dénormalisée des données nécessaires à partir des microservices de produit et de tarification.</span><span class="sxs-lookup"><span data-stu-id="ffc72-133">With this pattern, you directly place a local table (known as a *read model*) in the shopping basket service that contains a denormalized copy of the data that is needed from the product and pricing microservices.</span></span> <span data-ttu-id="ffc72-134">Le placement de ces données dans le microservice du panier d’achat élimine la nécessité d’appeler des appels inter-services onéreux.</span><span class="sxs-lookup"><span data-stu-id="ffc72-134">Placing that data inside the shopping basket microservice eliminates the need for invoking expensive cross-service calls.</span></span> <span data-ttu-id="ffc72-135">Avec les données locales au service, vous améliorez le temps de réponse et la fiabilité.</span><span class="sxs-lookup"><span data-stu-id="ffc72-135">With the data local to the service, you improve response time and reliability.</span></span>

<span data-ttu-id="ffc72-136">La capture avec cette approche vous offre maintenant des données dupliquées dans votre système.</span><span class="sxs-lookup"><span data-stu-id="ffc72-136">The catch with this approach is you now have duplicate data in your system.</span></span> <span data-ttu-id="ffc72-137">Dans les systèmes Cloud natifs, les données dupliquées ne sont pas considérées comme un [anti-modèle](https://en.wikipedia.org/wiki/Anti-pattern) et sont généralement implémentées dans les systèmes natifs du Cloud.</span><span class="sxs-lookup"><span data-stu-id="ffc72-137">In cloud-native systems, duplicate data isn't considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) and is commonly implemented in cloud-native systems.</span></span> <span data-ttu-id="ffc72-138">Toutefois, un seul système peut être propriétaire d’un jeu de données, et vous devez implémenter un mécanisme de synchronisation pour le système d’enregistrement afin de mettre à jour tous les modèles de lecture associés, chaque fois qu’une modification de ses données sous-jacentes se produit.</span><span class="sxs-lookup"><span data-stu-id="ffc72-138">However, one and only one system can be the owner of any dataset, and you'll need to implement a synchronization mechanism for the system of record to update all of the associated read models, whenever a change to its underlying data occurs.</span></span>

## <a name="transactional-support"></a><span data-ttu-id="ffc72-139">Prise en charge transactionnelle</span><span class="sxs-lookup"><span data-stu-id="ffc72-139">Transactional support</span></span>

<span data-ttu-id="ffc72-140">Si les requêtes sur les microservices sont difficiles, l’implémentation d’une transaction entre les microservices peut être complexe.</span><span class="sxs-lookup"><span data-stu-id="ffc72-140">While queries across microservices are challenging, implementing a transaction across microservices can be complex.</span></span> <span data-ttu-id="ffc72-141">Le défi inhérent à la gestion de la cohérence des données entre les sources de données qui résident dans des microservices différents ne peut pas être sous-état.</span><span class="sxs-lookup"><span data-stu-id="ffc72-141">The inherent challenge of maintaining data consistency across data sources that reside in different microservices can't be understated.</span></span> <span data-ttu-id="ffc72-142">La figure 5-8 illustre le problème.</span><span class="sxs-lookup"><span data-stu-id="ffc72-142">Figure 5-8 shows the problem.</span></span>

![Transaction dans le modèle saga](./media/saga-transaction-operation.png)

<span data-ttu-id="ffc72-144">**Figure 5-8**.</span><span class="sxs-lookup"><span data-stu-id="ffc72-144">**Figure 5-8**.</span></span> <span data-ttu-id="ffc72-145">Implémentation d’une transaction sur des microservices</span><span class="sxs-lookup"><span data-stu-id="ffc72-145">Implementing a transaction across microservices</span></span>

<span data-ttu-id="ffc72-146">Notez comment, dans la figure précédente, cinq microservices indépendants participent à une transaction de *commande de création* distribuée.</span><span class="sxs-lookup"><span data-stu-id="ffc72-146">Note how in the previous figure five independent microservices all participate in a distributed *Create Order* transaction.</span></span> <span data-ttu-id="ffc72-147">Toutefois, la transaction pour chacun des cinq microservices individuels doit être réussie, ou tous doivent abandonner et annuler l’opération.</span><span class="sxs-lookup"><span data-stu-id="ffc72-147">However, the transaction for each of the five individual microservices must succeed, or all must abort and roll-back the operation.</span></span> <span data-ttu-id="ffc72-148">Alors que la prise en charge transactionnelle intégrée est disponible dans chacun des microservices, il n’existe pas de prise en charge d’une transaction distribuée sur les cinq services.</span><span class="sxs-lookup"><span data-stu-id="ffc72-148">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction across all five services.</span></span>

<span data-ttu-id="ffc72-149">Étant donné que la prise en charge transactionnelle est essentielle pour que cette opération maintienne les données cohérentes dans chacun des microservices, vous devez construire par programmation une transaction distribuée.</span><span class="sxs-lookup"><span data-stu-id="ffc72-149">Since transactional support is essential for this operation to keep the data consistent in each of the microservices, you have to programmatically construct a distributed transaction.</span></span>

<span data-ttu-id="ffc72-150">Un modèle répandu pour l’ajout par programmation de la prise en charge transactionnelle est le [modèle saga](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span><span class="sxs-lookup"><span data-stu-id="ffc72-150">A popular pattern for programmatically adding transactional support is the [Saga pattern](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span></span> <span data-ttu-id="ffc72-151">Elle est implémentée par le regroupement des transactions locales et l’appel séquentiel de chacune d’elles.</span><span class="sxs-lookup"><span data-stu-id="ffc72-151">It's implemented by grouping local transactions together and sequentially invoking each one.</span></span> <span data-ttu-id="ffc72-152">En cas d’échec d’une transaction locale, saga abandonne l’opération et appelle un ensemble de [transactions de compensation](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) pour annuler les modifications apportées par les transactions locales précédentes.</span><span class="sxs-lookup"><span data-stu-id="ffc72-152">If a local transaction fails, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) to undo the changes made by the preceding local transactions.</span></span> <span data-ttu-id="ffc72-153">La figure 5-9 montre une transaction ayant échoué avec le modèle saga.</span><span class="sxs-lookup"><span data-stu-id="ffc72-153">Figure 5-9 shows a failed transaction with the Saga pattern.</span></span>

![Restauration dans le modèle saga](./media/saga-rollback-operation.png)

<span data-ttu-id="ffc72-155">**Figure 5-9**.</span><span class="sxs-lookup"><span data-stu-id="ffc72-155">**Figure 5-9**.</span></span> <span data-ttu-id="ffc72-156">Restauration d'une transaction</span><span class="sxs-lookup"><span data-stu-id="ffc72-156">Rolling back a transaction</span></span>

<span data-ttu-id="ffc72-157">Notez comment, dans la figure précédente, l’opération *GenerateContent* a échoué dans le microservice musical.</span><span class="sxs-lookup"><span data-stu-id="ffc72-157">Note how in the previous figure the *GenerateContent* operation has failed in the music microservice.</span></span> <span data-ttu-id="ffc72-158">Le saga appelle les transactions de compensation (en rouge) pour supprimer le contenu, annuler le paiement et annuler la commande, en retournant les données pour chaque microservice dans un état cohérent.</span><span class="sxs-lookup"><span data-stu-id="ffc72-158">The Saga invokes compensating transactions (in red) to remove the content, cancel the payment, and cancel the order, returning the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="ffc72-159">Les modèles Saga sont généralement des chorégraphiés sous la forme d’une série d’événements connexes ou orchestrés sous la forme d’un ensemble de commandes associées.</span><span class="sxs-lookup"><span data-stu-id="ffc72-159">Saga patterns are typically choreographed as a series of related events or orchestrated as a set of related commands.</span></span>

## <a name="cqrs-pattern"></a><span data-ttu-id="ffc72-160">Modèle CQRS</span><span class="sxs-lookup"><span data-stu-id="ffc72-160">CQRS pattern</span></span>

<span data-ttu-id="ffc72-161">CQRS, ou [séparation des responsabilités en matière de commande et de requête](https://docs.microsoft.com/azure/architecture/patterns/cqrs), est un modèle architectural qui sépare les opérations qui lisent les données de celles qui écrivent des données.</span><span class="sxs-lookup"><span data-stu-id="ffc72-161">CQRS, or [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that separate operations that read data from those that write data.</span></span> <span data-ttu-id="ffc72-162">Ce modèle peut contribuer à optimiser les performances, l’évolutivité et la sécurité.</span><span class="sxs-lookup"><span data-stu-id="ffc72-162">This pattern can help maximize performance, scalability, and security.</span></span>

<span data-ttu-id="ffc72-163">Dans les scénarios d’accès aux données normaux, vous implémentez un seul modèle (objet d’entité et de référentiel) qui effectuent à la *fois des* opérations de lecture et d’écriture de données.</span><span class="sxs-lookup"><span data-stu-id="ffc72-163">In normal data access scenarios, you implement a single model (entity and repository object) that perform *both* read and write data operations.</span></span>

<span data-ttu-id="ffc72-164">Toutefois, un scénario d’accès aux données plus avancé peut tirer parti de modèles et de tables de données distincts pour les lectures et les écritures.</span><span class="sxs-lookup"><span data-stu-id="ffc72-164">However, a more advanced data access scenario might benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="ffc72-165">Pour améliorer les performances, l’opération de lecture, connue sous le nom de *requête*, peut interroger une représentation fortement dénormalisée des données afin d’éviter des jointures de table répétitives coûteuses.</span><span class="sxs-lookup"><span data-stu-id="ffc72-165">To improve performance, the read operation, known as a *query*, might query against a highly denormalized representation of the data to avoid expensive repetitive table joins.</span></span> <span data-ttu-id="ffc72-166">Tandis que l’opération d' *écriture* , appelée *commande*, peut être mise à jour par rapport à une représentation entièrement normalisée des données.</span><span class="sxs-lookup"><span data-stu-id="ffc72-166">Whereas the *write* operation, known as a *command*, might update against a fully normalized representation of the data.</span></span> <span data-ttu-id="ffc72-167">Vous devez ensuite implémenter un mécanisme pour maintenir la synchronisation des deux représentations. En général, chaque fois que la table d’écriture est modifiée, elle déclenche un événement qui réplique la modification des données dans la table de lecture.</span><span class="sxs-lookup"><span data-stu-id="ffc72-167">You would then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it raises an event that replicates the data modification to the read table.</span></span>

<span data-ttu-id="ffc72-168">La figure 5-10 illustre une implémentation du modèle CQRS.</span><span class="sxs-lookup"><span data-stu-id="ffc72-168">Figure 5-10 shows an implementation of the CQRS pattern.</span></span>

![Implémentation CQRS](./media/cqrs-implementation.png)

<span data-ttu-id="ffc72-170">**Figure 5-10**.</span><span class="sxs-lookup"><span data-stu-id="ffc72-170">**Figure 5-10**.</span></span> <span data-ttu-id="ffc72-171">Implémentation CQRS</span><span class="sxs-lookup"><span data-stu-id="ffc72-171">CQRS implementation</span></span>

<span data-ttu-id="ffc72-172">Notez comment, dans la figure précédente, des modèles de commande et de requête distincts sont implémentés.</span><span class="sxs-lookup"><span data-stu-id="ffc72-172">Note how in the previous figure separate command and query models are implemented.</span></span> <span data-ttu-id="ffc72-173">En outre, chaque opération d’écriture de données est enregistrée dans le magasin d’écriture, puis propagée vers le magasin de lecture.</span><span class="sxs-lookup"><span data-stu-id="ffc72-173">Moreover, each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="ffc72-174">Portez une attention particulière à la façon dont le processus de propagation opère sur le principe de [cohérence éventuelle](https://www.cloudcomputingpatterns.org/eventual_consistency/), tandis que le modèle de lecture finit par se synchroniser avec le modèle d’écriture, mais il peut y avoir un décalage dans le processus.</span><span class="sxs-lookup"><span data-stu-id="ffc72-174">Pay close attention to how the propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), whereas the read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span>

<span data-ttu-id="ffc72-175">En implémentant la séparation, vous avez la possibilité de mettre à l’échelle les lectures et les écritures séparément.</span><span class="sxs-lookup"><span data-stu-id="ffc72-175">By implementing separation, you have the ability to scale reads and writes separately.</span></span> <span data-ttu-id="ffc72-176">En outre, vous pouvez imposer une sécurité plus étroite sur les opérations d’écriture que celles relatives aux lectures.</span><span class="sxs-lookup"><span data-stu-id="ffc72-176">As well, you might impose tighter security on write operations than those concerning reads.</span></span>

<span data-ttu-id="ffc72-177">En règle générale, les modèles CQRS sont appliqués à des sections limitées de votre système en fonction de vos besoins spécifiques.</span><span class="sxs-lookup"><span data-stu-id="ffc72-177">Typically, CQRS patterns are applied to limited sections of your system based upon specific needs.</span></span>

## <a name="relational-vs-nosql"></a><span data-ttu-id="ffc72-178">Comparaison entre NoSQL et NoSQL</span><span class="sxs-lookup"><span data-stu-id="ffc72-178">Relational vs NoSQL</span></span>

<span data-ttu-id="ffc72-179">L’impact des technologies [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) ne peut pas être surétat, en particulier pour les systèmes Cloud natifs distribués.</span><span class="sxs-lookup"><span data-stu-id="ffc72-179">The impact of [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologies can't be overstated, especially for distributed cloud-native systems.</span></span> <span data-ttu-id="ffc72-180">La prolifération des nouvelles technologies de données dans cet espace a perturbé les solutions qui, une fois exclusivement, s’appuyaient sur des bases de données relationnelles.</span><span class="sxs-lookup"><span data-stu-id="ffc72-180">The proliferation of new data technologies in this space has disrupted solutions that once exclusively relied on relational databases.</span></span>

<span data-ttu-id="ffc72-181">D’un côté, les bases de données relationnelles ont été une technologie répandue depuis des décennies.</span><span class="sxs-lookup"><span data-stu-id="ffc72-181">On the one side, relational databases have been a prevalent technology for decades.</span></span> <span data-ttu-id="ffc72-182">Elles sont matures, éprouvées et largement implémentées.</span><span class="sxs-lookup"><span data-stu-id="ffc72-182">They're mature, proven, and widely implemented.</span></span> <span data-ttu-id="ffc72-183">Les produits de base de données concurrents, l’expertise et les outils sont nombreux.</span><span class="sxs-lookup"><span data-stu-id="ffc72-183">Competing database products, expertise and tooling abounds.</span></span> <span data-ttu-id="ffc72-184">Les bases de données relationnelles fournissent un magasin de tables de données associées.</span><span class="sxs-lookup"><span data-stu-id="ffc72-184">Relational databases provide a store of related data tables.</span></span> <span data-ttu-id="ffc72-185">Ces tables ont un schéma fixe, utilisent SQL (langage SQL) pour gérer les données et ont des garanties [acid](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (également appelées atomicité, cohérence, isolation et durabilité).</span><span class="sxs-lookup"><span data-stu-id="ffc72-185">These tables have a fixed schema, use SQL (Structured Query Language) to manage data and have [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (also known as Atomicity, Consistency, Isolation, and Durability) guarantees.</span></span>

<span data-ttu-id="ffc72-186">Les bases de données non-SQL, de l’autre côté, font référence à des magasins de données non relationnels, à hautes performances.</span><span class="sxs-lookup"><span data-stu-id="ffc72-186">No-SQL databases, on the other side, refer to high-performance, non-relational data stores.</span></span> <span data-ttu-id="ffc72-187">Ils utilisent Excel dans leurs caractéristiques de facilité d’utilisation, d’évolutivité, de résilience et de disponibilité.</span><span class="sxs-lookup"><span data-stu-id="ffc72-187">They excel in their ease-of-use, scalability, resilience, and availability characteristics.</span></span> <span data-ttu-id="ffc72-188">Au lieu de joindre des tables de données normalisées, NoSQL stocke des données auto-descriptives (sans schéma) généralement dans des documents JSON.</span><span class="sxs-lookup"><span data-stu-id="ffc72-188">Instead of joining tables of normalized data, NoSQL stores self-describing (schemaless) data typically in JSON documents.</span></span> <span data-ttu-id="ffc72-189">Ils n’offrent pas de garanties [acid](https://www.geeksforgeeks.org/acid-properties-in-dbms/) .</span><span class="sxs-lookup"><span data-stu-id="ffc72-189">They don't offer [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) guarantees.</span></span>

<span data-ttu-id="ffc72-190">Un moyen de comprendre les différences entre ces types de bases de données se trouve dans le registre des [Cap](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), un ensemble de principes qui peuvent être appliqués aux systèmes distribués qui stockent l’État.</span><span class="sxs-lookup"><span data-stu-id="ffc72-190">A way to understand the differences between these types of databases can be found in the [CAP theorem](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), a set of principles that can be applied to distributed systems that store state.</span></span> <span data-ttu-id="ffc72-191">La figure 5-11 montre les trois propriétés de l’embout de CAP.</span><span class="sxs-lookup"><span data-stu-id="ffc72-191">Figure 5-11 shows the three properties of the CAP theorem.</span></span>

![CAP CAP](./media/cap-theorem.png)

<span data-ttu-id="ffc72-193">**Figure 5-11**.</span><span class="sxs-lookup"><span data-stu-id="ffc72-193">**Figure 5-11**.</span></span> <span data-ttu-id="ffc72-194">Le niveau de CAP</span><span class="sxs-lookup"><span data-stu-id="ffc72-194">The CAP theorem</span></span>

<span data-ttu-id="ffc72-195">Le titre de l’état d’un système de données distribuées offre un compromis entre cohérence, disponibilité et tolérance de partition, et n’importe quelle base de données ne peut garantir que deux des trois propriétés :</span><span class="sxs-lookup"><span data-stu-id="ffc72-195">The theorem states that any distributed data system will offer a trade-off between consistency, availability, and partition tolerance, and that any database can only guarantee two of the three properties:</span></span>

- <span data-ttu-id="ffc72-196">*Cohérence*: chaque nœud du cluster répondra avec les données les plus récentes, même s’il nécessite de bloquer une demande jusqu’à ce que tous les réplicas soient correctement mis à jour.</span><span class="sxs-lookup"><span data-stu-id="ffc72-196">*Consistency*: every node in the cluster will respond with the most recent data, even if it requires blocking a request until all replicas are correctly updated.</span></span>

- <span data-ttu-id="ffc72-197">*Disponibilité*: chaque nœud renvoie une réponse dans un laps de temps raisonnable, même si cette réponse n’est pas les données les plus récentes.</span><span class="sxs-lookup"><span data-stu-id="ffc72-197">*Availability*: every node will return a response in a reasonable amount of time, even if that response isn't the most recent data.</span></span>

- <span data-ttu-id="ffc72-198">*Tolérance*de la partition : garantit que le système continuera à fonctionner en cas de défaillance d’un nœud ou de perte de la connectivité avec un autre.</span><span class="sxs-lookup"><span data-stu-id="ffc72-198">*Partition Tolerance*: guarantees that the system will continue operating if a node fails or loses connectivity with another.</span></span>

<span data-ttu-id="ffc72-199">Les bases de données relationnelles présentent la cohérence et la disponibilité, mais pas la tolérance de partition.</span><span class="sxs-lookup"><span data-stu-id="ffc72-199">Relational databases exhibit consistency and availability, but not partition tolerance.</span></span> <span data-ttu-id="ffc72-200">Le partitionnement d’une base de données relationnelle, telle que partitionnement, est difficile et peut avoir un impact sur les performances.</span><span class="sxs-lookup"><span data-stu-id="ffc72-200">Partitioning a relational database, such as sharding, is difficult and can impact performance.</span></span>

<span data-ttu-id="ffc72-201">En revanche, les bases de données NoSQL présentent généralement la tolérance de la partition, appelée évolutivité horizontale et haute disponibilité.</span><span class="sxs-lookup"><span data-stu-id="ffc72-201">On the other hand, NoSQL databases typically exhibit partition tolerance, known as horizontal scalability, and high availability.</span></span> <span data-ttu-id="ffc72-202">À mesure que le niveau de CAP spécifie, vous ne pouvez avoir que deux des trois principes et vous perdez la propriété Consistency.</span><span class="sxs-lookup"><span data-stu-id="ffc72-202">As the CAP theorem specifies, you can only have two of the three principles, and you lose the  consistency property.</span></span>

<span data-ttu-id="ffc72-203">Les bases de données NoSQL sont distribuées et généralement mises à l’échelle sur les serveurs de base.</span><span class="sxs-lookup"><span data-stu-id="ffc72-203">NoSQL databases are distributed and commonly scaled out across commodity servers.</span></span> <span data-ttu-id="ffc72-204">Cela peut offrir une disponibilité exceptionnelle, à la fois dans et dans les régions géographiques à un coût réduit.</span><span class="sxs-lookup"><span data-stu-id="ffc72-204">Doing so can provide great availability, both within and across geographical regions at a reduced cost.</span></span> <span data-ttu-id="ffc72-205">Les données peuvent être partitionnées et répliquées sur ces ordinateurs, ou nœuds, fournissant ainsi une redondance et une tolérance de panne.</span><span class="sxs-lookup"><span data-stu-id="ffc72-205">Data can be partitioned and replicated across these machines, or nodes, providing redundancy and fault tolerance.</span></span> <span data-ttu-id="ffc72-206">L’inconvénient est la cohérence.</span><span class="sxs-lookup"><span data-stu-id="ffc72-206">The downside is consistency.</span></span> <span data-ttu-id="ffc72-207">Une modification des données sur un nœud NoSQL peut prendre un certain temps pour se propager à d’autres nœuds.</span><span class="sxs-lookup"><span data-stu-id="ffc72-207">A change to data on one NoSQL node can take some time to propagate to other nodes.</span></span> <span data-ttu-id="ffc72-208">En règle générale, un nœud de base de données NoSQL fournit une réponse immédiate à une requête, même si les données qu’elle présente sont obsolètes et n’ont pas encore été mises à jour.</span><span class="sxs-lookup"><span data-stu-id="ffc72-208">Typically, a NoSQL database node will provide an immediate response to a query, even if the data that it is presenting is stale and has not been updated yet.</span></span>

<span data-ttu-id="ffc72-209">Il s’agit d’une [cohérence éventuelle](https://www.cloudcomputingpatterns.org/eventual_consistency/), caractéristique des systèmes de données distribués où les transactions ACID ne sont pas prises en charge.</span><span class="sxs-lookup"><span data-stu-id="ffc72-209">This is known [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), a characteristic of distributed data systems where ACID transactions aren't supported.</span></span> <span data-ttu-id="ffc72-210">Il s’agit d’un bref délai entre la mise à jour d’un élément de données et le temps nécessaire à la propagation de cette mise à jour à chacun des nœuds de réplica.</span><span class="sxs-lookup"><span data-stu-id="ffc72-210">It's a brief delay between the update of a data item and time that it takes to propagate that update to each of the replica nodes.</span></span> <span data-ttu-id="ffc72-211">Si vous mettez à jour un élément de produit dans une base de données NoSQL dans le États-Unis, mais en même temps interrogez ce même élément de données à partir d’un nœud de réplica en Europe, vous pouvez récupérer les informations de produit antérieures, jusqu’à ce que le nœud européen ait été mis à jour avec la modification du produit.</span><span class="sxs-lookup"><span data-stu-id="ffc72-211">If you update a product item in a NoSQL database in the United States, but at same time query that same data item from a replica node in Europe, you might retrieve the earlier product information - until the European node has been updated with product change.</span></span> <span data-ttu-id="ffc72-212">Le compromis est qu’en donnant une [cohérence forte](https://en.wikipedia.org/wiki/Strong_consistency), en attendant que tous les nœuds de réplica soient mis à jour avant de retourner un résultat de requête, vous pouvez prendre en charge une grande échelle et un volume de trafic énorme, mais avec la possibilité de présenter des données plus anciennes.</span><span class="sxs-lookup"><span data-stu-id="ffc72-212">The trade-off is that by giving up [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency),  waiting for all replica nodes to update before returning a query result, you can support enormous scale and traffic volume, but with the possibility of presenting older data.</span></span>

<span data-ttu-id="ffc72-213">Les bases de données NoSQL peuvent être classées selon les quatre modèles suivants :</span><span class="sxs-lookup"><span data-stu-id="ffc72-213">NoSQL databases can be categorized by the following four models:</span></span>

- <span data-ttu-id="ffc72-214">*Magasin de documents* (MongoDB, CouchDB, Couchbase) : les données (et les métadonnées correspondantes) sont stockées de façon non relationnelle dans des documents JSON dénormalisés à l’intérieur de la base de données.</span><span class="sxs-lookup"><span data-stu-id="ffc72-214">*Document Store* (MongoDB, CouchDB, Couchbase): data (and corresponding metadata) is stored non-relationally in denormalized JSON-based documents inside the database.</span></span>

- <span data-ttu-id="ffc72-215">*Stockage de clé/valeur* (redims, Riak, Memcached) : les données sont stockées dans des paires clé-valeur simples avec des opérations système effectuées par rapport à une clé d’accès unique qui est mappée à une valeur de données utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ffc72-215">*Key/Value Store* (Redis, Riak, memcached): data is stored in simple key-value pairs with system operations performed against a unique access key that is mapped to a value of user data.</span></span>

- <span data-ttu-id="ffc72-216">*Stockage à colonnes larges* (HBase, Cassandra) : les données associées sont stockées dans un format de colonne sous la forme d’un ensemble de paires clé/valeur imbriquées au sein d’une même colonne avec des données généralement récupérées en tant qu’unité unique sans devoir joindre plusieurs tables.</span><span class="sxs-lookup"><span data-stu-id="ffc72-216">*Wide-Column Store* (HBase, Cassandra): related Data is stored in a columnar format as a set of nested-key/value pairs within a single column with data typically retrieved as a single unit without having to join multiple tables together.</span></span>

- <span data-ttu-id="ffc72-217">*Magasins de graphiques* (neo4j, Titan) : les données sont stockées sous la forme d’une représentation graphique au sein d’un nœud avec les bords qui spécifient la relation entre les nœuds.</span><span class="sxs-lookup"><span data-stu-id="ffc72-217">*Graph stores* (neo4j, titan): data is stored as a graphical representation within a node along with edges that specify the relationship between the nodes.</span></span>

<span data-ttu-id="ffc72-218">Les bases de données NoSQL peuvent être optimisées pour gérer les données à grande échelle, en particulier lorsque les données sont relativement simples.</span><span class="sxs-lookup"><span data-stu-id="ffc72-218">NoSQL databases can be optimized to deal with large-scale data, especially when the data is relatively simple.</span></span> <span data-ttu-id="ffc72-219">Prenons l’exemple d’une base de données NoSQL :</span><span class="sxs-lookup"><span data-stu-id="ffc72-219">Consider a NoSQL database when:</span></span>

- <span data-ttu-id="ffc72-220">Votre charge de travail nécessite une grande échelle et une haute concurrence.</span><span class="sxs-lookup"><span data-stu-id="ffc72-220">Your workload requires large-scale and high-concurrency.</span></span>
- <span data-ttu-id="ffc72-221">Vous avez un grand nombre d’utilisateurs.</span><span class="sxs-lookup"><span data-stu-id="ffc72-221">You have large numbers of users.</span></span>
- <span data-ttu-id="ffc72-222">Vos données peuvent être exprimées simplement sans relations.</span><span class="sxs-lookup"><span data-stu-id="ffc72-222">Your data can be expressed simply without relationships.</span></span>
- <span data-ttu-id="ffc72-223">Vous devez distribuer vos données géographiquement.</span><span class="sxs-lookup"><span data-stu-id="ffc72-223">You need to geographically distribute your data.</span></span>
- <span data-ttu-id="ffc72-224">Vous n’avez pas besoin de garanties ACID.</span><span class="sxs-lookup"><span data-stu-id="ffc72-224">You don't need ACID guarantees.</span></span>
- <span data-ttu-id="ffc72-225">Sera déployé sur le matériel de produit.</span><span class="sxs-lookup"><span data-stu-id="ffc72-225">Will be deployed to commodity hardware.</span></span>

<span data-ttu-id="ffc72-226">Envisagez ensuite une base de données relationnelle lorsque :</span><span class="sxs-lookup"><span data-stu-id="ffc72-226">Then, consider a relational database when:</span></span>

- <span data-ttu-id="ffc72-227">Vos charges de travail nécessitent une échelle moyenne à grande.</span><span class="sxs-lookup"><span data-stu-id="ffc72-227">Your workloads require medium to large scale.</span></span>
- <span data-ttu-id="ffc72-228">La concurrence n’est pas un problème majeur.</span><span class="sxs-lookup"><span data-stu-id="ffc72-228">Concurrency isn't a major concern.</span></span>
- <span data-ttu-id="ffc72-229">Des garanties ACID sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="ffc72-229">ACID guarantees are needed.</span></span>
- <span data-ttu-id="ffc72-230">Les données sont mieux exprimées de manière relationnelle.</span><span class="sxs-lookup"><span data-stu-id="ffc72-230">Data is best expressed relationally.</span></span>
- <span data-ttu-id="ffc72-231">Votre application sera déployée sur un matériel haut de gamme.</span><span class="sxs-lookup"><span data-stu-id="ffc72-231">Your application will be deployed to large, high-end hardware.</span></span>

<span data-ttu-id="ffc72-232">Ensuite, nous examinons le stockage des données dans le Cloud Azure.</span><span class="sxs-lookup"><span data-stu-id="ffc72-232">Next, we look at data storage in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="ffc72-233">[Précédent](distributed-data.md)
>[Suivant](azure-data-storage.md)</span><span class="sxs-lookup"><span data-stu-id="ffc72-233">[Previous](distributed-data.md)
[Next](azure-data-storage.md)</span></span>
