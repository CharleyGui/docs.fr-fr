---
title: Modèle de passerelle API et communication directe de client à microservice
description: Découvrez les différences et les utilisations du modèle de passerelle API et de la communication directe de client à microservice.
ms.date: 01/13/2021
ms.openlocfilehash: 86c975b7d739e62b8f0d465abdf36ad74047c56c
ms.sourcegitcommit: a4cecb7389f02c27e412b743f9189bd2a6dea4d6
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/14/2021
ms.locfileid: "98189575"
---
# <a name="the-api-gateway-pattern-versus-the-direct-client-to-microservice-communication"></a><span data-ttu-id="ce3da-103">Modèle de passerelle API et communication directe de client à microservice</span><span class="sxs-lookup"><span data-stu-id="ce3da-103">The API gateway pattern versus the Direct client-to-microservice communication</span></span>

<span data-ttu-id="ce3da-104">Dans une architecture de microservices, chaque microservice expose un ensemble de points de terminaison (généralement) très ciblés.</span><span class="sxs-lookup"><span data-stu-id="ce3da-104">In a microservices architecture, each microservice exposes a set of (typically) fine-grained endpoints.</span></span> <span data-ttu-id="ce3da-105">Ceci peut impacter la communication de client à microservice, comme cette section l’explique.</span><span class="sxs-lookup"><span data-stu-id="ce3da-105">This fact can impact the client-to-microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="ce3da-106">Communication directe de client à microservice</span><span class="sxs-lookup"><span data-stu-id="ce3da-106">Direct client-to-microservice communication</span></span>

<span data-ttu-id="ce3da-107">Une approche possible consiste à utiliser une architecture de communication directe de client à microservice.</span><span class="sxs-lookup"><span data-stu-id="ce3da-107">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="ce3da-108">Dans cette approche, une application cliente peut envoyer des demandes directement à certains des microservices, comme le montre la figure 4-12.</span><span class="sxs-lookup"><span data-stu-id="ce3da-108">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![Diagramme montrant l’architecture de communication entre les clients et les microservices.](./media/direct-client-to-microservice-communication.png)

<span data-ttu-id="ce3da-110">**Figure 4-12**.</span><span class="sxs-lookup"><span data-stu-id="ce3da-110">**Figure 4-12**.</span></span> <span data-ttu-id="ce3da-111">Utilisation d’une architecture de communication directe de client à microservice</span><span class="sxs-lookup"><span data-stu-id="ce3da-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="ce3da-112">Avec cette approche, chaque microservice a un point de terminaison public, parfois avec un port TCP différent pour chaque microservice.</span><span class="sxs-lookup"><span data-stu-id="ce3da-112">In this approach, each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="ce3da-113">Voici un exemple d’URL pour un service particulier dans Azure :</span><span class="sxs-lookup"><span data-stu-id="ce3da-113">An example of a URL for a particular service could be the following URL in Azure:</span></span>

`http://eshoponcontainers.westus.cloudapp.azure.com:88/`

<span data-ttu-id="ce3da-114">Dans un environnement de production basé sur un cluster, cette URL serait mappée à l’équilibreur de charge utilisé dans le cluster, qui à son tour distribue les demandes entre les microservices.</span><span class="sxs-lookup"><span data-stu-id="ce3da-114">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="ce3da-115">Dans les environnements de production, vous pouvez avoir un contrôleur de livraison d’application comme [Azure Application Gateway](/azure/application-gateway/application-gateway-introduction) entre vos microservices et Internet.</span><span class="sxs-lookup"><span data-stu-id="ce3da-115">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="ce3da-116">Cette couche agit comme un niveau transparent qui non seulement effectue l’équilibrage de charge, mais sécurise vos services en proposant une terminaison SSL.</span><span class="sxs-lookup"><span data-stu-id="ce3da-116">This layer acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="ce3da-117">Cette approche améliore la charge de vos hôtes en déchargeant la terminaison SSL gourmande en ressources processeur et les autres tâches de routage vers la passerelle Azure Application.</span><span class="sxs-lookup"><span data-stu-id="ce3da-117">This approach improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="ce3da-118">Dans tous les cas, un équilibreur de charge et un contrôleur de livraison d’application sont transparents du point de vue de l’architecture logique d’une application.</span><span class="sxs-lookup"><span data-stu-id="ce3da-118">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="ce3da-119">Une architecture de communication directe de client à microservice peut être suffisante pour une petite application basée sur des microservices, surtout si l’application cliente est une application web côté serveur, comme une application ASP.NET MVC.</span><span class="sxs-lookup"><span data-stu-id="ce3da-119">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="ce3da-120">Cependant, quand vous créez des applications basées sur les microservices de grande taille et complexes (par exemple quand vous gérez des dizaines de types de microservice), et en particulier quand les applications clientes sont des applications mobiles distantes ou des applications web SPA, cette approche doit faire face à quelques problèmes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-120">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="ce3da-121">Quand vous développez une application de grande taille basée sur les microservices, considérez les questions suivantes :</span><span class="sxs-lookup"><span data-stu-id="ce3da-121">Consider the following questions when developing a large application based on microservices:</span></span>

- <span data-ttu-id="ce3da-122">*Comment les applications clientes peuvent-elles minimiser le nombre de requêtes envoyées au back-end et réduire le volume important des communications avec plusieurs microservices ?*</span><span class="sxs-lookup"><span data-stu-id="ce3da-122">*How can client apps minimize the number of requests to the back end and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="ce3da-123">Interagir avec plusieurs microservices pour créer un seul écran de l’interface utilisateur augmente le nombre d’allers-retours sur Internet.</span><span class="sxs-lookup"><span data-stu-id="ce3da-123">Interacting with multiple microservices to build a single UI screen increases the number of round trips across the Internet.</span></span> <span data-ttu-id="ce3da-124">Cette approche augmente la latence et la complexité du côté de l’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ce3da-124">This approach increases latency and complexity on the UI side.</span></span> <span data-ttu-id="ce3da-125">Dans l’idéal, les réponses doivent être agrégées de façon efficace côté serveur.</span><span class="sxs-lookup"><span data-stu-id="ce3da-125">Ideally, responses should be efficiently aggregated in the server side.</span></span> <span data-ttu-id="ce3da-126">Cette approche réduit la latence, car plusieurs éléments de données reviennent en parallèle et certaines interfaces utilisateur peuvent afficher des données dès qu’elles sont prêtes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-126">This approach reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it's ready.</span></span>

- <span data-ttu-id="ce3da-127">*Comment pouvez-vous gérer des problèmes transversaux comme l’autorisation, les transformations de données et la distribution des requêtes dynamiques ?*</span><span class="sxs-lookup"><span data-stu-id="ce3da-127">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="ce3da-128">L’implémentation de la sécurité et de problèmes transversaux, comme la sécurité et l’autorisation, sur chaque microservice peut nécessiter un travail de développement considérable.</span><span class="sxs-lookup"><span data-stu-id="ce3da-128">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="ce3da-129">Une approche possible consiste à avoir ces services au sein de l’hôte Docker ou du cluster interne, de façon à limiter leur l’accès direct depuis l’extérieur et à implémenter ces problèmes transversaux à un emplacement centralisé, comme une passerelle API.</span><span class="sxs-lookup"><span data-stu-id="ce3da-129">A possible approach is to have those services within the Docker host or internal cluster to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

- <span data-ttu-id="ce3da-130">*Comment les applications clientes peuvent-elles communiquer avec les services qui utilisent des protocoles non compatibles Internet ?*</span><span class="sxs-lookup"><span data-stu-id="ce3da-130">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="ce3da-131">Les protocoles utilisés côté serveur (comme AMQP ou les protocoles binaires) ne sont pas pris en charge dans les applications clientes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-131">Protocols used on the server side (like AMQP or binary protocols) are not supported in client apps.</span></span> <span data-ttu-id="ce3da-132">Ainsi, les requêtes doivent être exécutées via des protocoles comme HTTP/HTTPS et être traduites après cela pour les autres protocoles.</span><span class="sxs-lookup"><span data-stu-id="ce3da-132">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="ce3da-133">Une approche par *intercepteur* peut aider dans cette situation.</span><span class="sxs-lookup"><span data-stu-id="ce3da-133">A *man-in-the-middle* approach can help in this situation.</span></span>

- <span data-ttu-id="ce3da-134">*Comment pouvez-vous mettre en forme une façade spécialement conçue pour les applications mobiles ?*</span><span class="sxs-lookup"><span data-stu-id="ce3da-134">*How can you shape a facade especially made for mobile apps?*</span></span>

<span data-ttu-id="ce3da-135">L’API de plusieurs microservices peut ne pas être bien conçue pour les besoins de différentes applications clientes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-135">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="ce3da-136">Par exemple, les besoins d’une application mobile peuvent être différents de ceux d’une application web.</span><span class="sxs-lookup"><span data-stu-id="ce3da-136">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="ce3da-137">Pour les applications mobiles, une optimisation supplémentaire peut être nécessaire pour rendre les réponses des données plus efficaces.</span><span class="sxs-lookup"><span data-stu-id="ce3da-137">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="ce3da-138">Vous pouvez effectuer cette fonctionnalité en agrégeant les données de plusieurs microservices et en retournant un seul jeu de données, et parfois en éliminant les données de la réponse qui ne sont pas nécessaires à l’application mobile.</span><span class="sxs-lookup"><span data-stu-id="ce3da-138">You might do this functionality by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that isn't needed by the mobile app.</span></span> <span data-ttu-id="ce3da-139">Bien sûr, vous pouvez aussi compresser les données.</span><span class="sxs-lookup"><span data-stu-id="ce3da-139">And, of course, you might compress that data.</span></span> <span data-ttu-id="ce3da-140">Là encore, une façade ou une API entre l’application mobile et les microservices peut être utile dans ce scénario.</span><span class="sxs-lookup"><span data-stu-id="ce3da-140">Again, a facade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="why-consider-api-gateways-instead-of-direct-client-to-microservice-communication"></a><span data-ttu-id="ce3da-141">Pourquoi utiliser des passerelles d’API plutôt qu’une communication directe de client à microservice</span><span class="sxs-lookup"><span data-stu-id="ce3da-141">Why consider API Gateways instead of direct client-to-microservice communication</span></span>

<span data-ttu-id="ce3da-142">Dans une architecture microservices, les applications clientes doivent généralement consommer la fonctionnalité de plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="ce3da-142">In a microservices architecture, the client apps usually need to consume functionality from more than one microservice.</span></span> <span data-ttu-id="ce3da-143">Si cette consommation est effectuée directement, le client doit gérer plusieurs appels à des points de terminaison de microservices.</span><span class="sxs-lookup"><span data-stu-id="ce3da-143">If that consumption is performed directly, the client needs to handle multiple calls to microservice endpoints.</span></span> <span data-ttu-id="ce3da-144">Que se passe-t-il lorsque l’application évolue et que de nouveaux microservices sont introduits ou que des microservices existants sont mis à jour ?</span><span class="sxs-lookup"><span data-stu-id="ce3da-144">What happens when the application evolves and new microservices are introduced or existing microservices are updated?</span></span> <span data-ttu-id="ce3da-145">Si votre application comporte de nombreux microservices, la gestion d’autant de points de terminaison à partir des applications clientes peut être un cauchemar.</span><span class="sxs-lookup"><span data-stu-id="ce3da-145">If your application has many microservices, handling so many endpoints from the client apps can be a nightmare.</span></span> <span data-ttu-id="ce3da-146">Étant donné que l’application cliente est associée à ces points de terminaison internes, le futur développement des microservices peut avoir un fort impact sur les applications clientes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-146">Since the client app would be coupled to those internal endpoints, evolving the microservices in the future can cause high impact for the client apps.</span></span>

<span data-ttu-id="ce3da-147">Par conséquent, le fait de disposer d’un niveau ou d’un niveau intermédiaire d’indirection (passerelle) peut être pratique pour les applications basées sur des microservices.</span><span class="sxs-lookup"><span data-stu-id="ce3da-147">Therefore, having an intermediate level or tier of indirection (Gateway) can be convenient for microservice-based applications.</span></span> <span data-ttu-id="ce3da-148">Si vous n’avez pas de passerelles d’API, les applications clientes doivent envoyer des requêtes directement aux microservices, ce qui entraîne les problèmes suivants :</span><span class="sxs-lookup"><span data-stu-id="ce3da-148">If you don't have API Gateways, the client apps must send requests directly to the microservices and that raises problems, such as the following issues:</span></span>

- <span data-ttu-id="ce3da-149">**Couplage** : sans le modèle de passerelle d’API, les applications clientes sont couplées aux microservices internes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-149">**Coupling**: Without the API Gateway pattern, the client apps are coupled to the internal microservices.</span></span> <span data-ttu-id="ce3da-150">Les applications clientes doivent savoir comment les différentes zones de l’application sont décomposées en microservices.</span><span class="sxs-lookup"><span data-stu-id="ce3da-150">The client apps need to know how the multiple areas of the application are decomposed in microservices.</span></span> <span data-ttu-id="ce3da-151">Lors de l’évolution et de la refactorisation des microservices internes, ces actions ont un impact sur la maintenance, car elles entraînent des modifications avec rupture des applications clientes en raison de la référence directe aux microservices internes des applications clientes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-151">When evolving and refactoring the internal microservices, those actions impact maintenance because they cause breaking changes to the client apps due to the direct reference to the internal microservices from the client apps.</span></span> <span data-ttu-id="ce3da-152">Les applications clientes doivent être fréquemment mises à jour, ce qui perturbe le développement de la solution.</span><span class="sxs-lookup"><span data-stu-id="ce3da-152">Client apps need to be updated frequently, making the solution harder to evolve.</span></span>

- <span data-ttu-id="ce3da-153">**Trop d’allers-retours**: un seul écran ou une seule page dans l’application cliente peut nécessiter plusieurs appels à différents services.</span><span class="sxs-lookup"><span data-stu-id="ce3da-153">**Too many round trips**: A single page/screen in the client app might require several calls to multiple services.</span></span> <span data-ttu-id="ce3da-154">Cette approche peut entraîner plusieurs allers-retours réseau entre le client et le serveur, ce qui ajoute une latence significative.</span><span class="sxs-lookup"><span data-stu-id="ce3da-154">That approach can result in multiple network round trips between the client and the server, adding significant latency.</span></span> <span data-ttu-id="ce3da-155">L’agrégation gérée dans un niveau intermédiaire peut améliorer les performances et l’expérience utilisateur pour l’application cliente.</span><span class="sxs-lookup"><span data-stu-id="ce3da-155">Aggregation handled in an intermediate level could improve the performance and user experience for the client app.</span></span>

- <span data-ttu-id="ce3da-156">**Problèmes de sécurité** : sans passerelle, tous les microservices doivent être exposés au « monde externe », augmentant ainsi la surface d’attaque même si vous masquez les microservices internes qui ne sont pas directement utilisés par les applications clientes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-156">**Security issues**: Without a gateway, all the microservices must be exposed to the "external world", making the attack surface larger than if you hide internal microservices that aren't directly used by the client apps.</span></span> <span data-ttu-id="ce3da-157">Plus la surface d’attaque est réduite, plus votre application peut être sécurisée.</span><span class="sxs-lookup"><span data-stu-id="ce3da-157">The smaller the attack surface is, the more secure your application can be.</span></span>

- <span data-ttu-id="ce3da-158">**Problèmes croisés**: chaque microservice publié publiquement doit gérer des problèmes tels que l’autorisation et SSL.</span><span class="sxs-lookup"><span data-stu-id="ce3da-158">**Cross-cutting concerns**: Each publicly published microservice must handle concerns such as authorization and SSL.</span></span> <span data-ttu-id="ce3da-159">Dans de nombreux cas, ces problèmes pourraient être traités dans un même niveau afin de simplifier les microservices internes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-159">In many situations, those concerns could be handled in a single tier so the internal microservices are simplified.</span></span>

## <a name="what-is-the-api-gateway-pattern"></a><span data-ttu-id="ce3da-160">Présentation du modèle Passerelle d’API</span><span class="sxs-lookup"><span data-stu-id="ce3da-160">What is the API Gateway pattern?</span></span>

<span data-ttu-id="ce3da-161">Quand vous concevez et que vous créez des applications de grande taille ou complexes basées sur des microservices avec plusieurs applications clientes, une [passerelle d’API](https://microservices.io/patterns/apigateway.html) peut être une bonne approche à considérer.</span><span class="sxs-lookup"><span data-stu-id="ce3da-161">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="ce3da-162">Ce modèle est un service qui fournit un point d’entrée unique pour certains groupes de microservices.</span><span class="sxs-lookup"><span data-stu-id="ce3da-162">This pattern is a service that provides a single-entry point for certain groups of microservices.</span></span> <span data-ttu-id="ce3da-163">Il est similaire au [modèle Façade](https://en.wikipedia.org/wiki/Facade_pattern) de la conception orientée objet, mais dans ce cas, il fait partie d’un système distribué.</span><span class="sxs-lookup"><span data-stu-id="ce3da-163">It's similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object-oriented design, but in this case, it's part of a distributed system.</span></span> <span data-ttu-id="ce3da-164">Le modèle Passerelle API est également parfois appelé « backend for frontend » ([BFF](https://samnewman.io/patterns/architectural/bff/)), car vous le créez en prenant en compte les besoins de l’application cliente.</span><span class="sxs-lookup"><span data-stu-id="ce3da-164">The API Gateway pattern is also sometimes known as the "backend for frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="ce3da-165">Par conséquent, la passerelle d’API se place entre les applications clientes et le microservices.</span><span class="sxs-lookup"><span data-stu-id="ce3da-165">Therefore, the API gateway sits between the client apps and the microservices.</span></span> <span data-ttu-id="ce3da-166">Elle agit comme un proxy inverse, en acheminant les requêtes des clients vers les services.</span><span class="sxs-lookup"><span data-stu-id="ce3da-166">It acts as a reverse proxy, routing requests from clients to services.</span></span> <span data-ttu-id="ce3da-167">Il peut également fournir d’autres fonctionnalités transversales telles que l’authentification, la terminaison SSL et le cache.</span><span class="sxs-lookup"><span data-stu-id="ce3da-167">It can also provide other cross-cutting features such as authentication, SSL termination, and cache.</span></span>

<span data-ttu-id="ce3da-168">La figure 4-13 montre comment une passerelle d’API personnalisée peut s’intégrer dans une architecture simplifiée basée sur quelques microservices.</span><span class="sxs-lookup"><span data-stu-id="ce3da-168">Figure 4-13 shows how a custom API Gateway can fit into a simplified microservice-based architecture with just a few microservices.</span></span>

![Diagramme montrant une passerelle d’API implémentée en tant que service personnalisé.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/custom-service-api-gateway.png)

<span data-ttu-id="ce3da-170">**Figure 4-13**.</span><span class="sxs-lookup"><span data-stu-id="ce3da-170">**Figure 4-13**.</span></span> <span data-ttu-id="ce3da-171">Utilisation d’une passerelle d’API implémentée comme service personnalisé</span><span class="sxs-lookup"><span data-stu-id="ce3da-171">Using an API Gateway implemented as a custom service</span></span>

<span data-ttu-id="ce3da-172">Les applications se connectent à un point de terminaison unique, la passerelle d’API, qui est configurée pour transférer les demandes à des microservices individuels.</span><span class="sxs-lookup"><span data-stu-id="ce3da-172">Apps connect to a single endpoint, the API Gateway, that's configured to forward requests to individual microservices.</span></span> <span data-ttu-id="ce3da-173">Dans cet exemple, la passerelle d’API doit être implémentée comme un service ASP.NET Core WebHost personnalisé s’exécutant en tant que conteneur.</span><span class="sxs-lookup"><span data-stu-id="ce3da-173">In this example, the API Gateway would be implemented as a custom ASP.NET Core WebHost service running as a container.</span></span>

<span data-ttu-id="ce3da-174">Il est important de souligner que dans ce diagramme, vous utilisez un seul service de passerelle API personnalisée faisant face à plusieurs applications clientes différentes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-174">It's important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="ce3da-175">Ceci peut présenter un risque important, car votre service de passerelle d’API va croître et évoluer en fonction des nombreuses exigences différentes des applications clientes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-175">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="ce3da-176">Au bout du compte, il sera encombré en raison de ces différents besoins et il peut être similaire à une application monolithique ou à un service monolithique.</span><span class="sxs-lookup"><span data-stu-id="ce3da-176">Eventually, it will be bloated because of those different needs and effectively it could be similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="ce3da-177">C’est pourquoi il est vivement recommandé de diviser la passerelle API en plusieurs services ou en plusieurs passerelles API plus petites, par exemple, une par type de facteur de forme dans une application cliente.</span><span class="sxs-lookup"><span data-stu-id="ce3da-177">That's why it's very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per client app form-factor type, for instance.</span></span>

<span data-ttu-id="ce3da-178">Soyez prudent lors de l’implémentation du modèle Passerelle API.</span><span class="sxs-lookup"><span data-stu-id="ce3da-178">You need to be careful when implementing the API Gateway pattern.</span></span> <span data-ttu-id="ce3da-179">Il n’est en général pas judicieux d’avoir une seule passerelle d’API agrégeant tous les microservices internes de votre application.</span><span class="sxs-lookup"><span data-stu-id="ce3da-179">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="ce3da-180">Dans ce cas, elle se comporte comme un agrégateur ou un orchestrateur monolithique, et contrevient au principe d’autonomie des microservices en couplant tous les microservices.</span><span class="sxs-lookup"><span data-stu-id="ce3da-180">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span>

<span data-ttu-id="ce3da-181">Par conséquent, les passerelles d’API doivent être séparées en fonction des limites métier et des applications clientes et ne pas agir comme un agrégateur pour tous les microservices internes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-181">Therefore, the API Gateways should be segregated based on business boundaries and the client apps and not act as a single aggregator for all the internal microservices.</span></span>

<span data-ttu-id="ce3da-182">Quand vous divisez le niveau de la passerelle API en plusieurs passerelles API, si votre application a plusieurs applications clientes, cela peut être un pivot essentiel pour identifier les différents types de passerelles API, et pouvoir ainsi utiliser une façade différente selon les besoins de chaque application cliente.</span><span class="sxs-lookup"><span data-stu-id="ce3da-182">When splitting the API Gateway tier into multiple API Gateways, if your application has multiple client apps, that can be a primary pivot when identifying the multiple API Gateways types, so that you can have a different facade for the needs of each client app.</span></span> <span data-ttu-id="ce3da-183">Ce cas est un modèle intitulé « Backend for Frontend » ([BFF](https://samnewman.io/patterns/architectural/bff/)), dans lequel chaque passerelle API peut fournir une API différente adaptée à chaque type d’application cliente, ou même personnalisée en fonction du facteur de forme de l’application cliente en implémentant un code d’adaptateur spécifique qui appelle plusieurs microservices internes de façon sous-jacente, comme le montre l’image suivante :</span><span class="sxs-lookup"><span data-stu-id="ce3da-183">This case is a pattern named "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) where each API Gateway can provide a different API tailored for each client app type, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices, as shown in the following image:</span></span>

![Diagramme montrant plusieurs passerelles d’API personnalisées.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/multiple-custom-api-gateways.png)

<span data-ttu-id="ce3da-185">**Figure 4-13.1**.</span><span class="sxs-lookup"><span data-stu-id="ce3da-185">**Figure 4-13.1**.</span></span> <span data-ttu-id="ce3da-186">Utilisation de plusieurs passerelles d’API personnalisées</span><span class="sxs-lookup"><span data-stu-id="ce3da-186">Using multiple custom API Gateways</span></span>

<span data-ttu-id="ce3da-187">Figure 4-13.1 affiche les passerelles d’API qui sont séparées par le type de client ; un pour les clients mobiles et un pour les clients Web.</span><span class="sxs-lookup"><span data-stu-id="ce3da-187">Figure 4-13.1 shows API Gateways that are segregated by client type; one for mobile clients and one for web clients.</span></span> <span data-ttu-id="ce3da-188">Une application web traditionnelle se connecte à un microservice MVC qui utilise la passerelle API web.</span><span class="sxs-lookup"><span data-stu-id="ce3da-188">A traditional web app connects to an MVC microservice that uses the web API Gateway.</span></span> <span data-ttu-id="ce3da-189">L’exemple illustre une architecture simplifiée avec plusieurs passerelles d’API affinées.</span><span class="sxs-lookup"><span data-stu-id="ce3da-189">The example depicts a simplified architecture with multiple fine-grained API Gateways.</span></span> <span data-ttu-id="ce3da-190">Dans ce cas, les limites identifiées pour chaque passerelle API reposant uniquement sur le modèle « Backend for Frontend » ([BFF](https://samnewman.io/patterns/architectural/bff/)), elles sont basées uniquement sur l’API nécessaire à l’application cliente.</span><span class="sxs-lookup"><span data-stu-id="ce3da-190">In this case, the boundaries identified for each API Gateway are based purely on the "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) pattern, hence based just on the API needed per client app.</span></span> <span data-ttu-id="ce3da-191">Mais dans les applications plus volumineuses, vous devez également aller plus loin et créer d’autres passerelles d’API basées sur les limites de l’entreprise en tant que deuxième conception pivot.</span><span class="sxs-lookup"><span data-stu-id="ce3da-191">But in larger applications you should also go further and create other API Gateways based on business boundaries as a second design pivot.</span></span>

## <a name="main-features-in-the-api-gateway-pattern"></a><span data-ttu-id="ce3da-192">Principales fonctionnalités du modèle Passerelle d’API</span><span class="sxs-lookup"><span data-stu-id="ce3da-192">Main features in the API Gateway pattern</span></span>

<span data-ttu-id="ce3da-193">Une passerelle d’API peut offrir plusieurs fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="ce3da-193">An API Gateway can offer multiple features.</span></span> <span data-ttu-id="ce3da-194">Selon le produit, elle peut proposer des fonctionnalités plus ou moins complètes, mais les fonctionnalités de bases les plus importantes pour toute passerelle d’API sont les modèles de conception suivants :</span><span class="sxs-lookup"><span data-stu-id="ce3da-194">Depending on the product it might offer richer or simpler features, however, the most important and foundational features for any API Gateway are the following design patterns:</span></span>

<span data-ttu-id="ce3da-195">**Proxy inversé ou routage de passerelle**.</span><span class="sxs-lookup"><span data-stu-id="ce3da-195">**Reverse proxy or gateway routing.**</span></span> <span data-ttu-id="ce3da-196">La passerelle d’API offre un proxy inversé pour rediriger ou acheminer les requêtes (routage de couche 7, généralement les requêtes HTTP) vers les points de terminaison des microservices internes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-196">The API Gateway offers a reverse proxy to redirect or route requests (layer 7 routing, usually HTTP requests) to the endpoints of the internal microservices.</span></span> <span data-ttu-id="ce3da-197">La passerelle fournit un point de terminaison ou une URL unique pour les applications clientes puis mappe en interne les requêtes à un groupe de microservices internes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-197">The gateway provides a single endpoint or URL for the client apps and then internally maps the requests to a group of internal microservices.</span></span> <span data-ttu-id="ce3da-198">Cette fonctionnalité de routage permet de découpler les applications clientes des microservices, mais elle est également pratique lors de la modernisation d’une API monolithique en assiste la passerelle d’API entre l’API monolithique et les applications clientes. vous pouvez alors ajouter de nouvelles API en tant que nouveaux microservices tout en continuant à utiliser l’API monolithique héritée jusqu’à ce qu’elle soit</span><span class="sxs-lookup"><span data-stu-id="ce3da-198">This routing feature helps to decouple the client apps from the microservices but it's also convenient when modernizing a monolithic API by sitting the API Gateway in between the monolithic API and the client apps, then you can add new APIs as new microservices while still using the legacy monolithic API until it's split into many microservices in the future.</span></span> <span data-ttu-id="ce3da-199">Avec la passerelle API, les applications clientes ne sauront pas si les API utilisées sont implémentées comme des microservices internes ou comme une API monolithique et, plus important encore, lors du développement et de la refactorisation de l’API monolithique en microservices, grâce au routage de la passerelle API, les applications clientes ne seront pas impactées par les modifications d’URI.</span><span class="sxs-lookup"><span data-stu-id="ce3da-199">Because of the API Gateway, the client apps won't notice if the APIs being used are implemented as internal microservices or a monolithic API and more importantly, when evolving and refactoring the monolithic API into microservices, thanks to the API Gateway routing, client apps won't be impacted with any URI change.</span></span>

<span data-ttu-id="ce3da-200">Pour plus d’informations, consultez [Modèle de routage de passerelle](/azure/architecture/patterns/gateway-routing).</span><span class="sxs-lookup"><span data-stu-id="ce3da-200">For more information, see [Gateway routing pattern](/azure/architecture/patterns/gateway-routing).</span></span>

<span data-ttu-id="ce3da-201">**Agrégation de requêtes**.</span><span class="sxs-lookup"><span data-stu-id="ce3da-201">**Requests aggregation.**</span></span> <span data-ttu-id="ce3da-202">Dans le cadre du modèle de passerelle, vous pouvez agréger plusieurs requêtes de client (généralement des requêtes HTTP) ciblant plusieurs microservices internes dans une requête de client unique.</span><span class="sxs-lookup"><span data-stu-id="ce3da-202">As part of the gateway pattern you can aggregate multiple client requests (usually HTTP requests) targeting multiple internal microservices into a single client request.</span></span> <span data-ttu-id="ce3da-203">Ce modèle est particulièrement pratique lorsqu’une page ou un écran d’un client a besoin d’informations provenant de plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="ce3da-203">This pattern is especially convenient when a client page/screen needs information from several microservices.</span></span> <span data-ttu-id="ce3da-204">Avec cette approche, l’application cliente envoie une demande unique à la passerelle d’API qui répartit plusieurs requêtes aux microservices internes, puis agrège les résultats et envoie le tout à l’application cliente.</span><span class="sxs-lookup"><span data-stu-id="ce3da-204">With this approach, the client app sends a single request to the API Gateway that dispatches several requests to the internal microservices and then aggregates the results and sends everything back to the client app.</span></span> <span data-ttu-id="ce3da-205">Le principal avantage et l’objectif de ce modèle de conception est de réduire les échanges excessifs entre les applications clientes et l’API backend, ce qui est particulièrement important pour les applications distantes en dehors du centre de code, où les microservices sont actifs, comme les applications mobiles ou les demandes provenant des applications SPA provenant de JavaScript dans les navigateurs distants client.</span><span class="sxs-lookup"><span data-stu-id="ce3da-205">The main benefit and goal of this design pattern is to reduce chattiness between the client apps and the backend API, which is especially important for remote apps out of the datacenter where the microservices live, like mobile apps or requests coming from SPA apps that come from JavaScript in client remote browsers.</span></span> <span data-ttu-id="ce3da-206">Pour les applications web normales effectuant les requêtes dans l’environnement du serveur (par exemple, une application web ASP.NET Core MVC), ce modèle n’est pas si important car la latence est bien plus faible que pour les applications clientes à distance.</span><span class="sxs-lookup"><span data-stu-id="ce3da-206">For regular web apps performing the requests in the server environment (like an ASP.NET Core MVC web app), this pattern is not so important as the latency is very much smaller than for remote client apps.</span></span>

<span data-ttu-id="ce3da-207">Selon le produit Passerelle d’API que vous utilisez, il sera en mesure d’effectuer cette agrégation.</span><span class="sxs-lookup"><span data-stu-id="ce3da-207">Depending on the API Gateway product you use, it might be able to perform this aggregation.</span></span> <span data-ttu-id="ce3da-208">Toutefois, dans de nombreux cas, il est plus simple de créer des microservices d’agrégation dans le cadre de la passerelle API. Vous définissez alors l’agrégation directement dans le code (code C#) :</span><span class="sxs-lookup"><span data-stu-id="ce3da-208">However, in many cases it's more flexible to create aggregation microservices under the scope of the API Gateway, so you define the aggregation in code (that is, C# code):</span></span>

<span data-ttu-id="ce3da-209">Pour plus d’informations, consultez [Modèle d’agrégation de passerelle](/azure/architecture/patterns/gateway-aggregation).</span><span class="sxs-lookup"><span data-stu-id="ce3da-209">For more information, see [Gateway aggregation pattern](/azure/architecture/patterns/gateway-aggregation).</span></span>

<span data-ttu-id="ce3da-210">**Problèmes transversaux ou déchargement de passerelle**.</span><span class="sxs-lookup"><span data-stu-id="ce3da-210">**Cross-cutting concerns or gateway offloading.**</span></span> <span data-ttu-id="ce3da-211">Selon les fonctionnalités offertes par chaque produit Passerelle d’API, vous pouvez décharger des fonctionnalités de microservices individuels vers la passerelle, ce qui simplifie l’implémentation de chaque microservice en consolidant les problèmes transversaux dans un seul niveau.</span><span class="sxs-lookup"><span data-stu-id="ce3da-211">Depending on the features offered by each API Gateway product, you can offload functionality from individual microservices to the gateway, which simplifies the implementation of each microservice by consolidating cross-cutting concerns into one tier.</span></span> <span data-ttu-id="ce3da-212">Cette approche est particulièrement pratique pour les fonctionnalités spécialisées qui peuvent être complexes à implémenter correctement dans chaque microservice interne, notamment les fonctionnalités suivantes :</span><span class="sxs-lookup"><span data-stu-id="ce3da-212">This approach is especially convenient for specialized features that can be complex to implement properly in every internal microservice, such as the following functionality:</span></span>

- <span data-ttu-id="ce3da-213">Authentification et autorisation</span><span class="sxs-lookup"><span data-stu-id="ce3da-213">Authentication and authorization</span></span>
- <span data-ttu-id="ce3da-214">Intégration de la découverte de service</span><span class="sxs-lookup"><span data-stu-id="ce3da-214">Service discovery integration</span></span>
- <span data-ttu-id="ce3da-215">Mise en cache des réponses</span><span class="sxs-lookup"><span data-stu-id="ce3da-215">Response caching</span></span>
- <span data-ttu-id="ce3da-216">Stratégies de nouvelle tentative, disjoncteur et qualité de service (QoS)</span><span class="sxs-lookup"><span data-stu-id="ce3da-216">Retry policies, circuit breaker, and QoS</span></span>
- <span data-ttu-id="ce3da-217">Limitation du débit</span><span class="sxs-lookup"><span data-stu-id="ce3da-217">Rate limiting and throttling</span></span>
- <span data-ttu-id="ce3da-218">Équilibrage de charge</span><span class="sxs-lookup"><span data-stu-id="ce3da-218">Load balancing</span></span>
- <span data-ttu-id="ce3da-219">Journalisation, suivi, corrélation</span><span class="sxs-lookup"><span data-stu-id="ce3da-219">Logging, tracing, correlation</span></span>
- <span data-ttu-id="ce3da-220">Transformation des en-têtes, chaînes de requête et revendications</span><span class="sxs-lookup"><span data-stu-id="ce3da-220">Headers, query strings, and claims transformation</span></span>
- <span data-ttu-id="ce3da-221">Allowlisting IP</span><span class="sxs-lookup"><span data-stu-id="ce3da-221">IP allowlisting</span></span>

<span data-ttu-id="ce3da-222">Pour plus d’informations, consultez [Modèle de déchargement de passerelle](/azure/architecture/patterns/gateway-offloading).</span><span class="sxs-lookup"><span data-stu-id="ce3da-222">For more information, see [Gateway offloading pattern](/azure/architecture/patterns/gateway-offloading).</span></span>

## <a name="using-products-with-api-gateway-features"></a><span data-ttu-id="ce3da-223">Utilisation de produits avec les fonctionnalités de la Passerelle d’API</span><span class="sxs-lookup"><span data-stu-id="ce3da-223">Using products with API Gateway features</span></span>

<span data-ttu-id="ce3da-224">Il peut y avoir plusieurs problèmes transversaux générés par les produits de la passerelle d’API en fonction de chaque implémentation.</span><span class="sxs-lookup"><span data-stu-id="ce3da-224">There can be many more cross-cutting concerns offered by the API Gateways products depending on each implementation.</span></span> <span data-ttu-id="ce3da-225">Nous aborderons ici les points suivants :</span><span class="sxs-lookup"><span data-stu-id="ce3da-225">We'll explore here:</span></span>

- [<span data-ttu-id="ce3da-226">Gestion des API Azure</span><span class="sxs-lookup"><span data-stu-id="ce3da-226">Azure API Management</span></span>](https://azure.microsoft.com/services/api-management/)
- [<span data-ttu-id="ce3da-227">Ocelot</span><span class="sxs-lookup"><span data-stu-id="ce3da-227">Ocelot</span></span>](https://github.com/ThreeMammals/Ocelot)

### <a name="azure-api-management"></a><span data-ttu-id="ce3da-228">Gestion des API Azure</span><span class="sxs-lookup"><span data-stu-id="ce3da-228">Azure API Management</span></span>

<span data-ttu-id="ce3da-229">En plus de répondre à vos besoins de passerelle API, le service [Gestion des API Azure](https://azure.microsoft.com/services/api-management/) (comme illustré à la figure 4-14) offre plusieurs fonctionnalités, telles que la collecte d’insights à partir de vos API.</span><span class="sxs-lookup"><span data-stu-id="ce3da-229">[Azure API Management](https://azure.microsoft.com/services/api-management/) (as shown in Figure 4-14) not only solves your API Gateway needs but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="ce3da-230">Si vous utilisez une solution de gestion des API globale, une passerelle API est simplement un composant de cette solution.</span><span class="sxs-lookup"><span data-stu-id="ce3da-230">If you're using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![Diagramme montrant comment utiliser la gestion des API Azure comme passerelle d’API.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/api-gateway-azure-api-management.png)

<span data-ttu-id="ce3da-232">**Figure 4-14**.</span><span class="sxs-lookup"><span data-stu-id="ce3da-232">**Figure 4-14**.</span></span> <span data-ttu-id="ce3da-233">Utilisation de Gestion des API Azure pour votre passerelle d’API</span><span class="sxs-lookup"><span data-stu-id="ce3da-233">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="ce3da-234">La gestion des API Azure résout vos besoins en matière de passerelle API et de gestion, comme la journalisation, la sécurité, le contrôle, etc. Dans ce cas, lors de l’utilisation d’un produit comme gestion des API Azure, le fait que vous ayez une seule passerelle d’API n’est pas si risqué, car ces types de passerelles d’API sont « plus fins », ce qui signifie que vous n’implémentez pas de code C# personnalisé qui pourrait évoluer vers un composant monolithique.</span><span class="sxs-lookup"><span data-stu-id="ce3da-234">Azure API Management solves both your API Gateway and Management needs like logging, security, metering, etc. In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span>

<span data-ttu-id="ce3da-235">Les produits Passerelle d’API agissent généralement comme un proxy inversé pour la communication en entrée, où vous pouvez aussi filtrer les API des microservices internes et appliquer une autorisation aux API publiées dans ce niveau unique.</span><span class="sxs-lookup"><span data-stu-id="ce3da-235">The API Gateway products usually act like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="ce3da-236">Les informations disponibles provenant d’un système de gestion des API vous aident à comprendre comment vos API sont utilisées et comment elles fonctionnent.</span><span class="sxs-lookup"><span data-stu-id="ce3da-236">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="ce3da-237">Elles effectuent cette activité en vous permettant d’afficher des rapports d’analyse en temps quasi réel et d’identifier les tendances susceptibles d’avoir un impact sur votre activité.</span><span class="sxs-lookup"><span data-stu-id="ce3da-237">They do this activity by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="ce3da-238">De plus, vous pouvez avoir des journaux sur l’activité des demandes et des réponses, que vous pouvez alors analyser de façon plus approfondie en ligne et hors connexion.</span><span class="sxs-lookup"><span data-stu-id="ce3da-238">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="ce3da-239">Avec Gestion des API Azure, vous pouvez sécuriser vos API avec une clé, un jeton et un filtrage des adresses IP.</span><span class="sxs-lookup"><span data-stu-id="ce3da-239">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="ce3da-240">Ces fonctionnalités vous permettent d’appliquer des quotas et des limites de débit de façon souple et précise, de modifier la forme et le comportement de vos API avec des stratégies, et d’améliorer les performances avec la mise en cache des réponses.</span><span class="sxs-lookup"><span data-stu-id="ce3da-240">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="ce3da-241">Dans ce guide et dans l’exemple d’application de référence (eShopOnContainers), l’architecture est limitée à une architecture en conteneurs plus simple et personnalisée, de façon à mettre l’accent sur des conteneurs ordinaires sans utiliser de produits PaaS comme Gestion des API Azure.</span><span class="sxs-lookup"><span data-stu-id="ce3da-241">In this guide and the reference sample application (eShopOnContainers), the architecture is limited to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="ce3da-242">Cependant, pour les applications de grande taille basées sur des microservices et déployées sur Microsoft Azure, nous vous encourageons à évaluer Gestion des API Azure comme base pour vos passerelles d’API en production.</span><span class="sxs-lookup"><span data-stu-id="ce3da-242">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to evaluate Azure API Management as the base for your API Gateways in production.</span></span>

### <a name="ocelot"></a><span data-ttu-id="ce3da-243">Ocelot</span><span class="sxs-lookup"><span data-stu-id="ce3da-243">Ocelot</span></span>

<span data-ttu-id="ce3da-244">[Ocelot](https://github.com/ThreeMammals/Ocelot) est une passerelle API légère qui est recommandée pour les approches plus simples.</span><span class="sxs-lookup"><span data-stu-id="ce3da-244">[Ocelot](https://github.com/ThreeMammals/Ocelot) is a lightweight API Gateway, recommended for simpler approaches.</span></span> <span data-ttu-id="ce3da-245">Ocelot est une passerelle d’API .NET Core Open source spécialement créée pour les architectures de microservices nécessitant des points d’entrée unifiés dans leurs systèmes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-245">Ocelot is an Open Source .NET Core-based API Gateway especially made for microservices architectures that need unified points of entry into their systems.</span></span> <span data-ttu-id="ce3da-246">Elle est légère, rapide et évolutive, et fournit le routage et l’authentification parmi de nombreuses autres fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="ce3da-246">It's lightweight, fast, and scalable and provides routing and authentication among many other features.</span></span>

<span data-ttu-id="ce3da-247">La principale raison de choisir Ocelot pour l' [application de référence eShopOnContainers 2,0](https://github.com/dotnet-architecture/eShopOnContainers/releases/tag/2.0) est que Ocelot est une passerelle d’API légère .net Core que vous pouvez déployer dans le même environnement de déploiement d’application que celui dans lequel vous déployez vos microservices/conteneurs, par exemple un hôte de station d’accueil, Kubernetes, etc. Et étant donné qu’il est basé sur .NET Core, il s’agit d’une plateforme multiplateforme qui vous permet de déployer sur Linux ou Windows.</span><span class="sxs-lookup"><span data-stu-id="ce3da-247">The main reason to choose Ocelot for the [eShopOnContainers reference application 2.0](https://github.com/dotnet-architecture/eShopOnContainers/releases/tag/2.0) is because Ocelot is a .NET Core lightweight API Gateway that you can deploy into the same application deployment environment where you're deploying your microservices/containers, such as a Docker Host, Kubernetes, etc. And since it's based on .NET Core, it's cross-platform allowing you to deploy on Linux or Windows.</span></span>

<span data-ttu-id="ce3da-248">Les diagrammes précédents montrant des passerelles d’API personnalisée en cours d’exécution dans les conteneurs expliquent précisément comment vous pouvez également exécuter Ocelot dans un conteneur et dans une application basée sur un microservice.</span><span class="sxs-lookup"><span data-stu-id="ce3da-248">The previous diagrams showing custom API Gateways running in containers are precisely how you can also run Ocelot in a container and microservice-based application.</span></span>

<span data-ttu-id="ce3da-249">En outre, il existe plusieurs autres produits sur le marché qui offrent des fonctionnalités de passerelles d’API, par exemple Apigee, Kong, MuleSoft, WSO2, et d’autres produits comme Linkerd et Istio pour les fonctionnalités de contrôleur d’ingestion de maille de services.</span><span class="sxs-lookup"><span data-stu-id="ce3da-249">In addition, there are many other products in the market offering API Gateways features, such as Apigee, Kong, MuleSoft, WSO2, and other products like Linkerd and Istio for service mesh ingress controller features.</span></span>

<span data-ttu-id="ce3da-250">Après les sections consacrées à l’architecture initiale et à la présentation des modèles, les sections suivantes expliquent comment implémenter des passerelles d’API avec [Ocelot](https://github.com/ThreeMammals/Ocelot).</span><span class="sxs-lookup"><span data-stu-id="ce3da-250">After the initial architecture and patterns explanation sections, the next sections explain how to implement API Gateways with [Ocelot](https://github.com/ThreeMammals/Ocelot).</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="ce3da-251">Inconvénients du modèle Passerelle d’API</span><span class="sxs-lookup"><span data-stu-id="ce3da-251">Drawbacks of the API Gateway pattern</span></span>

- <span data-ttu-id="ce3da-252">L’inconvénient plus important est que, quand vous implémentez une passerelle d’API, vous couplez ce niveau avec les microservices internes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-252">The most important drawback is that when you implement an API Gateway, you're coupling that tier with the internal microservices.</span></span> <span data-ttu-id="ce3da-253">Un tel couplage peut introduire de graves difficultés pour votre application.</span><span class="sxs-lookup"><span data-stu-id="ce3da-253">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="ce3da-254">Clemens Vaster, architecte de l’équipe Azure Service Bus, parlait de cette difficulté potentielle comme de « la nouvelle ESB » dans la session « [Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k) » à la conférence GOTO 2016.</span><span class="sxs-lookup"><span data-stu-id="ce3da-254">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as "the new ESB" in the "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

- <span data-ttu-id="ce3da-255">L’utilisation d’une passerelle d’API de microservices crée un possible point de défaillance unique supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="ce3da-255">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

- <span data-ttu-id="ce3da-256">Une passerelle d’API peut introduire des temps de réponse accrus en raison de l’appel réseau supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="ce3da-256">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="ce3da-257">Cependant, cet appel supplémentaire a généralement moins d’impact qu’un client de l’interface qui émet trop de communications en appelant directement les microservices internes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-257">However, this extra call usually has less impact than having a client interface that's too chatty directly calling the internal microservices.</span></span>

- <span data-ttu-id="ce3da-258">Si elle n’est pas montée pas en charge correctement, la passerelle d’API peut devenir un goulot d’étranglement.</span><span class="sxs-lookup"><span data-stu-id="ce3da-258">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

- <span data-ttu-id="ce3da-259">Une passerelle d’API nécessite des coûts de développement supplémentaires et une maintenance ultérieure si elle inclut une logique personnalisée et effectue une agrégation des données.</span><span class="sxs-lookup"><span data-stu-id="ce3da-259">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="ce3da-260">Les développeurs doivent mettre à jour la passerelle API pour pouvoir exposer les points de terminaison de chaque microservice.</span><span class="sxs-lookup"><span data-stu-id="ce3da-260">Developers must update the API Gateway in order to expose each microservice's endpoints.</span></span> <span data-ttu-id="ce3da-261">En outre, les changements d’implémentation dans les microservices internes peuvent entraîner des modifications du code au niveau de la passerelle d’API.</span><span class="sxs-lookup"><span data-stu-id="ce3da-261">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="ce3da-262">Cependant, si la passerelle d’API applique simplement la sécurité, la journalisation et la gestion des versions (comme quand vous utilisez Gestion des API Azure), ces coûts de développement supplémentaires peuvent ne pas s’appliquer.</span><span class="sxs-lookup"><span data-stu-id="ce3da-262">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

- <span data-ttu-id="ce3da-263">Si la passerelle d’API est développée par une même équipe, il peut y avoir un goulot d’étranglement en matière de développement.</span><span class="sxs-lookup"><span data-stu-id="ce3da-263">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="ce3da-264">Cet aspect est une autre raison pour laquelle une meilleure approche consiste à avoir plusieurs passerelles d’API affinées qui répondent à différents besoins du client.</span><span class="sxs-lookup"><span data-stu-id="ce3da-264">This aspect is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="ce3da-265">Vous pouvez aussi diviser la passerelle d’API en interne en plusieurs parties ou couches, affectées chacune aux différentes équipes travaillant sur les microservices internes.</span><span class="sxs-lookup"><span data-stu-id="ce3da-265">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="ce3da-266">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="ce3da-266">Additional resources</span></span>

- <span data-ttu-id="ce3da-267">**Chris Richardson. Modèle : passerelle API/backend pour serveur frontal** </span><span class="sxs-lookup"><span data-stu-id="ce3da-267">**Chris Richardson. Pattern: API Gateway / Backend for Front-End** </span></span>\
  <https://microservices.io/patterns/apigateway.html>

- <span data-ttu-id="ce3da-268">**Modèle de passerelle d’API** </span><span class="sxs-lookup"><span data-stu-id="ce3da-268">**API Gateway pattern** </span></span>\
  <https://docs.microsoft.com/azure/architecture/microservices/gateway>

- <span data-ttu-id="ce3da-269">**Modèle d’agrégation et de composition** </span><span class="sxs-lookup"><span data-stu-id="ce3da-269">**Aggregation and composition pattern** </span></span>\
  <https://microservices.io/patterns/data/api-composition.html>

- <span data-ttu-id="ce3da-270">**Gestion des API Azure** </span><span class="sxs-lookup"><span data-stu-id="ce3da-270">**Azure API Management** </span></span>\
  <https://azure.microsoft.com/services/api-management/>

- <span data-ttu-id="ce3da-271">**UDI Dahan. Composition orientée service** </span><span class="sxs-lookup"><span data-stu-id="ce3da-271">**Udi Dahan. Service Oriented Composition** </span></span>\
  <https://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

- <span data-ttu-id="ce3da-272">**Clemens. Messagerie et microservices à GOTO 2016 (vidéo)** </span><span class="sxs-lookup"><span data-stu-id="ce3da-272">**Clemens Vasters. Messaging and Microservices at GOTO 2016 (video)** </span></span>\
  <https://www.youtube.com/watch?v=rXi5CLjIQ9k>

- <span data-ttu-id="ce3da-273">**Passerelle d’API en résumé** (série de didacticiels de la passerelle API ASP.net Core) </span><span class="sxs-lookup"><span data-stu-id="ce3da-273">**API Gateway in a Nutshell** (ASP.NET Core API Gateway Tutorial Series) </span></span>\
  <https://www.pogsdotnet.com/2018/08/api-gateway-in-nutshell.html>

>[!div class="step-by-step"]
><span data-ttu-id="ce3da-274">[Précédent](identify-microservice-domain-model-boundaries.md) 
> [Suivant](communication-in-microservice-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="ce3da-274">[Previous](identify-microservice-domain-model-boundaries.md)
[Next](communication-in-microservice-architecture.md)</span></span>
