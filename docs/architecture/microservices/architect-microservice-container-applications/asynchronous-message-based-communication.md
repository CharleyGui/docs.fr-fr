---
title: Communication basée sur des messages asynchrones
description: Architecture de microservices .NET pour les applications .NET conteneurisées | Les communications asynchrones par messages représentent un concept essentiel dans l’architecture de microservices, car elles constituent le meilleur moyen de maintenir l’indépendance des microservices les uns par rapport aux autres tout en les synchronisant au bout du compte.
ms.date: 09/20/2018
ms.openlocfilehash: 84eaf70178cce91a86dae8a55badb0b4ddd6a7c1
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/03/2019
ms.locfileid: "73454232"
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="caebc-103">Communication basée sur des messages asynchrones</span><span class="sxs-lookup"><span data-stu-id="caebc-103">Asynchronous message-based communication</span></span>

<span data-ttu-id="caebc-104">La messagerie asynchrone et la communication pilotée par les événements sont des fonctionnalités essentielles lors de la propagation de changements sur plusieurs microservices et leurs modèles de domaine connexes.</span><span class="sxs-lookup"><span data-stu-id="caebc-104">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="caebc-105">Comme mentionné précédemment dans la discussion sur les microservices et les contextes délimités (BC, Bounded Context), les modèles comme User, Customer, Product, Account, etc. peuvent avoir des significations différentes pour différents microservices ou BC.</span><span class="sxs-lookup"><span data-stu-id="caebc-105">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="caebc-106">Quand des changements ont lieu, vous devez donc les rapprocher entre les différents modèles.</span><span class="sxs-lookup"><span data-stu-id="caebc-106">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="caebc-107">Une solution consiste à utiliser la cohérence à terme et la communication par messagerie asynchrone pilotée par les événements.</span><span class="sxs-lookup"><span data-stu-id="caebc-107">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="caebc-108">Quand vous utilisez la messagerie, les processus communiquent en échangeant des messages de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="caebc-108">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="caebc-109">Un client exécute une commande ou une requête sur un service en lui envoyant un message.</span><span class="sxs-lookup"><span data-stu-id="caebc-109">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="caebc-110">Si le service doit répondre, il retourne un autre message au client.</span><span class="sxs-lookup"><span data-stu-id="caebc-110">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="caebc-111">Dans la mesure où la communication est basée sur les messages, le client part du principe que les réponses ne sont pas immédiates, et qu’il est possible qu’il ne reçoive aucune réponse.</span><span class="sxs-lookup"><span data-stu-id="caebc-111">Since it's a message-based communication, the client assumes that the reply won't be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="caebc-112">Un message comprend un en-tête (composé de métadonnées telles que des informations d’identification ou de sécurité) et un corps.</span><span class="sxs-lookup"><span data-stu-id="caebc-112">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="caebc-113">Les messages sont généralement envoyés par le biais de protocoles asynchrones comme AMQP.</span><span class="sxs-lookup"><span data-stu-id="caebc-113">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="caebc-114">Dans la communauté des microservices, l’infrastructure de choix pour ce type de communication est un répartiteur de messages léger, dont la conception diffère de celle des grands répartiteurs et orchestrateurs utilisés dans SOA.</span><span class="sxs-lookup"><span data-stu-id="caebc-114">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="caebc-115">Constitué en général d’une infrastructure « passive », le répartiteur de messages léger se limite à la répartition des messages. Ses implémentations sont simples, par exemple RabbitMQ ou Azure Service Bus (un Service Bus scalable dans le cloud).</span><span class="sxs-lookup"><span data-stu-id="caebc-115">In a lightweight message broker, the infrastructure is typically "dumb," acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="caebc-116">Dans ce scénario, la plupart des fonctions « intelligentes » résident toujours dans les points de terminaison qui produisent et consomment des messages, c’est-à-dire dans les microservices.</span><span class="sxs-lookup"><span data-stu-id="caebc-116">In this scenario, most of the "smart" thinking still lives in the endpoints that are producing and consuming messages-that is, in the microservices.</span></span>

<span data-ttu-id="caebc-117">Une autre règle, que nous vous conseillons de suivre dans la mesure du possible, consiste à utiliser uniquement la messagerie asynchrone entre les services internes et à utiliser uniquement la communication synchrone (comme HTTP) des applications clientes aux services frontend (passerelles API, plus le premier niveau des microservices).</span><span class="sxs-lookup"><span data-stu-id="caebc-117">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="caebc-118">La communication asynchrone basée sur les messages se présente sous deux formes : celle avec un récepteur unique et celle avec plusieurs récepteurs.</span><span class="sxs-lookup"><span data-stu-id="caebc-118">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="caebc-119">Les sections suivantes fournissent les détails correspondants.</span><span class="sxs-lookup"><span data-stu-id="caebc-119">The following sections provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="caebc-120">Communication basée sur les messages avec un récepteur unique</span><span class="sxs-lookup"><span data-stu-id="caebc-120">Single-receiver message-based communication</span></span>

<span data-ttu-id="caebc-121">La communication asynchrone basée sur les messages avec un seul récepteur se caractérise comme suit : un message est remis à un seul des consommateurs lisant les données du canal (communication point à point), et le message n’est traité qu’une seule fois.</span><span class="sxs-lookup"><span data-stu-id="caebc-121">Message-based asynchronous communication with a single receiver means there's point-to-point communication that delivers a message to exactly one of the consumers that's reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="caebc-122">Toutefois, il existe des situations particulières.</span><span class="sxs-lookup"><span data-stu-id="caebc-122">However, there are special situations.</span></span> <span data-ttu-id="caebc-123">Par exemple, dans un système cloud qui tente de procéder à une récupération automatique après une défaillance, le même message peut être envoyé plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="caebc-123">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="caebc-124">En cas de panne réseau ou autre, le client doit pouvoir réessayer d’envoyer des messages, et le serveur doit implémenter une opération idempotente pour qu’un message donné ne soit traité qu’une seule fois.</span><span class="sxs-lookup"><span data-stu-id="caebc-124">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="caebc-125">La communication basée sur les messages avec un récepteur unique convient bien à l’envoi de commandes asynchrones d’un microservice à un autre. La Figure 4-18 illustre cette approche.</span><span class="sxs-lookup"><span data-stu-id="caebc-125">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="caebc-126">Une fois la communication basée sur les messages lancée (avec des commandes ou des événements), évitez de mélanger ce type de communication et la communication HTTP synchrone.</span><span class="sxs-lookup"><span data-stu-id="caebc-126">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![Microservice unique recevant un message asynchrone](./media/asynchronous-message-based-communication/single-receiver-message-based-communication.png)

<span data-ttu-id="caebc-128">**Figure 4-18**.</span><span class="sxs-lookup"><span data-stu-id="caebc-128">**Figure 4-18**.</span></span> <span data-ttu-id="caebc-129">Microservice unique recevant un message asynchrone</span><span class="sxs-lookup"><span data-stu-id="caebc-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="caebc-130">Notez que les commandes provenant d’applications clientes peuvent être implémentées en tant que commandes synchrones HTTP.</span><span class="sxs-lookup"><span data-stu-id="caebc-130">Note that when the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="caebc-131">Si vous souhaitez bénéficier d’une scalabilité plus élevée ou si vous vous trouvez déjà dans un processus métier à base de messages, utilisez des commandes à base de messages.</span><span class="sxs-lookup"><span data-stu-id="caebc-131">You should use message-based commands when you need higher scalability or when you're already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="caebc-132">Communication basée sur les messages avec plusieurs récepteurs</span><span class="sxs-lookup"><span data-stu-id="caebc-132">Multiple-receivers message-based communication</span></span>

<span data-ttu-id="caebc-133">Une approche plus souple consiste à utiliser un mécanisme de publication/abonnement de manière à ce que les communications de l’expéditeur soient accessibles aux microservices d’autres abonnés ou à des applications externes.</span><span class="sxs-lookup"><span data-stu-id="caebc-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="caebc-134">Il est donc utile de suivre le [principe ouvert/fermé](https://en.wikipedia.org/wiki/Open/closed_principle) dans le service d’envoi.</span><span class="sxs-lookup"><span data-stu-id="caebc-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="caebc-135">De cette façon, des abonnés peuvent être ajoutés sans qu’il soit nécessaire de modifier le service de l’expéditeur.</span><span class="sxs-lookup"><span data-stu-id="caebc-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="caebc-136">Quand vous utilisez une communication par publication/abonnement, vous pouvez utiliser une interface de bus d’événements pour publier les événements sur un abonné.</span><span class="sxs-lookup"><span data-stu-id="caebc-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="caebc-137">Communication asynchrone pilotée par les événements</span><span class="sxs-lookup"><span data-stu-id="caebc-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="caebc-138">Quand vous utilisez une communication asynchrone pilotée par les événements, un microservice publie un événement d’intégration dès que quelque chose se produit dans son domaine, comme un changement de prix dans un microservice de catalogue de produits, pour en informer un autre microservice.</span><span class="sxs-lookup"><span data-stu-id="caebc-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="caebc-139">D’autres microservices peuvent s’abonner aux événements pour les recevoir de manière asynchrone.</span><span class="sxs-lookup"><span data-stu-id="caebc-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="caebc-140">Dans ce cas, les récepteurs peuvent mettre à jour leurs propres entités de domaine, ce qui peut entraîner d’autres événements d’intégration.</span><span class="sxs-lookup"><span data-stu-id="caebc-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="caebc-141">Ce système de publication/abonnement est généralement obtenu à l’aide de l’implémentation d’un bus d’événements.</span><span class="sxs-lookup"><span data-stu-id="caebc-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="caebc-142">Le bus d’événements peut être conçu comme une abstraction ou une interface, avec l’API nécessaire pour s’abonner aux événements ou s’en désabonner ainsi que pour les publier.</span><span class="sxs-lookup"><span data-stu-id="caebc-142">The event bus can be designed as an abstraction or interface, with the API that's needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="caebc-143">Le bus d’événements peut également avoir une ou plusieurs implémentations basées sur un répartiteur entre processus ou de messagerie, comme une file d’attente de messagerie ou un Service Bus prenant en charge la communication asynchrone, ainsi qu’un modèle de publication/abonnement.</span><span class="sxs-lookup"><span data-stu-id="caebc-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="caebc-144">Si un système utilise la cohérence à terme pilotée par les événements d’intégration, il est recommandé que cette approche soit clairement indiquée à l’utilisateur final.</span><span class="sxs-lookup"><span data-stu-id="caebc-144">If a system uses eventual consistency driven by integration events, it's recommended that this approach is made completely clear to the end user.</span></span> <span data-ttu-id="caebc-145">Le système ne doit pas utiliser une approche qui reproduit les événements d’intégration, par exemple SignalR ou les systèmes d’interrogation du client.</span><span class="sxs-lookup"><span data-stu-id="caebc-145">The system shouldn't use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="caebc-146">L’utilisateur final et le propriétaire de l’entreprise doivent explicitement adopter la cohérence à terme dans le système. Ils doivent aussi avoir conscience que cette approche ne pose généralement aucun problème dans l’entreprise, à condition qu’elle soit explicite.</span><span class="sxs-lookup"><span data-stu-id="caebc-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business doesn't have any problem with this approach, as long as it's explicit.</span></span> <span data-ttu-id="caebc-147">Cela est important, car les utilisateurs peuvent s’attendre à voir des résultats immédiatement, ce qui ne se produit pas forcément avec une cohérence à terme.</span><span class="sxs-lookup"><span data-stu-id="caebc-147">This is important because users might expect to see some results immediately and this might not happen with eventual consistency.</span></span>

<span data-ttu-id="caebc-148">Comme indiqué précédemment dans la section [Défis et solutions pour la gestion de données distribuée](distributed-data-management.md), vous pouvez utiliser des événements d’intégration pour implémenter des tâches d’entreprise qui s’étendent sur plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="caebc-148">As noted earlier in the [Challenges and solutions for distributed data management](distributed-data-management.md) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="caebc-149">Vous bénéficiez ainsi d’une cohérence à terme entre ces services.</span><span class="sxs-lookup"><span data-stu-id="caebc-149">Thus, you'll have eventual consistency between those services.</span></span> <span data-ttu-id="caebc-150">Une transaction cohérente à terme se compose d’une collection d’actions distribuées.</span><span class="sxs-lookup"><span data-stu-id="caebc-150">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="caebc-151">À chaque action, le microservice connexe met à jour une entité de domaine et publie un autre événement d’intégration qui déclenche l’action suivante au sein de la même tâche d’entreprise de bout en bout.</span><span class="sxs-lookup"><span data-stu-id="caebc-151">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="caebc-152">Il est important de noter qu’il est possible de communiquer avec plusieurs microservices qui sont abonnés au même événement.</span><span class="sxs-lookup"><span data-stu-id="caebc-152">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="caebc-153">Pour ce faire, vous pouvez utiliser la messagerie par publication/abonnement basée sur la communication pilotée par les événements, comme le montre la figure 4-19.</span><span class="sxs-lookup"><span data-stu-id="caebc-153">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="caebc-154">Ce mécanisme de publication/d’abonnement n’est pas réservé à l’architecture des microservices.</span><span class="sxs-lookup"><span data-stu-id="caebc-154">This publish/subscribe mechanism isn't exclusive to the microservice architecture.</span></span> <span data-ttu-id="caebc-155">Il est similaire à la façon dont les [contextes délimités](https://martinfowler.com/bliki/BoundedContext.html) dans DDD doivent communiquer, ou à la façon dont vous propagez les mises à jour de la base de données accessible en écriture à la base de données accessible en lecture dans le modèle d’architecture [CQRS (séparation des responsabilités en matière de commande et de requête)](https://martinfowler.com/bliki/CQRS.html).</span><span class="sxs-lookup"><span data-stu-id="caebc-155">It's similar to the way [Bounded Contexts](https://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="caebc-156">L’objectif est d’obtenir une cohérence à terme entre plusieurs sources de données dans votre système distribué.</span><span class="sxs-lookup"><span data-stu-id="caebc-156">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![Diagramme montrant les communications asynchrones pilotées par les événements.](./media/asynchronous-message-based-communication/asynchronous-event-driven-communication.png)

<span data-ttu-id="caebc-158">**Figure 4-19**.</span><span class="sxs-lookup"><span data-stu-id="caebc-158">**Figure 4-19**.</span></span> <span data-ttu-id="caebc-159">Communication par message asynchrone pilotée par les événements</span><span class="sxs-lookup"><span data-stu-id="caebc-159">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="caebc-160">Dans une communication asynchrone pilotée par les événements, un microservice publie les événements sur un bus d’événements. De nombreux microservices peuvent s’y abonner pour recevoir des notifications et agir en conséquence.</span><span class="sxs-lookup"><span data-stu-id="caebc-160">In asynchronous event-driven communication one microservice publishes events to an event bus and many microservices can subscribe to it, to get notified and act on it.</span></span> <span data-ttu-id="caebc-161">Votre implémentation détermine le protocole à utiliser pour les communications basées sur messages et pilotées par les événements.</span><span class="sxs-lookup"><span data-stu-id="caebc-161">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="caebc-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) peut vous aider à obtenir une communication en file d’attente fiable.</span><span class="sxs-lookup"><span data-stu-id="caebc-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="caebc-163">Quand vous utilisez un bus d’événements, vous pouvez utiliser un niveau d’abstraction (par exemple, une interface de bus d’événements) basé sur une implémentation connexe dans des classes avec du code utilisant l’API d’un répartiteur de message comme [RabbitMQ](https://www.rabbitmq.com/) ou d’un Service Bus comme [Azure Service Bus avec des rubriques](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="caebc-163">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="caebc-164">Vous pouvez également utiliser un Service Bus de niveau supérieur comme NServiceBus, MassTransit ou Brighter pour définir votre bus d’événements et votre système de publication/abonnement.</span><span class="sxs-lookup"><span data-stu-id="caebc-164">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="caebc-165">Remarque à propos des technologies de messagerie pour les systèmes de production</span><span class="sxs-lookup"><span data-stu-id="caebc-165">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="caebc-166">Les technologies de messagerie disponibles pour implémenter votre bus d’événements abstraits se répartissent en plusieurs niveaux.</span><span class="sxs-lookup"><span data-stu-id="caebc-166">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="caebc-167">Par exemple, des produits comme RabbitMQ (transport pour répartiteur de message) et Azure Service Bus sont à un niveau inférieur par rapport à d’autres produits comme NServiceBus, MassTransit ou Brighter qui peuvent s’appuyer sur RabbitMQ et Azure Service Bus pour offrir davantage de fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="caebc-167">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="caebc-168">Votre choix dépend du nombre de fonctionnalités avancées au niveau application et du niveau de scalabilité prête à l’emploi dont vous avez besoin pour votre application.</span><span class="sxs-lookup"><span data-stu-id="caebc-168">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="caebc-169">Si vous souhaitez uniquement implémenter un bus d’événements en guise de preuve de concept pour votre environnement de développement, comme dans l’exemple eShopOnContainers, une simple implémentation reposant sur RabbitMQ sur un conteneur Docker peut suffire.</span><span class="sxs-lookup"><span data-stu-id="caebc-169">For implementing just a proof-of-concept event bus for your development environment, as it was done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="caebc-170">Toutefois, pour les systèmes stratégiques et les systèmes de production qui nécessitent un haut niveau de scalabilité, il peut être utile d’évaluer Azure Service Bus.</span><span class="sxs-lookup"><span data-stu-id="caebc-170">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="caebc-171">Pour les abstractions et les fonctionnalités de haut niveau qui facilitent le développement des applications distribuées, nous vous recommandons d’évaluer d’autres Service Bus commerciaux et open source, tels que NServiceBus, MassTransit et Brighter.</span><span class="sxs-lookup"><span data-stu-id="caebc-171">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="caebc-172">Bien entendu, vous pouvez créer vos propres fonctionnalités Service Bus sur des technologies de niveau inférieur comme RabbitMQ et Docker.</span><span class="sxs-lookup"><span data-stu-id="caebc-172">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="caebc-173">Mais tout ce travail peut coûter très cher pour une application d’entreprise personnalisée.</span><span class="sxs-lookup"><span data-stu-id="caebc-173">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="caebc-174">Publication résiliente sur le bus d’événements</span><span class="sxs-lookup"><span data-stu-id="caebc-174">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="caebc-175">L’implémentation d’une architecture pilotée par les événements sur plusieurs microservices soulève le problème suivant : comment mettre à jour atomiquement l’état dans le microservice d’origine tout en publiant avec résilience son événement d’intégration connexe dans le bus d’événements et en tenant compte des transactions.</span><span class="sxs-lookup"><span data-stu-id="caebc-175">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="caebc-176">Voici quelques manières d’y parvenir, mais d’autres approches peuvent être envisagées.</span><span class="sxs-lookup"><span data-stu-id="caebc-176">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

- <span data-ttu-id="caebc-177">Utilisation d’une file d’attente transactionnelle, basée sur DTC, comme MSMQ.</span><span class="sxs-lookup"><span data-stu-id="caebc-177">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="caebc-178">(Toutefois, il s’agit d’une approche héritée.)</span><span class="sxs-lookup"><span data-stu-id="caebc-178">(However, this is a legacy approach.)</span></span>

- <span data-ttu-id="caebc-179">Utiliser [l’exploration des données du journal des transactions](https://www.scoop.it/t/sql-server-transaction-log-mining)</span><span class="sxs-lookup"><span data-stu-id="caebc-179">Using [transaction log mining](https://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

- <span data-ttu-id="caebc-180">Utilisation de la version complète du [modèle d’approvisionnement en événements](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span><span class="sxs-lookup"><span data-stu-id="caebc-180">Using full [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) pattern.</span></span>

- <span data-ttu-id="caebc-181">Utilisation du [modèle Outbox](https://www.kamilgrzybek.com/design/the-outbox-pattern/) : table de base de données transactionnelle définie comme file d’attente de messages qui sert de base à un composant créateur d’événement qui crée l’événement et le publie.</span><span class="sxs-lookup"><span data-stu-id="caebc-181">Using the [Outbox pattern](https://www.kamilgrzybek.com/design/the-outbox-pattern/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="caebc-182">Si vous envisagez d’utiliser la communication asynchrone, veillez également à tenir compte de l’idempotence et de la déduplication des messages.</span><span class="sxs-lookup"><span data-stu-id="caebc-182">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="caebc-183">Ces rubriques sont traitées dans la section [Implémentation de la communication basée sur les événements entre les microservices (événements d’intégration)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) plus loin dans ce guide.</span><span class="sxs-lookup"><span data-stu-id="caebc-183">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="caebc-184">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="caebc-184">Additional resources</span></span>

- <span data-ttu-id="caebc-185">**Event Driven Messaging** </span><span class="sxs-lookup"><span data-stu-id="caebc-185">**Event Driven Messaging** </span></span>\
  <https://soapatterns.org/design_patterns/event_driven_messaging>

- <span data-ttu-id="caebc-186">**Publish/Subscribe Channel** </span><span class="sxs-lookup"><span data-stu-id="caebc-186">**Publish/Subscribe Channel** </span></span>\
  <https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html>

- <span data-ttu-id="caebc-187">**UDI Dahan. CQRS** \ clarifié</span><span class="sxs-lookup"><span data-stu-id="caebc-187">**Udi Dahan. Clarified CQRS** \</span></span>
  <http://udidahan.com/2009/12/09/clarified-cqrs/>

- <span data-ttu-id="caebc-188">**CQRS (séparation des responsabilités en matière de commande et de requête)**  </span><span class="sxs-lookup"><span data-stu-id="caebc-188">**Command and Query Responsibility Segregation (CQRS)** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/cqrs>

- <span data-ttu-id="caebc-189">**Communication entre contextes délimités** </span><span class="sxs-lookup"><span data-stu-id="caebc-189">**Communicating Between Bounded Contexts** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)>

- <span data-ttu-id="caebc-190">**Cohérence à terme** </span><span class="sxs-lookup"><span data-stu-id="caebc-190">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="caebc-191">**Jimmy bogard. Refactorisation vers la résilience : évaluation**de l’association  </span><span class="sxs-lookup"><span data-stu-id="caebc-191">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling** </span></span>\
  <https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/>

> [!div class="step-by-step"]
> <span data-ttu-id="caebc-192">[Précédent](communication-in-microservice-architecture.md)
> [Suivant](maintain-microservice-apis.md)</span><span class="sxs-lookup"><span data-stu-id="caebc-192">[Previous](communication-in-microservice-architecture.md)
[Next](maintain-microservice-apis.md)</span></span>
