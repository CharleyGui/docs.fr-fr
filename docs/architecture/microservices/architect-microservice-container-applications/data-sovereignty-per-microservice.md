---
title: Souveraineté des données par microservice
description: La souveraineté des données par microservice est un des points clés des microservices. Chaque microservice doit être le seul propriétaire de sa base de données. Il ne doit la partager avec aucun autre. Bien entendu, toutes les instances d’un microservice se connectent à la même base de données à haute disponibilité.
ms.date: 09/20/2018
ms.openlocfilehash: f606d6314f38bf3e2c163871af432806dddc7446
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/14/2020
ms.locfileid: "73191911"
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="a28d3-105">Souveraineté des données par microservice</span><span class="sxs-lookup"><span data-stu-id="a28d3-105">Data sovereignty per microservice</span></span>

<span data-ttu-id="a28d3-106">L’architecture en microservices obéit à une règle importante, à savoir que chaque microservice doit posséder les données et la logique de son domaine.</span><span class="sxs-lookup"><span data-stu-id="a28d3-106">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="a28d3-107">Au même titre qu’une application complète, chaque microservice doit posséder sa logique et ses données dans un cycle de vie autonome, avec un déploiement indépendant par microservice.</span><span class="sxs-lookup"><span data-stu-id="a28d3-107">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="a28d3-108">Cela signifie que le modèle conceptuel du domaine varie d’un sous-système ou d’un microservice à l’autre.</span><span class="sxs-lookup"><span data-stu-id="a28d3-108">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="a28d3-109">Par exemple, dans le cas des applications d’entreprise, l’application de gestion de la relation client, le sous-système de vente transactionnelle et le sous-système d’assistance à la clientèle appellent chacun les attributs et les données d’une entité client unique, et utilisent chacun un contexte délimité (BC, Bounded Context) différent.</span><span class="sxs-lookup"><span data-stu-id="a28d3-109">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="a28d3-110">Ce principe est similaire dans la [Conception pilotée par le domaine (DDD, Domain-Driven Design)](https://en.wikipedia.org/wiki/Domain-driven_design), où chaque [contexte délimité](https://martinfowler.com/bliki/BoundedContext.html) ou sous-système ou service autonome doit posséder son modèle de domaine (données, logique et comportement).</span><span class="sxs-lookup"><span data-stu-id="a28d3-110">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="a28d3-111">Chaque contexte délimité DDD correspond à un microservice d’entreprise (un ou plusieurs services).</span><span class="sxs-lookup"><span data-stu-id="a28d3-111">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="a28d3-112">Le modèle Contexte délimité est traité de manière plus détaillée dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="a28d3-112">This point about the Bounded Context pattern is expanded in the next section.</span></span>

<span data-ttu-id="a28d3-113">D’un autre côté, l’approche traditionnelle (données monolithiques) utilisée dans de nombreuses applications consiste à avoir une seule base de données centralisée ou seulement quelques-unes.</span><span class="sxs-lookup"><span data-stu-id="a28d3-113">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="a28d3-114">Il s’agit souvent d’une base de données SQL normalisée, utilisée pour l’ensemble de l’application et tous ses sous-systèmes internes (figure 4-7).</span><span class="sxs-lookup"><span data-stu-id="a28d3-114">This is often a normalized SQL database that's used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![Diagramme montrant les deux approches de base de données.](./media/data-sovereignty-per-microservice/data-sovereignty-comparison.png)

<span data-ttu-id="a28d3-116">**Figure 4-7**.</span><span class="sxs-lookup"><span data-stu-id="a28d3-116">**Figure 4-7**.</span></span> <span data-ttu-id="a28d3-117">Comparaison de la souveraineté des données : base de données monolithique et microservices</span><span class="sxs-lookup"><span data-stu-id="a28d3-117">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="a28d3-118">Dans l’approche classique, il existe une seule base de données partagée entre tous les services, généralement dans une architecture à plusieurs niveaux.</span><span class="sxs-lookup"><span data-stu-id="a28d3-118">In the traditional approach, there's a single database shared across all services, typically in a tiered architecture.</span></span> <span data-ttu-id="a28d3-119">Dans l’approche des microservices, chaque microservice possède son modèle/données.</span><span class="sxs-lookup"><span data-stu-id="a28d3-119">In the microservices approach, each microservice owns its model/data.</span></span> <span data-ttu-id="a28d3-120">À première vue, l’approche consistant à utiliser une base de données centralisée est plus simple et prend en charge la réutilisation des entités dans différents sous-systèmes à des fins de cohérence.</span><span class="sxs-lookup"><span data-stu-id="a28d3-120">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="a28d3-121">Mais en réalité, vous vous retrouvez avec des tables énormes qui sont au service de différents sous-systèmes, et qui incluent des attributs et des colonnes superflus dans la plupart des cas.</span><span class="sxs-lookup"><span data-stu-id="a28d3-121">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that aren't needed in most cases.</span></span> <span data-ttu-id="a28d3-122">Tout se passe comme si vous utilisiez la même carte pour faire une petite promenade à pied, faire un trajet en voiture d’une journée et apprendre la géographie.</span><span class="sxs-lookup"><span data-stu-id="a28d3-122">It's like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="a28d3-123">Une application monolithique, qui comprend généralement une seule base de données relationnelle, offre deux avantages importants : les [transactions ACID](https://en.wikipedia.org/wiki/ACID) et le langage SQL, ces deux éléments fonctionnant sur toutes les tables et toutes les données relatives à votre application.</span><span class="sxs-lookup"><span data-stu-id="a28d3-123">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="a28d3-124">Cette approche vous permet d’écrire facilement une requête qui combine les données de plusieurs tables.</span><span class="sxs-lookup"><span data-stu-id="a28d3-124">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="a28d3-125">Cependant, l’accès aux données devient beaucoup plus compliqué lorsque vous passez à une architecture de microservices.</span><span class="sxs-lookup"><span data-stu-id="a28d3-125">However, data access becomes much more complicated when you move to a microservices architecture.</span></span> <span data-ttu-id="a28d3-126">Même lorsqu’on utilise des transactions ACID dans un microservice ou un contexte limité, il est crucial de considérer que les données détenues par chaque microservice sont privées de ce microservice et ne doivent être consultées que de façon synchrone par le biais de ses paramètres d’API (REST, gRPC, SOAP, etc.) ou asynchrone par messagerie (AMQP ou similaire).</span><span class="sxs-lookup"><span data-stu-id="a28d3-126">Even when using ACID transactions within a microservice or Bounded Context, it is crucial to consider that the data owned by each microservice is private to that microservice and should only be accessed either synchronously through its API endpoints(REST, gRPC, SOAP, etc) or asynchronously via messaging(AMQP or similar).</span></span>

<span data-ttu-id="a28d3-127">L’encapsulation des données garantit que les microservices sont faiblement couplés et qu’ils peuvent évoluer indépendamment les uns des autres.</span><span class="sxs-lookup"><span data-stu-id="a28d3-127">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="a28d3-128">Si plusieurs services accèdent aux mêmes données, les mises à jour du schéma nécessitent l’application de mises à jour coordonnées à tous les services,</span><span class="sxs-lookup"><span data-stu-id="a28d3-128">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="a28d3-129">ce qui peut compromettre l’autonomie du cycle de vie des microservices.</span><span class="sxs-lookup"><span data-stu-id="a28d3-129">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="a28d3-130">Toutefois, les structures de données distribuées ne vous permettent pas d’effectuer une même transaction ACID sur plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="a28d3-130">But distributed data structures mean that you can't make a single ACID transaction across microservices.</span></span> <span data-ttu-id="a28d3-131">Vous devez donc recourir à la cohérence à terme quand un processus d’entreprise s’étend sur plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="a28d3-131">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="a28d3-132">Cela est beaucoup plus difficile à implémenter que de simples jointures SQL, car vous ne pouvez pas créer de contraintes d’intégrité ni utiliser de transactions distribuées entre des bases de données distinctes, comme nous l’allons l’expliquer plus tard.</span><span class="sxs-lookup"><span data-stu-id="a28d3-132">This is much harder to implement than simple SQL joins, because you can't create integrity constraints or use distributed transactions between separate databases, as we'll explain later on.</span></span> <span data-ttu-id="a28d3-133">De même, de nombreuses autres fonctionnalités propres aux bases de données relationnelles ne sont pas disponibles à l’échelle de plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="a28d3-133">Similarly, many other relational database features aren't available across multiple microservices.</span></span>

<span data-ttu-id="a28d3-134">Pour aller encore plus loin, des microservices différents utilisent souvent différents *genres* de bases de données.</span><span class="sxs-lookup"><span data-stu-id="a28d3-134">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="a28d3-135">Les applications modernes stockent et traitent différents genres de données. Une base de données relationnelle ne constitue pas toujours le meilleur choix.</span><span class="sxs-lookup"><span data-stu-id="a28d3-135">Modern applications store and process diverse kinds of data, and a relational database isn't always the best choice.</span></span> <span data-ttu-id="a28d3-136">Pour certains cas d’usage, une base de données NoSQL comme Azure CosmosDB ou MongoDB peut offrir un modèle de données plus pratique ainsi qu’un meilleur niveau de performance et de scalabilité qu’une base de données SQL comme SQL Server ou Azure SQL Database.</span><span class="sxs-lookup"><span data-stu-id="a28d3-136">For some use cases, a NoSQL database such as Azure CosmosDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="a28d3-137">Dans d’autres cas, une base de données relationnelle reste la meilleure approche.</span><span class="sxs-lookup"><span data-stu-id="a28d3-137">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="a28d3-138">Les applications basées sur des microservices utilisent donc souvent un mélange de bases de données SQL et NoSQL, une approche parfois appelée « [persistance polyglotte](https://martinfowler.com/bliki/PolyglotPersistence.html) ».</span><span class="sxs-lookup"><span data-stu-id="a28d3-138">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="a28d3-139">Une architecture partitionnée avec persistance polyglotte pour le stockage de données présente de nombreux avantages,</span><span class="sxs-lookup"><span data-stu-id="a28d3-139">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="a28d3-140">notamment des services faiblement couplés et de meilleurs résultats en termes de performances, de scalabilité, de coûts et de facilité de gestion.</span><span class="sxs-lookup"><span data-stu-id="a28d3-140">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="a28d3-141">Toutefois, elle peut entraîner des problèmes de gestion des données distribuée, comme indiqué dans « [Identification des limites du modèle de domaine](identify-microservice-domain-model-boundaries.md) » plus loin dans ce chapitre.</span><span class="sxs-lookup"><span data-stu-id="a28d3-141">However, it can introduce some distributed data management challenges, as explained in "[Identifying domain-model boundaries](identify-microservice-domain-model-boundaries.md)" later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="a28d3-142">Relation entre les microservices et le modèle Contexte délimité</span><span class="sxs-lookup"><span data-stu-id="a28d3-142">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="a28d3-143">Le concept de microservice dérive du [modèle de Contexte délimité (BC, Bounded Context)](https://martinfowler.com/bliki/BoundedContext.html) présenté dans la [conception pilotée par le domaine (DDD, Domain-Driven Design)](https://en.wikipedia.org/wiki/Domain-driven_design).</span><span class="sxs-lookup"><span data-stu-id="a28d3-143">The concept of microservice derives from the [Bounded Context (BC) pattern](https://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="a28d3-144">La conception DDD gère les modèles volumineux en les divisant en plusieurs contextes délimités et en définissant leurs limites de manière explicite.</span><span class="sxs-lookup"><span data-stu-id="a28d3-144">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="a28d3-145">Chaque contexte délimité doit avoir son propre modèle et sa propre base de données. De même, chaque microservice possède ses données connexes.</span><span class="sxs-lookup"><span data-stu-id="a28d3-145">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="a28d3-146">Chaque contexte délimité a aussi généralement son propre [langage omniprésent](https://martinfowler.com/bliki/UbiquitousLanguage.html) pour faciliter la communication entre les développeurs de logiciels et les experts du domaine.</span><span class="sxs-lookup"><span data-stu-id="a28d3-146">In addition, each BC usually has its own [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="a28d3-147">Les termes du langage omniprésent (principalement des entités de domaine) peuvent avoir d’autres noms dans différents contextes délimités, même quand différentes entités de domaine partagent la même identité (c’est-à-dire l’ID unique utilisé pour lire l’entité dans le stockage).</span><span class="sxs-lookup"><span data-stu-id="a28d3-147">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that's used to read the entity from storage).</span></span> <span data-ttu-id="a28d3-148">Par exemple, dans le contexte délimité d’un profil utilisateur, l’entité de domaine User peut partager l’identité avec l’entité de domaine Buyer dans le contexte délimité de la commande.</span><span class="sxs-lookup"><span data-stu-id="a28d3-148">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="a28d3-149">Un microservice est donc similaire à un contexte délimité, mais il indique également qu’il est un service distribué.</span><span class="sxs-lookup"><span data-stu-id="a28d3-149">A microservice is therefore like a Bounded Context, but it also specifies that it's a distributed service.</span></span> <span data-ttu-id="a28d3-150">Il se présente sous la forme d’un processus distinct pour chaque contexte délimité et doit utiliser les protocoles distribués indiqués précédemment, notamment HTTP/HTTPS, WebSockets ou [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span><span class="sxs-lookup"><span data-stu-id="a28d3-150">It's built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="a28d3-151">Toutefois, le modèle Contexte délimité ne spécifie pas si le contexte délimité est un service distribué, ou s’il s’agit simplement d’une limite logique (par exemple un sous-système générique) dans une application à déploiement monolithique.</span><span class="sxs-lookup"><span data-stu-id="a28d3-151">The Bounded Context pattern, however, doesn't specify whether the Bounded Context is a distributed service or if it's simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="a28d3-152">Il est important de souligner que la définition d’un service pour chaque contexte délimité est un bon point de départ.</span><span class="sxs-lookup"><span data-stu-id="a28d3-152">It's important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="a28d3-153">Mais cela ne doit en aucun cas restreindre votre conception.</span><span class="sxs-lookup"><span data-stu-id="a28d3-153">But you don't have to constrain your design to it.</span></span> <span data-ttu-id="a28d3-154">Parfois, vous devez concevoir un contexte délimité ou un microservice d’entreprise composé de plusieurs services physiques.</span><span class="sxs-lookup"><span data-stu-id="a28d3-154">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="a28d3-155">En fin de compte, les deux modèles (Contexte délimité et microservice) sont étroitement liés.</span><span class="sxs-lookup"><span data-stu-id="a28d3-155">But ultimately, both patterns -Bounded Context and microservice- are closely related.</span></span>

<span data-ttu-id="a28d3-156">La conception DDD tire parti des microservices en obtenant les limites réelles sous la forme de microservices distribués.</span><span class="sxs-lookup"><span data-stu-id="a28d3-156">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="a28d3-157">Mais le fait de ne pas partager le modèle entre microservices dans un contexte délimité peut aussi être ce que vous recherchez.</span><span class="sxs-lookup"><span data-stu-id="a28d3-157">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="a28d3-158">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="a28d3-158">Additional resources</span></span>

- <span data-ttu-id="a28d3-159">**Chris Richardson. Modèle : Base de données par service** </span><span class="sxs-lookup"><span data-stu-id="a28d3-159">**Chris Richardson. Pattern: Database per service** </span></span>\
  <https://microservices.io/patterns/data/database-per-service.html>

- <span data-ttu-id="a28d3-160">**Martin Fowler. LimiteContexte** </span><span class="sxs-lookup"><span data-stu-id="a28d3-160">**Martin Fowler. BoundedContext** </span></span>\
  <https://martinfowler.com/bliki/BoundedContext.html>

- <span data-ttu-id="a28d3-161">**Martin Fowler. PolyglotPersistence (PolyglotPersistence)** </span><span class="sxs-lookup"><span data-stu-id="a28d3-161">**Martin Fowler. PolyglotPersistence** </span></span>\
  <https://martinfowler.com/bliki/PolyglotPersistence.html>

- <span data-ttu-id="a28d3-162">**Alberto Brandolini. Conception stratégique de domaine avec la cartographie de contexte** </span><span class="sxs-lookup"><span data-stu-id="a28d3-162">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping** </span></span>\
  <https://www.infoq.com/articles/ddd-contextmapping>

>[!div class="step-by-step"]
><span data-ttu-id="a28d3-163">[Suivant précédent](microservices-architecture.md)
>[Next](logical-versus-physical-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="a28d3-163">[Previous](microservices-architecture.md)
[Next](logical-versus-physical-architecture.md)</span></span>
