---
title: Communication dans une architecture de microservices
description: Explorez les différents modes de communication entre les microservices, et découvrez les implications des modes synchrone et asynchrone.
ms.date: 01/30/2020
ms.openlocfilehash: f2d6e78966bb7d5f481de6db0ab1dcfe2812a1b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401654"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="e3879-103">Communication dans une architecture de microservices</span><span class="sxs-lookup"><span data-stu-id="e3879-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="e3879-104">Dans une application monolithique s’exécutant sur un seul processus, les composants s’appellent mutuellement avec des appels de méthode ou de fonction au niveau du langage.</span><span class="sxs-lookup"><span data-stu-id="e3879-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="e3879-105">Ceux-ci peuvent être fortement couplés si vous créez des objets avec du code (par exemple `new ClassName()`), ou ils peuvent être appelés de façon découplée si vous utilisez l’injection de dépendances en référençant des abstractions au lieu d’instances d’objets concrets.</span><span class="sxs-lookup"><span data-stu-id="e3879-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="e3879-106">Dans les deux cas, les objets s’exécutent dans le même processus.</span><span class="sxs-lookup"><span data-stu-id="e3879-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="e3879-107">La plus grande problématique quand vous passez d’une application monolithique à une application basée sur des microservices se trouve dans le changement du mécanisme de communication.</span><span class="sxs-lookup"><span data-stu-id="e3879-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="e3879-108">Une conversion directe des appels de méthode in-process en appels RPC à des services aboutit à des communications intensives et inefficaces qui ne fonctionnent pas bien dans les environnements distribués.</span><span class="sxs-lookup"><span data-stu-id="e3879-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="e3879-109">La problématique liée à la conception correcte d’un système distribué est tellement bien connue qu’il existe même un ensemble de principes canoniques appelé les [Illusions de l’informatique distribuée](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing). Cet ensemble liste les suppositions que font souvent les développeurs quand ils passent de conceptions monolithiques à des conceptions distribuées.</span><span class="sxs-lookup"><span data-stu-id="e3879-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="e3879-110">Il n’existe pas une seule solution, il en existe plusieurs.</span><span class="sxs-lookup"><span data-stu-id="e3879-110">There isn't one solution, but several.</span></span> <span data-ttu-id="e3879-111">Une solution consiste à isoler autant que possible le microservice métier.</span><span class="sxs-lookup"><span data-stu-id="e3879-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="e3879-112">Vous utilisez ensuite une communication asynchrone entre les microservices internes, et vous remplacez la communication à petite échelle, qui est classique dans la communication intraprocessus entre objets, par une communication à plus grande échelle.</span><span class="sxs-lookup"><span data-stu-id="e3879-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="e3879-113">Vous pouvez réaliser cela en regroupant les appels et en retournant au client des données qui agrègent les résultats de plusieurs appels internes.</span><span class="sxs-lookup"><span data-stu-id="e3879-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="e3879-114">Une application basée sur des microservices est un système distribué s’exécutant sur plusieurs processus ou services, généralement même entre plusieurs serveurs ou plusieurs hôtes.</span><span class="sxs-lookup"><span data-stu-id="e3879-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="e3879-115">Chaque instance de service est généralement un processus.</span><span class="sxs-lookup"><span data-stu-id="e3879-115">Each service instance is typically a process.</span></span> <span data-ttu-id="e3879-116">Pour cette raison, les services doivent interagir en utilisant un protocole de communication interprocessus, comme HTTP ou AMQP, ou un protocole binaire, comme TCP, selon la nature de chaque service.</span><span class="sxs-lookup"><span data-stu-id="e3879-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="e3879-117">La communauté des microservices promeut une philosophie consistant à avoir « [des points de terminaison intelligents et des canaux stupides](https://simplicable.com/new/smart-endpoints-and-dumb-pipes) ». Ce slogan encourage une conception aussi découplée que possible entre les microservices, et aussi cohérente que possible dans un même microservice.</span><span class="sxs-lookup"><span data-stu-id="e3879-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="e3879-118">Comme expliqué précédemment, chaque microservice a ses propres données et sa propre logique de domaine.</span><span class="sxs-lookup"><span data-stu-id="e3879-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="e3879-119">Cependant, les microservices composant une application de bout en bout sont généralement chorégraphiés simplement avec des communications REST au lieu de protocoles complexes comme WS-\*, et avec des communications flexibles pilotées par les événements au lieu d’orchestrateurs de processus métier centralisés.</span><span class="sxs-lookup"><span data-stu-id="e3879-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="e3879-120">Les deux protocoles couramment utilisés sont le protocole de requête/réponse HTTP avec des API de ressources (lors de l’interrogation de la plupart d’entre eux) et une messagerie asynchrone légère lors de la communication lors de la communication de mises à jour entre plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="e3879-121">Ils sont expliqués avec plus de détails dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="e3879-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="e3879-122">Types de communication</span><span class="sxs-lookup"><span data-stu-id="e3879-122">Communication types</span></span>

<span data-ttu-id="e3879-123">Un client et des services peuvent communiquer via de nombreux types différents de communication, chacun d’eux ciblant un scénario et des objectifs différents.</span><span class="sxs-lookup"><span data-stu-id="e3879-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="e3879-124">Au départ, ces types de communication peuvent être classés selon deux axes.</span><span class="sxs-lookup"><span data-stu-id="e3879-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="e3879-125">Le premier axe définit si le protocole est synchrone ou asynchrone :</span><span class="sxs-lookup"><span data-stu-id="e3879-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="e3879-126">Protocole synchrone.</span><span class="sxs-lookup"><span data-stu-id="e3879-126">Synchronous protocol.</span></span> <span data-ttu-id="e3879-127">HTTP est un protocole synchrone.</span><span class="sxs-lookup"><span data-stu-id="e3879-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="e3879-128">Le client envoie une requête et attend une réponse du service.</span><span class="sxs-lookup"><span data-stu-id="e3879-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="e3879-129">Cela est indépendant de l’exécution du code client, qui peut être synchrone (le thread est bloqué) ou asynchrone (le thread n’est pas bloqué, et la réponse atteint finalement un rappel).</span><span class="sxs-lookup"><span data-stu-id="e3879-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="e3879-130">Le point important ici est que le protocole (HTTP/HTTPS) est synchrone et que le code client peut continuer sa tâche seulement quand il reçoit la réponse du serveur HTTP.</span><span class="sxs-lookup"><span data-stu-id="e3879-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="e3879-131">Protocole asynchrone.</span><span class="sxs-lookup"><span data-stu-id="e3879-131">Asynchronous protocol.</span></span> <span data-ttu-id="e3879-132">D’autres protocoles, comme AMQP (un protocole pris en charge par de nombreux systèmes d’exploitation et environnements cloud), utilisent des messages asynchrones.</span><span class="sxs-lookup"><span data-stu-id="e3879-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="e3879-133">Le code client ou l’expéditeur du message n’attend généralement pas de réponse.</span><span class="sxs-lookup"><span data-stu-id="e3879-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="e3879-134">Il envoie simplement le message comme lors de l’envoi d’un message à une file d’attente RabbitMQ ou à tout autre service broker de messages.</span><span class="sxs-lookup"><span data-stu-id="e3879-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="e3879-135">Le deuxième axe définit si la communication a un ou plusieurs destinataires :</span><span class="sxs-lookup"><span data-stu-id="e3879-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="e3879-136">Destinataire unique.</span><span class="sxs-lookup"><span data-stu-id="e3879-136">Single receiver.</span></span> <span data-ttu-id="e3879-137">Chaque demande doit être traitée par exactement un récepteur ou un service.</span><span class="sxs-lookup"><span data-stu-id="e3879-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="e3879-138">Le [modèle Commande](https://en.wikipedia.org/wiki/Command_pattern) est un exemple de cette communication.</span><span class="sxs-lookup"><span data-stu-id="e3879-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="e3879-139">Plusieurs destinataires.</span><span class="sxs-lookup"><span data-stu-id="e3879-139">Multiple receivers.</span></span> <span data-ttu-id="e3879-140">Chaque demande peut être traitée par zéro à plusieurs destinataires.</span><span class="sxs-lookup"><span data-stu-id="e3879-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="e3879-141">Ce type de communication doit être asynchrone.</span><span class="sxs-lookup"><span data-stu-id="e3879-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="e3879-142">Le mécanisme de [publication/abonnement](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) utilisé dans des modèles comme [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html) en est un exemple.</span><span class="sxs-lookup"><span data-stu-id="e3879-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="e3879-143">Il s’appuie sur une interface de bus d’événements ou un répartiteur de messages durant la propagation des mises à jour des données entre plusieurs microservices via des événements. Il est généralement implémenté via un bus de service ou un artefact similaire, par exemple [Azure Service Bus](https://azure.microsoft.com/services/service-bus/), à l’aide des [rubriques et abonnements](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="e3879-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="e3879-144">Une application basée sur des microservices utilise souvent une combinaison de ces styles de communication.</span><span class="sxs-lookup"><span data-stu-id="e3879-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="e3879-145">Le type le plus courant est une communication avec un seul destinataire, avec un protocole synchrone comme HTTP/HTTPS lors de l’appel d’un service web HTTP d’API ordinaire.</span><span class="sxs-lookup"><span data-stu-id="e3879-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="e3879-146">Les microservices utilisent aussi en général des protocoles de messagerie pour la communication asynchrone entre microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="e3879-147">Il est bon de connaître ces axes pour avoir une compréhension claire des mécanismes de communication possibles, mais ils ne représentent pas des problèmes importants à prendre en compte au moment de la génération de microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="e3879-148">Ni la nature asynchrone de l’exécution des threads clients ni la nature asynchrone du protocole choisi sont les points importants lors de l’intégration de microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="e3879-149">Ce qui *est* important est de pouvoir intégrer vos microservices de façon asynchrone tout en conservant leur indépendance, comme expliqué dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="e3879-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="e3879-150">L’intégration de microservices asynchrones implique l’autonomie des microservices</span><span class="sxs-lookup"><span data-stu-id="e3879-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="e3879-151">Comme cela a été mentionné, le point important lors de la création d’une application basée sur des microservices est la façon dont vous intégrez vos microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="e3879-152">Dans l’idéal, vous devez essayer de réduire la communication entre les microservices internes.</span><span class="sxs-lookup"><span data-stu-id="e3879-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="e3879-153">Moins il existe de communications entre les microservices, mieux c’est.</span><span class="sxs-lookup"><span data-stu-id="e3879-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="e3879-154">Mais dans de nombreux cas, vous devez intégrer les microservices d’une façon ou d’une autre.</span><span class="sxs-lookup"><span data-stu-id="e3879-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="e3879-155">Quand vous devez le faire, la règle essentielle ici est que la communication entre les microservices doit être asynchrone.</span><span class="sxs-lookup"><span data-stu-id="e3879-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="e3879-156">Cela ne signifie pas que vous devez utiliser un protocole spécifique (par exemple une messagerie asynchrone par opposition au protocole HTTP synchrone).</span><span class="sxs-lookup"><span data-stu-id="e3879-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="e3879-157">Cela signifie simplement que vous devez effectuer la communication entre microservices par propagation asynchrone des données, tout en essayant de ne pas dépendre d’autres microservices internes dans le cadre de l’opération de requête-réponse HTTP du service initial.</span><span class="sxs-lookup"><span data-stu-id="e3879-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="e3879-158">Si possible, ne dépendez jamais d’une communication synchrone (requête/réponse) entre plusieurs microservices, pas même pour des requêtes.</span><span class="sxs-lookup"><span data-stu-id="e3879-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="e3879-159">L’objectif de chaque microservice est d’être autonome et disponible pour le consommateur client, même si les autres services qui font partie de l’application de bout en bout sont indisponibles ou défectueux.</span><span class="sxs-lookup"><span data-stu-id="e3879-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="e3879-160">Si vous pensez que vous devez effectuer un appel d’un microservice à d’autres microservices (par exemple, effectuer une requête HTTP pour une requête de données) afin de pouvoir fournir une réponse à une application cliente, votre architecture ne sera pas résiliente en cas d’échec de certains microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="e3879-161">De plus, l’existence de dépendances HTTP entre microservices, par exemple durant la création de cycles longs de requête-réponse avec des chaînes de requêtes HTTP, comme indiqué dans la première partie de la figure 4-15, rend non seulement vos microservices non autonomes, mais impacte aussi leur niveau de performance dès qu’un des services de la chaîne ne fonctionne pas correctement.</span><span class="sxs-lookup"><span data-stu-id="e3879-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="e3879-162">Plus vous ajoutez des dépendances synchrones entre microservices, comme des demandes avec des requêtes, plus le temps de réponse global se dégrade pour les applications clientes.</span><span class="sxs-lookup"><span data-stu-id="e3879-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![Diagramme montrant trois types de communications dans les microservices.](./media/communication-in-microservice-architecture/sync-vs-async-patterns-across-microservices.png)

<span data-ttu-id="e3879-164">**Figure 4-15**.</span><span class="sxs-lookup"><span data-stu-id="e3879-164">**Figure 4-15**.</span></span> <span data-ttu-id="e3879-165">Antimodèles et modèles de communication entre microservices</span><span class="sxs-lookup"><span data-stu-id="e3879-165">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="e3879-166">Comme le montre le diagramme ci-dessus, dans la communication synchrone, une « chaîne » de demandes est créée entre les microservices tout en répondant à la demande du client.</span><span class="sxs-lookup"><span data-stu-id="e3879-166">As shown in the above diagram, in synchronous communication a "chain" of requests is created between microservices while serving the client request.</span></span> <span data-ttu-id="e3879-167">Ceci est un antimodèle.</span><span class="sxs-lookup"><span data-stu-id="e3879-167">This is an anti-pattern.</span></span> <span data-ttu-id="e3879-168">Dans une communication asynchrone, les microservices utilisent des messages asynchrones ou une interrogation HTTP pour communiquer avec d’autres microservices, mais la requête cliente est immédiatement traitée.</span><span class="sxs-lookup"><span data-stu-id="e3879-168">In asynchronous communication microservices use asynchronous messages or http polling to communicate with other microservices, but the client request is served right away.</span></span>

<span data-ttu-id="e3879-169">Si votre microservice doit déclencher une action supplémentaire dans un autre microservice, si possible, n’effectuez pas cette action de façon synchrone ni dans le cadre de l’opération de requête et réponse du microservice d’origine.</span><span class="sxs-lookup"><span data-stu-id="e3879-169">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="e3879-170">Au lieu de cela, effectuez l’opération de façon asynchrone (en utilisant une messagerie asynchrone ou des événements d’intégration, des files d’attente, etc.).</span><span class="sxs-lookup"><span data-stu-id="e3879-170">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="e3879-171">Cependant, autant que possible, n’appelez pas l’action de façon synchrone dans le cadre de l’opération de requête et de réponse synchrone d’origine.</span><span class="sxs-lookup"><span data-stu-id="e3879-171">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="e3879-172">Enfin (et c’est là que la plupart des problèmes se posent durant la génération de microservices), si votre microservice initial a besoin de données détenues à l’origine par d’autres microservices, ne vous fiez pas à l’utilisation de requêtes synchrones pour ces données.</span><span class="sxs-lookup"><span data-stu-id="e3879-172">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="e3879-173">À la place, répliquez ou propagez ces données (seulement les attributs nécessaires) dans la base de données du service initial en utilisant une cohérence à terme (généralement à l’aide d’événements d’intégration, comme cela est expliqué dans les prochaines sections).</span><span class="sxs-lookup"><span data-stu-id="e3879-173">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="e3879-174">Comme indiqué précédemment dans les [limites du modèle de domaine d’identification pour chaque section de microservice,](identify-microservice-domain-model-boundaries.md) dupliquer certaines données dans plusieurs microservices n’est pas une conception incorrecte— au contraire, lorsque vous pouvez traduire les données dans la langue ou les termes spécifiques de ce domaine supplémentaire ou contexte lié.</span><span class="sxs-lookup"><span data-stu-id="e3879-174">As noted earlier in the [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) section, duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="e3879-175">Par exemple, dans l’application [eShopOnContainers,](https://github.com/dotnet-architecture/eShopOnContainers) vous avez un microservice nommé `identity-api` qui est en `User`charge de la plupart des données de l’utilisateur avec une entité nommée .</span><span class="sxs-lookup"><span data-stu-id="e3879-175">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named `identity-api` that's in charge of most of the user's data with an entity named `User`.</span></span> <span data-ttu-id="e3879-176">Cependant, lorsque vous avez besoin de `Ordering` stocker des données sur l’utilisateur `Buyer`dans le microservice, vous les stockez comme une entité différente nommée .</span><span class="sxs-lookup"><span data-stu-id="e3879-176">However, when you need to store data about the user within the `Ordering` microservice, you store it as a different entity named `Buyer`.</span></span> <span data-ttu-id="e3879-177">L’entité `Buyer` partage la même `User` identité avec l’entité d’origine, `Ordering` mais elle pourrait n’avoir que les quelques attributs nécessaires par le domaine, et non l’ensemble du profil utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e3879-177">The `Buyer` entity shares the same identity with the original `User` entity, but it might have only the few attributes needed by the `Ordering` domain, and not the whole user profile.</span></span>

<span data-ttu-id="e3879-178">Vous pouvez utiliser n’importe quel protocole pour communiquer et propager des données de façon asynchrone entre les microservices pour avoir une cohérence à terme.</span><span class="sxs-lookup"><span data-stu-id="e3879-178">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="e3879-179">Comme cela a été mentionné, vous pouvez utiliser des événements d’intégration avec un bus d’événements ou un courtier de messages, ou vous pouvez même utiliser HTTP en interrogeant les autres services.</span><span class="sxs-lookup"><span data-stu-id="e3879-179">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="e3879-180">Cela n’a pas d’importance.</span><span class="sxs-lookup"><span data-stu-id="e3879-180">It doesn't matter.</span></span> <span data-ttu-id="e3879-181">La règle importante est de ne pas créer de dépendances synchrones entre vos microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-181">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="e3879-182">Les sections suivantes expliquent les différents styles de communication que vous pouvez envisager d’utiliser dans une application basée sur des microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-182">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="e3879-183">Styles de communication</span><span class="sxs-lookup"><span data-stu-id="e3879-183">Communication styles</span></span>

<span data-ttu-id="e3879-184">De nombreux protocoles et choix sont disponibles pour la communication, en fonction du type de communication que vous voulez utiliser.</span><span class="sxs-lookup"><span data-stu-id="e3879-184">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="e3879-185">Si vous utilisez un mécanisme de communication de type requête-réponse synchrone, les protocoles tels que HTTP et REST sont les plus courants, en particulier si vous publiez vos services en dehors de l’hôte Docker ou du cluster de microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-185">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="e3879-186">Si vous communiquez entre des services de manière interne (au sein de votre hôte Docker ou de votre cluster de microservices), vous pouvez également utiliser des mécanismes de communication au format binaire (par exemple WCF à l’aide de TCP et d’un format binaire).</span><span class="sxs-lookup"><span data-stu-id="e3879-186">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like WCF using TCP and binary format).</span></span> <span data-ttu-id="e3879-187">Vous pouvez aussi utiliser des mécanismes de communication asynchrones basés sur des messages, comme AMQP.</span><span class="sxs-lookup"><span data-stu-id="e3879-187">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="e3879-188">Il existe également plusieurs formats de message, comme JSON ou XML, ou même des formats binaires, qui peuvent être plus efficaces.</span><span class="sxs-lookup"><span data-stu-id="e3879-188">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="e3879-189">Si le format binaire choisi n’est pas standard, il n’est probablement pas judicieux de publier vos services et de les rendre publics à l’aide de ce format.</span><span class="sxs-lookup"><span data-stu-id="e3879-189">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="e3879-190">Vous pouvez utiliser un format non standard pour la communication interne entre vos microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-190">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="e3879-191">Vous pouvez procéder ainsi pour la communication entre microservices dans votre hôte Docker ou votre cluster de microservices (par exemple, orchestrateurs Docker), ou pour des applications clientes propriétaires qui communiquent avec les microservices.</span><span class="sxs-lookup"><span data-stu-id="e3879-191">You might do this when communicating between microservices within your Docker host or microservice cluster (for example, Docker orchestrators), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="e3879-192">Communication demande/réponse avec HTTP et REST</span><span class="sxs-lookup"><span data-stu-id="e3879-192">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="e3879-193">Quand un client utilise une communication demande/réponse, il envoie une demande à un service, puis le service traite la demande et renvoie une réponse.</span><span class="sxs-lookup"><span data-stu-id="e3879-193">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="e3879-194">La communication demande/réponse est particulièrement bien adaptée pour interroger des données pour une interface utilisateur en temps réel (une interface utilisateur dynamique) à partir d’applications clientes.</span><span class="sxs-lookup"><span data-stu-id="e3879-194">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="e3879-195">Dans une architecture de microservices, vous allez donc probablement utiliser ce mécanisme de communication pour la plupart des requêtes, comme indiqué sur la figure 4-16.</span><span class="sxs-lookup"><span data-stu-id="e3879-195">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![Diagramme montrant les demandes/réponses pour les requêtes et mises à jour en direct.](./media/communication-in-microservice-architecture/request-response-comms-live-queries-updates.png)

<span data-ttu-id="e3879-197">**Figure 4-16**.</span><span class="sxs-lookup"><span data-stu-id="e3879-197">**Figure 4-16**.</span></span> <span data-ttu-id="e3879-198">Utilisation d’une communication demande/réponse HTTP (synchrone ou asynchrone)</span><span class="sxs-lookup"><span data-stu-id="e3879-198">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="e3879-199">Quand un client utilise une communication demande/réponse, il suppose que la réponse arrivera dans un délai court, en général en moins d’une seconde ou au plus en quelques secondes.</span><span class="sxs-lookup"><span data-stu-id="e3879-199">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="e3879-200">Pour les réponses différées, vous devez implémenter une communication asynchrone basée sur des [modèles de messagerie](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) et des [technologies de messagerie](https://en.wikipedia.org/wiki/Message-oriented_middleware), qui est une approche différente que nous expliquons dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="e3879-200">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="e3879-201">[REST](https://en.wikipedia.org/wiki/Representational_state_transfer) est un style d’architecture répandu pour la communication demande/réponse.</span><span class="sxs-lookup"><span data-stu-id="e3879-201">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="e3879-202">Cette approche est basée sur le protocole [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) et y est étroitement couplée ; elle utilise des verbes HTTP comme GET, POST et PUT.</span><span class="sxs-lookup"><span data-stu-id="e3879-202">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="e3879-203">REST est l’approche architecturale de communication la plus couramment utilisée pour la création de services.</span><span class="sxs-lookup"><span data-stu-id="e3879-203">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="e3879-204">Vous pouvez implémenter des services REST quand vous développez des services d’API web ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="e3879-204">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="e3879-205">Vous profitez d’autres avantages si vous utilisez les services HTTP REST en tant que langage IDL (Interface Definition Language).</span><span class="sxs-lookup"><span data-stu-id="e3879-205">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="e3879-206">Par exemple, si vous utilisez des [métadonnées Swagger](https://swagger.io/) pour décrire l’API de votre service, vous pouvez utiliser des outils qui génèrent des stubs clients, qui peuvent directement découvrir et utiliser vos services.</span><span class="sxs-lookup"><span data-stu-id="e3879-206">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="e3879-207">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="e3879-207">Additional resources</span></span>

- <span data-ttu-id="e3879-208">**Martin Fowler. Modèle de maturité Richardson** Une description du modèle REST.</span><span class="sxs-lookup"><span data-stu-id="e3879-208">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  <https://martinfowler.com/articles/richardsonMaturityModel.html>

- <span data-ttu-id="e3879-209">**Swagger** : site officiel.</span><span class="sxs-lookup"><span data-stu-id="e3879-209">**Swagger** The official site.</span></span> \
  <https://swagger.io/>

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="e3879-210">Communication par envoi (push) en temps réel basée sur HTTP</span><span class="sxs-lookup"><span data-stu-id="e3879-210">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="e3879-211">Une autre possibilité (généralement utilisée à des fins différentes de REST) est une communication en temps réel un-à-plusieurs avec des frameworks de plus haut niveau, comme [ASP.NET SignalR](https://www.asp.net/signalr) et des protocoles comme [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="e3879-211">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="e3879-212">Comme le montre la figure 4-17, la communication HTTP en temps réel signifie que le code serveur peut envoyer (push) du contenu à des clients connectés à mesure que les données sont disponibles, au lieu que le serveur attende qu’un client demande de nouvelles données.</span><span class="sxs-lookup"><span data-stu-id="e3879-212">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![Diagramme montrant la poussée et les comms en temps réel basés sur SignalR.](./media/communication-in-microservice-architecture/one-to-many-communication.png)

<span data-ttu-id="e3879-214">**Figure 4-17**.</span><span class="sxs-lookup"><span data-stu-id="e3879-214">**Figure 4-17**.</span></span> <span data-ttu-id="e3879-215">Communication par messages asynchrones un-à-un en temps réel</span><span class="sxs-lookup"><span data-stu-id="e3879-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="e3879-216">SignalR est un bon moyen d’effectuer une communication en temps réel pour envoyer (push) du contenu aux clients à partir d’un serveur back-end.</span><span class="sxs-lookup"><span data-stu-id="e3879-216">SignalR is a good way to achieve real-time communication for pushing content to the clients from a back-end server.</span></span> <span data-ttu-id="e3879-217">Étant donné que la communication est en temps réel, les applications clientes montrent les modifications quasi instantanément.</span><span class="sxs-lookup"><span data-stu-id="e3879-217">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="e3879-218">Ceci est généralement géré par un protocole comme WebSockets, avec de nombreuses connexions WebSockets (une par client).</span><span class="sxs-lookup"><span data-stu-id="e3879-218">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="e3879-219">Un exemple classique est quand un service communique un changement de score d’une rencontre sportive simultanément à de nombreuses d’applications web clientes.</span><span class="sxs-lookup"><span data-stu-id="e3879-219">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="e3879-220">[Suivant précédent](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[Next](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="e3879-220">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>
