---
title: Conception d’un microservice orienté DDD
description: Architecture des microservices .NET pour les applications .NET conteneurisées | Comprendre la conception du microservice orienté DDD (Domain Driven Design) et de ses couches d’application.
ms.date: 10/08/2018
ms.openlocfilehash: c5ac55978ca979a3ae055d9b0cd2d3c6b3187b4e
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/07/2019
ms.locfileid: "73739944"
---
# <a name="design-a-ddd-oriented-microservice"></a><span data-ttu-id="26267-103">Concevoir un microservice orienté DDD</span><span class="sxs-lookup"><span data-stu-id="26267-103">Design a DDD-oriented microservice</span></span>

<span data-ttu-id="26267-104">La conception DDD (Domain-Driven Design) préconise une modélisation basée sur la réalité de l’entreprise applicable à vos cas d’usage.</span><span class="sxs-lookup"><span data-stu-id="26267-104">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="26267-105">Dans le contexte de la génération d’applications, DDD traite les problèmes comme des domaines.</span><span class="sxs-lookup"><span data-stu-id="26267-105">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="26267-106">Elle décrit les problèmes indépendants comme des contextes délimités (chaque contexte délimité correspond à un microservice) et met l’accent sur un langage commun pour discuter de ces problèmes.</span><span class="sxs-lookup"><span data-stu-id="26267-106">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="26267-107">Elle suggère également de nombreux modèles et concepts techniques, comme des entités de domaine avec des modèles élaborés (aucun [modèle de domaine anémique](https://martinfowler.com/bliki/AnemicDomainModel.html)), objets de valeur, agrégats et règles de racine d’agrégat (ou d’entité racine) pour prendre en charge l’implémentation interne.</span><span class="sxs-lookup"><span data-stu-id="26267-107">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="26267-108">Cette section présente la conception et l’implémentation de ces modèles internes.</span><span class="sxs-lookup"><span data-stu-id="26267-108">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="26267-109">Parfois, ces modèles et règles techniques DDD sont considérés comme des obstacles avec une courbe d’apprentissage importante pour implémenter les approches DDD.</span><span class="sxs-lookup"><span data-stu-id="26267-109">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="26267-110">Toutefois, le plus important ne concerne pas les modèles proprement dits, mais l’organisation du code afin qu’il soit aligné sur les problèmes métier et l’utilisation des mêmes termes métier (langage omniprésent).</span><span class="sxs-lookup"><span data-stu-id="26267-110">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="26267-111">En outre, les approches DDD doivent être appliquées uniquement si vous implémentez des microservices complexes avec des règles métier importantes.</span><span class="sxs-lookup"><span data-stu-id="26267-111">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="26267-112">Des responsabilités plus simples, comme un service CRUD, peuvent être gérées avec des approches plus simples.</span><span class="sxs-lookup"><span data-stu-id="26267-112">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="26267-113">Le tracé des limites est la tâche clé lors de la conception et de la définition d’un microservice.</span><span class="sxs-lookup"><span data-stu-id="26267-113">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="26267-114">Les modèles DDD vous aident à comprendre la complexité dans le domaine.</span><span class="sxs-lookup"><span data-stu-id="26267-114">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="26267-115">Pour le modèle de domaine de chaque contexte délimité, vous identifiez et définissez les entités, les objets de valeur et les agrégats qui modélisent votre domaine.</span><span class="sxs-lookup"><span data-stu-id="26267-115">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="26267-116">Vous générez et affinez un modèle de domaine contenu dans une limite qui définit votre contexte.</span><span class="sxs-lookup"><span data-stu-id="26267-116">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="26267-117">Cela est très explicite sous la forme d’un microservice.</span><span class="sxs-lookup"><span data-stu-id="26267-117">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="26267-118">Les composants au sein de ces limites finissent par être vos microservices bien que, dans certains cas, un contexte délimité ou des microservices métier peuvent être composés de plusieurs services physiques.</span><span class="sxs-lookup"><span data-stu-id="26267-118">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="26267-119">La conception DDD concerne les limites, tout comme les microservices.</span><span class="sxs-lookup"><span data-stu-id="26267-119">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="26267-120">Maintenir les limites de contexte de microservices relativement faibles</span><span class="sxs-lookup"><span data-stu-id="26267-120">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="26267-121">Le choix de l’emplacement des limites entre les contextes délimités assure l’équilibre de deux objectifs concurrents.</span><span class="sxs-lookup"><span data-stu-id="26267-121">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="26267-122">Tout d’abord, vous voulez créer initialement les plus petits microservices possibles, même si cela ne doit pas être le principal facteur ; vous devez créer une limite autour des éléments en manque de cohésion.</span><span class="sxs-lookup"><span data-stu-id="26267-122">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="26267-123">En second lieu, vous voulez éviter les communications bavardes entre microservices.</span><span class="sxs-lookup"><span data-stu-id="26267-123">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="26267-124">Ces objectifs peuvent être contradictoires.</span><span class="sxs-lookup"><span data-stu-id="26267-124">These goals can contradict one another.</span></span> <span data-ttu-id="26267-125">Vous devez les équilibrer en décomposant le système en autant de petits microservices que possible jusqu’à ce que vous voyiez l’augmentation rapide des limites de communication avec chaque nouvelle tentative de séparation d’un nouveau contexte délimité.</span><span class="sxs-lookup"><span data-stu-id="26267-125">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="26267-126">La cohésion est essentielle dans un contexte délimité unique.</span><span class="sxs-lookup"><span data-stu-id="26267-126">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="26267-127">Elle est similaire aux [mauvaises odeurs (ou « code smell »)](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) lors de l’implémentation de classes.</span><span class="sxs-lookup"><span data-stu-id="26267-127">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="26267-128">Si deux microservices doivent beaucoup collaborer entre eux, ils doivent probablement représenter le même microservice.</span><span class="sxs-lookup"><span data-stu-id="26267-128">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="26267-129">Une autre perspective est l’autonomie.</span><span class="sxs-lookup"><span data-stu-id="26267-129">Another way to look at this is autonomy.</span></span> <span data-ttu-id="26267-130">Si un microservice doit s’appuyer sur un autre service pour traiter directement une demande, il n’est pas réellement autonome.</span><span class="sxs-lookup"><span data-stu-id="26267-130">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="26267-131">Couches dans les microservices DDD</span><span class="sxs-lookup"><span data-stu-id="26267-131">Layers in DDD microservices</span></span>

<span data-ttu-id="26267-132">La plupart des applications d’entreprise avec une importante complexité technique et métier sont définies par plusieurs couches.</span><span class="sxs-lookup"><span data-stu-id="26267-132">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="26267-133">Les couches sont un artefact logique et ne sont pas liées au déploiement du service.</span><span class="sxs-lookup"><span data-stu-id="26267-133">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="26267-134">Elles existent pour aider les développeurs à gérer la complexité dans le code.</span><span class="sxs-lookup"><span data-stu-id="26267-134">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="26267-135">Différentes couches (par exemple, la couche de modèle de domaine par rapport à la couche de présentation, etc.) peuvent avoir différents types, ce qui impose des conversions entre ces types.</span><span class="sxs-lookup"><span data-stu-id="26267-135">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="26267-136">Par exemple, une entité peut être chargée à partir de la base de données.</span><span class="sxs-lookup"><span data-stu-id="26267-136">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="26267-137">Par la suite, une partie de ces informations, ou une agrégation d’informations dont des données supplémentaires provenant d’autres entités, peut être envoyée à l’interface utilisateur du client via une API web REST.</span><span class="sxs-lookup"><span data-stu-id="26267-137">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="26267-138">L’intérêt ici est que l’entité de domaine est contenue dans la couche de modèle de domaine et qu’elle ne doit pas être propagée à d’autres zones auxquelles elle n’appartient pas, comme à la couche de présentation.</span><span class="sxs-lookup"><span data-stu-id="26267-138">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="26267-139">En outre, vous devez disposer d’entités toujours valides (consultez la section [Conception de validations dans la couche de modèle de domaine](domain-model-layer-validations.md)) contrôlées par les racines d’agrégat (entités racine).</span><span class="sxs-lookup"><span data-stu-id="26267-139">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](domain-model-layer-validations.md) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="26267-140">Par conséquent, les entités ne doivent pas liées aux vues clientes, car il est possible que certaines données ne soient pas encore validées au niveau de l’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="26267-140">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="26267-141">C’est là où intervient le ViewModel.</span><span class="sxs-lookup"><span data-stu-id="26267-141">This is what the ViewModel is for.</span></span> <span data-ttu-id="26267-142">Ce dernier est un modèle de données destiné exclusivement à répondre aux besoins de la couche de présentation.</span><span class="sxs-lookup"><span data-stu-id="26267-142">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="26267-143">Les entités de domaine n’appartiennent pas directement au ViewModel.</span><span class="sxs-lookup"><span data-stu-id="26267-143">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="26267-144">Au lieu de cela, vous devez effectuer la conversion entre ViewModels et entités de domaine, et vice versa.</span><span class="sxs-lookup"><span data-stu-id="26267-144">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="26267-145">Quand le problème de la complexité est abordé, il est important de disposer d’un modèle de domaine contrôlé par les racines d’agrégat qui vérifient que l’ensemble des invariants et règles associés à ce groupe d’entités (agrégat) fonctionne via un point d’entrée unique (une porte), la racine d’agrégat.</span><span class="sxs-lookup"><span data-stu-id="26267-145">When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root.</span></span>

<span data-ttu-id="26267-146">La figure 7-5 montre l’implémentation d’une conception par couches dans l’application eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="26267-146">Figure 7-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![Diagramme montrant les couches dans un microservice de conception piloté par domaine.](./media/ddd-oriented-microservice/domain-driven-design-microservice.png)

<span data-ttu-id="26267-148">**Figure 7-5**.</span><span class="sxs-lookup"><span data-stu-id="26267-148">**Figure 7-5**.</span></span> <span data-ttu-id="26267-149">Couches DDD dans le microservice de commandes dans eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="26267-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="26267-150">Les trois couches dans un microservice DDD comme Ordering.</span><span class="sxs-lookup"><span data-stu-id="26267-150">The three layers in a DDD microservice like Ordering.</span></span> <span data-ttu-id="26267-151">Chaque couche est un projet Visual Studio : la couche Application est Ordering.API, la couche Domaine est Ordering.Domain et la couche Infrastructure est Ordering.Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="26267-151">Each layer is a VS project: Application layer is Ordering.API, Domain layer is Ordering.Domain and the Infrastructure layer is Ordering.Infrastructure.</span></span> <span data-ttu-id="26267-152">Vous souhaitez concevoir le système afin que chaque couche communique uniquement avec certaines autres couches.</span><span class="sxs-lookup"><span data-stu-id="26267-152">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="26267-153">Cela peut être plus facile à appliquer si les couches sont implémentées comme des bibliothèques de classes différentes, car vous pouvez identifier clairement les dépendances définies entre les bibliothèques.</span><span class="sxs-lookup"><span data-stu-id="26267-153">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="26267-154">Par exemple, la couche de modèle de domaine ne nécessite pas de dépendance sur une autre couche (les classes de modèle de domaine doivent être des classes d’objets CLR traditionnels ou [OCT](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)).</span><span class="sxs-lookup"><span data-stu-id="26267-154">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="26267-155">Comme illustré dans la figure 7-6, la bibliothèque de la couche **Ordering.Domain** a des dépendances de bibliothèques .NET Core ou de packages NuGet seulement, et n’a pas de dépendances d’autres bibliothèques personnalisées, comme la bibliothèque de données ou la bibliothèque de persistance.</span><span class="sxs-lookup"><span data-stu-id="26267-155">As shown in Figure 7-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries or NuGet packages, but not on any other custom library, such as data library or persistence library.</span></span>

![Capture d’écran des dépendances de classement. domain.](./media/ddd-oriented-microservice/ordering-domain-dependencies.png)

<span data-ttu-id="26267-157">**Figure 7-6**.</span><span class="sxs-lookup"><span data-stu-id="26267-157">**Figure 7-6**.</span></span> <span data-ttu-id="26267-158">Les couches implémentées comme des bibliothèques permettent de mieux contrôler les dépendances entre les couches</span><span class="sxs-lookup"><span data-stu-id="26267-158">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="26267-159">Couche de modèle de domaine</span><span class="sxs-lookup"><span data-stu-id="26267-159">The domain model layer</span></span>

<span data-ttu-id="26267-160">L’excellent livre d’Eric Evans [Domain Driven Design](https://domainlanguage.com/ddd/) affirme ce qui suit à propos de la couche de modèle de domaine et de la couche d’application.</span><span class="sxs-lookup"><span data-stu-id="26267-160">Eric Evans's excellent book [Domain Driven Design](https://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="26267-161">**Couche de modèle de domaine** : chargée de représenter les concepts de l’entreprise, des informations sur sa situation ainsi que ses règles.</span><span class="sxs-lookup"><span data-stu-id="26267-161">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="26267-162">L’état qui reflète la situation de l’entreprise est contrôlé et utilisé ici, même si les détails techniques du stockage sont délégués à l’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="26267-162">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="26267-163">Cette couche est au cœur des logiciels d’entreprise.</span><span class="sxs-lookup"><span data-stu-id="26267-163">This layer is the heart of business software.</span></span>

<span data-ttu-id="26267-164">La couche de modèle de domaine est l’endroit où l’entreprise s’exprime.</span><span class="sxs-lookup"><span data-stu-id="26267-164">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="26267-165">Quand vous implémentez une couche de modèle de domaine de microservice dans .NET, cette couche est codée comme une bibliothèque de classes avec les entités de domaine qui capturent les données ainsi que le comportement (méthodes avec logique).</span><span class="sxs-lookup"><span data-stu-id="26267-165">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="26267-166">Selon les principes [d’ignorance de la persistance](https://deviq.com/persistence-ignorance/) et [d’ignorance de l’infrastructure](https://ayende.com/blog/3137/infrastructure-ignorance), cette couche doit ignorer complètement les détails de persistance des données.</span><span class="sxs-lookup"><span data-stu-id="26267-166">Following the [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="26267-167">Ces tâches de persistance doivent être effectuées par la couche d’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="26267-167">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="26267-168">Par conséquent, cette couche ne nécessite pas de dépendances directes sur l’infrastructure, ce qui signifie qu’il est important que vos classes d’entité de modèle de domaine soient des classes [OCT](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object).</span><span class="sxs-lookup"><span data-stu-id="26267-168">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="26267-169">Les entités de domaine ne doivent pas avoir de dépendance directe (par exemple, une dérivation d’une classe de base) sur un framework d’infrastructure d’accès aux données comme Entity Framework ou NHibernate.</span><span class="sxs-lookup"><span data-stu-id="26267-169">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="26267-170">Dans l’idéal, vos entités de domaine ne doivent pas dériver d’un type ni implémenter un type défini dans un framework d’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="26267-170">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="26267-171">La plupart des frameworks ORM modernes comme Entity Framework Core autorisent cette approche, afin que vos classes de modèle de domaine ne soient pas couplées à l’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="26267-171">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="26267-172">Toutefois, il n’est pas toujours possible d’avoir des entités OCT lors de l’utilisation de certains frameworks et bases de données NoSQL, comme Actors et Reliable Collections dans Azure Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="26267-172">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="26267-173">Même quand il est important de suivre le principe d’ignorance de la persistance pour votre modèle de domaine, vous ne devez pas ignorer les questions liées à la persistance.</span><span class="sxs-lookup"><span data-stu-id="26267-173">Even when it is important to follow the Persistence Ignorance principle for your Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="26267-174">Il est toujours très important de comprendre le modèle de données physique et comment il est mappé à votre modèle d’objet entité.</span><span class="sxs-lookup"><span data-stu-id="26267-174">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="26267-175">Dans le cas contraire, vous pouvez créer des conceptions impossibles.</span><span class="sxs-lookup"><span data-stu-id="26267-175">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="26267-176">En outre, cela ne signifie pas que vous pouvez prendre un modèle conçu pour une base de données relationnelle et le déplacer directement vers une base de données orientée document ou NoSQL.</span><span class="sxs-lookup"><span data-stu-id="26267-176">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="26267-177">Dans certains modèles d’entité, le modèle peut correspondre, mais ce n’est généralement pas le cas.</span><span class="sxs-lookup"><span data-stu-id="26267-177">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="26267-178">Il existe toujours des contraintes que votre modèle d’entité doit respecter, basées sur les technologies de stockage et ORM.</span><span class="sxs-lookup"><span data-stu-id="26267-178">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="26267-179">Couche d’application</span><span class="sxs-lookup"><span data-stu-id="26267-179">The application layer</span></span>

<span data-ttu-id="26267-180">En passant à la couche d’application, nous pouvons à nouveau citer le livre d’Eric Evans [Domain Driven Design](https://domainlanguage.com/ddd/) :</span><span class="sxs-lookup"><span data-stu-id="26267-180">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](https://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="26267-181">**Couche d’application :** définit les travaux que le logiciel est supposé effectuer et dirige les objets de domaine expressifs pour résoudre les problèmes.</span><span class="sxs-lookup"><span data-stu-id="26267-181">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="26267-182">Les tâches dont cette couche est responsable sont significatives pour l’entreprise ou nécessaires pour l’interaction avec les couches d’application d’autres systèmes.</span><span class="sxs-lookup"><span data-stu-id="26267-182">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="26267-183">Cette couche reste mince.</span><span class="sxs-lookup"><span data-stu-id="26267-183">This layer is kept thin.</span></span> <span data-ttu-id="26267-184">Elle ne contient pas de règles métier ni de connaissances métier, mais coordonne uniquement les tâches et le travail des délégués pour les collaborations des objets de domaine dans la couche suivante.</span><span class="sxs-lookup"><span data-stu-id="26267-184">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="26267-185">Elle ne présente pas d’état reflétant la situation de l’entreprise, mais peut avoir un état qui reflète la progression d’une tâche pour l’utilisateur ou le programme.</span><span class="sxs-lookup"><span data-stu-id="26267-185">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="26267-186">La couche d’application d’un microservice dans .NET est généralement codée comme un projet d’API web ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="26267-186">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="26267-187">Le projet implémente l’interaction du microservice, l’accès réseau à distance et les API web externes utilisées dans les applications clientes ou l’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="26267-187">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="26267-188">Il inclut des requêtes dans le cadre d’une approche CQRS, des commandes acceptées par le microservice et même la communication pilotée par événements entre les microservices (événements d’intégration).</span><span class="sxs-lookup"><span data-stu-id="26267-188">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="26267-189">L’API web ASP.NET Core qui représente la couche d’application ne doit pas contenir de règles métier ni de connaissances de domaine (notamment des règles de domaine pour les transactions ou les mises à jour) : celles-ci doivent appartenir à la bibliothèque de classes de modèle de domaine.</span><span class="sxs-lookup"><span data-stu-id="26267-189">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="26267-190">La couche d’application doit uniquement coordonner les tâches et ne doit pas contenir ni définir d’état de domaine (modèle de domaine).</span><span class="sxs-lookup"><span data-stu-id="26267-190">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="26267-191">Elle délègue l’exécution des règles métier aux classes de modèle de domaine (racines d’agrégat et entités de domaine) qui vont finalement mettre à jour les données au sein de ces entités de domaine.</span><span class="sxs-lookup"><span data-stu-id="26267-191">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="26267-192">En fait, la logique d’application est l’endroit où vous implémentez tous les cas d’usage qui dépendent d’un frontend donné,</span><span class="sxs-lookup"><span data-stu-id="26267-192">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="26267-193">par exemple l’implémentation liée à un service API web.</span><span class="sxs-lookup"><span data-stu-id="26267-193">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="26267-194">L’objectif est que la logique de domaine dans la couche de modèle de domaine, ses invariants, le modèle de données et les règles métier associées soient complètement indépendants des couches de présentation et d’application.</span><span class="sxs-lookup"><span data-stu-id="26267-194">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="26267-195">Surtout, la couche de modèle de domaine ne doit pas dépendre directement d’un framework d’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="26267-195">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="26267-196">Couche d’infrastructure</span><span class="sxs-lookup"><span data-stu-id="26267-196">The infrastructure layer</span></span>

<span data-ttu-id="26267-197">La couche d’infrastructure représente la façon dont les données qui sont initialement contenues dans les entités de domaine (en mémoire) sont conservées dans les bases de données ou un autre magasin persistant.</span><span class="sxs-lookup"><span data-stu-id="26267-197">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="26267-198">Un exemple est l’utilisation de code Entity Framework Core pour implémenter les classes de modèle de dépôt qui utilisent un DBContext pour conserver les données dans une base de données relationnelle.</span><span class="sxs-lookup"><span data-stu-id="26267-198">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="26267-199">Conformément aux principes [d’ignorance de la persistance](https://deviq.com/persistence-ignorance/) et [d’ignorance de l’infrastructure](https://ayende.com/blog/3137/infrastructure-ignorance) mentionnés précédemment, la couche d’infrastructure ne doit pas « contaminer » la couche de modèle de domaine.</span><span class="sxs-lookup"><span data-stu-id="26267-199">In accordance with the previously mentioned [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="26267-200">Les classes d’entité de modèle de domaine doivent rester étrangères à l’infrastructure qui vous permet de rendre persistantes des données (EF ou tout autre framework) en évitant les dépendances dures sur les frameworks.</span><span class="sxs-lookup"><span data-stu-id="26267-200">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="26267-201">Votre bibliothèque de classes de couche de modèle de domaine doit avoir uniquement votre code de domaine, simplement des classes d’entité [OCT](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) qui implémentent le cœur de votre logiciel et qui sont complètement découplées des technologies d’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="26267-201">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="26267-202">Ainsi, vos couches ou vos bibliothèques et projets de classes doivent au final s’appuyer sur votre couche de modèle de domaine (bibliothèque), et pas l’inverse, comme illustré dans la figure 7-7.</span><span class="sxs-lookup"><span data-stu-id="26267-202">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 7-7.</span></span>

![Diagramme montrant les dépendances qui existent entre les couches de service de DDD.](./media/ddd-oriented-microservice/ddd-service-layer-dependencies.png)

<span data-ttu-id="26267-204">**Figure 7-7**.</span><span class="sxs-lookup"><span data-stu-id="26267-204">**Figure 7-7**.</span></span> <span data-ttu-id="26267-205">Dépendances entre les couches dans DDD</span><span class="sxs-lookup"><span data-stu-id="26267-205">Dependencies between layers in DDD</span></span>

<span data-ttu-id="26267-206">Dépendances dans un service de conception DDD : la couche Application dépend des couches Domaine et Infrastructure, la couche Infrastructure dépend de la couche Domaine, mais la couche Domaine ne dépend d’aucune couche.</span><span class="sxs-lookup"><span data-stu-id="26267-206">Dependencies in a DDD Service, the Application layer depends on Domain and Infrastructure, and Infrastructure depends on Domain, but Domain doesn't depend on any layer.</span></span> <span data-ttu-id="26267-207">Cette conception de couche doit être indépendante pour chaque microservice.</span><span class="sxs-lookup"><span data-stu-id="26267-207">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="26267-208">Comme indiqué précédemment, vous pouvez implémenter les microservices les plus complexes suivant des modèles DDD, tout en implémentant des microservices pilotés par des données plus simples (CRUD de base dans une couche unique) plus simplement.</span><span class="sxs-lookup"><span data-stu-id="26267-208">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="26267-209">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="26267-209">Additional resources</span></span>

- <span data-ttu-id="26267-210">**DevIQ. Principe d’ignorance de la persistance** </span><span class="sxs-lookup"><span data-stu-id="26267-210">**DevIQ. Persistence Ignorance principle** </span></span>\
  <https://deviq.com/persistence-ignorance/>

- <span data-ttu-id="26267-211">**Oren Eini.**  \ d’ignorance de l’infrastructure</span><span class="sxs-lookup"><span data-stu-id="26267-211">**Oren Eini. Infrastructure Ignorance** \</span></span>
  <https://ayende.com/blog/3137/infrastructure-ignorance>

- <span data-ttu-id="26267-212">**Ange Lopez. Architecture en couches dans la conception pilotée par domaine** </span><span class="sxs-lookup"><span data-stu-id="26267-212">**Angel Lopez. Layered Architecture In Domain-Driven Design** </span></span>\
  <https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/>

>[!div class="step-by-step"]
><span data-ttu-id="26267-213">[Précédent](cqrs-microservice-reads.md)
>[Suivant](microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="26267-213">[Previous](cqrs-microservice-reads.md)
[Next](microservice-domain-model.md)</span></span>
