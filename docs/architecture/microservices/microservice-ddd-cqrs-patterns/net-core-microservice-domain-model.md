---
title: Implémentation d’un modèle de domaine de microservice avec .NET Core
description: Architecture des microservices .NET pour les applications .NET conteneurisées | Accéder aux détails d’implémentation d’un modèle de domaine orienté DDD.
ms.date: 10/08/2018
ms.openlocfilehash: 0b42ecc2440faf5870b2d99e31d03cda00b21ce0
ms.sourcegitcommit: 5280b2aef60a1ed99002dba44e4b9e7f6c830604
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/03/2020
ms.locfileid: "84306905"
---
# <a name="implement-a-microservice-domain-model-with-net-core"></a><span data-ttu-id="2a4b3-103">Implémenter un modèle de domaine de microservice avec .NET Core</span><span class="sxs-lookup"><span data-stu-id="2a4b3-103">Implement a microservice domain model with .NET Core</span></span>

<span data-ttu-id="2a4b3-104">Dans la section précédente, les modèles et principes fondamentaux de conception d’un modèle de domaine ont été expliqués.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-104">In the previous section, the fundamental design principles and patterns for designing a domain model were explained.</span></span> <span data-ttu-id="2a4b3-105">Il est maintenant temps de découvrir des méthodes possibles pour implémenter le modèle de domaine à l’aide de .NET Core (code C\# standard) et EF Core.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-105">Now it is time to explore possible ways to implement the domain model by using .NET Core (plain C\# code) and EF Core.</span></span> <span data-ttu-id="2a4b3-106">Votre modèle de domaine sera composé simplement de votre code.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-106">Your domain model will be composed simply of your code.</span></span> <span data-ttu-id="2a4b3-107">Il présentera seulement les exigences en matière de modèle EF Core, mais pas de dépendances réelles sur EF.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-107">It will have just the EF Core model requirements, but not real dependencies on EF.</span></span> <span data-ttu-id="2a4b3-108">Vous ne devez pas avoir de dépendances dures ni de références à EF Core ou n’importe quel autre ORM dans votre modèle de domaine.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-108">You should not have hard dependencies or references to EF Core or any other ORM in your domain model.</span></span>

## <a name="domain-model-structure-in-a-custom-net-standard-library"></a><span data-ttu-id="2a4b3-109">Structure de modèle de domaine dans une bibliothèque .NET Standard personnalisée</span><span class="sxs-lookup"><span data-stu-id="2a4b3-109">Domain model structure in a custom .NET Standard Library</span></span>

<span data-ttu-id="2a4b3-110">L’organisation des dossiers utilisée pour l’application de référence eShopOnContainers montre le modèle DDD pour l’application.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-110">The folder organization used for the eShopOnContainers reference application demonstrates the DDD model for the application.</span></span> <span data-ttu-id="2a4b3-111">Vous pouvez trouver qu’une organisation des dossiers différente communique plus clairement les choix de conception effectués pour votre application.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-111">You might find that a different folder organization more clearly communicates the design choices made for your application.</span></span> <span data-ttu-id="2a4b3-112">Comme vous pouvez le voir dans la figure 7-10, il existe deux agrégats dans le modèle de domaine de commandes : l’agrégat des commandes et l’agrégat des acheteurs.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-112">As you can see in Figure 7-10, in the ordering domain model there are two aggregates, the order aggregate and the buyer aggregate.</span></span> <span data-ttu-id="2a4b3-113">Chaque agrégat est un groupe d’entités de domaine et d’objets de valeur, bien que vous puissiez également avoir un agrégat composé d’une entité de domaine unique (la racine d’agrégat ou l’entité racine).</span><span class="sxs-lookup"><span data-stu-id="2a4b3-113">Each aggregate is a group of domain entities and value objects, although you could have an aggregate composed of a single domain entity (the aggregate root or root entity) as well.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/ordering-microservice-container.png" alt-text="Capture d’écran du projet Ordering. Domain dans Explorateur de solutions.":::
<span data-ttu-id="2a4b3-115">La vue Explorateur de solutions pour le projet Ordering. Domain, qui affiche le dossier AggregatesModel contenant les dossiers BuyerAggregate et OrderAggregate, chacun contenant ses classes d’entité, ses fichiers objet de valeur, etc.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-115">The Solution Explorer view for the Ordering.Domain project, showing the AggregatesModel folder containing the BuyerAggregate and OrderAggregate folders, each one containing its entity classes, value object files and so on.</span></span>
:::image-end:::

<span data-ttu-id="2a4b3-116">**Figure 7-10.**</span><span class="sxs-lookup"><span data-stu-id="2a4b3-116">**Figure 7-10**.</span></span> <span data-ttu-id="2a4b3-117">Structure de modèle de domaine pour le microservice de commandes dans eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="2a4b3-117">Domain model structure for the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="2a4b3-118">En outre, la couche de modèle de domaine inclut les contrats de dépôt (interfaces) qui représentent les exigences en matière d’infrastructure de votre modèle de domaine.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-118">Additionally, the domain model layer includes the repository contracts (interfaces) that are the infrastructure requirements of your domain model.</span></span> <span data-ttu-id="2a4b3-119">En d’autres termes, ces interfaces indiquent les dépôts et les méthodes que la couche d’infrastructure doit implémenter.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-119">In other words, these interfaces express what repositories and the methods the infrastructure layer must implement.</span></span> <span data-ttu-id="2a4b3-120">Il est essentiel que l’implémentation des dépôts soit placée en dehors de la couche de modèle de domaine dans la bibliothèque de couches d’infrastructure, de sorte que la couche de modèle de domaine n’est pas « contaminée » par l’API ou les classes des technologies d’infrastructure, comme Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-120">It is critical that the implementation of the repositories be placed outside of the domain model layer, in the infrastructure layer library, so the domain model layer is not "contaminated" by API or classes from infrastructure technologies, like Entity Framework.</span></span>

<span data-ttu-id="2a4b3-121">Vous pouvez également voir un dossier [SeedWork](https://martinfowler.com/bliki/Seedwork.html) qui contient des classes de base personnalisées que vous pouvez utiliser comme base pour vos entités de domaine et objets de valeur, de sorte que vous n’avez pas de code redondant dans la classe d’objets de chaque domaine.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-121">You can also see a [SeedWork](https://martinfowler.com/bliki/Seedwork.html) folder that contains custom base classes that you can use as a base for your domain entities and value objects, so you do not have redundant code in each domain's object class.</span></span>

## <a name="structure-aggregates-in-a-custom-net-standard-library"></a><span data-ttu-id="2a4b3-122">Structurer des agrégats dans une bibliothèque .NET Standard personnalisée</span><span class="sxs-lookup"><span data-stu-id="2a4b3-122">Structure aggregates in a custom .NET Standard library</span></span>

<span data-ttu-id="2a4b3-123">Un agrégat fait référence à un cluster d’objets de domaine regroupés pour assurer une cohérence transactionnelle.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-123">An aggregate refers to a cluster of domain objects grouped together to match transactional consistency.</span></span> <span data-ttu-id="2a4b3-124">Ces objets peuvent être des instances d’entités (un exemple est la racine d’agrégat ou l’entité racine) ainsi que tous les autres objets de valeur.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-124">Those objects could be instances of entities (one of which is the aggregate root or root entity) plus any additional value objects.</span></span>

<span data-ttu-id="2a4b3-125">La cohérence transactionnelle signifie qu’il est certain qu’un agrégat est cohérent et à jour à la fin d’une action métier.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-125">Transactional consistency means that an aggregate is guaranteed to be consistent and up to date at the end of a business action.</span></span> <span data-ttu-id="2a4b3-126">Par exemple, l’agrégat des commandes du modèle de domaine de microservice de commandes eShopOnContainers est composé comme indiqué dans la figure 7-11.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-126">For example, the order aggregate from the eShopOnContainers ordering microservice domain model is composed as shown in Figure 7-11.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/vs-solution-explorer-order-aggregate.png" alt-text="Capture d’écran du dossier OrderAggregate et de ses classes.":::
<span data-ttu-id="2a4b3-128">Vue détaillée du dossier OrderAggregate : Address.cs est un objet de valeur, IOrderRepository est une interface de référentiel, Order.cs est une racine d’agrégat, OrderItem.cs est une entité enfant et OrderStatus.cs est une classe d’énumération.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-128">A detailed view of the OrderAggregate folder: Address.cs is a value object, IOrderRepository is a repo interface, Order.cs is an aggregate root, OrderItem.cs is a child entity, and OrderStatus.cs is an enumeration class.</span></span>
:::image-end:::

<span data-ttu-id="2a4b3-129">**Figure 7-11.**</span><span class="sxs-lookup"><span data-stu-id="2a4b3-129">**Figure 7-11**.</span></span> <span data-ttu-id="2a4b3-130">Agrégat des commandes dans une solution Visual Studio</span><span class="sxs-lookup"><span data-stu-id="2a4b3-130">The order aggregate in Visual Studio solution</span></span>

<span data-ttu-id="2a4b3-131">Si vous ouvrez l’un des fichiers dans un dossier d’agrégats, vous pouvez voir comment il est marqué en tant qu’interface ou classe de base personnalisée, comme un objet entité ou de valeur, tel qu’implémenté dans le dossier [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork).</span><span class="sxs-lookup"><span data-stu-id="2a4b3-131">If you open any of the files in an aggregate folder, you can see how it is marked as either a custom base class or interface, like entity or value object, as implemented in the [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork) folder.</span></span>

## <a name="implement-domain-entities-as-poco-classes"></a><span data-ttu-id="2a4b3-132">Implémenter des entités de domaine en tant que classes OCT</span><span class="sxs-lookup"><span data-stu-id="2a4b3-132">Implement domain entities as POCO classes</span></span>

<span data-ttu-id="2a4b3-133">Vous implémentez un modèle de domaine dans .NET en créant des classes OCT qui implémentent vos entités de domaine.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-133">You implement a domain model in .NET by creating POCO classes that implement your domain entities.</span></span> <span data-ttu-id="2a4b3-134">Dans l’exemple suivant, la classe Order est définie comme une entité et également comme une racine d’agrégat.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-134">In the following example, the Order class is defined as an entity and also as an aggregate root.</span></span> <span data-ttu-id="2a4b3-135">Étant donné que la classe Order dérive de la classe de base Entity, elle peut réutiliser le code commun lié aux entités.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-135">Because the Order class derives from the Entity base class, it can reuse common code related to entities.</span></span> <span data-ttu-id="2a4b3-136">Gardez à l’esprit que ces classes de base et interfaces sont définies par vous dans le projet de modèle de domaine ; il s’agit donc de votre code et non d’un code d’infrastructure provenant d’un ORM tel qu’EF.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-136">Bear in mind that these base classes and interfaces are defined by you in the domain model project, so it is your code, not infrastructure code from an ORM like EF.</span></span>

```csharp
// COMPATIBLE WITH ENTITY FRAMEWORK CORE 2.0
// Entity is a custom base class with the ID
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId;

    public OrderStatus OrderStatus { get; private set; }
    private int _orderStatusId;

    private string _description;
    private int? _paymentMethodId;

    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;

    public Order(string userId, Address address, int cardTypeId, string cardNumber, string cardSecurityNumber,
            string cardHolderName, DateTime cardExpiration, int? buyerId = null, int? paymentMethodId = null)
    {
        _orderItems = new List<OrderItem>();
        _buyerId = buyerId;
        _paymentMethodId = paymentMethodId;
        _orderStatusId = OrderStatus.Submitted.Id;
        _orderDate = DateTime.UtcNow;
        Address = address;

        // ...Additional code ...
    }

    public void AddOrderItem(int productId, string productName,
                            decimal unitPrice, decimal discount,
                            string pictureUrl, int units = 1)
    {
        //...
        // Domain rules/logic for adding the OrderItem to the order
        // ...

        var orderItem = new OrderItem(productId, productName, unitPrice, discount, pictureUrl, units);

        _orderItems.Add(orderItem);

    }
    // ...
    // Additional methods with domain rules/logic related to the Order aggregate
    // ...
}
```

<span data-ttu-id="2a4b3-137">Il est important de noter qu’il s’agit d’une entité de domaine implémentée comme une classe OCT.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-137">It is important to note that this is a domain entity implemented as a POCO class.</span></span> <span data-ttu-id="2a4b3-138">Elle n’a aucune dépendance directe sur Entity Framework Core ni un autre framework d’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-138">It does not have any direct dependency on Entity Framework Core or any other infrastructure framework.</span></span> <span data-ttu-id="2a4b3-139">Cette implémentation est telle qu’elle devrait être dans DDD, juste le code C# qui implémente un modèle de domaine.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-139">This implementation is as it should be in DDD, just C# code implementing a domain model.</span></span>

<span data-ttu-id="2a4b3-140">En outre, la classe est décorée avec une interface nommée IAggregateRoot.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-140">In addition, the class is decorated with an interface named IAggregateRoot.</span></span> <span data-ttu-id="2a4b3-141">Cette interface est une interface vide, parfois appelée *interface de marqueur*, qui est utilisée uniquement pour indiquer que cette classe d’entité est également une racine d’agrégat.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-141">That interface is an empty interface, sometimes called a *marker interface*, that is used just to indicate that this entity class is also an aggregate root.</span></span>

<span data-ttu-id="2a4b3-142">Une interface de marqueur est parfois considérée comme un anti-modèle ; toutefois, il s’agit également d’un moyen adéquat pour marquer une classe, en particulier quand cette interface peut évoluer.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-142">A marker interface is sometimes considered as an anti-pattern; however, it is also a clean way to mark a class, especially when that interface might be evolving.</span></span> <span data-ttu-id="2a4b3-143">Un attribut peut représenter l’autre choix pour le marqueur, mais il est plus rapide d’afficher la classe de base (Entity) en regard de l’interface IAggregate au lieu de placer un marqueur d’attribut Aggregate au-dessus de la classe.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-143">An attribute could be the other choice for the marker, but it is quicker to see the base class (Entity) next to the IAggregate interface instead of putting an Aggregate attribute marker above the class.</span></span> <span data-ttu-id="2a4b3-144">Il s’agit d’une question de préférences dans tous les cas.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-144">It is a matter of preferences, in any case.</span></span>

<span data-ttu-id="2a4b3-145">Le fait d’avoir une racine d’agrégat signifie que la majeure partie du code lié à la cohérence et aux règles d’entreprise des entités de l’agrégat doit être implémentée en tant que méthodes dans la classe racine d’agrégat d’ordre (par exemple, AddOrderItem lors de l’ajout d’un objet OrderItem à l’agrégat).</span><span class="sxs-lookup"><span data-stu-id="2a4b3-145">Having an aggregate root means that most of the code related to consistency and business rules of the aggregate's entities should be implemented as methods in the Order aggregate root class (for example, AddOrderItem when adding an OrderItem object to the aggregate).</span></span> <span data-ttu-id="2a4b3-146">Vous ne devez pas créer ni mettre à jour des objets OrderItems indépendamment ou directement ; la classe AggregateRoot doit garder le contrôle et assurer la cohérence de toutes les opérations de mise à jour par rapport à ses entités enfants.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-146">You should not create or update OrderItems objects independently or directly; the AggregateRoot class must keep control and consistency of any update operation against its child entities.</span></span>

## <a name="encapsulate-data-in-the-domain-entities"></a><span data-ttu-id="2a4b3-147">Encapsuler des données dans les entités de domaine</span><span class="sxs-lookup"><span data-stu-id="2a4b3-147">Encapsulate data in the Domain Entities</span></span>

<span data-ttu-id="2a4b3-148">Un problème courant avec les modèles d’entité est qu’ils exposent des propriétés de navigation de collection en tant que types de listes accessibles publiquement.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-148">A common problem in entity models is that they expose collection navigation properties as publicly accessible list types.</span></span> <span data-ttu-id="2a4b3-149">Cela permet à tout développeur collaborateur de manipuler le contenu de ces types de collections, de contourner ainsi des règles métier importantes relatives à la collection et de laisser éventuellement l’objet dans un état non valide.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-149">This allows any collaborator developer to manipulate the contents of these collection types, which may bypass important business rules related to the collection, possibly leaving the object in an invalid state.</span></span> <span data-ttu-id="2a4b3-150">La solution consiste à exposer un accès en lecture seule aux collections associées et à fournir explicitement des méthodes qui définissent des moyens par lesquels les clients peuvent les manipuler.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-150">The solution to this is to expose read-only access to related collections and explicitly provide methods that define ways in which clients can manipulate them.</span></span>

<span data-ttu-id="2a4b3-151">Dans le code précédent, notez que beaucoup d’attributs sont en lecture seule ou privés, et peuvent uniquement être mis à jour par les méthodes de classe. Toute mise à jour tient donc compte des invariants de domaine d’entreprise et de la logique spécifiée dans les méthodes de classe.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-151">In the previous code, note that many attributes are read-only or private and are only updatable by the class methods, so any update considers business domain invariants and logic specified within the class methods.</span></span>

<span data-ttu-id="2a4b3-152">Par exemple, en suivant les modèles DDD, **vous ne devez *pas* effectuer les opérations suivantes** à partir de toute méthode de gestionnaire de commandes ou classe de couche d’application (en fait, il est normalement impossible pour vous de les effectuer) :</span><span class="sxs-lookup"><span data-stu-id="2a4b3-152">For example, following DDD patterns, **you should *not* do the following** from any command handler method or application layer class (actually, it should be impossible for you to do so):</span></span>

```csharp
// WRONG ACCORDING TO DDD PATTERNS – CODE AT THE APPLICATION LAYER OR
// COMMAND HANDLERS
// Code in command handler methods or Web API controllers
//... (WRONG) Some code with business logic out of the domain classes ...
OrderItem myNewOrderItem = new OrderItem(orderId, productId, productName,
    pictureUrl, unitPrice, discount, units);

//... (WRONG) Accessing the OrderItems collection directly from the application layer // or command handlers
myOrder.OrderItems.Add(myNewOrderItem);
//...
```

<span data-ttu-id="2a4b3-153">Dans ce cas, la méthode Add est purement une opération permettant d’ajouter des données, avec un accès direct à la collection OrderItems.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-153">In this case, the Add method is purely an operation to add data, with direct access to the OrderItems collection.</span></span> <span data-ttu-id="2a4b3-154">Par conséquent, une grande partie de la logique de domaine, des règles ou des validations liées à cette opération avec les entités enfants est répartie sur la couche d’application (gestionnaires de commandes et contrôleurs d’API web).</span><span class="sxs-lookup"><span data-stu-id="2a4b3-154">Therefore, most of the domain logic, rules, or validations related to that operation with the child entities will be spread across the application layer (command handlers and Web API controllers).</span></span>

<span data-ttu-id="2a4b3-155">Si vous examinez la racine d’agrégat, elle ne peut pas garantir ses invariants, sa validité ni sa cohérence.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-155">If you go around the aggregate root, the aggregate root cannot guarantee its invariants, its validity, or its consistency.</span></span> <span data-ttu-id="2a4b3-156">Vous obtiendrez finalement un code spaghetti ou un code de script transactionnel.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-156">Eventually you will have spaghetti code or transactional script code.</span></span>

<span data-ttu-id="2a4b3-157">Pour suivre les modèles DDD, les entités ne doivent pas avoir de méthodes setter publiques dans aucune propriété.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-157">To follow DDD patterns, entities must not have public setters in any entity property.</span></span> <span data-ttu-id="2a4b3-158">Les modifications apportées à une entité doivent être pilotées par des méthodes explicites avec un langage omniprésent clair sur la modification effectuée.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-158">Changes in an entity should be driven by explicit methods with explicit ubiquitous language about the change they are performing in the entity.</span></span>

<span data-ttu-id="2a4b3-159">En outre, les collections dans l’entité (par exemple, les articles de la commande) doivent être des propriétés en lecture seule (méthode AsReadOnly abordée plus loin).</span><span class="sxs-lookup"><span data-stu-id="2a4b3-159">Furthermore, collections within the entity (like the order items) should be read-only properties (the AsReadOnly method explained later).</span></span> <span data-ttu-id="2a4b3-160">Vous devez pouvoir effectuer la mise à jour uniquement à partir des méthodes de classe de la racine d’agrégat ou des méthodes de l’entité enfant.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-160">You should be able to update it only from within the aggregate root class methods or the child entity methods.</span></span>

<span data-ttu-id="2a4b3-161">Comme vous pouvez le voir dans le code de la racine d’agrégat Order, tous les accesseurs set doivent être privés ou au moins en lecture seule en externe, de sorte que toute opération sur les données de l’entité ou ses entités enfants doit être effectuée par le biais de méthodes dans la classe d’entité.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-161">As you can see in the code for the Order aggregate root, all setters should be private or at least read-only externally, so that any operation against the entity's data or its child entities has to be performed through methods in the entity class.</span></span> <span data-ttu-id="2a4b3-162">La cohérence est ainsi assurée de manière contrôlée et orientée objet au lieu d’implémenter un code de script transactionnel.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-162">This maintains consistency in a controlled and object-oriented way instead of implementing transactional script code.</span></span>

<span data-ttu-id="2a4b3-163">L’extrait de code suivant montre la façon correcte de coder la tâche d’ajout d’un objet OrderItem à l’agrégat Order.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-163">The following code snippet shows the proper way to code the task of adding an OrderItem object to the Order aggregate.</span></span>

```csharp
// RIGHT ACCORDING TO DDD--CODE AT THE APPLICATION LAYER OR COMMAND HANDLERS
// The code in command handlers or WebAPI controllers, related only to application stuff
// There is NO code here related to OrderItem object's business logic
myOrder.AddOrderItem(productId, productName, pictureUrl, unitPrice, discount, units);

// The code related to OrderItem params validations or domain rules should
// be WITHIN the AddOrderItem method.

//...
```

<span data-ttu-id="2a4b3-164">Dans cet extrait, une grande partie des validations ou de la logique relatives à la création d’un objet OrderItem est sous le contrôle de la racine d’agrégat Order, dans la méthode AddOrderItem, en particulier les validations et logique liées à d’autres éléments dans l’agrégat.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-164">In this snippet, most of the validations or logic related to the creation of an OrderItem object will be under the control of the Order aggregate root—in the AddOrderItem method—especially validations and logic related to other elements in the aggregate.</span></span> <span data-ttu-id="2a4b3-165">Par exemple, vous pouvez obtenir le même article suite à plusieurs appels à AddOrderItem.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-165">For instance, you might get the same product item as the result of multiple calls to AddOrderItem.</span></span> <span data-ttu-id="2a4b3-166">Dans cette méthode, vous pouvez examiner les articles et regrouper les mêmes articles dans un seul objet OrderItem avec plusieurs unités.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-166">In that method, you could examine the product items and consolidate the same product items into a single OrderItem object with several units.</span></span> <span data-ttu-id="2a4b3-167">En outre, s’il existe différents montants de remise alors que l’ID de produit est le même, vous devez probablement appliquer la remise la plus élevée.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-167">Additionally, if there are different discount amounts but the product ID is the same, you would likely apply the higher discount.</span></span> <span data-ttu-id="2a4b3-168">Ce principe s’applique à toute autre logique de domaine pour l’objet OrderItem.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-168">This principle applies to any other domain logic for the OrderItem object.</span></span>

<span data-ttu-id="2a4b3-169">En outre, la nouvelle opération OrderItem(params) sera également contrôlée et effectuée par la méthode AddOrderItem à partir de la racine d’agrégat Order.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-169">In addition, the new OrderItem(params) operation will also be controlled and performed by the AddOrderItem method from the Order aggregate root.</span></span> <span data-ttu-id="2a4b3-170">Par conséquent, une grande partie des validations ou de la logique liées à cette opération (en particulier tout ce qui a un impact sur la cohérence entre les autres entités enfants) est regroupée à un seul endroit au sein de la racine d’agrégat.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-170">Therefore, most of the logic or validations related to that operation (especially anything that impacts the consistency between other child entities) will be in a single place within the aggregate root.</span></span> <span data-ttu-id="2a4b3-171">Il s’agit de l’objectif ultime du modèle de racine d’agrégat.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-171">That is the ultimate purpose of the aggregate root pattern.</span></span>

<span data-ttu-id="2a4b3-172">Quand vous utilisez Entity Framework Core 1.1 ou version ultérieure, une entité DDD peut être mieux exprimée, car elle permet un [mappage à des champs](https://docs.microsoft.com/ef/core/modeling/backing-field) en plus des propriétés.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-172">When you use Entity Framework Core 1.1 or later, a DDD entity can be better expressed because it allows [mapping to fields](https://docs.microsoft.com/ef/core/modeling/backing-field) in addition to properties.</span></span> <span data-ttu-id="2a4b3-173">Cela est utile quand vous protégez des collections d’entités enfants ou d’objets de valeur.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-173">This is useful when protecting collections of child entities or value objects.</span></span> <span data-ttu-id="2a4b3-174">Avec cette amélioration, vous pouvez utiliser de simples champs privés au lieu de propriétés, et vous pouvez implémenter toute mise à jour de la collection de champs dans les méthodes publiques et fournir un accès en lecture seule via la méthode AsReadOnly.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-174">With this enhancement, you can use simple private fields instead of properties and you can implement any update to the field collection in public methods and provide read-only access through the AsReadOnly method.</span></span>

<span data-ttu-id="2a4b3-175">Dans DDD, vous souhaitez mettre à jour l’entité uniquement par le biais des méthodes de l’entité (ou du constructeur) afin de contrôler tout invariant et la cohérence des données, de sorte que les propriétés sont définies uniquement avec un accesseur Get.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-175">In DDD, you want to update the entity only through methods in the entity (or the constructor) in order to control any invariant and the consistency of the data, so properties are defined only with a get accessor.</span></span> <span data-ttu-id="2a4b3-176">Les propriétés sont associées à des champs privés.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-176">The properties are backed by private fields.</span></span> <span data-ttu-id="2a4b3-177">Les membres privés sont uniquement accessibles à partir de la classe.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-177">Private members can only be accessed from within the class.</span></span> <span data-ttu-id="2a4b3-178">Toutefois, il existe une exception : EF Core doit également définir ces champs (afin qu’il puisse retourner l’objet avec les valeurs appropriées).</span><span class="sxs-lookup"><span data-stu-id="2a4b3-178">However, there one exception: EF Core needs to set these fields as well (so it can return the object with the proper values).</span></span>

### <a name="map-properties-with-only-get-accessors-to-the-fields-in-the-database-table"></a><span data-ttu-id="2a4b3-179">Mapper des propriétés avec uniquement des accesseurs get aux champs de la table de base de données</span><span class="sxs-lookup"><span data-stu-id="2a4b3-179">Map properties with only get accessors to the fields in the database table</span></span>

<span data-ttu-id="2a4b3-180">Le mappage de propriétés aux colonnes de la table de base de données n’est pas une responsabilité de domaine, mais fait partie de la couche d’infrastructure et de persistance.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-180">Mapping properties to database table columns is not a domain responsibility but part of the infrastructure and persistence layer.</span></span> <span data-ttu-id="2a4b3-181">Nous le signalons ici uniquement pour que vous soyez informé des nouvelles fonctionnalités dans EF Core 1.1 ou version ultérieure liées au mode de modélisation des entités.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-181">We mention this here just so you are aware of the new capabilities in EF Core 1.1 or later related to how you can model entities.</span></span> <span data-ttu-id="2a4b3-182">D’autres détails sur ce sujet sont décrits dans la section relative à l’infrastructure et la persistance.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-182">Additional details on this topic are explained in the infrastructure and persistence section.</span></span>

<span data-ttu-id="2a4b3-183">Quand vous utilisez EF Core 1.0 ou une version ultérieure, dans le DbContext, vous devez mapper, les propriétés qui sont définies uniquement avec des méthodes getter aux champs réels de la table de base de données.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-183">When you use EF Core 1.0 or later, within the DbContext you need to map the properties that are defined only with getters to the actual fields in the database table.</span></span> <span data-ttu-id="2a4b3-184">Pour ce faire, utilisez la méthode HasField de la classe PropertyBuilder.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-184">This is done with the HasField method of the PropertyBuilder class.</span></span>

### <a name="map-fields-without-properties"></a><span data-ttu-id="2a4b3-185">Mapper des champs sans propriétés</span><span class="sxs-lookup"><span data-stu-id="2a4b3-185">Map fields without properties</span></span>

<span data-ttu-id="2a4b3-186">Avec la fonctionnalité dans EF Core 1.1 ou version ultérieure permettant de mapper des colonnes aux champs, il est également possible de ne pas utiliser de propriétés.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-186">With the feature in EF Core 1.1 or later to map columns to fields, it is also possible to not use properties.</span></span> <span data-ttu-id="2a4b3-187">Au lieu de cela, vous pouvez juste mapper des colonnes d’une table aux champs.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-187">Instead, you can just map columns from a table to fields.</span></span> <span data-ttu-id="2a4b3-188">Cette fonctionnalité est couramment utilisée dans le cadre des champs privés pour un état interne qui ne doit pas être accessible depuis l’extérieur de l’entité.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-188">A common use case for this is private fields for an internal state that does not need to be accessed from outside the entity.</span></span>

<span data-ttu-id="2a4b3-189">Par exemple, dans l’exemple de code OrderAggregate précédent, il existe plusieurs champs privés, tels que le champ `_paymentMethodId`, sans propriété associée pour une méthode setter ou un accesseur Get.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-189">For example, in the preceding OrderAggregate code example, there are several private fields, like the  `_paymentMethodId` field, that have no related property for either a setter or getter.</span></span> <span data-ttu-id="2a4b3-190">Ce champ peut également être calculé dans la logique métier de la commande et utilisé à partir des méthodes de la commande, mais il doit également être conservé dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-190">That field could also be calculated within the order's business logic and used from the order's methods, but it needs to be persisted in the database as well.</span></span> <span data-ttu-id="2a4b3-191">Ainsi, dans EF Core (depuis la version 1.1), il existe un moyen de mapper un champ sans une propriété associée à une colonne dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-191">So in EF Core (since v1.1) there is a way to map a field without a related property to a column in the database.</span></span> <span data-ttu-id="2a4b3-192">Cela est également expliqué dans la section [Couche d’infrastructure](ddd-oriented-microservice.md#the-infrastructure-layer) de ce guide.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-192">This is also explained in the [Infrastructure layer](ddd-oriented-microservice.md#the-infrastructure-layer) section of this guide.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="2a4b3-193">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="2a4b3-193">Additional resources</span></span>

- <span data-ttu-id="2a4b3-194">**Vaughn Vernon. Modélisation des agrégats avec DDD et Entity Framework.**</span><span class="sxs-lookup"><span data-stu-id="2a4b3-194">**Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework.**</span></span> <span data-ttu-id="2a4b3-195">Notez qu’il ne s’agit *pas* d’Entity Framework Core.</span><span class="sxs-lookup"><span data-stu-id="2a4b3-195">Note that this is *not* Entity Framework Core.</span></span> \
  <https://kalele.io/blog-posts/modeling-aggregates-with-ddd-and-entity-framework/>

- <span data-ttu-id="2a4b3-196">**Julie Lerman. Points de données-codage pour la conception pilotée par domaine : conseils pour les développeurs centrés sur les données** </span><span class="sxs-lookup"><span data-stu-id="2a4b3-196">**Julie Lerman. Data Points - Coding for Domain-Driven Design: Tips for Data-Focused Devs** </span></span>\
  <https://docs.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-domain-driven-design-tips-for-data-focused-devs>

- <span data-ttu-id="2a4b3-197">**UDI Dahan. Comment créer des modèles de domaine entièrement encapsulés** </span><span class="sxs-lookup"><span data-stu-id="2a4b3-197">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

> [!div class="step-by-step"]
> <span data-ttu-id="2a4b3-198">[Précédent](microservice-domain-model.md) 
>  [Suivant](seedwork-domain-model-base-classes-interfaces.md)</span><span class="sxs-lookup"><span data-stu-id="2a4b3-198">[Previous](microservice-domain-model.md)
[Next](seedwork-domain-model-base-classes-interfaces.md)</span></span>
