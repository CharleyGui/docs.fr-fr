---
title: Gestion d’une défaillance partielle
description: Découvrez comment gérer correctement les défaillances partielles. Un microservice peut ne pas être entièrement opérationnel, mais il peut toujours être en mesure d’effectuer un travail utile.
ms.date: 10/16/2018
ms.openlocfilehash: f00e5349df74b543deb6ac941c751cb130b3837c
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/07/2019
ms.locfileid: "73732969"
---
# <a name="handle-partial-failure"></a><span data-ttu-id="37995-104">Gérer une défaillance partielle</span><span class="sxs-lookup"><span data-stu-id="37995-104">Handle partial failure</span></span>

<span data-ttu-id="37995-105">Dans les systèmes distribués tels que les applications basées sur des microservices, le risque de défaillance partielle est omniprésent.</span><span class="sxs-lookup"><span data-stu-id="37995-105">In distributed systems like microservices-based applications, there's an ever-present risk of partial failure.</span></span> <span data-ttu-id="37995-106">Par exemple, un microservice ou un conteneur peut échouer ou ne pas être disponible pour répondre pendant un court instant, ou une machine virtuelle ou un serveur peut connaître un incident.</span><span class="sxs-lookup"><span data-stu-id="37995-106">For instance, a single microservice/container can fail or might not be available to respond for a short time, or a single VM or server can crash.</span></span> <span data-ttu-id="37995-107">Étant donné que les clients et les services sont des processus distincts, il peut arriver qu’un service ne puisse pas répondre à temps à une requête d’un client.</span><span class="sxs-lookup"><span data-stu-id="37995-107">Since clients and services are separate processes, a service might not be able to respond in a timely way to a client’s request.</span></span> <span data-ttu-id="37995-108">Le service peut être surchargé et répondre très lentement aux requêtes, ou simplement ne pas être accessible pendant un bref laps de temps à cause de problèmes réseau.</span><span class="sxs-lookup"><span data-stu-id="37995-108">The service might be overloaded and responding very slowly to requests or might simply not be accessible for a short time because of network issues.</span></span>

<span data-ttu-id="37995-109">Prenons la page des détails de commande dans l’exemple d’application eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="37995-109">For example, consider the Order details page from the eShopOnContainers sample application.</span></span> <span data-ttu-id="37995-110">Si le microservice Ordering ne répond pas quand l’utilisateur tente d’envoyer sa commande, une mauvaise implémentation du processus client (l’application web MVC) peut bloquer indéfiniment les threads en attente d’une réponse. C’est le cas, par exemple, si le code client est défini pour utiliser des RPC synchrones sans délai d’expiration.</span><span class="sxs-lookup"><span data-stu-id="37995-110">If the ordering microservice is unresponsive when the user tries to submit an order, a bad implementation of the client process (the MVC web application)—for example, if the client code were to use synchronous RPCs with no timeout—would block threads indefinitely waiting for a response.</span></span> <span data-ttu-id="37995-111">En plus de la mauvaise expérience que cela représente pour l’utilisateur, chaque attente de réponse consomme ou bloque un thread. Or, les applications hautement scalables ont besoin de beaucoup de threads.</span><span class="sxs-lookup"><span data-stu-id="37995-111">Besides creating a bad user experience, every unresponsive wait consumes or blocks a thread, and threads are extremely valuable in highly scalable applications.</span></span> <span data-ttu-id="37995-112">Si de nombreux threads sont bloqués, le runtime de l’application peut finir par ne plus disposer de suffisamment de threads.</span><span class="sxs-lookup"><span data-stu-id="37995-112">If there are many blocked threads, eventually the application’s runtime can run out of threads.</span></span> <span data-ttu-id="37995-113">Dans ce cas, l’application risque de ne plus répondre du tout au lieu de ne plus répondre juste partiellement, comme illustré à la Figure 8-1.</span><span class="sxs-lookup"><span data-stu-id="37995-113">In that case, the application can become globally unresponsive instead of just partially unresponsive, as shown in Figure 8-1.</span></span>

![Diagramme montrant les échecs partiels.](./media/handle-partial-failure/partial-failures-diagram.png)

<span data-ttu-id="37995-115">**Figure 8-1** :</span><span class="sxs-lookup"><span data-stu-id="37995-115">**Figure 8-1**.</span></span> <span data-ttu-id="37995-116">Défaillances partielles dues à des dépendances qui impactent la disponibilité des threads du service</span><span class="sxs-lookup"><span data-stu-id="37995-116">Partial failures because of dependencies that impact service thread availability</span></span>

<span data-ttu-id="37995-117">Dans une large application basée sur des microservices, une défaillance partielle peut avoir un impact plus global, surtout si la plupart des interactions de microservices internes sont basées sur des appels HTTP synchrones (ce qui est considéré comme anti-modèle).</span><span class="sxs-lookup"><span data-stu-id="37995-117">In a large microservices-based application, any partial failure can be amplified, especially if most of the internal microservices interaction is based on synchronous HTTP calls (which is considered an anti-pattern).</span></span> <span data-ttu-id="37995-118">Pensez à un système qui reçoit des millions d’appels par jour.</span><span class="sxs-lookup"><span data-stu-id="37995-118">Think about a system that receives millions of incoming calls per day.</span></span> <span data-ttu-id="37995-119">Si votre système a une mauvaise conception basée sur de longues chaînes d’appels HTTP synchrones, ces appels entrants peuvent provoquer des millions d’appels sortants supplémentaires (avec un ratio estimé de 1 pour 4) vers des dizaines de microservices internes et dépendances synchrones.</span><span class="sxs-lookup"><span data-stu-id="37995-119">If your system has a bad design that's based on long chains of synchronous HTTP calls, these incoming calls might result in many more millions of outgoing calls (let’s suppose a ratio of 1:4) to dozens of internal microservices as synchronous dependencies.</span></span> <span data-ttu-id="37995-120">Cette situation est illustrée dans la figure 8-2, en particulier dépendance \#3, qui démarre une chaîne, en appelant la dépendance #4.</span><span class="sxs-lookup"><span data-stu-id="37995-120">This situation is shown in Figure 8-2, especially dependency \#3, that starts a chain, calling dependency #4.</span></span> <span data-ttu-id="37995-121">que les appelle #5.</span><span class="sxs-lookup"><span data-stu-id="37995-121">which the calls #5.</span></span>

![Diagramme montrant plusieurs dépendances distribuées.](./media/handle-partial-failure/multiple-distributed-dependencies.png)

<span data-ttu-id="37995-123">**Figure 8-2** :</span><span class="sxs-lookup"><span data-stu-id="37995-123">**Figure 8-2**.</span></span> <span data-ttu-id="37995-124">Impact d’une mauvaise conception avec de longues chaînes de requêtes HTTP</span><span class="sxs-lookup"><span data-stu-id="37995-124">The impact of having an incorrect design featuring long chains of HTTP requests</span></span>

<span data-ttu-id="37995-125">Une défaillance intermittente est inévitable dans un système cloud et distribué, même si les dépendances présentent individuellement une haute disponibilité.</span><span class="sxs-lookup"><span data-stu-id="37995-125">Intermittent failure is guaranteed in a distributed and cloud-based system, even if every dependency itself has excellent availability.</span></span> <span data-ttu-id="37995-126">C’est un point important à prendre en compte.</span><span class="sxs-lookup"><span data-stu-id="37995-126">It's a fact you need to consider.</span></span>

<span data-ttu-id="37995-127">Si vous ne concevez pas et n’implémentez pas de techniques de tolérance de panne, même de courts temps d’arrêt peuvent avoir des répercussions amplifiées.</span><span class="sxs-lookup"><span data-stu-id="37995-127">If you do not design and implement techniques to ensure fault tolerance, even small downtimes can be amplified.</span></span> <span data-ttu-id="37995-128">Par exemple, l’existence de 50 dépendances avec 99,99 % de disponibilité se traduit par plusieurs heures d’arrêt chaque mois en raison de cet effet amplificateur.</span><span class="sxs-lookup"><span data-stu-id="37995-128">As an example, 50 dependencies each with 99.99% of availability would result in several hours of downtime each month because of this ripple effect.</span></span> <span data-ttu-id="37995-129">En cas d’échec d’une dépendance de microservice pendant le traitement d’un grand nombre de requêtes, cette défaillance peut rapidement saturer tous les threads de requête disponibles dans chaque service et entraîner le blocage de l’application entière.</span><span class="sxs-lookup"><span data-stu-id="37995-129">When a microservice dependency fails while handling a high volume of requests, that failure can quickly saturate all available request threads in each service and crash the whole application.</span></span>

![Diagramme montrant une défaillance partielle amplifiée dans les microservices.](./media/handle-partial-failure/partial-failure-amplified-microservices.png)

<span data-ttu-id="37995-131">**Figure 8-3** :</span><span class="sxs-lookup"><span data-stu-id="37995-131">**Figure 8-3**.</span></span> <span data-ttu-id="37995-132">Défaillance partielle amplifiée par les microservices avec de longues chaînes d’appels HTTP synchrones</span><span class="sxs-lookup"><span data-stu-id="37995-132">Partial failure amplified by microservices with long chains of synchronous HTTP calls</span></span>

<span data-ttu-id="37995-133">Pour limiter ce problème, la section « [L’intégration de microservices asynchrones implique l’autonomie des microservices](../architect-microservice-container-applications/communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) » de ce guide vous recommande d’utiliser une communication asynchrone entre les microservices internes.</span><span class="sxs-lookup"><span data-stu-id="37995-133">To minimize this problem, in the section [Asynchronous microservice integration enforce microservice’s autonomy](../architect-microservice-container-applications/communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy), this guide encourages you to use asynchronous communication across the internal microservices.</span></span>

<span data-ttu-id="37995-134">De plus, il est essentiel de concevoir vos microservices et applications clientes pour gérer les défaillances partielles, et ainsi les rendre résilients.</span><span class="sxs-lookup"><span data-stu-id="37995-134">In addition, it's essential that you design your microservices and client applications to handle partial failures—that is, to build resilient microservices and client applications.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="37995-135">[Précédent](index.md)
>[Suivant](partial-failure-strategies.md)</span><span class="sxs-lookup"><span data-stu-id="37995-135">[Previous](index.md)
[Next](partial-failure-strategies.md)</span></span>
