---
title: Services de streaming et champs répétés-gRPC pour les développeurs WCF
description: Comparez les champs répétés aux services de streaming pour passer des collections de données avec gRPC.
ms.date: 09/02/2019
ms.openlocfilehash: 46586ab08df6b136cdafb990ce8be75435a6bf6c
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337865"
---
# <a name="grpc-streaming-services-versus-repeated-fields"></a><span data-ttu-id="fb6b6-103">services de streaming gRPC et champs répétés</span><span class="sxs-lookup"><span data-stu-id="fb6b6-103">gRPC streaming services versus repeated fields</span></span>

<span data-ttu-id="fb6b6-104">les services gRPC offrent deux moyens de retourner des jeux de données ou des listes d’objets.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-104">gRPC services provide two ways of returning datasets, or lists of objects.</span></span> <span data-ttu-id="fb6b6-105">La spécification de message de mémoires tampons de protocole utilise le mot clé `repeated` pour déclarer des listes ou des tableaux de messages dans un autre message.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-105">The Protocol Buffers message specification uses the `repeated` keyword for declaring lists or arrays of messages within another message.</span></span> <span data-ttu-id="fb6b6-106">La spécification du service gRPC utilise le mot clé `stream` pour déclarer une connexion permanente longue sur laquelle plusieurs messages sont envoyés et peut être traitée individuellement.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-106">The gRPC service specification uses the `stream` keyword to declare a long-running persistent connection over which multiple messages are sent, and can be processed, individually.</span></span> <span data-ttu-id="fb6b6-107">La fonctionnalité `stream` peut également être utilisée pour des données temporelles de longue durée, telles que des notifications ou des messages de journal, mais ce chapitre prend en compte son utilisation pour retourner un jeu de données unique.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-107">The `stream` feature can also be used for long-running temporal data such as notifications or log messages, but this chapter will consider its use for returning a single dataset.</span></span>

<span data-ttu-id="fb6b6-108">Ce que vous devez utiliser dépend de divers facteurs, tels que la taille globale du jeu de données, le temps nécessaire pour créer le jeu de données à la fin du client ou du serveur, et si l’utilisateur du DataSet peut commencer à agir dessus dès que le premier élément est disponible , ou a besoin du jeu de données complet pour faire quelque chose d’utile.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-108">Which you should use depends on various factors, such as the overall size of the dataset, the time it took to create the dataset at either the client or server end, and whether the consumer of the dataset can start acting on it as soon as the first item is available, or needs the complete dataset to do anything useful.</span></span>

## <a name="when-to-use-repeated-fields"></a><span data-ttu-id="fb6b6-109">Quand utiliser les champs de `repeated`</span><span class="sxs-lookup"><span data-stu-id="fb6b6-109">When to use `repeated` fields</span></span>

<span data-ttu-id="fb6b6-110">Pour tout jeu de données limité en taille et pouvant être généré dans son intégralité dans un laps de temps donné (par exemple, sous une seconde), vous devez utiliser un champ `repeated` dans un message Protobuf normal.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-110">For any dataset that is constrained in size and that can be generated in its entirety in a short time—say, under one second—you should use a `repeated` field in a regular Protobuf message.</span></span> <span data-ttu-id="fb6b6-111">Par exemple, dans un système de commerce électronique, la création d’une liste d’éléments dans une commande est probablement rapide et la liste n’est pas très volumineuse.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-111">For example, in an e-commerce system, to build a list of items within an order is probably quick and the list won't be very large.</span></span> <span data-ttu-id="fb6b6-112">Le retour d’un seul message avec un champ `repeated` est un ordre de grandeur plus rapide que l’utilisation d’une `stream` et entraîne moins de surcharge du réseau.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-112">Returning a single message with a `repeated` field is an order of magnitude faster than using a `stream` and incurs less network overhead.</span></span>

<span data-ttu-id="fb6b6-113">Si le client a besoin de toutes les données avant de commencer à le traiter et que le jeu de données est suffisamment petit pour être construit en mémoire, envisagez d’utiliser un champ `repeated` même si la création réelle du jeu de données en mémoire sur le serveur est plus lente.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-113">If the client needs all the data before starting to process it and the dataset is small enough to construct in memory, then consider using a `repeated` field even if the actual creation of the dataset in memory on the server is slower.</span></span>

## <a name="when-to-use-stream-methods"></a><span data-ttu-id="fb6b6-114">Quand utiliser des méthodes `stream`</span><span class="sxs-lookup"><span data-stu-id="fb6b6-114">When to use `stream` methods</span></span>

<span data-ttu-id="fb6b6-115">Les jeux de données où les objets de message sont potentiellement très volumineux sont transférés le mieux à l’aide de demandes de streaming ou de réponses.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-115">Datasets where the message objects are potentially very large are best transferred using streaming requests or responses.</span></span> <span data-ttu-id="fb6b6-116">Il est plus efficace de construire un objet volumineux en mémoire, de l’écrire sur le réseau, puis de libérer les ressources.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-116">It's more efficient to construct a large object in memory, write it to the network and then free up the resources.</span></span> <span data-ttu-id="fb6b6-117">Cette approche permet d’améliorer l’évolutivité de votre service.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-117">This approach will improve the scalability of your service.</span></span>

<span data-ttu-id="fb6b6-118">De même, les jeux de données de taille non contrainte doivent être envoyés sur des flux pour éviter de manquer de mémoire lors de la construction de ces derniers.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-118">Similarly, datasets of unconstrained size should be sent over streams to avoid running out of memory while constructing them.</span></span>

<span data-ttu-id="fb6b6-119">Pour les jeux de données où chaque élément individuel peut être traité séparément par le consommateur, vous devez envisager d’utiliser un flux si cela signifie que la progression peut être indiquée à l’utilisateur final.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-119">For datasets where each individual item can be processed separately by the consumer, you should consider using a stream if it means that progress can be indicated to the end user.</span></span> <span data-ttu-id="fb6b6-120">Cela pourrait améliorer la réactivité apparente d’une application, même si elle doit être équilibrée par rapport aux performances globales de l’application.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-120">This could improve the apparent responsiveness of an application, although this should be balanced against the overall performance of the application.</span></span>

<span data-ttu-id="fb6b6-121">Un autre scénario dans lequel les flux peuvent être utiles est l’endroit où un message est traité sur plusieurs services.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-121">Another scenario where streams can be useful is where a message is being processed across multiple services.</span></span> <span data-ttu-id="fb6b6-122">Si chaque service d’une chaîne retourne un flux, le service Terminal (autrement dit, le dernier de la chaîne) peut commencer à retourner des messages qui peuvent être traités et retransmis le long de la chaîne au demandeur d’origine, qui peut soit retourner un flux, soit agréger le résultats dans un message de réponse unique.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-122">If each service in a chain returns a stream, then the terminal service (that is, the last one in the chain) can start returning messages that can be processed and passed back along the chain to the original requestor, which can either return a stream or aggregate the results into a single response message.</span></span> <span data-ttu-id="fb6b6-123">Cette approche se prête bien à des modèles tels que Map/Reduce.</span><span class="sxs-lookup"><span data-stu-id="fb6b6-123">This approach lends itself well to patterns like Map/Reduce.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="fb6b6-124">[Précédent](migrate-duplex-services.md)
>[Suivant](client-libraries.md)</span><span class="sxs-lookup"><span data-stu-id="fb6b6-124">[Previous](migrate-duplex-services.md)
[Next](client-libraries.md)</span></span>
