---
title: Étapes du workflow DevOps de la boucle externe pour une application Docker
description: Découvrez les étapes de la « boucle externe » du workflow DevOps
ms.date: 02/15/2019
ms.openlocfilehash: 44bd73bf88a743e5350e422d3ea000ca075f7383
ms.sourcegitcommit: 465547886a1224a5435c3ac349c805e39ce77706
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/21/2020
ms.locfileid: "82021297"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="001a8-103">Étapes du workflow DevOps de la boucle externe pour une application Docker</span><span class="sxs-lookup"><span data-stu-id="001a8-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="001a8-104">La Figure 5-1 décrit de bout en bout les étapes du workflow DevOps de la boucle externe.</span><span class="sxs-lookup"><span data-stu-id="001a8-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="001a8-105">Il montre la "boucle extérieure" de DevOps.</span><span class="sxs-lookup"><span data-stu-id="001a8-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="001a8-106">Quand du code est poussé (push) vers le dépôt, un pipeline d’intégration continue (CI) est démarré, puis il commence le pipeline de déploiement continu (CD), où l’application est déployée.</span><span class="sxs-lookup"><span data-stu-id="001a8-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="001a8-107">Les métriques collectées à partir d’applications déployées sont renvoyées à la charge de travail de développement, où la « boucle interne » se produit. Les équipes de développement disposent ainsi de données réelles pour répondre aux besoins des utilisateurs et des entreprises.</span><span class="sxs-lookup"><span data-stu-id="001a8-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![Diagramme montrant les 6 étapes du flux de travail de la boucle extérieure DevOps.](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="001a8-109">**Figure 5-1**.</span><span class="sxs-lookup"><span data-stu-id="001a8-109">**Figure 5-1**.</span></span> <span data-ttu-id="001a8-110">Workflow DevOps de la boucle externe pour les applications Docker avec des outils Microsoft</span><span class="sxs-lookup"><span data-stu-id="001a8-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="001a8-111">Maintenant, nous allons examiner chacune de ces étapes plus en détail.</span><span class="sxs-lookup"><span data-stu-id="001a8-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="001a8-112">Étape 1 : Flux de travail de développement en boucle intérieure</span><span class="sxs-lookup"><span data-stu-id="001a8-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="001a8-113">Cette étape est expliquée en détail au chapitre 4, mais, pour résumer, c’est là que commence la boucle externe, à savoir le moment auquel un développeur pousse (push) le code vers le système de gestion de contrôle de code source (comme Git), lançant ainsi les actions du pipeline CI.</span><span class="sxs-lookup"><span data-stu-id="001a8-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="001a8-114">Étape 2 : Intégration et gestion du contrôle des codes de la source avec Azure DevOps Services et Git</span><span class="sxs-lookup"><span data-stu-id="001a8-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="001a8-115">À cette étape, vous devez disposer d’un système de gestion de versions pour collecter une version consolidée de tout le code provenant des différents développeurs de l’équipe.</span><span class="sxs-lookup"><span data-stu-id="001a8-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="001a8-116">Même si le contrôle de code source (SCC, Source-Code Control) et la gestion de code source peuvent sembler naturels à la plupart des développeurs, quand vous créez des applications Docker dans un cycle de vie DevOps, gardez à l’esprit que vous ne devez pas pousser (push) les images Docker avec l’application directement vers le registre Docker global (comme Azure Container Registry ou Docker Hub) à partir de la machine du développeur.</span><span class="sxs-lookup"><span data-stu-id="001a8-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="001a8-117">Au contraire, les images Docker à publier et à déployer sur les environnements de production doivent uniquement être créées sur le code source en cours d’intégration à votre pipeline CI ou de build global en fonction de votre dépôt de code source (comme Git).</span><span class="sxs-lookup"><span data-stu-id="001a8-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="001a8-118">Les images locales, générées par les développeurs, doivent uniquement être utilisées par ces derniers lors des tests sur leurs propres machines.</span><span class="sxs-lookup"><span data-stu-id="001a8-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="001a8-119">C’est pourquoi il est essentiel que votre pipeline DevOps soit activé à partir du code SCC.</span><span class="sxs-lookup"><span data-stu-id="001a8-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="001a8-120">Azure DevOps Services et Team Foundation Server prennent en charge Git et Team Foundation Version Control.</span><span class="sxs-lookup"><span data-stu-id="001a8-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="001a8-121">Vous pouvez choisir l’un d’eux et l’utiliser pour une expérience Microsoft de bout en bout.</span><span class="sxs-lookup"><span data-stu-id="001a8-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="001a8-122">Cependant, vous pouvez également gérer votre code dans des dépôts externes (comme GitHub, sur place Git référentiels, ou Subversion) et toujours être en mesure de se connecter à elle et obtenir le code comme point de départ pour votre pipeline DevOps CI.</span><span class="sxs-lookup"><span data-stu-id="001a8-122">However, you can also manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="001a8-123">Étape 3 : Construire, CI, intégrer et tester avec Azure DevOps Services et Docker</span><span class="sxs-lookup"><span data-stu-id="001a8-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="001a8-124">L’intégration continue est devenue un standard pour le test et la livraison de logiciels modernes.</span><span class="sxs-lookup"><span data-stu-id="001a8-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="001a8-125">La solution Docker maintient une séparation claire des responsabilités entre les équipes de développement et des opérations.</span><span class="sxs-lookup"><span data-stu-id="001a8-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="001a8-126">L’immuabilité des images Docker garantit un déploiement reproductible entre ce qui a été développé, testé par le biais de l’intégration continue et exécuté en production.</span><span class="sxs-lookup"><span data-stu-id="001a8-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="001a8-127">Le moteur Docker déployé sur les ordinateurs portables des développeurs et l’infrastructure de test rend les conteneurs portables entre les environnements.</span><span class="sxs-lookup"><span data-stu-id="001a8-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="001a8-128">À ce stade, une fois que vous disposez d’un système de gestion de versions avec le bon code, vous avez besoin d’un *service de build* pour récupérer le code et exécuter la build et les tests globaux.</span><span class="sxs-lookup"><span data-stu-id="001a8-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="001a8-129">Le workflow interne de cette étape (CI, build, test) concerne la construction d’un pipeline CI constitué de votre dépôt de code (Git, etc.), de votre serveur de builds (Azure DevOps Services), du moteur Docker et d’un registre Docker.</span><span class="sxs-lookup"><span data-stu-id="001a8-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="001a8-130">Vous pouvez vous appuyer sur Azure DevOps Services pour générer vos applications et définir votre pipeline CI ainsi que pour publier les « artefacts » générés sur un « dépôt d’artefacts », comme l’explique la prochaine étape.</span><span class="sxs-lookup"><span data-stu-id="001a8-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="001a8-131">Quand vous utilisez Docker pour le déploiement, les « artefacts finaux » à déployer sont des images Docker comportant vos application ou services.</span><span class="sxs-lookup"><span data-stu-id="001a8-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="001a8-132">Ces images sont poussées vers, ou publiées sur, un *registre Docker* (un dépôt privé comme ceux que vous pouvez avoir dans Azure Container Registry ou un dépôt public tel que le registre Docker Hub, qui est couramment utilisé pour les images de base officielles).</span><span class="sxs-lookup"><span data-stu-id="001a8-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="001a8-133">Voici le concept de base : le pipeline CI sera lancé par un engagement à un référentiel SCC comme Git.</span><span class="sxs-lookup"><span data-stu-id="001a8-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="001a8-134">Le commit amène Azure DevOps Services à exécuter une tâche de build dans un conteneur Docker et, si cette tâche réussit, à pousser (push) une image Docker vers le registre Docker, comme illustré dans la Figure 5-2.</span><span class="sxs-lookup"><span data-stu-id="001a8-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="001a8-135">La première partie de la boucle extérieure implique des étapes 1 à 3, à partir du code, exécuter, déboguer et valider, puis le code répo jusqu’à l’étape CI de construction et de test.</span><span class="sxs-lookup"><span data-stu-id="001a8-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![Diagramme montrant les trois étapes impliquées dans le flux de travail de CI.](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="001a8-137">**Figure 5-2**.</span><span class="sxs-lookup"><span data-stu-id="001a8-137">**Figure 5-2**.</span></span> <span data-ttu-id="001a8-138">Étapes impliquées dans l’intégration continue</span><span class="sxs-lookup"><span data-stu-id="001a8-138">The steps involved in CI</span></span>

<span data-ttu-id="001a8-139">Voici les étapes du workflow CI avec Docker et Azure DevOps Services :</span><span class="sxs-lookup"><span data-stu-id="001a8-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="001a8-140">Le développeur pousse (push) un commit à un dépôt SCC (Git/Azure DevOps Services, GitHub, etc.).</span><span class="sxs-lookup"><span data-stu-id="001a8-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="001a8-141">Si vous utilisez Azure DevOps Services ou Git, l’intégration continue est intégrée ; vous avez uniquement besoin de cocher une case dans Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="001a8-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="001a8-142">Si vous utilisez un contrôle de code source externe (comme GitHub), un `webhook` avertit Azure DevOps Services de la mise à jour ou de la poussée (push) vers Git/GitHub.</span><span class="sxs-lookup"><span data-stu-id="001a8-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="001a8-143">Azure DevOps Services tire (pull) le dépôt SCC, notamment le fichier Dockerfile décrivant l’image ainsi que le code d’application et de test.</span><span class="sxs-lookup"><span data-stu-id="001a8-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="001a8-144">Azure DevOps Services génère une image Docker et l’étiquette avec un numéro de build.</span><span class="sxs-lookup"><span data-stu-id="001a8-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="001a8-145">Azure DevOps Services instancie le conteneur Docker dans l’hôte Docker provisionné et exécute les tests appropriés.</span><span class="sxs-lookup"><span data-stu-id="001a8-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="001a8-146">Si les tests réussissent, l’image est réétiquetée avec un nom significatif afin que vous sachiez qu’il s’agit d’une « build consacrée » (comme « /1.0.0 » ou n’importe quelle autre étiquette), puis poussée vers votre registre Docker (Docker Hub, Azure Container Registry, DTR, etc.).</span><span class="sxs-lookup"><span data-stu-id="001a8-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="001a8-147">Mise en œuvre du pipeline CI avec Azure DevOps Services et l’extension Docker pour Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="001a8-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="001a8-148">Visual Studio Azure DevOps Services contient des modèles de build et de mise en production que vous pouvez utiliser dans votre pipeline CI/CD, pour générer des images Docker, pousser (push) des images Docker vers un registre Docker authentifié, exécuter des images Docker ou exécuter d’autres opérations disponibles depuis l’interface CLI de Docker.</span><span class="sxs-lookup"><span data-stu-id="001a8-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="001a8-149">Il ajoute également une tâche Docker Compose que vous pouvez utiliser pour générer, pousser et exécuter des applications Docker multiconteneurs ou exécuter d’autres opérations disponibles depuis l’interface CLI de Docker Compose, comme illustré dans la Figure 5-3.</span><span class="sxs-lookup"><span data-stu-id="001a8-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Capture d’écran du pipeline Docker CI à Azure DevOps.](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="001a8-151">**Figure 5-3**.</span><span class="sxs-lookup"><span data-stu-id="001a8-151">**Figure 5-3**.</span></span> <span data-ttu-id="001a8-152">Pipeline d’intégration continue Docker dans Azure DevOps Services incluant les modèles de build et de mise en production et les tâches associées.</span><span class="sxs-lookup"><span data-stu-id="001a8-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="001a8-153">Vous pouvez utiliser ces modèles et tâches pour construire les artefacts CI/CD à générer, tester et déployer dans Azure Service Fabric, Azure Kubernetes Service et des offres similaires.</span><span class="sxs-lookup"><span data-stu-id="001a8-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="001a8-154">Avec ces tâches Visual Studio Team Services, une machine virtuelle ou un hôte Linux-Docker de build provisionné dans Azure et le registre Docker de votre choix (Azure Container Registry, Docker Hub, DTR Docker privé ou tout autre registre Docker), vous pouvez assembler votre pipeline CI Docker de façon très cohérente.</span><span class="sxs-lookup"><span data-stu-id="001a8-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="001a8-155">***Conditions requises :***</span><span class="sxs-lookup"><span data-stu-id="001a8-155">***Requirements:***</span></span>

- <span data-ttu-id="001a8-156">Azure DevOps Services ou, pour les installations locales, Team Foundation Server 2015 Update 3 ou version ultérieure</span><span class="sxs-lookup"><span data-stu-id="001a8-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="001a8-157">Un agent Azure DevOps Services ayant les binaires Docker</span><span class="sxs-lookup"><span data-stu-id="001a8-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="001a8-158">Un moyen facile de créer un de ces agents consiste à utiliser Docker pour exécuter un conteneur basé sur l’image Docker de l’agent Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="001a8-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [!INFORMATIONS]<span data-ttu-id="001a8-159"> Pour en savoir plus sur l’assemblage d’un pipeline CI Docker Azure DevOps Services et voir les procédures pas à pas, consultez ces sites :</span><span class="sxs-lookup"><span data-stu-id="001a8-159"> To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="001a8-160">Exécution d’un agent Visual Studio Team Services (maintenant Azure DevOps Services) en tant que conteneur Docker : </span><span class="sxs-lookup"><span data-stu-id="001a8-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="001a8-161">Génération d’images Docker Linux .NET Core avec Azure DevOps Services : </span><span class="sxs-lookup"><span data-stu-id="001a8-161">Building .NET Core Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="001a8-162">Génération d’une machine de build Visual Studio Team Services basée sur Linux avec prise en charge de Docker : </span><span class="sxs-lookup"><span data-stu-id="001a8-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="001a8-163">Intégrer, tester et valider des applications Docker multiconteneurs</span><span class="sxs-lookup"><span data-stu-id="001a8-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="001a8-164">En règle générale, la plupart des applications Docker sont composées de plusieurs conteneurs plutôt que d’un seul.</span><span class="sxs-lookup"><span data-stu-id="001a8-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="001a8-165">Un bon exemple est une application orientée microservices pour laquelle vous auriez un conteneur par microservice.</span><span class="sxs-lookup"><span data-stu-id="001a8-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="001a8-166">Toutefois, même sans suivre strictement les modèles d’approche des microservices, il est probable que votre application Docker soit composée de plusieurs conteneurs ou services.</span><span class="sxs-lookup"><span data-stu-id="001a8-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="001a8-167">Ainsi, après avoir généré les conteneurs de l’application dans le pipeline CI, vous devez également déployer, intégrer et tester l’application dans son ensemble avec tous ses conteneurs au sein d’un hôte Docker d’intégration ou même dans un cluster de test auquel vos conteneurs sont distribués.</span><span class="sxs-lookup"><span data-stu-id="001a8-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="001a8-168">Si vous utilisez un seul hôte, vous pouvez recourir à des commandes Docker telles que docker-compose pour générer et déployer des conteneurs associés afin de tester et valider l’environnement Docker dans une seule machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="001a8-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="001a8-169">Toutefois, si vous utilisez un cluster orchestrateur tel que DC/OS, Kubernetes ou Docker Swarm, vous devez déployer vos conteneurs par le biais d’un mécanisme ou orchestrateur différent, en fonction du cluster/planificateur sélectionné.</span><span class="sxs-lookup"><span data-stu-id="001a8-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="001a8-170">Voici plusieurs types de tests que vous pouvez exécuter contre des conteneurs Docker :</span><span class="sxs-lookup"><span data-stu-id="001a8-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="001a8-171">Tests unitaires pour conteneurs Docker</span><span class="sxs-lookup"><span data-stu-id="001a8-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="001a8-172">Test de groupes d’applications ou de microservices liés entre eux</span><span class="sxs-lookup"><span data-stu-id="001a8-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="001a8-173">Test dans les versions de production et de contrôle de validité</span><span class="sxs-lookup"><span data-stu-id="001a8-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="001a8-174">Le point important est que quand vous exécutez des tests d’intégration et fonctionnels, vous devez le faire en dehors des conteneurs.</span><span class="sxs-lookup"><span data-stu-id="001a8-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="001a8-175">Les tests ne sont pas contenus ou exécutés dans les conteneurs que vous déployez, car les conteneurs sont basés sur des images statiques qui doivent être des répliques exactes de celles que vous allez déployer en production.</span><span class="sxs-lookup"><span data-stu-id="001a8-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="001a8-176">Lors du test de scénarios plus avancés, tels que l’inclusion de plusieurs clusters (cluster de test, cluster de préproduction et cluster de production), une option pratique consiste à publier les images sur un registre afin de pouvoir opérer le test dans différents clusters.</span><span class="sxs-lookup"><span data-stu-id="001a8-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="001a8-177">Pousser l’image Docker d’application personnalisée à votre registre Docker global</span><span class="sxs-lookup"><span data-stu-id="001a8-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="001a8-178">Une fois les images Docker testées et validées, vous pouvez les étiqueter et les publier sur votre registre Docker.</span><span class="sxs-lookup"><span data-stu-id="001a8-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="001a8-179">Le registre Docker est un élément essentiel du cycle de vie des applications Docker, car c’est l’emplacement central où vous stockez votre test personnalisé (également appelé « images consacrées ») en vue de son déploiement sur des environnements d’assurance qualité et de production.</span><span class="sxs-lookup"><span data-stu-id="001a8-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="001a8-180">De la même manière que le code d’application stocké dans votre dépôt SCC (Git, etc.) est votre « source de vérité », le registre Docker est la « source de vérité » pour vos bits ou application binaire à déployer sur les environnements de production ou d’assurance qualité.</span><span class="sxs-lookup"><span data-stu-id="001a8-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="001a8-181">En règle générale, vous souhaiterez peut-être que les dépôts privés de vos images personnalisées se trouvent dans un dépôt privé au sein d’Azure Container Registry ou d’un registre local comme Docker Trusted Registry ou dans un registre cloud public avec accès restreint (tel que Docker Hub), bien que dans ce dernier cas vous deviez approuver la sécurité du fournisseur si votre code n’est pas open source.</span><span class="sxs-lookup"><span data-stu-id="001a8-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="001a8-182">Dans les deux cas, la méthode que vous utilisez est similaire et est basée sur la commande `docker push`, comme indiqué dans la Figure 5-4.</span><span class="sxs-lookup"><span data-stu-id="001a8-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![Diagramme montrant la poussée des images personnalisées à un registre de conteneurs.](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="001a8-184">**Figure 5-4**.</span><span class="sxs-lookup"><span data-stu-id="001a8-184">**Figure 5-4**.</span></span> <span data-ttu-id="001a8-185">Publication des images personnalisées sur un registre Docker</span><span class="sxs-lookup"><span data-stu-id="001a8-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="001a8-186">À l’étape 3, pour la génération, l’intégration et les tests (CI), vous pouvez publier les images Docker résultantes sur un registre privé ou public.</span><span class="sxs-lookup"><span data-stu-id="001a8-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="001a8-187">Les fournisseurs de cloud proposent diverses offres de registres Docker telles qu’Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry et Quay Registry.</span><span class="sxs-lookup"><span data-stu-id="001a8-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="001a8-188">À l’aide des tâches Docker, vous pouvez pousser un ensemble d’images de service définies par un fichier `docker-compose.yml`, avec plusieurs étiquettes, à un registre Docker authentifié (tel qu’Azure Container Registry), comme illustré dans la Figure 5-5.</span><span class="sxs-lookup"><span data-stu-id="001a8-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Capture d’écran montrant l’étape pour publier des images à un registre.](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="001a8-190">**Figure 5-5**.</span><span class="sxs-lookup"><span data-stu-id="001a8-190">**Figure 5-5**.</span></span> <span data-ttu-id="001a8-191">Utilisation d’Azure DevOps Services pour publier des images personnalisées sur un registre Docker</span><span class="sxs-lookup"><span data-stu-id="001a8-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [!INFORMATIONS]<span data-ttu-id="001a8-192"> Pour plus d’informations sur Azure Container Registry, consultez <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="001a8-192"> For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="001a8-193">Étape 4 : CD, Déploiement</span><span class="sxs-lookup"><span data-stu-id="001a8-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="001a8-194">L’immuabilité des images Docker garantit un déploiement reproductible avec ce qui a été développé, testé par le biais de l’intégration continue et exécuté en production.</span><span class="sxs-lookup"><span data-stu-id="001a8-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="001a8-195">Une fois les images Docker d’application publiées sur votre registre Docker (privé ou public), vous pouvez les déployer sur les différents environnements dont vous disposez (production, assurance qualité, préproduction, etc.) à partir de votre pipeline CD en utilisant Azure DevOps Services Release Management ou des tâches de pipeline Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="001a8-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="001a8-196">Toutefois, à ce stade, la nature du déploiement dépend du type d’application Docker à déployer.</span><span class="sxs-lookup"><span data-stu-id="001a8-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="001a8-197">Le déploiement d’une application simple (du point de vue de la composition et du déploiement), telle qu’une application monolithique comprenant quelques conteneurs ou services, sur quelques serveurs ou machines virtuelles diffère du déploiement d’une application plus complexe, telle qu’une application orientée microservices dotée de fonctionnalités d’hyperscale.</span><span class="sxs-lookup"><span data-stu-id="001a8-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="001a8-198">Ces deux scénarios sont expliqués dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="001a8-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="001a8-199">Déploiement d’applications Docker composées sur plusieurs environnements Docker</span><span class="sxs-lookup"><span data-stu-id="001a8-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="001a8-200">Examinons d’abord le scénario moins complexe : déploiement sur des hôtes Docker simples (machines virtuelles ou serveurs) dans un seul environnement ou dans plusieurs environnements (assurance qualité, préproduction et production).</span><span class="sxs-lookup"><span data-stu-id="001a8-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="001a8-201">Dans ce scénario, en interne, votre pipeline CD peut utiliser docker-compose (à partir de vos tâches de déploiement Azure DevOps Services) pour déployer les applications Docker avec l’ensemble de conteneurs ou de services connexe, comme illustré dans la Figure 5-6.</span><span class="sxs-lookup"><span data-stu-id="001a8-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![Diagramme montrant le CD déployer l’étape de déploiement à trois environnements.](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="001a8-203">**Figure 5-6**.</span><span class="sxs-lookup"><span data-stu-id="001a8-203">**Figure 5-6**.</span></span> <span data-ttu-id="001a8-204">Déploiement de conteneurs d’application sur un registre d’environnements hôtes Docker simple</span><span class="sxs-lookup"><span data-stu-id="001a8-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="001a8-205">La figure 5-7 met en évidence la façon dont vous pouvez connecter l’intégration continue de la build aux environnements de test et d’assurance qualité via Azure DevOps Services en cliquant sur Docker Compose dans la boîte de dialogue Ajouter des tâches.</span><span class="sxs-lookup"><span data-stu-id="001a8-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="001a8-206">Toutefois, quand vous effectuez un déploiement sur des environnements de préproduction ou de production, vous utilisez généralement des fonctionnalités Release Management gérant plusieurs environnements (assurance qualité, préproduction et production, par exemple).</span><span class="sxs-lookup"><span data-stu-id="001a8-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="001a8-207">Si vous effectuez un déploiement sur des hôtes Docker uniques, vous recourez à la tâche « Docker Compose » d’Azure DevOps Services (qui, en coulisses, appelle la commande `docker-compose up`).</span><span class="sxs-lookup"><span data-stu-id="001a8-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="001a8-208">Si vous effectuez un déploiement sur Azure Kubernetes Service (AKS), c’est la tâche Déployer sur Kubernetes qui est utilisée, comme expliqué dans la section qui suit.</span><span class="sxs-lookup"><span data-stu-id="001a8-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Capture d’écran montrant Add tâches dialogue de la tâche Docker Compose.](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="001a8-210">**Figure 5-7**.</span><span class="sxs-lookup"><span data-stu-id="001a8-210">**Figure 5-7**.</span></span> <span data-ttu-id="001a8-211">Ajout d’une tâche Docker Compose dans un pipeline Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="001a8-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="001a8-212">Quand vous créez une mise en production dans Azure DevOps Services, elle prend un ensemble d’artefacts d’entrée.</span><span class="sxs-lookup"><span data-stu-id="001a8-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="001a8-213">Ces artefacts sont destinés à être immuables pour la durée de vie de la mise en production, dans tous les environnements.</span><span class="sxs-lookup"><span data-stu-id="001a8-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="001a8-214">Quand vous introduisez des conteneurs, les artefacts d’entrée identifient les images dans un registre à déployer.</span><span class="sxs-lookup"><span data-stu-id="001a8-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="001a8-215">Suivant la manière dont ces images sont identifiées, il n’est pas garanti qu’elles restent les mêmes pendant toute la durée de la mise en production, en particulier si vous référencez `myimage:latest` à partir d’un fichier `docker-compose`.</span><span class="sxs-lookup"><span data-stu-id="001a8-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="001a8-216">Les modèles Azure DevOps Services vous donnent la possibilité de générer des artefacts de build contenant des condensats d’image de registre spécifiques qui identifient de manière unique le même binaire d’image.</span><span class="sxs-lookup"><span data-stu-id="001a8-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="001a8-217">Ce sont ceux-là qu’il convient d’utiliser comme entrée pour une mise en production.</span><span class="sxs-lookup"><span data-stu-id="001a8-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="001a8-218">Gestion des mises en production dans les environnements Docker à l’aide d’Azure DevOps Services Release Management</span><span class="sxs-lookup"><span data-stu-id="001a8-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="001a8-219">À l’aide des modèles Azure DevOps Services, vous pouvez générer une nouvelle image, la publier sur un registre Docker, l’exécuter sur des hôtes Linux ou Windows et utiliser des commandes telles que `docker-compose` pour déployer plusieurs conteneurs sous la forme d’une application entière, le tout grâce aux fonctionnalités Azure DevOps Services Release Management destinées à plusieurs environnements, comme illustré dans la Figure 5-8.</span><span class="sxs-lookup"><span data-stu-id="001a8-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Capture d’écran montrant la configuration des versions Docker composer.](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="001a8-221">**Figure 5-8**.</span><span class="sxs-lookup"><span data-stu-id="001a8-221">**Figure 5-8**.</span></span> <span data-ttu-id="001a8-222">Configuration de tâches Docker Compose Azure DevOps Services à partir d’Azure DevOps Services Release Management</span><span class="sxs-lookup"><span data-stu-id="001a8-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="001a8-223">Toutefois, gardez à l’esprit que le scénario illustré dans la Figure 5-6 et implémenté dans la Figure 5-8 est un scénario simple (déploiement sur des machines virtuelles et hôtes Docker uniques, à raison d’un conteneur ou instance par image) et qui ne doit probablement être utilisé que dans le cadre d’un développement ou de tests.</span><span class="sxs-lookup"><span data-stu-id="001a8-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="001a8-224">Dans la plupart des scénarios de production d’entreprise, vous souhaitez obtenir une haute disponibilité (HA) et une scalabilité facile à gérer en équilibrant la charge entre plusieurs nœuds, serveurs et machines virtuelles ainsi que des « basculements intelligents » afin que, si un serveur ou un nœud tombe en panne, ses services et conteneurs soient déplacés vers un autre serveur hôte ou machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="001a8-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="001a8-225">Dans ce cas, vous avez besoin de technologies plus avancées telles que les clusters de conteneurs, les orchestrateurs et les planificateurs.</span><span class="sxs-lookup"><span data-stu-id="001a8-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="001a8-226">Ainsi, la façon d’effectuer un déploiement sur ces clusters passe par la maîtrise des scénarios avancés expliqués dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="001a8-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="001a8-227">Déploiement d’applications Docker sur des clusters Docker</span><span class="sxs-lookup"><span data-stu-id="001a8-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="001a8-228">La nature des applications distribuées nécessite des ressources de calcul qui sont également distribuées.</span><span class="sxs-lookup"><span data-stu-id="001a8-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="001a8-229">Pour bénéficier de fonctionnalités de niveau production, vous devez disposer de fonctionnalités de clustering qui fournissent une haute scalabilité et une haute disponibilité basées sur le regroupement de ressources.</span><span class="sxs-lookup"><span data-stu-id="001a8-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="001a8-230">Vous pourriez déployer des conteneurs manuellement sur ces clusters à partir d’un outil CLI ou d’une interface utilisateur web, mais vous devez réserver ce genre de travail manuel à l’identification d’objectifs de gestion et de test de déploiement tels que la réalisation d’un scale-out ou d’une supervision.</span><span class="sxs-lookup"><span data-stu-id="001a8-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="001a8-231">Du point de vue du déploiement continu, et notamment d’Azure DevOps Services, vous pouvez exécuter à partir de vos environnements Azure DevOps Services Release Management des tâches de déploiement spécifiques destinées à déployer vos applications conteneurisées sur des clusters distribués dans Container Service, comme illustré dans la Figure 5-9.</span><span class="sxs-lookup"><span data-stu-id="001a8-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![Diagramme montrant le CD déployer l’étape de déploiement aux orchestrateurs.](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="001a8-233">**Figure 5-9**.</span><span class="sxs-lookup"><span data-stu-id="001a8-233">**Figure 5-9**.</span></span> <span data-ttu-id="001a8-234">Déploiement d’applications distribuées sur Container Service</span><span class="sxs-lookup"><span data-stu-id="001a8-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="001a8-235">Pour effectuer un déploiement sur certains clusters ou orchestrateurs, vous utilisez probablement des mécanismes et des scripts de déploiement spécifiques suivant chaque orchestrateur (en d’autres termes, Kubernetes et Service Fabric ont des mécanismes de déploiement différents) au lieu de l’outil convivial `docker-compose` basé sur le fichier de définition `docker-compose.yml`.</span><span class="sxs-lookup"><span data-stu-id="001a8-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="001a8-236">Cependant, grâce à la tâche Azure DevOps Services Docker Deploy, indiquée dans la figure 5-10, vous pouvez maintenant vous déployer aux orchestrateurs pris en charge en utilisant simplement votre fichier familier `docker-compose.yml` parce que l’outil effectue cette «traduction» pour vous (de votre `docker-compose.yml` fichier au format requis par l’orchestrateur).</span><span class="sxs-lookup"><span data-stu-id="001a8-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, now you can also deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that "translation" for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Capture d’écran montrant la tâche Deploy to Kubernetes.](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="001a8-238">**Figure 5-10**.</span><span class="sxs-lookup"><span data-stu-id="001a8-238">**Figure 5-10**.</span></span> <span data-ttu-id="001a8-239">Ajout de la tâche Déployer sur Kubernetes à votre environnement</span><span class="sxs-lookup"><span data-stu-id="001a8-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="001a8-240">La Figure 5-11 montre comment vous pouvez modifier la tâche Déployer sur Kubernetes avec les sections disponibles pour la configuration.</span><span class="sxs-lookup"><span data-stu-id="001a8-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="001a8-241">Cette tâche est chargée de récupérer vos images Docker personnalisées prêtes à l’emploi à déployer en tant que conteneurs dans le cluster.</span><span class="sxs-lookup"><span data-stu-id="001a8-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Capture d’écran montrant la configuration de tâche Deploy to Kubernetes.](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="001a8-243">**Figure 5-11**.</span><span class="sxs-lookup"><span data-stu-id="001a8-243">**Figure 5-11**.</span></span> <span data-ttu-id="001a8-244">Déploiement de la définition de la tâche Déployer sur Kubernetes sur ACS DC/OS</span><span class="sxs-lookup"><span data-stu-id="001a8-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> [!INFORMATIONS]<span data-ttu-id="001a8-245"> Pour en savoir plus sur le pipeline CD avec Azure DevOps Services et Docker, visitez <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="001a8-245"> To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="001a8-246">Étape 5 : Exécuter et gérer</span><span class="sxs-lookup"><span data-stu-id="001a8-246">Step 5: Run and manage</span></span>

<span data-ttu-id="001a8-247">Étant donné que l’exécution et la gestion des applications au niveau de la production en entreprise constituent en elles-mêmes un sujet majeur et en raison du type d’opérations et des personnes qui travaillent à ce niveau (opérations informatiques) ainsi que de la grande étendue de ce domaine, le chapitre suivant est consacré à leur explication.</span><span class="sxs-lookup"><span data-stu-id="001a8-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="001a8-248">Étape 6 : Surveiller et diagnostiquer</span><span class="sxs-lookup"><span data-stu-id="001a8-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="001a8-249">Ce sujet est également couvert dans le prochain chapitre dans le cadre des tâches effectuées par l’équipe informatique au sein des systèmes de production ; toutefois, il est important de souligner que les insights obtenus au cours de cette étape doivent parvenir à l’équipe de développement afin que l’application soit améliorée en permanence.</span><span class="sxs-lookup"><span data-stu-id="001a8-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="001a8-250">De ce point de vue, DevOps est également impliqué, bien que les tâches et les opérations soient couramment effectuées par l’équipe informatique.</span><span class="sxs-lookup"><span data-stu-id="001a8-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="001a8-251">Ce n’est que quand la supervision et les diagnostics relèvent en totalité du domaine de DevOps que les processus de supervision et l’analytique sont effectués par l’équipe de développement par rapport à des environnements de test ou bêta.</span><span class="sxs-lookup"><span data-stu-id="001a8-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="001a8-252">Ces opérations impliquent la réalisation de test de charge ou la supervision d’environnements bêta ou d’assurance qualité, où les bêta-testeurs essaient les nouvelles versions.</span><span class="sxs-lookup"><span data-stu-id="001a8-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="001a8-253">[Suivant précédent](index.md)
>[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="001a8-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
