---
title: Migrer WPF Apps à .NET Core 3.0
description: Apprenez à migrer une application de la Windows Presentation Foundation (WPF) vers .NET Core 3.0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/01/2020
ms.locfileid: "82071310"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="c8482-103">Migrer les applications WPF à .NET Core</span><span class="sxs-lookup"><span data-stu-id="c8482-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="c8482-104">Cet article couvre les étapes nécessaires pour migrer une application de la Fondation de présentation Windows (WPF) de .NET Framework à .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="c8482-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="c8482-105">Si vous n’avez pas d’application WPF à portée de main pour le port, mais que vous souhaitez essayer le processus, vous pouvez utiliser **l’application d’échantillon Bean Trader** disponible sur [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span><span class="sxs-lookup"><span data-stu-id="c8482-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="c8482-106">L’application originale (ciblant .NET Framework 4.7.2) est disponible dans le dossier NetFx-BeanTraderClient.</span><span class="sxs-lookup"><span data-stu-id="c8482-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="c8482-107">Tout d’abord, nous allons expliquer les étapes nécessaires pour les applications portuaires en général, puis nous allons marcher à travers les modifications spécifiques qui s’appliquent à **l’échantillon Bean Trader.**</span><span class="sxs-lookup"><span data-stu-id="c8482-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="c8482-108">Pour migrer vers .NET Core, vous devez d’abord :</span><span class="sxs-lookup"><span data-stu-id="c8482-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="c8482-109">Comprendre et mettre à jour les dépendances de NuGet :</span><span class="sxs-lookup"><span data-stu-id="c8482-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="c8482-110">Améliorer les dépendances NuGet `<PackageReference>` pour utiliser le format.</span><span class="sxs-lookup"><span data-stu-id="c8482-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="c8482-111">Examinez les dépendances NuGet de haut niveau pour la compatibilité .NET Core ou .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="c8482-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="c8482-112">Mettre à niveau les forfaits NuGet vers de nouvelles versions.</span><span class="sxs-lookup"><span data-stu-id="c8482-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="c8482-113">Utilisez [l’analyseur de portabilité .NET](../../standard/analyzers/portability-analyzer.md) pour comprendre les dépendances .NET.</span><span class="sxs-lookup"><span data-stu-id="c8482-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="c8482-114">Migrez le fichier du projet vers le nouveau format de style SDK :</span><span class="sxs-lookup"><span data-stu-id="c8482-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="c8482-115">Choisissez de cibler à la fois .NET Core et .NET Framework, ou seulement .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="c8482-116">Copiez les propriétés et les éléments pertinents du fichier de projet au nouveau fichier de projet.</span><span class="sxs-lookup"><span data-stu-id="c8482-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="c8482-117">Résoudre les problèmes de construction :</span><span class="sxs-lookup"><span data-stu-id="c8482-117">Fix build issues:</span></span>

    01. <span data-ttu-id="c8482-118">Ajoutez une référence au package [Microsoft.Windows.Compatibility.](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/)</span><span class="sxs-lookup"><span data-stu-id="c8482-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="c8482-119">Trouver et corriger les différences au niveau de l’API.</span><span class="sxs-lookup"><span data-stu-id="c8482-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="c8482-120">Supprimer les sections *app.config* autres que `appSettings` ou `connectionStrings`.</span><span class="sxs-lookup"><span data-stu-id="c8482-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="c8482-121">Régénérer le code généré, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c8482-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="c8482-122">Test de temps d’exécution :</span><span class="sxs-lookup"><span data-stu-id="c8482-122">Runtime testing:</span></span>

    01. <span data-ttu-id="c8482-123">Confirmez que l’application porte comme prévu.</span><span class="sxs-lookup"><span data-stu-id="c8482-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="c8482-124">Méfiez-vous des <xref:System.NotSupportedException> exceptions.</span><span class="sxs-lookup"><span data-stu-id="c8482-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="c8482-125">À propos de l’exemple</span><span class="sxs-lookup"><span data-stu-id="c8482-125">About the sample</span></span>

<span data-ttu-id="c8482-126">Cet article fait référence à [l’application d’échantillon Bean Trader](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) parce qu’elle utilise une variété de dépendances similaires à celles que les applications WPF du monde réel pourraient avoir.</span><span class="sxs-lookup"><span data-stu-id="c8482-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="c8482-127">L’application n’est pas grande, mais est censé être un pas en avant de «Hello World» en termes de complexité.</span><span class="sxs-lookup"><span data-stu-id="c8482-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="c8482-128">L’application démontre certains problèmes que les utilisateurs peuvent rencontrer tout en transférant de vraies applications.</span><span class="sxs-lookup"><span data-stu-id="c8482-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="c8482-129">L’application communique avec un service WCF, donc pour qu’il s’exécute correctement, vous aurez également besoin d’exécuter le projet BeanTraderServer (disponible dans le même référentiel GitHub) et assurez-vous que la configuration BeanTraderClient points au point de terminaison correct.</span><span class="sxs-lookup"><span data-stu-id="c8482-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="c8482-130">(Par défaut, l’échantillon suppose que le serveur *http://localhost:8090*fonctionne sur la même machine à , ce qui sera vrai si vous lancez BeanTraderServer localement.)</span><span class="sxs-lookup"><span data-stu-id="c8482-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="c8482-131">Gardez à l’esprit que cette application d’échantillon est destinée à démontrer les défis et les solutions de portage .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="c8482-132">Il n’est pas destiné à démontrer les meilleures pratiques WPF.</span><span class="sxs-lookup"><span data-stu-id="c8482-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="c8482-133">En fait, il comprend délibérément quelques anti-modèles pour s’assurer que vous rencontrez au moins un couple de défis intéressants tout en portant.</span><span class="sxs-lookup"><span data-stu-id="c8482-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="c8482-134">Préparation</span><span class="sxs-lookup"><span data-stu-id="c8482-134">Getting ready</span></span>

<span data-ttu-id="c8482-135">Le principal défi de la migration d’une application cadre .NET à .NET Core est que ses dépendances peuvent fonctionner différemment ou pas du tout.</span><span class="sxs-lookup"><span data-stu-id="c8482-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="c8482-136">La migration est beaucoup plus facile qu’elle ne l’était; de nombreux paquets NuGet ciblent désormais .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="c8482-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="c8482-137">À partir de .NET Core 2.0, le cadre .NET et les surfaces de base .NET sont devenus similaires.</span><span class="sxs-lookup"><span data-stu-id="c8482-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="c8482-138">Malgré cela, certaines différences (à la fois dans le soutien des paquets NuGet et dans les API .NET disponibles) restent.</span><span class="sxs-lookup"><span data-stu-id="c8482-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="c8482-139">La première étape dans la migration est de revoir les dépendances de l’application et de s’assurer que les références sont dans un format qui est facilement migré vers .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="c8482-140">Mise `<PackageReference>` à niveau vers les références NuGet</span><span class="sxs-lookup"><span data-stu-id="c8482-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="c8482-141">Les anciens projets cadre .NET énumèrent généralement leurs dépendances NuGet dans un fichier *packages.config.*</span><span class="sxs-lookup"><span data-stu-id="c8482-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="c8482-142">Le nouveau format de fichier de projet de [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) style SDK fait référence aux paquets NuGet comme éléments dans le fichier csproj lui-même plutôt que dans un fichier config distinct.</span><span class="sxs-lookup"><span data-stu-id="c8482-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="c8482-143">Lors de la migration, il ya `<PackageReference>`deux avantages à l’aide de références de style:</span><span class="sxs-lookup"><span data-stu-id="c8482-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="c8482-144">C’est le style de référence NuGet qui est nécessaire pour le nouveau fichier de projet .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="c8482-145">Si vous utilisez `<PackageReference>`déjà, ces éléments de fichiers de projet peuvent être copiés et collés directement dans le nouveau projet.</span><span class="sxs-lookup"><span data-stu-id="c8482-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="c8482-146">Contrairement à un fichier `<PackageReference>` packages.config, les éléments ne se réfèrent qu’aux dépendances de haut niveau dont votre projet dépend directement.</span><span class="sxs-lookup"><span data-stu-id="c8482-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="c8482-147">Tous les autres paquets NuGet transitifs seront déterminés au moment de la restauration et enregistrés dans le fichier autogenerated obj-project.assets.json.</span><span class="sxs-lookup"><span data-stu-id="c8482-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="c8482-148">Il est donc beaucoup plus facile de déterminer les dépendances de votre projet, ce qui est utile pour déterminer si les dépendances nécessaires fonctionneront sur .NET Core ou non.</span><span class="sxs-lookup"><span data-stu-id="c8482-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="c8482-149">La première étape pour migrer une application cadre .NET à `<PackageReference>` .NET Core est de le mettre à jour pour utiliser des références NuGet.</span><span class="sxs-lookup"><span data-stu-id="c8482-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="c8482-150">Visual Studio rend cela simple.</span><span class="sxs-lookup"><span data-stu-id="c8482-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="c8482-151">Il suffit de cliquer à droite le fichier *packages.config* du projet dans Visual Studio **Solution Explorer**, puis sélectionnez **Paquets Migrate.config à PackageReference**.</span><span class="sxs-lookup"><span data-stu-id="c8482-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Mise à niveau vers PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="c8482-153">Un dialogue apparaît montrant les dépendances NuGet calculées de haut niveau et demandant quels autres paquets NuGet devraient être promus au plus haut niveau.</span><span class="sxs-lookup"><span data-stu-id="c8482-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="c8482-154">Aucun de ces autres paquets doivent être de haut niveau pour l’échantillon Bean Trader, de sorte que vous pouvez décocher toutes ces boîtes.</span><span class="sxs-lookup"><span data-stu-id="c8482-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="c8482-155">Ensuite, cliquez sur **Ok** et le fichier `<PackageReference>` *packages.config* est supprimé et des éléments sont ajoutés au fichier du projet.</span><span class="sxs-lookup"><span data-stu-id="c8482-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="c8482-156">`<PackageReference>`Les références de style ne stockent pas les paquets NuGet localement dans un dossier de paquets.</span><span class="sxs-lookup"><span data-stu-id="c8482-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="c8482-157">Au lieu de cela, ils sont stockés dans le monde entier comme une optimisation.</span><span class="sxs-lookup"><span data-stu-id="c8482-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="c8482-158">Après la migration se termine, modifier le fichier `<Analyzer>` csproj et supprimer tous les éléments se référant aux analyseurs qui provenaient auparavant de la *.. Répertoire de paquets.*</span><span class="sxs-lookup"><span data-stu-id="c8482-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="c8482-159">Ne vous inquiétez pas; puisque vous avez toujours les références de paquet NuGet, les analyseurs seront inclus dans le projet.</span><span class="sxs-lookup"><span data-stu-id="c8482-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="c8482-160">Vous avez juste besoin de nettoyer les `<Analyzer>` anciens paquets.config-modèle éléments.</span><span class="sxs-lookup"><span data-stu-id="c8482-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="c8482-161">Publier un avis sur les forfaits NuGet</span><span class="sxs-lookup"><span data-stu-id="c8482-161">Review NuGet packages</span></span>

<span data-ttu-id="c8482-162">Maintenant que vous pouvez voir les paquets NuGet de haut niveau dont dépend le projet, vous pouvez examiner si ces paquets sont disponibles sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="c8482-163">Vous pouvez déterminer si un paquet prend en charge .NET Core en examinant ses dépendances sur [nuget.org](https://www.nuget.org/). Le site [fuget.org](https://www.fuget.org/) créé par la communauté montre cette information en bonne place en haut de la page d’information sur les colis.</span><span class="sxs-lookup"><span data-stu-id="c8482-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="c8482-164">Lors du ciblage .NET Core 3.0, tous les paquets ciblant .NET Core ou .NET Standard doivent fonctionner (puisque .NET Core implémente la surface standard .NET).</span><span class="sxs-lookup"><span data-stu-id="c8482-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="c8482-165">Dans certains cas, la version spécifique d’un paquet utilisé ne ciblera pas .NET Core ou .NET Standard, mais les versions plus nouvelles le feront.</span><span class="sxs-lookup"><span data-stu-id="c8482-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="c8482-166">Dans ce cas, vous devriez envisager de passer à la dernière version du paquet.</span><span class="sxs-lookup"><span data-stu-id="c8482-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="c8482-167">Vous pouvez utiliser des paquets ciblant .NET Framework, ainsi, mais qui introduit un certain risque.</span><span class="sxs-lookup"><span data-stu-id="c8482-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="c8482-168">.NET Core to .NET Les dépendances du Cadre sont autorisées parce que les surfaces .NET Core et .NET Framework sont assez semblables pour que ces dépendances fonctionnent *souvent.*</span><span class="sxs-lookup"><span data-stu-id="c8482-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="c8482-169">Toutefois, si le paquet tente d’utiliser un API .NET qui n’est pas présent dans .NET Core, vous rencontrerez une exception de temps d’exécution.</span><span class="sxs-lookup"><span data-stu-id="c8482-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="c8482-170">Pour cette raison, vous ne devez référence .NET paquets cadre quand aucune autre option n’est disponible et de comprendre que cela impose un fardeau de test.</span><span class="sxs-lookup"><span data-stu-id="c8482-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="c8482-171">S’il existe des paquets référencés qui ne ciblent pas .NET Core ou .NET Standard, vous devrez penser à d’autres alternatives :</span><span class="sxs-lookup"><span data-stu-id="c8482-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="c8482-172">Y a-t-il d’autres paquets similaires qui peuvent être utilisés à la place?</span><span class="sxs-lookup"><span data-stu-id="c8482-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="c8482-173">Parfois, les auteurs de NuGet publient séparément '. Les versions de base de leurs bibliothèques ciblant spécifiquement .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="c8482-174">Les forfaits Bibliothèque d’entreprise sont un exemple de l’édition communautaire " . NetCore" alternatives.</span><span class="sxs-lookup"><span data-stu-id="c8482-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="c8482-175">Dans d’autres cas, de nouveaux SDK pour un service particulier (parfois avec des noms de forfaits différents) sont disponibles pour .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="c8482-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="c8482-176">Si aucune alternative n’est disponible, vous pouvez procéder à l’aide des paquets .NET Framework-targeted, en gardant à l’esprit que vous aurez besoin de les tester à fond une fois en cours d’exécution sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="c8482-177">L’échantillon Bean Trader a les dépendances NuGet de haut niveau suivantes :</span><span class="sxs-lookup"><span data-stu-id="c8482-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="c8482-178">**Castle.Windsor, version 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="c8482-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="c8482-179">Ce paquet cible .NET Standard 1.6, de sorte qu’il fonctionne sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="c8482-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="c8482-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="c8482-181">Il s’agit d’un méta-package, il n’est donc pas immédiatement évident quelles plates-formes il prend en charge, mais [la documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indique que sa version la plus récente (2.9.2) fonctionnera à la fois pour .NET Framework et .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="c8482-182">**Nito.AsyncEx, version 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="c8482-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="c8482-183">Ce paquet ne cible pas .NET Core, mais la version 5.0 la plus récente le fait.</span><span class="sxs-lookup"><span data-stu-id="c8482-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="c8482-184">Ceci est commun lors de la migration parce que de nombreux paquets NuGet ont ajouté .NET Standard support récemment, mais les versions plus anciennes du projet ne cibleront .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c8482-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="c8482-185">Si la différence de version n’est qu’une différence de version mineure, il est souvent facile de mettre à niveau vers la version plus récente.</span><span class="sxs-lookup"><span data-stu-id="c8482-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="c8482-186">Parce qu’il s’agit d’un changement de version majeur, vous devez être prudent mise à niveau car il pourrait y avoir des changements de rupture dans le paquet.</span><span class="sxs-lookup"><span data-stu-id="c8482-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="c8482-187">Il y a cependant une voie à suivre, ce qui est bien.</span><span class="sxs-lookup"><span data-stu-id="c8482-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="c8482-188">**MahApps.Metro, version 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="c8482-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="c8482-189">Ce paquet ne cible pas non plus .NET Core, mais a une nouvelle pré-version (2.0-alpha) qui le fait.</span><span class="sxs-lookup"><span data-stu-id="c8482-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="c8482-190">Encore une fois, vous devez faire attention aux changements de rupture, mais le nouveau paquet est encourageant.</span><span class="sxs-lookup"><span data-stu-id="c8482-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="c8482-191">Les dépendances NuGet de l’échantillon De Bean Trader sont toutes ciblées .NET Standard/.NET Core ou ont de nouvelles versions qui le font, il est donc peu probable qu’il y ait des problèmes de blocage ici.</span><span class="sxs-lookup"><span data-stu-id="c8482-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="c8482-192">Améliorer les forfaits NuGet</span><span class="sxs-lookup"><span data-stu-id="c8482-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="c8482-193">Si possible, il serait bon de mettre à niveau les versions de tous les paquets qui ciblent seulement .NET Core ou .NET Standard avec des versions plus récentes à ce stade (avec le projet toujours ciblant .NET Framework) pour découvrir et aborder tout changement de rupture au début.</span><span class="sxs-lookup"><span data-stu-id="c8482-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="c8482-194">Si vous préférez ne pas apporter de modifications matérielles à la version cadre .NET existante de l’application, cela peut attendre jusqu’à ce que vous ayez un nouveau fichier de projet ciblant .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="c8482-195">Cependant, la mise à niveau des paquets NuGet en versions compatibles .NET Core à l’avance rend le processus de migration encore plus facile une fois que vous créez le nouveau fichier de projet et réduit le nombre de différences entre le cadre .NET et les versions .NET Core de l’application.</span><span class="sxs-lookup"><span data-stu-id="c8482-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="c8482-196">Avec l’échantillon Bean Trader, toutes les mises à niveau nécessaires peuvent être effectuées facilement (en utilisant le gestionnaire de forfaits NuGet de Visual Studio) à une exception près : la mise à niveau de **MahApps.Metro 1.6.5** à **2.0** révèle des changements de rupture liés aux API de gestion des thèmes et des accents.</span><span class="sxs-lookup"><span data-stu-id="c8482-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="c8482-197">Idéalement, l’application serait mise à jour pour utiliser la nouvelle version du paquet (puisque c’est plus susceptible de fonctionner sur .NET Core).</span><span class="sxs-lookup"><span data-stu-id="c8482-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="c8482-198">Dans certains cas, cependant, cela peut ne pas être faisable.</span><span class="sxs-lookup"><span data-stu-id="c8482-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="c8482-199">Dans ces cas, ne pas mettre à niveau **MahApps.Metro** parce que les changements nécessaires sont non-trivial et ce tutoriel se concentre sur la migration vers .NET Core 3, pas à **MahApps.Metro 2.**</span><span class="sxs-lookup"><span data-stu-id="c8482-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="c8482-200">En outre, il s’agit d’une dépendance à faible risque .NET Framework parce que l’application Bean Trader exerce seulement une petite partie de **MahApps.Metro**.</span><span class="sxs-lookup"><span data-stu-id="c8482-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="c8482-201">Il faudra, bien sûr, des tests pour s’assurer que tout fonctionne une fois la migration terminée.</span><span class="sxs-lookup"><span data-stu-id="c8482-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="c8482-202">S’il s’agissait d’un scénario réel, il serait bon de déposer un problème pour suivre le travail de passer à **MahApps.Metro** version 2.0 puisque ne pas faire la migration laisse maintenant derrière lui une certaine dette technique.</span><span class="sxs-lookup"><span data-stu-id="c8482-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="c8482-203">Une fois que les paquets NuGet `<PackageReference>` sont mis à jour sur des versions récentes, le groupe d’éléments dans le fichier de projet de l’échantillon Bean Trader devrait ressembler à ceci.</span><span class="sxs-lookup"><span data-stu-id="c8482-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="c8482-204">.NET Analyse de la portabilité du Cadre</span><span class="sxs-lookup"><span data-stu-id="c8482-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="c8482-205">Une fois que vous comprenez l’état des dépendances NuGet de votre projet, la prochaine chose à considérer est .NET Framework API dépendances.</span><span class="sxs-lookup"><span data-stu-id="c8482-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="c8482-206">[L’outil .NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) est utile pour comprendre lequel des API .NET que votre projet utilise sont disponibles sur d’autres plates-formes .NET.</span><span class="sxs-lookup"><span data-stu-id="c8482-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="c8482-207">L’outil est livré comme un [plugin Visual Studio](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), un [outil de commande-ligne](https://github.com/Microsoft/dotnet-apiport/releases), ou enveloppé dans une [interface graphique simple](https://github.com/Microsoft/dotnet-apiport-ui), qui simplifie ses options.</span><span class="sxs-lookup"><span data-stu-id="c8482-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="c8482-208">Vous pouvez en savoir plus sur l’utilisation de l’analyseur de portabilité .NET (API Port) en utilisant l’interface utilisateur dans les [applications de bureau Porting pour .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span><span class="sxs-lookup"><span data-stu-id="c8482-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="c8482-209">Si vous préférez utiliser la ligne de commande, les étapes nécessaires sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="c8482-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="c8482-210">Téléchargez [l’analyseur de portabilité .NET](https://github.com/Microsoft/dotnet-apiport/releases) si vous ne l’avez pas déjà.</span><span class="sxs-lookup"><span data-stu-id="c8482-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="c8482-211">Assurez-vous que l’application cadre .NET à porter construit avec succès (c’est une bonne idée avant la migration indépendamment).</span><span class="sxs-lookup"><span data-stu-id="c8482-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="c8482-212">Exécuter API Port avec une ligne de commande comme celle-ci.</span><span class="sxs-lookup"><span data-stu-id="c8482-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="c8482-213">L’argument `-f` précise le chemin contenant les binaires à analyser.</span><span class="sxs-lookup"><span data-stu-id="c8482-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="c8482-214">L’argument `-r` précise le format de fichier de sortie que vous voulez.</span><span class="sxs-lookup"><span data-stu-id="c8482-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="c8482-215">L’argument `-t` spécifie quelle plate-forme .NET pour analyser l’utilisation de l’API contre.</span><span class="sxs-lookup"><span data-stu-id="c8482-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="c8482-216">Dans ce cas, vous voulez .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="c8482-217">Lorsque vous ouvrez le rapport HTML, la première section répertorie tous les binaires analysés et quel pourcentage des API .NET qu’ils utilisent sont disponibles sur la plate-forme ciblée.</span><span class="sxs-lookup"><span data-stu-id="c8482-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="c8482-218">Le pourcentage n’est pas significatif en soi.</span><span class="sxs-lookup"><span data-stu-id="c8482-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="c8482-219">Ce qui est plus utile est de voir les API spécifiques qui manquent.</span><span class="sxs-lookup"><span data-stu-id="c8482-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="c8482-220">Pour ce faire, sélectionnez un nom d’assemblage ou faites défiler vers le bas vers les rapports pour les assemblages individuels.</span><span class="sxs-lookup"><span data-stu-id="c8482-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="c8482-221">Concentrez-vous sur les assemblages pour lequel vous possédez le code source.</span><span class="sxs-lookup"><span data-stu-id="c8482-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="c8482-222">Dans le rapport Bean Trader ApiPort, par exemple, il existe de nombreux binaires répertoriés, mais la plupart d’entre eux appartiennent à des paquets NuGet.</span><span class="sxs-lookup"><span data-stu-id="c8482-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="c8482-223">`Castle.Windsor`montre que cela dépend de certains API System.Web qui manquent dans .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="c8482-224">Ce n’est pas une préoccupation `Castle.Windsor` parce que vous avez déjà vérifié que prend en charge .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="c8482-225">Il est courant pour les paquets NuGet d’avoir différents binaires pour une `Castle.Windsor` utilisation avec différentes plates-formes .NET, donc si la version cadre .NET des utilisations System.Web API ou non n’est pas pertinente tant que le paquet cible également .NET Standard ou .NET Core (ce qu’il fait).</span><span class="sxs-lookup"><span data-stu-id="c8482-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="c8482-226">Avec l’échantillon Bean Trader, le seul binaire que vous devez considérer est **BeanTraderClient** et `System.ServiceModel.ClientBase<T>.Close` `System.ServiceModel.ClientBase<T>.Open`le rapport montre que seulement deux API .NET sont manquants: et .</span><span class="sxs-lookup"><span data-stu-id="c8482-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![Rapport sur la portabilité de BeanTraderClient](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="c8482-228">Il est peu probable qu’il bloque les problèmes parce que les API clients de la WCF sont (principalement) prises en charge sur .NET Core, il doit donc y avoir des alternatives disponibles pour ces API centrales.</span><span class="sxs-lookup"><span data-stu-id="c8482-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="c8482-229">En fait, `System.ServiceModel`en regardant la surface de <https://apisof.net>base de .NET (en utilisant ), vous voyez qu’il ya des alternatives async dans .NET Core à la place.</span><span class="sxs-lookup"><span data-stu-id="c8482-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="c8482-230">Sur la base de ce rapport et de l’analyse précédente de la dépendance NuGet, il semble qu’il ne devrait pas y avoir de problèmes majeurs de migration de l’échantillon De Bean Trader à .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="c8482-231">Vous êtes prêt pour la prochaine étape dans laquelle vous allez réellement commencer la migration.</span><span class="sxs-lookup"><span data-stu-id="c8482-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="c8482-232">Migration du fichier projet</span><span class="sxs-lookup"><span data-stu-id="c8482-232">Migrating the project file</span></span>

<span data-ttu-id="c8482-233">Si votre application n’utilise pas le nouveau [format de fichier de projet de style SDK,](../../core/tools/csproj.md)vous aurez besoin d’un nouveau fichier de projet pour cibler .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="c8482-234">Vous pouvez remplacer le fichier csproj existant ou, si vous préférez garder le projet existant intact dans son état actuel, vous pouvez ajouter un nouveau fichier csproj ciblant .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="c8482-235">Vous pouvez créer des versions de l’application pour .NET Framework et .NET Core avec un `<TargetFrameworks>` seul fichier de projet de style SDK avec [multi-ciblage](../../standard/library-guidance/cross-platform-targeting.md) (spécifiant plusieurs cibles).</span><span class="sxs-lookup"><span data-stu-id="c8482-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="c8482-236">Pour créer le nouveau fichier de projet, vous pouvez créer `dotnet new wpf` un nouveau projet WPF dans Visual Studio ou utiliser la commande dans un répertoire temporaire pour générer le fichier de projet, puis le copier/renommer à l’emplacement correct.</span><span class="sxs-lookup"><span data-stu-id="c8482-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="c8482-237">Il existe également un outil créé par la communauté, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), qui peut automatiser une partie de la migration des fichiers de projet.</span><span class="sxs-lookup"><span data-stu-id="c8482-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="c8482-238">L’outil est utile, mais a encore besoin d’un humain pour examiner les résultats pour s’assurer que tous les détails de la migration sont corrects.</span><span class="sxs-lookup"><span data-stu-id="c8482-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="c8482-239">Un domaine particulier que l’outil ne gère pas de manière optimale est la migration des paquets NuGet à partir de fichiers *packages.config.*</span><span class="sxs-lookup"><span data-stu-id="c8482-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="c8482-240">Si l’outil s’exécute sur un fichier de projet qui utilise toujours un `<PackageReference>` fichier *packages.config* pour référencer les paquets NuGet, il migrera automatiquement vers des éléments, mais ajoutera `<PackageReference>` des éléments pour tous *les* paquets au lieu de seulement les plus hauts niveaux.</span><span class="sxs-lookup"><span data-stu-id="c8482-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="c8482-241">Si vous avez déjà`<PackageReference>` migré vers des éléments avec Visual Studio (comme vous l’avez fait dans cet échantillon), alors l’outil peut vous aider avec le reste de la conversion.</span><span class="sxs-lookup"><span data-stu-id="c8482-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="c8482-242">Comme Scott Hanselman recommande dans [son blog sur la migration des fichiers csproj](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), le portage à la main est éducatif et donnera de meilleurs résultats si vous n’avez que quelques projets à port.</span><span class="sxs-lookup"><span data-stu-id="c8482-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="c8482-243">Mais si vous transférez des dizaines ou des centaines de fichiers de projet, alors un outil comme [CsprojToVs2017] peut être une aide.</span><span class="sxs-lookup"><span data-stu-id="c8482-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="c8482-244">Pour créer un nouveau fichier de projet `dotnet new wpf` pour l’échantillon Bean Trader, exécutez dans un répertoire temporaire et déplacez le fichier *généré .csproj* dans le dossier *BeanTraderClient* et renommez-le **BeanTraderClient.Core.csproj**.</span><span class="sxs-lookup"><span data-stu-id="c8482-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="c8482-245">Étant donné que le nouveau format de fichier de projet inclut automatiquement les fichiers C, les fichiers *resx* et les fichiers XAML qu’il trouve dans ou sous son répertoire, le fichier de projet est déjà presque complet !</span><span class="sxs-lookup"><span data-stu-id="c8482-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="c8482-246">Pour terminer la migration, ouvrez les fichiers anciens et nouveaux fichiers de projet côte à côte et regardez à travers l’ancien pour voir si des informations qu’il contient doit être migrée.</span><span class="sxs-lookup"><span data-stu-id="c8482-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="c8482-247">Dans le cas de l’échantillon Bean Trader, les éléments suivants doivent être copiés sur le nouveau projet :</span><span class="sxs-lookup"><span data-stu-id="c8482-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="c8482-248">Le `<RootNamespace>` `<AssemblyName>`, `<ApplicationIcon>` , et les propriétés doivent toutes être copiées.</span><span class="sxs-lookup"><span data-stu-id="c8482-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="c8482-249">Vous devez également `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` ajouter une propriété au nouveau fichier de projet puisque l’échantillon bean Trader inclut des attributs de niveau d’assemblage (comme `[AssemblyTitle]`) dans un fichier AssemblyInfo.cs.</span><span class="sxs-lookup"><span data-stu-id="c8482-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="c8482-250">Par défaut, de nouveaux projets de style SDK permettront d’autogénérer ces attributs en fonction des propriétés du fichier csproj.</span><span class="sxs-lookup"><span data-stu-id="c8482-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="c8482-251">Parce que vous ne voulez pas que cela se produise dans ce cas (les attributs autogénérés serait `<GenerateAssemblyInfo>`en conflit avec ceux de AssemblyInfo.cs), vous désactiver les attributs autogénérés avec .</span><span class="sxs-lookup"><span data-stu-id="c8482-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="c8482-252">Bien que les fichiers *resx* soient `<Resource>` automatiquement inclus comme ressources intégrées, d’autres éléments comme les images ne le sont pas.</span><span class="sxs-lookup"><span data-stu-id="c8482-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="c8482-253">Ainsi, copiez les `<Resource>` éléments pour intégrer des fichiers d’image et d’icône.</span><span class="sxs-lookup"><span data-stu-id="c8482-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="c8482-254">Vous pouvez simplifier les références de png à une seule ligne en utilisant `<Resource Include="**\*.png" />`le support du nouveau format de fichier de projet pour les modèles de glisse: .</span><span class="sxs-lookup"><span data-stu-id="c8482-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="c8482-255">De `<None>` même, les éléments sont inclus automatiquement, mais ils ne sont pas copiés à l’annuaire de sortie, par défaut.</span><span class="sxs-lookup"><span data-stu-id="c8482-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="c8482-256">Parce que le projet `<None>` Bean Trader comprend un élément qui `PreserveNewest` *est* copié à l’annuaire de sortie (en utilisant des comportements), vous devez mettre à jour l’élément automatiquement peuplé `<None>` pour ce fichier, comme ceci.</span><span class="sxs-lookup"><span data-stu-id="c8482-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="c8482-257">L’échantillon Bean Trader comprend un fichier XAML (Default.Accent.xaml) comme `Content` (plutôt que comme un `Page`) parce que les thèmes et les accents définis dans ce fichier sont chargés à partir de XAML du fichier au moment de l’exécution, plutôt que d’être intégré dans l’application elle-même.</span><span class="sxs-lookup"><span data-stu-id="c8482-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="c8482-258">Le nouveau système de projet `<Page>`inclut automatiquement ce fichier comme un , cependant, car il s’agit d’un fichier XAML.</span><span class="sxs-lookup"><span data-stu-id="c8482-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="c8482-259">Donc, vous devez à la fois supprimer le`<Page Remove="**\Default.Accent.xaml" />`fichier XAML comme une page ( ) et l’ajouter comme contenu.</span><span class="sxs-lookup"><span data-stu-id="c8482-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="c8482-260">Enfin, ajoutez des références NuGet en copiant le `<ItemGroup>` avec tous les `<PackageReference>` éléments.</span><span class="sxs-lookup"><span data-stu-id="c8482-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="c8482-261">Si vous n’aviez pas précédemment mis à niveau les paquets NuGet en versions compatibles .NET Core, vous pouvez le faire maintenant que les références de paquets sont dans un projet .NET Core-spécifique.</span><span class="sxs-lookup"><span data-stu-id="c8482-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="c8482-262">À ce stade, il devrait être possible d’ajouter le nouveau projet à la solution BeanTrader et de l’ouvrir dans Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="c8482-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="c8482-263">Le projet devrait sembler correct `dotnet restore BeanTraderClient.Core.csproj` dans Solution **Explorer**, et devrait restaurer avec succès les paquets (avec deux avertissements attendus liés à la version MahApps.Metro que vous utilisez le ciblage .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="c8482-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="c8482-264">Bien qu’il soit possible de garder les deux fichiers de projet côte à côte (et peut même être souhaitable si vous voulez continuer à construire l’ancien projet exactement comme il était), il complique le processus de migration (les deux projets vont essayer d’utiliser le même bac et dossiers obj) et n’est généralement pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c8482-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="c8482-265">Si vous voulez construire pour les objectifs .NET Core `<TargetFramework>netcoreapp3.0</TargetFramework>` et .NET Framework, `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` vous pouvez remplacer la propriété dans le nouveau fichier de projet avec à la place.</span><span class="sxs-lookup"><span data-stu-id="c8482-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="c8482-266">Pour l’échantillon Bean Trader, supprimez l’ancien fichier de projet (BeanTraderClient.csproj) car il n’est plus nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c8482-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="c8482-267">Si vous préférez conserver les deux fichiers de projet, assurez-vous de les faire construire à des voies de sortie différentes et intermédiaires.</span><span class="sxs-lookup"><span data-stu-id="c8482-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="c8482-268">Résoudre les problèmes de construction</span><span class="sxs-lookup"><span data-stu-id="c8482-268">Fix build issues</span></span>

<span data-ttu-id="c8482-269">La troisième étape du processus de portage consiste à construire le projet.</span><span class="sxs-lookup"><span data-stu-id="c8482-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="c8482-270">Certaines applications seront déjà créées avec succès une fois que le fichier du projet est converti en un projet de style SDK.</span><span class="sxs-lookup"><span data-stu-id="c8482-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="c8482-271">Si c’est le cas pour votre application, félicitations!</span><span class="sxs-lookup"><span data-stu-id="c8482-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="c8482-272">Vous pouvez passer à l’étape 4.</span><span class="sxs-lookup"><span data-stu-id="c8482-272">You can go on to Step 4.</span></span> <span data-ttu-id="c8482-273">D’autres applications auront besoin de quelques mises à jour pour les faire construire pour .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="c8482-274">Si vous essayez `dotnet build` d’exécuter sur le projet d’échantillon Bean Trader maintenant, par exemple, (ou le construire dans Visual Studio), il y aura beaucoup d’erreurs, mais vous les obtiendrez fixé rapidement.</span><span class="sxs-lookup"><span data-stu-id="c8482-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="c8482-275">Références System.ServiceModel et Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="c8482-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="c8482-276">Une source commune d’erreurs est des références manquantes pour les API qui sont disponibles pour .NET Core, mais pas automatiquement inclus dans le métapackage de l’application .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="c8482-277">Pour remédier à cette `Microsoft.Windows.Compatibility` situation, vous devez faire référence au paquet.</span><span class="sxs-lookup"><span data-stu-id="c8482-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="c8482-278">Le paquet de compatibilité comprend un large ensemble d’API qui sont courantes dans les applications de bureau Windows, telles que les clients WCF, les services d’annuaire, le registre, la configuration, les API APL, et plus encore.</span><span class="sxs-lookup"><span data-stu-id="c8482-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="c8482-279">Avec l’échantillon Bean Trader, la majorité des <xref:System.ServiceModel> erreurs de construction sont dues à des types manquants.</span><span class="sxs-lookup"><span data-stu-id="c8482-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="c8482-280">Ceux-ci pourraient être abordés en faisant référence aux paquets WCF NuGet nécessaires.</span><span class="sxs-lookup"><span data-stu-id="c8482-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="c8482-281">Les API clients WCF sont `Microsoft.Windows.Compatibility` parmi ceux présents dans le paquet, cependant, ainsi référencement du paquet de compatibilité est une solution encore meilleure (puisqu’il aborde également tous les problèmes liés aux API aussi bien que des solutions aux issues de WCF que le paquet de compatibilité rend disponible).</span><span class="sxs-lookup"><span data-stu-id="c8482-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="c8482-282">Le `Microsoft.Windows.Compatibility` paquet aide dans la plupart des scénarios de portage .NET Core 3.0 WPF et WinForms.</span><span class="sxs-lookup"><span data-stu-id="c8482-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="c8482-283">Après avoir ajouté la `Microsoft.Windows.Compatibility`référence NuGet à , une seule erreur de construction reste!</span><span class="sxs-lookup"><span data-stu-id="c8482-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="c8482-284">Nettoyage des fichiers inutilisés</span><span class="sxs-lookup"><span data-stu-id="c8482-284">Cleaning up unused files</span></span>

<span data-ttu-id="c8482-285">Un type de problème de migration qui se présente se rapporte souvent aux fichiers C et XAML qui n’étaient pas auparavant inclus dans la construction qui sont ramassés par les nouveaux projets de style SDK qui comprennent *toutes les* sources automatiquement.</span><span class="sxs-lookup"><span data-stu-id="c8482-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="c8482-286">L’erreur de construction suivante que vous voyez dans l’échantillon Bean Trader se réfère à une mauvaise implémentation d’interface dans *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="c8482-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="c8482-287">Le nom du fichier est un indice, mais lors de l’inspection, vous constaterez que ce fichier source est incorrect.</span><span class="sxs-lookup"><span data-stu-id="c8482-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="c8482-288">Il n’a pas causé de problèmes auparavant parce qu’il n’était pas inclus dans le projet cadre original .NET.</span><span class="sxs-lookup"><span data-stu-id="c8482-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="c8482-289">Les fichiers sources qui étaient présents sur disque mais non inclus dans l’ancien *csproj* sont inclus automatiquement dès maintenant.</span><span class="sxs-lookup"><span data-stu-id="c8482-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="c8482-290">Pour des questions ponctuelles comme celle-ci, il est facile de comparer au *csproj* précédent `<Compile Remove="" />` pour confirmer que le fichier n’est pas nécessaire, puis soit il ou, si le fichier source n’est plus nécessaire n’importe où, le supprimer.</span><span class="sxs-lookup"><span data-stu-id="c8482-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="c8482-291">Dans ce cas, il est sûr de simplement supprimer *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="c8482-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="c8482-292">Si vous avez de nombreux fichiers source qui devraient être exclus de cette façon, `<EnableDefaultCompileItems>` vous pouvez désactiver l’auto-inclusion des fichiers C en définissant la propriété à faux dans le fichier du projet.</span><span class="sxs-lookup"><span data-stu-id="c8482-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="c8482-293">Ensuite, vous `<Compile Include>` pouvez copier des éléments de l’ancien fichier de projet à la nouvelle afin de ne construire que les sources que vous aviez l’intention d’inclure.</span><span class="sxs-lookup"><span data-stu-id="c8482-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="c8482-294">De `<EnableDefaultPageItems>` même, peut être utilisé pour désactiver l’auto-inclusion des pages XAML et `<EnableDefaultItems>` peut contrôler les deux avec une seule propriété.</span><span class="sxs-lookup"><span data-stu-id="c8482-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="c8482-295">Un bref côté sur les compilateurs multi-pass</span><span class="sxs-lookup"><span data-stu-id="c8482-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="c8482-296">Après avoir retiré le fichier incriminé de l’échantillon Bean Trader, vous pouvez re-construire et obtiendrez quatre erreurs.</span><span class="sxs-lookup"><span data-stu-id="c8482-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="c8482-297">Tu n’en avais pas avant ?</span><span class="sxs-lookup"><span data-stu-id="c8482-297">Didn't you have one before?</span></span> <span data-ttu-id="c8482-298">Pourquoi le nombre d’erreurs a-t-il augmenté?</span><span class="sxs-lookup"><span data-stu-id="c8482-298">Why did the number of errors go up?</span></span> <span data-ttu-id="c8482-299">Le compilateur C est un [compilateur multi-pass](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span><span class="sxs-lookup"><span data-stu-id="c8482-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="c8482-300">Cela signifie qu’il passe par chaque fichier source deux fois.</span><span class="sxs-lookup"><span data-stu-id="c8482-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="c8482-301">Tout d’abord, le compilateur se contente d’examiner les métadonnées et les déclarations dans chaque fichier source et identifie tout problème au niveau de la déclaration.</span><span class="sxs-lookup"><span data-stu-id="c8482-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="c8482-302">Ce sont les erreurs que vous avez corrigées.</span><span class="sxs-lookup"><span data-stu-id="c8482-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="c8482-303">Ensuite, il passe à nouveau par le code pour construire la source C EN IL; ce sont la deuxième série d’erreurs que vous voyez maintenant.</span><span class="sxs-lookup"><span data-stu-id="c8482-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="c8482-304">Le compilateur C fait [plus que seulement deux passes,](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)mais le résultat final est que les erreurs de compilateur pour les grands changements de code comme celui-ci ont tendance à venir en deux vagues.</span><span class="sxs-lookup"><span data-stu-id="c8482-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="c8482-305">Corrections de dépendance de tiers (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="c8482-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="c8482-306">Une autre catégorie de questions qui apparaît dans certains scénarios de migration est les différences API entre .NET Framework et .NET Core versions des dépendances.</span><span class="sxs-lookup"><span data-stu-id="c8482-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="c8482-307">Même si un paquet NuGet cible à la fois .NET Framework et .NET Standard ou .NET Core, il peut y avoir différentes bibliothèques pour une utilisation avec des objectifs .NET différents.</span><span class="sxs-lookup"><span data-stu-id="c8482-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="c8482-308">Cela permet aux paquets de prendre en charge de nombreuses plates-formes .NET différentes, qui peuvent nécessiter des implémentations différentes.</span><span class="sxs-lookup"><span data-stu-id="c8482-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="c8482-309">Cela signifie également qu’il peut y avoir de petites différences d’API dans les bibliothèques lors du ciblage de différentes plates-formes .NET.</span><span class="sxs-lookup"><span data-stu-id="c8482-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="c8482-310">La prochaine série d’erreurs que vous verrez dans `Castle.Windsor` l’échantillon Bean Trader sont liées aux API.</span><span class="sxs-lookup"><span data-stu-id="c8482-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="c8482-311">Le projet .NET Core Bean Trader `Castle.Windsor` utilise la même version que le projet .NET Framework-targeted (4.1.1), mais les implémentations de ces deux plates-formes sont légèrement différentes.</span><span class="sxs-lookup"><span data-stu-id="c8482-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="c8482-312">Dans ce cas, vous voyez les questions suivantes qui doivent être corrigées :</span><span class="sxs-lookup"><span data-stu-id="c8482-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="c8482-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`n’est pas disponible sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="c8482-314">Il ya, cependant, `Classes.FromAssemblyContaining` l’API similaire disponible, `Classes.FromThisAssembly()` de sorte `Classes.FromAssemblyContaining(t)`que `t` nous pouvons remplacer les deux utilisations d’appels à , où est le type de faire l’appel.</span><span class="sxs-lookup"><span data-stu-id="c8482-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="c8482-315">De même, en *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`. Ce n’est pas disponible sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="c8482-316">Au lieu de cela, `FromAssembly.Containing(typeof(Bootstrapper))`cet appel peut être remplacé par .</span><span class="sxs-lookup"><span data-stu-id="c8482-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="c8482-317">Mise à jour de l’utilisation des clients WCF</span><span class="sxs-lookup"><span data-stu-id="c8482-317">Updating WCF client usage</span></span>

<span data-ttu-id="c8482-318">Après avoir `Castle.Windsor` corrigé les différences, la dernière erreur de construction restante `BeanTraderServiceClient` dans le `DuplexClientBase`projet .NET Core `Open` Bean Trader est que (qui dérive de ) n’a pas de méthode.</span><span class="sxs-lookup"><span data-stu-id="c8482-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="c8482-319">Ce n’est pas surprenant puisqu’il s’agit d’une API qui a été mise en évidence par l’analyseur de la portabilité .NET au début de ce processus de migration.</span><span class="sxs-lookup"><span data-stu-id="c8482-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="c8482-320">Cependant, `BeanTraderServiceClient` l’attention attire notre attention sur une question plus vaste.</span><span class="sxs-lookup"><span data-stu-id="c8482-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="c8482-321">Ce client WCF a été autogénéré par l’outil [Svcutil.exe.](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</span><span class="sxs-lookup"><span data-stu-id="c8482-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="c8482-322">**Les clients WCF générés par Svcutil sont destinés à être utilisés sur .NET Framework.**</span><span class="sxs-lookup"><span data-stu-id="c8482-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="c8482-323">Les solutions qui utilisent des clients WCF générés par le svcutil devront régénérer les clients compatibles avec la norme .NET pour une utilisation avec .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="c8482-324">L’une des principales raisons pour lesquelles les anciens clients ne fonctionneront pas est qu’ils dépendent de la configuration de l’application pour définir les liaisons et les paramètres WCF.</span><span class="sxs-lookup"><span data-stu-id="c8482-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="c8482-325">Parce que les API WCF standard .NET peuvent fonctionner interplateforme (où les API System.Configuration ne sont pas disponibles), les clients WCF pour les scénarios .NET Core et .NET Standard doivent définir les liaisons et les points de terminaison programmatiquement plutôt que dans la configuration.</span><span class="sxs-lookup"><span data-stu-id="c8482-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="c8482-326">En fait, toute utilisation du client `<system.serviceModel>` WCF qui dépend de la section app.config (qu’elle soit créée avec Svcutil ou manuellement) devra être modifiée pour travailler sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="c8482-327">Il existe deux façons de générer automatiquement des clients WCF compatibles avec la norme .NET :</span><span class="sxs-lookup"><span data-stu-id="c8482-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="c8482-328">L’outil `dotnet-svcutil` est un outil .NET qui génère des clients WCF d’une manière qui est similaire à la façon dont Svcutil a travaillé précédemment.</span><span class="sxs-lookup"><span data-stu-id="c8482-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="c8482-329">Visual Studio peut générer des clients WCF en utilisant l’option [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) de sa fonction Services connectés.</span><span class="sxs-lookup"><span data-stu-id="c8482-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="c8482-330">L’une ou l’autre approche fonctionne bien.</span><span class="sxs-lookup"><span data-stu-id="c8482-330">Either approach works well.</span></span> <span data-ttu-id="c8482-331">Alternativement, bien sûr, vous pouvez écrire le code client WCF vous-même.</span><span class="sxs-lookup"><span data-stu-id="c8482-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="c8482-332">Pour cet exemple, j’ai choisi d’utiliser la fonction Visual Studio Connected Service.</span><span class="sxs-lookup"><span data-stu-id="c8482-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="c8482-333">Pour ce faire, cliquez à droite sur le projet *BeanTraderClient.Core* dans l’explorateur de solutions de Visual Studio et sélectionnez **Add** > **Connected Service**.</span><span class="sxs-lookup"><span data-stu-id="c8482-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="c8482-334">Ensuite, choisissez le fournisseur de référence de service Web WCF.</span><span class="sxs-lookup"><span data-stu-id="c8482-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="c8482-335">Cela fera état d’un dialogue où vous pouvez spécifier`localhost:8080` l’adresse du service Web Backend Bean Trader (si vous exécutez le serveur localement) et l’espace nom qui a généré des types devraient utiliser (**BeanTrader.Service**, par exemple).</span><span class="sxs-lookup"><span data-stu-id="c8482-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![WCF Web Service Reference Connected Service Dialog](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="c8482-337">Une fois que vous avez choisi le bouton **Finition,** un nouveau nœud services connectés est ajouté au projet et un fichier Reference.cs est ajouté sous ce nœud contenant le nouveau client .NET Standard WCF pour accéder au service Bean Trader.</span><span class="sxs-lookup"><span data-stu-id="c8482-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="c8482-338">Si vous regardez `GetEndpointAddress` `GetBindingForEndpoint` les méthodes ou les méthodes de ce fichier, vous verrez que les fixations et les paramètres sont maintenant générés de façon programmatique (au lieu de via app config).</span><span class="sxs-lookup"><span data-stu-id="c8482-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="c8482-339">La fonction «Ajouter des services connectés» peut également ajouter des références à certains paquets System.ServiceModel dans le fichier du projet, qui ne sont pas nécessaires puisque tous les paquets WCF nécessaires sont inclus via Microsoft.Windows.Compatibility.</span><span class="sxs-lookup"><span data-stu-id="c8482-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="c8482-340">Vérifiez le csproj pour voir si des `<PackageReference>` éléments supplémentaires de System.ServiceModel ont été ajoutés, et si oui, supprimez-les.</span><span class="sxs-lookup"><span data-stu-id="c8482-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="c8482-341">Notre projet a de nouvelles classes de clients WCF maintenant (en *Reference.cs),* mais il a aussi encore les anciens (en BeanTrader.cs).</span><span class="sxs-lookup"><span data-stu-id="c8482-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="c8482-342">Il y a deux options à ce stade :</span><span class="sxs-lookup"><span data-stu-id="c8482-342">There are two options at this point:</span></span>

- <span data-ttu-id="c8482-343">Si vous souhaitez être en mesure de construire le projet cadre .NET original (à `<Compile Remove="BeanTrader.cs" />` côté du nouveau .NET Core-targeted one), vous pouvez utiliser un élément dans le fichier csproj du projet .NET Core afin que les versions .NET Framework et .NET Core de l’application utilisent différents clients WCF.</span><span class="sxs-lookup"><span data-stu-id="c8482-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="c8482-344">Cela a l’avantage de laisser le projet cadre .NET existant inchangé, mais a l’inconvénient que le code utilisant les clients WCF générés peuvent avoir besoin `#if` d’être légèrement différent dans le cas .NET Core qu’il ne l’était dans le projet cadre .NET, de sorte que vous aurez probablement besoin d’utiliser des directives pour compiler sous condition une certaine utilisation des clients WCF (création de clients, par exemple) de travailler d’une manière lorsqu’il était construit pour .NET Core et une autre façon lorsqu’il est construit pour .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c8482-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="c8482-345">Si, d’autre part, un certain désabonnement de code dans le projet cadre .NET existant est acceptable, vous pouvez supprimer *BeanTrader.cs* tous ensemble.</span><span class="sxs-lookup"><span data-stu-id="c8482-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="c8482-346">Parce que le nouveau client WCF est conçu pour .NET Standard, il fonctionnera à la fois dans les scénarios .NET Core et .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c8482-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="c8482-347">Si vous construisez pour .NET Framework en plus de .NET Core (soit par multi-ciblage ou en ayant deux fichiers csproj), vous pouvez utiliser ce nouveau fichier *Reference.cs* pour les deux cibles.</span><span class="sxs-lookup"><span data-stu-id="c8482-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="c8482-348">Cette approche a l’avantage que le code n’aura pas besoin de bifurquer pour soutenir deux clients WCF différents; le même code sera utilisé partout.</span><span class="sxs-lookup"><span data-stu-id="c8482-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="c8482-349">L’inconvénient est qu’il s’agit de modifier le projet cadre (probablement stable) .NET.</span><span class="sxs-lookup"><span data-stu-id="c8482-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="c8482-350">Dans le cas de l’échantillon Bean Trader, vous pouvez apporter de petites modifications au projet original s’il facilite la migration, alors suivez ces étapes pour concilier l’utilisation des clients WCF :</span><span class="sxs-lookup"><span data-stu-id="c8482-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="c8482-351">Ajoutez le nouveau fichier Reference.cs au projet .NET Framework *BeanTraderClient.csproj* à l’aide du menu contextuel « Ajouter l’élément existant » de l’explorateur de solution.</span><span class="sxs-lookup"><span data-stu-id="c8482-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="c8482-352">Assurez-vous d’ajouter « comme lien » afin que le même fichier soit utilisé par les deux projets (plutôt que de copier le fichier C).</span><span class="sxs-lookup"><span data-stu-id="c8482-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="c8482-353">Si vous construisez pour .NET Core et .NET Framework avec un seul csproj (en utilisant multi-ciblage), alors cette étape n’est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c8482-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="c8482-354">Supprimer *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="c8482-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="c8482-355">Le nouveau client WCF est similaire à l’ancien, mais un certain nombre d’espaces de nom dans le code généré sont différents.</span><span class="sxs-lookup"><span data-stu-id="c8482-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="c8482-356">Pour cette raison, il est nécessaire de mettre à jour le projet afin que les types de clients WCF sont utilisés à partir de BeanTrader.Service (ou quel que soit le nom que vous avez choisi) au lieu de BeanTrader.Model ou sans espace nom.</span><span class="sxs-lookup"><span data-stu-id="c8482-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="c8482-357">Construire *BeanTraderClient.Core.csproj* aidera à identifier où ces changements doivent être apportés.</span><span class="sxs-lookup"><span data-stu-id="c8482-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="c8482-358">Des correctifs seront nécessaires à la fois dans les fichiers de source C et XAML.</span><span class="sxs-lookup"><span data-stu-id="c8482-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="c8482-359">Enfin, vous découvrirez qu’il *BeanTraderServiceClientFactory.cs* y a une erreur dans `BeanTraderServiceClient` BeanTraderServiceClientFactory.cs parce que les constructeurs disponibles pour le type ont changé.</span><span class="sxs-lookup"><span data-stu-id="c8482-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="c8482-360">Il était possible de `InstanceContext` fournir un argument (qui `Castle.Windsor` a été créé à l’aide d’un `CallbackHandler` conteneur IoC).</span><span class="sxs-lookup"><span data-stu-id="c8482-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="c8482-361">Les nouveaux constructeurs `CallbackHandler`créent de nouveaux s.</span><span class="sxs-lookup"><span data-stu-id="c8482-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="c8482-362">Il ya, cependant, `BeanTraderServiceClient`les constructeurs dans le type de base qui correspondent à ce que vous voulez.</span><span class="sxs-lookup"><span data-stu-id="c8482-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="c8482-363">Étant donné que le code client WCF autogénéré existe dans les classes partielles, vous pouvez facilement l’étendre.</span><span class="sxs-lookup"><span data-stu-id="c8482-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="c8482-364">Pour ce faire, créez un nouveau fichier appelé *BeanTraderServiceClient.cs,* puis créez une classe partielle avec ce même nom (en utilisant le namespace BeanTrader.Service).</span><span class="sxs-lookup"><span data-stu-id="c8482-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="c8482-365">Ensuite, ajoutez un constructeur au type partiel tel qu’il est indiqué ici.</span><span class="sxs-lookup"><span data-stu-id="c8482-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="c8482-366">Avec ces modifications apportées, l’échantillon Bean Trader sera désormais à l’aide d’un nouveau `Open` client WCF compatible `await OpenAsync` standard .NET et vous pouvez faire le correctif final de changer l’appel dans *TradingService.cs* à utiliser à la place.</span><span class="sxs-lookup"><span data-stu-id="c8482-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="c8482-367">Avec les questions WCF abordés, la version .NET Core de l’échantillon Bean Trader construit maintenant proprement!</span><span class="sxs-lookup"><span data-stu-id="c8482-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="c8482-368">Test de temps d’exécution</span><span class="sxs-lookup"><span data-stu-id="c8482-368">Runtime testing</span></span>

<span data-ttu-id="c8482-369">Il est facile d’oublier que les travaux de migration ne se font pas dès que le projet se développe proprement contre .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c8482-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="c8482-370">Il est important de laisser le temps de tester l’application ported, aussi.</span><span class="sxs-lookup"><span data-stu-id="c8482-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="c8482-371">Une fois que les choses se construisent avec succès, assurez-vous que l’application fonctionne et fonctionne comme prévu, surtout si vous utilisez des paquets ciblant .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c8482-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="c8482-372">Essayons de lancer l’application Ported Bean Trader et voir ce qui se passe.</span><span class="sxs-lookup"><span data-stu-id="c8482-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="c8482-373">L’application ne va pas loin avant d’échouer à l’exception suivante.</span><span class="sxs-lookup"><span data-stu-id="c8482-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="c8482-374">C’est logique, bien sûr.</span><span class="sxs-lookup"><span data-stu-id="c8482-374">This makes sense, of course.</span></span> <span data-ttu-id="c8482-375">Rappelez-vous que WCF n’utilise plus la configuration de l’application, de sorte que l’ancienne section system.serviceModel du fichier app.config doit être supprimée.</span><span class="sxs-lookup"><span data-stu-id="c8482-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="c8482-376">Le client WCF mis à jour inclut toutes les mêmes informations dans son code, de sorte que la section config n’est plus nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c8482-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="c8482-377">Si vous vouliez que le point de terminaison WCF soit configurable dans app.config, vous pouvez l’ajouter comme paramètre d’application et mettre à jour le code client WCF pour récupérer le critère de service WCF de la configuration.</span><span class="sxs-lookup"><span data-stu-id="c8482-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="c8482-378">Après avoir supprimé la section system.serviceModel de *app.config*, l’application lance mais échoue à une autre exception lorsqu’un utilisateur s’y inscrit.</span><span class="sxs-lookup"><span data-stu-id="c8482-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="c8482-379">L’API non pris `Func<T>.BeginInvoke`en soutien est .</span><span class="sxs-lookup"><span data-stu-id="c8482-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="c8482-380">Comme expliqué dans [dotnet/corefx-5940](https://github.com/dotnet/corefx/issues/5940), .NET `BeginInvoke` Core `EndInvoke` ne prend pas en charge les types et les méthodes sur les types de délégués en raison de dépendances sous-jacentes de remotage.</span><span class="sxs-lookup"><span data-stu-id="c8482-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="c8482-381">Ce problème et son correctif sont expliqués plus en détail dans le [Délégué Migrateur.BeginInvoke appels pour .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, mais l’essentiel est `BeginInvoke` que et `EndInvoke` les appels doivent être remplacés par `Task.Run` (ou des alternatives async, si possible).</span><span class="sxs-lookup"><span data-stu-id="c8482-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="c8482-382">En appliquant la `BeginInvoke` solution générale ici, `Invoke` l’appel peut être remplacé par un appel lancé par `Task.Run`.</span><span class="sxs-lookup"><span data-stu-id="c8482-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="c8482-383">Après avoir `BeginInvoke` supprimé l’utilisation, l’application Bean Trader fonctionne avec succès sur .NET Core!</span><span class="sxs-lookup"><span data-stu-id="c8482-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Bean Trader en cours d’exécution sur .NET Core](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="c8482-385">Toutes les applications sont différentes, de sorte que les étapes spécifiques nécessaires pour migrer vos propres applications vers .NET Core variera.</span><span class="sxs-lookup"><span data-stu-id="c8482-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="c8482-386">Mais j’espère que l’échantillon Bean Trader démontre le flux de travail général et les types de questions qui peuvent être attendus.</span><span class="sxs-lookup"><span data-stu-id="c8482-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="c8482-387">Et, malgré la longueur de cet article, les changements réels nécessaires dans l’échantillon de Bean Trader pour le faire fonctionner sur .NET Core étaient assez limités.</span><span class="sxs-lookup"><span data-stu-id="c8482-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="c8482-388">De nombreuses applications migrent vers .NET Core de cette même manière; avec des modifications de code limitées ou même nulles nécessaires.</span><span class="sxs-lookup"><span data-stu-id="c8482-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
