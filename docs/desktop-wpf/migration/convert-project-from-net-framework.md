---
title: Migration d’applications WPF vers .NET Core 3,0
description: Découvrez comment migrer une application Windows Presentation Foundation (WPF) vers .NET Core 3,0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/01/2020
ms.locfileid: "82071310"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="35ff0-103">Migration d’applications WPF vers .NET Core</span><span class="sxs-lookup"><span data-stu-id="35ff0-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="35ff0-104">Cet article décrit les étapes nécessaires à la migration d’une application Windows Presentation Foundation (WPF) à partir de .NET Framework vers .NET Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="35ff0-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="35ff0-105">Si vous ne disposez pas d’une application WPF sur le port, mais que vous souhaitez essayer le processus, vous pouvez utiliser l’exemple d’application **Bean opérateur** disponible sur [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span><span class="sxs-lookup"><span data-stu-id="35ff0-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="35ff0-106">L’application d’origine (ciblant .NET Framework 4.7.2) est disponible dans le dossier NetFx\BeanTraderClient.</span><span class="sxs-lookup"><span data-stu-id="35ff0-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="35ff0-107">Tout d’abord, nous allons expliquer les étapes nécessaires pour porter les applications en général, puis nous allons examiner les modifications spécifiques qui s’appliquent à l’exemple de **courtier Bean** .</span><span class="sxs-lookup"><span data-stu-id="35ff0-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="35ff0-108">Pour migrer vers .NET Core, vous devez d’abord :</span><span class="sxs-lookup"><span data-stu-id="35ff0-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="35ff0-109">Comprendre et mettre à jour les dépendances NuGet :</span><span class="sxs-lookup"><span data-stu-id="35ff0-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="35ff0-110">Mettez à niveau les dépendances `<PackageReference>` NuGet pour utiliser le format.</span><span class="sxs-lookup"><span data-stu-id="35ff0-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="35ff0-111">Examinez les dépendances NuGet de niveau supérieur pour .NET Core ou la compatibilité .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="35ff0-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="35ff0-112">Mettez à niveau les packages NuGet vers des versions plus récentes.</span><span class="sxs-lookup"><span data-stu-id="35ff0-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="35ff0-113">Utilisez l' [Analyseur de portabilité .net](../../standard/analyzers/portability-analyzer.md) pour comprendre les dépendances .net.</span><span class="sxs-lookup"><span data-stu-id="35ff0-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="35ff0-114">Migrez le fichier projet vers le nouveau format de style SDK :</span><span class="sxs-lookup"><span data-stu-id="35ff0-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="35ff0-115">Indiquez si vous souhaitez cibler à la fois .NET Core et .NET Framework, ou uniquement .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="35ff0-116">Copiez les propriétés et éléments de fichier projet appropriés dans le nouveau fichier projet.</span><span class="sxs-lookup"><span data-stu-id="35ff0-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="35ff0-117">Résoudre les problèmes de génération :</span><span class="sxs-lookup"><span data-stu-id="35ff0-117">Fix build issues:</span></span>

    01. <span data-ttu-id="35ff0-118">Ajoutez une référence au package [Microsoft. Windows. Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) .</span><span class="sxs-lookup"><span data-stu-id="35ff0-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="35ff0-119">Recherchez et corrigez les différences au niveau de l’API.</span><span class="sxs-lookup"><span data-stu-id="35ff0-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="35ff0-120">Supprimez les sections *app. config* `appSettings` autres `connectionStrings`que ou.</span><span class="sxs-lookup"><span data-stu-id="35ff0-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="35ff0-121">Régénérez le code généré, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="35ff0-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="35ff0-122">Test du Runtime :</span><span class="sxs-lookup"><span data-stu-id="35ff0-122">Runtime testing:</span></span>

    01. <span data-ttu-id="35ff0-123">Confirmez que l’application portée fonctionne comme prévu.</span><span class="sxs-lookup"><span data-stu-id="35ff0-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="35ff0-124">Méfiez- <xref:System.NotSupportedException> vous des exceptions.</span><span class="sxs-lookup"><span data-stu-id="35ff0-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="35ff0-125">À propos de l’exemple</span><span class="sxs-lookup"><span data-stu-id="35ff0-125">About the sample</span></span>

<span data-ttu-id="35ff0-126">Cet article fait référence à l' [exemple d’application Bean opérateur](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) , car il utilise une variété de dépendances similaires à celles que des applications WPF réelles peuvent avoir.</span><span class="sxs-lookup"><span data-stu-id="35ff0-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="35ff0-127">L’application n’est pas grande, mais elle est destinée à être une étape allant de « Hello World » en termes de complexité.</span><span class="sxs-lookup"><span data-stu-id="35ff0-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="35ff0-128">L’application montre certains problèmes que les utilisateurs peuvent rencontrer lors du Portage d’applications réelles.</span><span class="sxs-lookup"><span data-stu-id="35ff0-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="35ff0-129">L’application communique avec un service WCF. pour qu’elle s’exécute correctement, vous devez également exécuter le projet BeanTraderServer (disponible dans le même dépôt GitHub) et vous assurer que la configuration BeanTraderClient pointe vers le point de terminaison correct.</span><span class="sxs-lookup"><span data-stu-id="35ff0-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="35ff0-130">(Par défaut, l’exemple suppose que le serveur est en cours d’exécution sur le *http://localhost:8090*même ordinateur à, ce qui est vrai si vous lancez BeanTraderServer localement.)</span><span class="sxs-lookup"><span data-stu-id="35ff0-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="35ff0-131">Gardez à l’esprit que cet exemple d’application est destiné à illustrer les défis et les solutions de Portage .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="35ff0-132">Elle n’est pas destinée à illustrer les bonnes pratiques WPF.</span><span class="sxs-lookup"><span data-stu-id="35ff0-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="35ff0-133">En fait, il comprend délibérément des anti-modèles pour s’assurer que vous avez rencontré au moins deux défis intéressants lors du Portage.</span><span class="sxs-lookup"><span data-stu-id="35ff0-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="35ff0-134">Préparation</span><span class="sxs-lookup"><span data-stu-id="35ff0-134">Getting ready</span></span>

<span data-ttu-id="35ff0-135">Le principal défi de la migration d’une application .NET Framework vers .NET Core est que ses dépendances peuvent fonctionner différemment ou pas du tout.</span><span class="sxs-lookup"><span data-stu-id="35ff0-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="35ff0-136">La migration est beaucoup plus facile qu’elle ne l’était. de nombreux packages NuGet ciblent à présent .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="35ff0-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="35ff0-137">À compter de .NET Core 2,0, les zones d’exposition .NET Framework et .NET Core sont devenues similaires.</span><span class="sxs-lookup"><span data-stu-id="35ff0-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="35ff0-138">Même dans ce cas, certaines différences (à la fois pour la prise en charge des packages NuGet et dans les API .NET disponibles) sont conservées.</span><span class="sxs-lookup"><span data-stu-id="35ff0-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="35ff0-139">La première étape de la migration consiste à passer en revue les dépendances de l’application et à vérifier que les références sont dans un format qui est facilement migré vers .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="35ff0-140">Mettre à `<PackageReference>` niveau vers les références NuGet</span><span class="sxs-lookup"><span data-stu-id="35ff0-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="35ff0-141">Les anciens projets de .NET Framework répertorient généralement leurs dépendances NuGet dans un fichier *packages. config* .</span><span class="sxs-lookup"><span data-stu-id="35ff0-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="35ff0-142">Le nouveau format de fichier de projet de type SDK fait référence [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) aux packages NuGet en tant qu’éléments dans le fichier csproj lui-même plutôt que dans un fichier de configuration distinct.</span><span class="sxs-lookup"><span data-stu-id="35ff0-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="35ff0-143">Lors de la migration, il existe deux avantages `<PackageReference>`à l’utilisation des références de style :</span><span class="sxs-lookup"><span data-stu-id="35ff0-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="35ff0-144">Il s’agit du style de référence NuGet requis pour le nouveau fichier projet .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="35ff0-145">Si vous utilisez `<PackageReference>`déjà, vous pouvez copier et coller ces éléments de fichier projet directement dans le nouveau projet.</span><span class="sxs-lookup"><span data-stu-id="35ff0-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="35ff0-146">Contrairement à un fichier Packages. config `<PackageReference>` , les éléments font uniquement référence aux dépendances de niveau supérieur dont votre projet dépend directement.</span><span class="sxs-lookup"><span data-stu-id="35ff0-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="35ff0-147">Tous les autres packages NuGet transitifs seront déterminés au moment de la restauration et enregistrés dans le fichier obj\project.Assets.JSON généré automatiquement.</span><span class="sxs-lookup"><span data-stu-id="35ff0-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="35ff0-148">Il est ainsi beaucoup plus facile de déterminer les dépendances de votre projet, ce qui est utile pour déterminer si les dépendances nécessaires fonctionnent sur .NET Core ou non.</span><span class="sxs-lookup"><span data-stu-id="35ff0-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="35ff0-149">La première étape de la migration d’une application .NET Framework vers .NET Core consiste à la mettre `<PackageReference>` à jour pour utiliser des références NuGet.</span><span class="sxs-lookup"><span data-stu-id="35ff0-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="35ff0-150">Visual Studio simplifie cette solution.</span><span class="sxs-lookup"><span data-stu-id="35ff0-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="35ff0-151">Il vous suffit de cliquer avec le bouton droit sur le fichier *packages. config* du projet dans le **Explorateur de solutions**de Visual Studio, puis de sélectionner **migrer packages. config vers PackageReference**.</span><span class="sxs-lookup"><span data-stu-id="35ff0-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Mise à niveau vers PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="35ff0-153">Une boîte de dialogue s’affiche avec les dépendances NuGet de niveau supérieur calculées et vous demandant quels autres packages NuGet doivent être promus au niveau le plus élevé.</span><span class="sxs-lookup"><span data-stu-id="35ff0-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="35ff0-154">Aucun de ces autres packages n’a besoin d’être de niveau supérieur pour l’exemple Bean responsable. vous pouvez donc décocher toutes ces zones.</span><span class="sxs-lookup"><span data-stu-id="35ff0-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="35ff0-155">Ensuite, cliquez sur **OK** et le fichier *packages. config* est supprimé `<PackageReference>` et les éléments sont ajoutés au fichier projet.</span><span class="sxs-lookup"><span data-stu-id="35ff0-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="35ff0-156">`<PackageReference>`-les références de style ne stockent pas les packages NuGet localement dans un dossier de packages.</span><span class="sxs-lookup"><span data-stu-id="35ff0-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="35ff0-157">Au lieu de cela, elles sont stockées globalement en tant qu’optimisation.</span><span class="sxs-lookup"><span data-stu-id="35ff0-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="35ff0-158">Une fois la migration terminée, modifiez le fichier csproj et supprimez `<Analyzer>` tous les éléments qui font référence aux analyseurs qui proviennent précédemment de *. Répertoire \Packages* .</span><span class="sxs-lookup"><span data-stu-id="35ff0-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="35ff0-159">Ne vous inquiétez pas ; étant donné que vous avez toujours les références de package NuGet, les analyseurs seront inclus dans le projet.</span><span class="sxs-lookup"><span data-stu-id="35ff0-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="35ff0-160">Vous devez simplement nettoyer les anciens éléments de style `<Analyzer>` packages. config.</span><span class="sxs-lookup"><span data-stu-id="35ff0-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="35ff0-161">Examiner les packages NuGet</span><span class="sxs-lookup"><span data-stu-id="35ff0-161">Review NuGet packages</span></span>

<span data-ttu-id="35ff0-162">Maintenant que vous pouvez voir les packages NuGet de niveau supérieur dont le projet dépend, vous pouvez vérifier si ces packages sont disponibles sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="35ff0-163">Vous pouvez déterminer si un package prend en charge .NET Core en examinant ses dépendances sur [NuGet.org](https://www.nuget.org/). Le site [fuget.org](https://www.fuget.org/) créé par la communauté affiche ces informations en haut de la page d’informations du package.</span><span class="sxs-lookup"><span data-stu-id="35ff0-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="35ff0-164">Quand vous ciblez .NET Core 3,0, tous les packages ciblant .NET Core ou .NET Standard doivent fonctionner (puisque .NET Core implémente la surface d’exposition .NET Standard).</span><span class="sxs-lookup"><span data-stu-id="35ff0-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="35ff0-165">Dans certains cas, la version spécifique d’un package qui est utilisée ne cible pas .NET Core ou .NET Standard, mais les versions plus récentes.</span><span class="sxs-lookup"><span data-stu-id="35ff0-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="35ff0-166">Dans ce cas, vous devez envisager une mise à niveau vers la version la plus récente du package.</span><span class="sxs-lookup"><span data-stu-id="35ff0-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="35ff0-167">Vous pouvez également utiliser des packages ciblant .NET Framework, mais cela présente des risques.</span><span class="sxs-lookup"><span data-stu-id="35ff0-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="35ff0-168">.NET Core vers .NET Framework les dépendances sont autorisées, car les zones de surface de .NET Framework et .NET Core sont suffisamment semblables pour que ces dépendances fonctionnent *souvent* .</span><span class="sxs-lookup"><span data-stu-id="35ff0-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="35ff0-169">Toutefois, si le package tente d’utiliser une API .NET qui n’est pas présente dans .NET Core, vous rencontrerez une exception d’exécution.</span><span class="sxs-lookup"><span data-stu-id="35ff0-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="35ff0-170">Pour cette raison, vous ne devez référencer des packages .NET Framework que si aucune autre option n’est disponible et comprendre que cela impose une charge de test.</span><span class="sxs-lookup"><span data-stu-id="35ff0-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="35ff0-171">Si des packages référencés ne ciblent pas .NET Core ou .NET Standard, vous devez réfléchir à d’autres solutions :</span><span class="sxs-lookup"><span data-stu-id="35ff0-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="35ff0-172">Existe-t-il d’autres packages similaires qui peuvent être utilisés à la place ?</span><span class="sxs-lookup"><span data-stu-id="35ff0-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="35ff0-173">Parfois, les auteurs NuGet publient des’séparés'. Versions principales de leurs bibliothèques ciblant spécifiquement .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="35ff0-174">Les packages Enterprise Library sont un exemple de la publication de la communauté». Solutions Netcore».</span><span class="sxs-lookup"><span data-stu-id="35ff0-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="35ff0-175">Dans d’autres cas, des kits de développement logiciel récents pour un service particulier (parfois avec des noms de packages différents) sont disponibles pour .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="35ff0-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="35ff0-176">Si aucune solution n’est disponible, vous pouvez continuer à utiliser les packages ciblés .NET Framework, en sachant que vous devrez les tester minutieusement une fois exécuté sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="35ff0-177">L’exemple de courtier de haricot présente les dépendances NuGet de niveau supérieur suivantes :</span><span class="sxs-lookup"><span data-stu-id="35ff0-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="35ff0-178">**Castle. Windsor, version 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="35ff0-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="35ff0-179">Ce package cible .NET Standard 1,6, il fonctionne donc sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="35ff0-180">**Microsoft. CodeAnalysis. FxCopAnalyzers, version 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="35ff0-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="35ff0-181">Il s’agit d’un méta-package, donc il n’est pas évident de savoir immédiatement quelles plateformes il prend en charge, mais la [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indique que sa version la plus récente (2.9.2) fonctionnera pour les .NET Framework et .net core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="35ff0-182">**Nito. AsyncEx, version 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="35ff0-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="35ff0-183">Ce package ne cible pas .NET Core, mais la version 5,0 la plus récente le fait.</span><span class="sxs-lookup"><span data-stu-id="35ff0-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="35ff0-184">Cette opération est courante lors de la migration, car de nombreux packages NuGet ont récemment ajouté la prise en charge de .NET Standard, mais les anciennes versions de projet ne ciblent que les .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="35ff0-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="35ff0-185">Si la différence de version n’est qu’une différence de version mineure, il est souvent facile de procéder à une mise à niveau vers la version la plus récente.</span><span class="sxs-lookup"><span data-stu-id="35ff0-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="35ff0-186">Étant donné qu’il s’agit d’une modification de version majeure, vous devez effectuer une mise à niveau avec prudence, car il y a peut-être des modifications avec rupture dans le package.</span><span class="sxs-lookup"><span data-stu-id="35ff0-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="35ff0-187">Toutefois, un chemin d’accès est correct.</span><span class="sxs-lookup"><span data-stu-id="35ff0-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="35ff0-188">**MahApps. Metro, version 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="35ff0-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="35ff0-189">Ce package ne cible pas non plus .NET Core, mais dispose d’une version préliminaire plus récente (2,0-alpha).</span><span class="sxs-lookup"><span data-stu-id="35ff0-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="35ff0-190">Là encore, vous devez consulter les modifications avec rupture, mais le package le plus récent est encourageant.</span><span class="sxs-lookup"><span data-stu-id="35ff0-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="35ff0-191">Les dépendances NuGet de l’exemple de courtier Bean sont toutes deux cibles .NET Standard/. NET Core ou ont des versions plus récentes qui, par conséquent, il est peu probable qu’il y ait des problèmes de blocage ici.</span><span class="sxs-lookup"><span data-stu-id="35ff0-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="35ff0-192">Mettre à niveau les packages NuGet</span><span class="sxs-lookup"><span data-stu-id="35ff0-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="35ff0-193">Si possible, il serait judicieux de mettre à niveau les versions de tous les packages qui ciblent uniquement .NET Core ou .NET Standard avec des versions plus récentes à ce stade (avec le projet qui cible toujours .NET Framework) pour découvrir et résoudre les modifications avec rupture.</span><span class="sxs-lookup"><span data-stu-id="35ff0-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="35ff0-194">Si vous préférez ne pas apporter de modifications matérielles à la version .NET Framework existante de l’application, cela peut attendre jusqu’à ce que vous ayez un nouveau fichier projet ciblant .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="35ff0-195">Toutefois, la mise à niveau des packages NuGet vers des versions compatibles .NET Core à l’avance rend le processus de migration encore plus facile une fois que vous avez créé le nouveau fichier projet et réduit le nombre de différences entre les versions .NET Framework et .NET Core de l’application.</span><span class="sxs-lookup"><span data-stu-id="35ff0-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="35ff0-196">Avec l’exemple Bean responsable, toutes les mises à niveau nécessaires peuvent être effectuées facilement (à l’aide du gestionnaire de package NuGet de Visual Studio), à une exception près : la mise à niveau de **MahApps. Metro 1.6.5** vers **2,0** révèle des modifications avec rupture relatives aux API de gestion des thèmes et des accents.</span><span class="sxs-lookup"><span data-stu-id="35ff0-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="35ff0-197">Dans l’idéal, l’application est mise à jour pour utiliser la version la plus récente du package (car elle est plus susceptible de fonctionner sur .NET Core).</span><span class="sxs-lookup"><span data-stu-id="35ff0-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="35ff0-198">Dans certains cas, toutefois, cela peut ne pas être possible.</span><span class="sxs-lookup"><span data-stu-id="35ff0-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="35ff0-199">Dans ce cas, ne mettez pas à niveau **MahApps. Metro** , car les modifications nécessaires sont non triviales et ce didacticiel se concentre sur la migration vers .net Core 3, et non sur **MahApps. Metro 2.**</span><span class="sxs-lookup"><span data-stu-id="35ff0-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="35ff0-200">En outre, il s’agit d’une dépendance .NET Framework à faible risque, car l’application de l’opérateur du haricot n’exerce qu’une petite partie de **MahApps. Metro**.</span><span class="sxs-lookup"><span data-stu-id="35ff0-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="35ff0-201">Bien entendu, il est nécessaire de tester pour s’assurer que tout fonctionne une fois la migration terminée.</span><span class="sxs-lookup"><span data-stu-id="35ff0-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="35ff0-202">S’il s’agissait d’un scénario réaliste, il serait judicieux de créer un problème pour suivre le travail à migrer vers **MahApps. Metro** version 2,0, car la migration n’a pas été effectuée à l’heure actuelle.</span><span class="sxs-lookup"><span data-stu-id="35ff0-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="35ff0-203">Une fois les packages NuGet mis à jour vers les versions `<PackageReference>` récentes, le groupe d’éléments dans le fichier projet de l’exemple de courtier Bean doit ressembler à ce qui suit.</span><span class="sxs-lookup"><span data-stu-id="35ff0-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="35ff0-204">Analyse de la portabilité .NET Framework</span><span class="sxs-lookup"><span data-stu-id="35ff0-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="35ff0-205">Une fois que vous comprenez l’état des dépendances NuGet de votre projet, la prochaine chose à prendre en compte est .NET Framework les dépendances de l’API.</span><span class="sxs-lookup"><span data-stu-id="35ff0-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="35ff0-206">L’outil de l' [Analyseur de portabilité .net](../../standard/analyzers/portability-analyzer.md) est utile pour comprendre quelles API .net votre projet utilise sont disponibles sur d’autres plateformes .net.</span><span class="sxs-lookup"><span data-stu-id="35ff0-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="35ff0-207">L’outil se présente sous la forme d’un plug [-](https://github.com/Microsoft/dotnet-apiport/releases) [in Visual Studio](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), d’un outil de ligne de commande ou encapsulé dans une [interface graphique utilisateur simple](https://github.com/Microsoft/dotnet-apiport-ui), ce qui simplifie ses options.</span><span class="sxs-lookup"><span data-stu-id="35ff0-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="35ff0-208">Vous pouvez en savoir plus sur l’utilisation de l’analyseur de portabilité .NET (port d’API) à l’aide de l’interface graphique utilisateur dans le billet de blog [sur le portage des applications de bureau vers .net Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) .</span><span class="sxs-lookup"><span data-stu-id="35ff0-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="35ff0-209">Si vous préférez utiliser la ligne de commande, les étapes nécessaires sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="35ff0-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="35ff0-210">Téléchargez l' [Analyseur de portabilité .net](https://github.com/Microsoft/dotnet-apiport/releases) si vous ne l’avez pas déjà.</span><span class="sxs-lookup"><span data-stu-id="35ff0-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="35ff0-211">Assurez-vous que l’application de .NET Framework est correctement reportée (il s’agit d’une bonne idée avant la migration).</span><span class="sxs-lookup"><span data-stu-id="35ff0-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="35ff0-212">Exécutez le port de l’API avec une ligne de commande telle que celle-ci.</span><span class="sxs-lookup"><span data-stu-id="35ff0-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="35ff0-213">L' `-f` argument spécifie le chemin d’accès contenant les fichiers binaires à analyser.</span><span class="sxs-lookup"><span data-stu-id="35ff0-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="35ff0-214">L' `-r` argument spécifie le format de fichier de sortie souhaité.</span><span class="sxs-lookup"><span data-stu-id="35ff0-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="35ff0-215">L' `-t` argument spécifie la plateforme .net sur laquelle analyser l’utilisation de l’API.</span><span class="sxs-lookup"><span data-stu-id="35ff0-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="35ff0-216">Dans ce cas, vous devez utiliser .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="35ff0-217">Lorsque vous ouvrez le rapport HTML, la première section répertorie tous les fichiers binaires analysés et le pourcentage des API .NET qu’ils utilisent sur la plateforme ciblée.</span><span class="sxs-lookup"><span data-stu-id="35ff0-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="35ff0-218">Le pourcentage n’est pas significatif par lui-même.</span><span class="sxs-lookup"><span data-stu-id="35ff0-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="35ff0-219">Ce qui est plus utile est de voir les API spécifiques qui sont manquantes.</span><span class="sxs-lookup"><span data-stu-id="35ff0-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="35ff0-220">Pour ce faire, sélectionnez un nom d’assembly ou faites défiler les rapports pour obtenir des assemblys individuels.</span><span class="sxs-lookup"><span data-stu-id="35ff0-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="35ff0-221">Concentrez-vous sur les assemblys pour lesquels vous possédez le code source.</span><span class="sxs-lookup"><span data-stu-id="35ff0-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="35ff0-222">Dans le rapport ApiPort de l’opérateur Bean, par exemple, de nombreux fichiers binaires sont répertoriés, mais la plupart d’entre eux appartiennent à des packages NuGet.</span><span class="sxs-lookup"><span data-stu-id="35ff0-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="35ff0-223">`Castle.Windsor`indique qu’il dépend de certaines API System. Web manquantes dans .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="35ff0-224">Ce n’est pas un problème, car vous `Castle.Windsor` avez déjà vérifié que prend en charge .net core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="35ff0-225">Il est courant que les packages NuGet aient des binaires différents à utiliser avec différentes plateformes .NET. par conséquent, si `Castle.Windsor` la version .NET Framework de utilise des API System. Web ou non n’est pas pertinente tant que le package cible également .NET standard ou .net Core (ce qu’elle fait).</span><span class="sxs-lookup"><span data-stu-id="35ff0-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="35ff0-226">Avec l’exemple de courtier de haricot, le seul binaire que vous devez prendre en compte est **BeanTraderClient** et le rapport montre que seules deux API .NET `System.ServiceModel.ClientBase<T>.Close` sont `System.ServiceModel.ClientBase<T>.Open`manquantes : et.</span><span class="sxs-lookup"><span data-stu-id="35ff0-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![Rapport de portabilité BeanTraderClient](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="35ff0-228">Il est peu probable qu’il y ait des problèmes de blocage, car les API clientes WCF sont (principalement) prises en charge sur .NET Core. elles doivent donc être disponibles pour ces API centrales.</span><span class="sxs-lookup"><span data-stu-id="35ff0-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="35ff0-229">En fait, en observant `System.ServiceModel`la surface d’exposition .net Core <https://apisof.net>(à l’aide de), vous constatez qu’il existe des alternatives Async dans .net core à la place.</span><span class="sxs-lookup"><span data-stu-id="35ff0-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="35ff0-230">Sur la base de ce rapport et de l’analyse de dépendance NuGet précédente, il semblerait qu’il n’y ait pas de problèmes majeurs lors de la migration de l’exemple de courtier Bean vers .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="35ff0-231">Vous êtes prêt pour l’étape suivante dans laquelle vous allez démarrer la migration.</span><span class="sxs-lookup"><span data-stu-id="35ff0-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="35ff0-232">Migration du fichier projet</span><span class="sxs-lookup"><span data-stu-id="35ff0-232">Migrating the project file</span></span>

<span data-ttu-id="35ff0-233">Si votre application n’utilise pas le nouveau [format de fichier projet de type SDK](../../core/tools/csproj.md), vous aurez besoin d’un nouveau fichier projet pour cibler .net core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="35ff0-234">Vous pouvez remplacer le fichier csproj existant ou, si vous préférez conserver le projet existant intact dans son état actuel, vous pouvez ajouter un nouveau fichier csproj ciblant .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="35ff0-235">Vous pouvez créer des versions de l’application pour .NET Framework et .NET Core avec un seul fichier projet de type SDK avec [multi-ciblage](../../standard/library-guidance/cross-platform-targeting.md) (en `<TargetFrameworks>` spécifiant plusieurs cibles).</span><span class="sxs-lookup"><span data-stu-id="35ff0-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="35ff0-236">Pour créer le nouveau fichier projet, vous pouvez créer un projet WPF dans Visual Studio ou utiliser la `dotnet new wpf` commande dans un répertoire temporaire pour générer le fichier projet, puis le copier/le renommer à l’emplacement correct.</span><span class="sxs-lookup"><span data-stu-id="35ff0-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="35ff0-237">Il existe également un outil créé par la Communauté, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), qui permet d’automatiser une partie de la migration des fichiers projet.</span><span class="sxs-lookup"><span data-stu-id="35ff0-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="35ff0-238">L’outil est utile, mais il a toujours besoin d’un homme pour passer en revue les résultats afin de s’assurer que tous les détails de la migration sont corrects.</span><span class="sxs-lookup"><span data-stu-id="35ff0-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="35ff0-239">L’outil ne gère pas de manière optimale les packages NuGet à partir des fichiers *packages. config* .</span><span class="sxs-lookup"><span data-stu-id="35ff0-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="35ff0-240">Si l’outil s’exécute sur un fichier projet qui utilise toujours un fichier *packages. config* pour faire référence à des packages NuGet, `<PackageReference>` il migre automatiquement vers les `<PackageReference>` éléments, mais il ajoute des éléments pour tous les packages, et non uniquement pour *les* éléments de niveau supérieur.</span><span class="sxs-lookup"><span data-stu-id="35ff0-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="35ff0-241">Si vous avez déjà migré vers`<PackageReference>` des éléments avec Visual Studio (comme vous l’avez fait dans cet exemple), l’outil peut vous aider dans le reste de la conversion.</span><span class="sxs-lookup"><span data-stu-id="35ff0-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="35ff0-242">Comme Scott Hanselman recommande dans [son billet de blog sur la migration de fichiers csproj, le](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx)Portage à la main est éducatif et donnera de meilleurs résultats si vous n’avez que quelques projets à porter.</span><span class="sxs-lookup"><span data-stu-id="35ff0-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="35ff0-243">Toutefois, si vous portez des dizaines ou des centaines de fichiers de projet, un outil tel que [CsprojToVs2017] peut être une aide.</span><span class="sxs-lookup"><span data-stu-id="35ff0-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="35ff0-244">Pour créer un nouveau fichier projet pour l’exemple Bean responsable, exécutez `dotnet new wpf` dans un répertoire temporaire et déplacez le fichier *. csproj* généré dans le dossier *BeanTraderClient* et renommez-le **BeanTraderClient. Core. csproj**.</span><span class="sxs-lookup"><span data-stu-id="35ff0-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="35ff0-245">Étant donné que le nouveau format de fichier projet comprend automatiquement des fichiers C#, des fichiers *resx* et des fichiers XAML qu’il trouve dans ou sous son répertoire, le fichier projet est déjà presque terminé.</span><span class="sxs-lookup"><span data-stu-id="35ff0-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="35ff0-246">Pour terminer la migration, ouvrez les fichiers de projet anciens et nouveaux côte à côte, puis examinez l’ancien pour voir si les informations qu’il contient doivent être migrées.</span><span class="sxs-lookup"><span data-stu-id="35ff0-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="35ff0-247">Dans l’exemple de cas d’opérateur Bean, les éléments suivants doivent être copiés dans le nouveau projet :</span><span class="sxs-lookup"><span data-stu-id="35ff0-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="35ff0-248">Les `<RootNamespace>`propriétés `<AssemblyName>`, et `<ApplicationIcon>` doivent toutes être copiées.</span><span class="sxs-lookup"><span data-stu-id="35ff0-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="35ff0-249">Vous devez également ajouter une `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` propriété au nouveau fichier projet, car l’exemple de courtier de haricot comprend des attributs au niveau de `[AssemblyTitle]`l’assembly (comme) dans un fichier AssemblyInfo.cs.</span><span class="sxs-lookup"><span data-stu-id="35ff0-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="35ff0-250">Par défaut, les nouveaux projets de type SDK génèrent automatiquement ces attributs en fonction des propriétés du fichier csproj.</span><span class="sxs-lookup"><span data-stu-id="35ff0-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="35ff0-251">Comme vous ne voulez pas que cela se produise dans ce cas (les attributs générés automatiquement sont en conflit avec ceux de AssemblyInfo.cs), vous désactivez les attributs générés automatiquement avec `<GenerateAssemblyInfo>`.</span><span class="sxs-lookup"><span data-stu-id="35ff0-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="35ff0-252">Bien que les fichiers *resx* soient automatiquement inclus en tant que `<Resource>` ressources incorporées, les autres éléments tels que les images ne le sont pas.</span><span class="sxs-lookup"><span data-stu-id="35ff0-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="35ff0-253">Copiez donc les `<Resource>` éléments pour l’incorporation des fichiers d’image et d’icône.</span><span class="sxs-lookup"><span data-stu-id="35ff0-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="35ff0-254">Vous pouvez simplifier les références png à une seule ligne à l’aide de la prise en charge du nouveau format de fichier `<Resource Include="**\*.png" />`projet pour les modèles globbing :.</span><span class="sxs-lookup"><span data-stu-id="35ff0-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="35ff0-255">De même, `<None>` les éléments sont inclus automatiquement, mais ils ne sont pas copiés dans le répertoire de sortie, par défaut.</span><span class="sxs-lookup"><span data-stu-id="35ff0-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="35ff0-256">Étant donné que le projet Bean opérateur `<None>` comprend un élément qui *est* copié dans le répertoire de `PreserveNewest` sortie (à l’aide de comportements), vous devez `<None>` mettre à jour l’élément rempli automatiquement pour ce fichier, comme ceci.</span><span class="sxs-lookup"><span data-stu-id="35ff0-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="35ff0-257">L’exemple Bean opérateur comprend un fichier XAML (default. accent. Xaml) en `Content` tant que (plutôt que `Page`), car les thèmes et les accents définis dans ce fichier sont chargés à partir du XAML du fichier au moment de l’exécution, au lieu d’être incorporés dans l’application elle-même.</span><span class="sxs-lookup"><span data-stu-id="35ff0-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="35ff0-258">Toutefois, le nouveau système de projet comprend automatiquement ce `<Page>`fichier en tant que fichier XAML.</span><span class="sxs-lookup"><span data-stu-id="35ff0-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="35ff0-259">Vous devez donc supprimer le fichier XAML en tant que page (`<Page Remove="**\Default.Accent.xaml" />`) et l’ajouter en tant que contenu.</span><span class="sxs-lookup"><span data-stu-id="35ff0-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="35ff0-260">Enfin, ajoutez des références NuGet en copiant `<ItemGroup>` le avec tous `<PackageReference>` les éléments.</span><span class="sxs-lookup"><span data-stu-id="35ff0-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="35ff0-261">Si vous n’aviez pas précédemment mis à niveau les packages NuGet vers des versions compatibles avec .NET Core, vous pouviez le faire maintenant que les références de package se trouvent dans un projet .NET Core spécifique.</span><span class="sxs-lookup"><span data-stu-id="35ff0-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="35ff0-262">À ce stade, il doit être possible d’ajouter le nouveau projet à la solution BeanTrader et de l’ouvrir dans Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="35ff0-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="35ff0-263">Le projet doit être correct dans **Explorateur de solutions**et `dotnet restore BeanTraderClient.Core.csproj` doit restaurer correctement les packages (avec deux avertissements attendus liés à la version MahApps. Metro que vous utilisez pour cibler .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="35ff0-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="35ff0-264">Bien qu’il soit possible de conserver les deux fichiers de projet côte à côte (et peut même être souhaitable si vous souhaitez continuer à générer l’ancien projet exactement tel qu’il était), cela complique le processus de migration (les deux projets essaieront d’utiliser les mêmes dossiers bin et obj) et ne sont généralement pas nécessaires.</span><span class="sxs-lookup"><span data-stu-id="35ff0-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="35ff0-265">Si vous souhaitez générer pour les cibles .NET Core et .NET Framework, vous pouvez remplacer la `<TargetFramework>netcoreapp3.0</TargetFramework>` propriété dans le nouveau fichier projet par à `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` la place.</span><span class="sxs-lookup"><span data-stu-id="35ff0-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="35ff0-266">Pour l’exemple Bean responsable, supprimez l’ancien fichier de projet (BeanTraderClient. csproj), car il n’est plus nécessaire.</span><span class="sxs-lookup"><span data-stu-id="35ff0-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="35ff0-267">Si vous préférez conserver les deux fichiers de projet, assurez-vous qu’ils sont générés sur différents chemins de sortie et de sortie intermédiaires.</span><span class="sxs-lookup"><span data-stu-id="35ff0-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="35ff0-268">Résoudre les problèmes de build</span><span class="sxs-lookup"><span data-stu-id="35ff0-268">Fix build issues</span></span>

<span data-ttu-id="35ff0-269">La troisième étape du processus de Portage consiste à obtenir le projet à générer.</span><span class="sxs-lookup"><span data-stu-id="35ff0-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="35ff0-270">Certaines applications sont déjà générées correctement une fois que le fichier projet est converti en projet de type SDK.</span><span class="sxs-lookup"><span data-stu-id="35ff0-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="35ff0-271">Si c’est le cas pour votre application, félicitations !</span><span class="sxs-lookup"><span data-stu-id="35ff0-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="35ff0-272">Vous pouvez passer à l’étape 4.</span><span class="sxs-lookup"><span data-stu-id="35ff0-272">You can go on to Step 4.</span></span> <span data-ttu-id="35ff0-273">D’autres applications auront besoin de certaines mises à jour pour les mettre en œuvre pour .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="35ff0-274">Si vous essayez d’exécuter `dotnet build` l’exemple de projet Bean opérateur maintenant, par exemple (ou de le générer dans Visual Studio), il y aura de nombreuses erreurs, mais vous les obtiendrez rapidement fixe.</span><span class="sxs-lookup"><span data-stu-id="35ff0-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="35ff0-275">System. ServiceModel fait référence à et Microsoft. Windows. Compatibility</span><span class="sxs-lookup"><span data-stu-id="35ff0-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="35ff0-276">Il manque des références pour les API qui sont disponibles pour .NET Core, mais qui ne sont pas automatiquement incluses dans le package d’application .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="35ff0-277">Pour résoudre ce cas, vous devez référencer le `Microsoft.Windows.Compatibility` package.</span><span class="sxs-lookup"><span data-stu-id="35ff0-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="35ff0-278">Le package de compatibilité comprend un large éventail d’API qui sont courantes dans les applications de bureau Windows, telles que le client WCF, les services d’annuaire, le registre, la configuration, les API de listes de contrôle d’accès (ACL) et bien plus encore.</span><span class="sxs-lookup"><span data-stu-id="35ff0-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="35ff0-279">Avec l’exemple Bean d’opérateur, la majorité des erreurs de build sont dues à <xref:System.ServiceModel> des types manquants.</span><span class="sxs-lookup"><span data-stu-id="35ff0-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="35ff0-280">Ils peuvent être traités en référençant les packages NuGet WCF nécessaires.</span><span class="sxs-lookup"><span data-stu-id="35ff0-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="35ff0-281">Toutefois, les API clientes WCF sont parmi `Microsoft.Windows.Compatibility` celles présentes dans le package. par conséquent, le fait de référencer le package de compatibilité est une solution encore meilleure (puisqu’il résout également les problèmes liés aux API, ainsi que les solutions aux problèmes WCF que le package de compatibilité rend disponible).</span><span class="sxs-lookup"><span data-stu-id="35ff0-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="35ff0-282">Le `Microsoft.Windows.Compatibility` package vous aide dans la plupart des scénarios de Portage .net Core 3,0 WPF et WinForms.</span><span class="sxs-lookup"><span data-stu-id="35ff0-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="35ff0-283">Après l’ajout de la référence `Microsoft.Windows.Compatibility`NuGet à, une seule erreur de build est conservée.</span><span class="sxs-lookup"><span data-stu-id="35ff0-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="35ff0-284">Nettoyage des fichiers inutilisés</span><span class="sxs-lookup"><span data-stu-id="35ff0-284">Cleaning up unused files</span></span>

<span data-ttu-id="35ff0-285">L’un des types de problèmes de migration qui s’affichent est souvent lié aux fichiers C# et XAML qui n’étaient pas inclus précédemment dans la build qui a été récupéré par les nouveaux projets de type SDK qui incluent *toutes les* sources automatiquement.</span><span class="sxs-lookup"><span data-stu-id="35ff0-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="35ff0-286">L’erreur de build suivante que vous voyez dans l’exemple de courtier de haricot fait référence à une implémentation d’interface incorrecte dans *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="35ff0-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="35ff0-287">Le nom de fichier est un indicateur, mais à l’inspection, vous constaterez que ce fichier source est incorrect.</span><span class="sxs-lookup"><span data-stu-id="35ff0-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="35ff0-288">Il n’a pas provoqué les problèmes précédemment, car il n’était pas inclus dans le projet d' .NET Framework d’origine.</span><span class="sxs-lookup"><span data-stu-id="35ff0-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="35ff0-289">Les fichiers sources qui étaient présents sur le disque mais non inclus dans l’ancien *csproj* sont maintenant inclus automatiquement.</span><span class="sxs-lookup"><span data-stu-id="35ff0-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="35ff0-290">Pour les problèmes uniques comme celui-ci, il est facile de le comparer au *csproj* précédent pour confirmer que le fichier n’est pas nécessaire, `<Compile Remove="" />` puis, si le fichier source n’est plus nécessaire, supprimez-le.</span><span class="sxs-lookup"><span data-stu-id="35ff0-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="35ff0-291">Dans ce cas, il est préférable de simplement supprimer *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="35ff0-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="35ff0-292">Si vous avez de nombreux fichiers sources qui doivent être exclus de cette manière, vous pouvez désactiver l’inclusion automatique des fichiers C# en affectant `<EnableDefaultCompileItems>` à la propriété la valeur false dans le fichier projet.</span><span class="sxs-lookup"><span data-stu-id="35ff0-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="35ff0-293">Ensuite, vous pouvez copier `<Compile Include>` des éléments de l’ancien fichier projet vers le nouveau, afin de générer uniquement les sources que vous souhaitez inclure.</span><span class="sxs-lookup"><span data-stu-id="35ff0-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="35ff0-294">De même, `<EnableDefaultPageItems>` peut être utilisé pour désactiver l’insertion automatique des pages XAML et `<EnableDefaultItems>` peut contrôler les deux avec une seule propriété.</span><span class="sxs-lookup"><span data-stu-id="35ff0-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="35ff0-295">Un court de côté sur les compilateurs à plusieurs passes</span><span class="sxs-lookup"><span data-stu-id="35ff0-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="35ff0-296">Après avoir supprimé le fichier incriminé de l’exemple Bean responsable, vous pouvez regénérer et afficher quatre erreurs.</span><span class="sxs-lookup"><span data-stu-id="35ff0-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="35ff0-297">Vous ne l’avez pas encore fait ?</span><span class="sxs-lookup"><span data-stu-id="35ff0-297">Didn't you have one before?</span></span> <span data-ttu-id="35ff0-298">Pourquoi le nombre d’erreurs est-il atteint ?</span><span class="sxs-lookup"><span data-stu-id="35ff0-298">Why did the number of errors go up?</span></span> <span data-ttu-id="35ff0-299">Le compilateur C# est un [compilateur à plusieurs passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span><span class="sxs-lookup"><span data-stu-id="35ff0-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="35ff0-300">Cela signifie qu’il parcourt chaque fichier source à deux reprises.</span><span class="sxs-lookup"><span data-stu-id="35ff0-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="35ff0-301">Tout d’abord, le compilateur examine simplement les métadonnées et les déclarations dans chaque fichier source et identifie les problèmes au niveau de la déclaration.</span><span class="sxs-lookup"><span data-stu-id="35ff0-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="35ff0-302">Il s’agit des erreurs que vous avez résolues.</span><span class="sxs-lookup"><span data-stu-id="35ff0-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="35ff0-303">Ensuite, il parcourt à nouveau le code pour générer la source C# dans IL. Il s’agit du deuxième ensemble d’erreurs que vous êtes en train de voir.</span><span class="sxs-lookup"><span data-stu-id="35ff0-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="35ff0-304">Le compilateur C# effectue [plus que deux passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), mais le résultat final est que les erreurs de compilateur pour les modifications de code volumineuses, telles que celles-ci, ont tendance à être en deux vagues.</span><span class="sxs-lookup"><span data-stu-id="35ff0-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="35ff0-305">Correctifs de dépendance tiers (Castle. Windsor)</span><span class="sxs-lookup"><span data-stu-id="35ff0-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="35ff0-306">Une autre classe de problème qui s’affiche dans certains scénarios de migration est l’API différences entre .NET Framework et les versions .NET Core des dépendances.</span><span class="sxs-lookup"><span data-stu-id="35ff0-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="35ff0-307">Même si un package NuGet cible à la fois .NET Framework et .NET Standard ou .NET Core, il peut y avoir différentes bibliothèques à utiliser avec différentes cibles .NET.</span><span class="sxs-lookup"><span data-stu-id="35ff0-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="35ff0-308">Cela permet aux packages de prendre en charge de nombreuses plateformes .NET différentes, ce qui peut nécessiter des implémentations différentes.</span><span class="sxs-lookup"><span data-stu-id="35ff0-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="35ff0-309">Cela signifie également qu’il peut y avoir de petites différences d’API dans les bibliothèques lors du ciblage de différentes plateformes .NET.</span><span class="sxs-lookup"><span data-stu-id="35ff0-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="35ff0-310">L’ensemble suivant d’erreurs que vous verrez dans l’exemple de courtier de haricot `Castle.Windsor` est lié aux API.</span><span class="sxs-lookup"><span data-stu-id="35ff0-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="35ff0-311">Le projet .NET Core Bean opérateur utilise la même version de `Castle.Windsor` que le projet de .NET Framework ciblé (4.1.1), mais les implémentations de ces deux plateformes sont légèrement différentes.</span><span class="sxs-lookup"><span data-stu-id="35ff0-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="35ff0-312">Dans ce cas, vous voyez les problèmes suivants qui doivent être résolus :</span><span class="sxs-lookup"><span data-stu-id="35ff0-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="35ff0-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`n’est pas disponible sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="35ff0-314">Toutefois `Classes.FromAssemblyContaining` , l’API similaire est disponible. par conséquent, nous pouvons remplacer les deux utilisations `Classes.FromThisAssembly()` de par des `Classes.FromAssemblyContaining(t)`appels à `t` , où est le type effectuant l’appel.</span><span class="sxs-lookup"><span data-stu-id="35ff0-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="35ff0-315">De même, dans *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`. Cela n’est pas disponible sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="35ff0-316">Au lieu de cela, cet appel peut `FromAssembly.Containing(typeof(Bootstrapper))`être remplacé par.</span><span class="sxs-lookup"><span data-stu-id="35ff0-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="35ff0-317">Mise à jour de l’utilisation du client WCF</span><span class="sxs-lookup"><span data-stu-id="35ff0-317">Updating WCF client usage</span></span>

<span data-ttu-id="35ff0-318">Après avoir corrigé `Castle.Windsor` les différences, la dernière erreur de build restante dans le projet .net Core `BeanTraderServiceClient` Bean opérateur est que ( `DuplexClientBase`qui dérive de `Open` ) n’a pas de méthode.</span><span class="sxs-lookup"><span data-stu-id="35ff0-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="35ff0-319">Cela n’est pas surprenant, car il s’agit d’une API qui a été mise en surbrillance par l’analyseur de portabilité .NET au début de ce processus de migration.</span><span class="sxs-lookup"><span data-stu-id="35ff0-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="35ff0-320">`BeanTraderServiceClient` Toutefois, nous allons attirer notre attention sur un problème plus important.</span><span class="sxs-lookup"><span data-stu-id="35ff0-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="35ff0-321">Ce client WCF a été généré automatiquement par l’outil [Svcutil. exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) .</span><span class="sxs-lookup"><span data-stu-id="35ff0-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="35ff0-322">**Les clients WCF générés par Svcutil sont destinés à être utilisés sur .NET Framework.**</span><span class="sxs-lookup"><span data-stu-id="35ff0-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="35ff0-323">Les solutions qui utilisent des clients WCF générés par Svcutil devront régénérer les clients compatibles .NET Standard pour une utilisation avec .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="35ff0-324">L’une des principales raisons pour lesquelles les anciens clients ne fonctionneront pas est qu’ils dépendent de la configuration des applications pour définir des liaisons et des points de terminaison WCF.</span><span class="sxs-lookup"><span data-stu-id="35ff0-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="35ff0-325">Étant donné que les API .NET Standard WCF peuvent fonctionner sur plusieurs plateformes (où les API System. configuration ne sont pas disponibles), les clients WCF pour les scénarios .NET Core et .NET Standard doivent définir des liaisons et des points de terminaison par programme plutôt que dans la configuration.</span><span class="sxs-lookup"><span data-stu-id="35ff0-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="35ff0-326">En fait, toute utilisation du client WCF qui dépend de `<system.serviceModel>` la section App. config (qu’elle soit créée avec Svcutil ou manuellement) doit être modifiée pour fonctionner sur .net core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="35ff0-327">Il existe deux façons de générer automatiquement des clients WCF compatibles .NET Standard :</span><span class="sxs-lookup"><span data-stu-id="35ff0-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="35ff0-328">L' `dotnet-svcutil` outil est un outil .net qui génère des clients WCF d’une manière similaire à la façon dont Svcutil fonctionnait précédemment.</span><span class="sxs-lookup"><span data-stu-id="35ff0-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="35ff0-329">Visual Studio peut générer des clients WCF à l’aide de l’option de [référence de service Web WCF](../../core/additional-tools/wcf-web-service-reference-guide.md) de sa fonctionnalité services connectés.</span><span class="sxs-lookup"><span data-stu-id="35ff0-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="35ff0-330">L’une ou l’autre approche fonctionne bien.</span><span class="sxs-lookup"><span data-stu-id="35ff0-330">Either approach works well.</span></span> <span data-ttu-id="35ff0-331">Vous pouvez également écrire le code client WCF vous-même.</span><span class="sxs-lookup"><span data-stu-id="35ff0-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="35ff0-332">Pour cet exemple, j’ai choisi d’utiliser la fonctionnalité de service connecté de Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="35ff0-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="35ff0-333">Pour ce faire, cliquez avec le bouton droit sur le projet *BeanTraderClient. Core* dans l’Explorateur de solutions de Visual Studio, puis sélectionnez **Ajouter** > un**service connecté**.</span><span class="sxs-lookup"><span data-stu-id="35ff0-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="35ff0-334">Ensuite, choisissez le fournisseur de référence de service Web WCF.</span><span class="sxs-lookup"><span data-stu-id="35ff0-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="35ff0-335">Une boîte de dialogue s’affiche alors, dans laquelle vous pouvez spécifier l’adresse du service Web de l'`localhost:8080` opérateur du serveur principal Bean (si vous exécutez le serveur localement) et l’espace de noms que les types générés doivent utiliser (**BeanTrader. service**, par exemple).</span><span class="sxs-lookup"><span data-stu-id="35ff0-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![Boîte de dialogue service connecté de référence de service Web WCF](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="35ff0-337">Une fois que vous avez sélectionné le bouton **Terminer** , un nouveau nœud de services connectés est ajouté au projet et un fichier Reference.cs est ajouté sous ce nœud contenant le nouveau client WCF .NET standard pour l’accès au service Bean opérateur.</span><span class="sxs-lookup"><span data-stu-id="35ff0-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="35ff0-338">Si vous examinez les `GetEndpointAddress` méthodes `GetBindingForEndpoint` ou dans ce fichier, vous verrez que les liaisons et les points de terminaison sont maintenant générés par programmation (au lieu de via la configuration de l’application).</span><span class="sxs-lookup"><span data-stu-id="35ff0-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="35ff0-339">La fonctionnalité « Ajouter un Services connectés » peut également ajouter des références à certains packages System. ServiceModel dans le fichier projet, ce qui n’est pas nécessaire, car tous les packages WCF nécessaires sont inclus par le biais de Microsoft. Windows. Compatibility.</span><span class="sxs-lookup"><span data-stu-id="35ff0-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="35ff0-340">Vérifiez si des éléments System. ServiceModel `<PackageReference>` supplémentaires ont été ajoutés dans le csproj et, le cas échéant, supprimez-les.</span><span class="sxs-lookup"><span data-stu-id="35ff0-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="35ff0-341">Notre projet a de nouvelles classes de client WCF maintenant (dans *Reference.cs*), mais il contient toujours les anciens (dans BeanTrader.cs).</span><span class="sxs-lookup"><span data-stu-id="35ff0-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="35ff0-342">Il existe deux options à ce stade :</span><span class="sxs-lookup"><span data-stu-id="35ff0-342">There are two options at this point:</span></span>

- <span data-ttu-id="35ff0-343">Si vous souhaitez être en mesure de générer le projet de .NET Framework d’origine (parallèlement au nouveau .NET Core), vous pouvez utiliser un `<Compile Remove="BeanTrader.cs" />` élément dans le fichier csproj du projet .net Core afin que les versions .NET Framework et .net Core de l’application utilisent différents clients WCF.</span><span class="sxs-lookup"><span data-stu-id="35ff0-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="35ff0-344">Cela présente l’avantage de laisser le projet de .NET Framework existant inchangé, mais présente l’inconvénient que le code qui utilise les clients WCF générés peut avoir besoin d’être légèrement différent dans le cas .NET Core que dans le projet .NET Framework. il est donc probable que `#if` vous deviez utiliser des directives pour compiler de façon conditionnelle une utilisation du client WCF (en créant des clients, par exemple) pour qu’ils fonctionnent de façon unidirectionnelle lorsqu’ils sont générés pour .net core. .NET Framework</span><span class="sxs-lookup"><span data-stu-id="35ff0-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="35ff0-345">Si, en revanche, une certaine évolution du code dans le projet de .NET Framework existant est acceptable, vous pouvez supprimer tous les *BeanTrader.cs* ensemble.</span><span class="sxs-lookup"><span data-stu-id="35ff0-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="35ff0-346">Étant donné que le nouveau client WCF est conçu pour .NET Standard, il fonctionnera à la fois dans les scénarios .NET Core et .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="35ff0-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="35ff0-347">Si vous générez pour .NET Framework en plus de .NET Core (soit par le biais du multi-ciblage, soit en utilisant deux fichiers csproj), vous pouvez utiliser ce nouveau fichier *Reference.cs* pour les deux cibles.</span><span class="sxs-lookup"><span data-stu-id="35ff0-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="35ff0-348">Cette approche présente l’avantage que le code n’a pas besoin de bifurquer pour prendre en charge deux clients WCF différents. le même code sera utilisé partout.</span><span class="sxs-lookup"><span data-stu-id="35ff0-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="35ff0-349">L’inconvénient est qu’il implique de modifier le projet de .NET Framework (vraisemblablement stable).</span><span class="sxs-lookup"><span data-stu-id="35ff0-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="35ff0-350">Dans le cas de l’exemple de courtier de haricot, vous pouvez apporter des modifications mineures au projet d’origine. si cela facilite la migration, procédez comme suit pour rapprocher l’utilisation du client WCF :</span><span class="sxs-lookup"><span data-stu-id="35ff0-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="35ff0-351">Ajoutez le nouveau fichier Reference.cs à la .NET Framework projet *BeanTraderClient. csproj* à l’aide du menu contextuel’ajouter un élément existant’de l’Explorateur de solutions.</span><span class="sxs-lookup"><span data-stu-id="35ff0-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="35ff0-352">Veillez à ajouter « As Link » pour que le même fichier soit utilisé par les deux projets (par opposition à la copie du fichier C#).</span><span class="sxs-lookup"><span data-stu-id="35ff0-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="35ff0-353">Si vous générez pour .NET Core et .NET Framework avec un seul csproj (à l’aide du multi-ciblage), cette étape n’est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="35ff0-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="35ff0-354">Supprimez *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="35ff0-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="35ff0-355">Le nouveau client WCF est similaire à l’ancien, mais un certain nombre d’espaces de noms dans le code généré sont différents.</span><span class="sxs-lookup"><span data-stu-id="35ff0-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="35ff0-356">Pour cette raison, il est nécessaire de mettre à jour le projet afin que les types de clients WCF soient utilisés à partir de BeanTrader. service (ou du nom d’espace de noms que vous avez choisi) au lieu de BeanTrader. Model ou sans espace de noms.</span><span class="sxs-lookup"><span data-stu-id="35ff0-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="35ff0-357">La génération de *BeanTraderClient. Core. csproj* vous aidera à identifier l’endroit où ces modifications doivent être apportées.</span><span class="sxs-lookup"><span data-stu-id="35ff0-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="35ff0-358">Les correctifs seront nécessaires en C# et dans les fichiers sources XAML.</span><span class="sxs-lookup"><span data-stu-id="35ff0-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="35ff0-359">Enfin, vous découvrirez qu’il y a une erreur dans *BeanTraderServiceClientFactory.cs* , car les constructeurs disponibles pour `BeanTraderServiceClient` le type ont changé.</span><span class="sxs-lookup"><span data-stu-id="35ff0-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="35ff0-360">Il était possible de fournir un `InstanceContext` argument (qui a été créé à l’aide `CallbackHandler` d’un `Castle.Windsor` à partir du conteneur IOC).</span><span class="sxs-lookup"><span data-stu-id="35ff0-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="35ff0-361">Les nouveaux constructeurs créent de nouveaux `CallbackHandler`.</span><span class="sxs-lookup"><span data-stu-id="35ff0-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="35ff0-362">Toutefois, il existe des constructeurs dans `BeanTraderServiceClient`le type de base de qui correspondent à ce que vous souhaitez.</span><span class="sxs-lookup"><span data-stu-id="35ff0-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="35ff0-363">Étant donné que le code client WCF généré automatiquement se trouve dans des classes partielles, vous pouvez facilement l’étendre.</span><span class="sxs-lookup"><span data-stu-id="35ff0-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="35ff0-364">Pour ce faire, créez un nouveau fichier appelé *BeanTraderServiceClient.cs* , puis créez une classe partielle portant ce même nom (à l’aide de l’espace de noms BeanTrader. service).</span><span class="sxs-lookup"><span data-stu-id="35ff0-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="35ff0-365">Ajoutez ensuite un constructeur au type partiel comme indiqué ici.</span><span class="sxs-lookup"><span data-stu-id="35ff0-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="35ff0-366">Avec ces modifications apportées, l’exemple de courtier Bean utilisera désormais un nouveau client WCF compatible avec la .NET Standard. vous pouvez donc utiliser `Open` `await OpenAsync` à la place le correctif final pour modifier l’appel dans *TradingService.cs* .</span><span class="sxs-lookup"><span data-stu-id="35ff0-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="35ff0-367">Avec les problèmes WCF résolus, la version .NET Core de l’exemple de courtier de haricot est désormais générée correctement.</span><span class="sxs-lookup"><span data-stu-id="35ff0-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="35ff0-368">Test du Runtime</span><span class="sxs-lookup"><span data-stu-id="35ff0-368">Runtime testing</span></span>

<span data-ttu-id="35ff0-369">Il est facile d’oublier que le travail de migration n’est pas effectué dès que le projet est généré proprement sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="35ff0-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="35ff0-370">Il est également important de garder le temps de tester l’application portée.</span><span class="sxs-lookup"><span data-stu-id="35ff0-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="35ff0-371">Une fois que les opérations sont correctement générées, assurez-vous que l’application s’exécute et fonctionne comme prévu, en particulier si vous utilisez des packages ciblant .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="35ff0-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="35ff0-372">Nous allons essayer de lancer l’application de l’opérateur de l’opérateur du rôle de haricot et de voir ce qui se passe.</span><span class="sxs-lookup"><span data-stu-id="35ff0-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="35ff0-373">L’application n’a pas beaucoup de succès avant d’échouer avec l’exception suivante.</span><span class="sxs-lookup"><span data-stu-id="35ff0-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="35ff0-374">Cela paraît logique, bien sûr.</span><span class="sxs-lookup"><span data-stu-id="35ff0-374">This makes sense, of course.</span></span> <span data-ttu-id="35ff0-375">N’oubliez pas que WCF n’utilise plus la configuration d’application, de sorte que l’ancienne section System. serviceModel du fichier app. config doit être supprimée.</span><span class="sxs-lookup"><span data-stu-id="35ff0-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="35ff0-376">Le client WCF mis à jour contient toutes les mêmes informations dans son code, donc la section de configuration n’est plus nécessaire.</span><span class="sxs-lookup"><span data-stu-id="35ff0-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="35ff0-377">Si vous souhaitez que le point de terminaison WCF soit configurable dans App. config, vous pouvez l’ajouter en tant que paramètre d’application et mettre à jour le code du client WCF pour récupérer le point de terminaison du service WCF à partir de la configuration.</span><span class="sxs-lookup"><span data-stu-id="35ff0-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="35ff0-378">Après avoir supprimé la section System. serviceModel du *fichier app. config*, l’application se lance mais échoue avec une autre exception quand un utilisateur se connecte.</span><span class="sxs-lookup"><span data-stu-id="35ff0-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="35ff0-379">L’API non prise en charge `Func<T>.BeginInvoke`est.</span><span class="sxs-lookup"><span data-stu-id="35ff0-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="35ff0-380">Comme expliqué dans [dotnet/corefx # 5940](https://github.com/dotnet/corefx/issues/5940), .net Core ne prend pas `BeginInvoke` en `EndInvoke` charge les méthodes et sur les types délégués en raison des dépendances de communication à distance sous-jacentes.</span><span class="sxs-lookup"><span data-stu-id="35ff0-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="35ff0-381">Ce problème et son correctif sont expliqués plus en détail dans le billet de blog [migration Delegate. BeginInvoke pour .net Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) , mais l’essentiel est `BeginInvoke` que `EndInvoke` les appels et doivent être `Task.Run` remplacés par (ou des alternatives Async, si possible).</span><span class="sxs-lookup"><span data-stu-id="35ff0-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="35ff0-382">En appliquant la solution générale ici `BeginInvoke` , l’appel peut être remplacé `Invoke` par un appel `Task.Run`lancé par.</span><span class="sxs-lookup"><span data-stu-id="35ff0-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="35ff0-383">Après la suppression `BeginInvoke` de l’utilisation, l’application de l’opérateur de haricot s’exécute correctement sur .net Core !</span><span class="sxs-lookup"><span data-stu-id="35ff0-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Opérateur Bean s’exécutant sur .NET Core](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="35ff0-385">Toutes les applications étant différentes, les étapes spécifiques nécessaires à la migration de vos propres applications vers .NET Core peuvent varier.</span><span class="sxs-lookup"><span data-stu-id="35ff0-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="35ff0-386">Mais j’espère que l’exemple Bean commerçant illustre le flux de travail général et les types de problèmes qui peuvent se produire.</span><span class="sxs-lookup"><span data-stu-id="35ff0-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="35ff0-387">Et, en dépit de la longueur de cet article, les modifications réelles nécessaires dans l’exemple d’opérateur Bean pour le rendre opérationnel sur .NET Core étaient relativement limitées.</span><span class="sxs-lookup"><span data-stu-id="35ff0-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="35ff0-388">De nombreuses applications migrent vers .NET Core de la même façon ; avec des modifications de code limitées ou même non nécessaires.</span><span class="sxs-lookup"><span data-stu-id="35ff0-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
