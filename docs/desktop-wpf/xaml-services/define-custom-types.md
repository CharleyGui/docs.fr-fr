---
title: Définition de types personnalisés pour les utiliser avec les services XAML .NET
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/12/2020
ms.locfileid: "82071856"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="384a5-102">Définir les types personnalisés pour une utilisation avec .NET XAML Services</span><span class="sxs-lookup"><span data-stu-id="384a5-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="384a5-103">Lorsque vous définissez des types personnalisés qui sont des objets d’affaires ou des types qui n’ont pas de dépendance à l’égard de cadres spécifiques, il existe certaines meilleures pratiques pour XAML que vous pouvez suivre.</span><span class="sxs-lookup"><span data-stu-id="384a5-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="384a5-104">Si vous suivez ces pratiques, .NET XAML Services et ses lecteurs XAML et les écrivains XAML peuvent découvrir les caractéristiques XAML de votre type et lui donner une représentation appropriée dans un flux de nœuds XAML en utilisant le système de type XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="384a5-105">Ce sujet décrit les meilleures pratiques pour les définitions de type, les définitions des membres et l’attribution clR des types ou des membres.</span><span class="sxs-lookup"><span data-stu-id="384a5-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="384a5-106">Modèles de constructeurs et définitions de type pour XAML</span><span class="sxs-lookup"><span data-stu-id="384a5-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="384a5-107">Pour être instantanée comme élément objet dans XAML, une classe personnalisée doit répondre aux exigences suivantes :</span><span class="sxs-lookup"><span data-stu-id="384a5-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="384a5-108">La classe personnalisée doit être publique et doit exposer un constructeur public sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="384a5-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="384a5-109">(Consultez la section suivante pour des remarques concernant les structures.)</span><span class="sxs-lookup"><span data-stu-id="384a5-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="384a5-110">La classe personnalisée ne doit pas être une classe imbriquée.</span><span class="sxs-lookup"><span data-stu-id="384a5-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="384a5-111">Le « point » supplémentaire dans le chemin de nom complet rend la division de classe-namespace ambigu, et interfère avec d’autres dispositifs XAML tels que les propriétés jointes.</span><span class="sxs-lookup"><span data-stu-id="384a5-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="384a5-112">Si un objet peut être instantané comme élément d’objet, l’objet créé peut remplir la forme d’élément de propriété de toutes les propriétés qui prennent l’objet comme leur type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="384a5-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="384a5-113">Vous pouvez toujours fournir des valeurs d’objet pour les types qui ne répondent pas à ces critères, si vous activez un convertisseur de valeur.</span><span class="sxs-lookup"><span data-stu-id="384a5-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="384a5-114">Pour plus d’informations, voir [Type Converters et Markup Extensions pour XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="384a5-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="384a5-115">Structures</span><span class="sxs-lookup"><span data-stu-id="384a5-115">Structures</span></span>

<span data-ttu-id="384a5-116">Les structures sont toujours capables d’être construites en XAML, selon la définition clR.</span><span class="sxs-lookup"><span data-stu-id="384a5-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="384a5-117">C’est parce qu’un compilateur CLR crée implicitement un constructeur sans paramètres pour une structure.</span><span class="sxs-lookup"><span data-stu-id="384a5-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="384a5-118">Ce constructeur initialise toutes les valeurs de propriété à leurs défauts.</span><span class="sxs-lookup"><span data-stu-id="384a5-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="384a5-119">Dans certains cas, le comportement de construction par défaut pour une structure n’est pas souhaitable.</span><span class="sxs-lookup"><span data-stu-id="384a5-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="384a5-120">C’est peut-être parce que la structure est destinée à remplir les valeurs et à fonctionner conceptuellement en tant que syndicat.</span><span class="sxs-lookup"><span data-stu-id="384a5-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="384a5-121">En tant que syndicat, les valeurs contenues peuvent avoir des interprétations mutuellement exclusives et, par conséquent, aucune de ses propriétés n’est définie.</span><span class="sxs-lookup"><span data-stu-id="384a5-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="384a5-122">Un exemple d’une telle structure <xref:System.Windows.GridLength>dans le vocabulaire WPF est .</span><span class="sxs-lookup"><span data-stu-id="384a5-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="384a5-123">Ces structures devraient mettre en œuvre un convertisseur de type afin que les valeurs puissent s’exprimer sous forme d’attribut, en utilisant des conventions de chaîne qui créent les différentes interprétations ou modes des valeurs de la structure.</span><span class="sxs-lookup"><span data-stu-id="384a5-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="384a5-124">La structure devrait également exposer un comportement similaire pour la construction de code par l’intermédiaire d’un constructeur non-paramètre.</span><span class="sxs-lookup"><span data-stu-id="384a5-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="384a5-125">Interfaces</span><span class="sxs-lookup"><span data-stu-id="384a5-125">Interfaces</span></span>

<span data-ttu-id="384a5-126">Les interfaces peuvent être utilisées comme types sous-jacents de membres.</span><span class="sxs-lookup"><span data-stu-id="384a5-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="384a5-127">Le système de type XAML vérifie la liste assignable et s’attend à ce que l’objet qui est fourni comme valeur peut être attribué à l’interface.</span><span class="sxs-lookup"><span data-stu-id="384a5-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="384a5-128">Il n’y a aucune idée de la façon dont l’interface doit être présentée comme un type XAML tant qu’un type assignable pertinent prend en charge les exigences de construction XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="384a5-129">Méthodes d’usine</span><span class="sxs-lookup"><span data-stu-id="384a5-129">Factory Methods</span></span>

<span data-ttu-id="384a5-130">Les méthodes d’usine sont une fonctionnalité XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="384a5-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="384a5-131">Ils modifient le principe XAML selon lequel les objets doivent avoir des constructeurs sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="384a5-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="384a5-132">Les méthodes d’usine ne sont pas documentées dans cet article.</span><span class="sxs-lookup"><span data-stu-id="384a5-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="384a5-133">Voir [x:FactoryMethod Directive](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="384a5-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="384a5-134">Énumérations</span><span class="sxs-lookup"><span data-stu-id="384a5-134">Enumerations</span></span>

<span data-ttu-id="384a5-135">Les énumérations ont un comportement de conversion de type natif XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="384a5-136">Les noms constants d’énumération spécifiés dans XAML sont résolus par rapport au type de recensement sous-jacent, et retournent la valeur de recensement à un auteur d’objets XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="384a5-137">XAML prend en charge une utilisation de <xref:System.FlagsAttribute> type pavillon pour les énumérations avec appliqué.</span><span class="sxs-lookup"><span data-stu-id="384a5-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="384a5-138">Pour plus d’informations, voir [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="384a5-138">For more information, see [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="384a5-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) est écrit pour le public WPF, mais la plupart des informations dans ce sujet est pertinente pour XAML qui n’est pas spécifique à un cadre de mise en œuvre particulier.)</span><span class="sxs-lookup"><span data-stu-id="384a5-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="384a5-140">Définitions des membres</span><span class="sxs-lookup"><span data-stu-id="384a5-140">Member Definitions</span></span>

<span data-ttu-id="384a5-141">Les types peuvent définir les membres pour l’utilisation de XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="384a5-142">Il est possible pour les types de définir les membres qui sont utilisables XAML, même si ce type spécifique n’est pas XAML-utilisable.</span><span class="sxs-lookup"><span data-stu-id="384a5-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="384a5-143">Ceci est possible en raison de l’héritage CLR.</span><span class="sxs-lookup"><span data-stu-id="384a5-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="384a5-144">Tant qu’un certain type qui hérite du membre prend en charge l’utilisation de XAML comme un type, et le membre prend en charge l’utilisation de XAML pour son type sous-jacent ou a une syntaxe XAML native disponible, ce membre est XAML-utilisable.</span><span class="sxs-lookup"><span data-stu-id="384a5-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="384a5-145">Propriétés</span><span class="sxs-lookup"><span data-stu-id="384a5-145">Properties</span></span>

<span data-ttu-id="384a5-146">Si vous définissez les propriétés comme une `get` `set` propriété PUBLIQUE CLR en utilisant les modèles typiques de CLR et d’accesseur et les mots clés de type langue-approprié, le système de type XAML peut déclarer la propriété en tant que membre avec des informations appropriées fournies pour <xref:System.Xaml.XamlMember> les propriétés, telles que <xref:System.Xaml.XamlMember.IsReadPublic%2A> et <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="384a5-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="384a5-147">Des propriétés spécifiques peuvent activer une syntaxe textuelle en appliquant <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="384a5-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="384a5-148">Pour plus d’informations, voir [Type Converters et Markup Extensions pour XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="384a5-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="384a5-149">En l’absence d’une syntaxe textuelle ou d’une conversion native XAML et en l’absence d’indirection supplémentaire, comme l’utilisation d’une extension de balisage, le type de propriété (dans<xref:System.Xaml.XamlMember.TargetType%2A> le système de type XAML) doit être en mesure de retourner une instance à un auteur d’objets XAML en traitant le type cible comme un type CLR.</span><span class="sxs-lookup"><span data-stu-id="384a5-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="384a5-150">Si vous utilisez XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) peut être utilisé pour fournir des valeurs si les considérations précédentes ne sont pas remplies; cependant, il s’agit plus d’un problème d’utilisation qu’d’un problème de définition de type.</span><span class="sxs-lookup"><span data-stu-id="384a5-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="384a5-151">Événements</span><span class="sxs-lookup"><span data-stu-id="384a5-151">Events</span></span>

<span data-ttu-id="384a5-152">Si vous définissez les événements comme un événement PUBLIC CLR, le <xref:System.Xaml.XamlMember.IsEvent%2A> système `true`de type XAML peut signaler l’événement en tant que membre avec comme .</span><span class="sxs-lookup"><span data-stu-id="384a5-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="384a5-153">Le câblage des gestionnaires d’événements n’est pas dans le cadre des capacités .NET XAML Services; le câblage est laissé à des cadres et des implémentations spécifiques.</span><span class="sxs-lookup"><span data-stu-id="384a5-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="384a5-154">Méthodes</span><span class="sxs-lookup"><span data-stu-id="384a5-154">Methods</span></span>

<span data-ttu-id="384a5-155">Le code inline pour les méthodes n’est pas une capacité XAML par défaut.</span><span class="sxs-lookup"><span data-stu-id="384a5-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="384a5-156">Dans la plupart des cas, vous ne référencez pas directement les membres de la méthode de XAML, et le rôle des méthodes dans XAML est seulement de fournir un soutien pour des modèles spécifiques XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="384a5-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) est une exception.</span><span class="sxs-lookup"><span data-stu-id="384a5-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="384a5-158">Champs</span><span class="sxs-lookup"><span data-stu-id="384a5-158">Fields</span></span>

<span data-ttu-id="384a5-159">Les lignes directrices en matière de conception de CLR découragent les champs nonstatiques.</span><span class="sxs-lookup"><span data-stu-id="384a5-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="384a5-160">Pour les champs statiques, vous ne pouvez accéder aux valeurs statiques du champ que grâce à [x:Static Markup Extension](xstatic-markup-extension.md); dans ce cas, vous ne faites rien de spécial dans la définition CLR pour exposer un champ pour [x:Utilisations statiques.](xstatic-markup-extension.md)</span><span class="sxs-lookup"><span data-stu-id="384a5-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="384a5-161">Membres attachables</span><span class="sxs-lookup"><span data-stu-id="384a5-161">Attachable Members</span></span>

<span data-ttu-id="384a5-162">Les membres attachables sont exposés à XAML par le biais d’un modèle de méthode d’accesseur sur un type définissant.</span><span class="sxs-lookup"><span data-stu-id="384a5-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="384a5-163">Le type définissant lui-même n’a pas besoin d’être XAML-utilisable comme un objet.</span><span class="sxs-lookup"><span data-stu-id="384a5-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="384a5-164">En fait, un modèle commun est de déclarer une classe de service dont le rôle est de posséder le membre attachable et de mettre en œuvre les comportements connexes, mais ne servent aucune autre fonction telle qu’une représentation d’assurance-chômage.</span><span class="sxs-lookup"><span data-stu-id="384a5-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="384a5-165">Pour les sections suivantes, le propriétaire de place *PropertyName* représente le nom de votre membre attachable.</span><span class="sxs-lookup"><span data-stu-id="384a5-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="384a5-166">Ce nom doit être valable dans la [grammaire XamlName](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="384a5-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="384a5-167">Soyez prudent des collisions de nom entre ces modèles et d’autres méthodes d’un type.</span><span class="sxs-lookup"><span data-stu-id="384a5-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="384a5-168">Si un membre existe qui correspond à l’un des modèles, il peut être interprété comme une voie d’utilisation des membres attachable par un processeur XAML, même si ce n’était pas votre intention.</span><span class="sxs-lookup"><span data-stu-id="384a5-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="384a5-169">L’accesseur GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="384a5-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="384a5-170">La signature `GetPropertyName` pour l’accesseur doit être :</span><span class="sxs-lookup"><span data-stu-id="384a5-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="384a5-171">L’objet `target` peut être défini comme un type plus spécifique dans votre implémentation.</span><span class="sxs-lookup"><span data-stu-id="384a5-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="384a5-172">Vous pouvez l’utiliser pour établir la portée de l’utilisation de votre membre attachable; les utilisations en dehors de votre portée prévue jetteront des exceptions de casting invalides qui sont ensuite faites surface par une erreur d’analyse XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="384a5-173">Le nom `target` du paramètre n’est pas une exigence, mais est nommé `target` par convention dans la plupart des implémentations.</span><span class="sxs-lookup"><span data-stu-id="384a5-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="384a5-174">La valeur de retour peut être spécifiée comme un type plus spécifique dans votre implémentation.</span><span class="sxs-lookup"><span data-stu-id="384a5-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="384a5-175">Pour prendre <xref:System.ComponentModel.TypeConverter> en charge une syntaxe textuelle <xref:System.ComponentModel.TypeConverterAttribute> activée `GetPropertyName` pour l’utilisation d’attributs du membre attachable, appliquez-le à l’accesseur.</span><span class="sxs-lookup"><span data-stu-id="384a5-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="384a5-176">S’appliquer `get` au `set` lieu de la peut sembler non-intuitif; toutefois, cette convention peut soutenir le concept de membres attachables qui sont sérialisants, ce qui est utile dans les scénarios de concepteur.</span><span class="sxs-lookup"><span data-stu-id="384a5-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="384a5-177">L’accesseur SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="384a5-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="384a5-178">La signature `SetPropertyName` pour l’accesseur doit être :</span><span class="sxs-lookup"><span data-stu-id="384a5-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="384a5-179">L’objet `target` peut être spécifié comme un type plus spécifique dans votre implémentation, avec la même logique et les mêmes conséquences que décrites dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="384a5-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="384a5-180">L’objet `value` peut être défini comme un type plus spécifique dans votre implémentation.</span><span class="sxs-lookup"><span data-stu-id="384a5-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="384a5-181">Rappelez-vous que la valeur de cette méthode est l’entrée provenant de l’utilisation XAML, généralement sous forme d’attribut.</span><span class="sxs-lookup"><span data-stu-id="384a5-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="384a5-182">De forme d’attribut il doit y avoir le support de `GetPropertyName`convertisseur de valeur pour une syntaxe de texte, et vous attribuez sur l’accesseur de s.</span><span class="sxs-lookup"><span data-stu-id="384a5-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="384a5-183">Magasins membres attachables</span><span class="sxs-lookup"><span data-stu-id="384a5-183">Attachable Member Stores</span></span>

<span data-ttu-id="384a5-184">Les méthodes d’accesseur ne sont généralement pas suffisantes pour fournir un moyen de placer les valeurs des membres attachables dans un graphique d’objet, ou pour récupérer des valeurs du graphique de l’objet et les sérialiser correctement.</span><span class="sxs-lookup"><span data-stu-id="384a5-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="384a5-185">Pour fournir cette fonctionnalité, les `target` objets des signatures d’accesseur précédents doivent être capables de stocker des valeurs.</span><span class="sxs-lookup"><span data-stu-id="384a5-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="384a5-186">Le mécanisme de stockage devrait être conforme au principe du membre attachable selon lequel le membre est attaché aux cibles lorsque le membre attachable ne fait pas partie de la liste des membres.</span><span class="sxs-lookup"><span data-stu-id="384a5-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="384a5-187">.NET XAML Services fournit une technique de mise <xref:System.Xaml.IAttachedPropertyStore> en <xref:System.Xaml.AttachablePropertyServices>œuvre pour les magasins de membres attachables par le biais des API et .</span><span class="sxs-lookup"><span data-stu-id="384a5-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="384a5-188"><xref:System.Xaml.IAttachedPropertyStore>est utilisé par les auteurs XAML pour découvrir la mise en `target` œuvre du magasin, et doit être mis en œuvre sur le type qui est le des accesseurs.</span><span class="sxs-lookup"><span data-stu-id="384a5-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="384a5-189">Les <xref:System.Xaml.AttachablePropertyServices> API statiques sont utilisées dans le corps des accesseurs, <xref:System.Xaml.AttachableMemberIdentifier>et se réfèrent au membre attachable par son .</span><span class="sxs-lookup"><span data-stu-id="384a5-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="384a5-190">Attributs CLR liés à XAML</span><span class="sxs-lookup"><span data-stu-id="384a5-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="384a5-191">Il est important d’attribuer correctement vos types, membres et assemblages afin de signaler les informations du système de type XAML à .NET XAML Services.</span><span class="sxs-lookup"><span data-stu-id="384a5-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="384a5-192">La communication des informations du système de type XAML est pertinente si l’une ou l’autre des situations suivantes s’applique :</span><span class="sxs-lookup"><span data-stu-id="384a5-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="384a5-193">Vous avez l’intention de vos types pour une utilisation avec les systèmes XAML qui sont directement basés sur .NET XAML Services lecteurs XAML et les écrivains XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="384a5-194">Vous définissez ou utilisez un cadre d’utilisation XAML basé sur ces lecteurs XAML et les écrivains XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="384a5-195">Pour une liste de chaque attribut XAML qui est pertinent pour le support XAML de vos types [personnalisés, consultez XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="384a5-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="384a5-196">Usage</span><span class="sxs-lookup"><span data-stu-id="384a5-196">Usage</span></span>

<span data-ttu-id="384a5-197">L’utilisation de types personnalisés exige que l’auteur de balisage doit cartographier un préfixe pour l’assemblage et l’espace de nom CLR qui contiennent le type personnalisé.</span><span class="sxs-lookup"><span data-stu-id="384a5-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="384a5-198">Cette procédure n’est pas documentée dans ce sujet.</span><span class="sxs-lookup"><span data-stu-id="384a5-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="384a5-199">Niveau d’accès</span><span class="sxs-lookup"><span data-stu-id="384a5-199">Access Level</span></span>

<span data-ttu-id="384a5-200">XAML fournit un moyen de charger et `internal` d’instantanéiser les types qui ont un niveau d’accès.</span><span class="sxs-lookup"><span data-stu-id="384a5-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="384a5-201">Cette capacité est fournie de sorte que le code utilisateur peut définir ses propres types, puis instantané les classes de balisage qui fait également partie de la même portée de code utilisateur.</span><span class="sxs-lookup"><span data-stu-id="384a5-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="384a5-202">Un exemple de WPF est chaque <xref:System.Windows.Controls.UserControl> fois que le code utilisateur définit un qui est destiné comme un moyen de refactorer un `public` comportement d’interface utilisateur, mais pas dans le cadre de tout mécanisme d’extension possible qui pourrait être implicite en déclarant la classe de support avec le niveau d’accès.</span><span class="sxs-lookup"><span data-stu-id="384a5-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="384a5-203">Un <xref:System.Windows.Controls.UserControl> tel peut `internal` être déclaré avec accès si le code de sauvegarde est compilé dans la même assemblée à partir de laquelle il est référencé comme un type XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="384a5-204">Pour une application qui charge XAML <xref:System.Xaml.XamlObjectWriter>en pleine `internal` confiance et utilise, le chargement des classes avec niveau d’accès est toujours activé.</span><span class="sxs-lookup"><span data-stu-id="384a5-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="384a5-205">Pour une application qui charge XAML en fiducie partielle, vous <xref:System.Xaml.Permissions.XamlAccessLevel> pouvez contrôler les caractéristiques du niveau d’accès en utilisant l’API.</span><span class="sxs-lookup"><span data-stu-id="384a5-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="384a5-206">En outre, les mécanismes de report (tels que le système de modèle WPF) doivent être en mesure de propager les autorisations de niveau d’accès et de les préserver pour les évaluations éventuelles du temps d’exécution; ceci est géré à <xref:System.Xaml.Permissions.XamlAccessLevel> l’interne en transmettant l’information.</span><span class="sxs-lookup"><span data-stu-id="384a5-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="384a5-207">Mise en œuvre du WPF</span><span class="sxs-lookup"><span data-stu-id="384a5-207">WPF Implementation</span></span>

<span data-ttu-id="384a5-208">WPF XAML utilise un modèle d’accès à la fiducie partielle où si BAML est chargé en fiducie partielle, l’accès est limité à <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> l’assemblage qui est la source BAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="384a5-209">Pour le report, WPF utilise <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> comme mécanisme pour passer les informations de niveau d’accès.</span><span class="sxs-lookup"><span data-stu-id="384a5-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="384a5-210">Dans la terminologie WPF XAML, un *type interne* est un type qui est défini par le même assemblage qui comprend également le référencement XAML.</span><span class="sxs-lookup"><span data-stu-id="384a5-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="384a5-211">Un tel type peut être cartographié à travers un espace de nom XAML qui `xmlns:local="clr-namespace:WPFApplication1"`omet délibérément la partie assemblage d’une cartographie, par exemple, .</span><span class="sxs-lookup"><span data-stu-id="384a5-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="384a5-212">Si BAML fait référence à `internal` un type interne et `GeneratedInternalTypeHelper` que ce type a un niveau d’accès, cela génère une classe pour l’assemblage.</span><span class="sxs-lookup"><span data-stu-id="384a5-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="384a5-213">Si vous voulez `GeneratedInternalTypeHelper`éviter, vous `public` devez soit utiliser le niveau d’accès, ou devez tenir compte de la classe concernée dans un assemblage séparé et rendre cet assemblage dépendant.</span><span class="sxs-lookup"><span data-stu-id="384a5-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="384a5-214">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="384a5-214">See also</span></span>

- [<span data-ttu-id="384a5-215">Attributs CLR XAML pour les bibliothèques et types personnalisés</span><span class="sxs-lookup"><span data-stu-id="384a5-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="384a5-216">Services XAML</span><span class="sxs-lookup"><span data-stu-id="384a5-216">XAML Services</span></span>](../../../api/index.md)
