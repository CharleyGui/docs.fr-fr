---
title: Définition de types personnalisés pour les utiliser avec les services XAML .NET
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 2c0578b5397172814c708706173c69ef69f91b2a
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90551776"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="907c7-102">Définir des types personnalisés à utiliser avec les services XAML .NET</span><span class="sxs-lookup"><span data-stu-id="907c7-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="907c7-103">Quand vous définissez des types personnalisés qui sont des objets métier ou des types qui n’ont pas de dépendance sur des frameworks spécifiques, il existe certaines meilleures pratiques pour XAML que vous pouvez suivre.</span><span class="sxs-lookup"><span data-stu-id="907c7-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="907c7-104">Si vous suivez ces pratiques, les services XAML .NET et leurs lecteurs et writers XAML peuvent découvrir les caractéristiques XAML de votre type et lui attribuer la représentation appropriée dans un flux de nœud XAML à l’aide du système de type XAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="907c7-105">Cette rubrique décrit les meilleures pratiques pour les définitions de type, les définitions de membres et l’attribution CLR de types ou de membres.</span><span class="sxs-lookup"><span data-stu-id="907c7-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="907c7-106">Modèles de constructeur et définitions de type pour XAML</span><span class="sxs-lookup"><span data-stu-id="907c7-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="907c7-107">Pour être instancié en tant qu’élément objet en XAML, une classe personnalisée doit remplir les conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="907c7-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="907c7-108">La classe personnalisée doit être publique et doit exposer un constructeur public sans paramètre.</span><span class="sxs-lookup"><span data-stu-id="907c7-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="907c7-109">(Consultez la section suivante pour des remarques concernant les structures.)</span><span class="sxs-lookup"><span data-stu-id="907c7-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="907c7-110">La classe personnalisée ne doit pas être une classe imbriquée.</span><span class="sxs-lookup"><span data-stu-id="907c7-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="907c7-111">Le « point » supplémentaire dans le chemin de nom complet rend la Division de l’espace de noms de classe ambiguë et interfère avec d’autres fonctionnalités XAML telles que les propriétés jointes.</span><span class="sxs-lookup"><span data-stu-id="907c7-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="907c7-112">Si un objet peut être instancié en tant qu’élément objet, l’objet créé peut remplir la forme d’élément de propriété de toutes les propriétés qui prennent l’objet comme type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="907c7-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="907c7-113">Vous pouvez toujours fournir des valeurs d’objet pour les types qui ne répondent pas à ces critères, si vous activez un convertisseur de valeur.</span><span class="sxs-lookup"><span data-stu-id="907c7-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="907c7-114">Pour plus d’informations, consultez [convertisseurs de type et extensions de balisage pour XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="907c7-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="907c7-115">Structures</span><span class="sxs-lookup"><span data-stu-id="907c7-115">Structures</span></span>

<span data-ttu-id="907c7-116">Les structures peuvent toujours être construites en XAML, par définition CLR.</span><span class="sxs-lookup"><span data-stu-id="907c7-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="907c7-117">Cela est dû au fait qu’un compilateur CLR crée implicitement un constructeur sans paramètre pour une structure.</span><span class="sxs-lookup"><span data-stu-id="907c7-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="907c7-118">Ce constructeur initialise toutes les valeurs de propriété à leurs valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="907c7-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="907c7-119">Dans certains cas, le comportement de construction par défaut d’une structure n’est pas souhaitable.</span><span class="sxs-lookup"><span data-stu-id="907c7-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="907c7-120">Cela peut être dû au fait que la structure est conçue pour remplir les valeurs et la fonction conceptuellement comme une Union.</span><span class="sxs-lookup"><span data-stu-id="907c7-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="907c7-121">En tant qu’Union, les valeurs contenues peuvent avoir des interprétations mutuellement exclusives et, par conséquent, aucune de ses propriétés ne peut être définie.</span><span class="sxs-lookup"><span data-stu-id="907c7-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="907c7-122">Un exemple d’une telle structure dans le vocabulaire WPF est <xref:System.Windows.GridLength> .</span><span class="sxs-lookup"><span data-stu-id="907c7-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="907c7-123">De telles structures doivent implémenter un convertisseur de type afin que les valeurs puissent être exprimées sous forme d’attribut, en utilisant des conventions de chaîne qui créent les différentes interprétations ou modes des valeurs de structure.</span><span class="sxs-lookup"><span data-stu-id="907c7-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="907c7-124">La structure doit également exposer un comportement similaire pour la construction de code via un constructeur sans paramètre.</span><span class="sxs-lookup"><span data-stu-id="907c7-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="907c7-125">Interfaces</span><span class="sxs-lookup"><span data-stu-id="907c7-125">Interfaces</span></span>

<span data-ttu-id="907c7-126">Les interfaces peuvent être utilisées comme types sous-jacents de membres.</span><span class="sxs-lookup"><span data-stu-id="907c7-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="907c7-127">Le système de type XAML vérifie la liste assignable et s’attend à ce que l’objet fourni comme valeur puisse être assigné à l’interface.</span><span class="sxs-lookup"><span data-stu-id="907c7-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="907c7-128">Il n’existe aucun concept de présentation de l’interface en tant que type XAML, à condition qu’un type assignable pertinent prenne en charge les spécifications de construction XAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="907c7-129">Méthodes de fabrique</span><span class="sxs-lookup"><span data-stu-id="907c7-129">Factory Methods</span></span>

<span data-ttu-id="907c7-130">Les méthodes de fabrique sont une fonctionnalité XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="907c7-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="907c7-131">Ils modifient le principe XAML selon lequel les objets doivent avoir des constructeurs sans paramètre.</span><span class="sxs-lookup"><span data-stu-id="907c7-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="907c7-132">Les méthodes de fabrique ne sont pas documentées dans cet article.</span><span class="sxs-lookup"><span data-stu-id="907c7-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="907c7-133">Consultez [directive x :FactoryMethod](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="907c7-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="907c7-134">Énumérations</span><span class="sxs-lookup"><span data-stu-id="907c7-134">Enumerations</span></span>

<span data-ttu-id="907c7-135">Les énumérations ont un comportement de conversion de type natif XAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="907c7-136">Les noms de constantes d’énumération spécifiés dans XAML sont résolus par rapport au type d’énumération sous-jacent et retournent la valeur d’énumération dans un writer d’objet XAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="907c7-137">XAML prend en charge une utilisation de style indicateurs pour les énumérations avec <xref:System.FlagsAttribute> appliqué.</span><span class="sxs-lookup"><span data-stu-id="907c7-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="907c7-138">Pour plus d’informations, consultez [syntaxe XAML en détail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail).</span><span class="sxs-lookup"><span data-stu-id="907c7-138">For more information, see [XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail).</span></span> <span data-ttu-id="907c7-139">(La[syntaxe XAML est écrite en détail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) pour l’audience WPF, mais la plupart des informations contenues dans cette rubrique s’appliquent à du code XAML qui n’est pas spécifique à une infrastructure d’implémentation particulière.)</span><span class="sxs-lookup"><span data-stu-id="907c7-139">([XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="907c7-140">Définitions de membres</span><span class="sxs-lookup"><span data-stu-id="907c7-140">Member Definitions</span></span>

<span data-ttu-id="907c7-141">Les types peuvent définir des membres pour l’utilisation de XAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="907c7-142">Il est possible pour les types de définir des membres qui sont utilisables en XAML même si ce type spécifique n’est pas utilisable en XAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="907c7-143">Cela est possible en raison de l’héritage CLR.</span><span class="sxs-lookup"><span data-stu-id="907c7-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="907c7-144">Tant qu’un type qui hérite du membre prend en charge l’utilisation de XAML en tant que type, et que le membre prend en charge l’utilisation de XAML pour son type sous-jacent ou possède une syntaxe XAML native disponible, ce membre est utilisable en XAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="907c7-145">Propriétés</span><span class="sxs-lookup"><span data-stu-id="907c7-145">Properties</span></span>

<span data-ttu-id="907c7-146">Si vous définissez des propriétés en tant que propriété CLR publique à l’aide des `get` modèles CLR et d' `set` accesseur standard et du mot de passe approprié au langage, le système de type XAML peut signaler la propriété en tant que membre avec les informations appropriées fournies pour les <xref:System.Xaml.XamlMember> Propriétés, telles que <xref:System.Xaml.XamlMember.IsReadPublic%2A> et <xref:System.Xaml.XamlMember.IsWritePublic%2A> .</span><span class="sxs-lookup"><span data-stu-id="907c7-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="907c7-147">Des propriétés spécifiques peuvent activer une syntaxe de texte en appliquant <xref:System.ComponentModel.TypeConverterAttribute> .</span><span class="sxs-lookup"><span data-stu-id="907c7-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="907c7-148">Pour plus d’informations, consultez [convertisseurs de type et extensions de balisage pour XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="907c7-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="907c7-149">En l’absence d’une syntaxe de texte ou d’une conversion XAML native et en l’absence d’une autre indirection, telle qu’une utilisation d’extension de balisage, le type d’une propriété ( <xref:System.Xaml.XamlMember.TargetType%2A> dans le système de type XAML) doit être en mesure de retourner une instance à un writer d’objet XAML en traitant le type cible comme un type CLR.</span><span class="sxs-lookup"><span data-stu-id="907c7-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="907c7-150">Si vous utilisez XAML 2009, l' [extension de balisage x :Reference](xreference-markup-extension.md) peut être utilisée pour fournir des valeurs si les considérations précédentes ne sont pas remplies ; Toutefois, il s’agit d’un problème d’utilisation plus qu’un problème de définition de type.</span><span class="sxs-lookup"><span data-stu-id="907c7-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="907c7-151">Événements</span><span class="sxs-lookup"><span data-stu-id="907c7-151">Events</span></span>

<span data-ttu-id="907c7-152">Si vous définissez des événements comme un événement CLR public, le système de type XAML peut signaler l’événement comme un membre avec <xref:System.Xaml.XamlMember.IsEvent%2A> comme `true` .</span><span class="sxs-lookup"><span data-stu-id="907c7-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="907c7-153">La connexion des gestionnaires d’événements n’est pas dans l’étendue des fonctionnalités des services XAML .NET. la connexion est laissée à des infrastructures et des implémentations spécifiques.</span><span class="sxs-lookup"><span data-stu-id="907c7-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="907c7-154">Méthodes</span><span class="sxs-lookup"><span data-stu-id="907c7-154">Methods</span></span>

<span data-ttu-id="907c7-155">Le code inline pour les méthodes n’est pas une fonctionnalité XAML par défaut.</span><span class="sxs-lookup"><span data-stu-id="907c7-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="907c7-156">Dans la plupart des cas, vous ne référencez pas directement des membres de méthode à partir de XAML, et le rôle des méthodes en XAML est uniquement de fournir la prise en charge de modèles XAML spécifiques.</span><span class="sxs-lookup"><span data-stu-id="907c7-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="907c7-157">[la directive x :FactoryMethod](xfactorymethod-directive.md) est une exception.</span><span class="sxs-lookup"><span data-stu-id="907c7-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="907c7-158">Champs</span><span class="sxs-lookup"><span data-stu-id="907c7-158">Fields</span></span>

<span data-ttu-id="907c7-159">Les instructions de conception du CLR découragent les champs non statiques.</span><span class="sxs-lookup"><span data-stu-id="907c7-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="907c7-160">Pour les champs statiques, vous pouvez accéder aux valeurs de champ statiques uniquement par le biais de l' [extension de balisage x :static](xstatic-markup-extension.md); dans ce cas, vous n’avez rien de spécial dans la définition du CLR pour exposer un champ pour les utilisations de [x :static](xstatic-markup-extension.md) .</span><span class="sxs-lookup"><span data-stu-id="907c7-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="907c7-161">Membres pouvant être attachés</span><span class="sxs-lookup"><span data-stu-id="907c7-161">Attachable Members</span></span>

<span data-ttu-id="907c7-162">Les membres pouvant être attachés sont exposés au code XAML via un modèle de méthode d’accesseur sur un type de définition.</span><span class="sxs-lookup"><span data-stu-id="907c7-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="907c7-163">Le type de définition lui-même n’a pas besoin d’être utilisable en XAML en tant qu’objet.</span><span class="sxs-lookup"><span data-stu-id="907c7-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="907c7-164">En fait, un modèle courant consiste à déclarer une classe de service dont le rôle est de posséder le membre pouvant être attaché et d’implémenter les comportements associés, mais qui n’a aucune autre fonction telle qu’une représentation d’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="907c7-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="907c7-165">Dans les sections suivantes, l’espace réservé *PropertyName* représente le nom de votre membre pouvant être attaché.</span><span class="sxs-lookup"><span data-stu-id="907c7-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="907c7-166">Ce nom doit être valide dans la [grammaire XamlName](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="907c7-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="907c7-167">Méfiez-vous des collisions de noms entre ces modèles et d’autres méthodes d’un type.</span><span class="sxs-lookup"><span data-stu-id="907c7-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="907c7-168">Si un membre existant correspond à l’un des modèles, il peut être interprété comme une voie d’utilisation de membre pouvant être attaché par un processeur XAML, même si ce n’est pas votre intention.</span><span class="sxs-lookup"><span data-stu-id="907c7-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="907c7-169">Accesseur GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="907c7-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="907c7-170">La signature de l' `GetPropertyName` accesseur doit être :</span><span class="sxs-lookup"><span data-stu-id="907c7-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="907c7-171">L’objet `target` peut être défini comme un type plus spécifique dans votre implémentation.</span><span class="sxs-lookup"><span data-stu-id="907c7-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="907c7-172">Vous pouvez l’utiliser pour étendre l’utilisation de votre membre pouvant être attaché ; les utilisations en dehors de votre portée prévue lèvent des exceptions de cast non valides qui sont ensuite représentées par une erreur d’analyse XAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="907c7-173">Le nom du paramètre `target` n’est pas obligatoire, mais il est nommé `target` par Convention dans la plupart des implémentations.</span><span class="sxs-lookup"><span data-stu-id="907c7-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="907c7-174">La valeur de retour peut être spécifiée comme un type plus spécifique dans votre implémentation.</span><span class="sxs-lookup"><span data-stu-id="907c7-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="907c7-175">Pour prendre en charge une <xref:System.ComponentModel.TypeConverter> syntaxe de texte activée pour l’utilisation d’attribut du membre pouvant être attaché, appliquez <xref:System.ComponentModel.TypeConverterAttribute> à l' `GetPropertyName` accesseur.</span><span class="sxs-lookup"><span data-stu-id="907c7-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="907c7-176">L’application de au `get` au lieu de `set` peut paraître non intuitive ; Toutefois, cette Convention peut prendre en charge le concept de membres pouvant être attachés en lecture seule qui sont sérialisables, ce qui est utile dans les scénarios de concepteur.</span><span class="sxs-lookup"><span data-stu-id="907c7-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="907c7-177">Accesseur SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="907c7-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="907c7-178">La signature de l' `SetPropertyName` accesseur doit être :</span><span class="sxs-lookup"><span data-stu-id="907c7-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="907c7-179">L' `target` objet peut être spécifié en tant que type plus spécifique dans votre implémentation, avec la même logique et les mêmes conséquences que celles décrites dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="907c7-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="907c7-180">L’objet `value` peut être défini comme un type plus spécifique dans votre implémentation.</span><span class="sxs-lookup"><span data-stu-id="907c7-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="907c7-181">N’oubliez pas que la valeur de cette méthode est l’entrée provenant de l’utilisation de XAML, généralement sous la forme d’un attribut.</span><span class="sxs-lookup"><span data-stu-id="907c7-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="907c7-182">À partir du formulaire d’attribut, il doit y avoir une prise en charge de convertisseur de valeurs pour une syntaxe de texte, et vous avez l’attribut sur l' `GetPropertyName` accesseur s.</span><span class="sxs-lookup"><span data-stu-id="907c7-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="907c7-183">Magasins de membres pouvant être attachés</span><span class="sxs-lookup"><span data-stu-id="907c7-183">Attachable Member Stores</span></span>

<span data-ttu-id="907c7-184">Les méthodes d’accesseur ne sont généralement pas suffisantes pour fournir un moyen de placer des valeurs de membre pouvant être attachées dans un graphique d’objet, ou pour récupérer des valeurs à partir du graphique d’objet et les sérialiser correctement.</span><span class="sxs-lookup"><span data-stu-id="907c7-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="907c7-185">Pour fournir cette fonctionnalité, les `target` objets dans les signatures d’accesseur précédentes doivent pouvoir stocker des valeurs.</span><span class="sxs-lookup"><span data-stu-id="907c7-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="907c7-186">Le mécanisme de stockage doit être cohérent avec le principe de membre pouvant être attaché que le membre peut être attaché aux cibles où le membre pouvant être attaché ne figure pas dans la liste des membres.</span><span class="sxs-lookup"><span data-stu-id="907c7-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="907c7-187">Les services XAML .NET fournissent une technique d’implémentation pour les magasins de membres pouvant être attachés via les API <xref:System.Xaml.IAttachedPropertyStore> et <xref:System.Xaml.AttachablePropertyServices> .</span><span class="sxs-lookup"><span data-stu-id="907c7-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="907c7-188"><xref:System.Xaml.IAttachedPropertyStore> est utilisé par les writers XAML pour découvrir l’implémentation du magasin et doit être implémenté sur le type qui est le `target` des accesseurs.</span><span class="sxs-lookup"><span data-stu-id="907c7-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="907c7-189">Les API statiques <xref:System.Xaml.AttachablePropertyServices> sont utilisées dans le corps des accesseurs et font référence au membre pouvant être attaché par son <xref:System.Xaml.AttachableMemberIdentifier> .</span><span class="sxs-lookup"><span data-stu-id="907c7-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="907c7-190">Attributs CLR liés à XAML</span><span class="sxs-lookup"><span data-stu-id="907c7-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="907c7-191">L’attribution correcte de vos types, membres et assemblys est importante pour signaler les informations du système de type XAML aux services XAML .NET.</span><span class="sxs-lookup"><span data-stu-id="907c7-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="907c7-192">La création de rapports sur le système de type XAML est pertinente si l’une des situations suivantes s’applique :</span><span class="sxs-lookup"><span data-stu-id="907c7-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="907c7-193">Vous avez l’intention d’utiliser vos types avec des systèmes XAML qui sont directement basés sur les lecteurs XAML et les writers XAML des services XAML .NET.</span><span class="sxs-lookup"><span data-stu-id="907c7-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="907c7-194">Vous définissez ou utilisez un Framework utilisant du code XAML basé sur ces lecteurs XAML et les writers XAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="907c7-195">Pour obtenir la liste de chaque attribut XAML pertinent pour la prise en charge XAML de vos types personnalisés, consultez [attributs CLR XAML pour les bibliothèques et les types personnalisés](clr-attributes-with-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="907c7-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="907c7-196">Utilisation</span><span class="sxs-lookup"><span data-stu-id="907c7-196">Usage</span></span>

<span data-ttu-id="907c7-197">L’utilisation de types personnalisés requiert que l’auteur du balisage doive mapper un préfixe pour l’assembly et l’espace de noms CLR qui contiennent le type personnalisé.</span><span class="sxs-lookup"><span data-stu-id="907c7-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="907c7-198">Cette procédure n’est pas décrite dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="907c7-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="907c7-199">Niveau d’accès</span><span class="sxs-lookup"><span data-stu-id="907c7-199">Access Level</span></span>

<span data-ttu-id="907c7-200">XAML fournit un moyen de charger et d’instancier des types qui ont un `internal` niveau d’accès.</span><span class="sxs-lookup"><span data-stu-id="907c7-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="907c7-201">Cette fonctionnalité est fournie afin que le code utilisateur puisse définir ses propres types, puis instancier ces classes à partir du balisage qui fait également partie de la même portée de code utilisateur.</span><span class="sxs-lookup"><span data-stu-id="907c7-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="907c7-202">Un exemple de WPF est à chaque fois que le code utilisateur définit un <xref:System.Windows.Controls.UserControl> qui est destiné à refactoriser un comportement d’interface utilisateur, mais pas dans le cadre d’un mécanisme d’extension possible qui peut être implicite en déclarant la classe de prise en charge avec le `public` niveau d’accès.</span><span class="sxs-lookup"><span data-stu-id="907c7-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="907c7-203">Ce type <xref:System.Windows.Controls.UserControl> peut être déclaré avec un `internal` accès si le code de stockage est compilé dans le même assembly que celui à partir duquel il est référencé en tant que type XAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="907c7-204">Pour une application qui charge du code XAML avec un niveau de confiance totale et utilise <xref:System.Xaml.XamlObjectWriter> , le chargement des classes avec le `internal` niveau d’accès est toujours activé.</span><span class="sxs-lookup"><span data-stu-id="907c7-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="907c7-205">Pour une application qui charge le code XAML en confiance partielle, vous pouvez contrôler les caractéristiques de niveau d’accès à l’aide de l' <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="907c7-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="907c7-206">En outre, les mécanismes de report (tels que le système de modèles WPF) doivent être en mesure de propager toutes les autorisations de niveau d’accès et de les conserver pour les évaluations de l’heure d’exécution. Cela est géré en interne en passant les <xref:System.Xaml.Permissions.XamlAccessLevel> informations.</span><span class="sxs-lookup"><span data-stu-id="907c7-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="907c7-207">Implémentation WPF</span><span class="sxs-lookup"><span data-stu-id="907c7-207">WPF Implementation</span></span>

<span data-ttu-id="907c7-208">Le XAML WPF utilise un modèle d’accès de confiance partielle où si BAML est chargé en mode de confiance partielle, l’accès est limité à <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> pour l’assembly qui est la source BAML.</span><span class="sxs-lookup"><span data-stu-id="907c7-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="907c7-209">Pour report, WPF utilise <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> comme mécanisme pour transmettre les informations de niveau d’accès.</span><span class="sxs-lookup"><span data-stu-id="907c7-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="907c7-210">Dans la terminologie XAML WPF, un *type interne* est un type défini par le même assembly qui comprend également le XAML de référencement.</span><span class="sxs-lookup"><span data-stu-id="907c7-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="907c7-211">Ce type peut être mappé par le biais d’un espace de noms XAML qui omet délibérément la partie assembly = d’un mappage, par exemple `xmlns:local="clr-namespace:WPFApplication1"` .</span><span class="sxs-lookup"><span data-stu-id="907c7-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="907c7-212">Si BAML fait référence à un type interne et que ce type a `internal` un niveau d’accès, cela génère une `GeneratedInternalTypeHelper` classe pour l’assembly.</span><span class="sxs-lookup"><span data-stu-id="907c7-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="907c7-213">Si vous souhaitez éviter `GeneratedInternalTypeHelper` , vous devez utiliser `public` le niveau d’accès ou vous devez factoriser la classe pertinente dans un assembly distinct et rendre cet assembly dépendant.</span><span class="sxs-lookup"><span data-stu-id="907c7-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="907c7-214">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="907c7-214">See also</span></span>

- [<span data-ttu-id="907c7-215">Attributs CLR XAML pour les bibliothèques et types personnalisés</span><span class="sxs-lookup"><span data-stu-id="907c7-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="907c7-216">Services XAML</span><span class="sxs-lookup"><span data-stu-id="907c7-216">XAML Services</span></span>](../../../api/index.md)
