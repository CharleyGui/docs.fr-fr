---
title: Fonctionnement des concepts et structures du flux de nœud XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: b3de3dca029c5e676fc7cdebc7735cfdade0228a
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/27/2020
ms.locfileid: "82071618"
---
# <a name="xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="bf18a-102">Structures et concepts de flux de nœuds XAML</span><span class="sxs-lookup"><span data-stu-id="bf18a-102">XAML node stream structures and concepts</span></span>

<span data-ttu-id="bf18a-103">Les lecteurs de XAML et les auteurs de XAML mis en œuvre dans .NET XAML Services sont basés sur le concept de conception d’un flux de nœuds XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-103">XAML readers and XAML writers as implemented in .NET XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="bf18a-104">Le flux de nœud XAML est une conceptualisation d'un ensemble de nœuds XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="bf18a-105">Dans cette conceptualisation, un processeur XAML parcourt la structure des relations de nœud dans le code XAML une par une.</span><span class="sxs-lookup"><span data-stu-id="bf18a-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="bf18a-106">À tout moment, il n'existe qu'un seul enregistrement actuel ou position actuelle dans un flux de nœud XAML ouvert, et de nombreux aspects de l'API ne signalent que les informations disponibles à partir de cette position.</span><span class="sxs-lookup"><span data-stu-id="bf18a-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="bf18a-107">Le nœud actuel dans un flux de nœud XAML peut être un objet, un membre ou une valeur.</span><span class="sxs-lookup"><span data-stu-id="bf18a-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="bf18a-108">Si les lecteurs XAML traitent le XAML en tant que flux de nœud XAML, ils peuvent communiquer avec les writers XAML et activer un programme qui permet d'afficher, de manipuler ou de modifier le contenu d'un flux de nœud XAML pendant une opération de chemin de chargement ou d'enregistrement impliquant du code XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="bf18a-109">La conception de l’API de lecteur et écrivain de XAML et le concept de flux de nœuds XAML sont semblables aux conceptions et concepts de lecteur et d’auteur apparentés précédents, tels que le modèle d’objet de document de XML (DOM) et le et <xref:System.Xml.XmlReader> <xref:System.Xml.XmlWriter> les classes.</span><span class="sxs-lookup"><span data-stu-id="bf18a-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the XML Document Object Model (DOM) and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="bf18a-110">Cette rubrique aborde les concepts de flux de nœud XAML et décrit comment écrire des routines qui interagissent avec des représentations XAML au niveau des nœuds XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="bf18a-111">Chargement de XAML dans un lecteur XAML</span><span class="sxs-lookup"><span data-stu-id="bf18a-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="bf18a-112">La classe <xref:System.Xaml.XamlReader> de base ne déclare pas de technique particulière pour le chargement du XAML initial dans un lecteur XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="bf18a-113">En revanche, une classe dérivée déclare et implémente la technique de chargement, y compris les caractéristiques et les contraintes générales de sa source d'entrée pour le XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="bf18a-114">Par exemple, un lecteur <xref:System.Xaml.XamlObjectReader> lit un graphique d'objet à partir de la source d'entrée d'un objet unique, qui représente la racine ou la base.</span><span class="sxs-lookup"><span data-stu-id="bf18a-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="bf18a-115"><xref:System.Xaml.XamlObjectReader> génère alors un flux de nœud XAML à partir du graphique d'objet.</span><span class="sxs-lookup"><span data-stu-id="bf18a-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="bf18a-116">La sous-classe définie <xref:System.Xaml.XamlReader> .NET XAML <xref:System.Xaml.XamlXmlReader>Services la plus importante est .</span><span class="sxs-lookup"><span data-stu-id="bf18a-116">The most prominent .NET XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="bf18a-117">La classe<xref:System.Xaml.XamlXmlReader> charge le XAML initial en chargeant un fichier texte directement via un chemin de flux ou de fichier, ou indirectement via une classe du lecteur associé telle que <xref:System.IO.TextReader>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="bf18a-118"><xref:System.Xaml.XamlReader> contient l'intégralité de la source d'entrée XAML après son chargement.</span><span class="sxs-lookup"><span data-stu-id="bf18a-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="bf18a-119">Toutefois, l'API de base de <xref:System.Xaml.XamlReader> est conçue afin que le lecteur interagisse avec un nœud unique du code XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="bf18a-120">Lors du premier chargement, le premier nœud unique que vous rencontrez est la racine du XAML et son objet de départ.</span><span class="sxs-lookup"><span data-stu-id="bf18a-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="bf18a-121">Concept du flux de nœud XAML</span><span class="sxs-lookup"><span data-stu-id="bf18a-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="bf18a-122">Si vous êtes plus familier avec un DOM, métaphore d’arbre, ou approche basée sur la requête vers l’accès aux technologies basées sur XML, un moyen utile de conceptualiser un flux de nœuds XAML est le suivant.</span><span class="sxs-lookup"><span data-stu-id="bf18a-122">If you are more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="bf18a-123">Imaginez que le XAML chargé est un modèle DOM ou une arborescence dans laquelle tous les nœuds sont développés et présentés de façon linéaire.</span><span class="sxs-lookup"><span data-stu-id="bf18a-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="bf18a-124">Dans un modèle DOM, à mesure que vous parcourez les nœuds, vous passez d'un niveau à l'autre, ce qui est pertinent dans ce contexte. Toutefois, le flux de nœud XAML n'effectue pas explicitement de suivi, car il ne gère pas le concept de niveau.</span><span class="sxs-lookup"><span data-stu-id="bf18a-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="bf18a-125">Le flux de nœud a une position « actuelle », mais à moins d'avoir vous-même stocké d'autres parties du flux en tant que références, tout aspect du flux de nœud autre que la position du nœud actuel n'est pas visible.</span><span class="sxs-lookup"><span data-stu-id="bf18a-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="bf18a-126">Le concept de flux de nœud XAML présente l'avantage notable que si vous parcourez l'intégralité du flux de nœud, vous êtes assuré d'avoir traité la représentation XAML dans sa totalité. Vous n'avez pas besoin de vérifier si une requête, une opération DOM ou une autre approche non linéaire de traitement des informations a négligé une partie de la représentation XAML complète.</span><span class="sxs-lookup"><span data-stu-id="bf18a-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="bf18a-127">Pour cette raison, la représentation sous forme de flux de nœud XAML est idéale pour connecter des lecteurs et writers XAML et pour fournir un système dans lequel vous pouvez insérer votre propre processus entre les phases de lecture et d'écriture d'une opération de traitement XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="bf18a-128">Dans de nombreux cas, l'ordre des nœuds dans le flux de nœud XAML est délibérément optimisé ou réorganisé par les lecteurs XAML, contrairement à l'ordre dans un texte source, un binaire ou un graphique d'objet.</span><span class="sxs-lookup"><span data-stu-id="bf18a-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="bf18a-129">Ce comportement permet d'appliquer une architecture de traitement XAML selon laquelle les writers XAML ne sont jamais dans une position qui les oblige à « revenir en arrière » dans le flux de nœud.</span><span class="sxs-lookup"><span data-stu-id="bf18a-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="bf18a-130">Idéalement, toutes les opérations d'écriture XAML doivent être en mesure d'agir selon le contexte de schéma ainsi que la position actuelle du flux de nœud.</span><span class="sxs-lookup"><span data-stu-id="bf18a-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="bf18a-131">Boucle de nœud de lecture de base</span><span class="sxs-lookup"><span data-stu-id="bf18a-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="bf18a-132">Une boucle de nœud de lecture de base pour examiner un flux de nœud XAML présente les concepts suivants.</span><span class="sxs-lookup"><span data-stu-id="bf18a-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="bf18a-133">Pour les besoins des boucles de nœud décrites dans cette rubrique, supposez que vous lisez un fichier XAML textuel lisible par l'utilisateur à l'aide de <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="bf18a-134">Les liens de cette section font référence à l'API de la boucle de nœud XAML implémentée par <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="bf18a-135">Assurez-vous que vous ne vous trouvez pas à la fin du flux de nœud XAML (vérifiez <xref:System.Xaml.XamlXmlReader.IsEof%2A>, ou utilisez la valeur de retour <xref:System.Xaml.XamlXmlReader.Read%2A> ).</span><span class="sxs-lookup"><span data-stu-id="bf18a-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="bf18a-136">Si vous vous trouvez à la fin du flux, il n'y a pas de nœud actuel et vous devez sortir.</span><span class="sxs-lookup"><span data-stu-id="bf18a-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="bf18a-137">Vérifiez le type de nœud que le flux de nœud XAML expose actuellement en appelant <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="bf18a-138">Si vous disposez d’un writer d’objet XAML associé directement connecté, vous appelez généralement <xref:System.Xaml.XamlWriter.WriteNode%2A> à ce stade.</span><span class="sxs-lookup"><span data-stu-id="bf18a-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="bf18a-139">En fonction du <xref:System.Xaml.XamlNodeType> indiqué comme le nœud ou l'enregistrement actuel, appelez l'un des éléments suivants pour obtenir des informations sur le contenu du nœud :</span><span class="sxs-lookup"><span data-stu-id="bf18a-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="bf18a-140">Pour une propriété <xref:System.Xaml.XamlXmlReader.NodeType%2A> du nœud <xref:System.Xaml.XamlNodeType.StartMember> ou <xref:System.Xaml.XamlNodeType.EndMember>, appelez <xref:System.Xaml.XamlXmlReader.Member%2A> pour obtenir des informations de <xref:System.Xaml.XamlMember> pour un membre.</span><span class="sxs-lookup"><span data-stu-id="bf18a-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="bf18a-141">Le membre peut <xref:System.Xaml.XamlDirective>être un membre, et donc peut-être pas nécessairement un membre conventionnel de type défini de l’objet précédent.</span><span class="sxs-lookup"><span data-stu-id="bf18a-141">The member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="bf18a-142">Par exemple, `x:Name` appliqué à un objet apparaît comme un membre XAML pour lequel la propriété <xref:System.Xaml.XamlMember.IsDirective%2A> a la valeur true et la propriété <xref:System.Xaml.XamlMember.Name%2A> du membre est `Name`. Les autres propriétés indiquent que cette directive se trouve sous l'espace de noms XAML du langage XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="bf18a-143">Pour une propriété <xref:System.Xaml.XamlXmlReader.NodeType%2A> d'un nœud <xref:System.Xaml.XamlNodeType.StartObject> ou <xref:System.Xaml.XamlNodeType.EndObject>, appelez <xref:System.Xaml.XamlXmlReader.Type%2A> pour obtenir des informations de <xref:System.Xaml.XamlType> pour un objet.</span><span class="sxs-lookup"><span data-stu-id="bf18a-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="bf18a-144">Pour une propriété <xref:System.Xaml.XamlXmlReader.NodeType%2A> d'un nœud <xref:System.Xaml.XamlNodeType.Value>, appelez <xref:System.Xaml.XamlXmlReader.Value%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="bf18a-145">Un nœud est une valeur uniquement s'il est l'expression la plus simple de la valeur d'un membre, ou le texte d'initialisation d'un objet (toutefois, vous devez connaître le comportement de conversion de type, comme indiqué dans une section à venir de cette rubrique).</span><span class="sxs-lookup"><span data-stu-id="bf18a-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="bf18a-146">Pour une propriété <xref:System.Xaml.XamlXmlReader.NodeType%2A> d'un nœud <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, appelez <xref:System.Xaml.XamlXmlReader.Namespace%2A> pour obtenir des informations d'espace de noms pour un nœud d'espace de noms.</span><span class="sxs-lookup"><span data-stu-id="bf18a-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="bf18a-147">Appelez <xref:System.Xaml.XamlXmlReader.Read%2A> pour faire avancer le lecteur XAML au nœud suivant dans le flux de nœud XAML, et recommencez les étapes.</span><span class="sxs-lookup"><span data-stu-id="bf18a-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="bf18a-148">Le flux de nœuds XAML fourni par les lecteurs .NET XAML Services XAML fournit toujours une traversée complète et profonde de tous les nœuds possibles.</span><span class="sxs-lookup"><span data-stu-id="bf18a-148">The XAML node stream provided by .NET XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="bf18a-149">L'une des techniques de contrôle de flux courantes pour une boucle de nœud XAML est la définition d'un corps dans `while (reader.Read())`et l'activation de <xref:System.Xaml.XamlXmlReader.NodeType%2A> à chaque point de nœud de la boucle de nœud.</span><span class="sxs-lookup"><span data-stu-id="bf18a-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="bf18a-150">Si le flux de nœud se trouve à la fin du fichier, le nœud actuel a la valeur null.</span><span class="sxs-lookup"><span data-stu-id="bf18a-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="bf18a-151">La boucle la plus simple qui utilise un lecteur et un writer ressemble à l'exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="bf18a-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="bf18a-152">Cet exemple de base d'une boucle de nœud XAML de chemin de chargement connecte le lecteur et le writer XAML de façon transparente, comme si vous aviez utilisé <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bf18a-153">Mais cette structure de base est ensuite développée pour s'appliquer à votre scénario d'écriture ou de lecture.</span><span class="sxs-lookup"><span data-stu-id="bf18a-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="bf18a-154">Voici quelques scénarios possibles :</span><span class="sxs-lookup"><span data-stu-id="bf18a-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="bf18a-155">Activez <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="bf18a-156">Effectuez différentes actions en fonction du type de nœud en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="bf18a-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="bf18a-157">Dans tous les cas, n'appelez pas <xref:System.Xaml.XamlWriter.WriteNode%2A> .</span><span class="sxs-lookup"><span data-stu-id="bf18a-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="bf18a-158">Appelez uniquement <xref:System.Xaml.XamlWriter.WriteNode%2A> dans certains cas de <xref:System.Xaml.XamlXmlReader.NodeType%2A> .</span><span class="sxs-lookup"><span data-stu-id="bf18a-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="bf18a-159">Dans la logique d'un type de nœud particulier, analysez les caractéristiques de ce nœud et modifiez-les.</span><span class="sxs-lookup"><span data-stu-id="bf18a-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="bf18a-160">Par exemple, vous ne pouvez écrire que des objets qui proviennent d’un espace de nom XAML particulier, puis déposer ou reporter tous les objets non de cet espace de nom XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-160">For example, you could only write objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="bf18a-161">Vous pouvez également supprimer ou retraiter différemment toutes les directives XAML que votre système XAML ne prend pas en charge dans le cadre du traitement des membres.</span><span class="sxs-lookup"><span data-stu-id="bf18a-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="bf18a-162">Définissez un <xref:System.Xaml.XamlObjectWriter> personnalisé qui remplace les méthodes `Write*` , en effectuant éventuellement un mappage de type qui ignore le contexte de schéma XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="bf18a-163">Créez le <xref:System.Xaml.XamlXmlReader> pour qu'il utilise un contexte de schéma XAML autre que celui par défaut, de sorte que les différences personnalisées du comportement XAML soient utilisées à la fois par le lecteur et le writer.</span><span class="sxs-lookup"><span data-stu-id="bf18a-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="bf18a-164">Accès au code XAML au-delà du concept de boucle de nœud</span><span class="sxs-lookup"><span data-stu-id="bf18a-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="bf18a-165">Vous pouvez éventuellement utiliser une représentation XAML autrement que sous forme de boucle de nœud XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="bf18a-166">Par exemple, un lecteur XAML peut lire un nœud indexé ou accéder aux nœuds directement par le biais de `x:Name`, `x:Uid`ou d'autres identificateurs.</span><span class="sxs-lookup"><span data-stu-id="bf18a-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="bf18a-167">.NET XAML Services ne fournit pas une mise en œuvre complète, mais fournit un modèle suggéré par le biais de services et de types de soutien.</span><span class="sxs-lookup"><span data-stu-id="bf18a-167">.NET XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="bf18a-168">Pour plus d’informations, consultez <xref:System.Xaml.IXamlIndexingReader> et <xref:System.Xaml.XamlNodeList>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

## <a name="working-with-the-current-node"></a><span data-ttu-id="bf18a-169">Utilisation du nœud actuel</span><span class="sxs-lookup"><span data-stu-id="bf18a-169">Working with the Current Node</span></span>

<span data-ttu-id="bf18a-170">La plupart des scénarios qui utilisent une boucle de nœud XAML ne se limitent pas à la lecture de nœuds.</span><span class="sxs-lookup"><span data-stu-id="bf18a-170">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="bf18a-171">Ils traitent les nœuds actuels et les transfèrent un par un à une implémentation de <xref:System.Xaml.XamlWriter>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-171">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="bf18a-172">Dans un scénario classique de chemin de chargement, un <xref:System.Xaml.XamlXmlReader> génère un flux de nœud XAML, les nœuds XAML sont traités en fonction de votre logique et du contexte de schéma XAML, puis sont passés à un <xref:System.Xaml.XamlObjectWriter>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-172">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="bf18a-173">Vous intégrez ensuite le graphique d'objet obtenu à votre application ou infrastructure.</span><span class="sxs-lookup"><span data-stu-id="bf18a-173">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="bf18a-174">Dans un scénario classique de chemin d'enregistrement, un <xref:System.Xaml.XamlObjectReader> lit le graphique d'objet, les nœuds XAML sont traités individuellement et un <xref:System.Xaml.XamlXmlWriter> exporte le résultat sérialisé en tant que fichier texte XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-174">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="bf18a-175">La clé est que les chemins et les scénarios impliquent de travailler avec exactement un nœud XAML à la fois, et les nœuds XAML sont disponibles pour le traitement d’une manière standardisée qui est définie par le système de type XAML et the.NET API XAML Services.</span><span class="sxs-lookup"><span data-stu-id="bf18a-175">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="bf18a-176">Frames et portée</span><span class="sxs-lookup"><span data-stu-id="bf18a-176">Frames and Scope</span></span>

<span data-ttu-id="bf18a-177">Une boucle de nœud XAML parcourt un flux de nœud XAML de façon linéaire.</span><span class="sxs-lookup"><span data-stu-id="bf18a-177">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="bf18a-178">Le flux de nœud parcourt des objets, des membres contenant d'autres objets, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="bf18a-178">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="bf18a-179">Il est souvent utile d'effectuer le suivi de la portée au sein du flux de nœud XAML en implémentant un concept de frame et pile.</span><span class="sxs-lookup"><span data-stu-id="bf18a-179">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="bf18a-180">Cela est particulièrement vrai si vous ajustez activement le flux de nœud pendant son traitement.</span><span class="sxs-lookup"><span data-stu-id="bf18a-180">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="bf18a-181">La prise en charge de frame et de pile que vous implémentez dans le cadre de votre logique de boucle de nœud peut dénombrer les portées `StartObject` (ou `GetObject`) et `EndObject` à mesure que vous descendez dans une structure de nœud XAML, d'un point de vue DOM.</span><span class="sxs-lookup"><span data-stu-id="bf18a-181">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="bf18a-182">Parcourir des nœuds d'objet et y entrer</span><span class="sxs-lookup"><span data-stu-id="bf18a-182">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="bf18a-183">Le premier nœud d'un flux de nœud ouvert par un lecteur XAML est le nœud d'objet de début de l'objet racine.</span><span class="sxs-lookup"><span data-stu-id="bf18a-183">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="bf18a-184">Par définition, cet objet est toujours un nœud d'objet unique, sans homologue.</span><span class="sxs-lookup"><span data-stu-id="bf18a-184">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="bf18a-185">Dans tous les exemples de code XAML réel, l'objet racine est défini pour avoir une ou plusieurs propriétés contenant d'autres objets, et ces propriétés contiennent des nœuds membres.</span><span class="sxs-lookup"><span data-stu-id="bf18a-185">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="bf18a-186">Les nœuds membres contiennent à leur tour un ou plusieurs nœuds d'objet, ou peuvent aussi se terminer dans un nœud de valeur.</span><span class="sxs-lookup"><span data-stu-id="bf18a-186">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="bf18a-187">L'objet racine définit généralement les portées de nom XAML, lesquelles sont syntaxiquement assignées en tant qu'attributs dans le balisage de texte XAML, mais mappent vers un type de nœud `Namescope` dans la représentation de flux de nœud XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-187">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="bf18a-188">Prenons l’exemple XAML suivant (c’est L’exemple arbitraire de XAML, non soutenu par les types existants en .NET).</span><span class="sxs-lookup"><span data-stu-id="bf18a-188">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in .NET).</span></span> <span data-ttu-id="bf18a-189">Supposons que dans ce modèle objet, `FavorCollection` est un `List<T>` de `Favor`, `Balloon` et `NoiseMaker` peuvent être assignés à `Favor`, la propriété `Balloon.Color` est associée à un objet `Color` semblable à la façon dont WPF définit les couleurs en tant que noms de couleurs connus, et `Color` prend en charge un convertisseur de type pour la syntaxe d'attribut.</span><span class="sxs-lookup"><span data-stu-id="bf18a-189">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="bf18a-190">Balisage XAML</span><span class="sxs-lookup"><span data-stu-id="bf18a-190">XAML markup</span></span>|<span data-ttu-id="bf18a-191">Flux de nœud XAML résultant</span><span class="sxs-lookup"><span data-stu-id="bf18a-191">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="bf18a-192">`Namespace` pour `Party`</span><span class="sxs-lookup"><span data-stu-id="bf18a-192">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="bf18a-193">`StartObject` pour `Party`</span><span class="sxs-lookup"><span data-stu-id="bf18a-193">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="bf18a-194">`StartMember` pour `Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="bf18a-194">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="bf18a-195">Nœud`StartObject` pour la collection `FavorCollection`implicite</span><span class="sxs-lookup"><span data-stu-id="bf18a-195">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="bf18a-196">Nœud`StartMember` pour la propriété des éléments de la collection `FavorCollection` implicite.</span><span class="sxs-lookup"><span data-stu-id="bf18a-196">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="bf18a-197">`StartObject` pour `Balloon`</span><span class="sxs-lookup"><span data-stu-id="bf18a-197">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="bf18a-198">`StartMember` pour `Color`</span><span class="sxs-lookup"><span data-stu-id="bf18a-198">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="bf18a-199">`Value` pour la chaîne de valeur d'attribut `"Red"`</span><span class="sxs-lookup"><span data-stu-id="bf18a-199">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="bf18a-200">`EndMember` pour `Color`</span><span class="sxs-lookup"><span data-stu-id="bf18a-200">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="bf18a-201">`StartMember` pour `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="bf18a-201">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="bf18a-202">`Value` pour la chaîne de valeur d'attribut `"True"`</span><span class="sxs-lookup"><span data-stu-id="bf18a-202">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="bf18a-203">`EndMember` pour `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="bf18a-203">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="bf18a-204">`EndObject` pour `Balloon`</span><span class="sxs-lookup"><span data-stu-id="bf18a-204">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="bf18a-205">`StartObject` pour `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="bf18a-205">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="bf18a-206">`StartMember` pour `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="bf18a-206">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="bf18a-207">`Value` pour la chaîne de valeur d'initialisation `"Loudest"`</span><span class="sxs-lookup"><span data-stu-id="bf18a-207">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="bf18a-208">`EndMember` pour `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="bf18a-208">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="bf18a-209">`EndObject` pour `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="bf18a-209">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="bf18a-210">Nœud`EndMember` pour la propriété des éléments de la collection `FavorCollection` implicite.</span><span class="sxs-lookup"><span data-stu-id="bf18a-210">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="bf18a-211">Nœud`EndObject` pour la collection `FavorCollection`implicite</span><span class="sxs-lookup"><span data-stu-id="bf18a-211">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="bf18a-212">`EndMember` pour `Favors`</span><span class="sxs-lookup"><span data-stu-id="bf18a-212">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="bf18a-213">`EndObject` pour `Party`</span><span class="sxs-lookup"><span data-stu-id="bf18a-213">`EndObject` for `Party`</span></span>|

<span data-ttu-id="bf18a-214">Dans le flux de nœud XAML, vous pouvez compter sur le comportement suivant :</span><span class="sxs-lookup"><span data-stu-id="bf18a-214">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="bf18a-215">Si un nœud `Namespace` existe, il est ajouté au flux immédiatement avant le `StartObject` qui a déclaré l'espace de noms XAML avec `xmlns`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-215">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="bf18a-216">Réexaminez le tableau précédent avec l'exemple de flux de nœud XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-216">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="bf18a-217">Notez la façon dont les nœuds `StartObject` et `Namespace` semblent être transposés par rapport à leur position de déclaration dans le balisage de texte.</span><span class="sxs-lookup"><span data-stu-id="bf18a-217">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="bf18a-218">Ceci est représentatif du comportement selon lequel les nœuds d'espace de noms apparaissent toujours avant le nœud auquel ils s'appliquent dans le flux de nœud.</span><span class="sxs-lookup"><span data-stu-id="bf18a-218">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="bf18a-219">Cette conception s'explique par le fait que les informations d'espace de noms sont essentielles pour les writers d'objet et doivent être connues avant que le writer d'objet ne tente d'effectuer le mappage de type ou de traiter l'objet.</span><span class="sxs-lookup"><span data-stu-id="bf18a-219">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="bf18a-220">Il est plus simple de placer les informations d'espace de noms XAML avant sa portée d'application dans le flux, plutôt que de traiter toujours le flux de nœud dans l'ordre présenté.</span><span class="sxs-lookup"><span data-stu-id="bf18a-220">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="bf18a-221">Par conséquent, vous lisez d'abord un ou plusieurs nœuds `Namespace` dans la plupart des cas de balisage réels lors du parcours des nœuds à partir du début, plutôt que le `StartObject` de la racine.</span><span class="sxs-lookup"><span data-stu-id="bf18a-221">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="bf18a-222">Un nœud `StartObject` peut être suivi de `StartMember`, `Value`ou d'un `EndObject`immédiat.</span><span class="sxs-lookup"><span data-stu-id="bf18a-222">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="bf18a-223">Il n'est jamais immédiatement suivi d'un autre `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-223">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="bf18a-224">Un nœud `StartMember` peut être suivi d'un nœud `StartObject`, `Value`ou d'un nœud `EndMember`immédiat.</span><span class="sxs-lookup"><span data-stu-id="bf18a-224">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="bf18a-225">Il peut être suivi d'un nœud `GetObject`, pour les membres dont la valeur est censée provenir d'une valeur existante de l'objet parent et non d'un nœud `StartObject` qui instancierait une nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="bf18a-225">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="bf18a-226">Il peut également être suivi d'un nœud `Namespace` , qui s'applique à un nœud `StartObject`à venir.</span><span class="sxs-lookup"><span data-stu-id="bf18a-226">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="bf18a-227">Il n'est jamais immédiatement suivi d'un autre `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-227">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="bf18a-228">Un nœud `Value` représente la valeur elle-même. Il n'y a pas de « EndValue ».</span><span class="sxs-lookup"><span data-stu-id="bf18a-228">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="bf18a-229">Il peut être suivi uniquement d'un nœud `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-229">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="bf18a-230">Le texte d'initialisation XAML de l'objet, tel qu'il peut être utilisé par la construction, n'entraîne pas de structure objet-valeur.</span><span class="sxs-lookup"><span data-stu-id="bf18a-230">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="bf18a-231">À la place, un nœud membre dédié à un membre nommé `_Initialization` est créé.</span><span class="sxs-lookup"><span data-stu-id="bf18a-231">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="bf18a-232">Ce nœud membre contient la chaîne de valeur d'initialisation.</span><span class="sxs-lookup"><span data-stu-id="bf18a-232">and that member node contains the initialization value string.</span></span> <span data-ttu-id="bf18a-233">S'il existe, le membre `_Initialization` est toujours le premier nœud `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-233">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="bf18a-234">Le membre`_Initialization` peut être qualifié dans certaines représentations des services XAML avec la portée de nom XAML du langage XAML, pour préciser que le membre `_Initialization` n'est pas une propriété définie dans les types de stockage.</span><span class="sxs-lookup"><span data-stu-id="bf18a-234">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="bf18a-235">Une combinaison membre-valeur représente un paramètre d'attribut de la valeur.</span><span class="sxs-lookup"><span data-stu-id="bf18a-235">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="bf18a-236">Un convertisseur de valeurs peut éventuellement être impliqué dans le traitement de cette valeur, et la valeur est une chaîne simple.</span><span class="sxs-lookup"><span data-stu-id="bf18a-236">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="bf18a-237">Toutefois, cela n'est pas évalué tant qu'un writer d'objet XAML traite ce flux de nœud.</span><span class="sxs-lookup"><span data-stu-id="bf18a-237">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="bf18a-238">Le writer d'objet XAML possède le contexte de schéma XAML, le mappage de système de type et d'autres prises en charge nécessaires pour la conversion de valeurs.</span><span class="sxs-lookup"><span data-stu-id="bf18a-238">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="bf18a-239">Un nœud `EndMember` peut être suivi d'un nœud `StartMember` pour un membre suivant ou d'un nœud `EndObject` pour le propriétaire du membre.</span><span class="sxs-lookup"><span data-stu-id="bf18a-239">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="bf18a-240">Un nœud `EndObject` peut être suivi d'un nœud `EndMember` .</span><span class="sxs-lookup"><span data-stu-id="bf18a-240">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="bf18a-241">Il peut également être suivi d'un nœud `StartObject` si les objets sont des homologues dans les éléments d'une collection.</span><span class="sxs-lookup"><span data-stu-id="bf18a-241">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="bf18a-242">Il peut également être suivi d'un nœud `Namespace` , qui s'applique à un nœud `StartObject`à venir.</span><span class="sxs-lookup"><span data-stu-id="bf18a-242">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="bf18a-243">Dans le seul cas de la fermeture du flux de nœud entier, le nœud `EndObject` de la racine n'est pas suivi, le lecteur se trouve à la fin du fichier et <xref:System.Xaml.XamlReader.Read%2A> renvoie `false`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-243">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="bf18a-244">Convertisseurs de valeurs et flux de nœud XAML</span><span class="sxs-lookup"><span data-stu-id="bf18a-244">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="bf18a-245">Un convertisseur de valeurs est un terme général qui désigne une extension de balisage, un convertisseur de type (y compris les sérialiseurs de valeur) ou une autre classe dédiée signalée comme convertisseur de valeurs via le système de type XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-245">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="bf18a-246">Dans le flux de nœud XAML, l'utilisation d'un convertisseur de type et celle d'une extension de balisage ont des représentations très différentes.</span><span class="sxs-lookup"><span data-stu-id="bf18a-246">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="bf18a-247">Convertisseurs de type et flux de nœud XAML</span><span class="sxs-lookup"><span data-stu-id="bf18a-247">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="bf18a-248">Un attribut défini, qui finit par entraîner une utilisation de convertisseur de type, est signalé dans le flux de nœud XAML comme une valeur de membre.</span><span class="sxs-lookup"><span data-stu-id="bf18a-248">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="bf18a-249">Le flux de nœud XAML ne tente pas de générer un objet d'instance de convertisseur de type et de lui passer la valeur.</span><span class="sxs-lookup"><span data-stu-id="bf18a-249">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="bf18a-250">L'implémentation de la conversion d'un convertisseur de type requiert l'appel du contexte de schéma XAML et son utilisation pour le mappage de type.</span><span class="sxs-lookup"><span data-stu-id="bf18a-250">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="bf18a-251">De la même façon, le contexte de schéma XAML est requis indirectement pour déterminer la classe de convertisseur de type qui doit être utilisée pour traiter la valeur.</span><span class="sxs-lookup"><span data-stu-id="bf18a-251">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="bf18a-252">Quand vous utilisez le contexte de schéma XAML par défaut, ces informations sont disponibles à partir du système de type XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-252">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="bf18a-253">Si vous avez besoin des informations de classe de convertisseur de type au niveau du flux de nœud XAML avant la connexion à un writer XAML, vous pouvez les obtenir à partir des informations de <xref:System.Xaml.XamlMember> du membre défini.</span><span class="sxs-lookup"><span data-stu-id="bf18a-253">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="bf18a-254">Mais autrement, l’entrée de convertisseur de type doit être préservée dans le flux de nœuds XAML comme valeur simple jusqu’à ce que le reste des opérations qui nécessitent le système de cartographie de type et le contexte du schéma XAML sont exécutés, par exemple la création d’objet par un auteur d’objets XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-254">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type-mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="bf18a-255">Par exemple, considérez la structure de définition de classe suivante et son utilisation de code XAML :</span><span class="sxs-lookup"><span data-stu-id="bf18a-255">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="bf18a-256">Une représentation textuelle du flux de nœud XAML pour cette utilisation peut être exprimée comme suit :</span><span class="sxs-lookup"><span data-stu-id="bf18a-256">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="bf18a-257">`StartObject` avec <xref:System.Xaml.XamlType> représentant `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="bf18a-257">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="bf18a-258">`StartMember` avec <xref:System.Xaml.XamlMember> représentant `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="bf18a-258">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="bf18a-259">Le nœud`Value` , avec la chaîne de texte «`8x8`»</span><span class="sxs-lookup"><span data-stu-id="bf18a-259">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="bf18a-260">`EndMember` correspond à `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="bf18a-260">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="bf18a-261">`EndObject` correspond à `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="bf18a-261">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="bf18a-262">Notez qu'il n'y a aucune instance de convertisseur de type dans ce flux de nœud.</span><span class="sxs-lookup"><span data-stu-id="bf18a-262">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="bf18a-263">Mais vous pouvez obtenir des informations sur le convertisseur de type en appelant <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> sur le <xref:System.Xaml.XamlMember> pour `BoardSize`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-263">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="bf18a-264">Si vous disposez d'un contexte de schéma XAML valide, vous pouvez également appeler les méthodes du convertisseur en obtenant une instance à partir de <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-264">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="bf18a-265">Extensions de balisage dans le flux de nœud XAML</span><span class="sxs-lookup"><span data-stu-id="bf18a-265">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="bf18a-266">L'utilisation d'une extension de balisage est signalée dans le flux de nœud XAML en tant que nœud d'objet dans un membre, où l'objet représente une instance d'extension de balisage.</span><span class="sxs-lookup"><span data-stu-id="bf18a-266">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="bf18a-267">Par conséquent, une extension de balisage est présentée plus explicitement dans la représentation de flux de nœud qu'une utilisation de convertisseur de type, et comporte plus d'informations.</span><span class="sxs-lookup"><span data-stu-id="bf18a-267">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="bf18a-268">Les informations relatives à<xref:System.Xaml.XamlMember> ne vous renseignent pas sur l'extension de balisage, car l'utilisation est situationnelle et varie selon chaque cas de balisage possible. Elle n'est ni dédiée ni implicite pour un type ou un membre, contrairement aux convertisseurs de type.</span><span class="sxs-lookup"><span data-stu-id="bf18a-268"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="bf18a-269">C'est le cas notamment de la représentation de flux de nœud des extensions de balisage en tant que nœuds d'objet, même si l'utilisation de l'extension de balisage a été effectuée sous forme d'attribut dans le balisage de texte XAML (ce qui se produit souvent).</span><span class="sxs-lookup"><span data-stu-id="bf18a-269">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="bf18a-270">Les cas d'utilisation d'extension de balisage qui utilisaient un formulaire d'élément objet explicite sont traités de la même façon.</span><span class="sxs-lookup"><span data-stu-id="bf18a-270">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="bf18a-271">Un nœud d'objet d'extension de balisage peut comporter des membres de cette extension de balisage.</span><span class="sxs-lookup"><span data-stu-id="bf18a-271">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="bf18a-272">La représentation de flux de nœud XAML conserve l'utilisation de cette extension de balisage, qu'il s'agisse d'une utilisation de paramètres positionnels ou d'une utilisation avec des paramètres nommés explicites.</span><span class="sxs-lookup"><span data-stu-id="bf18a-272">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="bf18a-273">Pour une utilisation de paramètres positionnels, le flux de nœud XAML contient une propriété `_PositionalParameters` définie en langage XAML qui enregistre cette utilisation.</span><span class="sxs-lookup"><span data-stu-id="bf18a-273">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="bf18a-274">Cette propriété est un <xref:System.Collections.Generic.List%601> générique avec une contrainte <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="bf18a-274">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="bf18a-275">La contrainte est un objet et non une chaîne, car en théorie l'utilisation d'un paramètre positionnel peut contenir des utilisations d'extension de balisage imbriquées.</span><span class="sxs-lookup"><span data-stu-id="bf18a-275">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="bf18a-276">Pour accéder aux paramètres positionnels à partir de l'utilisation, vous pouvez effectuer une itération dans la liste et utiliser les indexeurs pour les valeurs de liste individuelles.</span><span class="sxs-lookup"><span data-stu-id="bf18a-276">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="bf18a-277">Pour l'utilisation d'un paramètre nommé, chaque paramètre nommé est représenté comme un nœud du membre du même nom dans le flux de nœud.</span><span class="sxs-lookup"><span data-stu-id="bf18a-277">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="bf18a-278">Les valeurs de membre ne sont pas nécessairement des chaînes, car il peut y avoir une utilisation d'extension de balisage imbriquée.</span><span class="sxs-lookup"><span data-stu-id="bf18a-278">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="bf18a-279">`ProvideValue` n'est pas encore appelé dans l'extension de balisage.</span><span class="sxs-lookup"><span data-stu-id="bf18a-279">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="bf18a-280">Toutefois, il est appelé si vous connectez un lecteur et un writer XAML de sorte que `WriteEndObject` soit appelé sur le nœud d'extension de balisage quand vous l'examinez dans le flux de nœud.</span><span class="sxs-lookup"><span data-stu-id="bf18a-280">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="bf18a-281">Pour cette raison, vous avez généralement besoin du même contexte de schéma XAML que celui que vous utilisez pour former le graphique d'objet sur le chemin de chargement.</span><span class="sxs-lookup"><span data-stu-id="bf18a-281">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="bf18a-282">Sinon, `ProvideValue` dans n'importe quelle extension de balisage peut lever des exceptions, car les services attendus ne sont pas disponibles.</span><span class="sxs-lookup"><span data-stu-id="bf18a-282">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="bf18a-283">Membres définis en langage XAML et XML dans le flux de nœud XAML</span><span class="sxs-lookup"><span data-stu-id="bf18a-283">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="bf18a-284">Certains membres sont présentés dans un flux de nœud XAML en raison des interprétations et des conventions d'un lecteur XAML, et non par le biais de la recherche ou la construction d'un <xref:System.Xaml.XamlMember> explicite.</span><span class="sxs-lookup"><span data-stu-id="bf18a-284">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="bf18a-285">Souvent, ces membres sont des directives XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-285">Often, these members are XAML directives.</span></span> <span data-ttu-id="bf18a-286">Dans certains cas, c'est la lecture du code XAML qui présente la directive dans le flux de nœud XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-286">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="bf18a-287">En d’autres termes, le texte d’entrée originale XAML n’a pas précisé explicitement la directive membre, mais le lecteur XAML insère la directive afin de satisfaire une convention structurelle XAML et de rapporter des informations dans le flux de nœuds XAML avant que ces informations ne sont perdues.</span><span class="sxs-lookup"><span data-stu-id="bf18a-287">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="bf18a-288">La liste suivante note tous les cas où un lecteur XAML est censé introduire une directive XAML nœud membre, et comment ce nœud membre est identifié dans .NET XAML Services mises en œuvre.</span><span class="sxs-lookup"><span data-stu-id="bf18a-288">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in .NET XAML Services implementations.</span></span>

- <span data-ttu-id="bf18a-289">**Texte d'initialisation d'un nœud d'objet :** le nom de ce nœud membre est `_Initialization`, il représente une directive XAML et est défini dans l'espace de noms XAML du langage XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-289">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="bf18a-290">Vous pouvez en obtenir une entité statique à partir de <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-290">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="bf18a-291">**Paramètres positionnels d'une extension de balisage :** le nom de ce nœud membre est `_PositionalParameters`et est défini dans l'espace de noms XAML du langage XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-291">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="bf18a-292">Il contient toujours une liste générique d'objets, chacun d'eux étant un paramètre positionnel préalablement séparé par fractionnement à partir du caractère délimiteur `,` fourni dans le XAML d'entrée.</span><span class="sxs-lookup"><span data-stu-id="bf18a-292">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="bf18a-293">Vous pouvez obtenir une entité statique pour la directive de paramètres positionnels à partir de <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-293">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="bf18a-294">**Contenu inconnu :** le nom de ce nœud membre est `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-294">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="bf18a-295">Proprement dit, il s'agit d'une directive <xref:System.Xaml.XamlDirective>définie dans l'espace de noms XAML du langage XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-295">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="bf18a-296">Cette directive est utilisée comme sentinelle au cas où  un élément objet XAML contient le contenu de la source XAML, mais qu'aucune propriété de contenu ne peut être déterminée dans le contexte de schéma XAML actuellement disponible.</span><span class="sxs-lookup"><span data-stu-id="bf18a-296">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="bf18a-297">Vous pouvez détecter ce cas dans un flux de nœud XAML en recherchant les membres nommés `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-297">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="bf18a-298">Si aucune autre action n'est effectuée dans un flux de nœud XAML de chemin de chargement, le nœud <xref:System.Xaml.XamlObjectWriter> par défaut lève une exception sur une tentative de `WriteEndObject` quand il rencontre le membre `_UnknownContent` sur un objet.</span><span class="sxs-lookup"><span data-stu-id="bf18a-298">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="bf18a-299">Le writer <xref:System.Xaml.XamlXmlWriter> par défaut ne lève pas d'exception et traite le membre comme s'il était implicite.</span><span class="sxs-lookup"><span data-stu-id="bf18a-299">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="bf18a-300">Vous pouvez obtenir une entité statique pour `_UnknownContent` à partir de <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-300">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="bf18a-301">**Propriété de collecte d’une collection :** Bien que le type DE CLR de soutien d’une classe de collecte qui est utilisé pour XAML a généralement une propriété dédiée nommée qui détient les éléments de collecte, cette propriété n’est pas connue d’un système de type XAML avant la résolution de type de support.</span><span class="sxs-lookup"><span data-stu-id="bf18a-301">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="bf18a-302">Au lieu de cela, le flux de nœud XAML présente un espace réservé `Items` en tant que membre du type XAML de la collection.</span><span class="sxs-lookup"><span data-stu-id="bf18a-302">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="bf18a-303">Dans la mise en œuvre de .NET XAML Services, le nom de cette directive ou membre dans le flux de nœuds est `_Items`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-303">In .NET XAML Services implementation, the name of this directive or member in the node stream is `_Items`.</span></span> <span data-ttu-id="bf18a-304">Une constante pour cette directive peut être obtenue à partir de <xref:System.Xaml.XamlLanguage.Items%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-304">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="bf18a-305">Notez qu’un flux de nœuds XAML peut contenir une propriété Items avec des éléments qui s’avèrent ne pas être parsables en fonction de la résolution de type de support et le contexte du schéma XAML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-305">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="bf18a-306">Par exemple,</span><span class="sxs-lookup"><span data-stu-id="bf18a-306">For example,</span></span>

- <span data-ttu-id="bf18a-307">**Membres définis par XML :** Le `xml:base`XML-défini `xml:lang` `xml:space` , et les membres sont `base` `lang`signalés `space` comme directives XAML nommé , , et dans .NET XAML Services implémentations.</span><span class="sxs-lookup"><span data-stu-id="bf18a-307">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in .NET XAML Services implementations.</span></span> <span data-ttu-id="bf18a-308">L'espace de noms pour ces directives est l'espace de noms XML `http://www.w3.org/XML/1998/namespace`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-308">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="bf18a-309">Des constantes pour chacune d'elles peuvent être obtenues à partir de <xref:System.Xaml.XamlLanguage>.</span><span class="sxs-lookup"><span data-stu-id="bf18a-309">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="bf18a-310">Ordre des nœuds</span><span class="sxs-lookup"><span data-stu-id="bf18a-310">Node Order</span></span>

<span data-ttu-id="bf18a-311">Dans certains cas, <xref:System.Xaml.XamlXmlReader> modifie l'ordre des nœuds XAML dans le flux de nœud XAML, par rapport à l'ordre des nœuds affichés dans le balisage ou traités en tant que XML.</span><span class="sxs-lookup"><span data-stu-id="bf18a-311">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="bf18a-312">Cela permet de classer les nœuds de sorte qu'un <xref:System.Xaml.XamlObjectWriter> puisse traiter le flux de nœud uniquement vers l'avant.</span><span class="sxs-lookup"><span data-stu-id="bf18a-312">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="bf18a-313">Dans .NET XAML Services, le lecteur XAML réorganise les nœuds plutôt que de laisser cette tâche à l’auteur XAML, comme une optimisation des performances pour les consommateurs XAML écrivain objet du flux de nœuds.</span><span class="sxs-lookup"><span data-stu-id="bf18a-313">In .NET XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="bf18a-314">Certaines directives sont conçues spécifiquement pour fournir plus d'informations sur la création d'un objet à partir d'un élément objet.</span><span class="sxs-lookup"><span data-stu-id="bf18a-314">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="bf18a-315">Ces directives sont les suivantes : `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span><span class="sxs-lookup"><span data-stu-id="bf18a-315">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="bf18a-316">.NET XAML Services lecteurs XAML tentent de placer ces directives comme les `StartObject`premiers membres dans le flux de nœuds suivant un objet , pour des raisons qui sont expliquées dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="bf18a-316">.NET XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="bf18a-317">Comportement de XamlObjectWriter et ordre des nœuds</span><span class="sxs-lookup"><span data-stu-id="bf18a-317">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="bf18a-318">Un nœud`StartObject` pour un <xref:System.Xaml.XamlObjectWriter> ne signifie pas nécessairement que le writer d'objet XAML doit immédiatement créer l'instance d'objet.</span><span class="sxs-lookup"><span data-stu-id="bf18a-318">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="bf18a-319">XAML comprend plusieurs caractéristiques linguistiques qui permettent d’initialiser un objet avec une entrée supplémentaire, et de ne pas compter entièrement sur l’invocation d’un constructeur sans paramètres pour produire l’objet initial, et seulement alors la mise en place des propriétés.</span><span class="sxs-lookup"><span data-stu-id="bf18a-319">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a parameterless constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="bf18a-320">Ces fonctionnalités sont notamment les suivantes : <xref:System.Windows.Markup.XamlDeferLoadAttribute>; texte d'initialisation ; [x: TypeArguments](xtypearguments-directive.md); paramètres positionnels d'une extension de balisage ; méthodes de fabrique et nœuds [x: Arguments](xarguments-directive.md) associés (XAML 2009).</span><span class="sxs-lookup"><span data-stu-id="bf18a-320">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](xtypearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](xarguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="bf18a-321">Chacun de ces cas retarde la construction réelle de l’objet, et parce que le flux de nœud est réorganisé, l’auteur d’objets XAML peut s’appuyer sur un comportement de construire réellement l’instance chaque fois qu’un membre de démarrage est rencontré qui n’est pas spécifiquement une directive de construction pour ce type d’objet.</span><span class="sxs-lookup"><span data-stu-id="bf18a-321">Each of these cases delays the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="bf18a-322">GetObject</span><span class="sxs-lookup"><span data-stu-id="bf18a-322">GetObject</span></span>

<span data-ttu-id="bf18a-323">`GetObject` représente un nœud XAML dans lequel un writer d'objet XAML doit obtenir la valeur de la propriété contenant l'objet au lieu de construire un objet.</span><span class="sxs-lookup"><span data-stu-id="bf18a-323">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="bf18a-324">Généralement, un nœud `GetObject` est rencontré dans un flux de nœud XAML pour un objet collection ou un objet dictionnaire, quand la propriété conteneur est délibérément en lecture seule dans le modèle d'objet du type de stockage.</span><span class="sxs-lookup"><span data-stu-id="bf18a-324">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="bf18a-325">Dans ce cas, la collection ou le dictionnaire est souvent créé et initialisé (généralement vide) par la logique d'initialisation d'un type propriétaire.</span><span class="sxs-lookup"><span data-stu-id="bf18a-325">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="bf18a-326">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="bf18a-326">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- [<span data-ttu-id="bf18a-327">Services XAML</span><span class="sxs-lookup"><span data-stu-id="bf18a-327">XAML Services</span></span>](index.md)
- [<span data-ttu-id="bf18a-328">Espaces de noms XAML</span><span class="sxs-lookup"><span data-stu-id="bf18a-328">XAML Namespaces</span></span>](namespaces.md)
