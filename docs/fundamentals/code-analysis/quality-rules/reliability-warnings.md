---
title: Règles de fiabilité (analyse du code)
description: En savoir plus sur les règles de fiabilité de l’analyse du code.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/07/2020
ms.locfileid: "96587798"
---
# <a name="reliability-rules"></a><span data-ttu-id="c0314-103">Règles de fiabilité</span><span class="sxs-lookup"><span data-stu-id="c0314-103">Reliability rules</span></span>

<span data-ttu-id="c0314-104">Les règles de fiabilité prennent en charge la fiabilité des bibliothèques et des applications, telles que la mémoire et l’utilisation des threads.</span><span class="sxs-lookup"><span data-stu-id="c0314-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="c0314-105">Les règles de fiabilité sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="c0314-105">The reliability rules include:</span></span>

|<span data-ttu-id="c0314-106">Règle</span><span class="sxs-lookup"><span data-stu-id="c0314-106">Rule</span></span>|<span data-ttu-id="c0314-107">Description</span><span class="sxs-lookup"><span data-stu-id="c0314-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="c0314-108">CA2000 : Supprimer les objets avant la mise hors de portée</span><span class="sxs-lookup"><span data-stu-id="c0314-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="c0314-109">Sachant qu'un événement exceptionnel peut se produire et empêcher l'exécution du finaliseur d'un objet, ce dernier doit plutôt être supprimé explicitement avant que toutes les références à lui soient hors de portée.</span><span class="sxs-lookup"><span data-stu-id="c0314-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="c0314-110">CA2002 : Ne définissez pas un verrou sur des objets à identité faible</span><span class="sxs-lookup"><span data-stu-id="c0314-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="c0314-111">Un objet est dit d'identité faible lorsqu'il est accessible directement au-delà des limites d'un domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="c0314-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="c0314-112">Un thread qui essaie d'acquérir un verrou sur un objet qui affiche une identité faible peut être bloqué par un deuxième thread dans un domaine d'application différent qui dispose d'un verrou sur le même objet.</span><span class="sxs-lookup"><span data-stu-id="c0314-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="c0314-113">CA2007 : N’attendez pas directement une Tâche</span><span class="sxs-lookup"><span data-stu-id="c0314-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="c0314-114">Une méthode asynchrone [attend](../../../csharp/language-reference/operators/await.md) directement un <xref:System.Threading.Tasks.Task> .</span><span class="sxs-lookup"><span data-stu-id="c0314-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="c0314-115">CA2008 : Ne pas créer de tâches sans passer TaskScheduler</span><span class="sxs-lookup"><span data-stu-id="c0314-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="c0314-116">Une opération de création de tâche ou de continuation utilise une surcharge de méthode qui ne spécifie pas de <xref:System.Threading.Tasks.TaskScheduler> paramètre.</span><span class="sxs-lookup"><span data-stu-id="c0314-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="c0314-117">CA2009 : N’appelez pas ToImmutableCollection sur une valeur ImmutableCollection</span><span class="sxs-lookup"><span data-stu-id="c0314-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="c0314-118">`ToImmutable` la méthode était inutilement appelée sur une collection immuable de l' <xref:System.Collections.Immutable> espace de noms.</span><span class="sxs-lookup"><span data-stu-id="c0314-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="c0314-119">CA2011 : Ne pas assigner la propriété dans son setter</span><span class="sxs-lookup"><span data-stu-id="c0314-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="c0314-120">Une valeur a été assignée par erreur à une propriété dans son propre [accesseur Set](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span><span class="sxs-lookup"><span data-stu-id="c0314-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="c0314-121">CA2012 : Utiliser correctement ValueTasks</span><span class="sxs-lookup"><span data-stu-id="c0314-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="c0314-122">Les ValueTasks retournés par les appels de membres sont censés être attendus directement.</span><span class="sxs-lookup"><span data-stu-id="c0314-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="c0314-123">Toute tentative d’utilisation d’un ValueTask à plusieurs reprises ou d’un accès direct à l’un des résultats avant qu’il ne soit connu peut entraîner une exception ou une altération.</span><span class="sxs-lookup"><span data-stu-id="c0314-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="c0314-124">En ignorant ce ValueTask, il est probable qu’il s’agit d’une indication d’un bogue fonctionnel et peut nuire aux performances.</span><span class="sxs-lookup"><span data-stu-id="c0314-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="c0314-125">CA2013 : Ne pas utiliser ReferenceEquals avec des types valeur</span><span class="sxs-lookup"><span data-stu-id="c0314-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="c0314-126">Lors de la comparaison de valeurs à l’aide <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> de, si objA et objB sont des types valeur, ils sont boxed avant d’être passés à la <xref:System.Object.ReferenceEquals%2A> méthode.</span><span class="sxs-lookup"><span data-stu-id="c0314-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="c0314-127">Cela signifie que même si objA et objB représentent la même instance d’un type valeur, la <xref:System.Object.ReferenceEquals%2A> méthode retourne néanmoins false.</span><span class="sxs-lookup"><span data-stu-id="c0314-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="c0314-128">Ca2014 : n’utilisez pas stackalloc dans les boucles.</span><span class="sxs-lookup"><span data-stu-id="c0314-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="c0314-129">L’espace de pile alloué par stackalloc est libéré uniquement à la fin de l’appel de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="c0314-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="c0314-130">Son utilisation dans une boucle peut entraîner une croissance de pile illimitée et des conditions de dépassement de capacité de pile éventuelles.</span><span class="sxs-lookup"><span data-stu-id="c0314-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="c0314-131">Ca2015 : ne définissez pas de finaliseur pour les types dérivés de MemoryManager &lt; T&gt;</span><span class="sxs-lookup"><span data-stu-id="c0314-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="c0314-132">L’ajout d’un finaliseur à un type dérivé de <xref:System.Buffers.MemoryManager%601> peut permettre la libération de la mémoire pendant qu’il est toujours utilisé par un <xref:System.Span%601> .</span><span class="sxs-lookup"><span data-stu-id="c0314-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="c0314-133">CA2016 : Transférer le paramètre CancellationToken aux méthodes qui l’acceptent</span><span class="sxs-lookup"><span data-stu-id="c0314-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="c0314-134">Transférez le `CancellationToken` paramètre aux méthodes qui prennent une pour garantir que les notifications d’annulation d’opération sont correctement propagées, ou transmettez `CancellationToken.None` explicitement pour indiquer intentionnellement que le jeton n’est pas propagé.</span><span class="sxs-lookup"><span data-stu-id="c0314-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
