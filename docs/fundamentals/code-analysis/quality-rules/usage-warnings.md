---
title: Règles d’utilisation (analyse du code)
description: En savoir plus sur les règles d’utilisation de l’analyse du code.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: c8b14d2f92502d5a82e41a322e599745bdcf8b85
ms.sourcegitcommit: a6bd4cad438fe479cbd112eae10f2cd449f06e40
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/08/2020
ms.locfileid: "96588083"
---
# <a name="usage-rules"></a><span data-ttu-id="02884-103">Règles d’utilisation</span><span class="sxs-lookup"><span data-stu-id="02884-103">Usage rules</span></span>

<span data-ttu-id="02884-104">Les règles d’utilisation prennent en charge l’utilisation correcte de .NET.</span><span class="sxs-lookup"><span data-stu-id="02884-104">Usage rules support proper usage of .NET.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="02884-105">Dans cette section</span><span class="sxs-lookup"><span data-stu-id="02884-105">In this section</span></span>

|<span data-ttu-id="02884-106">Règle</span><span class="sxs-lookup"><span data-stu-id="02884-106">Rule</span></span>|<span data-ttu-id="02884-107">Description</span><span class="sxs-lookup"><span data-stu-id="02884-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="02884-108">CA1801 : Passez en revue les paramètres inutilisés</span><span class="sxs-lookup"><span data-stu-id="02884-108">CA1801: Review unused parameters</span></span>](ca1801.md)|<span data-ttu-id="02884-109">Une signature de méthode inclut un paramètre qui n'est pas utilisé dans le corps de la méthode.</span><span class="sxs-lookup"><span data-stu-id="02884-109">A method signature includes a parameter that is not used in the method body.</span></span>|
|[<span data-ttu-id="02884-110">CA1816 : Appeler GC.SuppressFinalize correctement</span><span class="sxs-lookup"><span data-stu-id="02884-110">CA1816: Call GC.SuppressFinalize correctly</span></span>](ca1816.md)|<span data-ttu-id="02884-111">Une méthode qui est une implémentation de dispose n’appelle pas `GC.SuppressFinalize` ; ou une méthode qui n’est pas une implémentation d' `Dispose` appels `GC.SuppressFinalize` ; ou une méthode appelle `GC.SuppressFinalize` et passe autre chose que `this` ( `Me` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="02884-111">A method that is an implementation of Dispose does not call `GC.SuppressFinalize`; or a method that is not an implementation of `Dispose` calls `GC.SuppressFinalize`; or a method calls `GC.SuppressFinalize` and passes something other than `this` (`Me` in Visual Basic).</span></span>|
|[<span data-ttu-id="02884-112">CA2200 : Levez à nouveau une exception pour conserver les détails de la pile</span><span class="sxs-lookup"><span data-stu-id="02884-112">CA2200: Rethrow to preserve stack details</span></span>](ca2200.md)|<span data-ttu-id="02884-113">Une exception est à nouveau levée et est spécifiée explicitement dans l'instruction throw.</span><span class="sxs-lookup"><span data-stu-id="02884-113">An exception is rethrown and the exception is explicitly specified in the throw statement.</span></span> <span data-ttu-id="02884-114">Si une exception est à nouveau levée par sa spécification dans l'instruction throw, la liste des appels de méthode présents entre la méthode d'origine qui a levé l'exception et la méthode actuelle est perdue.</span><span class="sxs-lookup"><span data-stu-id="02884-114">If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</span></span>|
|[<span data-ttu-id="02884-115">CA2201 : Ne levez pas des types d'exceptions réservés</span><span class="sxs-lookup"><span data-stu-id="02884-115">CA2201: Do not raise reserved exception types</span></span>](ca2201.md)|<span data-ttu-id="02884-116">Cela rend l’erreur d’origine difficile à détecter et à déboguer.</span><span class="sxs-lookup"><span data-stu-id="02884-116">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="02884-117">CA2207 : Initialisez les champs statiques des types valeur en ligne</span><span class="sxs-lookup"><span data-stu-id="02884-117">CA2207: Initialize value type static fields inline</span></span>](ca2207.md)|<span data-ttu-id="02884-118">Un type valeur déclare un constructeur statique explicite.</span><span class="sxs-lookup"><span data-stu-id="02884-118">A value type declares an explicit static constructor.</span></span> <span data-ttu-id="02884-119">Pour corriger une violation de cette règle, initialisez toutes les données statiques lorsqu’elles sont déclarées et supprimez le constructeur statique.</span><span class="sxs-lookup"><span data-stu-id="02884-119">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span>|
|[<span data-ttu-id="02884-120">CA2208 : Instanciez les exceptions d'argument comme il se doit</span><span class="sxs-lookup"><span data-stu-id="02884-120">CA2208: Instantiate argument exceptions correctly</span></span>](ca2208.md)|<span data-ttu-id="02884-121">Un appel est passé au constructeur par défaut (sans paramètre) d'un type d'exception qui est ou dérive d'ArgumentException, ou un argument string incorrect est passé à un constructeur paramétrable d'un type d'exception qui est ou dérive d'ArgumentException.</span><span class="sxs-lookup"><span data-stu-id="02884-121">A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</span></span>|
|[<span data-ttu-id="02884-122">CA2211 : Les champs non constants ne doivent pas être visibles</span><span class="sxs-lookup"><span data-stu-id="02884-122">CA2211: Non-constant fields should not be visible</span></span>](ca2211.md)|<span data-ttu-id="02884-123">Les champs statiques qui ne sont pas des constantes ou en lecture seule ne sont pas thread-safe.</span><span class="sxs-lookup"><span data-stu-id="02884-123">Static fields that are not constants or read-only are not thread-safe.</span></span> <span data-ttu-id="02884-124">L’accès à ce champ doit être contrôlé avec soin et nécessite des techniques de programmation avancées pour la synchronisation de l’accès à l’objet de classe.</span><span class="sxs-lookup"><span data-stu-id="02884-124">Access to such a field must be carefully controlled and requires advanced programming techniques for synchronizing access to the class object.</span></span>|
|[<span data-ttu-id="02884-125">CA2213 : Les champs pouvant être supprimés doivent l’être</span><span class="sxs-lookup"><span data-stu-id="02884-125">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)|<span data-ttu-id="02884-126">Un type qui implémente <xref:System.IDisposable?displayProperty=fullName> déclare des champs de types qui implémentent également `IDisposable` .</span><span class="sxs-lookup"><span data-stu-id="02884-126">A type that implements <xref:System.IDisposable?displayProperty=fullName> declares fields that are of types that also implement `IDisposable`.</span></span> <span data-ttu-id="02884-127">La `Dispose` méthode du champ n’est pas appelée par la `Dispose` méthode du type déclarant.</span><span class="sxs-lookup"><span data-stu-id="02884-127">The `Dispose` method of the field is not called by the `Dispose` method of the declaring type.</span></span>|
|[<span data-ttu-id="02884-128">CA2214 : N'appelez pas de méthodes substituables dans les constructeurs</span><span class="sxs-lookup"><span data-stu-id="02884-128">CA2214: Do not call overridable methods in constructors</span></span>](ca2214.md)|<span data-ttu-id="02884-129">Quand un constructeur appelle une méthode virtuelle, il est possible que le constructeur de l’instance qui appelle la méthode n’ait pas été exécuté.</span><span class="sxs-lookup"><span data-stu-id="02884-129">When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed.</span></span>|
|[<span data-ttu-id="02884-130">CA2215 : Les méthodes Dispose doivent appeler la méthode Dispose de la classe de base</span><span class="sxs-lookup"><span data-stu-id="02884-130">CA2215: Dispose methods should call base class dispose</span></span>](ca2215.md)|<span data-ttu-id="02884-131">Si un type hérite d’un type supprimable, il doit appeler la `Dispose` méthode du type de base à partir de sa propre `Dispose` méthode.</span><span class="sxs-lookup"><span data-stu-id="02884-131">If a type inherits from a disposable type, it must call the `Dispose` method of the base type from its own `Dispose` method.</span></span>|
|[<span data-ttu-id="02884-132">CA2216 : Les types pouvant être supprimés doivent déclarer un finaliseur</span><span class="sxs-lookup"><span data-stu-id="02884-132">CA2216: Disposable types should declare finalizer</span></span>](ca2216.md)|<span data-ttu-id="02884-133">Un type qui implémente <xref:System.IDisposable?displayProperty=fullName> et a des champs qui suggèrent l’utilisation de ressources non managées, n’implémente pas de finaliseur comme décrit par `Object.Finalize` .</span><span class="sxs-lookup"><span data-stu-id="02884-133">A type that implements <xref:System.IDisposable?displayProperty=fullName>, and has fields that suggest the use of unmanaged resources, does not implement a finalizer as described by `Object.Finalize`.</span></span>|
|[<span data-ttu-id="02884-134">CA2217 : Ne marquez pas les enums avec l'attribut FlagsAttribute</span><span class="sxs-lookup"><span data-stu-id="02884-134">CA2217: Do not mark enums with FlagsAttribute</span></span>](ca2217.md)|<span data-ttu-id="02884-135">Une énumération visible de l’extérieur est marquée avec `FlagsAttribute` , et elle a une ou plusieurs valeurs qui ne sont pas des puissances de deux ou une combinaison des autres valeurs définies sur l’énumération.</span><span class="sxs-lookup"><span data-stu-id="02884-135">An externally visible enumeration is marked with `FlagsAttribute`, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</span></span>|
|[<span data-ttu-id="02884-136">CA2218 : Remplacez GetHashCode au moment de remplacer Equals</span><span class="sxs-lookup"><span data-stu-id="02884-136">CA2218: Override GetHashCode on overriding Equals</span></span>](ca2218.md)|<span data-ttu-id="02884-137">Un type public substitue <xref:System.Object.Equals%2A?displayProperty=fullName> mais ne remplace pas <xref:System.Object.GetHashCode%2A?displayProperty=fullName> .</span><span class="sxs-lookup"><span data-stu-id="02884-137">A public type overrides <xref:System.Object.Equals%2A?displayProperty=fullName> but does not override <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="02884-138">CA2219 : Ne pas lever d'exceptions dans les clauses d'exception</span><span class="sxs-lookup"><span data-stu-id="02884-138">CA2219: Do not raise exceptions in exception clauses</span></span>](ca2219.md)|<span data-ttu-id="02884-139">Lorsqu'une exception est levée dans une clause finally ou fault, la nouvelle exception masque l'exception active.</span><span class="sxs-lookup"><span data-stu-id="02884-139">When an exception is raised in a finally or fault clause, the new exception hides the active exception.</span></span> <span data-ttu-id="02884-140">Lorsqu'une exception est levée dans une clause filter, le runtime l'intercepte en silence.</span><span class="sxs-lookup"><span data-stu-id="02884-140">When an exception is raised in a filter clause, the run time silently catches the exception.</span></span> <span data-ttu-id="02884-141">Cela rend l’erreur d’origine difficile à détecter et à déboguer.</span><span class="sxs-lookup"><span data-stu-id="02884-141">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="02884-142">CA2224 : Remplacez Equals au moment de surcharger l'opérateur égal</span><span class="sxs-lookup"><span data-stu-id="02884-142">CA2224: Override equals on overloading operator equals</span></span>](ca2224.md)|<span data-ttu-id="02884-143">Un type public implémente l’opérateur d’égalité, mais ne remplace pas <xref:System.Object.Equals%2A?displayProperty=fullName> .</span><span class="sxs-lookup"><span data-stu-id="02884-143">A public type implements the equality operator but doesn't override <xref:System.Object.Equals%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="02884-144">CA2225 : Les surcharges d'opérateur offrent d'autres méthodes nommées</span><span class="sxs-lookup"><span data-stu-id="02884-144">CA2225: Operator overloads have named alternates</span></span>](ca2225.md)|<span data-ttu-id="02884-145">Une surcharge d'opérateur a été détectée, et la méthode de substitution nommée attendue n'a pas été trouvée.</span><span class="sxs-lookup"><span data-stu-id="02884-145">An operator overload was detected, and the expected named alternative method was not found.</span></span> <span data-ttu-id="02884-146">Le membre de substitution nommé fournit l’accès aux mêmes fonctionnalités que l’opérateur et est fourni aux développeurs qui programment dans des langages qui ne prennent pas en charge les opérateurs surchargés.</span><span class="sxs-lookup"><span data-stu-id="02884-146">The named alternative member provides access to the same functionality as the operator, and is provided for developers who program in languages that do not support overloaded operators.</span></span>|
|[<span data-ttu-id="02884-147">CA2226 : Les opérateurs doivent contenir des surcharges symétriques</span><span class="sxs-lookup"><span data-stu-id="02884-147">CA2226: Operators should have symmetrical overloads</span></span>](ca2226.md)|<span data-ttu-id="02884-148">Un type implémente l’opérateur d’égalité ou d’inégalité et n’implémente pas l’opérateur opposé.</span><span class="sxs-lookup"><span data-stu-id="02884-148">A type implements the equality or inequality operator, and does not implement the opposite operator.</span></span>|
|[<span data-ttu-id="02884-149">CA2227 : Les propriétés de collection doivent être en lecture seule</span><span class="sxs-lookup"><span data-stu-id="02884-149">CA2227: Collection properties should be read only</span></span>](ca2227.md)|<span data-ttu-id="02884-150">Une propriété de collection accessible en écriture permet à un utilisateur de remplacer la collection par une collection différente.</span><span class="sxs-lookup"><span data-stu-id="02884-150">A writable collection property allows a user to replace the collection with a different collection.</span></span> <span data-ttu-id="02884-151">Une propriété en lecture seule empêche le remplacement de la collection, mais permet quand même aux membres individuels d’être définis.</span><span class="sxs-lookup"><span data-stu-id="02884-151">A read-only property stops the collection from being replaced but still allows the individual members to be set.</span></span>|
|[<span data-ttu-id="02884-152">CA2229 : Implémentez des constructeurs de sérialisation</span><span class="sxs-lookup"><span data-stu-id="02884-152">CA2229: Implement serialization constructors</span></span>](ca2229.md)|<span data-ttu-id="02884-153">Pour corriger une violation de cette règle, implémentez le constructeur de sérialisation.</span><span class="sxs-lookup"><span data-stu-id="02884-153">To fix a violation of this rule, implement the serialization constructor.</span></span> <span data-ttu-id="02884-154">Dans le cas d'une classe sealed, rendez le constructeur privé ; sinon, attribuez-lui l'état protégé.</span><span class="sxs-lookup"><span data-stu-id="02884-154">For a sealed class, make the constructor private; otherwise, make it protected.</span></span>|
|[<span data-ttu-id="02884-155">CA2231 : Surchargez l’opérateur égal (equals) en remplaçant ValueType.Equals</span><span class="sxs-lookup"><span data-stu-id="02884-155">CA2231: Overload operator equals on overriding ValueType.Equals</span></span>](ca2231.md)|<span data-ttu-id="02884-156">Un type valeur se substitue à `Object.Equals` , mais n’implémente pas l’opérateur d’égalité.</span><span class="sxs-lookup"><span data-stu-id="02884-156">A value type overrides `Object.Equals` but does not implement the equality operator.</span></span>|
|[<span data-ttu-id="02884-157">CA2234 : Passez des objets System.Uri à la place de chaînes</span><span class="sxs-lookup"><span data-stu-id="02884-157">CA2234: Pass System.Uri objects instead of strings</span></span>](ca2234.md)|<span data-ttu-id="02884-158">Un appel est passé à une méthode qui a un paramètre de chaîne dont le nom contient « uri », « URI », « urn », « URN », « url » ou « URL ».</span><span class="sxs-lookup"><span data-stu-id="02884-158">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL".</span></span>  <span data-ttu-id="02884-159">Le type déclarant de la méthode contient une surcharge de méthode correspondante qui a un <xref:System.Uri?displayProperty=fullName> paramètre.</span><span class="sxs-lookup"><span data-stu-id="02884-159">The declaring type of the method contains a corresponding method overload that has a <xref:System.Uri?displayProperty=fullName> parameter.</span></span>|
|[<span data-ttu-id="02884-160">CA2235 : Marquez tous les champs non sérialisés</span><span class="sxs-lookup"><span data-stu-id="02884-160">CA2235: Mark all non-serializable fields</span></span>](ca2235.md)|<span data-ttu-id="02884-161">Un champ d'instance d'un type non sérialisable est déclaré dans un type sérialisable.</span><span class="sxs-lookup"><span data-stu-id="02884-161">An instance field of a type that is not serializable is declared in a type that is serializable.</span></span>|
|[<span data-ttu-id="02884-162">CA2237 : Marquer les types ISerializable avec SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="02884-162">CA2237: Mark ISerializable types with SerializableAttribute</span></span>](ca2237.md)|<span data-ttu-id="02884-163">Pour être reconnus par le common language runtime comme sérialisables, les types doivent être marqués avec l’attribut SerializableAttribute même si le type utilise une routine de sérialisation personnalisée par le biais de l’implémentation de l' `ISerializable` interface.</span><span class="sxs-lookup"><span data-stu-id="02884-163">To be recognized by the common language runtime as serializable, types must be marked with the SerializableAttribute attribute even if the type uses a custom serialization routine through implementation of the `ISerializable` interface.</span></span>|
|[<span data-ttu-id="02884-164">CA2241 : Indiquer le nombre correct d'arguments dans les méthodes de mise en forme</span><span class="sxs-lookup"><span data-stu-id="02884-164">CA2241: Provide correct arguments to formatting methods</span></span>](ca2241.md)|<span data-ttu-id="02884-165">L’argument de format passé à <xref:System.String.Format%2A?displayProperty=nameWithType> ne contient pas d’élément de mise en forme qui correspond à chaque argument d’objet, ou vice versa.</span><span class="sxs-lookup"><span data-stu-id="02884-165">The format argument passed to <xref:System.String.Format%2A?displayProperty=nameWithType> does not contain a format item that corresponds to each object argument, or vice versa.</span></span>|
|[<span data-ttu-id="02884-166">CA2242 : Effectuez correctement des tests NaN</span><span class="sxs-lookup"><span data-stu-id="02884-166">CA2242: Test for NaN correctly</span></span>](ca2242.md)|<span data-ttu-id="02884-167">Cette expression teste une valeur par rapport à `Single.Nan` ou `Double.Nan` .</span><span class="sxs-lookup"><span data-stu-id="02884-167">This expression tests a value against `Single.Nan` or `Double.Nan`.</span></span> <span data-ttu-id="02884-168">Utilisez `Single.IsNan(Single)` ou `Double.IsNan(Double)` pour tester la valeur.</span><span class="sxs-lookup"><span data-stu-id="02884-168">Use `Single.IsNan(Single)` or `Double.IsNan(Double)` to test the value.</span></span>|
|[<span data-ttu-id="02884-169">CA2243 : Les littéraux de chaîne d'attribut doivent être analysés correctement</span><span class="sxs-lookup"><span data-stu-id="02884-169">CA2243: Attribute string literals should parse correctly</span></span>](ca2243.md)|<span data-ttu-id="02884-170">Le paramètre de littéral de chaîne d’un attribut n’est pas analysé correctement pour une URL, un GUID ou une version.</span><span class="sxs-lookup"><span data-stu-id="02884-170">An attribute's string literal parameter does not parse correctly for a URL, a GUID, or a version.</span></span>|
|[<span data-ttu-id="02884-171">CA2244 : Ne pas dupliquer les initialisations d’éléments indexés</span><span class="sxs-lookup"><span data-stu-id="02884-171">CA2244: Do not duplicate indexed element initializations</span></span>](ca2244.md)|<span data-ttu-id="02884-172">Un initialiseur d’objet a plus d’un initialiseur d’élément indexé avec le même index constant.</span><span class="sxs-lookup"><span data-stu-id="02884-172">An object initializer has more than one indexed element initializer with the same constant index.</span></span> <span data-ttu-id="02884-173">Tout sauf le dernier initialiseur est redondant.</span><span class="sxs-lookup"><span data-stu-id="02884-173">All but the last initializer are redundant.</span></span>|
|[<span data-ttu-id="02884-174">CA2245 : Ne pas attribuer une propriété à elle-même</span><span class="sxs-lookup"><span data-stu-id="02884-174">CA2245: Do not assign a property to itself</span></span>](ca2245.md)|<span data-ttu-id="02884-175">Une propriété a été accidentellement assignée à elle-même.</span><span class="sxs-lookup"><span data-stu-id="02884-175">A property was accidentally assigned to itself.</span></span>|
|[<span data-ttu-id="02884-176">CA2246 : Ne pas attribuer un symbole et son membre dans la même instruction</span><span class="sxs-lookup"><span data-stu-id="02884-176">CA2246: Do not assign a symbol and its member in the same statement</span></span>](ca2246.md)|<span data-ttu-id="02884-177">L’assignation d’un symbole et de son membre, autrement dit, un champ ou une propriété, dans la même instruction n’est pas recommandée.</span><span class="sxs-lookup"><span data-stu-id="02884-177">Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended.</span></span> <span data-ttu-id="02884-178">Il n’est pas évident de préciser si l’accès au membre était destiné à utiliser l’ancienne valeur du symbole avant l’assignation ou la nouvelle valeur de l’assignation dans cette instruction.</span><span class="sxs-lookup"><span data-stu-id="02884-178">It is not clear if the member access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.</span></span>|
|[<span data-ttu-id="02884-179">CA2247 : L’argument passé au constructeur TaskCompletionSource doit être l’enum TaskCreationOptions au lieu de l’enum TaskContinuationOptions</span><span class="sxs-lookup"><span data-stu-id="02884-179">CA2247: Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</span></span>](ca2246.md)|<span data-ttu-id="02884-180">TaskCompletionSource possède des constructeurs qui prennent des TaskCreationOptions qui contrôlent la tâche sous-jacente, et les constructeurs qui prennent l’état d’objet stocké dans la tâche.</span><span class="sxs-lookup"><span data-stu-id="02884-180">TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.</span></span>  <span data-ttu-id="02884-181">Le passage accidentel d’un TaskContinuationOptions au lieu d’un TaskCreationOptions entraînera l’appel du traitement des options en tant qu’État.</span><span class="sxs-lookup"><span data-stu-id="02884-181">Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</span></span>|
|[<span data-ttu-id="02884-182">CA2248 : fournissez un argument « enum » correct à « Enum. HasFlag »</span><span class="sxs-lookup"><span data-stu-id="02884-182">CA2248: Provide correct 'enum' argument to 'Enum.HasFlag'</span></span>](ca2248.md)|<span data-ttu-id="02884-183">Le type enum passé comme argument à l' `HasFlag` appel de méthode est différent du type enum appelant.</span><span class="sxs-lookup"><span data-stu-id="02884-183">The enum type passed as an argument to the `HasFlag` method call is different from the calling enum type.</span></span>|
|[<span data-ttu-id="02884-184">CA2249 : Utiliser de préférence String.Contains à la place de String.IndexOf</span><span class="sxs-lookup"><span data-stu-id="02884-184">CA2249: Consider using String.Contains instead of String.IndexOf</span></span>](ca2249.md)|<span data-ttu-id="02884-185">Les appels à `string.IndexOf` où le résultat est utilisé pour vérifier la présence ou l’absence d’une sous-chaîne peuvent être remplacés par `string.Contains` .</span><span class="sxs-lookup"><span data-stu-id="02884-185">Calls to `string.IndexOf` where the result is used to check for the presence or absence of a substring can be replaced by `string.Contains`.</span></span>|
