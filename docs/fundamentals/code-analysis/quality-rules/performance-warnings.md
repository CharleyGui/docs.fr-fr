---
title: Règles de performances (analyse du code)
description: En savoir plus sur les règles de performance de l’analyse du code.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/25/2020
ms.locfileid: "96586954"
---
# <a name="performance-rules"></a><span data-ttu-id="5c8df-103">Règles de performances</span><span class="sxs-lookup"><span data-stu-id="5c8df-103">Performance rules</span></span>

<span data-ttu-id="5c8df-104">Les règles de performances prennent en charge les bibliothèques et les applications hautes performances.</span><span class="sxs-lookup"><span data-stu-id="5c8df-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="5c8df-105">Dans cette section</span><span class="sxs-lookup"><span data-stu-id="5c8df-105">In this section</span></span>

| <span data-ttu-id="5c8df-106">Règle</span><span class="sxs-lookup"><span data-stu-id="5c8df-106">Rule</span></span> | <span data-ttu-id="5c8df-107">Description</span><span class="sxs-lookup"><span data-stu-id="5c8df-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="5c8df-108">CA1802 : Utilisez des littéraux quand cela est approprié</span><span class="sxs-lookup"><span data-stu-id="5c8df-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="5c8df-109">Un champ est déclaré statique et en lecture seule (Shared et ReadOnly en Visual Basic), et est initialisé avec une valeur qui peut être calculée au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="5c8df-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="5c8df-110">Étant donné que la valeur assignée au champ ciblé peut être calculée au moment de la compilation, remplacez la déclaration par un champ const (const dans Visual Basic) afin que la valeur soit calculée au moment de la compilation plutôt qu’au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c8df-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="5c8df-111">CA1805 : Ne pas initialiser inutilement</span><span class="sxs-lookup"><span data-stu-id="5c8df-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="5c8df-112">Le Runtime .NET initialise tous les champs de type référence à leurs valeurs par défaut avant d’exécuter le constructeur.</span><span class="sxs-lookup"><span data-stu-id="5c8df-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="5c8df-113">Dans la plupart des cas, l’initialisation explicite d’un champ à sa valeur par défaut est redondante, ce qui augmente les coûts de maintenance et peut dégrader les performances (par exemple, avec une taille d’assembly accrue).</span><span class="sxs-lookup"><span data-stu-id="5c8df-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="5c8df-114">CA1806 : N'ignorez pas les résultats des méthodes</span><span class="sxs-lookup"><span data-stu-id="5c8df-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="5c8df-115">Un nouvel objet est créé mais jamais utilisé, ou une méthode qui crée et retourne une nouvelle chaîne est appelée et la nouvelle chaîne n’est jamais utilisée, ou une méthode COM (Component Object Model) ou P/Invoke retourne un HRESULT ou un code d’erreur qui n’est jamais utilisé.</span><span class="sxs-lookup"><span data-stu-id="5c8df-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="5c8df-116">CA1810 : Initialisez les champs statiques de type référence en ligne</span><span class="sxs-lookup"><span data-stu-id="5c8df-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="5c8df-117">Lorsqu'un type déclare un constructeur statique explicite, le compilateur juste-à-temps (JIT, Just-In-Time) ajoute une vérification à chacun des méthodes statiques et constructeurs d'instances du type afin de garantir que le constructeur statique a été appelé précédemment.</span><span class="sxs-lookup"><span data-stu-id="5c8df-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="5c8df-118">Les vérifications des constructeurs statiques peuvent diminuer les performances.</span><span class="sxs-lookup"><span data-stu-id="5c8df-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="5c8df-119">CA1812 : Évitez les classes internes non instanciées</span><span class="sxs-lookup"><span data-stu-id="5c8df-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="5c8df-120">Une instance d'un type de niveau assembly n'est pas créée par le code au sein de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="5c8df-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="5c8df-121">CA1813 : Évitez les attributs unsealed</span><span class="sxs-lookup"><span data-stu-id="5c8df-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="5c8df-122">.NET fournit des méthodes pour récupérer des attributs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="5c8df-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="5c8df-123">Par défaut, ces méthodes recherchent la hiérarchie d'héritage des attributs.</span><span class="sxs-lookup"><span data-stu-id="5c8df-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="5c8df-124">Le fait de sceller l'attribut élimine la recherche dans la hiérarchie d'héritage et peut améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="5c8df-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="5c8df-125">CA1814 : Utilisez des tableaux en escalier à la place de tableaux multidimensionnels</span><span class="sxs-lookup"><span data-stu-id="5c8df-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="5c8df-126">Un tableau en escalier est un tableau dont les éléments sont des tableaux.</span><span class="sxs-lookup"><span data-stu-id="5c8df-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="5c8df-127">Les tableaux qui composent les éléments peuvent être de différentes tailles, ce qui peut entraîner un gaspillage de l’espace pour certains jeux de données.</span><span class="sxs-lookup"><span data-stu-id="5c8df-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="5c8df-128">CA1815 : Remplacez Equals et l'opérateur égal à dans les types valeur</span><span class="sxs-lookup"><span data-stu-id="5c8df-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="5c8df-129">Pour les types valeur, l'implémentation héritée de Equals utilise la bibliothèque Reflection et compare le contenu de tous les champs.</span><span class="sxs-lookup"><span data-stu-id="5c8df-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="5c8df-130">Le processus de réflexion sollicite fortement les ressources informatiques et la comparaison de chaque champ à la recherche d'une égalité peut s'avérer inutile.</span><span class="sxs-lookup"><span data-stu-id="5c8df-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="5c8df-131">Si des utilisateurs sont susceptibles de comparer ou de trier des instances, ou de les utiliser en tant que clés de table de hachage, votre type valeur doit implémenter Equals.</span><span class="sxs-lookup"><span data-stu-id="5c8df-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="5c8df-132">CA1819 : Les propriétés ne doivent pas retourner des tableaux</span><span class="sxs-lookup"><span data-stu-id="5c8df-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="5c8df-133">Les tableaux retournés par les propriétés ne sont pas protégés en écriture, même si la propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="5c8df-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="5c8df-134">Pour protéger le tableau de toute falsification, la propriété doit retourner une copie du tableau.</span><span class="sxs-lookup"><span data-stu-id="5c8df-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="5c8df-135">En général, les utilisateurs ne comprennent l'incidence négative en matière de performances de l'appel à une telle propriété.</span><span class="sxs-lookup"><span data-stu-id="5c8df-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="5c8df-136">CA1820 : Vérifiez la présence de chaînes vides par la longueur de chaîne</span><span class="sxs-lookup"><span data-stu-id="5c8df-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="5c8df-137">La comparaison de chaînes à l'aide de la propriété String.Length ou de la méthode String.IsNullOrEmpty est nettement plus rapide que l'utilisation d'Equals.</span><span class="sxs-lookup"><span data-stu-id="5c8df-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="5c8df-138">CA1821 : Supprimez les finaliseurs vides</span><span class="sxs-lookup"><span data-stu-id="5c8df-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="5c8df-139">Évitez autant que possible d'utiliser des finaliseurs en raison de la surcharge supplémentaire des performances impliquée dans le suivi de la durée de vie de l'objet.</span><span class="sxs-lookup"><span data-stu-id="5c8df-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="5c8df-140">Un finaliseur vide entraîne une surcharge supplémentaire sans aucun avantage.</span><span class="sxs-lookup"><span data-stu-id="5c8df-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="5c8df-141">CA1822 : Marquez les membres comme static</span><span class="sxs-lookup"><span data-stu-id="5c8df-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="5c8df-142">Les membres qui n’accèdent pas aux données d’instance ou appelent des méthodes d’instance peuvent être marqués comme static (Shared in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="5c8df-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="5c8df-143">Une fois que les méthodes ont été marquées comme static, le compilateur émet des sites d'appel non virtuels vers ces membres.</span><span class="sxs-lookup"><span data-stu-id="5c8df-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="5c8df-144">Cette opération se traduit par un gain de performances mesurable pour le code dépendant des performances.</span><span class="sxs-lookup"><span data-stu-id="5c8df-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="5c8df-145">CA1823 : Évitez les champs privés inutilisés</span><span class="sxs-lookup"><span data-stu-id="5c8df-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="5c8df-146">Des champs privés qui ne sont pas accessibles dans l'assembly ont été détectés.</span><span class="sxs-lookup"><span data-stu-id="5c8df-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="5c8df-147">CA1824 : Marquer les assemblys avec NeutralResourcesLanguageAttribute</span><span class="sxs-lookup"><span data-stu-id="5c8df-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="5c8df-148">L’attribut NeutralResourcesLanguage indique la Gestionnaire des ressources de la langue utilisée pour afficher les ressources d’une culture neutre pour un assembly.</span><span class="sxs-lookup"><span data-stu-id="5c8df-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="5c8df-149">Cela permet d'améliorer les performances de recherche de la première ressource chargée et de réduire votre jeu de travail.</span><span class="sxs-lookup"><span data-stu-id="5c8df-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="5c8df-150">CA1825 : Éviter les allocations de tableau de longueur nulle</span><span class="sxs-lookup"><span data-stu-id="5c8df-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="5c8df-151">L’initialisation d’un tableau de longueur zéro provoque une allocation de mémoire inutile.</span><span class="sxs-lookup"><span data-stu-id="5c8df-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="5c8df-152">Utilisez plutôt l’instance de tableau vide allouée statiquement en appelant <xref:System.Array.Empty%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5c8df-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5c8df-153">L’allocation de mémoire est partagée entre tous les appels de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="5c8df-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="5c8df-154">CA1826 : Utiliser une propriété au lieu de la méthode Linq Enumerable</span><span class="sxs-lookup"><span data-stu-id="5c8df-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="5c8df-155"><xref:System.Linq.Enumerable> La méthode LINQ a été utilisée sur un type qui prend en charge une propriété équivalente et plus efficace.</span><span class="sxs-lookup"><span data-stu-id="5c8df-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="5c8df-156">CA1827 : N’utilisez pas Count/LongCount quand Any peut être utilisé</span><span class="sxs-lookup"><span data-stu-id="5c8df-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="5c8df-157"><xref:System.Linq.Enumerable.Count%2A> ou la <xref:System.Linq.Enumerable.LongCount%2A> méthode a été utilisée là où la <xref:System.Linq.Enumerable.Any%2A> méthode serait plus efficace.</span><span class="sxs-lookup"><span data-stu-id="5c8df-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="5c8df-158">CA1828 : N’utilisez pas CountAsync/LongCountAsync quand AnyAsync peut être utilisé</span><span class="sxs-lookup"><span data-stu-id="5c8df-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="5c8df-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> ou la <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> méthode a été utilisée là où la <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> méthode serait plus efficace.</span><span class="sxs-lookup"><span data-stu-id="5c8df-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="5c8df-160">CA1829 : Utilisez la propriété Length/Count au lieu de la méthode Enumerable.Count</span><span class="sxs-lookup"><span data-stu-id="5c8df-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="5c8df-161"><xref:System.Linq.Enumerable.Count%2A> La méthode LINQ a été utilisée sur un type qui prend en charge une propriété équivalente, plus efficace `Length` ou `Count` .</span><span class="sxs-lookup"><span data-stu-id="5c8df-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="5c8df-162">CA1830 : Préférer les surcharges de méthode Append et Insert fortement typées sur StringBuilder</span><span class="sxs-lookup"><span data-stu-id="5c8df-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="5c8df-163"><xref:System.Text.StringBuilder.Append%2A> et <xref:System.Text.StringBuilder.Insert%2A> fournissent des surcharges pour plusieurs types au-delà de System. String.</span><span class="sxs-lookup"><span data-stu-id="5c8df-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="5c8df-164">Dans la mesure du possible, préférez les surcharges fortement typées à l’aide de ToString () et de la surcharge basée sur une chaîne.</span><span class="sxs-lookup"><span data-stu-id="5c8df-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="5c8df-165">CA1831 : Utiliser AsSpan à la place d’indexeurs basés sur Range pour une chaîne si approprié</span><span class="sxs-lookup"><span data-stu-id="5c8df-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="5c8df-166">Lors de l’utilisation d’un indexeur de plages sur une chaîne et de l’assignation implicite de la valeur à un &lt; type char ReadOnlySpan &gt; , la méthode <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> est utilisée à la place de <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , ce qui génère une copie de la partie demandée de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="5c8df-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="5c8df-167">CA1832 : Utiliser AsSpan ou AsMemory à la place d’indexeurs basés sur Range pour obtenir la partie ReadOnlySpan ou ReadOnlyMemory d’un tableau</span><span class="sxs-lookup"><span data-stu-id="5c8df-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="5c8df-168">Lors de l’utilisation d’un indexeur de plages sur un tableau et de l’assignation implicite de la valeur à un <xref:System.ReadOnlySpan%601> <xref:System.ReadOnlyMemory%601> type ou, la méthode <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> est utilisée à la place de <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , ce qui produit une copie de la partie demandée du tableau.</span><span class="sxs-lookup"><span data-stu-id="5c8df-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="5c8df-169">CA1833 : Utiliser AsSpan ou AsMemory à la place d’indexeurs basés sur Range pour obtenir la partie Span ou Memory d’un tableau</span><span class="sxs-lookup"><span data-stu-id="5c8df-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="5c8df-170">Lors de l’utilisation d’un indexeur de plages sur un tableau et de l’assignation implicite de la valeur à un <xref:System.Span%601> <xref:System.Memory%601> type ou, la méthode <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> est utilisée à la place de <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , ce qui produit une copie de la partie demandée du tableau.</span><span class="sxs-lookup"><span data-stu-id="5c8df-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="5c8df-171">CA1834 : Utiliser StringBuilder.Append (char) pour les chaînes de caractères uniques</span><span class="sxs-lookup"><span data-stu-id="5c8df-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="5c8df-172"><xref:System.Text.StringBuilder> a une `Append` surcharge qui prend un `char` comme argument.</span><span class="sxs-lookup"><span data-stu-id="5c8df-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="5c8df-173">Préférez l’appel `char` de la surcharge pour améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="5c8df-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="5c8df-174">CA1835 : préférer les surcharges « Memory' » pour « ReadAsync » et « WriteAsync »</span><span class="sxs-lookup"><span data-stu-id="5c8df-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="5c8df-175">'Stream’a une surcharge’ReadAsync’qui accepte’Memory &lt; Byte &gt; 'comme premier argument et une surcharge’WriteAsync’qui prend un’ReadOnlyMemory &lt; Byte &gt; 'comme premier argument.</span><span class="sxs-lookup"><span data-stu-id="5c8df-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="5c8df-176">Préférez appeler les surcharges basées sur la mémoire, qui sont plus efficaces.</span><span class="sxs-lookup"><span data-stu-id="5c8df-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="5c8df-177">CA1836 : préférer `IsEmpty` le `Count` cas échéant</span><span class="sxs-lookup"><span data-stu-id="5c8df-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="5c8df-178">Préférer `IsEmpty` la propriété qui est plus efficace `Count` que `Length` , <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> ou <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> pour déterminer si l’objet contient ou non des éléments.</span><span class="sxs-lookup"><span data-stu-id="5c8df-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="5c8df-179">CA1837 : utilisez à la `Environment.ProcessId` place de `Process.GetCurrentProcess().Id`</span><span class="sxs-lookup"><span data-stu-id="5c8df-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="5c8df-180">`Environment.ProcessId` est plus simple et plus rapide que `Process.GetCurrentProcess().Id` .</span><span class="sxs-lookup"><span data-stu-id="5c8df-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="5c8df-181">CA1838 : éviter `StringBuilder` les paramètres pour les P/Invoke</span><span class="sxs-lookup"><span data-stu-id="5c8df-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="5c8df-182">Le marshaling de `StringBuilder` crée toujours une copie de mémoire tampon native, ce qui entraîne plusieurs allocations pour une opération de marshaling.</span><span class="sxs-lookup"><span data-stu-id="5c8df-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
