---
title: Règles de conception (analyse du code)
description: En savoir plus sur les règles de conception de l’analyse du code.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 7b49403b1aa3d48008e6f7448ab0ed5a84468373
ms.sourcegitcommit: 45c7148f2483db2501c1aa696ab6ed2ed8cb71b2
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/08/2020
ms.locfileid: "96851527"
---
# <a name="design-rules"></a><span data-ttu-id="5c200-103">Règles de conception</span><span class="sxs-lookup"><span data-stu-id="5c200-103">Design rules</span></span>

<span data-ttu-id="5c200-104">Les règles de conception prennent en charge l’adhésion aux règles de [conception de .NET Framework](../../../standard/design-guidelines/index.md).</span><span class="sxs-lookup"><span data-stu-id="5c200-104">Design rules support adherence to the [.NET Framework Design Guidelines](../../../standard/design-guidelines/index.md).</span></span>

## <a name="in-this-section"></a><span data-ttu-id="5c200-105">Dans cette section</span><span class="sxs-lookup"><span data-stu-id="5c200-105">In this section</span></span>

| <span data-ttu-id="5c200-106">Règle</span><span class="sxs-lookup"><span data-stu-id="5c200-106">Rule</span></span> | <span data-ttu-id="5c200-107">Description</span><span class="sxs-lookup"><span data-stu-id="5c200-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="5c200-108">CA1000 : Ne pas déclarer de membres statiques sur les types génériques</span><span class="sxs-lookup"><span data-stu-id="5c200-108">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="5c200-109">Lorsqu'un membre statique d'un type générique est appelé, l'argument de type doit être spécifié pour le type.</span><span class="sxs-lookup"><span data-stu-id="5c200-109">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="5c200-110">Lorsqu'un membre d'instance générique qui ne prend pas en charge l'inférence est appelé, l'argument de type doit être spécifié pour le membre.</span><span class="sxs-lookup"><span data-stu-id="5c200-110">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="5c200-111">Dans ces deux cas, la syntaxe permettant de spécifier l'argument de type est différente et peut être facilement confondue.</span><span class="sxs-lookup"><span data-stu-id="5c200-111">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
| [<span data-ttu-id="5c200-112">CA1001 : Les types qui possèdent des champs supprimables doivent être supprimables</span><span class="sxs-lookup"><span data-stu-id="5c200-112">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="5c200-113">Une classe déclare et implémente un champ d’instance qui est un type System. IDisposable et la classe n’implémente pas IDisposable.</span><span class="sxs-lookup"><span data-stu-id="5c200-113">A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable.</span></span> <span data-ttu-id="5c200-114">Une classe qui déclare un champ IDisposable possède indirectement une ressource non managée et doit implémenter l'interface IDisposable.</span><span class="sxs-lookup"><span data-stu-id="5c200-114">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
| [<span data-ttu-id="5c200-115">CA1002 : Ne pas exposer de listes génériques</span><span class="sxs-lookup"><span data-stu-id="5c200-115">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="5c200-116">System. Collections. Generic. List< (of \<(T> ) >) est une collection générique conçue pour les performances, et non pour l’héritage.</span><span class="sxs-lookup"><span data-stu-id="5c200-116">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="5c200-117">Par conséquent, la liste ne contient aucun membre virtuel.</span><span class="sxs-lookup"><span data-stu-id="5c200-117">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="5c200-118">Les collections génériques qui sont conçues pour l’héritage doivent être exposées à la place.</span><span class="sxs-lookup"><span data-stu-id="5c200-118">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
| [<span data-ttu-id="5c200-119">CA1003 : Utiliser les instances du gestionnaire d'événements génériques</span><span class="sxs-lookup"><span data-stu-id="5c200-119">CA1003: Use generic event handler instances</span></span>](ca1003.md) | <span data-ttu-id="5c200-120">Un type contient un délégué qui retourne void, dont la signature contient deux paramètres (le premier objet et le deuxième un type qui peut être assigné à EventArgs), et l’assembly conteneur cible .NET Framework 2,0.</span><span class="sxs-lookup"><span data-stu-id="5c200-120">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.</span></span> |
| [<span data-ttu-id="5c200-121">CA1005 : Éviter les paramètres excessifs sur les types génériques</span><span class="sxs-lookup"><span data-stu-id="5c200-121">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="5c200-122">Plus un type générique contient de paramètres de type, plus il est difficile de déterminer et de mémoriser la représentation de chaque paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="5c200-122">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="5c200-123">Elle est généralement évidente avec un paramètre de type, comme dans la liste \<T> , et dans certains cas avec deux paramètres de type, comme dans Dictionary \<TKey, TValue> .</span><span class="sxs-lookup"><span data-stu-id="5c200-123">It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="5c200-124">Cependant, s’il existe plus de deux paramètres de type, la difficulté devient trop grande pour la plupart des utilisateurs.</span><span class="sxs-lookup"><span data-stu-id="5c200-124">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
| [<span data-ttu-id="5c200-125">CA1008 : Les enums doivent avoir la valeur zéro</span><span class="sxs-lookup"><span data-stu-id="5c200-125">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="5c200-126">La valeur par défaut d'une énumération non initialisée, comme d'autres types valeur, est zéro.</span><span class="sxs-lookup"><span data-stu-id="5c200-126">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="5c200-127">Une énumération attribuée sans indicateur doit définir un membre à l’aide de la valeur de zéro afin que la valeur par défaut soit une valeur valide de l’énumération.</span><span class="sxs-lookup"><span data-stu-id="5c200-127">A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="5c200-128">Si une énumération à laquelle l'attribut FlagsAttribute est appliqué définit un membre de valeur zéro, son nom doit être "None" pour indiquer qu'aucune valeur n'a été définie dans l'énumération.</span><span class="sxs-lookup"><span data-stu-id="5c200-128">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
| [<span data-ttu-id="5c200-129">CA1010 : Les collections doivent implémenter une interface générique</span><span class="sxs-lookup"><span data-stu-id="5c200-129">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="5c200-130">Pour étendre la facilité d’utilisation d’une collection, implémentez l’une des interfaces de collection génériques.</span><span class="sxs-lookup"><span data-stu-id="5c200-130">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="5c200-131">La collection peut être ensuite utilisée pour remplir des types de collection génériques.</span><span class="sxs-lookup"><span data-stu-id="5c200-131">Then the collection can be used to populate generic collection types.</span></span> |
| [<span data-ttu-id="5c200-132">CA1012 : Les types abstract ne doivent pas avoir de constructeurs</span><span class="sxs-lookup"><span data-stu-id="5c200-132">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="5c200-133">Les constructeurs des types abstraits peuvent être appelés uniquement par des types dérivés.</span><span class="sxs-lookup"><span data-stu-id="5c200-133">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="5c200-134">Étant donné que les constructeurs publics créent des instances d'un type et que vous ne pouvez pas créer d'instance d'un type abstrait, un type abstrait doté d'un constructeur public est de conception incorrecte.</span><span class="sxs-lookup"><span data-stu-id="5c200-134">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
| [<span data-ttu-id="5c200-135">CA1014 : Marquer les assemblys avec CLSCompliantAttribute</span><span class="sxs-lookup"><span data-stu-id="5c200-135">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="5c200-136">La spécification de langage commun CLS (Common Language Specification) définit des restrictions de dénomination, des types de données, et des règles auxquelles les assemblys doivent se conformer s'ils doivent être utilisés à l'échelle de différents langages de programmation.</span><span class="sxs-lookup"><span data-stu-id="5c200-136">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="5c200-137">Une bonne conception impose que tous les assemblys indiquent explicitement la conformité CLS à l’aide de CLSCompliantAttribute.</span><span class="sxs-lookup"><span data-stu-id="5c200-137">Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.</span></span> <span data-ttu-id="5c200-138">Si cet attribut n'est pas présent sur un assembly, l'assembly n'est pas conforme.</span><span class="sxs-lookup"><span data-stu-id="5c200-138">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
| [<span data-ttu-id="5c200-139">CA1016 : Marquer les assemblys avec AssemblyVersionAttribute</span><span class="sxs-lookup"><span data-stu-id="5c200-139">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="5c200-140">.NET utilise le numéro de version pour identifier de manière unique un assembly et pour établir une liaison aux types dans des assemblys avec nom fort.</span><span class="sxs-lookup"><span data-stu-id="5c200-140">.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="5c200-141">Le numéro de version est utilisé conjointement avec la version et la stratégie d'éditeur.</span><span class="sxs-lookup"><span data-stu-id="5c200-141">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="5c200-142">Par défaut, les applications s'exécutent uniquement avec la version d'assembly avec laquelle elles ont été construites.</span><span class="sxs-lookup"><span data-stu-id="5c200-142">By default, applications run only with the assembly version with which they were built.</span></span> |
| [<span data-ttu-id="5c200-143">CA1017 : Marquer les assemblys avec ComVisibleAttribute</span><span class="sxs-lookup"><span data-stu-id="5c200-143">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) | <span data-ttu-id="5c200-144">ComVisibleAttribute détermine comment les clients COM accèdent à du code managé.</span><span class="sxs-lookup"><span data-stu-id="5c200-144">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="5c200-145">Un bon design stipule que les assemblys indiquent explicitement la visibilité COM.</span><span class="sxs-lookup"><span data-stu-id="5c200-145">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="5c200-146">La visibilité COM peut être définie pour l'assembly en entier, puis être substituée pour des types et des membres de type individuels.</span><span class="sxs-lookup"><span data-stu-id="5c200-146">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="5c200-147">Si cet attribut n'est pas présent, les clients COM peuvent voir le contenu de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="5c200-147">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
| [<span data-ttu-id="5c200-148">CA1018 : Marquer les attributs avec AttributeUsageAttribute</span><span class="sxs-lookup"><span data-stu-id="5c200-148">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="5c200-149">Lorsque vous définissez un attribut personnalisé, marquez-le à l'aide d'AttributeUsageAttribute pour indiquer où l'attribut personnalisé peut être appliqué dans le code source.</span><span class="sxs-lookup"><span data-stu-id="5c200-149">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="5c200-150">La signification et l'utilisation prévue d'un attribut déterminent ses emplacements valides au sein d'un code.</span><span class="sxs-lookup"><span data-stu-id="5c200-150">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
| [<span data-ttu-id="5c200-151">CA1019 : Définir des accesseurs pour les arguments d'attribut</span><span class="sxs-lookup"><span data-stu-id="5c200-151">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="5c200-152">Les attributs peuvent définir des arguments obligatoires qui doivent être spécifiés lorsque vous appliquez l’attribut à une cible.</span><span class="sxs-lookup"><span data-stu-id="5c200-152">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="5c200-153">Ceux-ci sont également appelés arguments positionnels parce qu’ils sont fournis aux constructeurs d’attributs en tant que paramètres positionnels.</span><span class="sxs-lookup"><span data-stu-id="5c200-153">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="5c200-154">Pour chaque argument obligatoire, l'attribut doit également fournir une propriété en lecture seule correspondante afin que la valeur de l'argument puisse être récupérée au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="5c200-154">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="5c200-155">Les attributs peuvent également définir des arguments facultatifs, qui sont également appelés arguments nommés.</span><span class="sxs-lookup"><span data-stu-id="5c200-155">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="5c200-156">Ces arguments sont fournis aux constructeurs d’attributs par noms et doivent disposer d’une propriété en lecture/écriture correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c200-156">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
| [<span data-ttu-id="5c200-157">CA1021 : Éviter les paramètres out</span><span class="sxs-lookup"><span data-stu-id="5c200-157">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="5c200-158">Passer des types par référence (en utilisant out ou ref) nécessite une certaine expérience des pointeurs, de comprendre la différence entre les types valeur et les types référence, ainsi que la gestion de méthodes impliquant plusieurs valeurs de retour.</span><span class="sxs-lookup"><span data-stu-id="5c200-158">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="5c200-159">Par ailleurs, la différence entre les paramètres out et ref est généralement peu comprise.</span><span class="sxs-lookup"><span data-stu-id="5c200-159">Also, the difference between out and ref parameters is not widely understood.</span></span> |
| [<span data-ttu-id="5c200-160">CA1024 : Utiliser les propriétés lorsque cela est approprié</span><span class="sxs-lookup"><span data-stu-id="5c200-160">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="5c200-161">Le nom d'une méthode publique ou protégée commence par « Get », n'accepte aucun paramètre et retourne une valeur qui n'est pas un tableau.</span><span class="sxs-lookup"><span data-stu-id="5c200-161">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="5c200-162">La méthode est susceptible de devenir une propriété.</span><span class="sxs-lookup"><span data-stu-id="5c200-162">The method might be a good candidate to become a property.</span></span> |
| [<span data-ttu-id="5c200-163">CA1027 : Marquer les enums avec FlagsAttribute</span><span class="sxs-lookup"><span data-stu-id="5c200-163">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="5c200-164">Une énumération est un type valeur qui définit un jeu de constantes nommées associées.</span><span class="sxs-lookup"><span data-stu-id="5c200-164">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="5c200-165">Appliquez FlagsAttribute à une énumération lorsque ses constantes nommées peuvent être combinées de manière pertinente.</span><span class="sxs-lookup"><span data-stu-id="5c200-165">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
| [<span data-ttu-id="5c200-166">CA1028 : Enum Storage doit être Int32</span><span class="sxs-lookup"><span data-stu-id="5c200-166">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="5c200-167">Une énumération est un type valeur qui définit un jeu de constantes nommées associées.</span><span class="sxs-lookup"><span data-stu-id="5c200-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="5c200-168">Par défaut, le type de données System.Int32 est utilisé pour stocker la valeur de constante.</span><span class="sxs-lookup"><span data-stu-id="5c200-168">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="5c200-169">Même si vous pouvez modifier ce type sous-jacent, il n’est pas obligatoire ou recommandé pour la plupart des scénarios.</span><span class="sxs-lookup"><span data-stu-id="5c200-169">Even though you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
| [<span data-ttu-id="5c200-170">CA1030 : Utiliser des événements lorsque cela est approprié</span><span class="sxs-lookup"><span data-stu-id="5c200-170">CA1030: Use events where appropriate</span></span>](ca1030.md) | <span data-ttu-id="5c200-171">Cette règle détecte des méthodes qui présentent des noms qui ordinairement seraient utilisés pour des événements.</span><span class="sxs-lookup"><span data-stu-id="5c200-171">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="5c200-172">Si une méthode est appelée en réponse à une modification d'état clairement définie, la méthode doit être appelée par un gestionnaire d'événements.</span><span class="sxs-lookup"><span data-stu-id="5c200-172">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="5c200-173">Les objets qui appellent la méthode doivent déclencher des événements au lieu d'appeler directement la méthode.</span><span class="sxs-lookup"><span data-stu-id="5c200-173">Objects that call the method should raise events instead of calling the method directly.</span></span> |
| [<span data-ttu-id="5c200-174">CA1031 : Ne pas intercepter des types d'exception générale</span><span class="sxs-lookup"><span data-stu-id="5c200-174">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="5c200-175">Les exceptions générales ne doivent pas être interceptées.</span><span class="sxs-lookup"><span data-stu-id="5c200-175">General exceptions should not be caught.</span></span> <span data-ttu-id="5c200-176">Interceptez une exception plus spécifique ou levez à nouveau l’exception générale comme dernière instruction dans le bloc catch.</span><span class="sxs-lookup"><span data-stu-id="5c200-176">Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
| [<span data-ttu-id="5c200-177">CA1032 : Implémenter des constructeurs d'exception standard</span><span class="sxs-lookup"><span data-stu-id="5c200-177">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="5c200-178">Ne pas fournir le jeu complet de constructeurs peut rendre difficile une gestion des exceptions correcte.</span><span class="sxs-lookup"><span data-stu-id="5c200-178">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
| [<span data-ttu-id="5c200-179">CA1033 : Les méthodes d'interface doivent pouvoir être appelées par les types enfants</span><span class="sxs-lookup"><span data-stu-id="5c200-179">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="5c200-180">Un type unsealed visible de l'extérieur fournit une implémentation de méthode explicite d'une interface publique mais ne fournit aucune méthode de substitution visible de l'extérieur de même nom.</span><span class="sxs-lookup"><span data-stu-id="5c200-180">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
| [<span data-ttu-id="5c200-181">CA1034 : Les types imbriqués ne doivent pas être visibles</span><span class="sxs-lookup"><span data-stu-id="5c200-181">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="5c200-182">Un type imbriqué représente un type déclaré dans la portée d'un autre type.</span><span class="sxs-lookup"><span data-stu-id="5c200-182">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="5c200-183">Les types imbriqués sont utiles pour encapsuler les détails de l'implémentation privée du type conteneur.</span><span class="sxs-lookup"><span data-stu-id="5c200-183">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="5c200-184">Utilisés à cette fin, les types imbriqués ne doivent pas être visibles de l'extérieur.</span><span class="sxs-lookup"><span data-stu-id="5c200-184">Used for this purpose, nested types should not be externally visible.</span></span> |
| [<span data-ttu-id="5c200-185">CA1036 : Substituer les méthodes sur les types Comparable</span><span class="sxs-lookup"><span data-stu-id="5c200-185">CA1036: Override methods on comparable types</span></span>](ca1036.md) | <span data-ttu-id="5c200-186">Un type public ou protégé implémente l'interface System.IComparable.</span><span class="sxs-lookup"><span data-stu-id="5c200-186">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="5c200-187">Il ne substitue pas Object.Equals, ni ne surcharge l'opérateur égal à, différent de, inférieur à ou supérieur à propre au langage.</span><span class="sxs-lookup"><span data-stu-id="5c200-187">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
| [<span data-ttu-id="5c200-188">CA1040 : Éviter les interfaces vides</span><span class="sxs-lookup"><span data-stu-id="5c200-188">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="5c200-189">Les interfaces définissent des membres qui fournissent un comportement ou un contrat d'utilisation.</span><span class="sxs-lookup"><span data-stu-id="5c200-189">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="5c200-190">Les fonctionnalités décrites par l'interface peuvent être adoptées par tout type, indépendamment de l'endroit où le type figure dans la hiérarchie d'héritage.</span><span class="sxs-lookup"><span data-stu-id="5c200-190">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="5c200-191">Un type implémente une interface en fournissant des implémentations pour les membres de celle-ci.</span><span class="sxs-lookup"><span data-stu-id="5c200-191">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="5c200-192">Une interface vide ne définit aucun membre ; par conséquent, elle ne définit aucun contrat pouvant être implémenté.</span><span class="sxs-lookup"><span data-stu-id="5c200-192">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
| [<span data-ttu-id="5c200-193">CA1041 : Fournir un message ObsoleteAttribute</span><span class="sxs-lookup"><span data-stu-id="5c200-193">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="5c200-194">Un type ou un membre est marqué avec un attribut System.ObsoleteAttribute dont la propriété ObsoleteAttribute.Message n'est pas spécifiée.</span><span class="sxs-lookup"><span data-stu-id="5c200-194">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="5c200-195">Lorsqu’un type ou un membre qui est marqué à l’aide de ObsoleteAttribute est compilé, la propriété message de l’attribut s’affiche, qui donne à l’utilisateur des informations sur le type ou le membre obsolète.</span><span class="sxs-lookup"><span data-stu-id="5c200-195">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.</span></span> |
| [<span data-ttu-id="5c200-196">CA1043 : Utiliser un argument de chaîne ou intégral pour les indexeurs</span><span class="sxs-lookup"><span data-stu-id="5c200-196">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="5c200-197">Les indexeurs (c'est-à-dire les propriétés indexées) doivent utiliser des types intégral ou chaîne pour l'index.</span><span class="sxs-lookup"><span data-stu-id="5c200-197">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="5c200-198">Ces types sont généralement utilisés pour indexer des structures de données et augmentent la facilité d'utilisation de la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="5c200-198">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="5c200-199">L'utilisation du type Object doit se restreindre aux cas où le type intégral ou de chaîne spécifique ne peut pas être spécifié au moment du design.</span><span class="sxs-lookup"><span data-stu-id="5c200-199">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
| [<span data-ttu-id="5c200-200">CA1044 : Les propriétés ne doivent pas être en écriture seule</span><span class="sxs-lookup"><span data-stu-id="5c200-200">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="5c200-201">Bien qu'il soit acceptable et souvent nécessaire de disposer d'une propriété en lecture seule, les règles de conception interdisent l'utilisation de propriétés en écriture seule.</span><span class="sxs-lookup"><span data-stu-id="5c200-201">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="5c200-202">Le fait de permettre à un utilisateur de définir une valeur et l'empêcher ensuite de la consulter n'offre aucune garantie de sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c200-202">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="5c200-203">De plus, sans accès en lecture, l'état des objets partagés ne peut s'afficher, ce qui limite leur utilité.</span><span class="sxs-lookup"><span data-stu-id="5c200-203">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
| [<span data-ttu-id="5c200-204">CA1045 : Ne pas passer de types par référence</span><span class="sxs-lookup"><span data-stu-id="5c200-204">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="5c200-205">Passer des types par référence (en utilisant out ou ref) nécessite une certaine expérience des pointeurs, de comprendre la différence entre les types valeur et les types référence, ainsi que la gestion de méthodes impliquant plusieurs valeurs de retour.</span><span class="sxs-lookup"><span data-stu-id="5c200-205">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="5c200-206">Les architectes de bibliothèques qui réalisent un travail de conception destiné à une audience générale ne doivent pas s'attendre à ce que les utilisateurs maîtrisent l'utilisation des paramètres out ou ref.</span><span class="sxs-lookup"><span data-stu-id="5c200-206">Library architects who design for a general audience should not expect users to master working with out or ref parameters.</span></span> |
| [<span data-ttu-id="5c200-207">CA1046 : Ne pas surcharger l'opérateur égal à sur les types référence</span><span class="sxs-lookup"><span data-stu-id="5c200-207">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="5c200-208">Pour les types référence, l'implémentation par défaut de l'opérateur d'égalité est presque toujours correcte.</span><span class="sxs-lookup"><span data-stu-id="5c200-208">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="5c200-209">Par défaut, deux références sont égales uniquement si elles pointent sur le même objet.</span><span class="sxs-lookup"><span data-stu-id="5c200-209">By default, two references are equal only if they point to the same object.</span></span> |
| [<span data-ttu-id="5c200-210">CA1047 : Ne pas déclarer les membres protégés dans les types sealed</span><span class="sxs-lookup"><span data-stu-id="5c200-210">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="5c200-211">Les types déclarent des membres protégés afin que des types qui héritent puissent accéder au membre ou le substituer.</span><span class="sxs-lookup"><span data-stu-id="5c200-211">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="5c200-212">Par définition, les types sealed ne peuvent pas être hérités, ce qui signifie que les méthodes protégées sur les types sealed ne peuvent pas être appelées.</span><span class="sxs-lookup"><span data-stu-id="5c200-212">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
| [<span data-ttu-id="5c200-213">CA1050 : Déclarer les types dans des espaces de noms</span><span class="sxs-lookup"><span data-stu-id="5c200-213">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="5c200-214">Les types sont déclarés au sein d'espaces de noms pour empêcher des collisions de dénomination, ainsi qu'en guise que méthode d'organisation de types connexes au sein d'une hiérarchie d'objets.</span><span class="sxs-lookup"><span data-stu-id="5c200-214">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
| [<span data-ttu-id="5c200-215">CA1051 : Ne pas déclarer de champs d'instances visibles</span><span class="sxs-lookup"><span data-stu-id="5c200-215">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="5c200-216">Un champ s'utilise principalement en tant que détail d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="5c200-216">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="5c200-217">Les champs doivent être privés ou internes, et doivent être exposés au moyen de propriétés.</span><span class="sxs-lookup"><span data-stu-id="5c200-217">Fields should be private or internal and should be exposed by using properties.</span></span> |
| [<span data-ttu-id="5c200-218">CA1052 : Les types de conteneurs statiques doivent être sealed</span><span class="sxs-lookup"><span data-stu-id="5c200-218">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="5c200-219">Un type public ou protégé contient uniquement des membres statiques et n’est pas déclaré à l’aide du modificateur sealed (C#) ou NotInheritable (Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="5c200-219">A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier.</span></span> <span data-ttu-id="5c200-220">Un type qui n'est pas destiné à être hérité doit être marqué avec le modificateur sealed pour empêcher son utilisation en tant que type de base.</span><span class="sxs-lookup"><span data-stu-id="5c200-220">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
| [<span data-ttu-id="5c200-221">CA1053 : Les types de conteneurs statiques ne doivent pas comporter de constructeur</span><span class="sxs-lookup"><span data-stu-id="5c200-221">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="5c200-222">Un type public ou imbriqué déclare uniquement des membres statiques et dispose d'un constructeur par défaut public ou protégé.</span><span class="sxs-lookup"><span data-stu-id="5c200-222">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="5c200-223">Le constructeur est inutile car l'appel à des membres statiques ne requiert aucune instance du type.</span><span class="sxs-lookup"><span data-stu-id="5c200-223">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="5c200-224">La surcharge de chaîne doit appeler la surcharge d'URI (Uniform Resource Identifier) à l'aide de l'argument de chaîne pour des raisons de sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c200-224">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
| [<span data-ttu-id="5c200-225">CA1054 : Les paramètres URI ne doivent pas être des chaînes</span><span class="sxs-lookup"><span data-stu-id="5c200-225">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="5c200-226">Si une méthode accepte une représentation sous forme de chaîne d'un URI, une surcharge correspondante qui accepte une instance de la classe URI doit être fournie ; elle-même fournit ces services de manière sûre et sécurisée.</span><span class="sxs-lookup"><span data-stu-id="5c200-226">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="5c200-227">CA1055 : Les valeurs de retour URI ne doivent pas être des chaînes</span><span class="sxs-lookup"><span data-stu-id="5c200-227">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="5c200-228">Cette règle considère que la méthode retourne un URI.</span><span class="sxs-lookup"><span data-stu-id="5c200-228">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="5c200-229">Une représentation sous forme de chaîne d'un URI est sujette aux erreurs d'analyse et d'encodage, et peut entraîner des failles de sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c200-229">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="5c200-230">La classe System.Uri fournit ces services de manière sûre et sécurisée.</span><span class="sxs-lookup"><span data-stu-id="5c200-230">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="5c200-231">CA1056 : Les propriétés URI ne doivent pas être des chaînes</span><span class="sxs-lookup"><span data-stu-id="5c200-231">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="5c200-232">Cette règle suppose que la propriété représente un URI.</span><span class="sxs-lookup"><span data-stu-id="5c200-232">This rule assumes that the property represents a URI.</span></span> <span data-ttu-id="5c200-233">Une représentation sous forme de chaîne d'un URI est sujette aux erreurs d'analyse et d'encodage, et peut entraîner des failles de sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c200-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="5c200-234">La classe System.Uri fournit ces services de manière sûre et sécurisée.</span><span class="sxs-lookup"><span data-stu-id="5c200-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="5c200-235">CA1058 : Les types ne doivent pas étendre certains types de base</span><span class="sxs-lookup"><span data-stu-id="5c200-235">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="5c200-236">Un type visible de l'extérieur étend certains types de base.</span><span class="sxs-lookup"><span data-stu-id="5c200-236">An externally visible type extends certain base types.</span></span> <span data-ttu-id="5c200-237">Utilisez l'une des solutions de remplacement.</span><span class="sxs-lookup"><span data-stu-id="5c200-237">Use one of the alternatives.</span></span> |
| [<span data-ttu-id="5c200-238">CA1060 : déplacer les P/Invoke vers une classe NativeMethods</span><span class="sxs-lookup"><span data-stu-id="5c200-238">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="5c200-239">Les méthodes d’appel de plateforme, telles que celles marquées avec les <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> méthodes ou définies à l’aide du mot clé Declare dans Visual Basic, accèdent au code non managé.</span><span class="sxs-lookup"><span data-stu-id="5c200-239">Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="5c200-240">Ces méthodes doivent être de la classe NativeMethods, SafeNativeMethods ou UnsafeNativeMethods.</span><span class="sxs-lookup"><span data-stu-id="5c200-240">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
| [<span data-ttu-id="5c200-241">CA1061 : Ne pas masquer les méthodes de la classe de base</span><span class="sxs-lookup"><span data-stu-id="5c200-241">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="5c200-242">Une méthode dans un type de base est masquée par une méthode portant le même nom dans un type dérivé, lorsque la signature de paramètre de la méthode dérivée diffère uniquement par les types qui sont dérivés plus faiblement que les types correspondants dans la signature de paramètre de la méthode de base.</span><span class="sxs-lookup"><span data-stu-id="5c200-242">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
| [<span data-ttu-id="5c200-243">CA1062 : Valider les arguments de méthodes publiques</span><span class="sxs-lookup"><span data-stu-id="5c200-243">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="5c200-244">Tous les arguments de référence passés aux méthodes visibles de l'extérieur doivent être vérifiés pour voir s'ils ont la valeur null.</span><span class="sxs-lookup"><span data-stu-id="5c200-244">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
| [<span data-ttu-id="5c200-245">CA1063 : Implémenter IDisposable correctement</span><span class="sxs-lookup"><span data-stu-id="5c200-245">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="5c200-246">Tous les types IDisposable doivent implémenter le modèle Dispose correctement.</span><span class="sxs-lookup"><span data-stu-id="5c200-246">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
| [<span data-ttu-id="5c200-247">CA1064 : Les exceptions doivent être publiques</span><span class="sxs-lookup"><span data-stu-id="5c200-247">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="5c200-248">Une exception interne est uniquement visible à l'intérieur de sa propre portée interne.</span><span class="sxs-lookup"><span data-stu-id="5c200-248">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="5c200-249">Lorsque l'exception se situe en dehors de la portée interne, seule l'exception de base peut être utilisée pour intercepter l'exception.</span><span class="sxs-lookup"><span data-stu-id="5c200-249">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="5c200-250">Si l’exception interne est héritée de <xref:System.Exception?displayProperty=fullName> , <xref:System.SystemException?displayProperty=fullName> ou <xref:System.ApplicationException?displayProperty=fullName> , le code externe ne disposera pas d’informations suffisantes pour savoir ce qu’il faut faire avec l’exception.</span><span class="sxs-lookup"><span data-stu-id="5c200-250">If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
| [<span data-ttu-id="5c200-251">CA1065 : Ne pas lever d'exceptions dans les emplacements inattendus</span><span class="sxs-lookup"><span data-stu-id="5c200-251">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="5c200-252">Une méthode dont l'objet n'est pas de lever des exceptions lève une exception.</span><span class="sxs-lookup"><span data-stu-id="5c200-252">A method that is not expected to throw exceptions throws an exception.</span></span> |
| [<span data-ttu-id="5c200-253">CA1066 : Implémenter IEquatable au moment de remplacer Equals</span><span class="sxs-lookup"><span data-stu-id="5c200-253">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="5c200-254">Un type valeur substitue la <xref:System.Object.Equals%2A> méthode, mais n’implémente pas <xref:System.IEquatable%601> .</span><span class="sxs-lookup"><span data-stu-id="5c200-254">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
| [<span data-ttu-id="5c200-255">CA1067: Remplacer Equals lors de l’implémentation d’IEquatable</span><span class="sxs-lookup"><span data-stu-id="5c200-255">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="5c200-256">Un type implémente <xref:System.IEquatable%601> , mais ne se substitue pas à la <xref:System.Object.Equals%2A> méthode.</span><span class="sxs-lookup"><span data-stu-id="5c200-256">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
| [<span data-ttu-id="5c200-257">CA1068 : Les paramètres CancellationToken doivent venir en dernier</span><span class="sxs-lookup"><span data-stu-id="5c200-257">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="5c200-258">Une méthode a un paramètre CancellationToken qui n’est pas le dernier paramètre.</span><span class="sxs-lookup"><span data-stu-id="5c200-258">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
| [<span data-ttu-id="5c200-259">CA1069 : Les enums ne doivent pas avoir de valeurs en double</span><span class="sxs-lookup"><span data-stu-id="5c200-259">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="5c200-260">Une énumération a plusieurs membres auxquels la même valeur de constante est affectée explicitement.</span><span class="sxs-lookup"><span data-stu-id="5c200-260">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
| [<span data-ttu-id="5c200-261">CA1070 : Ne pas déclarer de champs d’événement comme virtuels</span><span class="sxs-lookup"><span data-stu-id="5c200-261">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="5c200-262">Un [événement de type champ](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) a été déclaré comme étant virtuel.</span><span class="sxs-lookup"><span data-stu-id="5c200-262">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
| [<span data-ttu-id="5c200-263">CA1071 : remplacement de la base. Égal à lors de l’implémentation de IEquatable</span><span class="sxs-lookup"><span data-stu-id="5c200-263">CA1071: Override base.Equals when implementing IEquatable</span></span>](ca1071.md) | <span data-ttu-id="5c200-264">Un type dérivé implémente <xref:System.IEquatable%601> , mais ne se substitue pas à la méthode de la classe de base <xref:System.IEquatable%601.Equals%2A> .</span><span class="sxs-lookup"><span data-stu-id="5c200-264">A derived type implements <xref:System.IEquatable%601>, but does not override the base class <xref:System.IEquatable%601.Equals%2A> method.</span></span> |
