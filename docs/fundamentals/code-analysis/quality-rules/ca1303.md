---
title: 'CA1303 : ne pas passer de littéraux en tant que paramètres localisés (analyse du code)'
description: 'En savoir plus sur la règle d’analyse du code CA1303 : ne pas passer de littéraux en tant que paramètres localisés'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Do not pass literals as localized parameters
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
helpviewer_keywords:
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
author: gewarren
ms.author: gewarren
dev_langs:
- CSharp
- VB
ms.openlocfilehash: 1c8c1491a3a279fae98262fb8102bf0b1cb130d4
ms.sourcegitcommit: a6bd4cad438fe479cbd112eae10f2cd449f06e40
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/08/2020
ms.locfileid: "96587934"
---
# <a name="ca1303-do-not-pass-literals-as-localized-parameters"></a>CA1303 : Ne pas passer de littéraux en paramètres localisés

| | Valeur |
|-|-|
| **Identificateur de la règle** |CA1303|
| **Catégorie** |Microsoft. Globalization|
| **Correction en rupture ou sans rupture** |Sans rupture|

## <a name="cause"></a>Cause

Une méthode passe un littéral de chaîne en tant que paramètre à un constructeur .NET ou une méthode et cette chaîne doit être localisable.

Cet avertissement est déclenché quand une chaîne littérale est passée en tant que valeur à un paramètre ou une propriété et qu’une ou plusieurs des situations suivantes sont vraies :

- L' <xref:System.ComponentModel.LocalizableAttribute> attribut du paramètre ou de la propriété a la valeur `true` .

- Le nom du paramètre de chaîne passé à une `Console.Write` `Console.WriteLine` méthode ou est `value` ou `format` .

- La règle est configurée pour [utiliser l’heuristique d’attribution de noms](#use-naming-heuristic), et un paramètre ou un nom de propriété contient `Text` , `Message` ou `Caption` .

Par défaut, cette règle analyse l’ensemble du code base, mais il peut être [configuré](#excluded-type-names-with-derived-types).

## <a name="rule-description"></a>Description de la règle

Les littéraux de chaîne incorporés dans le code source sont difficiles à localiser.

## <a name="how-to-fix-violations"></a>Comment corriger les violations

Pour corriger une violation de cette règle, remplacez le littéral de chaîne par une chaîne récupérée par le biais d’une instance de la <xref:System.Resources.ResourceManager> classe.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Il est possible de supprimer sans risque un avertissement de cette règle si la bibliothèque de code n’est pas localisée ou si la chaîne n’est pas exposée à l’utilisateur final ou à un développeur à l’aide de la bibliothèque de code.

Les utilisateurs peuvent éliminer le bruit sur les méthodes qui ne doivent pas être passées aux chaînes localisées en renommant le paramètre ou la propriété, ou en marquant ces éléments comme conditionnels.

## <a name="configurability"></a>Configurabilité

Cette règle comporte les options configurables suivantes.

### <a name="excluded-type-names-with-derived-types"></a>Noms de types exclus avec des types dérivés

Vous pouvez configurer les types, y compris ses types dérivés, à exclure de l’analyse. Par exemple, pour spécifier que la règle ne doit pas s’exécuter sur les méthodes dans les types nommés `MyType` et ses types dérivés, ajoutez la paire clé-valeur suivante à un fichier *. editorconfig* dans votre projet :

```ini
dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType
```

Formats de noms de symboles autorisés dans la valeur de l’option (séparés par `|` ) :

- Nom de type uniquement (comprend tous les types portant le nom, quel que soit le type ou l’espace de noms conteneur)
- Noms qualifiés complets dans le format d' [ID de documentation](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)du symbole, avec un `T:` préfixe facultatif.

Exemples :

| Valeur d’option | Résumé |
| --- | --- |
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType` | Met en correspondance tous les types nommés’MyType’et tous ses types dérivés dans la compilation
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType1|MyType2` | Correspond à tous les types nommés’MyType1 'ou’MyType2 'et tous leurs types dérivés dans la compilation
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS.MyType` | Correspond au type spécifique’MyType’avec le nom qualifié complet donné et tous ses types dérivés
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS1.MyType1|M:NS2.MyType2` | Met en correspondance les types spécifiques’MyType1 'et’MyType2 'avec les noms qualifiés complets respectifs et tous leurs types dérivés

Vous pouvez configurer cette option uniquement pour cette règle, pour toutes les règles ou pour toutes les règles de cette catégorie (globalisation). Pour plus d’informations, consultez Options de configuration d’une [règle de qualité du code](../code-quality-rule-options.md).

### <a name="use-naming-heuristic"></a>Utiliser l’heuristique d’appellation

Vous pouvez configurer si des paramètres ou des noms de propriétés contenant `Text` , `Message` ou `Caption` déclencheront cette règle.

```ini
dotnet_code_quality.CA1303.use_naming_heuristic = true
```

## <a name="example"></a> Exemple

L’exemple suivant montre une méthode qui écrit dans la console lorsque l’un de ses deux arguments est hors limites. Pour la `hour` vérification de l’argument, une chaîne littérale est transmise à `Console.WriteLine` , ce qui viole cette règle. Pour la `minute` vérification de l’argument, une chaîne récupérée via un <xref:System.Resources.ResourceManager> est passée à `Console.WriteLine` , qui satisfait la règle.

:::code language="vb" source="snippets/vb/all-rules/ca1303-do-not-pass-literals-as-localized-parameters_1.vb":::

:::code language="csharp" source="snippets/csharp/all-rules/ca1303.cs" id="snippet1":::

## <a name="see-also"></a>Voir aussi

- [Ressources dans des applications de bureau](../../../framework/resources/index.md)
- [Demande de modification de comportement de la communauté](https://github.com/dotnet/roslyn-analyzers/issues/2933)
